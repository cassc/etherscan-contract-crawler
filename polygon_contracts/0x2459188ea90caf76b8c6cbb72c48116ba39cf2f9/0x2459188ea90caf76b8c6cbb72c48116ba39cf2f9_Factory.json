{"SourceCode": "// SPDX-License-Identifier: None\r\npragma solidity ^0.8.14;\r\n\r\n// @openzepplin/contracts/utils/Strings\r\n// License: MIT\r\nlibrary Utils {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n    \r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n}\r\n\r\n// @openzepplin/contracts/token/ERC20/IERC20\r\n// License: MIT\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n/**\r\n* @title Squid Contract Factory.\r\n* @author Dream Kollab.\r\n* @notice You can use this factory to create and interface with squids.\r\n* @dev All function calls are currently implemented without side effects.\r\n* @custom:developer Etienne Cellier-Clarke.\r\n*/\r\ncontract Factory {\r\n\r\n    address payable private owner;\r\n    address private manager;\r\n\r\n    uint public creation_fee;\r\n    uint public transaction_fee;\r\n    uint public id_counter;\r\n\r\n    mapping(uint => Squid) private squids;\r\n    mapping(address => uint) private squid_ids;\r\n    mapping(address => uint[]) private asoc_squids;\r\n    mapping(address => uint[]) private created_squids;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Error: 1000\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyManagement {\r\n        require(msg.sender == owner || msg.sender == manager, \"Error: 1000\");\r\n        _;\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    constructor() {\r\n        owner = payable(msg.sender);\r\n        manager = msg.sender;\r\n        creation_fee = 10000000000000000; // Wei\r\n        transaction_fee = 1000000; // Fraction of 100000000\r\n        id_counter = 5457;\r\n    }\r\n\r\n    /**\r\n    * @notice Use this method to create a new Squid smart contract.\r\n    * @param _name Name of the contract.\r\n    * @param _description Description of the contract.\r\n    * @param _payees Array of addresses\r\n    * @param _shares Array of integers which define how much each address owns.\r\n    */\r\n    function create(\r\n        string memory _name,\r\n        string memory _description,\r\n        address[] memory _payees,\r\n        uint[] memory _shares\r\n    ) external payable {\r\n\r\n        uint id = ++id_counter;\r\n\r\n        require(!exists(id), 'Error: 1001');\r\n        require(msg.value >= creation_fee, 'Error: 1002');\r\n        require(bytes(_name).length <= 20, 'Error: 1003');\r\n        require(bytes(_description).length <= 50, 'Error: 1003');\r\n        require(_payees.length == _shares.length, 'Error: 1004');\r\n\r\n        // Calc total shares within contract\r\n        uint total_shares;\r\n        for(uint16 i = 0; i < _shares.length; i++) {\r\n            total_shares += _shares[i];\r\n        }\r\n\r\n        // Not allowed more than one trillion shares total\r\n        require(total_shares <= 1000000000000, 'Error: 1005');\r\n\r\n        // Create new Squid contract\r\n        squids[id] = new Squid(\r\n            _name,\r\n            _description,\r\n            _payees,\r\n            _shares,\r\n            total_shares,\r\n            transaction_fee,\r\n            msg.sender,\r\n            address(this)\r\n        );\r\n\r\n        // Log squid creator and payees\r\n        for(uint16 i = 0; i < _payees.length; i++) {\r\n            asoc_squids[_payees[i]].push(id);\r\n        }\r\n\r\n        created_squids[msg.sender].push(id);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Retrieve all data (except shareholders) about a specific Squid.\r\n    * @param _id UUID used to identify which squid to access.\r\n    * @param _account Address of payee.\r\n    * @return result An array of strings which contains the collated data.\r\n    */\r\n    function getShareData(uint _id, address _account) public view returns (string[] memory) {\r\n        string[] memory result;\r\n        if(!exists(_id)) { return result; }\r\n        return squids[_id].getData(_account);\r\n    }\r\n\r\n    /**\r\n    * @notice Allows the retrieval of all UUIDs associated with an address\r\n    * where the address is a payee of a squid.\r\n    * @param _account Address of account to retrieve UUIDs for.\r\n    * @return UUIDs An array of UUIDs.\r\n    */\r\n    function getIds(address _account) public view returns (uint[] memory) {\r\n        return asoc_squids[_account];\r\n    }\r\n\r\n    /**\r\n    * @notice Allows the retrieval of all UUIDs associated with an address\r\n    * where the address is a creator of a Squid.\r\n    * @param _account Address of account to retrieve UUIDs for.\r\n    * @return UUIDs An array of UUIDs.\r\n    */\r\n    function getCreatedIds(address _account) public view returns (uint[] memory) {\r\n        return created_squids[_account];\r\n    }\r\n\r\n    /**\r\n    * @notice Retrieves all shareholders and their number of assigned shares.\r\n    * @param _id UUID of a Squid.\r\n    * @return shareholders An array containing each address and associated shares\r\n    * founnd within a Squid. \r\n    */\r\n    function getShareholders(uint _id) public view returns (string[] memory) {\r\n        return squids[_id].getShareholders();\r\n    }\r\n\r\n    /**\r\n    * @notice The owner of the contract factory can set a new owner.\r\n    */\r\n    function changeOwner(address _account) onlyOwner public {\r\n        owner = payable(_account);\r\n    }\r\n\r\n    /**\r\n    * @notice The owner of the contract factory can set a new manager.\r\n    */\r\n    function changeManager(address _account) onlyOwner public {\r\n        manager = _account;\r\n    }\r\n\r\n    /**\r\n    * @notice Allows only the contract owner to change the creation fee\r\n    * as long as the new fee is not less than 0.\r\n    * @param _fee The new fee value which will be used henceforth.\r\n    */\r\n    function changeCreationFee(uint _fee) onlyOwner public {\r\n        require(_fee >= 0, 'Error: 1006');\r\n        creation_fee = _fee;\r\n    }\r\n\r\n    /**\r\n    * @notice Allows only the contract owner to change the transaction fee\r\n    * as long as the new fee is not less than 0. When a fee is changed it will\r\n    * only apply to new squids that are created.\r\n    * @param _fee The new fee value which will be used henceforth.\r\n    */\r\n    function changeTransactionFee(uint _fee) onlyOwner public {\r\n        require(_fee >= 0, 'Error: 1006');\r\n        transaction_fee = _fee;\r\n    }\r\n\r\n    /**\r\n    * @notice The owner of the contract can release accumulated fees to their wallet.\r\n    * @param _token Smart contract address for token when releasing ERC-20 Tokens.\r\n    * @param _matic Boolean where true is to handle matic, and false is to\r\n    * handle other tokens.\r\n    */\r\n    function releaseFunds(IERC20 _token, bool _matic) onlyOwner public {\r\n        if(!_matic) {\r\n            _token.transfer(owner, _token.balanceOf(address(this)));\r\n        } else {\r\n            owner.transfer(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Owner and assigned manager can enter an array of ids to initiate global\r\n    * payouts. If an ID does not exist it will be skipped.\r\n    * @param _ids Array of UUIDS\r\n    * @param _token Smart contract address for token when releasing ERC-20 Tokens.\r\n    * @param _matic Boolean where true is to handle matic, and false is to\r\n    * handle other tokens.\r\n    */\r\n    function flush(uint[] memory _ids, IERC20 _token, bool _matic) onlyManagement public {\r\n        for(uint i = 0; i < _ids.length; i++) {\r\n            if(!exists(_ids[i])) { continue; }\r\n            if(!_matic) {\r\n                squids[_ids[i]].payoutAllTokenized(_token);\r\n            } else {\r\n                squids[_ids[i]].payoutAll();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Locks a squid, meaning it can no longer recieve or release funds.\r\n    * @param _id UUID of a squid.\r\n    * @param _state True to lock, False to unlock.\r\n    */\r\n    function lock(uint _id, bool _state) onlyOwner public {\r\n        squids[_id].lock(_state);\r\n    }\r\n\r\n    /**\r\n    * @notice Allows a payee to withdraw available funds from a squid.\r\n    * @param _id UUID of a squid.\r\n    */\r\n    function payout(uint _id) external {\r\n        squids[_id].payout(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Allows the creator of a squid to release the funds to all payees.\r\n    * @param _id UUID of a squid.\r\n    * @param _token Smart contract address for token when releasing ERC-20 Tokens.\r\n    * @param _matic Boolean where true is to handle matic, and false is to\r\n    * handle other tokens.\r\n    */\r\n    function payoutAll(uint _id, IERC20 _token, bool _matic) external {\r\n        require(squids[_id].getCreator() == msg.sender, 'Error: 1011');\r\n        if(!_matic) {\r\n            squids[_id].payoutAllTokenized(_token);\r\n        } else {\r\n            squids[_id].payoutAll();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Checks whether a unique universal identifier already exists.\r\n    * @param _id UUID to be checked.\r\n    * @return bool true if UUID exists, false if not.\r\n    */\r\n    function exists(uint _id) private view returns (bool) {\r\n        if(address(squids[_id]) != address(0)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n/**\r\n* @title Squid Smart Contract.\r\n* @author Dream Kollab.\r\n* @notice A Squid is a collection of crypto addresses each with an assigned number of shares.\r\n* Once a Squid has been created it can no longer be modified and all share values are fixed.\r\n* If a payee wants to withdraw any monies from the Squid they can only withdraw the amount\r\n* they are entitled to which is determined by the amount of shares they have been allocated.\r\n* The creator of the Squid has the ability to flush the contract and all payees will be\r\n* transferred their share of any monies remaining.\r\n* @dev All function calls are currently implemented without side effects.\r\n* @custom:developer Etienne Cellier-Clarke.\r\n*/\r\ncontract Squid {\r\n\r\n    address factory;\r\n    address creator;\r\n\r\n    string name;\r\n    string description;\r\n\r\n    bool locked;\r\n\r\n    uint total_shares = 0;\r\n    uint total_revenue = 0;\r\n    uint fee;\r\n\r\n    address[] payees;\r\n    mapping(address => uint) shareholders;\r\n\r\n    mapping(address => uint) total_released;\r\n    mapping(address => uint) last_withdrawl;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _description,\r\n        address[] memory _payees,\r\n        uint[] memory _shares,\r\n        uint _total_shares,\r\n        uint _fee,\r\n        address _creator,\r\n        address _factory\r\n    ) {\r\n        name = _name;\r\n        description = _description;\r\n        total_shares = _total_shares;\r\n        payees = _payees;\r\n        fee = _fee;\r\n        creator = _creator;\r\n        factory = _factory;\r\n\r\n        locked = false;\r\n\r\n        for(uint16 i = 0; i < _payees.length; i++) {\r\n            shareholders[_payees[i]] = _shares[i];\r\n        }\r\n    }\r\n\r\n    fallback() external payable {\r\n        require(!locked, \"Error: 1015\");\r\n        uint transaction_fee = ( msg.value / 100000000 ) * fee;\r\n        total_revenue = total_revenue + msg.value - transaction_fee;\r\n        payable(factory).transfer(transaction_fee);\r\n    }\r\n\r\n    /**\r\n    * @notice Locks a squid, meaning it can no longer recieve or release funds.\r\n    * @param _state True to lock, False to unlock.\r\n    */\r\n    function lock(bool _state) public {\r\n        require(msg.sender == factory, \"Error: 1012\");\r\n        locked = _state;\r\n    }\r\n\r\n    /**\r\n    * @notice Gets squid data.\r\n    * @param _account Address of payee to get data for.\r\n    * @return result An array of strings containing collated data.\r\n    */\r\n    function getData(address _account) public view returns (string[] memory) {\r\n        string[] memory shareData = new string[](10);\r\n        shareData[0] = Utils.toHexString(address(this));\r\n        shareData[1] = name;\r\n        shareData[2] = description;\r\n        shareData[3] = Utils.toString(shareholders[_account]);\r\n        shareData[4] = Utils.toString(total_shares);\r\n        shareData[5] = Utils.toString(getUserBalance(_account));\r\n        shareData[6] = Utils.toString(address(this).balance);\r\n        shareData[7] = Utils.toString(last_withdrawl[_account]);\r\n        shareData[8] = Utils.toHexString(creator);\r\n        if(locked) { shareData[9] = \"true\"; } else { shareData[9] = \"false\"; }\r\n        return shareData;\r\n    }\r\n\r\n    /**\r\n    * @notice Returns creator of the Squid.\r\n    */\r\n    function getCreator() public view returns (address) {\r\n        return creator;\r\n    }\r\n\r\n    /**\r\n    * @notice Calculates available balance within the Squid.\r\n    * @param _payee Address to check balance of.\r\n    * @return balance Remaning balance.\r\n    */\r\n    function getUserBalance(address _payee) private view returns (uint) {\r\n        return ( shareholders[_payee] * total_revenue ) / total_shares - total_released[_payee];\r\n    }\r\n\r\n    /**\r\n    * @notice Checks is a payee is a shareholder within a Squid.\r\n    * @param _payee Address to be checked.\r\n    * @return bool true if payee is a shareholder, false if not.\r\n    */\r\n    function isPayee(address _payee) private view returns (bool) {\r\n        for(uint i = 0; i < payees.length; i++) {\r\n            if(_payee == payees[i]) { return true; }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @notice Retrieves all shareholders and their number of allocated shares\r\n    * within the Squid\r\n    * @return _shareholders An array containing each address and associated shares\r\n    * found within a Squid.\r\n    */\r\n    function getShareholders() public view returns (string[] memory) {\r\n        string[] memory _shareholders = new string[](payees.length * 2);\r\n\r\n        uint j = 0;\r\n        for(uint i = 0; i < payees.length; i++) {\r\n            address _payee = payees[i];\r\n            _shareholders[j] = Utils.toHexString(_payee);\r\n            _shareholders[j + 1] = Utils.toString(shareholders[_payee]);\r\n            j = j + 2;\r\n        }\r\n\r\n        return _shareholders;\r\n    }\r\n\r\n    /**\r\n    * @notice Transfers payee their available balance. Can only be executed\r\n    * by a payee.\r\n    * @param _account Address to send funds.\r\n    */\r\n    function payout(address _account) external {\r\n\r\n        require(msg.sender == factory, 'Error: 1012');\r\n        require(isPayee(_account), 'Error: 1007');\r\n        require(shareholders[_account] > 0, 'Error: 1008');\r\n        require(address(this).balance > 0, 'Error: 1009');\r\n        require(!locked, \"Error: 1015\");\r\n\r\n        uint bal = getUserBalance(_account);\r\n\r\n        require(bal > 0, 'Error: 1010');\r\n\r\n        total_released[_account] += bal;\r\n        last_withdrawl[_account] = block.timestamp;\r\n\r\n        (bool success, bytes memory data) = payable(_account).call{value: bal}(\"\");\r\n        require(success, \"Failed to send\");\r\n    }\r\n\r\n    /**\r\n    * @notice Transfers all payees their available balance. Can only be executed\r\n    * by the creator of the squid.\r\n    */\r\n    function payoutAll() external {\r\n\r\n        require(msg.sender == factory, 'Error: 1012');\r\n        require(address(this).balance > 0, 'Error: 1009');\r\n        require(!locked, \"Error: 1015\");\r\n\r\n        for(uint i = 0; i < payees.length; i++) {\r\n\r\n            address payee = payees[i];\r\n\r\n            if(shareholders[payee] == 0) { continue; }\r\n\r\n            uint bal = getUserBalance(payee);\r\n            if(bal > 0) {\r\n                // Track Data\r\n                total_released[payee] += bal;\r\n                last_withdrawl[payee] = block.timestamp;\r\n\r\n                // Pay\r\n                (bool success, bytes memory data) = payable(payee).call{value: bal}(\"\");\r\n                require(success, \"Failed to send\");\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Transfers all payees their tokens from defined token address. Can only be executed\r\n    * by the creator of the squid.\r\n    * @param _token Smart contract address that handles token transactions\r\n    */\r\n    function payoutAllTokenized(IERC20 _token) external {\r\n        require(msg.sender == factory, 'Error: 1012');\r\n        require(!locked, \"Error: 1015\");\r\n\r\n        uint tokenBalance = _token.balanceOf(address(this));\r\n        uint transaction_fee = ( tokenBalance / 100000000 ) * fee;\r\n        _token.transfer(factory, transaction_fee);\r\n\r\n        uint postFeeTokenBalance = tokenBalance - transaction_fee;\r\n        for(uint i = 0; i < payees.length; i++) {\r\n\r\n            address payee = payees[i];\r\n\r\n            if(shareholders[payee] == 0) { continue; }\r\n\r\n            uint amount = shareholders[payee] * postFeeTokenBalance / total_shares;\r\n            _token.transfer(payee, amount);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"changeCreationFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"changeManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"changeTransactionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"address[]\",\"name\":\"_payees\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_shares\",\"type\":\"uint256[]\"}],\"name\":\"create\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"creation_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_matic\",\"type\":\"bool\"}],\"name\":\"flush\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getCreatedIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getShareData\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getShareholders\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"id_counter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"lock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_matic\",\"type\":\"bool\"}],\"name\":\"payoutAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_matic\",\"type\":\"bool\"}],\"name\":\"releaseFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transaction_fee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Factory", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://13e5d6bcfb9407837863d24fa14295a3e99109ce3a46e65fef5628c5b771d4a9"}