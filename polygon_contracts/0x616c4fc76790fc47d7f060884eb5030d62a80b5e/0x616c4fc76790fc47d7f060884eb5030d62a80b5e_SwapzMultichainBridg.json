{"SourceCode": "/**\r\n *Submitted for verification at BscScan.com on 2022-05-28\r\n*/\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n// File: contracts/Swapz.sol\r\n\r\n\r\n\r\npragma solidity 0.8.8;\r\n\r\n\r\n// This contract is owned by Decentralized Swapz Network\r\n// Decentralized Swapz Network is Mesh network based on Threshold Signature Scheme with 2/3 PoS Consensus. \r\n\r\nabstract contract TokenFactory {\r\n    function create(uint contractType , string memory name, string memory symbol) virtual public returns(address);\r\n} \r\n\r\nabstract contract Token is IERC20 {\r\n    function mint(address _address, uint256 _amount) virtual public;\r\n    function burn(address _address, uint256 _amount) virtual public;\r\n    function setBaseURI(string memory _baseUri) virtual public;\r\n    function transferOwnership(address newAddress) virtual public;\r\n    function tokenType() public virtual returns (uint);\r\n}\r\n\r\nabstract contract FlashReceiver {\r\n    function executeOperation(address token, uint amount, uint fee, bytes calldata params) virtual public;\r\n}\r\n\r\n// Crosschain Liquidity Pool\r\ncontract SwapzMultichainBridge {\r\n    \r\n    TokenFactory public tokenFactory;\r\n\r\n    function changeTokenFactory(address newTokenFactory) public onlyAdmin {\r\n        tokenFactory = TokenFactory(newTokenFactory);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(owner == msg.sender, \"OWNER\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(admin == msg.sender || owner == msg.sender, \"ADMIN\");\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n    address public admin;\r\n\r\n    function transferOwnership(address _address) virtual public onlyOwner() {\r\n        owner = _address;\r\n    }\r\n\r\n    function transferAdmin(address _address) virtual public onlyAdmin() {\r\n        owner = _address;\r\n    }\r\n    \r\n    // Define the token \r\n    constructor() {\r\n        tokenToAllowed[address(0x0)] = true;\r\n        tokenFactory = TokenFactory(0x46f62e61160f89Fb9423C62EC4A43A12AC3aAa2B);\r\n        owner = 0xdF2DAc8147b38bB4BBAf4a626E271a153bBC359F; \r\n        admin = 0xdF2DAc8147b38bB4BBAf4a626E271a153bBC359F;\r\n    }    \r\n    \r\n    uint public airdrop = 1 ether;\r\n\r\n    mapping(bytes => address) public assetToAddress;\r\n    mapping(address => bytes) public addressToAsset;\r\n    mapping(address => bool) public tokenToAllowed;\r\n    mapping(bytes => uint256) public chainFee;\r\n    mapping(bytes => bool) public knownForainTxs;\r\n    \r\n    function setBaseURI(address token, string memory uri) public onlyAdmin {\r\n        Token(token).setBaseURI(uri);\r\n    }\r\n\r\n    function allowSwapToken(address _token, bool _allow) onlyAdmin public {\r\n        tokenToAllowed[_token] = _allow;\r\n    }\r\n    \r\n    function changeChainFee(bytes calldata _chainId, uint _chainFee) public onlyAdmin {\r\n        chainFee[_chainId] = _chainFee;\r\n    }\r\n\r\n    function changeTokenOwner(address _token, address _newOwner) public onlyAdmin {\r\n        Token t = Token(_token);\r\n        t.transferOwnership(_newOwner);\r\n    }\r\n\r\n    function assignTokenToAsset(bytes memory _assetId, address _token) public onlyAdmin {\r\n        assetToAddress[_assetId] = _token;\r\n        addressToAsset[_token] = _assetId;\r\n\r\n    }\r\n\r\n\r\n    function chainAirdrop(uint _airdrop) public onlyAdmin {\r\n        airdrop = _airdrop;\r\n    }\r\n\r\n    function bytesToAddress(bytes memory bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys,20))\r\n        } \r\n    }\r\n\r\n\r\n    function sendAll(address[] calldata keepers, bytes[] calldata tokens, uint[] calldata amounts, bytes[] calldata foreignTx) external onlyOwner {\r\n        \r\n        for (uint i = 0; i < keepers.length; i++) {\r\n\r\n            require(knownForainTxs[foreignTx[i]] == false, \"KNOWN\");\r\n            knownForainTxs[foreignTx[i]] = true;\r\n\r\n            send(keepers[i], tokens[i], amounts[i]);\r\n            \r\n        }\r\n\r\n    }\r\n    \r\n    function send(address keeper, bytes calldata token, uint amount) private {\r\n\r\n        if (token.length == 20) {\r\n            sendNative(keeper, bytesToAddress(token), amount);\r\n        }\r\n        else {\r\n            sendWrapped(keeper, token, amount);\r\n        }\r\n\r\n    }\r\n\r\n    \r\n    function sendWrapped(address keeper, bytes calldata asset, uint256 amount) private {\r\n\r\n            if (assetToAddress[asset] == address(0x0)) {\r\n                \r\n                address token_address = tokenFactory.create(getType(asset), getName(asset), getSymbol(asset));\r\n                \r\n                assetToAddress[asset] = token_address;\r\n                addressToAsset[token_address] = asset;\r\n                allowSwapToken(token_address, true);\r\n\r\n                \r\n                changeChainFee(getChainId(asset), 1 ether);\r\n            }\r\n            \r\n            Token t2 = Token(assetToAddress[asset]);\r\n            t2.mint(keeper, amount); \r\n    \r\n    }\r\n    \r\n    uint public gasLimit = 21000;\r\n\r\n    function chainGasLimit(uint _gasLimit) public onlyAdmin {\r\n        gasLimit = _gasLimit;\r\n    }\r\n\r\n    function transfer(address _to , uint256 value) private {\r\n        _to.call{ value: value, gas: gasLimit }('');\r\n        //payable(_to).transfer(value);\r\n    }\r\n\r\n    function sendNative(address keeper, address token, uint amount) private {\r\n            \r\n        if (token == address(0x0)) {\r\n            \r\n            transfer(keeper, amount);\r\n            //payable(keeper).transfer(amount);\r\n\r\n        } else {\r\n            // the transaction should reverted if not enough balance (each ERC20 should be audited)\r\n            Token(token).transfer(keeper, amount);\r\n\r\n            if (address(this).balance > airdrop) {\r\n                transfer(keeper, airdrop);\r\n                //payable(keeper).transfer(airdrop);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    function flashLoan(uint _amount, address _token, FlashReceiver _receiver, bytes calldata _params) public {\r\n\r\n        uint _fee = _amount / 10000;\r\n        bool isNative = _token == address(0x0);\r\n        Token token = Token(_token);\r\n        address receiver = address(_receiver);\r\n        address sender = address(this);\r\n\r\n        uint256 balanceBefore = isNative ? sender.balance : token.balanceOf(sender);\r\n        require(token.tokenType() == 0, \"ERC20\");\r\n        require(_amount <= balanceBefore, \"BALANCE\");\r\n\r\n        if (isNative) {\r\n            //payable(receiver).transfer(_amount);\r\n            transfer(receiver, _amount);\r\n        }\r\n        else {\r\n            token.transfer(receiver, _amount);\r\n        }\r\n\r\n        _receiver.executeOperation(_token, _amount, _fee, _params);\r\n\r\n        uint256 balanceAfter  = isNative ? sender.balance : token.balanceOf(sender);\r\n\r\n        require(balanceBefore + _fee == balanceAfter, \"RESULT\");\r\n\r\n    }\r\n\r\n    mapping(address => bool) referrals;\r\n\r\n    function setAcceptedReferral(address referral, bool accepted) public onlyAdmin {\r\n        referrals[referral] = accepted;\r\n    }\r\n\r\n    \r\n\r\n    function swapRequestNative(uint _amount, address _token, bytes calldata chainId, address referral) external payable {\r\n        \r\n        uint256 fee = chainFee[chainId];\r\n\r\n        require(tokenToAllowed[_token], \"DISABLED\");\r\n        \r\n        require(fee > 0, \"FEE\");\r\n        \r\n        if (_token == address(0x0)) {\r\n            require(msg.value == fee + _amount, \"AMOUNT\");\r\n        }\r\n        else {\r\n            require(msg.value == fee, \"FEE\");\r\n            // the transaction should reverted if not enough balance (each ERC20 should be audited)\r\n            \r\n            Token(_token).transferFrom(msg.sender, address(this), _amount);\r\n        }\r\n        if (referrals[referral]) {\r\n            uint fee2 = fee / 2;\r\n            //payable(owner).transfer(fee - fee2);\r\n            transfer(owner, fee - fee2);\r\n            //payable(referral).transfer(fee2);\r\n            transfer(referral, fee2);\r\n            \r\n        }\r\n        else {\r\n            //payable(owner).transfer(fee);\r\n            transfer(owner, fee);\r\n        }\r\n        \r\n\r\n        emit CrossSwap(_amount, msg.sender, chainId, _token);\r\n    }\r\n\r\n    // Mash nodes connected to this event\r\n    event CrossSwap ( uint256 value, address recipient, bytes chainIdOrAssetId, address token );\r\n    \r\n    function getName(bytes calldata assetId) public pure returns (string memory) {\r\n        //return \"\";\r\n        bytes memory s = assetId[15:35];\r\n        return string(s);\r\n    } \r\n\r\n    function getSymbol(bytes calldata assetId) public pure returns (string memory) {\r\n        //return \"\";\r\n        bytes memory s = assetId[5:15];\r\n        return string(s);\r\n    } \r\n\r\n    function getType(bytes calldata asset) public pure returns (uint8) {\r\n        return uint8(bytes1(asset[4:6]));\r\n    }\r\n\r\n    function getChainId(bytes calldata assetId) public pure returns (bytes calldata) {\r\n        return assetId[0:4];\r\n    } \r\n\r\n    function swapRequestWrapped(address _token, uint _amount, address referral) external payable {                \r\n        bytes memory chainId = this.getChainId(addressToAsset[_token]);\r\n\r\n        uint256 fee = chainFee[chainId];\r\n\r\n        require(fee > 0, \"CHAIN\");\r\n\r\n        require(msg.value == chainFee[chainId], \"FEE\");\r\n        \r\n        Token(_token).burn(msg.sender, _amount);\r\n\r\n        if (referrals[referral]) {\r\n            uint fee2 = fee / 2;\r\n            transfer(owner, fee - fee2);\r\n            transfer(referral, fee2);\r\n            \r\n            \r\n        }\r\n        else {\r\n            //payable(owner).transfer(fee);\r\n            transfer(owner, fee);\r\n        }\r\n\r\n        emit CrossSwap(_amount, msg.sender, addressToAsset[_token], _token);\r\n    }\r\n    \r\n    // Added to make deposits\r\n    receive() external payable {} \r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"chainIdOrAssetId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"CrossSwap\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToAsset\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdrop\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allow\",\"type\":\"bool\"}],\"name\":\"allowSwapToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"assetToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_assetId\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"assignTokenToAsset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_airdrop\",\"type\":\"uint256\"}],\"name\":\"chainAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"chainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"}],\"name\":\"chainGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_chainId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_chainFee\",\"type\":\"uint256\"}],\"name\":\"changeChainFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTokenFactory\",\"type\":\"address\"}],\"name\":\"changeTokenFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeTokenOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"contract FlashReceiver\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_params\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"assetId\",\"type\":\"bytes\"}],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"assetId\",\"type\":\"bytes\"}],\"name\":\"getName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"assetId\",\"type\":\"bytes\"}],\"name\":\"getSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"asset\",\"type\":\"bytes\"}],\"name\":\"getType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"knownForainTxs\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"keepers\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"tokens\",\"type\":\"bytes[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"foreignTx\",\"type\":\"bytes[]\"}],\"name\":\"sendAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"accepted\",\"type\":\"bool\"}],\"name\":\"setAcceptedReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uri\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"chainId\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"swapRequestNative\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"}],\"name\":\"swapRequestWrapped\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenFactory\",\"outputs\":[{\"internalType\":\"contract TokenFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SwapzMultichainBridge", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://77e5e031e632ffe7b56c6b9e200c748b7a98fe8c83ef6fde3f4e14a646632f72"}