{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/MobulaTokensProtocol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable2Step.sol\\\";\\nimport \\\"@axelar/contracts/executable/AxelarExecutable.sol\\\";\\n\\nimport \\\"./interfaces/IAPI.sol\\\";\\nimport \\\"./interfaces/IERC20Extended.sol\\\";\\n\\nimport \\\"./lib/ProtocolErrors.sol\\\";\\nimport \\\"./lib/TokenStructs.sol\\\";\\nimport \\\"./lib/AxelarStructs.sol\\\";\\n\\ncontract MobulaTokensProtocol is AxelarExecutable, Ownable2Step {\\n\\n    /* Modifiers */\\n    /**\\n     * @dev Modifier to limit function calls to Rank I or higher\\n     */\\n    modifier onlyRanked() {\\n        if (rank[msg.sender] == 0) {\\n            revert InvalidUserRank(rank[msg.sender], 1);\\n        }\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to limit function calls to Rank II\\n     */\\n    modifier onlyRankII() {\\n        if (rank[msg.sender] < 2) {\\n            revert InvalidUserRank(rank[msg.sender], 2);\\n        }\\n        _;\\n    }\\n\\n    /* Protocol variables */\\n    /**\\n     * @dev whitelistedStable Does an ERC20 stablecoin is whitelisted as listing payment\\n     */\\n    mapping(address => bool) public whitelistedStable;\\n\\n    /**\\n     * @dev whitelistedSubmitter Does this user needs to pay for a Token submission\\n     * @dev whitelistedLastSubmit Timestamp last submission\\n     * @dev whitelistedCooldown Minimum time required between two Token submission for whitelisted users\\n     */\\n    mapping(address => bool) public whitelistedSubmitter;\\n    mapping(address => uint256) public whitelistedLastSubmit;\\n    uint256 public whitelistedCooldown;\\n\\n    /**\\n     * @dev submitFloorPrice Minimim price to pay for a listing\\n     */\\n    uint256 public submitFloorPrice;\\n\\n    /**\\n     * @dev whitelistedAxelarContract Does an address on a blockchain is whitelisted\\n     */\\n    mapping(string => mapping(string => bool)) public whitelistedAxelarContract;\\n\\n    /**\\n     * @dev tokenListings All Token Listings\\n     */\\n    TokenListing[] public tokenListings;\\n\\n    /**\\n    * @dev nextTokenId used to track token ID state.\\n     */\\n    uint256 public nextTokenId;\\n\\n    /**\\n     * @dev sortingMaxVotes Maximum votes count for Sorting\\n     * @dev sortingMinAcceptancesPct Minimum % of Acceptances for Sorting\\n     * @dev sortingMinModificationsPct Minimum % of ModificationsNeeded for Sorting\\n     * @dev validationMaxVotes Maximum votes count for Validation\\n     * @dev validationMinAcceptancesPct Minimum % of Acceptances for Validation\\n     * @dev validationMinModificationsPct Minimum % of ModificationsNeeded for Validation\\n     * @dev tokensPerVote Amount of tokens rewarded per vote (* coeff)\\n     */\\n    uint256 public sortingMaxVotes;\\n    uint256 public sortingMinAcceptancesPct;\\n    uint256 public sortingMinModificationsPct;\\n    uint256 public validationMaxVotes;\\n    uint256 public validationMinAcceptancesPct;\\n    uint256 public validationMinModificationsPct;\\n    uint256 public tokensPerVote;\\n\\n    /**\\n     * @dev membersToPromoteToRankI Amount of Rank I promotions available\\n     * @dev membersToPromoteToRankII Amount of Rank II promotions available\\n     * @dev votesNeededToRankIPromotion Amount of votes needed for a Rank I promotion\\n     * @dev votesNeededToRankIIPromotion Amount of votes needed for a Rank II promotion\\n     * @dev membersToDemoteFromRankI Amount of Rank I demotion available\\n     * @dev membersToDemoteFromRankII Amount of Rank II demotion available\\n     * @dev votesNeededToRankIDemotion Amount of votes needed for a Rank I demotion\\n     * @dev votesNeededToRankIIDemotion Amount of votes needed for a Rank II demotion\\n     * @dev voteCooldown Minimum time required between a Token update and a first validation vote\\n     * @dev editCoeffMultiplier Coefficient multiplier for Token update (edit)\\n     */\\n    uint256 public membersToPromoteToRankI;\\n    uint256 public membersToPromoteToRankII;\\n    uint256 public votesNeededToRankIPromotion;\\n    uint256 public votesNeededToRankIIPromotion;\\n    uint256 public membersToDemoteFromRankI;\\n    uint256 public membersToDemoteFromRankII;\\n    uint256 public votesNeededToRankIDemotion;\\n    uint256 public votesNeededToRankIIDemotion;\\n    uint256 public voteCooldown;\\n    uint256 public editCoeffMultiplier;\\n\\n    /**\\n     * @dev rank User rank\\n     * @dev promoteVotes Amount of votes for User promotion\\n     * @dev demoteVotes Amount of votes for User demotion\\n     * @dev goodSortingVotes Amount of User's 'good' first votes\\n     * @dev badSortingVotes Amount of User's 'bad' first votes\\n     * @dev goodValidationVotes Amount of User's 'good' final votes\\n     * @dev badValidationVotes Amount of User's 'bad' final votes\\n     * @dev owedRewards Amount of User's owed rewards\\n     * @dev paidRewards Amount of User's paid rewards\\n     */\\n    mapping(address => uint256) public rank;\\n    mapping(address => uint256) public promoteVotes;\\n    mapping(address => uint256) public demoteVotes;\\n    mapping(address => uint256) public goodSortingVotes;\\n    mapping(address => uint256) public badSortingVotes;\\n    mapping(address => uint256) public goodValidationVotes;\\n    mapping(address => uint256) public badValidationVotes;\\n    mapping(address => uint256) public owedRewards;\\n    mapping(address => uint256) public paidRewards;\\n\\n    /**\\n     * @dev poolListings IDs of listing in Pool state\\n     * @dev updatingListings IDs of listing in Updating state\\n     * @dev sortingListings IDs of listing in Sorting state\\n     * @dev validationListings IDs of listing in Validation state\\n     * @dev validatedListings IDs of listing in Validated state\\n     * @dev rejectedListings IDs of listing in Rejected state\\n     * @dev killedListings IDs of listing in Killed state\\n     */\\n    uint256[] poolListings;\\n    uint256[] updatingListings;\\n    uint256[] sortingListings;\\n    uint256[] validationListings;\\n    uint256[] validatedListings;\\n    uint256[] rejectedListings;\\n    uint256[] killedListings;\\n\\n    /**\\n     * @dev sortingVotesPhase Token's Sorting Users vote phase\\n     * @dev validationVotesPhase Token's Validation Users vote phase\\n     */\\n    mapping(uint256 => mapping(address => uint256)) public sortingVotesPhase;\\n    mapping(uint256 => mapping(address => uint256)) public validationVotesPhase;\\n\\n    /**\\n     * @dev sortingAcceptances Token's Sorting Accept voters\\n     * @dev sortingRejections Token's Sorting Reject voters\\n     * @dev sortingModifications Token's Sorting ModificationsNeeded voters\\n     * @dev validationAcceptances Token's Validation Accept voters\\n     * @dev validationRejections Token's Validation Reject voters\\n     * @dev validationModifications Token's Validation ModificationsNeeded voters\\n     */\\n    mapping(uint256 => address[]) public sortingAcceptances;\\n    mapping(uint256 => address[]) public sortingRejections;\\n    mapping(uint256 => address[]) public sortingModifications;\\n    mapping(uint256 => address[]) public validationAcceptances;\\n    mapping(uint256 => address[]) public validationRejections;\\n    mapping(uint256 => address[]) public validationModifications;\\n    \\n    /**\\n     * @dev PAYMENT_COEFF Payment coefficient\\n     */\\n    uint256 private constant PAYMENT_COEFF = 1000;\\n\\n    /**\\n     * @dev mobulaToken MOBL token address\\n     */\\n    address private mobulaToken;\\n\\n    /**\\n     * @dev protocolAPI API address\\n     */\\n    address public protocolAPI;\\n\\n    /* Events */\\n    event TokenListingSubmitted(address submitter, TokenListing tokenListing);\\n    event TokenDetailsUpdated(Token token);\\n    event TokenListingFunded(address indexed funder, TokenListing tokenListing, uint256 amount);\\n    event RewardsClaimed(address indexed claimer, uint256 amount);\\n    event FundsWithdrawn(address indexed recipient, uint256 amount);\\n    event ERC20FundsWithdrawn(address indexed recipient, address indexed contractAddress, uint256 amount);\\n    event UserPromoted(address indexed promoted, uint256 newRank);\\n    event UserDemoted(address indexed demoted, uint256 newRank);\\n    event ListingStatusUpdated(Token token, ListingStatus previousStatus, ListingStatus newStatus);\\n    event SortingVote(Token token, address voter, ListingVote vote, uint256 utilityScore, uint256 socialScore, uint256 trustScore);\\n    event ValidationVote(Token token, address voter, ListingVote vote, uint256 utilityScore, uint256 socialScore, uint256 trustScore);\\n    event TokenValidated(Token token);\\n\\n    constructor(address gateway_, address _owner, address _mobulaToken) AxelarExecutable(gateway_) {\\n        _transferOwnership(_owner);\\n        mobulaToken = _mobulaToken;\\n    }\\n\\n    /* Getters */\\n\\n    /**\\n     * @dev Retrieve all Token listings\\n     */\\n    function getTokenListings() external view returns (TokenListing[] memory) {\\n        return tokenListings;\\n    }\\n\\n    /**\\n     * @dev Retrieve all Token listings in Sorting status\\n     */\\n    function getSortingTokenListings() external view returns (TokenListing[] memory) {\\n        return getTokenListingsWithStatus(ListingStatus.Sorting);\\n    }\\n\\n    /**\\n     * @dev Retrieve all Token listings in Validation status\\n     */\\n    function getValidationTokenListings() external view returns (TokenListing[] memory) {\\n        return getTokenListingsWithStatus(ListingStatus.Validation);\\n    }\\n\\n    /**\\n     * @dev Retrieve all Token listings in a specific status\\n     * @param status Status of listings to retrieve\\n     */\\n    function getTokenListingsWithStatus(ListingStatus status) public view returns (TokenListing[] memory) {\\n        if (status == ListingStatus.Init) {\\n            return new TokenListing[](0);\\n        }\\n\\n        uint256[] memory voteIds = _getStorageArrayForStatus(status);\\n\\n        TokenListing[] memory listings = new TokenListing[](voteIds.length);\\n        for (uint256 i; i < listings.length; i++) {\\n            listings[i] = tokenListings[voteIds[i]];\\n        }\\n\\n        return listings;\\n    }\\n    \\n    /* Users methods */\\n\\n    /**\\n     * @dev Allows the submitter of a Token to update Token details\\n     * @param voteId ID of the Vote to update\\n     * @param ipfsHash New IPFS hash of the Token\\n     */\\n    function updateToken(uint256 voteId, string memory ipfsHash) external {\\n        _updateToken(voteId, ipfsHash, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Allows a user to submit a Token for validation\\n     * @param ipfsHash IPFS hash of the Token\\n     * @param paymentTokenAddress Address of ERC20 stablecoins used to pay for listing\\n     * @param paymentAmount Amount to be paid (without decimals)\\n     * @param tokenId ID of the Token to update (if update, 0 otherwise)\\n     */\\n    function submitToken(string memory ipfsHash, address paymentTokenAddress, uint256 paymentAmount, uint256 tokenId) external {\\n        _submitToken(ipfsHash, paymentTokenAddress, paymentAmount, msg.sender, tokenId);\\n    }\\n\\n    /**\\n     * @dev Allows a user to top up listing payment\\n     * @param voteId ID of the Vote to top up\\n     * @param paymentTokenAddress Address of ERC20 stablecoins used to pay for listing\\n     * @param paymentAmount Amount to be paid (without decimals)\\n     */\\n    function topUpToken(uint256 voteId, address paymentTokenAddress, uint256 paymentAmount) external {\\n        _topUpToken(voteId, paymentTokenAddress, paymentAmount, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Claim User rewards\\n     * @param user User to claim rewards for\\n     */\\n    function claimRewards(address user) external {\\n        uint256 amountToPay = owedRewards[user] * tokensPerVote;\\n        if (amountToPay == 0) revert NothingToClaim(user);\\n\\n        paidRewards[user] += amountToPay;\\n        delete owedRewards[user];\\n\\n        uint256 moblAmount = amountToPay / PAYMENT_COEFF;\\n\\n        IERC20(mobulaToken).transfer(user, moblAmount);\\n\\n        emit RewardsClaimed(user, moblAmount);\\n    }\\n\\n    /* Votes */\\n\\n    /**\\n     * @dev Allows a ranked user to vote for Token Sorting\\n     * @param voteId ID of the Vote to vote for\\n     * @param vote User's vote\\n     * @param utilityScore Utility score\\n     * @param socialScore Social score\\n     * @param trustScore Trust score\\n     */\\n    function voteSorting(uint256 voteId, ListingVote vote, uint256 utilityScore, uint256 socialScore, uint256 trustScore)\\n        external\\n        onlyRanked\\n    {\\n        if (voteId >= tokenListings.length) revert VoteNotFound(voteId);\\n\\n        TokenListing storage listing = tokenListings[voteId];\\n\\n        if (listing.status != ListingStatus.Sorting) revert NotSortingListing(listing.token, listing.status);\\n\\n        if (listing.token.lastUpdate > block.timestamp - voteCooldown) revert TokenInCooldown(listing.token);\\n\\n        if (sortingVotesPhase[voteId][msg.sender] >= listing.phase) revert AlreadyVoted(msg.sender, listing.status, listing.phase);\\n\\n        sortingVotesPhase[voteId][msg.sender] = listing.phase;\\n\\n        if (vote == ListingVote.ModificationsNeeded) {\\n            sortingModifications[voteId].push(msg.sender);\\n        } else if (vote == ListingVote.Reject) {\\n            sortingRejections[voteId].push(msg.sender);\\n        } else {\\n            if (utilityScore > 5 || socialScore > 5 || trustScore > 5) revert InvalidScoreValue();\\n\\n            sortingAcceptances[voteId].push(msg.sender);\\n\\n            listing.accruedUtilityScore += utilityScore;\\n            listing.accruedSocialScore += socialScore;\\n            listing.accruedTrustScore += trustScore;\\n        }\\n\\n        emit SortingVote(listing.token, msg.sender, vote, utilityScore, socialScore, trustScore);\\n\\n        if (sortingModifications[voteId].length * 100 >= sortingMaxVotes * sortingMinModificationsPct) {\\n            _updateListingStatus(voteId, ListingStatus.Updating);\\n        } else if (sortingAcceptances[voteId].length + sortingRejections[voteId].length + sortingModifications[voteId].length >= sortingMaxVotes) {\\n            if (sortingAcceptances[voteId].length * 100 >= sortingMaxVotes * sortingMinAcceptancesPct) {\\n                _updateListingStatus(voteId, ListingStatus.Validation);\\n            } else {\\n                _updateListingStatus(voteId, ListingStatus.Rejected);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows a rank II User to vote for Token Validation\\n     * @param voteId ID of the Token to vote for\\n     * @param vote User's vote\\n     * @param utilityScore Utility score\\n     * @param socialScore Social score\\n     * @param trustScore Trust score\\n     */\\n    function voteValidation(uint256 voteId, ListingVote vote, uint256 utilityScore, uint256 socialScore, uint256 trustScore)\\n        external\\n        onlyRankII\\n    {\\n        if (voteId >= tokenListings.length) revert VoteNotFound(voteId);\\n\\n        TokenListing storage listing = tokenListings[voteId];\\n\\n        if (listing.status != ListingStatus.Validation) revert NotValidationListing(listing.token, listing.status);\\n\\n        if (validationVotesPhase[voteId][msg.sender] >= listing.phase) revert AlreadyVoted(msg.sender, listing.status, listing.phase);\\n\\n        validationVotesPhase[voteId][msg.sender] = listing.phase;\\n\\n        if (vote == ListingVote.ModificationsNeeded) {\\n            validationModifications[voteId].push(msg.sender);\\n        } else if (vote == ListingVote.Reject) {\\n            validationRejections[voteId].push(msg.sender);\\n        } else {\\n            if (utilityScore > 5 || socialScore > 5 || trustScore > 5) revert InvalidScoreValue();\\n\\n            validationAcceptances[voteId].push(msg.sender);\\n\\n            listing.accruedUtilityScore += utilityScore;\\n            listing.accruedSocialScore += socialScore;\\n            listing.accruedTrustScore += trustScore;\\n        }\\n\\n        emit ValidationVote(listing.token, msg.sender, vote, utilityScore, socialScore, trustScore);\\n\\n        if (validationModifications[voteId].length * 100 >= validationMaxVotes * validationMinModificationsPct) {\\n            _updateListingStatus(voteId, ListingStatus.Updating);\\n        } else if (validationAcceptances[voteId].length + validationRejections[voteId].length + validationModifications[voteId].length >= validationMaxVotes) {\\n            if (validationAcceptances[voteId].length * 100 >= validationMaxVotes * validationMinAcceptancesPct) {\\n                _rewardVoters(voteId, ListingStatus.Validated);\\n\\n                _saveToken(voteId);\\n\\n                _updateListingStatus(voteId, ListingStatus.Validated);\\n            } else {\\n                _rewardVoters(voteId, ListingStatus.Rejected);\\n\\n                _updateListingStatus(voteId, ListingStatus.Rejected);\\n            }\\n        }\\n    }\\n\\n    /* Hierarchy Management */\\n\\n    /**\\n     * @dev Allows a Rank II user to vote for a promotion for a Rank I user or below\\n     * @param promoted Address of the user\\n     */\\n    function promote(address promoted) external onlyRankII {\\n        uint256 rankPromoted = rank[promoted];\\n        if (rankPromoted > 1) revert RankPromotionImpossible(rankPromoted, 1);\\n\\n        if (rankPromoted == 0) {\\n            if (membersToPromoteToRankI == 0) revert NoPromotionYet(1);\\n            ++promoteVotes[promoted];\\n\\n            if (promoteVotes[promoted] == votesNeededToRankIPromotion) {\\n                --membersToPromoteToRankI;\\n                _promote(promoted);\\n            }\\n        } else {\\n            if (membersToPromoteToRankII == 0) revert NoPromotionYet(2);\\n            ++promoteVotes[promoted];\\n\\n            if (promoteVotes[promoted] == votesNeededToRankIIPromotion) {\\n                --membersToPromoteToRankII;\\n                _promote(promoted);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Allows a Rank II user to vote for a demotion for a Rank II user or below\\n     * @param demoted Address of the user\\n     */\\n    function demote(address demoted) external onlyRankII {\\n        uint256 rankDemoted = rank[demoted];\\n        if (rankDemoted == 0) revert RankDemotionImpossible(rankDemoted, 1);\\n\\n        if (rankDemoted == 1) {\\n            if (membersToDemoteFromRankI == 0) revert NoDemotionYet(1);\\n            ++demoteVotes[demoted];\\n\\n            if (demoteVotes[demoted] == votesNeededToRankIDemotion) {\\n                --membersToDemoteFromRankI;\\n                _demote(demoted);\\n            }\\n        } else {\\n            if (membersToDemoteFromRankII == 0) revert NoDemotionYet(2);\\n            ++demoteVotes[demoted];\\n\\n            if (demoteVotes[demoted] == votesNeededToRankIIDemotion) {\\n                --membersToDemoteFromRankII;\\n                _demote(demoted);\\n            }\\n        }\\n    }\\n\\n    /* Emergency Methods */\\n\\n    /**\\n     * @dev Allows the owner to promote a user\\n     * @param promoted Address of the user\\n     */\\n    function emergencyPromote(address promoted) external onlyOwner {\\n        uint256 rankPromoted = rank[promoted];\\n        if (rankPromoted > 1) revert RankPromotionImpossible(rankPromoted, 1);\\n        _promote(promoted);\\n    }\\n\\n    /**\\n     * @dev Allows the owner to demote a user\\n     * @param demoted Address of the user\\n     */\\n    function emergencyDemote(address demoted) external onlyOwner {\\n        uint256 rankDemoted = rank[demoted];\\n        if (rankDemoted == 0) revert RankDemotionImpossible(rankDemoted, 1);\\n        _demote(demoted);\\n    }\\n\\n    /**\\n     * @dev Allows the owner to remove a Token from the validation process\\n     * @param voteId ID of the Token\\n     */\\n    function emergencyKillRequest(uint256 voteId) external onlyOwner {\\n        _updateListingStatus(voteId, ListingStatus.Killed);\\n    }\\n\\n    /**\\n     * @dev Allows the owner to change a Token listing status\\n     * @param voteId ID of the Token\\n     * @param status New status of the listing\\n     */\\n     function emergencyUpdateListingStatus(uint256 voteId, ListingStatus status) external onlyOwner {\\n        _updateListingStatus(voteId, status);\\n    }\\n\\n    /* Protocol Management */\\n\\n    function whitelistStable(address _stableAddress, bool whitelisted) external onlyOwner {\\n        whitelistedStable[_stableAddress] = whitelisted;\\n    }\\n\\n    function whitelistSubmitter(address _submitter, bool whitelisted) external onlyOwner {\\n        whitelistedSubmitter[_submitter] = whitelisted;\\n    }\\n\\n    function whitelistAxelarContract(string memory _sourceChain, string memory _sourceAddress, bool whitelisted) external onlyOwner {\\n        whitelistedAxelarContract[_sourceChain][_sourceAddress] = whitelisted;\\n    }\\n\\n    function updateProtocolAPIAddress(address _protocolAPI) external onlyOwner {\\n        protocolAPI = _protocolAPI;\\n    }\\n\\n    function updateSubmitFloorPrice(uint256 _submitFloorPrice) external onlyOwner {\\n        submitFloorPrice = _submitFloorPrice;\\n    }\\n\\n    function updateSortingMaxVotes(uint256 _sortingMaxVotes) external onlyOwner {\\n        sortingMaxVotes = _sortingMaxVotes;\\n    }\\n\\n    function updateValidationMaxVotes(uint256 _validationMaxVotes)\\n        external\\n        onlyOwner\\n    {\\n        validationMaxVotes = _validationMaxVotes;\\n    }\\n\\n    function updateEditCoeffMultiplier(uint256 _editCoeffMultiplier)\\n        external\\n        onlyOwner\\n    {\\n        editCoeffMultiplier = _editCoeffMultiplier;\\n    }\\n\\n    function updateSortingMinAcceptancesPct(uint256 _sortingMinAcceptancesPct) external onlyOwner {\\n        if (_sortingMinAcceptancesPct > 100) revert InvalidPercentage(_sortingMinAcceptancesPct);\\n        sortingMinAcceptancesPct = _sortingMinAcceptancesPct;\\n    }\\n\\n    function updateSortingMinModificationsPct(uint256 _sortingMinModificationsPct) external onlyOwner {\\n        if (_sortingMinModificationsPct > 100) revert InvalidPercentage(_sortingMinModificationsPct);\\n        sortingMinModificationsPct = _sortingMinModificationsPct;\\n    }\\n\\n    function updateValidationMinAcceptancesPct(uint256 _validationMinAcceptancesPct) external onlyOwner {\\n        if (_validationMinAcceptancesPct > 100) revert InvalidPercentage(_validationMinAcceptancesPct);\\n        validationMinAcceptancesPct = _validationMinAcceptancesPct;\\n    }\\n\\n    function updateValidationMinModificationsPct(uint256 _validationMinModificationsPct) external onlyOwner {\\n        if (_validationMinModificationsPct > 100) revert InvalidPercentage(_validationMinModificationsPct);\\n        validationMinModificationsPct = _validationMinModificationsPct;\\n    }\\n\\n    function updateTokensPerVote(uint256 _tokensPerVote) external onlyOwner {\\n        tokensPerVote = _tokensPerVote;\\n    }\\n\\n    function updateMembersToPromoteToRankI(uint256 _membersToPromoteToRankI)\\n        external\\n        onlyOwner\\n    {\\n        membersToPromoteToRankI = _membersToPromoteToRankI;\\n    }\\n\\n    function updateMembersToPromoteToRankII(uint256 _membersToPromoteToRankII)\\n        external\\n        onlyOwner\\n    {\\n        membersToPromoteToRankII = _membersToPromoteToRankII;\\n    }\\n\\n    function updateMembersToDemoteFromRankI(uint256 _membersToDemoteToRankI)\\n        external\\n        onlyOwner\\n    {\\n        membersToDemoteFromRankI = _membersToDemoteToRankI;\\n    }\\n\\n    function updateMembersToDemoteFromRankII(uint256 _membersToDemoteToRankII)\\n        external\\n        onlyOwner\\n    {\\n        membersToDemoteFromRankII = _membersToDemoteToRankII;\\n    }\\n\\n    function updateVotesNeededToRankIPromotion(\\n        uint256 _votesNeededToRankIPromotion\\n    ) external onlyOwner {\\n        votesNeededToRankIPromotion = _votesNeededToRankIPromotion;\\n    }\\n\\n    function updateVotesNeededToRankIIPromotion(\\n        uint256 _votesNeededToRankIIPromotion\\n    ) external onlyOwner {\\n        votesNeededToRankIIPromotion = _votesNeededToRankIIPromotion;\\n    }\\n\\n    function updateVotesNeededToRankIDemotion(\\n        uint256 _votesNeededToRankIDemotion\\n    ) external onlyOwner {\\n        votesNeededToRankIDemotion = _votesNeededToRankIDemotion;\\n    }\\n\\n    function updateVotesNeededToRankIIDemotion(\\n        uint256 _votesNeededToRankIIDemotion\\n    ) external onlyOwner {\\n        votesNeededToRankIIDemotion = _votesNeededToRankIIDemotion;\\n    }\\n\\n    function updateVoteCooldown(uint256 _voteCooldown) external onlyOwner {\\n        voteCooldown = _voteCooldown;\\n    }\\n\\n    function updateWhitelistedCooldown(uint256 _whitelistedCooldown) external onlyOwner {\\n        whitelistedCooldown = _whitelistedCooldown;\\n    }\\n\\n    /* Funds Management */\\n\\n    /**\\n     * @dev Withdraw ETH amount to recipient\\n     * @param recipient The recipient\\n     * @param amount Amount to withdraw\\n     */\\n    function withdrawFunds(address recipient, uint256 amount) external onlyOwner {\\n        uint256 protocolBalance = address(this).balance;\\n        if (amount > protocolBalance) revert InsufficientProtocolBalance(protocolBalance, amount);\\n\\n        (bool success,) = recipient.call{value: amount}(\\\"\\\");\\n\\n        if (!success) revert ETHTransferFailed(recipient);\\n\\n        emit FundsWithdrawn(recipient, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraw ERC20 amount to recipient\\n     * @param recipient The recipient\\n     * @param amount Amount to withdraw\\n     * @param contractAddress ERC20 address\\n     */\\n    function withdrawERC20Funds(address recipient, uint256 amount, address contractAddress) external onlyOwner {\\n        bool success = IERC20Extended(contractAddress).transfer(recipient, amount);\\n\\n        if (!success) revert ERC20WithdrawFailed(contractAddress, recipient, amount);\\n\\n        emit ERC20FundsWithdrawn(recipient, contractAddress, amount);\\n    }\\n\\n    /* Axelar callback */\\n\\n    /**\\n     * @dev Execute a cross chain call from Axelar\\n     * @param sourceChain Source blockchain\\n     * @param sourceAddress Source smart contract address\\n     * @param payload Payload\\n     */\\n    function _execute(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) internal override {\\n        if (!whitelistedAxelarContract[sourceChain][sourceAddress]) revert InvalidAxelarContract(sourceChain, sourceAddress);\\n\\n        MobulaPayload memory mPayload = abi.decode(payload, (MobulaPayload));\\n        \\n        if (mPayload.method == MobulaMethod.SubmitToken) {\\n            _submitToken(mPayload.ipfsHash, mPayload.paymentTokenAddress, mPayload.paymentAmount, mPayload.sender, mPayload.tokenId);\\n        } else if (mPayload.method == MobulaMethod.UpdateToken) {\\n            _updateToken(mPayload.voteId, mPayload.ipfsHash, mPayload.sender);\\n        } else if (mPayload.method == MobulaMethod.TopUpToken) {\\n            _topUpToken(mPayload.voteId, mPayload.paymentTokenAddress, mPayload.paymentAmount, mPayload.sender);\\n        } else {\\n            revert UnknownMethod(mPayload);\\n        }\\n    }\\n\\n    /* Internal Methods */\\n\\n    /**\\n     * @dev Allows the submitter of a Token to update Token details\\n     * @param voteId ID of the Token to update\\n     * @param ipfsHash New IPFS hash of the Token\\n     * @param sourceMsgSender Sender of the tx\\n     */\\n    function _updateToken(uint256 voteId, string memory ipfsHash, address sourceMsgSender) internal {\\n        if (voteId >= tokenListings.length) revert VoteNotFound(voteId);\\n\\n        TokenListing storage listing = tokenListings[voteId];\\n\\n        if (listing.status != ListingStatus.Updating) revert NotUpdatingListing(listing.token, listing.status);\\n\\n        if (listing.submitter != sourceMsgSender) revert InvalidUpdatingUser(sourceMsgSender, listing.submitter);\\n\\n        listing.token.ipfsHash = ipfsHash;\\n        listing.token.lastUpdate = block.timestamp;\\n\\n        emit TokenDetailsUpdated(listing.token);\\n        \\n        // We put the Vote back to Sorting (impossible to be in Pool status)\\n        _updateListingStatus(voteId, ListingStatus.Sorting);\\n    }\\n    \\n    /**\\n     * @dev Allows a user to submit a Token for validation\\n     * @param ipfsHash IPFS hash of the Token\\n     * @param paymentTokenAddress Address of ERC20 stablecoins used to pay for listing\\n     * @param paymentAmount Amount to be paid (without decimals)\\n     * @param sourceMsgSender Sender of the tx\\n     * @param tokenId ID of the Token to update (if update, 0 otherwise)\\n     */\\n    function _submitToken(string memory ipfsHash, address paymentTokenAddress, uint256 paymentAmount, address sourceMsgSender, uint256 tokenId)\\n        internal\\n    {\\n        uint256 coeff;\\n        ListingStatus status = ListingStatus.Pool;\\n\\n        if (whitelistedSubmitter[sourceMsgSender]) {\\n            if (whitelistedLastSubmit[sourceMsgSender] > block.timestamp - whitelistedCooldown) revert SubmitterInCooldown(sourceMsgSender);\\n            whitelistedLastSubmit[sourceMsgSender] = block.timestamp;\\n\\n            coeff = PAYMENT_COEFF;\\n        } else if (paymentAmount != 0) {\\n            // If method was called from another chain\\n            if (msg.sender != sourceMsgSender) {\\n                coeff = _getCoeff(paymentAmount);\\n            } else {\\n                coeff = _payment(paymentTokenAddress, paymentAmount);\\n            }\\n        }\\n\\n        if (tokenId != 0 && tokenId >= nextTokenId) {\\n            revert TokenNotFound(tokenId);\\n        }\\n\\n        if (tokenId != 0) {\\n            coeff += PAYMENT_COEFF * editCoeffMultiplier;\\n        }\\n\\n        if (coeff >= PAYMENT_COEFF) {\\n            status = ListingStatus.Sorting;\\n        }\\n\\n        Token memory token;\\n        TokenListing memory listing;\\n\\n        token.ipfsHash = ipfsHash;\\n        token.lastUpdate = block.timestamp;\\n        token.id = tokenId != 0 ? tokenId : nextTokenId;\\n\\n        listing.token = token;\\n        listing.coeff = coeff;\\n        listing.submitter = sourceMsgSender;\\n        listing.phase = 1;\\n\\n        tokenListings.push(listing);\\n\\n        // We are working with a new token, so must update.\\n        if (tokenId == 0) nextTokenId += 1;\\n\\n        emit TokenListingSubmitted(sourceMsgSender, listing);\\n        \\n        _updateListingStatus(token.id, status);\\n    }\\n\\n    /**\\n     * @dev Allows a user to top up listing payment\\n     * @param voteId ID of the Vote to top up\\n     * @param paymentTokenAddress Address of ERC20 stablecoins used to pay for listing\\n     * @param paymentAmount Amount to be paid (without decimals)\\n     * @param sourceMsgSender Sender of the tx\\n     */\\n    function _topUpToken(uint256 voteId, address paymentTokenAddress, uint256 paymentAmount, address sourceMsgSender) internal {\\n        if (voteId >= tokenListings.length) revert VoteNotFound(voteId);\\n        if (paymentAmount == 0) revert InvalidPaymentAmount();\\n\\n        // If method was called from another chain\\n        if (msg.sender != sourceMsgSender) {\\n            tokenListings[voteId].coeff += _getCoeff(paymentAmount);\\n        } else {\\n            tokenListings[voteId].coeff += _payment(paymentTokenAddress, paymentAmount);\\n        }\\n\\n        emit TokenListingFunded(sourceMsgSender, tokenListings[voteId], paymentAmount);\\n\\n        if (tokenListings[voteId].status == ListingStatus.Pool && tokenListings[voteId].coeff >= PAYMENT_COEFF) {\\n            _updateListingStatus(voteId, ListingStatus.Sorting);\\n        }\\n    }\\n\\n    /**\\n     * @dev Update the status of a listing, by moving the listing/token index from one status array to another one\\n     * @param voteId ID of the Token to vote for\\n     * @param status New listing status\\n     */\\n    function _updateListingStatus(uint256 voteId, ListingStatus status) internal {\\n        TokenListing storage listing = tokenListings[voteId];\\n\\n        if (status == ListingStatus.Init) revert InvalidStatusUpdate(listing.token, listing.status, status);\\n\\n        if (listing.status != ListingStatus.Init) {\\n            // Can only be updated to Pool status, if current status is Init\\n            if (status == ListingStatus.Pool) revert InvalidStatusUpdate(listing.token, listing.status, status);\\n\\n            // Remove listing from current status array\\n            uint256[] storage fromArray = _getStorageArrayForStatus(listing.status);\\n            uint256 indexMovedListing = fromArray[fromArray.length - 1];\\n            fromArray[listing.statusIndex] = indexMovedListing;\\n            tokenListings[indexMovedListing].statusIndex = listing.statusIndex;\\n            fromArray.pop();\\n        }\\n\\n        // Add listing to new status array\\n        uint256[] storage toArray = _getStorageArrayForStatus(status);\\n        listing.statusIndex = toArray.length;\\n        toArray.push(voteId);\\n\\n        ListingStatus previousStatus = listing.status;\\n        listing.status = status;\\n\\n        // For these status, we need to reset all votes and scores of the listing\\n        if (status == ListingStatus.Updating || status == ListingStatus.Rejected || status == ListingStatus.Validated || status == ListingStatus.Killed) {\\n            // Increment listing phase, so voters will be able to vote again on this listing\\n            if (status == ListingStatus.Updating) {\\n                ++listing.phase;\\n            }\\n\\n            delete listing.accruedUtilityScore;\\n            delete listing.accruedSocialScore;\\n            delete listing.accruedTrustScore;\\n\\n            delete sortingAcceptances[voteId];\\n            delete sortingRejections[voteId];\\n            delete sortingModifications[voteId];\\n            delete validationAcceptances[voteId];\\n            delete validationRejections[voteId];\\n            delete validationModifications[voteId];\\n        }\\n\\n        emit ListingStatusUpdated(listing.token, previousStatus, status);\\n    }\\n\\n    /**\\n     * @dev Retrieve status' corresponding storage array\\n     * @param status Status\\n     */\\n    function _getStorageArrayForStatus(ListingStatus status) internal view returns (uint256[] storage) {\\n        uint256[] storage array = poolListings;\\n        if (status == ListingStatus.Updating) {\\n            array = updatingListings;\\n        } else if (status == ListingStatus.Sorting) {\\n            array = sortingListings;\\n        } else if (status == ListingStatus.Validation) {\\n            array = validationListings;\\n        } else if (status == ListingStatus.Validated) {\\n            array = validatedListings;\\n        } else if (status == ListingStatus.Rejected) {\\n            array = rejectedListings;\\n        } else if (status == ListingStatus.Killed) {\\n            array = killedListings;\\n        }\\n        return array;\\n    }\\n\\n    /**\\n     * @dev Save Token in Protocol API\\n     * @param voteId ID of the Vote to save\\n     */\\n    function _saveToken(uint256 voteId) internal {\\n        TokenListing storage listing = tokenListings[voteId];\\n\\n        uint256 scoresCount = sortingAcceptances[voteId].length + validationAcceptances[voteId].length;\\n\\n        // TODO : Handle float value (x10 then round() / 10 ?)\\n        listing.token.utilityScore = listing.accruedUtilityScore / scoresCount;\\n        listing.token.socialScore = listing.accruedSocialScore / scoresCount;\\n        listing.token.trustScore = listing.accruedTrustScore / scoresCount;\\n        \\n        IAPI(protocolAPI).addAssetData(listing.token);\\n\\n        emit TokenValidated(listing.token);\\n    }\\n\\n    /**\\n     * @dev Reward voters of a Token listing process\\n     * @param voteId ID of the Token\\n     * @param finalStatus Final status of the listing\\n     */\\n    function _rewardVoters(uint256 voteId, ListingStatus finalStatus) internal {\\n        uint256 coeff = tokenListings[voteId].coeff;\\n\\n        for (uint256 i; i < sortingAcceptances[voteId].length; i++) {\\n            if (finalStatus == ListingStatus.Validated) {\\n                ++goodSortingVotes[sortingAcceptances[voteId][i]];\\n                owedRewards[sortingAcceptances[voteId][i]] += coeff;\\n            } else {\\n                ++badSortingVotes[sortingAcceptances[voteId][i]];\\n            }\\n        }\\n        \\n        for (uint256 i; i < sortingRejections[voteId].length; i++) {\\n            if (finalStatus == ListingStatus.Rejected) {\\n                ++goodSortingVotes[sortingRejections[voteId][i]];\\n                owedRewards[sortingRejections[voteId][i]] += coeff;\\n            } else {\\n                ++badSortingVotes[sortingRejections[voteId][i]];\\n            }\\n        }\\n\\n        for (uint256 i; i < validationAcceptances[voteId].length; i++) {\\n            if (finalStatus == ListingStatus.Validated) {\\n                ++goodValidationVotes[validationAcceptances[voteId][i]];\\n                owedRewards[validationAcceptances[voteId][i]] += coeff * 2;\\n            } else {\\n                ++badValidationVotes[validationAcceptances[voteId][i]];\\n            }\\n        }\\n\\n        for (uint256 i; i < validationRejections[voteId].length; i++) {\\n            if (finalStatus == ListingStatus.Rejected) {\\n                ++goodValidationVotes[validationRejections[voteId][i]];\\n                owedRewards[validationRejections[voteId][i]] += coeff * 2;\\n            } else {\\n                ++badValidationVotes[validationRejections[voteId][i]];\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Make the payment from user\\n     * @param paymentTokenAddress Address of ERC20 stablecoins used to pay for listing\\n     * @param paymentAmount Amount to be paid (without decimals)\\n     * @return coeff Coeff to add to the listing\\n     */\\n    function _payment(address paymentTokenAddress, uint256 paymentAmount) internal returns (uint256 coeff) {\\n        if (!whitelistedStable[paymentTokenAddress]) revert InvalidPaymentToken(paymentTokenAddress);\\n\\n        IERC20Extended paymentToken = IERC20Extended(paymentTokenAddress);\\n        uint256 amount = paymentAmount * 10**paymentToken.decimals();\\n        bool success = paymentToken.transferFrom(msg.sender, address(this), amount);\\n\\n        if (!success) revert TokenPaymentFailed(paymentTokenAddress, amount);\\n\\n        coeff = _getCoeff(paymentAmount);\\n    }\\n\\n    /**\\n     * @dev Get the coeff for a payment amount\\n     * @param paymentAmount Amount paid (without decimals)\\n     * @return coeff Coeff to add to the listing\\n     */\\n    function _getCoeff(uint256 paymentAmount) internal view returns (uint256 coeff) {\\n        coeff = (paymentAmount * PAYMENT_COEFF) / submitFloorPrice;\\n    }\\n\\n    /**\\n     * @dev Increase user rank\\n     * @param promoted Address of the user\\n     */\\n    function _promote(address promoted) internal {\\n        delete promoteVotes[promoted];\\n\\n        emit UserPromoted(promoted, ++rank[promoted]);\\n    }\\n\\n    /**\\n     * @dev Decrease user rank\\n     * @param demoted Address of the user\\n     */\\n    function _demote(address demoted) internal {\\n        delete demoteVotes[demoted];\\n\\n        emit UserDemoted(demoted, --rank[demoted]);\\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2Step is Ownable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/executable/AxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from '../interfaces/IAxelarGateway.sol';\\nimport { IAxelarExecutable } from '../interfaces/IAxelarExecutable.sol';\\n\\ncontract AxelarExecutable is IAxelarExecutable {\\n    IAxelarGateway public immutable gateway;\\n\\n    constructor(address gateway_) {\\n        if (gateway_ == address(0)) revert InvalidAddress();\\n\\n        gateway = IAxelarGateway(gateway_);\\n    }\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (!gateway.validateContractCall(commandId, sourceChain, sourceAddress, payloadHash))\\n            revert NotApprovedByGateway();\\n\\n        _execute(sourceChain, sourceAddress, payload);\\n    }\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external {\\n        bytes32 payloadHash = keccak256(payload);\\n\\n        if (\\n            !gateway.validateContractCallAndMint(\\n                commandId,\\n                sourceChain,\\n                sourceAddress,\\n                payloadHash,\\n                tokenSymbol,\\n                amount\\n            )\\n        ) revert NotApprovedByGateway();\\n\\n        _executeWithToken(sourceChain, sourceAddress, payload, tokenSymbol, amount);\\n    }\\n\\n    function _execute(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) internal virtual {}\\n\\n    function _executeWithToken(\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAPI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"../lib/TokenStructs.sol\\\";\\n\\ninterface IAPI {\\n    function addAssetData(Token memory token) external;\\n\\n    function addStaticData(address token, string memory hashString) external;\\n\\n    function staticData(address token)\\n        external\\n        view\\n        returns (string memory hashString);\\n}\"\r\n    },\r\n    \"src/interfaces/IERC20Extended.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IERC20Extended is IERC20 {\\n    function decimals() external view returns (uint8);\\n}\"\r\n    },\r\n    \"src/lib/ProtocolErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"./AxelarStructs.sol\\\";\\nimport \\\"./TokenStructs.sol\\\";\\n\\n// TODO : Add NatSpec + Token to tokenId ?\\n\\nerror AlreadyVoted(address voter, ListingStatus status, uint256 listingPhase);\\nerror InvalidPaymentToken(address paymentToken);\\nerror TokenPaymentFailed(address paymentToken, uint256 amount);\\nerror TokenNotFound(uint256 tokenId);\\nerror VoteNotFound(uint256 voteId);\\nerror InvalidPaymentAmount();\\nerror InvalidUpdatingUser(address sender, address submitter);\\nerror NotSortingListing(Token token, ListingStatus status);\\nerror NotUpdatingListing(Token token, ListingStatus status);\\nerror NotValidationListing(Token token, ListingStatus status);\\nerror TokenInCooldown(Token token);\\nerror SubmitterInCooldown(address submitter);\\nerror InvalidScoreValue();\\nerror InsufficientProtocolBalance(uint256 protocolBalance, uint256 amountToWithdraw);\\nerror NothingToClaim(address claimer);\\nerror ETHTransferFailed(address recipient);\\nerror ERC20WithdrawFailed(address contractAddress, address recipient, uint256 amount);\\nerror InvalidUserRank(uint256 userRank, uint256 minimumRankNeeded);\\nerror RankPromotionImpossible(uint256 userRank, uint256 maxCurrentRank);\\nerror NoPromotionYet(uint256 toRank);\\nerror RankDemotionImpossible(uint256 userRank, uint256 minCurrentRank);\\nerror NoDemotionYet(uint256 fromRank);\\nerror InvalidPercentage(uint256 percentage);\\nerror InvalidStatusUpdate(Token token, ListingStatus currentStatus, ListingStatus targetStatus);\\nerror UnknownMethod(MobulaPayload payload);\\nerror InvalidAxelarContract(string sourceChain, string sourceAddress);\"\r\n    },\r\n    \"src/lib/TokenStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\n/**\\n* @dev Enum to define a listing vote\\n* @custom:Accept Accept the Token\\n* @custom:Reject Reject the Token\\n* @custom:ModificationsNeeded Token needs modifications\\n*/\\nenum ListingVote {\\n    Accept,\\n    Reject,\\n    ModificationsNeeded\\n}\\n\\n/**\\n* @dev Enum to define Listing status\\n* @custom:Init Initial Listing status\\n* @custom:Pool Token has been submitted\\n* @custom:Updating Submitter needs to update Token details\\n* @custom:Sorting RankI users can vote to sort this Token\\n* @custom:Validation RankII users can vote to validate this Token\\n* @custom:Validated Token has been validated and listed\\n* @custom:Rejected Token has been rejected\\n* @custom:Killed Token has been killed by owner\\n*/\\nenum ListingStatus {\\n    Init,\\n    Pool,\\n    Updating,\\n    Sorting,\\n    Validation,\\n    Validated,\\n    Rejected,\\n    Killed\\n}\\n\\n/**\\n * @custom:ipfsHash IPFS Hash of metadatas\\n * @custom:id Attributed ID for the Token\\n * @custom:lastUpdate Timestamp of Token's last update\\n * @custom:utilityScore Token's utility score\\n * @custom:socialScore Token's social score\\n * @custom:trustScore Token's trust score\\n */\\n// TODO : Use uint8 score type ?\\nstruct Token {\\n    string ipfsHash;\\n    uint256 id;\\n    uint256 lastUpdate;\\n    uint256 utilityScore;\\n    uint256 socialScore;\\n    uint256 trustScore;\\n}\\n\\n/**\\n * @custom:token Token\\n * @custom:coeff Listing coeff\\n * @custom:status Listing status\\n * @custom:submitter User who submitted the Token for listing\\n * @custom:statusIndex Index of listing in corresponding statusArray\\n * @custom:accruedUtilityScore Sum of voters utility score\\n * @custom:accruedSocialScore Sum of voters social score\\n * @custom:accruedTrustScore Sum of voters trust score\\n * @custom:phase Phase count\\n */\\n// TODO : Reorg for gas effiency \\nstruct TokenListing {\\n    Token token;\\n    uint256 coeff;\\n    ListingStatus status;\\n    address submitter;\\n    uint256 statusIndex;\\n\\n    uint256 accruedUtilityScore;\\n    uint256 accruedSocialScore;\\n    uint256 accruedTrustScore;\\n\\n    uint256 phase;\\n}\"\r\n    },\r\n    \"src/lib/AxelarStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nenum MobulaMethod {\\n    SubmitToken,\\n    UpdateToken,\\n    TopUpToken\\n}\\n\\nstruct MobulaPayload {\\n    MobulaMethod method;\\n    address sender;\\n    address paymentTokenAddress;\\n    string ipfsHash;\\n    uint256 tokenId;\\n    uint256 paymentAmount;\\n    uint256 voteId;\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\ninterface IAxelarGateway {\\n    /**********\\\\\\n    |* Errors *|\\n    \\\\**********/\\n\\n    error NotSelf();\\n    error NotProxy();\\n    error InvalidCodeHash();\\n    error SetupFailed();\\n    error InvalidAuthModule();\\n    error InvalidTokenDeployer();\\n    error InvalidAmount();\\n    error InvalidChainId();\\n    error InvalidCommands();\\n    error TokenDoesNotExist(string symbol);\\n    error TokenAlreadyExists(string symbol);\\n    error TokenDeployFailed(string symbol);\\n    error TokenContractDoesNotExist(address token);\\n    error BurnFailed(string symbol);\\n    error MintFailed(string symbol);\\n    error InvalidSetMintLimitsParams();\\n    error ExceedMintLimit(string symbol);\\n\\n    /**********\\\\\\n    |* Events *|\\n    \\\\**********/\\n\\n    event TokenSent(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationAddress,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event ContractCall(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload\\n    );\\n\\n    event ContractCallWithToken(\\n        address indexed sender,\\n        string destinationChain,\\n        string destinationContractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes payload,\\n        string symbol,\\n        uint256 amount\\n    );\\n\\n    event Executed(bytes32 indexed commandId);\\n\\n    event TokenDeployed(string symbol, address tokenAddresses);\\n\\n    event ContractCallApproved(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event ContractCallApprovedWithMint(\\n        bytes32 indexed commandId,\\n        string sourceChain,\\n        string sourceAddress,\\n        address indexed contractAddress,\\n        bytes32 indexed payloadHash,\\n        string symbol,\\n        uint256 amount,\\n        bytes32 sourceTxHash,\\n        uint256 sourceEventIndex\\n    );\\n\\n    event TokenMintLimitUpdated(string symbol, uint256 limit);\\n\\n    event OperatorshipTransferred(bytes newOperatorsData);\\n\\n    event Upgraded(address indexed implementation);\\n\\n    /********************\\\\\\n    |* Public Functions *|\\n    \\\\********************/\\n\\n    function sendToken(\\n        string calldata destinationChain,\\n        string calldata destinationAddress,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function callContract(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function callContractWithToken(\\n        string calldata destinationChain,\\n        string calldata contractAddress,\\n        bytes calldata payload,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external;\\n\\n    function isContractCallApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash\\n    ) external view returns (bool);\\n\\n    function isContractCallAndMintApproved(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        address contractAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external view returns (bool);\\n\\n    function validateContractCall(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash\\n    ) external returns (bool);\\n\\n    function validateContractCallAndMint(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes32 payloadHash,\\n        string calldata symbol,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /***********\\\\\\n    |* Getters *|\\n    \\\\***********/\\n\\n    function authModule() external view returns (address);\\n\\n    function tokenDeployer() external view returns (address);\\n\\n    function tokenMintLimit(string memory symbol) external view returns (uint256);\\n\\n    function tokenMintAmount(string memory symbol) external view returns (uint256);\\n\\n    function allTokensFrozen() external view returns (bool);\\n\\n    function implementation() external view returns (address);\\n\\n    function tokenAddresses(string memory symbol) external view returns (address);\\n\\n    function tokenFrozen(string memory symbol) external view returns (bool);\\n\\n    function isCommandExecuted(bytes32 commandId) external view returns (bool);\\n\\n    function adminEpoch() external view returns (uint256);\\n\\n    function adminThreshold(uint256 epoch) external view returns (uint256);\\n\\n    function admins(uint256 epoch) external view returns (address[] memory);\\n\\n    /*******************\\\\\\n    |* Admin Functions *|\\n    \\\\*******************/\\n\\n    function setTokenMintLimits(string[] calldata symbols, uint256[] calldata limits) external;\\n\\n    function upgrade(\\n        address newImplementation,\\n        bytes32 newImplementationCodeHash,\\n        bytes calldata setupParams\\n    ) external;\\n\\n    /**********************\\\\\\n    |* External Functions *|\\n    \\\\**********************/\\n\\n    function setup(bytes calldata params) external;\\n\\n    function execute(bytes calldata input) external;\\n}\\n\"\r\n    },\r\n    \"lib/axelar-gmp-sdk-solidity/contracts/interfaces/IAxelarExecutable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport { IAxelarGateway } from './IAxelarGateway.sol';\\n\\ninterface IAxelarExecutable {\\n    error InvalidAddress();\\n    error NotApprovedByGateway();\\n\\n    function gateway() external view returns (IAxelarGateway);\\n\\n    function execute(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload\\n    ) external;\\n\\n    function executeWithToken(\\n        bytes32 commandId,\\n        string calldata sourceChain,\\n        string calldata sourceAddress,\\n        bytes calldata payload,\\n        string calldata tokenSymbol,\\n        uint256 amount\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@axelar/=lib/axelar-gmp-sdk-solidity/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"axelar-gmp-sdk-solidity/=lib/axelar-gmp-sdk-solidity/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gateway_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mobulaToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"listingPhase\",\"type\":\"uint256\"}],\"name\":\"AlreadyVoted\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20WithdrawFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"ETHTransferFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"protocolBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"InsufficientProtocolBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"}],\"name\":\"InvalidAxelarContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPaymentAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"}],\"name\":\"InvalidPaymentToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"}],\"name\":\"InvalidPercentage\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidScoreValue\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"currentStatus\",\"type\":\"uint8\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"targetStatus\",\"type\":\"uint8\"}],\"name\":\"InvalidStatusUpdate\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"InvalidUpdatingUser\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minimumRankNeeded\",\"type\":\"uint256\"}],\"name\":\"InvalidUserRank\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromRank\",\"type\":\"uint256\"}],\"name\":\"NoDemotionYet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"toRank\",\"type\":\"uint256\"}],\"name\":\"NoPromotionYet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotApprovedByGateway\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"NotSortingListing\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"NotUpdatingListing\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"NotValidationListing\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"NothingToClaim\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCurrentRank\",\"type\":\"uint256\"}],\"name\":\"RankDemotionImpossible\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"userRank\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCurrentRank\",\"type\":\"uint256\"}],\"name\":\"RankPromotionImpossible\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"}],\"name\":\"SubmitterInCooldown\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"TokenInCooldown\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TokenNotFound\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPaymentFailed\",\"type\":\"error\"},{\"inputs\":[{\"components\":[{\"internalType\":\"enum MobulaMethod\",\"name\":\"method\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"}],\"internalType\":\"struct MobulaPayload\",\"name\":\"payload\",\"type\":\"tuple\"}],\"name\":\"UnknownMethod\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"}],\"name\":\"VoteNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ERC20FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"enum ListingStatus\",\"name\":\"previousStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum ListingStatus\",\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"ListingStatusUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ListingVote\",\"name\":\"vote\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"name\":\"SortingVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"TokenDetailsUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"funder\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"statusIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedUtilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedSocialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedTrustScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct TokenListing\",\"name\":\"tokenListing\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenListingFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"statusIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedUtilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedSocialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedTrustScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct TokenListing\",\"name\":\"tokenListing\",\"type\":\"tuple\"}],\"name\":\"TokenListingSubmitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"}],\"name\":\"TokenValidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"demoted\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRank\",\"type\":\"uint256\"}],\"name\":\"UserDemoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"promoted\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRank\",\"type\":\"uint256\"}],\"name\":\"UserPromoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ListingVote\",\"name\":\"vote\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"name\":\"ValidationVote\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"badSortingVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"badValidationVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"demoted\",\"type\":\"address\"}],\"name\":\"demote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"demoteVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editCoeffMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"demoted\",\"type\":\"address\"}],\"name\":\"emergencyDemote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"}],\"name\":\"emergencyKillRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"promoted\",\"type\":\"address\"}],\"name\":\"emergencyPromote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"emergencyUpdateListingStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"commandId\",\"type\":\"bytes32\"},{\"internalType\":\"string\",\"name\":\"sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"tokenSymbol\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"executeWithToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateway\",\"outputs\":[{\"internalType\":\"contract IAxelarGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSortingTokenListings\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"statusIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedUtilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedSocialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedTrustScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenListing[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenListings\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"statusIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedUtilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedSocialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedTrustScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenListing[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"getTokenListingsWithStatus\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"statusIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedUtilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedSocialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedTrustScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenListing[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getValidationTokenListings\",\"outputs\":[{\"components\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"statusIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedUtilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedSocialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedTrustScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"}],\"internalType\":\"struct TokenListing[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"goodSortingVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"goodValidationVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membersToDemoteFromRankI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membersToDemoteFromRankII\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membersToPromoteToRankI\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"membersToPromoteToRankII\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"owedRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"paidRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"promoted\",\"type\":\"address\"}],\"name\":\"promote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"promoteVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolAPI\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sortingAcceptances\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortingMaxVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortingMinAcceptancesPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sortingMinModificationsPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sortingModifications\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sortingRejections\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sortingVotesPhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"submitFloorPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"submitToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenListings\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastUpdate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"internalType\":\"struct Token\",\"name\":\"token\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"coeff\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"submitter\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"statusIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedUtilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedSocialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accruedTrustScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"phase\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensPerVote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"paymentAmount\",\"type\":\"uint256\"}],\"name\":\"topUpToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_editCoeffMultiplier\",\"type\":\"uint256\"}],\"name\":\"updateEditCoeffMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_membersToDemoteToRankI\",\"type\":\"uint256\"}],\"name\":\"updateMembersToDemoteFromRankI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_membersToDemoteToRankII\",\"type\":\"uint256\"}],\"name\":\"updateMembersToDemoteFromRankII\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_membersToPromoteToRankI\",\"type\":\"uint256\"}],\"name\":\"updateMembersToPromoteToRankI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_membersToPromoteToRankII\",\"type\":\"uint256\"}],\"name\":\"updateMembersToPromoteToRankII\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_protocolAPI\",\"type\":\"address\"}],\"name\":\"updateProtocolAPIAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sortingMaxVotes\",\"type\":\"uint256\"}],\"name\":\"updateSortingMaxVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sortingMinAcceptancesPct\",\"type\":\"uint256\"}],\"name\":\"updateSortingMinAcceptancesPct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_sortingMinModificationsPct\",\"type\":\"uint256\"}],\"name\":\"updateSortingMinModificationsPct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_submitFloorPrice\",\"type\":\"uint256\"}],\"name\":\"updateSubmitFloorPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"ipfsHash\",\"type\":\"string\"}],\"name\":\"updateToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokensPerVote\",\"type\":\"uint256\"}],\"name\":\"updateTokensPerVote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validationMaxVotes\",\"type\":\"uint256\"}],\"name\":\"updateValidationMaxVotes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validationMinAcceptancesPct\",\"type\":\"uint256\"}],\"name\":\"updateValidationMinAcceptancesPct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_validationMinModificationsPct\",\"type\":\"uint256\"}],\"name\":\"updateValidationMinModificationsPct\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_voteCooldown\",\"type\":\"uint256\"}],\"name\":\"updateVoteCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_votesNeededToRankIDemotion\",\"type\":\"uint256\"}],\"name\":\"updateVotesNeededToRankIDemotion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_votesNeededToRankIIDemotion\",\"type\":\"uint256\"}],\"name\":\"updateVotesNeededToRankIIDemotion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_votesNeededToRankIIPromotion\",\"type\":\"uint256\"}],\"name\":\"updateVotesNeededToRankIIPromotion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_votesNeededToRankIPromotion\",\"type\":\"uint256\"}],\"name\":\"updateVotesNeededToRankIPromotion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_whitelistedCooldown\",\"type\":\"uint256\"}],\"name\":\"updateWhitelistedCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validationAcceptances\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validationMaxVotes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validationMinAcceptancesPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validationMinModificationsPct\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validationModifications\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"validationRejections\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validationVotesPhase\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"voteCooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingVote\",\"name\":\"vote\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"name\":\"voteSorting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"voteId\",\"type\":\"uint256\"},{\"internalType\":\"enum ListingVote\",\"name\":\"vote\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"utilityScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"socialScore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"trustScore\",\"type\":\"uint256\"}],\"name\":\"voteValidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votesNeededToRankIDemotion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votesNeededToRankIIDemotion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votesNeededToRankIIPromotion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"votesNeededToRankIPromotion\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_sourceChain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_sourceAddress\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"whitelistAxelarContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stableAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"whitelistStable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_submitter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"whitelisted\",\"type\":\"bool\"}],\"name\":\"whitelistSubmitter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"whitelistedAxelarContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistedCooldown\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedLastSubmit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedStable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedSubmitter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"withdrawERC20Funds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MobulaTokensProtocol", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000006f015f16de9fc8791b234ef68d486d2bf203fba800000000000000000000000099fb00369e6a5c1963dcd32eba99d7b21c5a37d80000000000000000000000005fef39b578deeefa4485a7e5944c7691677d5dd4", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}