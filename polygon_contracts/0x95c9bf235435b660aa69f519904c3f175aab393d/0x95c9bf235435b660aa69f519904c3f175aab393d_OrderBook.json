{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/concrete/OrderBook.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity =0.8.19;\\n\\nimport {Math} from \\\"openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport {Multicall} from \\\"openzeppelin-contracts/contracts/utils/Multicall.sol\\\";\\nimport {IERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport {ReentrancyGuard} from \\\"openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"rain.math.fixedpoint/lib/LibFixedPointDecimalArithmeticOpenZeppelin.sol\\\";\\nimport \\\"rain.math.fixedpoint/lib/LibFixedPointDecimalScale.sol\\\";\\nimport \\\"rain.interpreter/src/lib/caller/LibEncodedDispatch.sol\\\";\\nimport \\\"rain.interpreter/src/lib/caller/LibContext.sol\\\";\\nimport {\\n    DeployerDiscoverableMetaV2,\\n    DeployerDiscoverableMetaV2ConstructionConfig,\\n    LibMeta\\n} from \\\"rain.interpreter/src/abstract/DeployerDiscoverableMetaV2.sol\\\";\\nimport \\\"rain.interpreter/src/lib/bytecode/LibBytecode.sol\\\";\\n\\nimport \\\"../interface/unstable/IOrderBookV3.sol\\\";\\nimport \\\"../interface/unstable/IOrderBookV3OrderTaker.sol\\\";\\nimport \\\"../lib/LibOrder.sol\\\";\\nimport \\\"../abstract/OrderBookV3FlashLender.sol\\\";\\n\\n/// This will exist in a future version of Open Zeppelin if their main branch is\\n/// to be believed.\\nerror ReentrancyGuardReentrantCall();\\n\\n/// Thrown when the `msg.sender` modifying an order is not its owner.\\n/// @param sender `msg.sender` attempting to modify the order.\\n/// @param owner The owner of the order.\\nerror NotOrderOwner(address sender, address owner);\\n\\n/// Thrown when the input and output tokens don't match, in either direction.\\n/// @param aliceToken The input or output of one order.\\n/// @param bobToken The input or output of the other order that doesn't match a.\\nerror TokenMismatch(address aliceToken, address bobToken);\\n\\n/// Thrown when the input and output token decimals don't match, in either\\n/// direction.\\n/// @param aliceTokenDecimals The input or output decimals of one order.\\n/// @param bobTokenDecimals The input or output decimals of the other order.\\nerror TokenDecimalsMismatch(uint8 aliceTokenDecimals, uint8 bobTokenDecimals);\\n\\n/// Thrown when the minimum input is not met.\\n/// @param minimumInput The minimum input required.\\n/// @param input The input that was achieved.\\nerror MinimumInput(uint256 minimumInput, uint256 input);\\n\\n/// Thrown when two orders have the same owner during clear.\\n/// @param owner The owner of both orders.\\nerror SameOwner(address owner);\\n\\n/// @dev Stored value for a live order. NOT a boolean because storing a boolean\\n/// is more expensive than storing a uint256.\\nuint256 constant ORDER_LIVE = 1;\\n\\n/// @dev Stored value for a dead order. `0` is chosen because it is the default\\n/// value for a mapping, which means all orders are dead unless explicitly made\\n/// live.\\nuint256 constant ORDER_DEAD = 0;\\n\\n/// @dev Entrypoint to a calculate the amount and ratio of an order.\\nSourceIndex constant CALCULATE_ORDER_ENTRYPOINT = SourceIndex.wrap(0);\\n/// @dev Entrypoint to handle the final internal vault movements resulting from\\n/// matching multiple calculated orders.\\nSourceIndex constant HANDLE_IO_ENTRYPOINT = SourceIndex.wrap(1);\\n\\n/// @dev Minimum outputs for calculate order are the amount and ratio.\\nuint256 constant CALCULATE_ORDER_MIN_OUTPUTS = 2;\\n/// @dev Maximum outputs for calculate order are the amount and ratio.\\nuint16 constant CALCULATE_ORDER_MAX_OUTPUTS = 2;\\n\\n/// @dev Handle IO has no outputs as it only responds to vault movements.\\nuint256 constant HANDLE_IO_MIN_OUTPUTS = 0;\\n/// @dev Handle IO has no outputs as it only response to vault movements.\\nuint16 constant HANDLE_IO_MAX_OUTPUTS = 0;\\n\\n/// @dev Orderbook context is actually fairly complex. The calling context column\\n/// is populated before calculate order, but the remaining columns are only\\n/// available to handle IO as they depend on the full evaluation of calculuate\\n/// order, and cross referencing against the same from the counterparty, as well\\n/// as accounting limits such as current vault balances, etc.\\n/// The token address and decimals for vault inputs and outputs IS available to\\n/// the calculate order entrypoint, but not the final vault balances/diff.\\nuint256 constant CALLING_CONTEXT_COLUMNS = 4;\\n/// @dev Base context from LibContext.\\nuint256 constant CONTEXT_BASE_COLUMN = 0;\\n\\n/// @dev Contextual data available to both calculate order and handle IO. The\\n/// order hash, order owner and order counterparty. IMPORTANT NOTE that the\\n/// typical base context of an order with the caller will often be an unrelated\\n/// clearer of the order rather than the owner or counterparty.\\nuint256 constant CONTEXT_CALLING_CONTEXT_COLUMN = 1;\\n/// @dev Calculations column contains the DECIMAL RESCALED calculations but\\n/// otherwise provided as-is according to calculate order entrypoint\\nuint256 constant CONTEXT_CALCULATIONS_COLUMN = 2;\\n/// @dev Vault inputs are the literal token amounts and vault balances before and\\n/// after for the input token from the perspective of the order. MAY be\\n/// significantly different to the calculated amount due to insufficient vault\\n/// balances from either the owner or counterparty, etc.\\nuint256 constant CONTEXT_VAULT_INPUTS_COLUMN = 3;\\n/// @dev Vault outputs are the same as vault inputs but for the output token from\\n/// the perspective of the order.\\nuint256 constant CONTEXT_VAULT_OUTPUTS_COLUMN = 4;\\n\\n/// @dev Row of the token address for vault inputs and outputs columns.\\nuint256 constant CONTEXT_VAULT_IO_TOKEN = 0;\\n/// @dev Row of the token decimals for vault inputs and outputs columns.\\nuint256 constant CONTEXT_VAULT_IO_TOKEN_DECIMALS = 1;\\n/// @dev Row of the vault ID for vault inputs and outputs columns.\\nuint256 constant CONTEXT_VAULT_IO_VAULT_ID = 2;\\n/// @dev Row of the vault balance before the order was cleared for vault inputs\\n/// and outputs columns.\\nuint256 constant CONTEXT_VAULT_IO_BALANCE_BEFORE = 3;\\n/// @dev Row of the vault balance difference after the order was cleared for\\n/// vault inputs and outputs columns. The diff is ALWAYS POSITIVE as it is a\\n/// `uint256` so it must be added to input balances and subtraced from output\\n/// balances.\\nuint256 constant CONTEXT_VAULT_IO_BALANCE_DIFF = 4;\\n/// @dev Length of a vault IO column.\\nuint256 constant CONTEXT_VAULT_IO_ROWS = 5;\\n\\n/// @dev Hash of the caller contract metadata for construction.\\nbytes32 constant CALLER_META_HASH = bytes32(0x1317ffd909f4ca1cd6402c7dd02501ba5965a5b8787a9627cde7b5f3f8f6f840);\\n\\n/// All information resulting from an order calculation that allows for vault IO\\n/// to be calculated and applied, then the handle IO entrypoint to be dispatched.\\n/// @param outputMax The UNSCALED maximum output calculated by the order\\n/// expression. WILL BE RESCALED ACCORDING TO TOKEN DECIMALS to an 18 fixed\\n/// point decimal number for the purpose of calculating actual vault movements.\\n/// The output max is CAPPED AT THE OUTPUT VAULT BALANCE OF THE ORDER OWNER.\\n/// The order is guaranteed that the total output of this single clearance cannot\\n/// exceed this (subject to rescaling). It is up to the order expression to track\\n/// values over time if the output max is to impose a global limit across many\\n/// transactions and counterparties.\\n/// @param IORatio The UNSCALED order ratio as input/output from the perspective\\n/// of the order. As each counterparty's input is the other's output, the IORatio\\n/// calculated by each order is inverse of its counterparty. IORatio is SCALED\\n/// ACCORDING TO TOKEN DECIMALS to allow 18 decimal fixed point math over the\\n/// vault balances. I.e. `1e18` returned from the expression is ALWAYS \\\"one\\\" as\\n/// ECONOMIC EQUIVALENCE between two tokens, but this will be rescaled according\\n/// to the decimals of the token. For example, if DAI and USDT have a ratio of\\n/// `1e18` then in reality `1e12` DAI will move in the vault for every `1` USDT\\n/// that moves, because DAI has `1e18` decimals per $1 peg and USDT has `1e6`\\n/// decimals per $1 peg. THE ORDER DEFINES THE DECIMALS for each token, NOT the\\n/// token itself, because the token MAY NOT report its decimals as per it being\\n/// optional in the ERC20 specification.\\n/// @param context The entire 2D context array, initialized from the context\\n/// passed into the order calculations and then populated with the order\\n/// calculations and vault IO before being passed back to handle IO entrypoint.\\n/// @param namespace The `StateNamespace` to be passed to the store for calculate\\n/// IO state changes.\\n/// @param kvs KVs returned from calculate order entrypoint to pass to the store\\n/// before calling handle IO entrypoint.\\nstruct OrderIOCalculation {\\n    Order order;\\n    uint256 outputIOIndex;\\n    Output18Amount outputMax;\\n    //solhint-disable-next-line var-name-mixedcase\\n    uint256 IORatio;\\n    uint256[][] context;\\n    StateNamespace namespace;\\n    uint256[] kvs;\\n}\\n\\ntype Output18Amount is uint256;\\n\\ntype Input18Amount is uint256;\\n\\n/// @title OrderBook\\n/// See `IOrderBookV1` for more documentation.\\ncontract OrderBook is IOrderBookV3, ReentrancyGuard, Multicall, OrderBookV3FlashLender, DeployerDiscoverableMetaV2 {\\n    using LibUint256Array for uint256[];\\n    using SafeERC20 for IERC20;\\n    using LibOrder for Order;\\n    using LibUint256Array for uint256;\\n    using Math for uint256;\\n    using LibFixedPointDecimalScale for uint256;\\n    using LibFixedPointDecimalArithmeticOpenZeppelin for uint256;\\n\\n    /// All hashes of all active orders. There's nothing interesting in the value\\n    /// it's just nonzero if the order is live. The key is the hash of the order.\\n    /// Removing an order sets the value back to zero so it is identical to the\\n    /// order never existing.\\n    /// The order hash includes its owner so there's no need to build a multi\\n    /// level mapping, each order hash MUST uniquely identify the order globally.\\n    /// order hash => order is live\\n    // Solhint and slither disagree on this. Slither wins.\\n    //solhint-disable-next-line private-vars-leading-underscore\\n    mapping(bytes32 orderHash => uint256 liveness) internal sOrders;\\n\\n    /// @dev Vault balances are stored in a mapping of owner => token => vault ID\\n    /// This gives 1:1 parity with the `IOrderBookV1` interface but keeping the\\n    /// `sFoo` naming convention for storage variables.\\n    // Solhint and slither disagree on this. Slither wins.\\n    //solhint-disable-next-line private-vars-leading-underscore\\n    mapping(address owner => mapping(address token => mapping(uint256 vaultId => uint256 balance))) internal\\n        sVaultBalances;\\n\\n    /// Initializes the orderbook upon construction for compatibility with\\n    /// Open Zeppelin upgradeable contracts. Orderbook itself does NOT support\\n    /// factory deployments as each order is a unique expression deployment\\n    /// rather than needing to wrap up expressions with proxies.\\n    constructor(DeployerDiscoverableMetaV2ConstructionConfig memory config)\\n        DeployerDiscoverableMetaV2(CALLER_META_HASH, config)\\n    {}\\n\\n    /// Guard against read-only reentrancy.\\n    /// https://chainsecurity.com/heartbreaks-curve-lp-oracles/\\n    modifier nonReentrantView() {\\n        if (_reentrancyGuardEntered()) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n        _;\\n    }\\n\\n    /// @inheritdoc IOrderBookV3\\n    // This has a reentrancy guard on it but Slither doesn't know that because\\n    // it is a read-only reentrancy due to potential cross function reentrancy.\\n    // https://github.com/crytic/slither/issues/735#issuecomment-1620704314\\n    //slither-disable-next-line reentrancy-no-eth\\n    function vaultBalance(address owner, address token, uint256 vaultId)\\n        external\\n        view\\n        override\\n        nonReentrantView\\n        returns (uint256)\\n    {\\n        return sVaultBalances[owner][token][vaultId];\\n    }\\n\\n    /// @inheritdoc IOrderBookV3\\n    function orderExists(bytes32 orderHash) external view override nonReentrantView returns (bool) {\\n        return sOrders[orderHash] == ORDER_LIVE;\\n    }\\n\\n    /// @inheritdoc IOrderBookV3\\n    function deposit(address token, uint256 vaultId, uint256 amount) external nonReentrant {\\n        if (amount == 0) {\\n            revert ZeroDepositAmount(msg.sender, token, vaultId);\\n        }\\n        // It is safest with vault deposits to move tokens in to the Orderbook\\n        // before updating internal vault balances although we have a reentrancy\\n        // guard in place anyway.\\n        emit Deposit(msg.sender, token, vaultId, amount);\\n        //slither-disable-next-line reentrancy-benign\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\\n        sVaultBalances[msg.sender][token][vaultId] += amount;\\n    }\\n\\n    /// @inheritdoc IOrderBookV3\\n    function withdraw(address token, uint256 vaultId, uint256 targetAmount) external nonReentrant {\\n        if (targetAmount == 0) {\\n            revert ZeroWithdrawTargetAmount(msg.sender, token, vaultId);\\n        }\\n        uint256 currentVaultBalance = sVaultBalances[msg.sender][token][vaultId];\\n        // Don't allow withdrawals to exceed the current vault balance.\\n        uint256 withdrawAmount = targetAmount.min(currentVaultBalance);\\n        if (withdrawAmount > 0) {\\n            // The overflow check here is redundant with .min above, so\\n            // technically this is overly conservative but we REALLY don't want\\n            // withdrawals to exceed vault balances.\\n            sVaultBalances[msg.sender][token][vaultId] = currentVaultBalance - withdrawAmount;\\n            emit Withdraw(msg.sender, token, vaultId, targetAmount, withdrawAmount);\\n            _decreaseFlashDebtThenSendToken(token, msg.sender, withdrawAmount);\\n        }\\n    }\\n\\n    /// @inheritdoc IOrderBookV3\\n    function addOrder(OrderConfigV2 calldata config) external nonReentrant returns (bool stateChanged) {\\n        uint256 sourceCount = LibBytecode.sourceCount(config.evaluableConfig.bytecode);\\n        if (sourceCount == 0) {\\n            revert OrderNoSources(msg.sender);\\n        }\\n        if (sourceCount == 1) {\\n            revert OrderNoHandleIO(msg.sender);\\n        }\\n        if (config.validInputs.length == 0) {\\n            revert OrderNoInputs(msg.sender);\\n        }\\n        if (config.validOutputs.length == 0) {\\n            revert OrderNoOutputs(msg.sender);\\n        }\\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) = config\\n            .evaluableConfig\\n            .deployer\\n            .deployExpression(\\n            config.evaluableConfig.bytecode,\\n            config.evaluableConfig.constants,\\n            LibUint256Array.arrayFrom(CALCULATE_ORDER_MIN_OUTPUTS, HANDLE_IO_MIN_OUTPUTS)\\n        );\\n\\n        // Merge our view on the sender/owner and handle IO emptiness with the\\n        // config and deployer's view on the `Evaluable` to produce the final\\n        // order.\\n        Order memory order = Order(\\n            msg.sender,\\n            LibBytecode.sourceOpsLength(config.evaluableConfig.bytecode, SourceIndex.unwrap(HANDLE_IO_ENTRYPOINT)) > 0,\\n            Evaluable(interpreter, store, expression),\\n            config.validInputs,\\n            config.validOutputs\\n        );\\n        bytes32 orderHash = order.hash();\\n\\n        // If the order is not dead we return early without state changes.\\n        if (sOrders[orderHash] == ORDER_DEAD) {\\n            stateChanged = true;\\n\\n            //slither-disable-next-line reentrancy-benign\\n            sOrders[orderHash] = ORDER_LIVE;\\n            emit AddOrder(msg.sender, config.evaluableConfig.deployer, order, orderHash);\\n\\n            // We only emit the meta event if there is meta to emit. We do require\\n            // that the meta self describes as a Rain meta document.\\n            if (config.meta.length > 0) {\\n                LibMeta.checkMetaUnhashed(config.meta);\\n                emit MetaV1(msg.sender, uint256(orderHash), config.meta);\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IOrderBookV3\\n    function removeOrder(Order calldata order) external nonReentrant returns (bool stateChanged) {\\n        if (msg.sender != order.owner) {\\n            revert NotOrderOwner(msg.sender, order.owner);\\n        }\\n        bytes32 orderHash = order.hash();\\n        if (sOrders[orderHash] == ORDER_LIVE) {\\n            stateChanged = true;\\n            sOrders[orderHash] = ORDER_DEAD;\\n            emit RemoveOrder(msg.sender, order, orderHash);\\n        }\\n    }\\n\\n    /// @inheritdoc IOrderBookV3\\n    function takeOrders(TakeOrdersConfigV2 calldata config)\\n        external\\n        nonReentrant\\n        returns (uint256 totalTakerInput, uint256 totalTakerOutput)\\n    {\\n        if (config.orders.length == 0) {\\n            revert NoOrders();\\n        }\\n\\n        uint256 i = 0;\\n        TakeOrderConfig memory takeOrderConfig;\\n        Order memory order;\\n\\n        uint256 remainingTakerInput = config.maximumInput;\\n        if (remainingTakerInput == 0) {\\n            revert ZeroMaximumInput();\\n        }\\n        while (i < config.orders.length && remainingTakerInput > 0) {\\n            takeOrderConfig = config.orders[i];\\n            order = takeOrderConfig.order;\\n            // Every order needs the same input token.\\n            if (\\n                order.validInputs[takeOrderConfig.inputIOIndex].token\\n                    != config.orders[0].order.validInputs[config.orders[0].inputIOIndex].token\\n            ) {\\n                revert TokenMismatch(\\n                    order.validInputs[takeOrderConfig.inputIOIndex].token,\\n                    config.orders[0].order.validInputs[config.orders[0].inputIOIndex].token\\n                );\\n            }\\n            // Every order needs the same output token.\\n            if (\\n                order.validOutputs[takeOrderConfig.outputIOIndex].token\\n                    != config.orders[0].order.validOutputs[config.orders[0].outputIOIndex].token\\n            ) {\\n                revert TokenMismatch(\\n                    order.validOutputs[takeOrderConfig.outputIOIndex].token,\\n                    config.orders[0].order.validOutputs[config.orders[0].outputIOIndex].token\\n                );\\n            }\\n            // Every order needs the same input token decimals.\\n            if (\\n                order.validInputs[takeOrderConfig.inputIOIndex].decimals\\n                    != config.orders[0].order.validInputs[config.orders[0].inputIOIndex].decimals\\n            ) {\\n                revert TokenDecimalsMismatch(\\n                    order.validInputs[takeOrderConfig.inputIOIndex].decimals,\\n                    config.orders[0].order.validInputs[config.orders[0].inputIOIndex].decimals\\n                );\\n            }\\n            // Every order needs the same output token decimals.\\n            if (\\n                order.validOutputs[takeOrderConfig.outputIOIndex].decimals\\n                    != config.orders[0].order.validOutputs[config.orders[0].outputIOIndex].decimals\\n            ) {\\n                revert TokenDecimalsMismatch(\\n                    order.validOutputs[takeOrderConfig.outputIOIndex].decimals,\\n                    config.orders[0].order.validOutputs[config.orders[0].outputIOIndex].decimals\\n                );\\n            }\\n\\n            bytes32 orderHash = order.hash();\\n            if (sOrders[orderHash] == ORDER_DEAD) {\\n                emit OrderNotFound(msg.sender, order.owner, orderHash);\\n            } else {\\n                OrderIOCalculation memory orderIOCalculation = calculateOrderIO(\\n                    order,\\n                    takeOrderConfig.inputIOIndex,\\n                    takeOrderConfig.outputIOIndex,\\n                    msg.sender,\\n                    takeOrderConfig.signedContext\\n                );\\n\\n                // Skip orders that are too expensive rather than revert as we have\\n                // no way of knowing if a specific order becomes too expensive\\n                // between submitting to mempool and execution, but other orders may\\n                // be valid so we want to take advantage of those if possible.\\n                if (orderIOCalculation.IORatio > config.maximumIORatio) {\\n                    emit OrderExceedsMaxRatio(msg.sender, order.owner, orderHash);\\n                } else if (Output18Amount.unwrap(orderIOCalculation.outputMax) == 0) {\\n                    emit OrderZeroAmount(msg.sender, order.owner, orderHash);\\n                } else {\\n                    uint8 takerInputDecimals = order.validOutputs[takeOrderConfig.outputIOIndex].decimals;\\n                    // Taker is just \\\"market buying\\\" the order output max.\\n                    Input18Amount takerInput18 = Input18Amount.wrap(Output18Amount.unwrap(orderIOCalculation.outputMax));\\n                    // Cap the taker input at the remaining input before\\n                    // calculating the taker output. Keep everything in 18\\n                    // decimals at this point, which requires rescaling the\\n                    // remaining taker input to match.\\n                    {\\n                        // Round down and saturate when converting remaining taker input to 18 decimals.\\n                        Input18Amount remainingTakerInput18 =\\n                            Input18Amount.wrap(remainingTakerInput.scale18(takerInputDecimals, FLAG_SATURATE));\\n                        if (Input18Amount.unwrap(takerInput18) > Input18Amount.unwrap(remainingTakerInput18)) {\\n                            takerInput18 = remainingTakerInput18;\\n                        }\\n                    }\\n\\n                    uint256 takerOutput;\\n                    {\\n                        // Always round IO calculations up so the taker pays more.\\n                        Output18Amount takerOutput18 = Output18Amount.wrap(\\n                            // Use the capped taker input to calculate the taker\\n                            // output.\\n                            Input18Amount.unwrap(takerInput18).fixedPointMul(\\n                                orderIOCalculation.IORatio, Math.Rounding.Up\\n                            )\\n                        );\\n                        takerOutput = Output18Amount.unwrap(takerOutput18).scaleN(\\n                            order.validInputs[takeOrderConfig.inputIOIndex].decimals, FLAG_ROUND_UP\\n                        );\\n                    }\\n\\n                    uint256 takerInput = Input18Amount.unwrap(takerInput18).scaleN(takerInputDecimals, FLAG_SATURATE);\\n\\n                    remainingTakerInput -= takerInput;\\n                    totalTakerOutput += takerOutput;\\n\\n                    recordVaultIO(order, takerOutput, takerInput, orderIOCalculation);\\n                    emit TakeOrder(msg.sender, takeOrderConfig, takerInput, takerOutput);\\n                }\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n        totalTakerInput = config.maximumInput - remainingTakerInput;\\n\\n        if (totalTakerInput < config.minimumInput) {\\n            revert MinimumInput(config.minimumInput, totalTakerInput);\\n        }\\n\\n        // Prioritise paying down any active flash loans before sending any\\n        // tokens to `msg.sender`. We send the tokens to `msg.sender` first\\n        // adopting a similar pattern to Uniswap flash swaps. We call the caller\\n        // before attempting to pull tokens from them in order to facilitate\\n        // better integrations with external liquidity sources. This could be\\n        // done by the caller using flash loans but this callback:\\n        // - may be simpler for the caller to implement\\n        // - allows the caller to call `takeOrders` _before_ placing external\\n        //   trades, which is important if the order logic itself is dependent on\\n        //   external data (e.g. prices) that could be modified by the caller's\\n        //   trades.\\n        uint256 takerInputAmountSent = _decreaseFlashDebtThenSendToken(\\n            config.orders[0].order.validOutputs[config.orders[0].outputIOIndex].token, msg.sender, totalTakerInput\\n        );\\n        if (config.data.length > 0) {\\n            IOrderBookV3OrderTaker(msg.sender).onTakeOrders(\\n                config.orders[0].order.validOutputs[config.orders[0].outputIOIndex].token,\\n                config.orders[0].order.validInputs[config.orders[0].inputIOIndex].token,\\n                takerInputAmountSent,\\n                totalTakerOutput,\\n                config.data\\n            );\\n        }\\n\\n        if (totalTakerOutput > 0) {\\n            // We already updated vault balances before we took tokens from\\n            // `msg.sender` which is usually NOT the correct order of operations for\\n            // depositing to a vault. We rely on reentrancy guards to make this safe.\\n            IERC20(config.orders[0].order.validInputs[config.orders[0].inputIOIndex].token).safeTransferFrom(\\n                msg.sender, address(this), totalTakerOutput\\n            );\\n        }\\n    }\\n\\n    /// @inheritdoc IOrderBookV3\\n    function clear(\\n        Order memory alice,\\n        Order memory bob,\\n        ClearConfig calldata clearConfig,\\n        SignedContextV1[] memory aliceSignedContext,\\n        SignedContextV1[] memory bobSignedContext\\n    ) external nonReentrant {\\n        {\\n            if (alice.owner == bob.owner) {\\n                revert SameOwner(alice.owner);\\n            }\\n            if (\\n                alice.validOutputs[clearConfig.aliceOutputIOIndex].token\\n                    != bob.validInputs[clearConfig.bobInputIOIndex].token\\n            ) {\\n                revert TokenMismatch(\\n                    alice.validOutputs[clearConfig.aliceOutputIOIndex].token,\\n                    bob.validInputs[clearConfig.bobInputIOIndex].token\\n                );\\n            }\\n\\n            if (\\n                alice.validOutputs[clearConfig.aliceOutputIOIndex].decimals\\n                    != bob.validInputs[clearConfig.bobInputIOIndex].decimals\\n            ) {\\n                revert TokenDecimalsMismatch(\\n                    alice.validOutputs[clearConfig.aliceOutputIOIndex].decimals,\\n                    bob.validInputs[clearConfig.bobInputIOIndex].decimals\\n                );\\n            }\\n\\n            if (\\n                bob.validOutputs[clearConfig.bobOutputIOIndex].token\\n                    != alice.validInputs[clearConfig.aliceInputIOIndex].token\\n            ) {\\n                revert TokenMismatch(\\n                    alice.validInputs[clearConfig.aliceInputIOIndex].token,\\n                    bob.validOutputs[clearConfig.bobOutputIOIndex].token\\n                );\\n            }\\n\\n            if (\\n                bob.validOutputs[clearConfig.bobOutputIOIndex].decimals\\n                    != alice.validInputs[clearConfig.aliceInputIOIndex].decimals\\n            ) {\\n                revert TokenDecimalsMismatch(\\n                    alice.validInputs[clearConfig.aliceInputIOIndex].decimals,\\n                    bob.validOutputs[clearConfig.bobOutputIOIndex].decimals\\n                );\\n            }\\n\\n            // If either order is dead the clear is a no-op other than emitting\\n            // `OrderNotFound`. Returning rather than erroring makes it easier to\\n            // bulk clear using `Multicall`.\\n            if (sOrders[alice.hash()] == ORDER_DEAD) {\\n                emit OrderNotFound(msg.sender, alice.owner, alice.hash());\\n                return;\\n            }\\n            if (sOrders[bob.hash()] == ORDER_DEAD) {\\n                emit OrderNotFound(msg.sender, bob.owner, bob.hash());\\n                return;\\n            }\\n\\n            // Emit the Clear event before `eval`.\\n            emit Clear(msg.sender, alice, bob, clearConfig);\\n        }\\n        OrderIOCalculation memory aliceOrderIOCalculation = calculateOrderIO(\\n            alice, clearConfig.aliceInputIOIndex, clearConfig.aliceOutputIOIndex, bob.owner, bobSignedContext\\n        );\\n        OrderIOCalculation memory bobOrderIOCalculation = calculateOrderIO(\\n            bob, clearConfig.bobInputIOIndex, clearConfig.bobOutputIOIndex, alice.owner, aliceSignedContext\\n        );\\n        ClearStateChange memory clearStateChange =\\n            calculateClearStateChange(aliceOrderIOCalculation, bobOrderIOCalculation);\\n\\n        recordVaultIO(alice, clearStateChange.aliceInput, clearStateChange.aliceOutput, aliceOrderIOCalculation);\\n        recordVaultIO(bob, clearStateChange.bobInput, clearStateChange.bobOutput, bobOrderIOCalculation);\\n\\n        {\\n            // At least one of these will overflow due to negative bounties if\\n            // there is a spread between the orders.\\n            uint256 aliceBounty = clearStateChange.aliceOutput - clearStateChange.bobInput;\\n            uint256 bobBounty = clearStateChange.bobOutput - clearStateChange.aliceInput;\\n            if (aliceBounty > 0) {\\n                sVaultBalances[msg.sender][alice.validOutputs[clearConfig.aliceOutputIOIndex].token][clearConfig\\n                    .aliceBountyVaultId] += aliceBounty;\\n            }\\n            if (bobBounty > 0) {\\n                sVaultBalances[msg.sender][bob.validOutputs[clearConfig.bobOutputIOIndex].token][clearConfig\\n                    .bobBountyVaultId] += bobBounty;\\n            }\\n        }\\n\\n        emit AfterClear(msg.sender, clearStateChange);\\n    }\\n\\n    /// Main entrypoint into an order calculates the amount and IO ratio. Both\\n    /// are always treated as 18 decimal fixed point values and then rescaled\\n    /// according to the order's definition of each token's actual fixed point\\n    /// decimals.\\n    /// @param order The order to evaluate.\\n    /// @param inputIOIndex The index of the input token being calculated for.\\n    /// @param outputIOIndex The index of the output token being calculated for.\\n    /// @param counterparty The counterparty of the order as it is currently\\n    /// being cleared against.\\n    /// @param signedContext Any signed context provided by the clearer/taker\\n    /// that the order may need for its calculations.\\n    function calculateOrderIO(\\n        Order memory order,\\n        uint256 inputIOIndex,\\n        uint256 outputIOIndex,\\n        address counterparty,\\n        SignedContextV1[] memory signedContext\\n    ) internal view returns (OrderIOCalculation memory) {\\n        unchecked {\\n            bytes32 orderHash = order.hash();\\n\\n            uint256[][] memory context;\\n            {\\n                uint256[][] memory callingContext = new uint256[][](\\n                    CALLING_CONTEXT_COLUMNS\\n                );\\n                callingContext[CONTEXT_CALLING_CONTEXT_COLUMN - 1] = LibUint256Array.arrayFrom(\\n                    uint256(orderHash), uint256(uint160(order.owner)), uint256(uint160(counterparty))\\n                );\\n\\n                callingContext[CONTEXT_VAULT_INPUTS_COLUMN - 1] = LibUint256Array.arrayFrom(\\n                    uint256(uint160(order.validInputs[inputIOIndex].token)),\\n                    order.validInputs[inputIOIndex].decimals,\\n                    order.validInputs[inputIOIndex].vaultId,\\n                    sVaultBalances[order.owner][order.validInputs[inputIOIndex].token][order.validInputs[inputIOIndex]\\n                        .vaultId],\\n                    // Don't know the balance diff yet!\\n                    0\\n                );\\n\\n                callingContext[CONTEXT_VAULT_OUTPUTS_COLUMN - 1] = LibUint256Array.arrayFrom(\\n                    uint256(uint160(order.validOutputs[outputIOIndex].token)),\\n                    order.validOutputs[outputIOIndex].decimals,\\n                    order.validOutputs[outputIOIndex].vaultId,\\n                    sVaultBalances[order.owner][order.validOutputs[outputIOIndex].token][order.validOutputs[outputIOIndex]\\n                        .vaultId],\\n                    // Don't know the balance diff yet!\\n                    0\\n                );\\n                context = LibContext.build(callingContext, signedContext);\\n            }\\n\\n            // The state changes produced here are handled in _recordVaultIO so\\n            // that local storage writes happen before writes on the interpreter.\\n            StateNamespace namespace = StateNamespace.wrap(uint256(uint160(order.owner)));\\n            // Slither false positive. External calls within loops are fine if\\n            // the caller controls which orders are eval'd as they can drop\\n            // failing calls and resubmit a new transaction.\\n            // https://github.com/crytic/slither/issues/880\\n            //slither-disable-next-line calls-loop\\n            (uint256[] memory calculateOrderStack, uint256[] memory calculateOrderKVs) = order\\n                .evaluable\\n                .interpreter\\n                .eval(order.evaluable.store, namespace, _calculateOrderDispatch(order.evaluable.expression), context);\\n\\n            Output18Amount orderOutputMax18 = Output18Amount.wrap(calculateOrderStack[calculateOrderStack.length - 2]);\\n            uint256 orderIORatio = calculateOrderStack[calculateOrderStack.length - 1];\\n\\n            {\\n                // The order owner can't send more than the smaller of their vault\\n                // balance or their per-order limit.\\n                uint256 ownerVaultBalance = sVaultBalances[order.owner][order.validOutputs[outputIOIndex].token][order\\n                    .validOutputs[outputIOIndex].vaultId];\\n                // We round down vault balances and don't saturate because we're\\n                // dealing with real token amounts here. If rescaling would somehow\\n                // cause an overflow in a real token amount, that's basically an\\n                // unsupported token, it implies a very small decimals value with\\n                // very large token total supply. E.g. 0 decimals with a total supply\\n                // around 10^60. That's beyond what even Uniswap handles, as they use\\n                // uint112 values internally for tokens.\\n                // It's possible that if a token has large decimals, e.g. much more\\n                // than 18, that the owner vault balance could be rounded down enough\\n                // to cause significant non-dust amounts to be untradeable. In this\\n                // case the token is not really supported.\\n                // In either case, the order owner can still withdraw their vault\\n                // balances in full, they just can't trade that token effectively.\\n                Output18Amount ownerVaultBalance18 =\\n                    Output18Amount.wrap(ownerVaultBalance.scale18(order.validOutputs[outputIOIndex].decimals, 0));\\n                if (Output18Amount.unwrap(orderOutputMax18) > Output18Amount.unwrap(ownerVaultBalance18)) {\\n                    orderOutputMax18 = ownerVaultBalance18;\\n                }\\n            }\\n\\n            // Populate the context with the output max rescaled and vault capped.\\n            context[CONTEXT_CALCULATIONS_COLUMN] =\\n                LibUint256Array.arrayFrom(Output18Amount.unwrap(orderOutputMax18), orderIORatio);\\n\\n            return OrderIOCalculation(\\n                order, outputIOIndex, orderOutputMax18, orderIORatio, context, namespace, calculateOrderKVs\\n            );\\n        }\\n    }\\n\\n    /// Given an order, final input and output amounts and the IO calculation\\n    /// verbatim from `_calculateOrderIO`, dispatch the handle IO entrypoint if\\n    /// it exists and update the order owner's vault balances.\\n    /// @param order The order that is being cleared.\\n    /// @param input The exact token input amount to move into the owner's\\n    /// vault.\\n    /// @param output The exact token output amount to move out of the owner's\\n    /// vault.\\n    /// @param orderIOCalculation The verbatim order IO calculation returned by\\n    /// `_calculateOrderIO`.\\n    function recordVaultIO(\\n        Order memory order,\\n        uint256 input,\\n        uint256 output,\\n        OrderIOCalculation memory orderIOCalculation\\n    ) internal {\\n        orderIOCalculation.context[CONTEXT_VAULT_INPUTS_COLUMN][CONTEXT_VAULT_IO_BALANCE_DIFF] = input;\\n        orderIOCalculation.context[CONTEXT_VAULT_OUTPUTS_COLUMN][CONTEXT_VAULT_IO_BALANCE_DIFF] = output;\\n\\n        if (input > 0) {\\n            // IMPORTANT! THIS MATH MUST BE CHECKED TO AVOID OVERFLOW.\\n            sVaultBalances[order.owner][address(\\n                uint160(orderIOCalculation.context[CONTEXT_VAULT_INPUTS_COLUMN][CONTEXT_VAULT_IO_TOKEN])\\n            )][orderIOCalculation.context[CONTEXT_VAULT_INPUTS_COLUMN][CONTEXT_VAULT_IO_VAULT_ID]] += input;\\n        }\\n        if (output > 0) {\\n            // IMPORTANT! THIS MATH MUST BE CHECKED TO AVOID UNDERFLOW.\\n            sVaultBalances[order.owner][address(\\n                uint160(orderIOCalculation.context[CONTEXT_VAULT_OUTPUTS_COLUMN][CONTEXT_VAULT_IO_TOKEN])\\n            )][orderIOCalculation.context[CONTEXT_VAULT_OUTPUTS_COLUMN][CONTEXT_VAULT_IO_VAULT_ID]] -= output;\\n        }\\n\\n        // Emit the context only once in its fully populated form rather than two\\n        // nearly identical emissions of a partial and full context.\\n        emit Context(msg.sender, orderIOCalculation.context);\\n\\n        // Apply state changes to the interpreter store after the vault balances\\n        // are updated, but before we call handle IO. We want handle IO to see\\n        // a consistent view on sets from calculate IO.\\n        if (orderIOCalculation.kvs.length > 0) {\\n            // Slither false positive. External calls within loops are fine if\\n            // the caller controls which orders are eval'd as they can drop\\n            // failing calls and resubmit a new transaction.\\n            // https://github.com/crytic/slither/issues/880\\n            //slither-disable-next-line calls-loop\\n            order.evaluable.store.set(orderIOCalculation.namespace, orderIOCalculation.kvs);\\n        }\\n\\n        // Only dispatch handle IO entrypoint if it is defined, otherwise it is\\n        // a waste of gas to hit the interpreter a second time.\\n        if (order.handleIO) {\\n            // The handle IO eval is run under the same namespace as the\\n            // calculate order entrypoint.\\n            // Slither false positive. External calls within loops are fine if\\n            // the caller controls which orders are eval'd as they can drop\\n            // failing calls and resubmit a new transaction.\\n            // https://github.com/crytic/slither/issues/880\\n            //slither-disable-next-line calls-loop\\n            (uint256[] memory handleIOStack, uint256[] memory handleIOKVs) = order.evaluable.interpreter.eval(\\n                order.evaluable.store,\\n                orderIOCalculation.namespace,\\n                _handleIODispatch(order.evaluable.expression),\\n                orderIOCalculation.context\\n            );\\n            // There's nothing to be done with the stack.\\n            (handleIOStack);\\n            // Apply state changes to the interpreter store from the handle IO\\n            // entrypoint.\\n            if (handleIOKVs.length > 0) {\\n                // Slither false positive. External calls within loops are fine\\n                // if the caller controls which orders are eval'd as they can\\n                // drop failing calls and resubmit a new transaction.\\n                // https://github.com/crytic/slither/issues/880\\n                //slither-disable-next-line calls-loop\\n                order.evaluable.store.set(orderIOCalculation.namespace, handleIOKVs);\\n            }\\n        }\\n    }\\n\\n    /// Calculates the clear state change given both order calculations for order\\n    /// alice and order bob. The input of each is their output multiplied by\\n    /// their IO ratio and the output of each is the smaller of their maximum\\n    /// output and the counterparty IO * max output.\\n    /// @param aliceOrderIOCalculation Order calculation for Alice.\\n    /// @param bobOrderIOCalculation Order calculation for Bob.\\n    /// @return clearStateChange The clear state change with absolute inputs and\\n    /// outputs for Alice and Bob.\\n    function calculateClearStateChange(\\n        OrderIOCalculation memory aliceOrderIOCalculation,\\n        OrderIOCalculation memory bobOrderIOCalculation\\n    ) internal pure returns (ClearStateChange memory clearStateChange) {\\n        // Calculate the clear state change for Alice.\\n        (clearStateChange.aliceInput, clearStateChange.aliceOutput) =\\n            calculateClearStateAlice(aliceOrderIOCalculation, bobOrderIOCalculation);\\n\\n        // Flip alice and bob to calculate bob's output.\\n        (clearStateChange.bobInput, clearStateChange.bobOutput) =\\n            calculateClearStateAlice(bobOrderIOCalculation, aliceOrderIOCalculation);\\n    }\\n\\n    function calculateClearStateAlice(\\n        OrderIOCalculation memory aliceOrderIOCalculation,\\n        OrderIOCalculation memory bobOrderIOCalculation\\n    ) internal pure returns (uint256 aliceInput, uint256 aliceOutput) {\\n        // Always round IO calculations up so that the counterparty pays more.\\n        // This is the max input that bob can afford, given his own IO ratio\\n        // and maximum spend/output.\\n        Input18Amount bobInputMax18 = Input18Amount.wrap(\\n            Output18Amount.unwrap(bobOrderIOCalculation.outputMax).fixedPointMul(\\n                bobOrderIOCalculation.IORatio, Math.Rounding.Up\\n            )\\n        );\\n        Output18Amount aliceOutputMax18 = aliceOrderIOCalculation.outputMax;\\n        // Alice's doesn't need to provide more output than bob's max input.\\n        if (Output18Amount.unwrap(aliceOutputMax18) > Input18Amount.unwrap(bobInputMax18)) {\\n            aliceOutputMax18 = Output18Amount.wrap(Input18Amount.unwrap(bobInputMax18));\\n        }\\n        // Alice's final output is the scaled version of the 18 decimal output,\\n        // rounded down to benefit Alice.\\n        aliceOutput = Output18Amount.unwrap(aliceOutputMax18).scaleN(\\n            aliceOrderIOCalculation.order.validOutputs[aliceOrderIOCalculation.outputIOIndex].decimals, 0\\n        );\\n\\n        // Alice's input is her bob-capped output * her IO ratio, rounded up.\\n        Input18Amount aliceInput18 = Input18Amount.wrap(\\n            Output18Amount.unwrap(aliceOutputMax18).fixedPointMul(aliceOrderIOCalculation.IORatio, Math.Rounding.Up)\\n        );\\n        aliceInput =\\n        // Use bob's output decimals as alice's input decimals.\\n        //\\n        // This is only safe if we have previously checked that the decimals\\n        // match for alice and bob per token, otherwise bob could manipulate\\n        // alice's intent.\\n        Input18Amount.unwrap(aliceInput18).scaleN(\\n            bobOrderIOCalculation.order.validOutputs[bobOrderIOCalculation.outputIOIndex].decimals, FLAG_ROUND_UP\\n        );\\n    }\\n\\n    function _calculateOrderDispatch(address expression_) internal pure returns (EncodedDispatch) {\\n        return LibEncodedDispatch.encode(expression_, CALCULATE_ORDER_ENTRYPOINT, CALCULATE_ORDER_MAX_OUTPUTS);\\n    }\\n\\n    function _handleIODispatch(address expression_) internal pure returns (EncodedDispatch) {\\n        return LibEncodedDispatch.encode(expression_, HANDLE_IO_ENTRYPOINT, HANDLE_IO_MAX_OUTPUTS);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.math.fixedpoint/src/lib/LibFixedPointDecimalArithmeticOpenZeppelin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport {Math} from \\\"openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\n\\nimport \\\"./FixedPointDecimalConstants.sol\\\";\\n\\nlibrary LibFixedPointDecimalArithmeticOpenZeppelin {\\n    using Math for uint256;\\n\\n    /// Fixed point multiplication in 18 decimal fixed point.\\n    /// Both `a` and `b` MUST be 18 decimal fixed point values.\\n    /// Implemented in terms of Open Zeppelin `Math` library.\\n    /// @param a First term.\\n    /// @param b Second term.\\n    /// @param rounding Rounding direction as per Open Zeppelin `Math`.\\n    /// @return `a` multiplied by `b` in 18 fixed point decimals.\\n    function fixedPointMul(uint256 a, uint256 b, Math.Rounding rounding) internal pure returns (uint256) {\\n        return a.mulDiv(b, FIXED_POINT_ONE, rounding);\\n    }\\n\\n    /// Fixed point division in 18 decimal fixed point.\\n    /// Both `a` and `b` MUST be 18 decimal fixed point values.\\n    /// Implemented in terms of Open Zeppelin `Math` library.\\n    /// @param a First term.\\n    /// @param b Second term.\\n    /// @param rounding Rounding direction as per Open Zeppelin `Math`.\\n    /// @return `a` divided by `b` in 18 fixed point decimals.\\n    function fixedPointDiv(uint256 a, uint256 b, Math.Rounding rounding) internal pure returns (uint256) {\\n        return a.mulDiv(FIXED_POINT_ONE, b, rounding);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.math.fixedpoint/src/lib/LibFixedPointDecimalScale.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./FixedPointDecimalConstants.sol\\\";\\n\\n/// @title FixedPointDecimalScale\\n/// @notice Tools to scale unsigned values to/from 18 decimal fixed point\\n/// representation.\\n///\\n/// Overflows error and underflows are rounded up or down explicitly.\\n///\\n/// The max uint256 as decimal is roughly 1e77 so scaling values comparable to\\n/// 1e18 is unlikely to ever overflow in most contexts. For a typical use case\\n/// involving tokens, the entire supply of a token rescaled up a full 18 decimals\\n/// would still put it \\\"only\\\" in the region of ~1e40 which has a full 30 orders\\n/// of magnitude buffer before running into saturation issues. However, there's\\n/// no theoretical reason that a token or any other use case couldn't use large\\n/// numbers or extremely precise decimals that would push this library to\\n/// overflow point, so it MUST be treated with caution around the edge cases.\\n///\\n/// Scaling down ANY fixed point decimal also reduces the precision which can\\n/// lead to  dust or in the worst case trapped funds if subsequent subtraction\\n/// overflows a rounded-down number. Consider using saturating subtraction for\\n/// safety against previously downscaled values, and whether trapped dust is a\\n/// significant issue. If you need to retain full/arbitrary precision in the case\\n/// of downscaling DO NOT use this library.\\n///\\n/// All rescaling and/or division operations in this library require a rounding\\n/// flag. This allows and forces the caller to specify where dust sits due to\\n/// rounding. For example the caller could round up when taking tokens from\\n/// `msg.sender` and round down when returning them, ensuring that any dust in\\n/// the round trip accumulates in the contract rather than opening an exploit or\\n/// reverting and trapping all funds. This is exactly how the ERC4626 vault spec\\n/// handles dust and is a good reference point in general. Typically the contract\\n/// holding tokens and non-interactive participants should be favoured by\\n/// rounding calculations rather than active participants. This is because we\\n/// assume that an active participant, e.g. `msg.sender`, knowns something we\\n/// don't and is carefully crafting an attack, so we are most conservative and\\n/// suspicious of their inputs and actions.\\nlibrary LibFixedPointDecimalScale {\\n    /// Scales `a` up by a specified number of decimals.\\n    /// @param a The number to scale up.\\n    /// @param scaleUpBy Number of orders of magnitude to scale `b_` up by.\\n    /// Errors if overflows.\\n    /// @return b `a` scaled up by `scaleUpBy`.\\n    function scaleUp(uint256 a, uint256 scaleUpBy) internal pure returns (uint256 b) {\\n        // Checked power is expensive so don't do that.\\n        unchecked {\\n            b = 10 ** scaleUpBy;\\n        }\\n        b = a * b;\\n\\n        // We know exactly when 10 ** X overflows so replay the checked version\\n        // to get the standard Solidity overflow behaviour. The branching logic\\n        // here is still ~230 gas cheaper than unconditionally running the\\n        // overflow checks. We're optimising for standardisation rather than gas\\n        // in the unhappy revert case.\\n        if (scaleUpBy >= OVERFLOW_RESCALE_OOMS) {\\n            b = a == 0 ? 0 : 10 ** scaleUpBy;\\n        }\\n    }\\n\\n    /// Identical to `scaleUp` but saturates instead of reverting on overflow.\\n    /// @param a As per `scaleUp`.\\n    /// @param scaleUpBy As per `scaleUp`.\\n    /// @return c As per `scaleUp` but saturates as `type(uint256).max` on\\n    /// overflow.\\n    function scaleUpSaturating(uint256 a, uint256 scaleUpBy) internal pure returns (uint256 c) {\\n        unchecked {\\n            if (scaleUpBy >= OVERFLOW_RESCALE_OOMS) {\\n                c = a == 0 ? 0 : type(uint256).max;\\n            } else {\\n                // Adapted from saturatingMath.\\n                // Inlining everything here saves ~250-300+ gas relative to slow.\\n                uint256 b_ = 10 ** scaleUpBy;\\n                c = a * b_;\\n                // Checking b_ here allows us to skip an \\\"is zero\\\" check because even\\n                // 10 ** 0 = 1, so we have a positive lower bound on b_.\\n                c = c / b_ == a ? c : type(uint256).max;\\n            }\\n        }\\n    }\\n\\n    /// Scales `a` down by a specified number of decimals, rounding down.\\n    /// Used internally by several other functions in this lib.\\n    /// @param a The number to scale down.\\n    /// @param scaleDownBy Number of orders of magnitude to scale `a` down by.\\n    /// Overflows if greater than 77.\\n    /// @return c `a` scaled down by `scaleDownBy` and rounded down.\\n    function scaleDown(uint256 a, uint256 scaleDownBy) internal pure returns (uint256) {\\n        unchecked {\\n            return scaleDownBy >= OVERFLOW_RESCALE_OOMS ? 0 : a / (10 ** scaleDownBy);\\n        }\\n    }\\n\\n    /// Scales `a` down by a specified number of decimals, rounding up.\\n    /// Used internally by several other functions in this lib.\\n    /// @param a The number to scale down.\\n    /// @param scaleDownBy Number of orders of magnitude to scale `a` down by.\\n    /// Overflows if greater than 77.\\n    /// @return c `a` scaled down by `scaleDownBy` and rounded up.\\n    function scaleDownRoundUp(uint256 a, uint256 scaleDownBy) internal pure returns (uint256 c) {\\n        unchecked {\\n            if (scaleDownBy >= OVERFLOW_RESCALE_OOMS) {\\n                c = a == 0 ? 0 : 1;\\n            } else {\\n                uint256 b = 10 ** scaleDownBy;\\n                c = a / b;\\n\\n                // Intentionally doing a divide before multiply here to detect\\n                // the need to round up.\\n                //slither-disable-next-line divide-before-multiply\\n                if (a != c * b) {\\n                    c += 1;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// Scale a fixed point decimal of some scale factor to 18 decimals.\\n    /// @param a Some fixed point decimal value.\\n    /// @param decimals The number of fixed decimals of `a`.\\n    /// @param flags Controls rounding and saturation.\\n    /// @return `a` scaled to 18 decimals.\\n    function scale18(uint256 a, uint256 decimals, uint256 flags) internal pure returns (uint256) {\\n        unchecked {\\n            if (FIXED_POINT_DECIMALS > decimals) {\\n                uint256 scaleUpBy = FIXED_POINT_DECIMALS - decimals;\\n                if (flags & FLAG_SATURATE > 0) {\\n                    return scaleUpSaturating(a, scaleUpBy);\\n                } else {\\n                    return scaleUp(a, scaleUpBy);\\n                }\\n            } else if (decimals > FIXED_POINT_DECIMALS) {\\n                uint256 scaleDownBy = decimals - FIXED_POINT_DECIMALS;\\n                if (flags & FLAG_ROUND_UP > 0) {\\n                    return scaleDownRoundUp(a, scaleDownBy);\\n                } else {\\n                    return scaleDown(a, scaleDownBy);\\n                }\\n            } else {\\n                return a;\\n            }\\n        }\\n    }\\n\\n    /// Scale an 18 decimal fixed point value to some other scale.\\n    /// Exactly the inverse behaviour of `scale18`. Where `scale18` would scale\\n    /// up, `scaleN` scales down, and vice versa.\\n    /// @param a An 18 decimal fixed point number.\\n    /// @param targetDecimals The new scale of `a`.\\n    /// @param flags Controls rounding and saturation.\\n    /// @return `a` rescaled from 18 to `targetDecimals`.\\n    function scaleN(uint256 a, uint256 targetDecimals, uint256 flags) internal pure returns (uint256) {\\n        unchecked {\\n            if (FIXED_POINT_DECIMALS > targetDecimals) {\\n                uint256 scaleDownBy = FIXED_POINT_DECIMALS - targetDecimals;\\n                if (flags & FLAG_ROUND_UP > 0) {\\n                    return scaleDownRoundUp(a, scaleDownBy);\\n                } else {\\n                    return scaleDown(a, scaleDownBy);\\n                }\\n            } else if (targetDecimals > FIXED_POINT_DECIMALS) {\\n                uint256 scaleUpBy = targetDecimals - FIXED_POINT_DECIMALS;\\n                if (flags & FLAG_SATURATE > 0) {\\n                    return scaleUpSaturating(a, scaleUpBy);\\n                } else {\\n                    return scaleUp(a, scaleUpBy);\\n                }\\n            } else {\\n                return a;\\n            }\\n        }\\n    }\\n\\n    /// Scale a fixed point up or down by `ooms` orders of magnitude.\\n    /// Notably `scaleBy` is a SIGNED integer so scaling down by negative OOMS\\n    /// IS supported.\\n    /// @param a Some integer of any scale.\\n    /// @param ooms OOMs to scale `a` up or down by. This is a SIGNED int8\\n    /// which means it can be negative, and also means that sign extension MUST\\n    /// be considered if changing it to another type.\\n    /// @param flags Controls rounding and saturating.\\n    /// @return `a` rescaled according to `ooms`.\\n    function scaleBy(uint256 a, int8 ooms, uint256 flags) internal pure returns (uint256) {\\n        unchecked {\\n            if (ooms > 0) {\\n                if (flags & FLAG_SATURATE > 0) {\\n                    return scaleUpSaturating(a, uint8(ooms));\\n                } else {\\n                    return scaleUp(a, uint8(ooms));\\n                }\\n            } else if (ooms < 0) {\\n                // We know that ooms is negative here, so we can convert it\\n                // to an absolute value with bitwise NOT + 1.\\n                // This is slightly less gas than multiplying by negative 1 and\\n                // casting it, and handles the case of -128 without overflow.\\n                uint8 scaleDownBy = uint8(~ooms) + 1;\\n                if (flags & FLAG_ROUND_UP > 0) {\\n                    return scaleDownRoundUp(a, scaleDownBy);\\n                } else {\\n                    return scaleDown(a, scaleDownBy);\\n                }\\n            } else {\\n                return a;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibEncodedDispatch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../../interface/IInterpreterV1.sol\\\";\\n\\n/// @title LibEncodedDispatch\\n/// @notice Establishes and implements a convention for encoding an interpreter\\n/// dispatch. Handles encoding of several things required for efficient dispatch.\\nlibrary LibEncodedDispatch {\\n    /// Builds an `EncodedDispatch` from its constituent parts.\\n    /// @param expression The onchain address of the expression to run.\\n    /// @param sourceIndex The index of the source to run within the expression\\n    /// as an entrypoint.\\n    /// @param maxOutputs The maximum outputs the caller can meaningfully use.\\n    /// If the interpreter returns a larger stack than this it is merely wasting\\n    /// gas across the external call boundary.\\n    /// @return The encoded dispatch.\\n    function encode(address expression, SourceIndex sourceIndex, uint16 maxOutputs)\\n        internal\\n        pure\\n        returns (EncodedDispatch)\\n    {\\n        return EncodedDispatch.wrap(\\n            (uint256(uint160(expression)) << 32) | (uint256(SourceIndex.unwrap(sourceIndex)) << 16) | maxOutputs\\n        );\\n    }\\n\\n    /// Decodes an `EncodedDispatch` to its constituent parts.\\n    /// @param dispatch_ The `EncodedDispatch` to decode.\\n    /// @return The expression, source index, and max outputs as per `encode`.\\n    function decode(EncodedDispatch dispatch_) internal pure returns (address, SourceIndex, uint16) {\\n        return (\\n            address(uint160(EncodedDispatch.unwrap(dispatch_) >> 32)),\\n            SourceIndex.wrap(uint16(EncodedDispatch.unwrap(dispatch_) >> 16)),\\n            uint16(EncodedDispatch.unwrap(dispatch_))\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibContext.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"rain.solmem/lib/LibUint256Array.sol\\\";\\nimport \\\"rain.lib.hash/LibHashNoAlloc.sol\\\";\\n\\nimport {SignatureChecker} from \\\"openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport {ECDSA} from \\\"openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\\\";\\n\\nimport \\\"../../interface/IInterpreterCallerV2.sol\\\";\\n\\n/// Thrown when the ith signature from a list of signed contexts is invalid.\\nerror InvalidSignature(uint256 i);\\n\\n/// @title LibContext\\n/// @notice Conventions for working with context as a calling contract. All of\\n/// this functionality is OPTIONAL but probably useful for the majority of use\\n/// cases. By building and authenticating onchain, caller provided and signed\\n/// contexts all in a standard way the overall usability of context is greatly\\n/// improved for expression authors and readers. Any calling contract that can\\n/// match the context expectations of an existing expression is one large step\\n/// closer to compatibility and portability, inheriting network effects of what\\n/// has already been authored elsewhere.\\nlibrary LibContext {\\n    using LibUint256Array for uint256[];\\n\\n    /// The base context is the `msg.sender` and address of the calling contract.\\n    /// As the interpreter itself is called via an external interface and may be\\n    /// statically calling itself, it MAY NOT have any ability to inspect either\\n    /// of these values. Even if this were not the case the calling contract\\n    /// cannot assume the existence of some opcode(s) in the interpreter that\\n    /// inspect the caller, so providing these two values as context is\\n    /// sufficient to decouple the calling contract from the interpreter. It is\\n    /// STRONGLY RECOMMENDED that even if the calling contract has \\\"no context\\\"\\n    /// that it still provides this base to every `eval`.\\n    ///\\n    /// Calling contracts DO NOT need to call this directly. It is built and\\n    /// merged automatically into the standard context built by `build`.\\n    ///\\n    /// @return The `msg.sender` and address of the calling contract using this\\n    /// library, as a context-compatible array.\\n    function base() internal view returns (uint256[] memory) {\\n        return LibUint256Array.arrayFrom(uint256(uint160(msg.sender)), uint256(uint160(address(this))));\\n    }\\n\\n    /// Standard hashing process over a single `SignedContextV1`. Notably used\\n    /// to hash a list as `SignedContextV1[]` but could also be used to hash a\\n    /// single `SignedContextV1` in isolation. Avoids allocating memory by\\n    /// hashing each struct field in sequence within the memory scratch space.\\n    /// @param signedContext The signed context to hash.\\n    /// @param hashed The hashed signed context.\\n    function hash(SignedContextV1 memory signedContext) internal pure returns (bytes32 hashed) {\\n        uint256 signerOffset = SIGNED_CONTEXT_SIGNER_OFFSET;\\n        uint256 contextOffset = SIGNED_CONTEXT_CONTEXT_OFFSET;\\n        uint256 signatureOffset = SIGNED_CONTEXT_SIGNATURE_OFFSET;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, keccak256(add(signedContext, signerOffset), 0x20))\\n\\n            let context_ := mload(add(signedContext, contextOffset))\\n            mstore(0x20, keccak256(add(context_, 0x20), mul(mload(context_), 0x20)))\\n\\n            mstore(0, keccak256(0, 0x40))\\n\\n            let signature_ := mload(add(signedContext, signatureOffset))\\n            mstore(0x20, keccak256(add(signature_, 0x20), mload(signature_)))\\n\\n            hashed := keccak256(0, 0x40)\\n        }\\n    }\\n\\n    /// Standard hashing process over a list of signed contexts. Situationally\\n    /// useful if the calling contract wants to record that it has seen a set of\\n    /// signed data then later compare it against some input (e.g. to ensure that\\n    /// many calls of some function all share the same input values). Note that\\n    /// unlike the internals of `build`, this hashes over the signer and the\\n    /// signature, to ensure that some data cannot be re-signed and used under\\n    /// a different provenance later.\\n    /// @param signedContexts The list of signed contexts to hash over.\\n    /// @return hashed The hash of the signed contexts.\\n    function hash(SignedContextV1[] memory signedContexts) internal pure returns (bytes32 hashed) {\\n        uint256 cursor;\\n        uint256 end;\\n        bytes32 hashNil = HASH_NIL;\\n        assembly (\\\"memory-safe\\\") {\\n            cursor := add(signedContexts, 0x20)\\n            end := add(cursor, mul(mload(signedContexts), 0x20))\\n            mstore(0, hashNil)\\n        }\\n\\n        SignedContextV1 memory signedContext;\\n        bytes32 mem0;\\n        while (cursor < end) {\\n            assembly (\\\"memory-safe\\\") {\\n                signedContext := mload(cursor)\\n                // Subhash will write to 0 for its own hashing so keep a copy\\n                // before it gets overwritten.\\n                mem0 := mload(0)\\n            }\\n            bytes32 subHash = hash(signedContext);\\n            assembly (\\\"memory-safe\\\") {\\n                mstore(0, mem0)\\n                mstore(0x20, subHash)\\n                mstore(0, keccak256(0, 0x40))\\n                cursor := add(cursor, 0x20)\\n            }\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            hashed := mload(0)\\n        }\\n    }\\n\\n    /// Builds a standard 2-dimensional context array from base, calling and\\n    /// signed contexts. Note that \\\"columns\\\" of a context array refer to each\\n    /// `uint256[]` and each item within a `uint256[]` is a \\\"row\\\".\\n    ///\\n    /// @param baseContext Anything the calling contract can provide which MAY\\n    /// include input from the `msg.sender` of the calling contract. The default\\n    /// base context from `LibContext.base()` DOES NOT need to be provided by the\\n    /// caller, this matrix MAY be empty and will be simply merged into the final\\n    /// context. The base context matrix MUST contain a consistent number of\\n    /// columns from the calling contract so that the expression can always\\n    /// predict how many unsigned columns there will be when it runs.\\n    /// @param signedContexts Signed contexts are provided by the `msg.sender`\\n    /// but signed by a third party. The expression (author) defines _who_ may\\n    /// sign and the calling contract authenticates the signature over the\\n    /// signed data. Technically `build` handles all the authentication inline\\n    /// for the calling contract so if some context builds it can be treated as\\n    /// authentic. The builder WILL REVERT if any of the signatures are invalid.\\n    /// Note two things about the structure of the final built context re: signed\\n    /// contexts:\\n    /// - The first column is a list of the signers in order of what they signed\\n    /// - The `msg.sender` can provide an arbitrary number of signed contexts so\\n    ///   expressions DO NOT know exactly how many columns there are.\\n    /// The expression is responsible for defining e.g. a domain separator in a\\n    /// position that would force signed context to be provided in the \\\"correct\\\"\\n    /// order, rather than relying on the `msg.sender` to honestly present data\\n    /// in any particular structure/order.\\n    function build(uint256[][] memory baseContext, SignedContextV1[] memory signedContexts)\\n        internal\\n        view\\n        returns (uint256[][] memory)\\n    {\\n        unchecked {\\n            uint256[] memory signers = new uint256[](signedContexts.length);\\n\\n            // - LibContext.base() + whatever we are provided.\\n            // - signed contexts + signers if they exist else nothing.\\n            uint256 contextLength = 1 + baseContext.length + (signedContexts.length > 0 ? signedContexts.length + 1 : 0);\\n\\n            uint256[][] memory context = new uint256[][](contextLength);\\n            uint256 offset = 0;\\n            context[offset] = LibContext.base();\\n\\n            for (uint256 i = 0; i < baseContext.length; i++) {\\n                offset++;\\n                context[offset] = baseContext[i];\\n            }\\n\\n            if (signedContexts.length > 0) {\\n                offset++;\\n                context[offset] = signers;\\n\\n                for (uint256 i = 0; i < signedContexts.length; i++) {\\n                    if (\\n                        // Unlike `LibContext.hash` we can only hash over\\n                        // the context as it's impossible for a signature\\n                        // to sign itself.\\n                        // Note the use of encodePacked here over a\\n                        // single array, not including the length. This\\n                        // would be a security issue if multiple dynamic\\n                        // length values were hashed over together as\\n                        // then many possible inputs could collide with\\n                        // a single encoded output.\\n                        !SignatureChecker.isValidSignatureNow(\\n                            signedContexts[i].signer,\\n                            ECDSA.toEthSignedMessageHash(LibHashNoAlloc.hashWords(signedContexts[i].context)),\\n                            signedContexts[i].signature\\n                        )\\n                    ) {\\n                        revert InvalidSignature(i);\\n                    }\\n\\n                    signers[i] = uint256(uint160(signedContexts[i].signer));\\n                    offset++;\\n                    context[offset] = signedContexts[i].context;\\n                }\\n            }\\n\\n            return context;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/abstract/DeployerDiscoverableMetaV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"rain.metadata/IMetaV1.sol\\\";\\nimport \\\"rain.metadata/LibMeta.sol\\\";\\nimport \\\"../lib/caller/LibDeployerDiscoverable.sol\\\";\\n\\n/// Construction config for `DeployerDiscoverableMetaV2`.\\n/// @param deployer Deployer the calling contract will be discoverable under.\\n/// @param meta MetaV1 data to emit before touching the deployer.\\nstruct DeployerDiscoverableMetaV2ConstructionConfig {\\n    address deployer;\\n    bytes meta;\\n}\\n\\n/// @title DeployerDiscoverableMetaV2\\n/// @notice Upon construction, checks metadata against a known hash, emits it\\n/// then touches the deployer (deploy an empty expression). This allows indexers\\n/// to discover the metadata of the `DeployerDiscoverableMetaV2` contract by\\n/// indexing the deployer. In this way the deployer acts as a pseudo-registry by\\n/// virtue of it being a natural hub for interactions with calling contracts.\\nabstract contract DeployerDiscoverableMetaV2 is IMetaV1 {\\n    constructor(bytes32 metaHash, DeployerDiscoverableMetaV2ConstructionConfig memory config) {\\n        LibMeta.checkMetaHashed(metaHash, config.meta);\\n        emit MetaV1(msg.sender, uint256(uint160(address(this))), config.meta);\\n        LibDeployerDiscoverable.touchDeployerV2(config.deployer);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/bytecode/LibBytecode.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.19;\\n\\nimport \\\"../../interface/IInterpreterV1.sol\\\";\\nimport \\\"rain.solmem/lib/LibPointer.sol\\\";\\nimport \\\"rain.solmem/lib/LibBytes.sol\\\";\\nimport \\\"rain.solmem/lib/LibMemCpy.sol\\\";\\n\\n/// Thrown when a bytecode source offset is out of bounds.\\nerror SourceOffsetOutOfBounds(bytes bytecode, uint256 sourceIndex);\\n\\nlibrary LibBytecode {\\n    using LibPointer for Pointer;\\n    using LibBytes for bytes;\\n    using LibMemCpy for Pointer;\\n\\n    function sourceCount(bytes memory bytecode) internal pure returns (uint256 count) {\\n        if (bytecode.length == 0) {\\n            return 0;\\n        }\\n        assembly {\\n            // The first byte of rain bytecode is the count of how many sources\\n            // there are.\\n            count := byte(0, mload(add(bytecode, 0x20)))\\n        }\\n    }\\n\\n    function sourceRelativeOffset(bytes memory bytecode, uint256 sourceIndex) internal pure returns (uint256 offset) {\\n        assembly {\\n            // After the first byte, all the relative offset pointers are\\n            // stored sequentially as 16 bit values.\\n            offset := and(mload(add(add(bytecode, 3), mul(sourceIndex, 2))), 0xFFFF)\\n        }\\n        // This doesn't replace a full integrity check but gives a sanity check\\n        // that the offset is within the bytecode. This also covers the functions\\n        // that use this function, to generate absolute pointers and read from\\n        // the source header after the offset, so they don't need to check\\n        // bounds redundantly.\\n        unchecked {\\n            uint256 count = sourceCount(bytecode);\\n            // Source count byte + 2 bytes per source offset + offset + 4 byte source header.\\n            uint256 expectedMinBytes = 1 + count * 2 + offset + 4;\\n            if (bytecode.length < expectedMinBytes || sourceIndex >= count) {\\n                revert SourceOffsetOutOfBounds(bytecode, sourceIndex);\\n            }\\n        }\\n    }\\n\\n    function sourcePointer(bytes memory bytecode, uint256 sourceIndex) internal pure returns (Pointer pointer) {\\n        unchecked {\\n            uint256 sourcesStartOffset = 1 + sourceCount(bytecode) * 2;\\n            uint256 offset = sourceRelativeOffset(bytecode, sourceIndex);\\n            assembly {\\n                pointer := add(add(add(bytecode, 0x20), sourcesStartOffset), offset)\\n            }\\n        }\\n    }\\n\\n    function sourceOpsLength(bytes memory bytecode, uint256 sourceIndex) internal pure returns (uint256 length) {\\n        unchecked {\\n            Pointer pointer = sourcePointer(bytecode, sourceIndex);\\n            assembly (\\\"memory-safe\\\") {\\n                length := byte(0, mload(pointer))\\n            }\\n        }\\n    }\\n\\n    function sourceStackAllocation(bytes memory bytecode, uint256 sourceIndex)\\n        internal\\n        pure\\n        returns (uint256 allocation)\\n    {\\n        unchecked {\\n            Pointer pointer = sourcePointer(bytecode, sourceIndex);\\n            assembly (\\\"memory-safe\\\") {\\n                allocation := byte(1, mload(pointer))\\n            }\\n        }\\n    }\\n\\n    function sourceInputsLength(bytes memory bytecode, uint256 sourceIndex) internal pure returns (uint256 length) {\\n        unchecked {\\n            Pointer pointer = sourcePointer(bytecode, sourceIndex);\\n            assembly (\\\"memory-safe\\\") {\\n                length := byte(2, mload(pointer))\\n            }\\n        }\\n    }\\n\\n    function sourceOutputsLength(bytes memory bytecode, uint256 sourceIndex) internal pure returns (uint256 length) {\\n        unchecked {\\n            Pointer pointer = sourcePointer(bytecode, sourceIndex);\\n            assembly (\\\"memory-safe\\\") {\\n                length := byte(3, mload(pointer))\\n            }\\n        }\\n    }\\n\\n    /// Backwards compatibility with the old way of representing sources.\\n    /// Requires allocation and copying so it isn't particularly efficient, but\\n    /// allows us to use the new bytecode format with old interpreter code. Not\\n    /// recommended for production code but useful for testing.\\n    function bytecodeToSources(bytes memory bytecode) internal pure returns (bytes[] memory) {\\n        unchecked {\\n            uint256 count = sourceCount(bytecode);\\n            bytes[] memory sources = new bytes[](count);\\n            for (uint256 i = 0; i < count; i++) {\\n                // Skip over the prefix 4 bytes.\\n                Pointer pointer = sourcePointer(bytecode, i).unsafeAddBytes(4);\\n                uint256 length = sourceOpsLength(bytecode, i) * 4;\\n                bytes memory source = new bytes(length);\\n                pointer.unsafeCopyBytesTo(source.dataPointer(), length);\\n                // Move the opcode index one byte for each opcode, into the input\\n                // position, as legacly sources did not have input bytes.\\n                assembly (\\\"memory-safe\\\") {\\n                    for {\\n                        let cursor := add(source, 0x20)\\n                        let end := add(cursor, length)\\n                    } lt(cursor, end) { cursor := add(cursor, 4) } {\\n                        mstore8(add(cursor, 1), byte(0, mload(cursor)))\\n                        mstore8(cursor, 0)\\n                    }\\n                }\\n                sources[i] = source;\\n            }\\n            return sources;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/unstable/IOrderBookV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../ierc3156/IERC3156FlashLender.sol\\\";\\nimport {\\n    EvaluableConfigV2, IExpressionDeployerV2, Evaluable\\n} from \\\"lib/rain.interpreter/src/lib/caller/LibEvaluable.sol\\\";\\nimport \\\"lib/rain.interpreter/src/interface/IInterpreterCallerV2.sol\\\";\\n\\n/// Import unmodified structures from older versions of `IOrderBook`.\\nimport {IO, Order, TakeOrderConfig, ClearConfig, ClearStateChange} from \\\"../IOrderBookV2.sol\\\";\\n\\n/// Thrown when take orders is called with no orders.\\nerror NoOrders();\\n\\n/// Thrown when take orders is called with a zero maximum input.\\nerror ZeroMaximumInput();\\n\\n/// Config the order owner may provide to define their order. The `msg.sender`\\n/// that adds an order cannot modify the owner nor bypass the integrity check of\\n/// the expression deployer that they specify. However they MAY specify a\\n/// deployer with a corrupt integrity check, so counterparties and clearers MUST\\n/// check the DISpair of the order and avoid untrusted pairings.\\n/// @param validInputs As per `validInputs` on the `Order`.\\n/// @param validOutputs As per `validOutputs` on the `Order`.\\n/// @param evaluableConfig Standard `EvaluableConfig` used to produce the\\n/// `Evaluable` on the order.\\n/// @param meta Arbitrary bytes that will NOT be used in the order evaluation\\n/// but MUST be emitted as a Rain `MetaV1` when the order is placed so can be\\n/// used by offchain processes.\\nstruct OrderConfigV2 {\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n    EvaluableConfigV2 evaluableConfig;\\n    bytes meta;\\n}\\n\\n/// Config for a list of orders to take sequentially as part of a `takeOrders`\\n/// call.\\n/// @param minimumInput Minimum input from the perspective of the order taker.\\n/// @param maximumInput Maximum input from the perspective of the order taker.\\n/// @param maximumIORatio Maximum IO ratio as calculated by the order being\\n/// taken. The input is from the perspective of the order so higher ratio means\\n/// worse deal for the order taker.\\n/// @param orders Ordered list of orders that will be taken until the limit is\\n/// hit. Takers are expected to prioritise orders that appear to be offering\\n/// better deals i.e. lower IO ratios. This prioritisation and sorting MUST\\n/// happen offchain, e.g. via. some simulator.\\n/// @param data If nonzero length, triggers `onTakeOrders` on the caller of\\n/// `takeOrders` with this data. This allows the caller to perform arbitrary\\n/// onchain actions between receiving their input tokens, before having to send\\n/// their output tokens.\\nstruct TakeOrdersConfigV2 {\\n    uint256 minimumInput;\\n    uint256 maximumInput;\\n    uint256 maximumIORatio;\\n    TakeOrderConfig[] orders;\\n    bytes data;\\n}\\n\\n/// @title IOrderBookV3\\n/// @notice An orderbook that deploys _strategies_ represented as interpreter\\n/// expressions rather than individual orders. The order book contract itself\\n/// behaves similarly to an `ERC4626` vault but with much more fine grained\\n/// control over how tokens are allocated and moved internally by their owners,\\n/// and without any concept of \\\"shares\\\". Token owners MAY deposit and withdraw\\n/// their tokens under arbitrary vault IDs on a per-token basis, then define\\n/// orders that specify how tokens move between vaults according to an expression.\\n/// The expression returns a maximum amount and a token input/output ratio from\\n/// the perpective of the order. When two expressions intersect, as in their\\n/// ratios are the inverse of each other, then tokens can move between vaults.\\n///\\n/// For example, consider order A with input TKNA and output TKNB with a constant\\n/// ratio of 100:1. This order in isolation has no ability to move tokens. If\\n/// an order B appears with input TKNB and output TKNA and a ratio of 1:100 then\\n/// this is a perfect match with order A. In this case 100 TKNA will move from\\n/// order B to order A and 1 TKNB will move from order A to order B.\\n///\\n/// IO ratios are always specified as input:output and are 18 decimal fixed point\\n/// values. The maximum amount that can be moved in the current clearance is also\\n/// set by the order expression as an 18 decimal fixed point value.\\n///\\n/// Typically orders will not clear when their match is exactly 1:1 as the\\n/// clearer needs to pay gas to process the match. Each order will get exactly\\n/// the ratio it calculates when it does clear so if there is _overlap_ in the\\n/// ratios then the clearer keeps the difference. In our above example, consider\\n/// order B asking a ratio of 1:110 instead of 1:100. In this case 100 TKNA will\\n/// move from order B to order A and 10 TKNA will move to the clearer's vault and\\n/// 1 TKNB will move from order A to order B. In the case of fixed prices this is\\n/// not very interesting as order B could more simply take order A directly for\\n/// cheaper rather than involving a third party. Indeed, Orderbook supports a\\n/// direct \\\"take orders\\\" method that works similar to a \\\"market buy\\\". In the case\\n/// of dynamic expression based ratios, it allows both order A and order B to\\n/// clear non-interactively according to their strategy, trading off active\\n/// management, dealing with front-running, MEV, etc. for zero-gas and\\n/// exact-ratio clearance.\\n///\\n/// The general invariant for clearing and take orders is:\\n///\\n/// ```\\n/// ratioA = InputA / OutputA\\n/// ratioB = InputB / OutputB\\n/// ratioA * ratioB = ( InputA * InputB ) / ( OutputA * OutputB )\\n/// OutputA >= InputB\\n/// OutputB >= InputA\\n///\\n/// \u2234 ratioA * ratioB <= 1\\n/// ```\\n///\\n/// Orderbook is `IERC3156FlashLender` compliant with a 0 fee flash loan\\n/// implementation to allow external liquidity from other onchain DEXes to match\\n/// against orderbook expressions. All deposited tokens across all vaults are\\n/// available for flashloan, the flashloan MAY BE REPAID BY CALLING TAKE ORDER\\n/// such that Orderbook's liability to its vaults is decreased by an incoming\\n/// trade from the flashloan borrower. See `ZeroExOrderBookFlashBorrower` for\\n/// an example of how this works in practise.\\n///\\n/// Orderbook supports many to many input/output token relationship, for example\\n/// some order can specify an array of stables it would be willing to accept in\\n/// return for some ETH. This removes the need for a combinatorial explosion of\\n/// order strategies between like assets but introduces the issue of token\\n/// decimal handling. End users understand that \\\"one\\\" USDT is roughly equal to\\n/// \\\"one\\\" DAI, but onchain this is incorrect by _12 orders of magnitude_. This\\n/// is because \\\"one\\\" DAI is `1e18` tokens and \\\"one\\\" USDT is `1e6` tokens. The\\n/// orderbook is allowing orders to deploy expressions that define _economic\\n/// equivalence_ but this doesn't map 1:1 with numeric equivalence in a many to\\n/// many setup behind token decimal convensions. The solution is to require that\\n/// end users who place orders provide the decimals of each token they include\\n/// in their valid IO lists, and to calculate all amounts and ratios in their\\n/// expressions _as though they were 18 decimal fixed point values_. Orderbook\\n/// will then automatically rescale the expression values before applying the\\n/// final vault movements. If an order provides the \\\"wrong\\\" decimal values for\\n/// some token then it will simply calculate its own ratios and amounts\\n/// incorrectly which will either lead to no matching orders or a very bad trade\\n/// for the order owner. There is no way that misrepresenting decimals can attack\\n/// some other order by a counterparty. Orderbook DOES NOT read decimals from\\n/// tokens onchain because A. this would be gas for an external call to a cold\\n/// token contract and B. the ERC20 standard specifically states NOT to read\\n/// decimals from the interface onchain.\\n///\\n/// Token amounts and ratios returned by calculate order MUST be 18 decimal fixed\\n/// point values. Token amounts input to handle IO MUST be the exact absolute\\n/// values that move between the vaults, i.e. NOT rescaled to 18 decimals. The\\n/// author of the handle IO expression MUST use the token decimals and amounts to\\n/// rescale themselves if they want that logic, notably the expression author\\n/// will need to specify the desired rounding behaviour in the rescaling process.\\n///\\n/// When two orders clear there are NO TOKEN MOVEMENTS, only internal vault\\n/// balances are updated from the input and output vaults. Typically this results\\n/// in less gas per clear than calling external token transfers and also avoids\\n/// issues with reentrancy, allowances, external balances etc. This also means\\n/// that REBASING TOKENS AND TOKENS WITH DYNAMIC BALANCE ARE NOT SUPPORTED.\\n/// Orderbook ONLY WORKS IF TOKEN BALANCES ARE 1:1 WITH ADDITION/SUBTRACTION PER\\n/// VAULT MOVEMENT.\\n///\\n/// Dust due to rounding errors always favours the order. Output max is rounded\\n/// down and IO ratios are rounded up. Input and output amounts are always\\n/// converted to absolute values before applying to vault balances such that\\n/// orderbook always retains fully collateralised inventory of underlying token\\n/// balances to support withdrawals, with the caveat that dynamic token balanes\\n/// are not supported.\\n///\\n/// When an order clears it is NOT removed. Orders remain active until the owner\\n/// deactivates them. This is gas efficient as order owners MAY deposit more\\n/// tokens in a vault with an order against it many times and the order strategy\\n/// will continue to be clearable according to its expression. As vault IDs are\\n/// `uint256` values there are effectively infinite possible vaults for any token\\n/// so there is no limit to how many active orders any address can have at one\\n/// time. This also allows orders to be daisy chained arbitrarily where output\\n/// vaults for some order are the input vaults for some other order.\\n///\\n/// Expression storage is namespaced by order owner, so gets and sets are unique\\n/// to each onchain address. Order owners MUST TAKE CARE not to override their\\n/// storage sets globally across all their orders, which they can do most simply\\n/// by hashing the order hash into their get/set keys inside the expression. This\\n/// gives maximum flexibility for shared state across orders without allowing\\n/// order owners to attack and overwrite values stored by orders placed by their\\n/// counterparty.\\n///\\n/// Note that each order specifies its own interpreter and deployer so the\\n/// owner is responsible for not corrupting their own calculations with bad\\n/// interpreters. This also means the Orderbook MUST assume the interpreter, and\\n/// notably the interpreter's store, is malicious and guard against reentrancy\\n/// etc.\\n///\\n/// As Orderbook supports any expression that can run on any `IInterpreterV1` and\\n/// counterparties are available to the order, order strategies are free to\\n/// implement KYC/membership, tracking, distributions, stock, buybacks, etc. etc.\\n///\\n/// Main differences between `IOrderBookV2` and `IOderBookV3`:\\n/// - Most structs are now primitives to save gas.\\n/// - Order hash is `bytes32`.\\n/// - `deposit` and `withdraw` MUST revert if the amount is zero.\\n/// - adding an order MUST revert if there is no calculation entrypoint.\\n/// - adding an order MUST revert if there is no handle IO entrypoint.\\n/// - adding an order MUST revert if there are no inputs.\\n/// - adding an order MUST revert if there are no outputs.\\n/// - adding and removing orders MUST return a boolean indicating if the state\\n/// changed.\\n/// - new `orderExists` method.\\ninterface IOrderBookV3 is IERC3156FlashLender, IInterpreterCallerV2 {\\n    /// MUST be thrown by `deposit` if the amount is zero.\\n    /// @param sender `msg.sender` depositing tokens.\\n    /// @param token The token being deposited.\\n    /// @param vaultId The vault ID the tokens are being deposited under.\\n    error ZeroDepositAmount(address sender, address token, uint256 vaultId);\\n\\n    /// MUST be thrown by `withdraw` if the amount _requested_ to withdraw is\\n    /// zero. The withdrawal MAY still not move any tokens if the vault balance\\n    /// is zero, or the withdrawal is used to repay a flash loan.\\n    /// @param sender `msg.sender` withdrawing tokens.\\n    /// @param token The token being withdrawn.\\n    /// @param vaultId The vault ID the tokens are being withdrawn from.\\n    error ZeroWithdrawTargetAmount(address sender, address token, uint256 vaultId);\\n\\n    /// MUST be thrown by `addOrder` if the order has no associated calculation.\\n    /// @param sender `msg.sender` adding the order.\\n    error OrderNoSources(address sender);\\n\\n    /// MUST be thrown by `addOrder` if the order has no associated handle IO.\\n    /// @param sender `msg.sender` adding the order.\\n    error OrderNoHandleIO(address sender);\\n\\n    /// MUST be thrown by `addOrder` if the order has no inputs.\\n    /// @param sender `msg.sender` adding the order.\\n    error OrderNoInputs(address sender);\\n\\n    /// MUST be thrown by `addOrder` if the order has no outputs.\\n    /// @param sender `msg.sender` adding the order.\\n    error OrderNoOutputs(address sender);\\n\\n    /// Some tokens have been deposited to a vault.\\n    /// @param sender `msg.sender` depositing tokens. Delegated deposits are NOT\\n    /// supported.\\n    /// @param token The token being deposited.\\n    /// @param vaultId The vault ID the tokens are being deposited under.\\n    /// @param amount The amount of tokens deposited.\\n    event Deposit(address sender, address token, uint256 vaultId, uint256 amount);\\n\\n    /// Some tokens have been withdrawn from a vault.\\n    /// @param sender `msg.sender` withdrawing tokens. Delegated withdrawals are\\n    /// NOT supported.\\n    /// @param token The token being withdrawn.\\n    /// @param vaultId The vault ID the tokens are being withdrawn from.\\n    /// @param targetAmount The amount of tokens requested to withdraw.\\n    /// @param amount The amount of tokens withdrawn, can be less than the\\n    /// target amount if the vault does not have the funds available to cover\\n    /// the target amount. For example an active order might move tokens before\\n    /// the withdraw completes.\\n    event Withdraw(address sender, address token, uint256 vaultId, uint256 targetAmount, uint256 amount);\\n\\n    /// An order has been added to the orderbook. The order is permanently and\\n    /// always active according to its expression until/unless it is removed.\\n    /// @param sender `msg.sender` adding the order and is owner of the order.\\n    /// @param expressionDeployer The expression deployer that ran the integrity\\n    /// check for this order. This is NOT included in the `Order` itself but is\\n    /// important for offchain processes to ignore untrusted deployers before\\n    /// interacting with them.\\n    /// @param order The newly added order. MUST be handed back as-is when\\n    /// clearing orders and contains derived information in addition to the order\\n    /// config that was provided by the order owner.\\n    /// @param orderHash The hash of the order as it is recorded onchain. Only\\n    /// the hash is stored in Orderbook storage to avoid paying gas to store the\\n    /// entire order.\\n    event AddOrder(address sender, IExpressionDeployerV2 expressionDeployer, Order order, bytes32 orderHash);\\n\\n    /// An order has been removed from the orderbook. This effectively\\n    /// deactivates it. Orders can be added again after removal.\\n    /// @param sender `msg.sender` removing the order and is owner of the order.\\n    /// @param order The removed order.\\n    /// @param orderHash The hash of the removed order.\\n    event RemoveOrder(address sender, Order order, bytes32 orderHash);\\n\\n    /// Some order has been taken by `msg.sender`. This is the same as them\\n    /// placing inverse orders then immediately clearing them all, but costs less\\n    /// gas and is more convenient and reliable. Analogous to a market buy\\n    /// against the specified orders. Each order that is matched within a the\\n    /// `takeOrders` loop emits its own individual event.\\n    /// @param sender `msg.sender` taking the orders.\\n    /// @param config All config defining the orders to attempt to take.\\n    /// @param input The input amount from the perspective of sender.\\n    /// @param output The output amount from the perspective of sender.\\n    event TakeOrder(address sender, TakeOrderConfig config, uint256 input, uint256 output);\\n\\n    /// Emitted when attempting to match an order that either never existed or\\n    /// was removed. An event rather than an error so that we allow attempting\\n    /// many orders in a loop and NOT rollback on \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that wasn't found.\\n    /// @param owner Owner of the order that was not found.\\n    /// @param orderHash Hash of the order that was not found.\\n    event OrderNotFound(address sender, address owner, bytes32 orderHash);\\n\\n    /// Emitted when an order evaluates to a zero amount. An event rather than an\\n    /// error so that we allow attempting many orders in a loop and NOT rollback\\n    /// on a \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that had a 0 amount.\\n    /// @param owner Owner of the order that evaluated to a 0 amount.\\n    /// @param orderHash Hash of the order that evaluated to a 0 amount.\\n    event OrderZeroAmount(address sender, address owner, bytes32 orderHash);\\n\\n    /// Emitted when an order evaluates to a ratio exceeding the counterparty's\\n    /// maximum limit. An error rather than an error so that we allow attempting\\n    /// many orders in a loop and NOT rollback on a \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that had an excess ratio.\\n    /// @param owner Owner of the order that had an excess ratio.\\n    /// @param orderHash Hash of the order that had an excess ratio.\\n    event OrderExceedsMaxRatio(address sender, address owner, bytes32 orderHash);\\n\\n    /// Emitted before two orders clear. Covers both orders and includes all the\\n    /// state before anything is calculated.\\n    /// @param sender `msg.sender` clearing both orders.\\n    /// @param alice One of the orders.\\n    /// @param bob The other order.\\n    /// @param clearConfig Additional config required to process the clearance.\\n    event Clear(address sender, Order alice, Order bob, ClearConfig clearConfig);\\n\\n    /// Emitted after two orders clear. Includes all final state changes in the\\n    /// vault balances, including the clearer's vaults.\\n    /// @param sender `msg.sender` clearing the order.\\n    /// @param clearStateChange The final vault state changes from the clearance.\\n    event AfterClear(address sender, ClearStateChange clearStateChange);\\n\\n    /// Get the current balance of a vault for a given owner, token and vault ID.\\n    /// @param owner The owner of the vault.\\n    /// @param token The token the vault is for.\\n    /// @param id The vault ID to read.\\n    /// @return balance The current balance of the vault.\\n    function vaultBalance(address owner, address token, uint256 id) external view returns (uint256 balance);\\n\\n    /// `msg.sender` deposits tokens according to config. The config specifies\\n    /// the vault to deposit tokens under. Delegated depositing is NOT supported.\\n    /// Depositing DOES NOT mint shares (unlike ERC4626) so the overall vaulted\\n    /// experience is much simpler as there is always a 1:1 relationship between\\n    /// deposited assets and vault balances globally and individually. This\\n    /// mitigates rounding/dust issues, speculative behaviour on derived assets,\\n    /// possible regulatory issues re: whether a vault share is a security, code\\n    /// bloat on the vault, complex mint/deposit/withdraw/redeem 4-way logic,\\n    /// the need for preview functions, etc. etc.\\n    ///\\n    /// At the same time, allowing vault IDs to be specified by the depositor\\n    /// allows much more granular and direct control over token movements within\\n    /// Orderbook than either ERC4626 vault shares or mere contract-level ERC20\\n    /// allowances can facilitate.\\n    //\\n    /// Vault IDs are namespaced by the token address so there is no risk of\\n    /// collision between tokens. For example, vault ID 0 for token A is\\n    /// completely different to vault ID 0 for token B.\\n    ///\\n    /// `0` amount deposits are unsupported as underlying token contracts\\n    /// handle `0` value transfers differently and this would be a source of\\n    /// confusion. The order book MUST revert with `ZeroDepositAmount` if the\\n    /// amount is zero.\\n    ///\\n    /// @param token The token to deposit.\\n    /// @param vaultId The vault ID to deposit under.\\n    /// @param amount The amount of tokens to deposit.\\n    function deposit(address token, uint256 vaultId, uint256 amount) external;\\n\\n    /// Allows the sender to withdraw any tokens from their own vaults. If the\\n    /// withrawer has an active flash loan debt denominated in the same token\\n    /// being withdrawn then Orderbook will merely reduce the debt and NOT send\\n    /// the amount of tokens repaid to the flashloan debt.\\n    ///\\n    /// MUST revert if the amount _requested_ to withdraw is zero. The withdrawal\\n    /// MAY still not move any tokens (without revert) if the vault balance is\\n    /// zero, or the withdrawal is used to repay a flash loan, or due to any\\n    /// other internal accounting.\\n    ///\\n    /// @param token The token to withdraw.\\n    /// @param vaultId The vault ID to withdraw from.\\n    /// @param targetAmount The amount of tokens to attempt to withdraw. MAY\\n    /// result in fewer tokens withdrawn if the vault balance is lower than the\\n    /// target amount. MAY NOT be zero, the order book MUST revert with\\n    /// `ZeroWithdrawTargetAmount` if the amount is zero.\\n    function withdraw(address token, uint256 vaultId, uint256 targetAmount) external;\\n\\n    /// Given an order config, deploys the expression and builds the full `Order`\\n    /// for the config, then records it as an active order. Delegated adding an\\n    /// order is NOT supported. The `msg.sender` that adds an order is ALWAYS\\n    /// the owner and all resulting vault movements are their own.\\n    ///\\n    /// MUST revert with `OrderNoSources` if the order has no associated\\n    /// calculation and `OrderNoHandleIO` if the order has no handle IO\\n    /// entrypoint. The calculation MUST return at least two values from\\n    /// evaluation, the maximum amount and the IO ratio. The handle IO entrypoint\\n    /// SHOULD return zero values from evaluation. Either MAY revert during\\n    /// evaluation on the interpreter, which MUST prevent the order from\\n    /// clearing.\\n    ///\\n    /// MUST revert with `OrderNoInputs` if the order has no inputs.\\n    /// MUST revert with `OrderNoOutputs` if the order has no outputs.\\n    ///\\n    /// If the order already exists, the order book MUST NOT change state, which\\n    /// includes not emitting an event. Instead it MUST return false. If the\\n    /// order book modifies state it MUST emit an `AddOrder` event and return\\n    /// true.\\n    ///\\n    /// @param config All config required to build an `Order`.\\n    /// @return stateChanged True if the order was added, false if it already\\n    /// existed.\\n    function addOrder(OrderConfigV2 calldata config) external returns (bool stateChanged);\\n\\n    /// Returns true if the order exists, false otherwise.\\n    /// @param orderHash The hash of the order to check.\\n    /// @return exists True if the order exists, false otherwise.\\n    function orderExists(bytes32 orderHash) external view returns (bool exists);\\n\\n    /// Order owner can remove their own orders. Delegated order removal is NOT\\n    /// supported and will revert. Removing an order multiple times or removing\\n    /// an order that never existed are valid, the event will be emitted and the\\n    /// transaction will complete with that order hash definitely, redundantly\\n    /// not live.\\n    /// @param order The `Order` data exactly as it was added.\\n    /// @return stateChanged True if the order was removed, false if it did not\\n    /// exist.\\n    function removeOrder(Order calldata order) external returns (bool stateChanged);\\n\\n    /// Allows `msg.sender` to attempt to fill a list of orders in sequence\\n    /// without needing to place their own order and clear them. This works like\\n    /// a market buy but against a specific set of orders. Every order will\\n    /// looped over and calculated individually then filled maximally until the\\n    /// request input is reached for the `msg.sender`. The `msg.sender` is\\n    /// responsible for selecting the best orders at the time according to their\\n    /// criteria and MAY specify a maximum IO ratio to guard against an order\\n    /// spiking the ratio beyond what the `msg.sender` expected and is\\n    /// comfortable with. As orders may be removed and calculate their ratios\\n    /// dynamically, all issues fulfilling an order other than misconfiguration\\n    /// by the `msg.sender` are no-ops and DO NOT revert the transaction. This\\n    /// allows the `msg.sender` to optimistically provide a list of orders that\\n    /// they aren't sure will completely fill at a good price, and fallback to\\n    /// more reliable orders further down their list. Misconfiguration such as\\n    /// token mismatches are errors that revert as this is known and static at\\n    /// all times to the `msg.sender` so MUST be provided correctly. `msg.sender`\\n    /// MAY specify a minimum input that MUST be reached across all orders in the\\n    /// list, otherwise the transaction will revert, this MAY be set to zero.\\n    ///\\n    /// Exactly like withdraw, if there is an active flash loan for `msg.sender`\\n    /// they will have their outstanding loan reduced by the final input amount\\n    /// preferentially before sending any tokens. Notably this allows arb bots\\n    /// implemented as flash loan borrowers to connect orders against external\\n    /// liquidity directly by paying back the loan with a `takeOrders` call and\\n    /// outputting the result of the external trade.\\n    ///\\n    /// Rounding errors always favour the order never the `msg.sender`.\\n    ///\\n    /// @param config The constraints and list of orders to take, orders are\\n    /// processed sequentially in order as provided, there is NO ATTEMPT onchain\\n    /// to predict/filter/sort these orders other than evaluating them as\\n    /// provided. Inputs and outputs are from the perspective of `msg.sender`\\n    /// except for values specified by the orders themselves which are the from\\n    /// the perspective of that order.\\n    /// @return totalInput Total tokens sent to `msg.sender`, taken from order\\n    /// vaults processed.\\n    /// @return totalOutput Total tokens taken from `msg.sender` and distributed\\n    /// between vaults.\\n    function takeOrders(TakeOrdersConfigV2 calldata config)\\n        external\\n        returns (uint256 totalInput, uint256 totalOutput);\\n\\n    /// Allows `msg.sender` to match two live orders placed earlier by\\n    /// non-interactive parties and claim a bounty in the process. The clearer is\\n    /// free to select any two live orders on the order book for matching and as\\n    /// long as they have compatible tokens, ratios and amounts, the orders will\\n    /// clear. Clearing the orders DOES NOT remove them from the orderbook, they\\n    /// remain live until explicitly removed by their owner. Even if the input\\n    /// vault balances are completely emptied, the orders remain live until\\n    /// removed. This allows order owners to deploy a strategy over a long period\\n    /// of time and periodically top up the input vaults. Clearing two orders\\n    /// from the same owner is disallowed.\\n    ///\\n    /// Any mismatch in the ratios between the two orders will cause either more\\n    /// inputs than there are available outputs (transaction will revert) or less\\n    /// inputs than there are available outputs. In the latter case the excess\\n    /// outputs are given to the `msg.sender` of clear, to the vaults they\\n    /// specify in the clear config. This not only incentivises \\\"automatic\\\" clear\\n    /// calls for both alice and bob, but incentivises _prioritising greater\\n    /// ratio differences_ with a larger bounty. The second point is important\\n    /// because it implicitly prioritises orders that are further from the\\n    /// current market price, thus putting constant increasing pressure on the\\n    /// entire system the further it drifts from the norm, no matter how esoteric\\n    /// the individual order expressions and sizings might be.\\n    ///\\n    /// All else equal there are several factors that would impact how reliably\\n    /// some order clears relative to the wider market, such as:\\n    ///\\n    /// - Bounties are effectively percentages of cleared amounts so larger\\n    ///   orders have larger bounties and cover gas costs more easily\\n    /// - High gas on the network means that orders are harder to clear\\n    ///   profitably so the negative spread of the ratios will need to be larger\\n    /// - Complex and stateful expressions cost more gas to evalulate so the\\n    ///   negative spread will need to be larger\\n    /// - Erratic behavior of the order owner could reduce the willingness of\\n    ///   third parties to interact if it could result in wasted gas due to\\n    ///   orders suddently being removed before clearance etc.\\n    /// - Dynamic and highly volatile words used in the expression could be\\n    ///   ignored or low priority by clearers who want to be sure that they can\\n    ///   accurately predict the ratios that they include in their clearance\\n    /// - Geopolitical issues such as sanctions and regulatory restrictions could\\n    ///   cause issues for certain owners and clearers\\n    ///\\n    /// @param alice Some order to clear.\\n    /// @param bob Another order to clear.\\n    /// @param clearConfig Additional configuration for the clearance such as\\n    /// how to handle the bounty payment for the `msg.sender`.\\n    /// @param aliceSignedContext Optional signed context that is relevant to A.\\n    /// @param bobSignedContext Optional signed context that is relevant to B.\\n    function clear(\\n        Order memory alice,\\n        Order memory bob,\\n        ClearConfig calldata clearConfig,\\n        SignedContextV1[] memory aliceSignedContext,\\n        SignedContextV1[] memory bobSignedContext\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interface/unstable/IOrderBookV3OrderTaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\ninterface IOrderBookV3OrderTaker {\\n    /// @notice Called by `OrderBookV3` when `takeOrders` is called with non-zero\\n    /// data, if it caused a non-zero input amount. I.e. if the order(s) taker\\n    /// received some tokens. Input and output directions are relative to the\\n    /// `IOrderBookV3OrderTaker` contract. If the order(s) taker had an active\\n    /// debt from a flash loan then that debt will be paid _before_ calculating\\n    /// any input amounts sent.\\n    /// i.e. the debt is deducted from the input amount before this callback is\\n    /// called.\\n    /// @param inputToken The token that was sent to `IOrderBookV3OrderTaker`.\\n    /// @param outputToken The token that `IOrderBookV3` will attempt to pull\\n    /// from `IOrderBookV3OrderTaker` after this callback returns.\\n    /// @param inputAmountSent The amount of `inputToken` that was sent to\\n    /// `IOrderBookV3OrderTaker`.\\n    /// @param totalOutputAmount The total amount of `outputToken` that\\n    /// `IOrderBookV3` will attempt to pull from `IOrderBookV3OrderTaker` after\\n    /// this callback returns.\\n    /// @param takeOrdersData The data passed to `takeOrders` by the caller.\\n    function onTakeOrders(\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmountSent,\\n        uint256 totalOutputAmount,\\n        bytes calldata takeOrdersData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/lib/LibOrder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../interface/unstable/IOrderBookV3.sol\\\";\\n\\n/// @title LibOrder\\n/// @notice Consistent handling of `Order` for where it matters w.r.t.\\n/// determinism and security.\\nlibrary LibOrder {\\n    /// Hashes `Order` in a secure and deterministic way. Uses abi.encode rather\\n    /// than abi.encodePacked to guard against potential collisions where many\\n    /// inputs encode to the same output bytes.\\n    /// @param order The order to hash.\\n    /// @return The hash of `order`.\\n    function hash(Order memory order) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(order));\\n    }\\n}\\n\"\r\n    },\r\n    \"src/abstract/OrderBookV3FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport {Math} from \\\"lib/openzeppelin-contracts/contracts/utils/math/Math.sol\\\";\\nimport {IERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\\\";\\nimport {SafeERC20} from \\\"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nimport \\\"../interface/ierc3156/IERC3156FlashBorrower.sol\\\";\\nimport \\\"../interface/ierc3156/IERC3156FlashLender.sol\\\";\\n\\n/// Thrown when `flashLoan` token is zero address.\\nerror ZeroToken();\\n\\n/// Thrown when `flashLoan` receiver is zero address.\\nerror ZeroReceiver();\\n\\n/// Thrown when `flashLoan` amount is zero.\\nerror ZeroAmount();\\n\\n/// Thrown when the `onFlashLoan` callback returns anything other than\\n/// ON_FLASH_LOAN_CALLBACK_SUCCESS.\\n/// @param result The value that was returned by `onFlashLoan`.\\nerror FlashLenderCallbackFailed(bytes32 result);\\n\\n/// Thrown when more than one debt is attempted simultaneously.\\n/// @param receiver The receiver of the active debt.\\n/// @param token The token of the active debt.\\n/// @param amount The amount of the active debt.\\nerror ActiveDebt(address receiver, address token, uint256 amount);\\n\\n/// @dev Flash fee is always 0 for orderbook as there's no entity to take\\n/// revenue for `Orderbook` and its more important anyway that flashloans happen\\n/// to connect external liquidity to live orders via arbitrage.\\nuint256 constant FLASH_FEE = 0;\\n\\n/// @title OrderBookV3FlashLender\\n/// @notice Implements `IERC3156FlashLender` for `OrderBook`. Based on the\\n/// reference implementation by Alberto Cuesta Ca\u00f1ada found at\\n/// https://eips.ethereum.org/EIPS/eip-3156\\n/// Several features found in the reference implementation are simplified or\\n/// hardcoded for `OrderBookV3`.\\nabstract contract OrderBookV3FlashLender is IERC3156FlashLender {\\n    using Math for uint256;\\n    using SafeERC20 for IERC20;\\n\\n    IERC3156FlashBorrower private _sReceiver = IERC3156FlashBorrower(address(0));\\n    address private _sToken = address(0);\\n    uint256 private _sAmountUnpaid = 0;\\n\\n    /// If any of the debt related storage values are set then we consider a\\n    /// debt active. Notably the debt is still active even if the amount unpaid\\n    /// is zero, until the loan originating `flashLoan` call fully completes.\\n    function _isActiveDebt() internal view returns (bool) {\\n        return (address(_sReceiver) != address(0)) || (_sToken != address(0)) || (_sAmountUnpaid != 0);\\n    }\\n\\n    function _checkActiveDebt() internal view {\\n        if (_isActiveDebt()) {\\n            revert ActiveDebt(address(_sReceiver), _sToken, _sAmountUnpaid);\\n        }\\n    }\\n\\n    /// Whenever `Orderbook` sends tokens to any address it MUST first attempt\\n    /// to decrease any outstanding flash loans for that address. Consider the\\n    /// case that Alice deposits 100 TKN and she is the only depositor of TKN\\n    /// then flash borrows 100 TKN. If she attempts to withdraw 100 TKN during\\n    /// her `onFlashLoan` callback then `Orderbook`:\\n    ///\\n    /// - has 0 TKN balance to process the withdrawal\\n    /// - MUST process the withdrawal as Alice has the right to withdraw her\\n    /// balance at any time\\n    /// - Has the 100 TKN debt active under Alice\\n    ///\\n    /// In this case `Orderbook` can simply forgive Alice's 100 TKN debt instead\\n    /// of actually transferring any tokens. The withdrawal can decrease her\\n    /// vault balance by 100 TKN decoupled from needing to know whether a\\n    /// tranfer or forgiveness happened.\\n    ///\\n    /// The same logic applies to withdrawals as sending tokens during\\n    /// `takeOrders` as the reason for sending tokens is irrelevant, all that\\n    /// matters is that `Orderbook` prioritises debt repayments over external\\n    /// transfers.\\n    ///\\n    /// If there is an active debt that only partially eclipses the withdrawal\\n    /// then the debt will be fully repaid and the remainder transferred as a\\n    /// real token transfer.\\n    ///\\n    /// Note that Alice can still contrive a situation that causes `Orderbook`\\n    /// to attempt to send tokens that it does not have. If Alice can write a\\n    /// smart contract to trigger withdrawals she can flash loan 100% of the\\n    /// TKN supply in `Orderbook` and trigger her contract to attempt a\\n    /// withdrawal. For any normal ERC20 token this will fail and revert as the\\n    /// `Orderbook` cannot send tokens it does not have under any circumstances,\\n    /// but the scenario is worth being aware of for more exotic token\\n    /// behaviours that may not be supported.\\n    ///\\n    /// @param token The token being sent or for the debt being paid.\\n    /// @param receiver The receiver of the token or holder of the debt.\\n    /// @param sendAmount The amount to send or repay.\\n    /// @return The final amount sent after any debt repayment.\\n    function _decreaseFlashDebtThenSendToken(address token, address receiver, uint256 sendAmount)\\n        internal\\n        returns (uint256)\\n    {\\n        // If this token transfer matches the active debt then prioritise\\n        // reducing debt over sending tokens.\\n        if (token == _sToken && receiver == address(_sReceiver)) {\\n            uint256 debtReduction = sendAmount.min(_sAmountUnpaid);\\n            sendAmount -= debtReduction;\\n\\n            // Even if this completely zeros the amount the debt is considered\\n            // active until the `flashLoan` also clears the token and recipient.\\n            _sAmountUnpaid -= debtReduction;\\n        }\\n\\n        if (sendAmount > 0) {\\n            IERC20(token).safeTransfer(receiver, sendAmount);\\n        }\\n        return sendAmount;\\n    }\\n\\n    /// @inheritdoc IERC3156FlashLender\\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)\\n        external\\n        override\\n        returns (bool)\\n    {\\n        // Set the active debt before transferring tokens to prevent reeentrancy.\\n        // The active debt is set beyond the scope of `flashLoan` to facilitate\\n        // early repayment via. `_decreaseFlashDebtThenSendToken`.\\n        {\\n            if (address(receiver) == address(0)) {\\n                revert ZeroReceiver();\\n            }\\n            if (token == address(0)) {\\n                revert ZeroToken();\\n            }\\n            if (amount == 0) {\\n                revert ZeroAmount();\\n            }\\n\\n            // This prevents reentrancy, loans can be taken sequentially within\\n            // a transaction but not simultanously. If any of these values are\\n            // nonzero in storage, they cannot be set to a new value.\\n            _checkActiveDebt();\\n            _sToken = token;\\n            _sReceiver = receiver;\\n            // As long as FLASH_FEE is 0 this `+` will probably get optimised\\n            // away by the compiler.\\n            _sAmountUnpaid = amount + FLASH_FEE;\\n            IERC20(token).safeTransfer(address(receiver), amount);\\n        }\\n\\n        bytes32 result = receiver.onFlashLoan(msg.sender, token, amount, FLASH_FEE, data);\\n        if (result != ON_FLASH_LOAN_CALLBACK_SUCCESS) {\\n            revert FlashLenderCallbackFailed(result);\\n        }\\n\\n        // Pull tokens before releasing the active debt to prevent a new loan\\n        // from being taken reentrantly during the repayment of the current loan.\\n        {\\n            // Sync local `amount_` with global `_amount` in case an early\\n            // repayment was made during the loan term via.\\n            // `_decreaseFlashDebtThenSendToken`.\\n            amount = _sAmountUnpaid;\\n            if (amount > 0) {\\n                // There is no way to fix this slither warning and be compatible\\n                // with ERC3156.\\n                // https://github.com/crytic/slither/issues/1658\\n                //slither-disable-next-line arbitrary-send-erc20\\n                IERC20(token).safeTransferFrom(address(receiver), address(this), amount);\\n                _sAmountUnpaid = 0;\\n            }\\n\\n            // Both of these are required to fully clear the active debt and\\n            // allow new debts.\\n            _sReceiver = IERC3156FlashBorrower(address(0));\\n            _sToken = address(0);\\n        }\\n\\n        // Guard against some bad code path that allowed an active debt to remain\\n        // at this point. Should be impossible.\\n        _checkActiveDebt();\\n\\n        return true;\\n    }\\n\\n    /// @inheritdoc IERC3156FlashLender\\n    function flashFee(address, uint256) external pure override returns (uint256) {\\n        return FLASH_FEE;\\n    }\\n\\n    /// There's no limit to the size of a flash loan from `Orderbook` other than\\n    /// the current tokens deposited in `Orderbook`. If there is an active debt\\n    /// then loans are disabled so the max becomes `0` until after repayment.\\n    /// @inheritdoc IERC3156FlashLender\\n    function maxFlashLoan(address token) external view override returns (uint256) {\\n        return _isActiveDebt() ? 0 : IERC20(token).balanceOf(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/rain.math.fixedpoint/src/lib/FixedPointDecimalConstants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// @dev The scale of all fixed point math. This is adopting the conventions of\\n/// both ETH (wei) and most ERC20 tokens, so is hopefully uncontroversial.\\nuint256 constant FIXED_POINT_DECIMALS = 18;\\n\\n/// @dev Value of \\\"one\\\" for fixed point math.\\nuint256 constant FIXED_POINT_ONE = 1e18;\\n\\n/// @dev Calculations MUST round up.\\nuint256 constant FLAG_ROUND_UP = 1;\\n\\n/// @dev Calculations MUST saturate NOT overflow.\\nuint256 constant FLAG_SATURATE = 1 << 1;\\n\\n/// @dev Flags MUST NOT exceed this value.\\nuint256 constant FLAG_MAX_INT = FLAG_SATURATE | FLAG_ROUND_UP;\\n\\n/// @dev Can't represent this many OOMs of decimals in `uint256`.\\nuint256 constant OVERFLOW_RESCALE_OOMS = 78;\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IInterpreterV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterStoreV1.sol\\\";\\n\\n/// @dev The index of a source within a deployed expression that can be evaluated\\n/// by an `IInterpreterV1`. MAY be an entrypoint or the index of a source called\\n/// internally such as by the `call` opcode.\\ntype SourceIndex is uint16;\\n\\n/// @dev Encoded information about a specific evaluation including the expression\\n/// address onchain, entrypoint and expected return values.\\ntype EncodedDispatch is uint256;\\n\\n/// @dev The namespace for state changes as requested by the calling contract.\\n/// The interpreter MUST apply this namespace IN ADDITION to namespacing by\\n/// caller etc.\\ntype StateNamespace is uint256;\\n\\n/// @dev Additional bytes that can be used to configure a single opcode dispatch.\\n/// Commonly used to specify the number of inputs to a variadic function such\\n/// as addition or multiplication.\\ntype Operand is uint256;\\n\\n/// @dev The default state namespace MUST be used when a calling contract has no\\n/// particular opinion on or need for dynamic namespaces.\\nStateNamespace constant DEFAULT_STATE_NAMESPACE = StateNamespace.wrap(0);\\n\\n/// @title IInterpreterV1\\n/// Interface into a standard interpreter that supports:\\n///\\n/// - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1`\\n/// - receiving arbitrary `uint256[][]` supporting context to be made available\\n///   to the evaluated logic\\n/// - handling subsequent state changes in bulk in response to evaluated logic\\n/// - namespacing state changes according to the caller's preferences to avoid\\n///   unwanted key collisions\\n/// - exposing its internal function pointers to support external precompilation\\n///   of logic for more gas efficient runtime evaluation by the interpreter\\n///\\n/// The interface is designed to be stable across many versions and\\n/// implementations of an interpreter, balancing minimalism with features\\n/// required for a general purpose onchain interpreted compute environment.\\n///\\n/// The security model of an interpreter is that it MUST be resilient to\\n/// malicious expressions even if they dispatch arbitrary internal function\\n/// pointers during an eval. The interpreter MAY return garbage or exhibit\\n/// undefined behaviour or error during an eval, _provided that no state changes\\n/// are persisted_ e.g. in storage, such that only the caller that specifies the\\n/// malicious expression can be negatively impacted by the result. In turn, the\\n/// caller must guard itself against arbitrarily corrupt/malicious reverts and\\n/// return values from any interpreter that it requests an expression from. And\\n/// so on and so forth up to the externally owned account (EOA) who signs the\\n/// transaction and agrees to a specific combination of contracts, expressions\\n/// and interpreters, who can presumably make an informed decision about which\\n/// ones to trust to get the job done.\\n///\\n/// The state changes for an interpreter are expected to be produces by an `eval`\\n/// and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the\\n/// caller, after the caller has had an opportunity to apply their own\\n/// intermediate logic such as reentrancy defenses against malicious\\n/// interpreters. The interpreter is free to structure the state changes however\\n/// it wants but MUST guard against the calling contract corrupting the changes\\n/// between `eval` and `set`. For example a store could sandbox storage writes\\n/// per-caller so that a malicious caller can only damage their own state\\n/// changes, while honest callers respect, benefit from and are protected by the\\n/// interpreter store's state change handling.\\n///\\n/// The two step eval-state model allows eval to be read-only which provides\\n/// security guarantees for the caller such as no stateful reentrancy, either\\n/// from the interpreter or some contract interface used by some word, while\\n/// still allowing for storage writes. As the storage writes happen on the\\n/// interpreter rather than the caller (c.f. delegate call) the caller DOES NOT\\n/// need to trust the interpreter, which allows for permissionless selection of\\n/// interpreters by end users. Delegate call always implies an admin key on the\\n/// caller because the delegatee contract can write arbitrarily to the state of\\n/// the delegator, which severely limits the generality of contract composition.\\ninterface IInterpreterV1 {\\n    /// Exposes the function pointers as `uint16` values packed into a single\\n    /// `bytes` in the same order as they would be indexed into by opcodes. For\\n    /// example, if opcode `2` should dispatch function at position `0x1234` then\\n    /// the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is\\n    /// a placeholder for the function pointers of opcodes `0` and `1`.\\n    ///\\n    /// `IExpressionDeployerV1` contracts use these function pointers to\\n    /// \\\"compile\\\" the expression into something that an interpreter can dispatch\\n    /// directly without paying gas to lookup the same at runtime. As the\\n    /// validity of any integrity check and subsequent dispatch is highly\\n    /// sensitive to both the function pointers and overall bytecode of the\\n    /// interpreter, `IExpressionDeployerV1` contracts SHOULD implement guards\\n    /// against accidentally being deployed onchain paired against an unknown\\n    /// interpreter. It is very easy for an apparent compatible pairing to be\\n    /// subtly and critically incompatible due to addition/removal/reordering of\\n    /// opcodes and compiler optimisations on the interpreter bytecode.\\n    ///\\n    /// This MAY return different values during construction vs. all other times\\n    /// after the interpreter has been successfully deployed onchain. DO NOT rely\\n    /// on function pointers reported during contract construction.\\n    function functionPointers() external view returns (bytes memory);\\n\\n    /// The raison d'etre for an interpreter. Given some expression and per-call\\n    /// additional contextual data, produce a stack of results and a set of state\\n    /// changes that the caller MAY OPTIONALLY pass back to be persisted by a\\n    /// call to `IInterpreterStoreV1.set`.\\n    /// @param store The storage contract that the returned key/value pairs\\n    /// MUST be passed to IF the calling contract is in a non-static calling\\n    /// context. Static calling contexts MUST pass `address(0)`.\\n    /// @param namespace The state namespace that will be fully qualified by the\\n    /// interpreter at runtime in order to perform gets on the underlying store.\\n    /// MUST be the same namespace passed to the store by the calling contract\\n    /// when sending the resulting key/value items to storage.\\n    /// @param dispatch All the information required for the interpreter to load\\n    /// an expression, select an entrypoint and return the values expected by the\\n    /// caller. The interpreter MAY encode dispatches differently to\\n    /// `LibEncodedDispatch` but this WILL negatively impact compatibility for\\n    /// calling contracts that hardcode the encoding logic.\\n    /// @param context A 2-dimensional array of data that can be indexed into at\\n    /// runtime by the interpreter. The calling contract is responsible for\\n    /// ensuring the authenticity and completeness of context data. The\\n    /// interpreter MUST revert at runtime if an expression attempts to index\\n    /// into some context value that is not provided by the caller. This implies\\n    /// that context reads cannot be checked for out of bounds reads at deploy\\n    /// time, as the runtime context MAY be provided in a different shape to what\\n    /// the expression is expecting.\\n    /// Same as `eval` but allowing the caller to specify a namespace under which\\n    /// the state changes will be applied. The interpeter MUST ensure that keys\\n    /// will never collide across namespaces, even if, for example:\\n    ///\\n    /// - The calling contract is malicious and attempts to craft a collision\\n    ///   with state changes from another contract\\n    /// - The expression is malicious and attempts to craft a collision with\\n    ///   other expressions evaluated by the same calling contract\\n    ///\\n    /// A malicious entity MAY have access to significant offchain resources to\\n    /// attempt to precompute key collisions through brute force. The collision\\n    /// resistance of namespaces should be comparable or equivalent to the\\n    /// collision resistance of the hashing algorithms employed by the blockchain\\n    /// itself, such as the design of `mapping` in Solidity that hashes each\\n    /// nested key to produce a collision resistant compound key.\\n    /// @return stack The list of values produced by evaluating the expression.\\n    /// MUST NOT be longer than the maximum length specified by `dispatch`, if\\n    /// applicable.\\n    /// @return kvs A list of pairwise key/value items to be saved in the store.\\n    function eval(\\n        IInterpreterStoreV1 store,\\n        StateNamespace namespace,\\n        EncodedDispatch dispatch,\\n        uint256[][] calldata context\\n    ) external view returns (uint256[] memory stack, uint256[] memory kvs);\\n}\\n\"\r\n    },\r\n    \"lib/rain.solmem/src/lib/LibUint256Array.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibMemCpy.sol\\\";\\n\\n/// Thrown if a truncated length is longer than the array being truncated. It is\\n/// not possible to truncate something and increase its length as the memory\\n/// region after the array MAY be allocated for something else already.\\nerror OutOfBoundsTruncate(uint256 arrayLength, uint256 truncatedLength);\\n\\n/// @title Uint256Array\\n/// @notice Things we want to do carefully and efficiently with uint256 arrays\\n/// that Solidity doesn't give us native tools for.\\nlibrary LibUint256Array {\\n    using LibUint256Array for uint256[];\\n\\n    /// Pointer to the start (length prefix) of a `uint256[]`.\\n    /// @param array The array to get the start pointer of.\\n    /// @return pointer The pointer to the start of `array`.\\n    function startPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := array\\n        }\\n    }\\n\\n    /// Pointer to the data of a `uint256[]` NOT the length prefix.\\n    /// @param array The array to get the data pointer of.\\n    /// @return pointer The pointer to the data of `array`.\\n    function dataPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(array, 0x20)\\n        }\\n    }\\n\\n    /// Pointer to the end of the allocated memory of an array.\\n    /// @param array The array to get the end pointer of.\\n    /// @return pointer The pointer to the end of `array`.\\n    function endPointer(uint256[] memory array) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(array, add(0x20, mul(0x20, mload(array))))\\n        }\\n    }\\n\\n    /// Cast a `Pointer` to `uint256[]` without modification or safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `uint256[]`.\\n    /// @param pointer The pointer to cast to `uint256[]`.\\n    /// @return array The cast `uint256[]`.\\n    function unsafeAsUint256Array(Pointer pointer) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := pointer\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a A single integer to build an array around.\\n    /// @return array The newly allocated array including `a` as a single item.\\n    function arrayFrom(uint256 a) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 1)\\n            mstore(add(array, 0x20), a)\\n            mstore(0x40, add(array, 0x40))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @return array The newly allocated array including `a` and `b` as the only\\n    /// items.\\n    function arrayFrom(uint256 a, uint256 b) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 2)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(0x40, add(array, 0x60))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b` and `c` as the\\n    /// only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 3)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(0x40, add(array, 0x80))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c` and `d` as the\\n    /// only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 4)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(0x40, add(array, 0xA0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @param e The fifth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c`, `d` and\\n    /// `e` as the only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e)\\n        internal\\n        pure\\n        returns (uint256[] memory array)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 5)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(add(array, 0xA0), e)\\n            mstore(0x40, add(array, 0xC0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first integer to build an array around.\\n    /// @param b The second integer to build an array around.\\n    /// @param c The third integer to build an array around.\\n    /// @param d The fourth integer to build an array around.\\n    /// @param e The fifth integer to build an array around.\\n    /// @param f The sixth integer to build an array around.\\n    /// @return array The newly allocated array including `a`, `b`, `c`, `d`, `e`\\n    /// and `f` as the only items.\\n    function arrayFrom(uint256 a, uint256 b, uint256 c, uint256 d, uint256 e, uint256 f)\\n        internal\\n        pure\\n        returns (uint256[] memory array)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            array := mload(0x40)\\n            mstore(array, 6)\\n            mstore(add(array, 0x20), a)\\n            mstore(add(array, 0x40), b)\\n            mstore(add(array, 0x60), c)\\n            mstore(add(array, 0x80), d)\\n            mstore(add(array, 0xA0), e)\\n            mstore(add(array, 0xC0), f)\\n            mstore(0x40, add(array, 0xE0))\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The head of the new array.\\n    /// @param tail The tail of the new array.\\n    /// @return array The new array.\\n    function arrayFrom(uint256 a, uint256[] memory tail) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := add(mload(tail), 1)\\n            let outputCursor := mload(0x40)\\n            array := outputCursor\\n            let outputEnd := add(outputCursor, add(0x20, mul(length, 0x20)))\\n            mstore(0x40, outputEnd)\\n\\n            mstore(outputCursor, length)\\n            mstore(add(outputCursor, 0x20), a)\\n\\n            for {\\n                outputCursor := add(outputCursor, 0x40)\\n                let inputCursor := add(tail, 0x20)\\n            } lt(outputCursor, outputEnd) {\\n                outputCursor := add(outputCursor, 0x20)\\n                inputCursor := add(inputCursor, 0x20)\\n            } { mstore(outputCursor, mload(inputCursor)) }\\n        }\\n    }\\n\\n    /// Building arrays from literal components is a common task that introduces\\n    /// boilerplate that is either inefficient or error prone.\\n    /// @param a The first item of the new array.\\n    /// @param b The second item of the new array.\\n    /// @param tail The tail of the new array.\\n    /// @return array The new array.\\n    function arrayFrom(uint256 a, uint256 b, uint256[] memory tail) internal pure returns (uint256[] memory array) {\\n        assembly (\\\"memory-safe\\\") {\\n            let length := add(mload(tail), 2)\\n            let outputCursor := mload(0x40)\\n            array := outputCursor\\n            let outputEnd := add(outputCursor, add(0x20, mul(length, 0x20)))\\n            mstore(0x40, outputEnd)\\n\\n            mstore(outputCursor, length)\\n            mstore(add(outputCursor, 0x20), a)\\n            mstore(add(outputCursor, 0x40), b)\\n\\n            for {\\n                outputCursor := add(outputCursor, 0x60)\\n                let inputCursor := add(tail, 0x20)\\n            } lt(outputCursor, outputEnd) {\\n                outputCursor := add(outputCursor, 0x20)\\n                inputCursor := add(inputCursor, 0x20)\\n            } { mstore(outputCursor, mload(inputCursor)) }\\n        }\\n    }\\n\\n    /// Solidity provides no way to change the length of in-memory arrays but\\n    /// it also does not deallocate memory ever. It is always safe to shrink an\\n    /// array that has already been allocated, with the caveat that the\\n    /// truncated items will effectively become inaccessible regions of memory.\\n    /// That is to say, we deliberately \\\"leak\\\" the truncated items, but that is\\n    /// no worse than Solidity's native behaviour of leaking everything always.\\n    /// The array is MUTATED in place so there is no return value and there is\\n    /// no new allocation or copying of data either.\\n    /// @param array The array to truncate.\\n    /// @param newLength The new length of the array after truncation.\\n    function truncate(uint256[] memory array, uint256 newLength) internal pure {\\n        if (newLength > array.length) {\\n            revert OutOfBoundsTruncate(array.length, newLength);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(array, newLength)\\n        }\\n    }\\n\\n    /// Extends `base_` with `extend_` by allocating only an additional\\n    /// `extend_.length` words onto `base_` and copying only `extend_` if\\n    /// possible. If `base_` is large this MAY be significantly more efficient\\n    /// than allocating `base_.length + extend_.length` for an entirely new array\\n    /// and copying both `base_` and `extend_` into the new array one item at a\\n    /// time in Solidity.\\n    ///\\n    /// The efficient version of extension is only possible if the free memory\\n    /// pointer sits at the end of the base array at the moment of extension. If\\n    /// there is allocated memory after the end of base then extension will\\n    /// require copying both the base and extend arays to a new region of memory.\\n    /// The caller is responsible for optimising code paths to avoid additional\\n    /// allocations.\\n    ///\\n    /// This function is UNSAFE because the base array IS MUTATED DIRECTLY by\\n    /// some code paths AND THE FINAL RETURN ARRAY MAY POINT TO THE SAME REGION\\n    /// OF MEMORY. It is NOT POSSIBLE to reliably see this behaviour from the\\n    /// caller in all cases as the Solidity compiler optimisations may switch the\\n    /// caller between the allocating and non-allocating logic due to subtle\\n    /// optimisation reasons. To use this function safely THE CALLER MUST NOT USE\\n    /// THE BASE ARRAY AND MUST USE THE RETURNED ARRAY ONLY. It is safe to use\\n    /// the extend array after calling this function as it is never mutated, it\\n    /// is only copied from.\\n    ///\\n    /// @param b The base integer array that will be extended by `e`.\\n    /// @param e The extend integer array that extends `b`.\\n    /// @return extended The extended array of `b` extended by `e`.\\n    function unsafeExtend(uint256[] memory b, uint256[] memory e) internal pure returns (uint256[] memory extended) {\\n        assembly (\\\"memory-safe\\\") {\\n            // Slither doesn't recognise assembly function names as mixed case\\n            // even if they are.\\n            // https://github.com/crytic/slither/issues/1815\\n            //slither-disable-next-line naming-convention\\n            function extendInline(base, extend) -> baseAfter {\\n                let outputCursor := mload(0x40)\\n                let baseLength := mload(base)\\n                let baseEnd := add(base, add(0x20, mul(baseLength, 0x20)))\\n\\n                // If base is NOT the last thing in allocated memory, allocate,\\n                // copy and recurse.\\n                switch eq(outputCursor, baseEnd)\\n                case 0 {\\n                    let newBase := outputCursor\\n                    let newBaseEnd := add(newBase, sub(baseEnd, base))\\n                    mstore(0x40, newBaseEnd)\\n                    for { let inputCursor := base } lt(outputCursor, newBaseEnd) {\\n                        inputCursor := add(inputCursor, 0x20)\\n                        outputCursor := add(outputCursor, 0x20)\\n                    } { mstore(outputCursor, mload(inputCursor)) }\\n\\n                    baseAfter := extendInline(newBase, extend)\\n                }\\n                case 1 {\\n                    let totalLength_ := add(baseLength, mload(extend))\\n                    let outputEnd_ := add(base, add(0x20, mul(totalLength_, 0x20)))\\n                    mstore(base, totalLength_)\\n                    mstore(0x40, outputEnd_)\\n                    for { let inputCursor := add(extend, 0x20) } lt(outputCursor, outputEnd_) {\\n                        inputCursor := add(inputCursor, 0x20)\\n                        outputCursor := add(outputCursor, 0x20)\\n                    } { mstore(outputCursor, mload(inputCursor)) }\\n\\n                    baseAfter := base\\n                }\\n            }\\n\\n            extended := extendInline(b, e)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.lib.memkv/lib/rain.lib.hash/src/LibHashNoAlloc.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nbytes32 constant HASH_NIL = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n\\n/// @title LibHashNoAlloc\\n/// @notice When producing hashes of just about anything that isn't already bytes\\n/// the common suggestions look something like `keccak256(abi.encode(...))` or\\n/// `keccak256(abi.encodePacked(...))` with the main differentiation being\\n/// whether dynamic data types are being hashed. If they are then there is a hash\\n/// collision risk in the packed case as `\\\"abc\\\" + \\\"def\\\"` and `\\\"ab\\\" + \\\"cdef\\\"` will\\n/// pack and therefore hash to the same values, the suggested fix commonly being\\n/// to use abi.encode, which includes the lengths disambiguating dynamic data.\\n/// Something like `3\\\"abc\\\" + 3\\\"def\\\"` with the length prefixes won't collide with\\n/// `2\\\"ab\\\" + 4\\\"cdef\\\"` but note that ABI provides neither a strong guarantee to\\n/// be collision resitant on inputs (as far as I know, it's a coincidence that\\n/// this works), nor an efficient solution.\\n///\\n/// - Abi encoding is a complex algorithm that is easily 1k+ gas for simple\\n///   structs with just one or two dynamic typed fields.\\n/// - Abi encoding requires allocating and copying all the data plus a header to\\n///   a new region of memory, which gives it non-linearly increasing costs due to\\n///   memory expansion.\\n/// - Abi encoding can't easily be reproduced offchain without specialised tools,\\n///   it's not simply a matter of length prefixing some byte string and hashing\\n///   with keccak256, the heads and tails all need to be produced recursively\\n///   https://docs.soliditylang.org/en/develop/abi-spec.html#formal-specification-of-the-encoding\\n///\\n/// Consider that `hash(hash(\\\"abc\\\") + hash(\\\"def\\\"))` won't collide with\\n/// `hash(hash(\\\"ab\\\") + hash(\\\"cdef\\\"))`. It should be easier to convince ourselves\\n/// this is true for all possible pairs of byte strings than it is to convince\\n/// ourselves that the ABI serialization is never ambigious. Inductively we can\\n/// scale this to all possible data structures that are ordered compositions of\\n/// byte strings. Even better, the native behaviour of `keccak256` in the EVM\\n/// requires no additional allocation of memory. Worst case scenario is that we\\n/// want to hash several hashes together like `hash(hash0, hash1, ...)`, in which\\n/// case we can write the words after the free memory pointer, hash them, but\\n/// leave the pointer. This way we pay for memory expansion but can re-use that\\n/// region of memory for subsequent logic, which may effectively make the\\n/// expansion free as we would have needed to pay for it anyway. Given that hash\\n/// checks often occur early in real world logic due to\\n/// checks-effects-interactions, this is not an unreasonable assumption to call\\n/// this kind of expansion \\\"no alloc\\\".\\n///\\n/// One problem is that the gas saving for trivial abi encoding,\\n/// e.g. ~1-3 uint256 values, can be lost by the overhead of jumps and stack\\n/// manipulation due to function calls.\\n///\\n/// ```\\n/// struct Foo {\\n///   uint256 a;\\n///   address b;\\n///   uint32 c;\\n/// }\\n/// ```\\n/// The simplest way to hash `Foo` is to just hash it (crazy, i know!).\\n///\\n/// ```\\n/// assembly (\\\"memory-safe\\\") {\\n///   hash_ := keccak256(foo_, 0x60)\\n/// }\\n/// ```\\n/// Every struct field is 0x20 bytes in memory so 3 fields = 0x60 bytes to hash\\n/// always, with the exception of dynamic types. This costs about 70 gas vs.\\n/// about 350 gas for an abi encoding based approach.\\nlibrary LibHashNoAlloc {\\n    function hashBytes(bytes memory data_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(data_, 0x20), mload(data_))\\n        }\\n    }\\n\\n    function hashWords(bytes32[] memory words_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(words_, 0x20), mul(mload(words_), 0x20))\\n        }\\n    }\\n\\n    function hashWords(uint256[] memory words_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            hash_ := keccak256(add(words_, 0x20), mul(mload(words_), 0x20))\\n        }\\n    }\\n\\n    function combineHashes(bytes32 a_, bytes32 b_) internal pure returns (bytes32 hash_) {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(0, a_)\\n            mstore(0x20, b_)\\n            hash_ := keccak256(0, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IInterpreterCallerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Typed embodiment of some context data with associated signer and signature.\\n/// The signature MUST be over the packed encoded bytes of the context array,\\n/// i.e. the context array concatenated as bytes without the length prefix, then\\n/// hashed, then handled as per EIP-191 to produce a final hash to be signed.\\n///\\n/// The calling contract (likely with the help of `LibContext`) is responsible\\n/// for ensuring the authenticity of the signature, but not authorizing _who_ can\\n/// sign. IN ADDITION to authorisation of the signer to known-good entities the\\n/// expression is also responsible for:\\n///\\n/// - Enforcing the context is the expected data (e.g. with a domain separator)\\n/// - Tracking and enforcing nonces if signed contexts are only usable one time\\n/// - Tracking and enforcing uniqueness of signed data if relevant\\n/// - Checking and enforcing expiry times if present and relevant in the context\\n/// - Many other potential constraints that expressions may want to enforce\\n///\\n/// EIP-1271 smart contract signatures are supported in addition to EOA\\n/// signatures via. the Open Zeppelin `SignatureChecker` library, which is\\n/// wrapped by `LibContext.build`. As smart contract signatures are checked\\n/// onchain they CAN BE REVOKED AT ANY MOMENT as the smart contract can simply\\n/// return `false` when it previously returned `true`.\\n///\\n/// @param signer The account that produced the signature for `context`. The\\n/// calling contract MUST authenticate that the signer produced the signature.\\n/// @param context The signed data in a format that can be merged into a\\n/// 2-dimensional context matrix as-is.\\n/// @param signature The cryptographic signature for `context`. The calling\\n/// contract MUST authenticate that the signature is valid for the `signer` and\\n/// `context`.\\nstruct SignedContextV1 {\\n    // The ordering of these fields is important and used in assembly offset\\n    // calculations and hashing.\\n    address signer;\\n    uint256[] context;\\n    bytes signature;\\n}\\n\\nuint256 constant SIGNED_CONTEXT_SIGNER_OFFSET = 0;\\nuint256 constant SIGNED_CONTEXT_CONTEXT_OFFSET = 0x20;\\nuint256 constant SIGNED_CONTEXT_SIGNATURE_OFFSET = 0x40;\\n\\n/// @title IInterpreterCallerV2\\n/// @notice A contract that calls an `IInterpreterV1` via. `eval`. There are near\\n/// zero requirements on a caller other than:\\n///\\n/// - Emit some meta about itself upon construction so humans know what the\\n///   contract does\\n/// - Provide the context, which can be built in a standard way by `LibContext`\\n/// - Handle the stack array returned from `eval`\\n/// - OPTIONALLY emit the `Context` event\\n/// - OPTIONALLY set state on the `IInterpreterStoreV1` returned from eval.\\ninterface IInterpreterCallerV2 {\\n    /// Calling contracts SHOULD emit `Context` before calling `eval` if they\\n    /// are able. Notably `eval` MAY be called within a static call which means\\n    /// that events cannot be emitted, in which case this does not apply. It MAY\\n    /// NOT be useful to emit this multiple times for several eval calls if they\\n    /// all share a common context, in which case a single emit is sufficient.\\n    /// @param sender `msg.sender` building the context.\\n    /// @param context The context that was built.\\n    event Context(address sender, uint256[][] context);\\n}\\n\"\r\n    },\r\n    \"lib/rain.metadata/src/IMetaV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// Thrown when hashed metadata does NOT match the expected hash.\\n/// @param expectedHash The hash expected by the `IMetaV1` contract.\\n/// @param actualHash The hash of the metadata seen by the `IMetaV1` contract.\\nerror UnexpectedMetaHash(bytes32 expectedHash, bytes32 actualHash);\\n\\n/// Thrown when some bytes are expected to be rain meta and are not.\\n/// @param unmeta the bytes that are not meta.\\nerror NotRainMetaV1(bytes unmeta);\\n\\n/// @dev Randomly generated magic number with first bytes oned out.\\n/// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\nuint64 constant META_MAGIC_NUMBER_V1 = 0xff0a89c674ee7874;\\n\\n/// @title IMetaV1\\ninterface IMetaV1 {\\n    /// An onchain wrapper to carry arbitrary Rain metadata. Assigns the sender\\n    /// to the metadata so that tooling can easily drop/ignore data from unknown\\n    /// sources. As metadata is about something, the subject MUST be provided.\\n    /// @param sender The msg.sender.\\n    /// @param subject The entity that the metadata is about. MAY be the address\\n    /// of the emitting contract (as `uint256`) OR anything else. The\\n    /// interpretation of the subject is context specific, so will often be a\\n    /// hash of some data/thing that this metadata is about.\\n    /// @param meta Rain metadata V1 compliant metadata bytes.\\n    /// https://github.com/rainprotocol/specs/blob/main/metadata-v1.md\\n    event MetaV1(address sender, uint256 subject, bytes meta);\\n}\\n\"\r\n    },\r\n    \"lib/rain.metadata/src/LibMeta.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IMetaV1.sol\\\";\\n\\n/// @title LibMeta\\n/// @notice Need a place to put data that can be handled offchain like ABIs that\\n/// IS NOT etherscan.\\nlibrary LibMeta {\\n    /// Returns true if the metadata bytes are prefixed by the Rain meta magic\\n    /// number. DOES NOT attempt to validate the body of the metadata as offchain\\n    /// tooling will be required for this.\\n    /// @param meta_ The data that may be rain metadata.\\n    /// @return True if `meta_` is metadata, false otherwise.\\n    function isRainMetaV1(bytes memory meta_) internal pure returns (bool) {\\n        if (meta_.length < 8) return false;\\n        uint256 mask_ = type(uint64).max;\\n        uint256 magicNumber_ = META_MAGIC_NUMBER_V1;\\n        assembly (\\\"memory-safe\\\") {\\n            magicNumber_ := and(mload(add(meta_, 8)), mask_)\\n        }\\n        return magicNumber_ == META_MAGIC_NUMBER_V1;\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1`.\\n    /// @param meta_ The metadata bytes to check.\\n    function checkMetaUnhashed(bytes memory meta_) internal pure {\\n        if (!isRainMetaV1(meta_)) {\\n            revert NotRainMetaV1(meta_);\\n        }\\n    }\\n\\n    /// Reverts if the provided `meta_` is NOT metadata according to\\n    /// `isRainMetaV1` OR it does not match the expected hash of its data.\\n    /// @param meta_ The metadata to check.\\n    function checkMetaHashed(bytes32 expectedHash_, bytes memory meta_) internal pure {\\n        bytes32 actualHash_ = keccak256(meta_);\\n        if (expectedHash_ != actualHash_) {\\n            revert UnexpectedMetaHash(expectedHash_, actualHash_);\\n        }\\n        checkMetaUnhashed(meta_);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibDeployerDiscoverable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../../interface/IExpressionDeployerV1.sol\\\";\\nimport \\\"../../interface/unstable/IExpressionDeployerV2.sol\\\";\\n\\nlibrary LibDeployerDiscoverable {\\n    /// Hack so that some deployer will emit an event with the sender as the\\n    /// caller of `touchDeployer`. This MAY be needed by indexers such as\\n    /// subgraph that can only index events from the first moment they are aware\\n    /// of some contract. The deployer MUST be registered in ERC1820 registry\\n    /// before it is touched, THEN the caller meta MUST be emitted after the\\n    /// deployer is touched. This allows indexers such as subgraph to index the\\n    /// deployer, then see the caller, then see the caller's meta emitted in the\\n    /// same transaction.\\n    /// This is NOT required if ANY other expression is deployed in the same\\n    /// transaction as the caller meta, there only needs to be one expression on\\n    /// ANY deployer known to ERC1820.\\n    function touchDeployerV1(address deployer) internal {\\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) =\\n            IExpressionDeployerV1(deployer).deployExpression(new bytes[](0), new uint256[](0), new uint256[](0));\\n        (interpreter);\\n        (store);\\n        (expression);\\n    }\\n\\n    function touchDeployerV2(address deployer) internal {\\n        (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression) =\\n            IExpressionDeployerV2(deployer).deployExpression(\\\"\\\", new uint256[](0), new uint256[](0));\\n        (interpreter);\\n        (store);\\n        (expression);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.solmem/src/lib/LibPointer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\n/// A pointer to a location in memory. This is a `uint256` to save gas on low\\n/// level operations on the evm stack. These same low level operations typically\\n/// WILL NOT check for overflow or underflow, so all pointer logic MUST ensure\\n/// that reads, writes and movements are not out of bounds.\\ntype Pointer is uint256;\\n\\n/// @title LibPointer\\n/// Ergonomic wrappers around common pointer movements, reading and writing. As\\n/// wrappers on such low level operations often introduce too much jump gas\\n/// overhead, these functions MAY find themselves used in reference\\n/// implementations that more optimised code can be fuzzed against. MAY also be\\n/// situationally useful on cooler performance paths.\\nlibrary LibPointer {\\n    /// Cast a `Pointer` to `bytes` without modification or any safety checks.\\n    /// The caller MUST ensure the pointer is to a valid region of memory for\\n    /// some `bytes`.\\n    /// @param pointer The pointer to cast to `bytes`.\\n    /// @return data The cast `bytes`.\\n    function unsafeAsBytes(Pointer pointer) internal pure returns (bytes memory data) {\\n        assembly (\\\"memory-safe\\\") {\\n            data := pointer\\n        }\\n    }\\n\\n    /// Increase some pointer by a number of bytes.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// Note that moving a pointer by some bytes offset is likely to unalign it\\n    /// with the 32 byte increments of the Solidity allocator.\\n    ///\\n    /// @param pointer The pointer to increase by `length`.\\n    /// @param length The number of bytes to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddBytes(Pointer pointer, uint256 length) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, length)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase by a single word.\\n    /// @return The increased pointer.\\n    function unsafeAddWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Increase some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently overflow or point beyond some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to increase.\\n    /// @param words The number of words to increase the pointer by.\\n    /// @return The increased pointer.\\n    function unsafeAddWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by a single 32 byte word.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease by a single word.\\n    /// @return The decreased pointer.\\n    function unsafeSubWord(Pointer pointer) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, 0x20)\\n        }\\n        return pointer;\\n    }\\n\\n    /// Decrease some pointer by multiple 32 byte words.\\n    ///\\n    /// This is UNSAFE because it can silently underflow or point below some\\n    /// data structure. The caller MUST ensure that this is a safe operation.\\n    ///\\n    /// If the original pointer is aligned to the Solidity allocator it will be\\n    /// aligned after the movement.\\n    ///\\n    /// @param pointer The pointer to decrease.\\n    /// @param words The number of words to decrease the pointer by.\\n    /// @return The decreased pointer.\\n    function unsafeSubWords(Pointer pointer, uint256 words) internal pure returns (Pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := sub(pointer, mul(0x20, words))\\n        }\\n        return pointer;\\n    }\\n\\n    /// Read the word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can read outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to read the word at.\\n    /// @return word The word read from the pointer.\\n    function unsafeReadWord(Pointer pointer) internal pure returns (uint256 word) {\\n        assembly (\\\"memory-safe\\\") {\\n            word := mload(pointer)\\n        }\\n    }\\n\\n    /// Write a word at the pointer.\\n    ///\\n    /// This is UNSAFE because it can write outside any particular data stucture\\n    /// or even beyond allocated memory. The caller MUST ensure that this is a\\n    /// safe operation.\\n    ///\\n    /// @param pointer Pointer to write the word at.\\n    /// @param word The word to write.\\n    function unsafeWriteWord(Pointer pointer, uint256 word) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(pointer, word)\\n        }\\n    }\\n\\n    /// Get the pointer to the end of all allocated memory.\\n    /// As per Solidity docs, there is no guarantee that the region of memory\\n    /// beyond this pointer is zeroed out, as assembly MAY write beyond allocated\\n    /// memory for temporary use if the scratch space is insufficient.\\n    /// @return pointer The pointer to the end of all allocated memory.\\n    function allocatedMemoryPointer() internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := mload(0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.solmem/src/lib/LibBytes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibPointer.sol\\\";\\n\\n/// Thrown when asked to truncate data to a longer length.\\n/// @param length Actual bytes length.\\n/// @param truncate Attempted truncation length.\\nerror TruncateError(uint256 length, uint256 truncate);\\n\\n/// @title LibBytes\\n/// @notice Tools for working directly with memory in a Solidity compatible way.\\nlibrary LibBytes {\\n    /// Truncates bytes of data by mutating its length directly.\\n    /// Any excess bytes are leaked\\n    function truncate(bytes memory data, uint256 length) internal pure {\\n        if (data.length < length) {\\n            revert TruncateError(data.length, length);\\n        }\\n        assembly (\\\"memory-safe\\\") {\\n            mstore(data, length)\\n        }\\n    }\\n\\n    /// Pointer to the data of a bytes array NOT the length prefix.\\n    /// @param data Bytes to get the data pointer for.\\n    /// @return pointer Pointer to the data of the bytes in memory.\\n    function dataPointer(bytes memory data) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(data, 0x20)\\n        }\\n    }\\n\\n    /// Pointer to the start of a bytes array (the length prefix).\\n    /// @param data Bytes to get the pointer to.\\n    /// @return pointer Pointer to the start of the bytes data structure.\\n    function startPointer(bytes memory data) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := data\\n        }\\n    }\\n\\n    /// Pointer to the end of some bytes.\\n    ///\\n    /// Note that this pointer MAY NOT BE ALIGNED, i.e. it MAY NOT point to the\\n    /// start of a multiple of 32, UNLIKE the free memory pointer at 0x40.\\n    ///\\n    /// @param data Bytes to get the pointer to the end of.\\n    /// @return pointer Pointer to the end of the bytes data structure.\\n    function endDataPointer(bytes memory data) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(data, add(0x20, mload(data)))\\n        }\\n    }\\n\\n    /// Pointer to the end of the memory allocated for bytes.\\n    ///\\n    /// The allocator is ALWAYS aligned to whole words, i.e. 32 byte multiples,\\n    /// for data structures allocated by Solidity. This includes `bytes` which\\n    /// means that any time the length of some `bytes` is NOT a multiple of 32\\n    /// the alloation will point past the end of the `bytes` data.\\n    ///\\n    /// There is no guarantee that the memory region between `endDataPointer`\\n    /// and `endAllocatedPointer` is zeroed out. It is best to think of that\\n    /// space as leaked garbage.\\n    ///\\n    /// Almost always, e.g. for the purpose of copying data between regions, you\\n    /// will want `endDataPointer` rather than this function.\\n    /// @param data Bytes to get the end of the allocated data region for.\\n    /// @return pointer Pointer to the end of the allocated data region.\\n    function endAllocatedPointer(bytes memory data) internal pure returns (Pointer pointer) {\\n        assembly (\\\"memory-safe\\\") {\\n            pointer := add(data, and(add(add(mload(data), 0x20), 0x1f), not(0x1f)))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.solmem/src/lib/LibMemCpy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./LibPointer.sol\\\";\\n\\nlibrary LibMemCpy {\\n    /// Copy an arbitrary number of bytes from one location in memory to another.\\n    /// As we can only read/write bytes in 32 byte chunks we first have to loop\\n    /// over 32 byte values to copy then handle any unaligned remaining data. The\\n    /// remaining data will be appropriately masked with the existing data in the\\n    /// final chunk so as to not write past the desired length. Note that the\\n    /// final unaligned write will be more gas intensive than the prior aligned\\n    /// writes. The writes are completely unsafe, the caller MUST ensure that\\n    /// sufficient memory is allocated and reading/writing the requested number\\n    /// of bytes from/to the requested locations WILL NOT corrupt memory in the\\n    /// opinion of solidity or other subsequent read/write operations.\\n    /// @param sourceCursor The starting pointer to read from.\\n    /// @param targetCursor The starting pointer to write to.\\n    /// @param length The number of bytes to read/write.\\n    function unsafeCopyBytesTo(Pointer sourceCursor, Pointer targetCursor, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            // Precalculating the end here, rather than tracking the remaining\\n            // length each iteration uses relatively more gas for less data, but\\n            // scales better for more data. Copying 1-2 words is ~30 gas more\\n            // expensive but copying 3+ words favours a precalculated end point\\n            // increasingly for more data.\\n            let m := mod(length, 0x20)\\n            let end := add(sourceCursor, sub(length, m))\\n            for {} lt(sourceCursor, end) {\\n                sourceCursor := add(sourceCursor, 0x20)\\n                targetCursor := add(targetCursor, 0x20)\\n            } { mstore(targetCursor, mload(sourceCursor)) }\\n\\n            if iszero(iszero(m)) {\\n                //slither-disable-next-line incorrect-shift\\n                let mask_ := shr(mul(m, 8), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n                // preserve existing bytes\\n                mstore(\\n                    targetCursor,\\n                    or(\\n                        // input\\n                        and(mload(sourceCursor), not(mask_)),\\n                        and(mload(targetCursor), mask_)\\n                    )\\n                )\\n            }\\n        }\\n    }\\n\\n    /// Copies `length` `uint256` values starting from `source` to `target`\\n    /// with NO attempt to check that this is safe to do so. The caller MUST\\n    /// ensure that there exists allocated memory at `target` in which it is\\n    /// safe and appropriate to copy `length * 32` bytes to. Anything that was\\n    /// already written to memory at `[target:target+(length * 32 bytes)]`\\n    /// will be overwritten.\\n    /// There is no return value as memory is modified directly.\\n    /// @param source The starting position in memory that data will be copied\\n    /// from.\\n    /// @param target The starting position in memory that data will be copied\\n    /// to.\\n    /// @param length The number of 32 byte (i.e. `uint256`) words that will\\n    /// be copied.\\n    function unsafeCopyWordsTo(Pointer source, Pointer target, uint256 length) internal pure {\\n        assembly (\\\"memory-safe\\\") {\\n            for { let end_ := add(source, mul(0x20, length)) } lt(source, end_) {\\n                source := add(source, 0x20)\\n                target := add(target, 0x20)\\n            } { mstore(target, mload(source)) }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/ierc3156/IERC3156FlashLender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0\\n// Alberto Cuesta Ca\u00f1ada, Fiona Kobayashi, fubuloubu, Austin Williams, \\\"EIP-3156: Flash Loans,\\\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IERC3156FlashBorrower.sol\\\";\\n\\ninterface IERC3156FlashLender {\\n    /**\\n     * @dev The amount of currency available to be lent.\\n     * @param token The loan currency.\\n     * @return The amount of `token` that can be borrowed.\\n     */\\n    function maxFlashLoan(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev The fee to be charged for a given loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\\n     */\\n    function flashFee(address token, uint256 amount) external view returns (uint256);\\n\\n    /**\\n     * @dev Initiate a flash loan.\\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     */\\n    function flashLoan(IERC3156FlashBorrower receiver, address token, uint256 amount, bytes calldata data)\\n        external\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/lib/caller/LibEvaluable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../../interface/IExpressionDeployerV1.sol\\\";\\nimport \\\"../../interface/unstable/IExpressionDeployerV2.sol\\\";\\nimport \\\"../../interface/IInterpreterStoreV1.sol\\\";\\nimport \\\"../../interface/IInterpreterV1.sol\\\";\\n\\n/// Standard struct that can be embedded in ABIs in a consistent format for\\n/// tooling to read/write. MAY be useful to bundle up the data required to call\\n/// `IExpressionDeployerV1` but is NOT mandatory.\\n/// @param deployer Will deploy the expression from sources and constants.\\n/// @param sources Will be deployed to an expression address for use in\\n/// `Evaluable`.\\n/// @param constants Will be available to the expression at runtime.\\nstruct EvaluableConfig {\\n    IExpressionDeployerV1 deployer;\\n    bytes[] sources;\\n    uint256[] constants;\\n}\\n\\n/// Standard struct that can be embedded in ABIs in a consistent format for\\n/// tooling to read/write. MAY be useful to bundle up the data required to call\\n/// `IExpressionDeployerV2` but is NOT mandatory.\\n/// @param deployer Will deploy the expression from sources and constants.\\n/// @param bytecode Will be deployed to an expression address for use in\\n/// `Evaluable`.\\n/// @param constants Will be available to the expression at runtime.\\nstruct EvaluableConfigV2 {\\n    IExpressionDeployerV2 deployer;\\n    bytes bytecode;\\n    uint256[] constants;\\n}\\n\\n/// Struct over the return of `IExpressionDeployerV1.deployExpression`\\n/// which MAY be more convenient to work with than raw addresses.\\n/// @param interpreter Will evaluate the expression.\\n/// @param store Will store state changes due to evaluation of the expression.\\n/// @param expression Will be evaluated by the interpreter.\\nstruct Evaluable {\\n    IInterpreterV1 interpreter;\\n    IInterpreterStoreV1 store;\\n    address expression;\\n}\\n\\n/// @title LibEvaluable\\n/// @notice Common logic to provide consistent implementations of common tasks\\n/// that could be arbitrarily/ambiguously implemented, but work much better if\\n/// consistently implemented.\\nlibrary LibEvaluable {\\n    /// Hashes an `Evaluable`, ostensibly so that only the hash need be stored,\\n    /// thus only storing a single `uint256` instead of 3x `uint160`.\\n    /// @param evaluable The evaluable to hash.\\n    /// @return evaluableHash Standard hash of the evaluable.\\n    function hash(Evaluable memory evaluable) internal pure returns (bytes32 evaluableHash) {\\n        // `Evaluable` does NOT contain any dynamic types so it is safe to encode\\n        // packed for hashing, and is preferable due to the smaller/simpler\\n        // in-memory structure. It also makes it easier to replicate the logic\\n        // offchain as a simple concatenation of bytes.\\n        assembly (\\\"memory-safe\\\") {\\n            evaluableHash := keccak256(evaluable, 0x60)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interface/IOrderBookV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./ierc3156/IERC3156FlashLender.sol\\\";\\nimport \\\"lib/rain.interpreter/src/lib/caller/LibEvaluable.sol\\\";\\nimport \\\"lib/rain.interpreter/src/interface/IInterpreterCallerV2.sol\\\";\\n\\n/// Configuration for a deposit. All deposits are processed by and for\\n/// `msg.sender` so the vaults are unambiguous here.\\n/// @param token The token to deposit.\\n/// @param vaultId The vault ID for the token to deposit.\\n/// @param amount The amount of the token to deposit.\\nstruct DepositConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\n/// Configuration for a withdrawal. All withdrawals are processed by and for\\n/// `msg.sender` so the vaults are unambiguous here.\\n/// @param token The token to withdraw.\\n/// @param vaultId The vault ID for the token to withdraw.\\n/// @param amount The amount of the token to withdraw.\\nstruct WithdrawConfig {\\n    address token;\\n    uint256 vaultId;\\n    uint256 amount;\\n}\\n\\n/// Configuration for a single input or output on an `Order`.\\n/// @param token The token to either send from the owner as an output or receive\\n/// from the counterparty to the owner as an input. The tokens are not moved\\n/// during an order, only internal vault balances are updated, until a separate\\n/// withdraw step.\\n/// @param decimals The decimals to use for internal scaling calculations for\\n/// `token`. This is provided directly in IO to save gas on external lookups and\\n/// to respect the ERC20 spec that mandates NOT assuming or using the `decimals`\\n/// method for onchain calculations. Ostensibly the decimals exists so that all\\n/// calculate order entrypoints can treat amounts and ratios as 18 decimal fixed\\n/// point values. Order max amounts MUST be rounded down and IO ratios rounded up\\n/// to compensate for any loss of precision during decimal rescaling.\\n/// @param vaultId The vault ID that tokens will move into if this is an input\\n/// or move out from if this is an output.\\nstruct IO {\\n    address token;\\n    uint8 decimals;\\n    uint256 vaultId;\\n}\\n\\n/// Config the order owner may provide to define their order. The `msg.sender`\\n/// that adds an order cannot modify the owner nor bypass the integrity check of\\n/// the expression deployer that they specify. However they MAY specify a\\n/// deployer with a corrupt integrity check, so counterparties and clearers MUST\\n/// check the DISpair of the order and avoid untrusted pairings.\\n/// @param validInputs As per `validInputs` on the `Order`.\\n/// @param validOutputs As per `validOutputs` on the `Order`.\\n/// @param evaluableConfig Standard `EvaluableConfig` used to produce the\\n/// `Evaluable` on the order.\\n/// @param meta Arbitrary bytes that will NOT be used in the order evaluation\\n/// but MUST be emitted as a Rain `MetaV1` when the order is placed so can be\\n/// used by offchain processes.\\nstruct OrderConfig {\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n    EvaluableConfig evaluableConfig;\\n    bytes meta;\\n}\\n\\n/// Defines a fully deployed order ready to evaluate by Orderbook.\\n/// @param owner The owner of the order is the `msg.sender` that added the order.\\n/// @param handleIO true if there is a \\\"handle IO\\\" entrypoint to run. If false\\n/// the order book MAY skip calling the interpreter to save gas.\\n/// @param evaluable Standard `Evaluable` with entrypoints for both\\n/// \\\"calculate order\\\" and \\\"handle IO\\\". The latter MAY be empty bytes, in which\\n/// case it will be skipped at runtime to save gas.\\n/// @param validInputs A list of input tokens that are economically equivalent\\n/// for the purpose of processing this order. Inputs are relative to the order\\n/// so these tokens will be sent to the owners vault.\\n/// @param validOutputs A list of output tokens that are economically equivalent\\n/// for the purpose of processing this order. Outputs are relative to the order\\n/// so these tokens will be sent from the owners vault.\\nstruct Order {\\n    address owner;\\n    bool handleIO;\\n    Evaluable evaluable;\\n    IO[] validInputs;\\n    IO[] validOutputs;\\n}\\n\\n/// Config for a list of orders to take sequentially as part of a `takeOrders`\\n/// call.\\n/// @param output Output token from the perspective of the order taker.\\n/// @param input Input token from the perspective of the order taker.\\n/// @param minimumInput Minimum input from the perspective of the order taker.\\n/// @param maximumInput Maximum input from the perspective of the order taker.\\n/// @param maximumIORatio Maximum IO ratio as calculated by the order being\\n/// taken. The input is from the perspective of the order so higher ratio means\\n/// worse deal for the order taker.\\n/// @param orders Ordered list of orders that will be taken until the limit is\\n/// hit. Takers are expected to prioritise orders that appear to be offering\\n/// better deals i.e. lower IO ratios. This prioritisation and sorting MUST\\n/// happen offchain, e.g. via. some simulator.\\nstruct TakeOrdersConfig {\\n    address output;\\n    address input;\\n    uint256 minimumInput;\\n    uint256 maximumInput;\\n    uint256 maximumIORatio;\\n    TakeOrderConfig[] orders;\\n}\\n\\n/// Config for an individual take order from the overall list of orders in a\\n/// call to `takeOrders`.\\n/// @param order The order being taken this iteration.\\n/// @param inputIOIndex The index of the input token in `order` to match with the\\n/// take order output.\\n/// @param outputIOIndex The index of the output token in `order` to match with\\n/// the take order input.\\n/// @param signedContext Optional additional signed context relevant to the\\n/// taken order.\\nstruct TakeOrderConfig {\\n    Order order;\\n    uint256 inputIOIndex;\\n    uint256 outputIOIndex;\\n    SignedContextV1[] signedContext;\\n}\\n\\n/// Additional config to a `clear` that allows two orders to be fully matched to\\n/// a specific token moment. Also defines the bounty for the clearer.\\n/// @param aliceInputIOIndex The index of the input token in order A.\\n/// @param aliceOutputIOIndex The index of the output token in order A.\\n/// @param bobInputIOIndex The index of the input token in order B.\\n/// @param bobOutputIOIndex The index of the output token in order B.\\n/// @param aliceBountyVaultId The vault ID that the bounty from order A should\\n/// move to for the clearer.\\n/// @param bobBountyVaultId The vault ID that the bounty from order B should move\\n/// to for the clearer.\\nstruct ClearConfig {\\n    uint256 aliceInputIOIndex;\\n    uint256 aliceOutputIOIndex;\\n    uint256 bobInputIOIndex;\\n    uint256 bobOutputIOIndex;\\n    uint256 aliceBountyVaultId;\\n    uint256 bobBountyVaultId;\\n}\\n\\n/// Summary of the vault state changes due to clearing an order. NOT the state\\n/// changes sent to the interpreter store, these are the LOCAL CHANGES in vault\\n/// balances. Note that the difference in inputs/outputs overall between the\\n/// counterparties is the bounty paid to the entity that cleared the order.\\n/// @param aliceOutput Amount of counterparty A's output token that moved out of\\n/// their vault.\\n/// @param bobOutput Amount of counterparty B's output token that moved out of\\n/// their vault.\\n/// @param aliceInput Amount of counterparty A's input token that moved into\\n/// their vault.\\n/// @param bobInput Amount of counterparty B's input token that moved into their\\n/// vault.\\nstruct ClearStateChange {\\n    uint256 aliceOutput;\\n    uint256 bobOutput;\\n    uint256 aliceInput;\\n    uint256 bobInput;\\n}\\n\\n/// @title IOrderBookV2\\n/// @notice An orderbook that deploys _strategies_ represented as interpreter\\n/// expressions rather than individual orders. The order book contract itself\\n/// behaves similarly to an `ERC4626` vault but with much more fine grained\\n/// control over how tokens are allocated and moved internally by their owners,\\n/// and without any concept of \\\"shares\\\". Token owners MAY deposit and withdraw\\n/// their tokens under arbitrary vault IDs on a per-token basis, then define\\n/// orders that specify how tokens move between vaults according to an expression.\\n/// The expression returns a maximum amount and a token input/output ratio from\\n/// the perpective of the order. When two expressions intersect, as in their\\n/// ratios are the inverse of each other, then tokens can move between vaults.\\n///\\n/// For example, consider order A with input TKNA and output TKNB with a constant\\n/// ratio of 100:1. This order in isolation has no ability to move tokens. If\\n/// an order B appears with input TKNB and output TKNA and a ratio of 1:100 then\\n/// this is a perfect match with order A. In this case 100 TKNA will move from\\n/// order B to order A and 1 TKNB will move from order A to order B.\\n///\\n/// IO ratios are always specified as input:output and are 18 decimal fixed point\\n/// values. The maximum amount that can be moved in the current clearance is also\\n/// set by the order expression as an 18 decimal fixed point value.\\n///\\n/// Typically orders will not clear when their match is exactly 1:1 as the\\n/// clearer needs to pay gas to process the match. Each order will get exactly\\n/// the ratio it calculates when it does clear so if there is _overlap_ in the\\n/// ratios then the clearer keeps the difference. In our above example, consider\\n/// order B asking a ratio of 1:110 instead of 1:100. In this case 100 TKNA will\\n/// move from order B to order A and 10 TKNA will move to the clearer's vault and\\n/// 1 TKNB will move from order A to order B. In the case of fixed prices this is\\n/// not very interesting as order B could more simply take order A directly for\\n/// cheaper rather than involving a third party. Indeed, Orderbook supports a\\n/// direct \\\"take orders\\\" method that works similar to a \\\"market buy\\\". In the case\\n/// of dynamic expression based ratios, it allows both order A and order B to\\n/// clear non-interactively according to their strategy, trading off active\\n/// management, dealing with front-running, MEV, etc. for zero-gas and\\n/// exact-ratio clearance.\\n///\\n/// The general invariant for clearing and take orders is:\\n///\\n/// ```\\n/// ratioA = InputA / OutputA\\n/// ratioB = InputB / OutputB\\n/// ratioA * ratioB = ( InputA * InputB ) / ( OutputA * OutputB )\\n/// OutputA >= InputB\\n/// OutputB >= InputA\\n///\\n/// \u2234 ratioA * ratioB <= 1\\n/// ```\\n///\\n/// Orderbook is `IERC3156FlashLender` compliant with a 0 fee flash loan\\n/// implementation to allow external liquidity from other onchain DEXes to match\\n/// against orderbook expressions. All deposited tokens across all vaults are\\n/// available for flashloan, the flashloan MAY BE REPAID BY CALLING TAKE ORDER\\n/// such that Orderbook's liability to its vaults is decreased by an incoming\\n/// trade from the flashloan borrower. See `ZeroExOrderBookFlashBorrower` for\\n/// an example of how this works in practise.\\n///\\n/// Orderbook supports many to many input/output token relationship, for example\\n/// some order can specify an array of stables it would be willing to accept in\\n/// return for some ETH. This removes the need for a combinatorial explosion of\\n/// order strategies between like assets but introduces the issue of token\\n/// decimal handling. End users understand that \\\"one\\\" USDT is roughly equal to\\n/// \\\"one\\\" DAI, but onchain this is incorrect by _12 orders of magnitude_. This\\n/// is because \\\"one\\\" DAI is `1e18` tokens and \\\"one\\\" USDT is `1e6` tokens. The\\n/// orderbook is allowing orders to deploy expressions that define _economic\\n/// equivalence_ but this doesn't map 1:1 with numeric equivalence in a many to\\n/// many setup behind token decimal convensions. The solution is to require that\\n/// end users who place orders provide the decimals of each token they include\\n/// in their valid IO lists, and to calculate all amounts and ratios in their\\n/// expressions _as though they were 18 decimal fixed point values_. Orderbook\\n/// will then automatically rescale the expression values before applying the\\n/// final vault movements. If an order provides the \\\"wrong\\\" decimal values for\\n/// some token then it will simply calculate its own ratios and amounts\\n/// incorrectly which will either lead to no matching orders or a very bad trade\\n/// for the order owner. There is no way that misrepresenting decimals can attack\\n/// some other order by a counterparty. Orderbook DOES NOT read decimals from\\n/// tokens onchain because A. this would be gas for an external call to a cold\\n/// token contract and B. the ERC20 standard specifically states NOT to read\\n/// decimals from the interface onchain.\\n///\\n/// Token amounts and ratios returned by calculate order MUST be 18 decimal fixed\\n/// point values. Token amounts input to handle IO MUST be the exact absolute\\n/// values that move between the vaults, i.e. NOT rescaled to 18 decimals. The\\n/// author of the handle IO expression MUST use the token decimals and amounts to\\n/// rescale themselves if they want that logic, notably the expression author\\n/// will need to specify the desired rounding behaviour in the rescaling process.\\n///\\n/// When two orders clear there are NO TOKEN MOVEMENTS, only internal vault\\n/// balances are updated from the input and output vaults. Typically this results\\n/// in less gas per clear than calling external token transfers and also avoids\\n/// issues with reentrancy, allowances, external balances etc. This also means\\n/// that REBASING TOKENS AND TOKENS WITH DYNAMIC BALANCE ARE NOT SUPPORTED.\\n/// Orderbook ONLY WORKS IF TOKEN BALANCES ARE 1:1 WITH ADDITION/SUBTRACTION PER\\n/// VAULT MOVEMENT.\\n///\\n/// Dust due to rounding errors always favours the order. Output max is rounded\\n/// down and IO ratios are rounded up. Input and output amounts are always\\n/// converted to absolute values before applying to vault balances such that\\n/// orderbook always retains fully collateralised inventory of underlying token\\n/// balances to support withdrawals, with the caveat that dynamic token balanes\\n/// are not supported.\\n///\\n/// When an order clears it is NOT removed. Orders remain active until the owner\\n/// deactivates them. This is gas efficient as order owners MAY deposit more\\n/// tokens in a vault with an order against it many times and the order strategy\\n/// will continue to be clearable according to its expression. As vault IDs are\\n/// `uint256` values there are effectively infinite possible vaults for any token\\n/// so there is no limit to how many active orders any address can have at one\\n/// time. This also allows orders to be daisy chained arbitrarily where output\\n/// vaults for some order are the input vaults for some other order.\\n///\\n/// Expression storage is namespaced by order owner, so gets and sets are unique\\n/// to each onchain address. Order owners MUST TAKE CARE not to override their\\n/// storage sets globally across all their orders, which they can do most simply\\n/// by hashing the order hash into their get/set keys inside the expression. This\\n/// gives maximum flexibility for shared state across orders without allowing\\n/// order owners to attack and overwrite values stored by orders placed by their\\n/// counterparty.\\n///\\n/// Note that each order specifies its own interpreter and deployer so the\\n/// owner is responsible for not corrupting their own calculations with bad\\n/// interpreters. This also means the Orderbook MUST assume the interpreter, and\\n/// notably the interpreter's store, is malicious and guard against reentrancy\\n/// etc.\\n///\\n/// As Orderbook supports any expression that can run on any `IInterpreterV1` and\\n/// counterparties are available to the order, order strategies are free to\\n/// implement KYC/membership, tracking, distributions, stock, buybacks, etc. etc.\\ninterface IOrderBookV2 is IERC3156FlashLender, IInterpreterCallerV2 {\\n    /// Some tokens have been deposited to a vault.\\n    /// @param sender `msg.sender` depositing tokens. Delegated deposits are NOT\\n    /// supported.\\n    /// @param config All config sent to the `deposit` call.\\n    event Deposit(address sender, DepositConfig config);\\n\\n    /// Some tokens have been withdrawn from a vault.\\n    /// @param sender `msg.sender` withdrawing tokens. Delegated withdrawals are\\n    /// NOT supported.\\n    /// @param config All config sent to the `withdraw` call.\\n    /// @param amount The amount of tokens withdrawn, can be less than the\\n    /// config amount if the vault does not have the funds available to cover\\n    /// the config amount. For example an active order might move tokens before\\n    /// the withdraw completes.\\n    event Withdraw(address sender, WithdrawConfig config, uint256 amount);\\n\\n    /// An order has been added to the orderbook. The order is permanently and\\n    /// always active according to its expression until/unless it is removed.\\n    /// @param sender `msg.sender` adding the order and is owner of the order.\\n    /// @param expressionDeployer The expression deployer that ran the integrity\\n    /// check for this order. This is NOT included in the `Order` itself but is\\n    /// important for offchain processes to ignore untrusted deployers before\\n    /// interacting with them.\\n    /// @param order The newly added order. MUST be handed back as-is when\\n    /// clearing orders and contains derived information in addition to the order\\n    /// config that was provided by the order owner.\\n    /// @param orderHash The hash of the order as it is recorded onchain. Only\\n    /// the hash is stored in Orderbook storage to avoid paying gas to store the\\n    /// entire order.\\n    event AddOrder(address sender, IExpressionDeployerV2 expressionDeployer, Order order, uint256 orderHash);\\n\\n    /// An order has been removed from the orderbook. This effectively\\n    /// deactivates it. Orders can be added again after removal.\\n    /// @param sender `msg.sender` removing the order and is owner of the order.\\n    /// @param order The removed order.\\n    /// @param orderHash The hash of the removed order.\\n    event RemoveOrder(address sender, Order order, uint256 orderHash);\\n\\n    /// Some order has been taken by `msg.sender`. This is the same as them\\n    /// placing inverse orders then immediately clearing them all, but costs less\\n    /// gas and is more convenient and reliable. Analogous to a market buy\\n    /// against the specified orders. Each order that is matched within a the\\n    /// `takeOrders` loop emits its own individual event.\\n    /// @param sender `msg.sender` taking the orders.\\n    /// @param config All config defining the orders to attempt to take.\\n    /// @param input The input amount from the perspective of sender.\\n    /// @param output The output amount from the perspective of sender.\\n    event TakeOrder(address sender, TakeOrderConfig config, uint256 input, uint256 output);\\n\\n    /// Emitted when attempting to match an order that either never existed or\\n    /// was removed. An event rather than an error so that we allow attempting\\n    /// many orders in a loop and NOT rollback on \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that wasn't found.\\n    /// @param owner Owner of the order that was not found.\\n    /// @param orderHash Hash of the order that was not found.\\n    event OrderNotFound(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted when an order evaluates to a zero amount. An event rather than an\\n    /// error so that we allow attempting many orders in a loop and NOT rollback\\n    /// on a \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that had a 0 amount.\\n    /// @param owner Owner of the order that evaluated to a 0 amount.\\n    /// @param orderHash Hash of the order that evaluated to a 0 amount.\\n    event OrderZeroAmount(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted when an order evaluates to a ratio exceeding the counterparty's\\n    /// maximum limit. An error rather than an error so that we allow attempting\\n    /// many orders in a loop and NOT rollback on a \\\"best effort\\\" basis to clear.\\n    /// @param sender `msg.sender` clearing the order that had an excess ratio.\\n    /// @param owner Owner of the order that had an excess ratio.\\n    /// @param orderHash Hash of the order that had an excess ratio.\\n    event OrderExceedsMaxRatio(address sender, address owner, uint256 orderHash);\\n\\n    /// Emitted before two orders clear. Covers both orders and includes all the\\n    /// state before anything is calculated.\\n    /// @param sender `msg.sender` clearing both orders.\\n    /// @param alice One of the orders.\\n    /// @param bob The other order.\\n    /// @param clearConfig Additional config required to process the clearance.\\n    event Clear(address sender, Order alice, Order bob, ClearConfig clearConfig);\\n\\n    /// Emitted after two orders clear. Includes all final state changes in the\\n    /// vault balances, including the clearer's vaults.\\n    /// @param sender `msg.sender` clearing the order.\\n    /// @param clearStateChange The final vault state changes from the clearance.\\n    event AfterClear(address sender, ClearStateChange clearStateChange);\\n\\n    /// Get the current balance of a vault for a given owner, token and vault ID.\\n    /// @param owner The owner of the vault.\\n    /// @param token The token the vault is for.\\n    /// @param id The vault ID to read.\\n    /// @return balance The current balance of the vault.\\n    function vaultBalance(address owner, address token, uint256 id) external view returns (uint256 balance);\\n\\n    /// `msg.sender` deposits tokens according to config. The config specifies\\n    /// the vault to deposit tokens under. Delegated depositing is NOT supported.\\n    /// Depositing DOES NOT mint shares (unlike ERC4626) so the overall vaulted\\n    /// experience is much simpler as there is always a 1:1 relationship between\\n    /// deposited assets and vault balances globally and individually. This\\n    /// mitigates rounding/dust issues, speculative behaviour on derived assets,\\n    /// possible regulatory issues re: whether a vault share is a security, code\\n    /// bloat on the vault, complex mint/deposit/withdraw/redeem 4-way logic,\\n    /// the need for preview functions, etc. etc.\\n    /// At the same time, allowing vault IDs to be specified by the depositor\\n    /// allows much more granular and direct control over token movements within\\n    /// Orderbook than either ERC4626 vault shares or mere contract-level ERC20\\n    /// allowances can facilitate.\\n    /// @param config All config for the deposit.\\n    function deposit(DepositConfig calldata config) external;\\n\\n    /// Allows the sender to withdraw any tokens from their own vaults. If the\\n    /// withrawer has an active flash loan debt denominated in the same token\\n    /// being withdrawn then Orderbook will merely reduce the debt and NOT send\\n    /// the amount of tokens repaid to the flashloan debt.\\n    /// @param config All config required to withdraw. Notably if the amount\\n    /// is less than the current vault balance then the vault will be cleared\\n    /// to 0 rather than the withdraw transaction reverting.\\n    function withdraw(WithdrawConfig calldata config) external;\\n\\n    /// Given an order config, deploys the expression and builds the full `Order`\\n    /// for the config, then records it as an active order. Delegated adding an\\n    /// order is NOT supported. The `msg.sender` that adds an order is ALWAYS\\n    /// the owner and all resulting vault movements are their own.\\n    /// @param config All config required to build an `Order`.\\n    function addOrder(OrderConfig calldata config) external;\\n\\n    /// Order owner can remove their own orders. Delegated order removal is NOT\\n    /// supported and will revert. Removing an order multiple times or removing\\n    /// an order that never existed are valid, the event will be emitted and the\\n    /// transaction will complete with that order hash definitely, redundantly\\n    /// not live.\\n    /// @param order The `Order` data exactly as it was added.\\n    function removeOrder(Order calldata order) external;\\n\\n    /// Allows `msg.sender` to attempt to fill a list of orders in sequence\\n    /// without needing to place their own order and clear them. This works like\\n    /// a market buy but against a specific set of orders. Every order will\\n    /// looped over and calculated individually then filled maximally until the\\n    /// request input is reached for the `msg.sender`. The `msg.sender` is\\n    /// responsible for selecting the best orders at the time according to their\\n    /// criteria and MAY specify a maximum IO ratio to guard against an order\\n    /// spiking the ratio beyond what the `msg.sender` expected and is\\n    /// comfortable with. As orders may be removed and calculate their ratios\\n    /// dynamically, all issues fulfilling an order other than misconfiguration\\n    /// by the `msg.sender` are no-ops and DO NOT revert the transaction. This\\n    /// allows the `msg.sender` to optimistically provide a list of orders that\\n    /// they aren't sure will completely fill at a good price, and fallback to\\n    /// more reliable orders further down their list. Misconfiguration such as\\n    /// token mismatches are errors that revert as this is known and static at\\n    /// all times to the `msg.sender` so MUST be provided correctly. `msg.sender`\\n    /// MAY specify a minimum input that MUST be reached across all orders in the\\n    /// list, otherwise the transaction will revert, this MAY be set to zero.\\n    ///\\n    /// Exactly like withdraw, if there is an active flash loan for `msg.sender`\\n    /// they will have their outstanding loan reduced by the final input amount\\n    /// preferentially before sending any tokens. Notably this allows arb bots\\n    /// implemented as flash loan borrowers to connect orders against external\\n    /// liquidity directly by paying back the loan with a `takeOrders` call and\\n    /// outputting the result of the external trade.\\n    ///\\n    /// Rounding errors always favour the order never the `msg.sender`.\\n    ///\\n    /// @param config The constraints and list of orders to take, orders are\\n    /// processed sequentially in order as provided, there is NO ATTEMPT onchain\\n    /// to predict/filter/sort these orders other than evaluating them as\\n    /// provided. Inputs and outputs are from the perspective of `msg.sender`\\n    /// except for values specified by the orders themselves which are the from\\n    /// the perspective of that order.\\n    /// @return totalInput Total tokens sent to `msg.sender`, taken from order\\n    /// vaults processed.\\n    /// @return totalOutput Total tokens taken from `msg.sender` and distributed\\n    /// between vaults.\\n    function takeOrders(TakeOrdersConfig calldata config) external returns (uint256 totalInput, uint256 totalOutput);\\n\\n    /// Allows `msg.sender` to match two live orders placed earlier by\\n    /// non-interactive parties and claim a bounty in the process. The clearer is\\n    /// free to select any two live orders on the order book for matching and as\\n    /// long as they have compatible tokens, ratios and amounts, the orders will\\n    /// clear. Clearing the orders DOES NOT remove them from the orderbook, they\\n    /// remain live until explicitly removed by their owner. Even if the input\\n    /// vault balances are completely emptied, the orders remain live until\\n    /// removed. This allows order owners to deploy a strategy over a long period\\n    /// of time and periodically top up the input vaults. Clearing two orders\\n    /// from the same owner is disallowed.\\n    ///\\n    /// Any mismatch in the ratios between the two orders will cause either more\\n    /// inputs than there are available outputs (transaction will revert) or less\\n    /// inputs than there are available outputs. In the latter case the excess\\n    /// outputs are given to the `msg.sender` of clear, to the vaults they\\n    /// specify in the clear config. This not only incentivises \\\"automatic\\\" clear\\n    /// calls for both alice and bob, but incentivises _prioritising greater\\n    /// ratio differences_ with a larger bounty. The second point is important\\n    /// because it implicitly prioritises orders that are further from the\\n    /// current market price, thus putting constant increasing pressure on the\\n    /// entire system the further it drifts from the norm, no matter how esoteric\\n    /// the individual order expressions and sizings might be.\\n    ///\\n    /// All else equal there are several factors that would impact how reliably\\n    /// some order clears relative to the wider market, such as:\\n    ///\\n    /// - Bounties are effectively percentages of cleared amounts so larger\\n    ///   orders have larger bounties and cover gas costs more easily\\n    /// - High gas on the network means that orders are harder to clear\\n    ///   profitably so the negative spread of the ratios will need to be larger\\n    /// - Complex and stateful expressions cost more gas to evalulate so the\\n    ///   negative spread will need to be larger\\n    /// - Erratic behavior of the order owner could reduce the willingness of\\n    ///   third parties to interact if it could result in wasted gas due to\\n    ///   orders suddently being removed before clearance etc.\\n    /// - Dynamic and highly volatile words used in the expression could be\\n    ///   ignored or low priority by clearers who want to be sure that they can\\n    ///   accurately predict the ratios that they include in their clearance\\n    /// - Geopolitical issues such as sanctions and regulatory restrictions could\\n    ///   cause issues for certain owners and clearers\\n    ///\\n    /// @param alice Some order to clear.\\n    /// @param bob Another order to clear.\\n    /// @param clearConfig Additional configuration for the clearance such as\\n    /// how to handle the bounty payment for the `msg.sender`.\\n    /// @param aliceSignedContext Optional signed context that is relevant to A.\\n    /// @param bobSignedContext Optional signed context that is relevant to B.\\n    function clear(\\n        Order memory alice,\\n        Order memory bob,\\n        ClearConfig calldata clearConfig,\\n        SignedContextV1[] memory aliceSignedContext,\\n        SignedContextV1[] memory bobSignedContext\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"src/interface/ierc3156/IERC3156FlashBorrower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0\\n// Alberto Cuesta Ca\u00f1ada, Fiona Kobayashi, fubuloubu, Austin Williams, \\\"EIP-3156: Flash Loans,\\\" Ethereum Improvement Proposals, no. 3156, November 2020. [Online serial]. Available: https://eips.ethereum.org/EIPS/eip-3156.\\npragma solidity ^0.8.18;\\n\\n/// @dev The ERC3156 spec mandates this hash be returned by `onFlashLoan` if it\\n/// succeeds.\\nbytes32 constant ON_FLASH_LOAN_CALLBACK_SUCCESS = keccak256(\\\"ERC3156FlashBorrower.onFlashLoan\\\");\\n\\ninterface IERC3156FlashBorrower {\\n    /**\\n     * @dev Receive a flash loan.\\n     * @param initiator The initiator of the loan.\\n     * @param token The loan currency.\\n     * @param amount The amount of tokens lent.\\n     * @param fee The additional amount of tokens to repay.\\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\\n     * @return The keccak256 hash of \\\"ERC3156FlashBorrower.onFlashLoan\\\"\\n     */\\n    function onFlashLoan(address initiator, address token, uint256 amount, uint256 fee, bytes calldata data)\\n        external\\n        returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IInterpreterStoreV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\n/// A fully qualified namespace includes the interpreter's own namespacing logic\\n/// IN ADDITION to the calling contract's requested `StateNamespace`. Typically\\n/// this involves hashing the `msg.sender` into the `StateNamespace` so that each\\n/// caller operates within its own disjoint state universe. Intepreters MUST NOT\\n/// allow either the caller nor any expression/word to modify this directly on\\n/// pain of potential key collisions on writes to the interpreter's own storage.\\ntype FullyQualifiedNamespace is uint256;\\n\\nIInterpreterStoreV1 constant NO_STORE = IInterpreterStoreV1(address(0));\\n\\n/// @title IInterpreterStoreV1\\n/// @notice Tracks state changes on behalf of an interpreter. A single store can\\n/// handle state changes for many calling contracts, many interpreters and many\\n/// expressions. The store is responsible for ensuring that applying these state\\n/// changes is safe from key collisions with calls to `set` from different\\n/// `msg.sender` callers. I.e. it MUST NOT be possible for a caller to modify the\\n/// state changes associated with some other caller.\\n///\\n/// The store defines the shape of its own state changes, which is opaque to the\\n/// calling contract. For example, some store may treat the list of state changes\\n/// as a pairwise key/value set, and some other store may treat it as a literal\\n/// list to be stored as-is.\\n///\\n/// Each interpreter decides for itself which store to use based on the\\n/// compatibility of its own opcodes.\\n///\\n/// The store MUST assume the state changes have been corrupted by the calling\\n/// contract due to bugs or malicious intent, and enforce state isolation between\\n/// callers despite arbitrarily invalid state changes. The store MUST revert if\\n/// it can detect invalid state changes, such as a key/value list having an odd\\n/// number of items, but this MAY NOT be possible if the corruption is\\n/// undetectable.\\ninterface IInterpreterStoreV1 {\\n    /// Mutates the interpreter store in bulk. The bulk values are provided in\\n    /// the form of a `uint256[]` which can be treated e.g. as pairwise keys and\\n    /// values to be stored in a Solidity mapping. The `IInterpreterStoreV1`\\n    /// defines the meaning of the `uint256[]` for its own storage logic.\\n    ///\\n    /// @param namespace The unqualified namespace for the set that MUST be\\n    /// fully qualified by the `IInterpreterStoreV1` to prevent key collisions\\n    /// between callers. The fully qualified namespace forms a compound key with\\n    /// the keys for each value to set.\\n    /// @param kvs The list of changes to apply to the store's internal state.\\n    function set(StateNamespace namespace, uint256[] calldata kvs) external;\\n\\n    /// Given a fully qualified namespace and key, return the associated value.\\n    /// Ostensibly the interpreter can use this to implement opcodes that read\\n    /// previously set values. The interpreter MUST apply the same qualification\\n    /// logic as the store that it uses to guarantee consistent round tripping of\\n    /// data and prevent malicious behaviours. Technically also allows onchain\\n    /// reads of any set value from any contract, not just interpreters, but in\\n    /// this case readers MUST be aware and handle inconsistencies between get\\n    /// and set while the state changes are still in memory in the calling\\n    /// context and haven't yet been persisted to the store.\\n    ///\\n    /// `IInterpreterStoreV1` uses the same fallback behaviour for unset keys as\\n    /// Solidity. Specifically, any UNSET VALUES SILENTLY FALLBACK TO `0`.\\n    /// @param namespace The fully qualified namespace to get a single value for.\\n    /// @param key The key to get the value for within the namespace.\\n    /// @return The value OR ZERO IF NOT SET.\\n    function get(FullyQualifiedNamespace namespace, uint256 key) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/IExpressionDeployerV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"./IInterpreterV1.sol\\\";\\n\\nstring constant IERC1820_NAME_IEXPRESSION_DEPLOYER_V1 = \\\"IExpressionDeployerV1\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV1 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param sources Sources verbatim. These sources MUST be provided in their\\n    /// sequential/index opcode form as the deployment process will need to index\\n    /// into BOTH the integrity check and the final runtime function pointers.\\n    /// This will be emitted in an event for offchain processing to use the\\n    /// indexed opcode sources. The first N sources are considered entrypoints\\n    /// and will be integrity checked by the expression deployer against a\\n    /// starting stack height of 0. Non-entrypoint sources MAY be provided for\\n    /// internal use such as the `call` opcode but will NOT be integrity checked\\n    /// UNLESS entered by an opcode in an entrypoint.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes[] memory sources, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\"\r\n    },\r\n    \"lib/rain.interpreter/src/interface/unstable/IExpressionDeployerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CAL\\npragma solidity ^0.8.18;\\n\\nimport \\\"../IInterpreterV1.sol\\\";\\n\\nstring constant IERC1820_NAME_IEXPRESSION_DEPLOYER_V2 = \\\"IExpressionDeployerV2\\\";\\n\\n/// @title IExpressionDeployerV1\\n/// @notice Companion to `IInterpreterV1` responsible for onchain static code\\n/// analysis and deploying expressions. Each `IExpressionDeployerV1` is tightly\\n/// coupled at the bytecode level to some interpreter that it knows how to\\n/// analyse and deploy expressions for. The expression deployer can perform an\\n/// integrity check \\\"dry run\\\" of candidate source code for the intepreter. The\\n/// critical analysis/transformation includes:\\n///\\n/// - Enforcement of no out of bounds memory reads/writes\\n/// - Calculation of memory required to eval the stack with a single allocation\\n/// - Replacing index based opcodes with absolute interpreter function pointers\\n/// - Enforcement that all opcodes and operands used exist and are valid\\n///\\n/// This analysis is highly sensitive to the specific implementation and position\\n/// of all opcodes and function pointers as compiled into the interpreter. This\\n/// is what makes the coupling between an interpreter and expression deployer\\n/// so tight. Ideally all responsibilities would be handled by a single contract\\n/// but this introduces code size issues quickly by roughly doubling the compiled\\n/// logic of each opcode (half for the integrity check and half for evaluation).\\n///\\n/// Interpreters MUST assume that expression deployers are malicious and fail\\n/// gracefully if the integrity check is corrupt/bypassed and/or function\\n/// pointers are incorrect, etc. i.e. the interpreter MUST always return a stack\\n/// from `eval` in a read only way or error. I.e. it is the expression deployer's\\n/// responsibility to do everything it can to prevent undefined behaviour in the\\n/// interpreter, and the interpreter's responsibility to handle the expression\\n/// deployer completely failing to do so.\\ninterface IExpressionDeployerV2 {\\n    /// This is the literal InterpreterOpMeta bytes to be used offchain to make\\n    /// sense of the opcodes in this interpreter deployment, as a human. For\\n    /// formats like json that make heavy use of boilerplate, repetition and\\n    /// whitespace, some kind of compression is recommended.\\n    /// @param sender The `msg.sender` providing the op meta.\\n    /// @param opMeta The raw binary data of the op meta. Maybe compressed data\\n    /// etc. and is intended for offchain consumption.\\n    event DISpair(address sender, address deployer, address interpreter, address store, bytes opMeta);\\n\\n    /// Expressions are expected to be deployed onchain as immutable contract\\n    /// code with a first class address like any other contract or account.\\n    /// Technically this is optional in the sense that all the tools required to\\n    /// eval some expression and define all its opcodes are available as\\n    /// libraries.\\n    ///\\n    /// In practise there are enough advantages to deploying the sources directly\\n    /// onchain as contract data and loading them from the interpreter at eval:\\n    ///\\n    /// - Loading and storing binary data is gas efficient as immutable contract\\n    ///   data\\n    /// - Expressions need to be immutable between their deploy time integrity\\n    ///   check and runtime evaluation\\n    /// - Passing the address of an expression through calldata to an interpreter\\n    ///   is cheaper than passing an entire expression through calldata\\n    /// - Conceptually a very simple approach, even if implementations like\\n    ///   SSTORE2 are subtle under the hood\\n    ///\\n    /// The expression deployer MUST perform an integrity check of the source\\n    /// code before it puts the expression onchain at a known address. The\\n    /// integrity check MUST at a minimum (it is free to do additional static\\n    /// analysis) calculate the memory required to be allocated for the stack in\\n    /// total, and that no out of bounds memory reads/writes occur within this\\n    /// stack. A simple example of an invalid source would be one that pushes one\\n    /// value to the stack then attempts to pops two values, clearly we cannot\\n    /// remove more values than we added. The `IExpressionDeployerV1` MUST revert\\n    /// in the case of any integrity failure, all integrity checks MUST pass in\\n    /// order for the deployment to complete.\\n    ///\\n    /// Once the integrity check is complete the `IExpressionDeployerV1` MUST do\\n    /// any additional processing required by its paired interpreter.\\n    /// For example, the `IExpressionDeployerV1` MAY NEED to replace the indexed\\n    /// opcodes in the `ExpressionConfig` sources with real function pointers\\n    /// from the corresponding interpreter.\\n    ///\\n    /// @param bytecode Bytecode verbatim. Exactly how the bytecode is structured\\n    /// is up to the deployer and interpreter. The deployer MUST NOT modify the\\n    /// bytecode in any way. The interpreter MUST NOT assume anything about the\\n    /// bytecode other than that it is valid according to the interpreter's\\n    /// integrity checks. It is assumed that the bytecode will be produced from\\n    /// a human friendly string via. `IParserV1.parse` but this is not required\\n    /// if the caller has some other means to prooduce valid bytecode.\\n    /// @param constants Constants verbatim. Constants are provided alongside\\n    /// sources rather than inline as it allows us to avoid variable length\\n    /// opcodes and can be more memory efficient if the same constant is\\n    /// referenced several times from the sources.\\n    /// @param minOutputs The first N sources on the state config are entrypoints\\n    /// to the expression where N is the length of the `minOutputs` array. Each\\n    /// item in the `minOutputs` array specifies the number of outputs that MUST\\n    /// be present on the final stack for an evaluation of each entrypoint. The\\n    /// minimum output for some entrypoint MAY be zero if the expectation is that\\n    /// the expression only applies checks and error logic. Non-entrypoint\\n    /// sources MUST NOT have a minimum outputs length specified.\\n    /// @return interpreter The interpreter the deployer believes it is qualified\\n    /// to perform integrity checks on behalf of.\\n    /// @return store The interpreter store the deployer believes is compatible\\n    /// with the interpreter.\\n    /// @return expression The address of the deployed onchain expression. MUST\\n    /// be valid according to all integrity checks the deployer is aware of.\\n    function deployExpression(bytes memory bytecode, uint256[] memory constants, uint256[] memory minOutputs)\\n        external\\n        returns (IInterpreterV1 interpreter, IInterpreterStoreV1 store, address expression);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@prb/test/=lib/rain.interpreter/lib/prb-math/lib/prb-test/src/\",\r\n      \"axelar-gmp-sdk-solidity/=lib/sushixswap-v2/lib/axelar-gmp-sdk-solidity/\",\r\n      \"bytecode/=lib/rain.interpreter/src/lib/bytecode/\",\r\n      \"caller/=lib/rain.interpreter/src/lib/caller/\",\r\n      \"compile/=lib/rain.interpreter/src/lib/compile/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"eval/=lib/rain.interpreter/src/lib/eval/\",\r\n      \"extern/=lib/rain.interpreter/src/lib/extern/\",\r\n      \"forge-gas-snapshot/=lib/sushixswap-v2/lib/forge-gas-snapshot/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"integrity/=lib/rain.interpreter/src/lib/integrity/\",\r\n      \"ns/=lib/rain.interpreter/src/lib/ns/\",\r\n      \"op/=lib/rain.interpreter/src/lib/op/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"parse/=lib/rain.interpreter/src/lib/parse/\",\r\n      \"prb-math/=lib/rain.interpreter/lib/prb-math/src/\",\r\n      \"prb-test/=lib/rain.interpreter/lib/prb-math/lib/prb-test/src/\",\r\n      \"rain.chainlink/=lib/rain.interpreter/lib/rain.chainlink/src/\",\r\n      \"rain.datacontract/=lib/rain.interpreter/lib/rain.datacontract/src/\",\r\n      \"rain.erc1820/=lib/rain.erc1820/src/\",\r\n      \"rain.extrospection/=lib/rain.factory/lib/rain.extrospection/\",\r\n      \"rain.factory/=lib/rain.factory/\",\r\n      \"rain.interpreter/=lib/rain.interpreter/\",\r\n      \"rain.lib.hash/=lib/rain.lib.memkv/lib/rain.lib.hash/src/\",\r\n      \"rain.lib.memkv/=lib/rain.lib.memkv/src/\",\r\n      \"rain.lib.typecast/=lib/rain.interpreter/lib/rain.lib.typecast/src/\",\r\n      \"rain.math.fixedpoint/=lib/rain.math.fixedpoint/src/\",\r\n      \"rain.math.saturating/=lib/rain.math.fixedpoint/lib/rain.math.saturating/src/\",\r\n      \"rain.metadata/=lib/rain.metadata/src/\",\r\n      \"rain.solmem/=lib/rain.solmem/src/\",\r\n      \"sol.lib.binmaskflag/=lib/rain.interpreter/lib/sol.lib.binmaskflag/src/\",\r\n      \"state/=lib/rain.interpreter/src/lib/state/\",\r\n      \"sushixswap-v2/=lib/sushixswap-v2/\",\r\n      \"uniswap/=lib/rain.interpreter/src/lib/uniswap/\",\r\n      \"v2-core/=lib/rain.interpreter/lib/v2-core/contracts/\",\r\n      \"v2-periphery/=lib/rain.interpreter/lib/v2-periphery/contracts/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"none\",\r\n      \"appendCBOR\": false\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"internalType\":\"struct DeployerDiscoverableMetaV2ConstructionConfig\",\"name\":\"config\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ActiveDebt\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"name\":\"FlashLenderCallbackFailed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minimumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"MinimumInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoOrders\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"NotOrderOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"unmeta\",\"type\":\"bytes\"}],\"name\":\"NotRainMetaV1\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OrderNoHandleIO\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OrderNoInputs\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OrderNoOutputs\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"OrderNoSources\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"SameOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"sourceIndex\",\"type\":\"uint256\"}],\"name\":\"SourceOffsetOutOfBounds\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"aliceTokenDecimals\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"bobTokenDecimals\",\"type\":\"uint8\"}],\"name\":\"TokenDecimalsMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aliceToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bobToken\",\"type\":\"address\"}],\"name\":\"TokenMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"expectedHash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"actualHash\",\"type\":\"bytes32\"}],\"name\":\"UnexpectedMetaHash\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"ZeroDepositAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroMaximumInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroReceiver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroToken\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"ZeroWithdrawTargetAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IExpressionDeployerV2\",\"name\":\"expressionDeployer\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"AddOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aliceOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobOutput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobInput\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ClearStateChange\",\"name\":\"clearStateChange\",\"type\":\"tuple\"}],\"name\":\"AfterClear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"alice\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"bob\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aliceInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceBountyVaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobBountyVaultId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ClearConfig\",\"name\":\"clearConfig\",\"type\":\"tuple\"}],\"name\":\"Clear\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256[][]\",\"name\":\"context\",\"type\":\"uint256[][]\"}],\"name\":\"Context\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"subject\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"name\":\"MetaV1\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderExceedsMaxRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderNotFound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"OrderZeroAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"RemoveOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"inputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputIOIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"signedContext\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct TakeOrderConfig\",\"name\":\"config\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"input\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"output\",\"type\":\"uint256\"}],\"name\":\"TakeOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"targetAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"contract IExpressionDeployerV2\",\"name\":\"deployer\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"internalType\":\"struct EvaluableConfigV2\",\"name\":\"evaluableConfig\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"meta\",\"type\":\"bytes\"}],\"internalType\":\"struct OrderConfigV2\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"addOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"stateChanged\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"alice\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"bob\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"aliceInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobInputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobOutputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aliceBountyVaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bobBountyVaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct ClearConfig\",\"name\":\"clearConfig\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"aliceSignedContext\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"bobSignedContext\",\"type\":\"tuple[]\"}],\"name\":\"clear\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"flashFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC3156FlashBorrower\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"maxFlashLoan\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderHash\",\"type\":\"bytes32\"}],\"name\":\"orderExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"}],\"name\":\"removeOrder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"stateChanged\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minimumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maximumIORatio\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"handleIO\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"contract IInterpreterV1\",\"name\":\"interpreter\",\"type\":\"address\"},{\"internalType\":\"contract IInterpreterStoreV1\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"expression\",\"type\":\"address\"}],\"internalType\":\"struct Evaluable\",\"name\":\"evaluable\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validInputs\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"internalType\":\"struct IO[]\",\"name\":\"validOutputs\",\"type\":\"tuple[]\"}],\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"inputIOIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputIOIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"context\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct SignedContextV1[]\",\"name\":\"signedContext\",\"type\":\"tuple[]\"}],\"internalType\":\"struct TakeOrderConfig[]\",\"name\":\"orders\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct TakeOrdersConfigV2\",\"name\":\"config\",\"type\":\"tuple\"}],\"name\":\"takeOrders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalTakerInput\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTakerOutput\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"}],\"name\":\"vaultBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"vaultId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"targetAmount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "OrderBook", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000808f049f53ca70a2b8ace4c117ffbec4ce77de84000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000016a3ff0a89c674ee7874a500590642ed5c4b6fdb3810fe2b0b9f73498a16416f796e0d3435e064b3c0063ed0d238e146220d91726c14fdef1dd19649bd29c9719d84973696c821e7a16f1e1ce9e1e780b2792cc5e02bfee9f170ce19b0cd4fca24448c0477ab390cbe0e88ef4720c4e068c048985cf0611ef0154478456687fc3a2acc9eae241873439044cf5bdffc3539cacf12328a3df9d7e566a54b2a3cbe80884c03b8410af727179cadc750cef0ef197dd46b78e9efcd2a329e07a056119248b8892599d280ca15de639ccdc92aa1abc77b296d1e6d38da4aaa49341178401796a229cc96fc1998d5d4187f9f7cfea2a79290c74ceab9e98084ebcd903314d6022e616a0c83286a645229e9d389c9a4880399d3220e30d6ba0e8878fa0ecc87e88204c19478cfd78406e0b75bbac026ade570c81624a0fe2d7d6444c611f45c2ca48c8671384c6694ac6ba1155a31556ff9a6748d92edea293ff82842b98a76dc158c4d28ed743354fec24aa79a9b946a97a3ec486b7bd36bc5ac0a33f452634299c285e3d7128a5e4eb1f5837f23cc0f6038dadb82c335d17d2d378ae55ed7bbe571e481b07c06c680de2a22cc5bfd1d93c84f7fca046c7a6eb9d9b66ff1bffe769dfcf4b80f05cbb6c015a1843544d92e6bd1652dd4d16c2640a24247b373f4127e4ba526744f0d4f13500fee124f75091e0d4920b25b38ade2c0a031e5d37a0a9a85ccb81b2a4222bda79e2ad62c7483bf74fbb556a24674db70c1e3c2720e9e04ff1b7ad512bf7bd44c8178322641c57cbde97f58ba5402a7d9e1b50fe47f10f1b35c0cb277b7d4237e5a100c69867eedd394f088112917545ab09a9d7743966dfd7c326d5c88271ba7e42cf33d2ae15f2a9ffc88bcdc91e8116a744130ba5fe15d647a86e801475919207a6240aa6ff591492d2d4c28d03b613e33bc5ace934998b4a4a9cd7df631cfdd2d5fae65be56e5d14a6083f340cf7b2a8438ea7ef30e34bfc3e4063285ffaad86c1b176f2f5bedab94e02de667605215c9856e46ab255f8ee9e5e9e915a61bf126774c091997b2e9677bbdb57b924ecd04bd9563b67f06cbc5301c3d4c4c029882e5835525031cf5b1a45088a1b76250546a3163435545c7c6a31c6530489b5603b5423ca00835860367be3fcaae080b54dc7ec1b5de5e8a959024b85b4bbe5bd28ed15d9fe96afd1e35035c7e585d36b0b39a8b0008e22316bb2e10c41f0d7cf28a77b2b664287f86a415a50356bf7376ced93967f73e9d9d42d21d9896830407090e12de05246070d4deb06a42b4e1a8aa886a1be9ad79ec45278df8fa12d9c156144b499158aeee2b4dc06e374d54da05b38533deccc5aa10f6cf47af0db436d2789898cf4e82f6b02c26006a94c95d7edce1f1d70ecd6c446583511d88599c9f6f4abf6fc09c0c5af1f47f2ce777929165e7467a909d3f7e3d7c5bac8d0b5fa39ca29cd9d5d203f0051e088c89a4dc49ac516278c07f9d9c5b3a51358aaaf418ced56c5c82e6123497a0bdc3038a31847c01077746e1f0cfe19fc3bf378f7ffdf0ae9e01dabbe2c39bcb3d2d3529e8a32d106d4b1236658bca0eb5ecd2b99eeda6970392366ff0374590fb63732bc2bcd5c7bbdd91e7b577b17cc7a0438a4eeb8e8adb91e255c7d6465762ca90ab1aed40e0b2b401ed95eb5069f75b9906ab5fea71aecdb9364b31d8b62bf6790fac7df77bced508499814a5cea6391c5ca379a6f5327bcbc2a3f77ab1cdf029e62ebca6030da21bb2f846c165fde3992c41e86e1f3f9f2958bf13378b997ad7ae01655ca6e3321de70ede65a6e3ba711c043808f8d010e0ba6f6a88bcc1ee1bb98b6e9b0f5c6652faba6da8357d60f9a01d36496792b5b14c5ed33b39d92d98b72923f52ef2f8db66a33dcaa39b286af998251f02b906a84f582d6916b99f674cd5926fa3be31bef874fcf98bfa5ac9398f22fe62babbc3fb984be3f3eb93da262da58def9cb036f5839dd70cba4a4ef31192e5b51d2b9d2d6b41e1a5352b4ae0260296e8238b7a21c208f5d65fada8d3489e70a4bec123ca69ef543d1d4fe6f9bad78d0ab5c9dd1a9b9d6e5c5eeaf25297977edc43f88901966697d05b289c1744ddff5b6461e91748ba5018e51a976b3a0e1c063b0c7618ec1aa15c23d4013742c9e6c6279326cf7d7dd27c62ba65a70d5b101d0ecae57672cbfc507289377176d4c3536a22a39a96acd7cda2ed7de97eea6293ec98731210e6bd565da853f67e30f5c186b6322dc917dd0ad6ab4c38f90d011bffe5ffb4a3ff2cde02706170706c69636174696f6e2f6a736f6e03676465666c6174650462656ea500590ffdad5a6d6f1bb911fe2b84bff8ee203b71da0b0e41af8064eb7a42122bb09d5cd36b1053bb944478b5ab5bee5a518bfef73e334372b97a89db5e11209676c999e1bc3e33d43f4f4abd3227af4ea6756e6a35aaaa8793c1899ed9ebe4b17f9a1b97e1d1b054153d9de1a96a96ba51b95917d5d629d7d4ba310b6b9caacdba36ce948dc99576cae2438d27f85f992ff4cad9aac432dd2cf108544aacc9eda3cd5b5d087d77aeee96463e2b6696552538648db28d33c55ccdcc523f8299b32b5be8bad8aaa652a034beb9fce3cb172fd5a36e8b46cdda466d6cb354ab36c37f556dd4dc96462d6a8d3fb950adc0f4117c96d506441e0c64d358a88ba2ca341fa2ccb1f7119ff82c25de6cd50c1c97c6d6aada941078c0ab8857059ebadc12edccac1b55cdd5a95b82a23bc5a988bedfa2de0e3f92fe2a679bb83baff5c613f6b2b4252941d7330b05d45b7fb2c9955355a9b45a9bfa8c57aa99761672607309b27c4e51a658caad4d66e7dbf498742868b2d9186c61ba387a9661972d175ea19dc9c426dd7718ba696bd2965ae92f76d5ae945e556d2987d1c2042a5bb7cd3328057fc8e6b652f3ba5a9198243b846a2ca480969a60f173f50b9da1d9543d8761e53bac1f885b7935314d311951b0e523ad228246c3e8157999d78a3f7686631d38fab9527f2fd54f15b9a95ead0b33201b3a4bea174f1c8a33f191d4ddebeb219fd49f0ddf47f25ef3be4697e1c090e5e2f9f35717a441eb3c311cc0baaaa005a55ae24425f43db3856dd897594011f85c4de6640ad937527abd361a66ed0b33da1166e8cdd089f00a4278459018d689fbcca15258b081b298a23f2bb8fa8599863e692f53ddd8a210e9d88e4128881c94447c2f823e0e2c1e768b47e7a4f3c934b5a22e369a320afbab0d4904a77ae50fc7e7c2c28b1fe0e7995d216bcced172c5c57f01158b3688dcf203b8ec98140e69f9918d1ec35595bd7c8582a2ba0598dc065ed14ae52ce343ed6bdc849004030d0fa9a18e25377dbb5cd386bf88064b59495e7a7366213f266b10398c307b3063b6035e2c342d26248501a933bd2e15a6fd542cbc7baca2015af631ae76acceecf3233bf054e12a8d232710c4b0a29b2168e8874ca92e0515ee18b08071d580ece9a95f2997265a1d79f83eabce5bc5f75523e18b31679723b9f6337b4ca3e55b5486733f28963710657760f9482fade7bf11c3c5d63741eddf9773ae9de6a2c48ce70ea7cb6fdef3c7ae215a1250d79a7a82d0c14238f8c0f456e25ab19d7f0715d9434abda22978a8512b72693e90713d9e5b6366cc839d255b6341a71bc53511fabe25174089e3504d075b325e172b8cf404d631d77ed7a5dd594fa3d5975daf172a76a6550d472899d4d553fc4a2cb15429dae74fd4041d26e4ff7ce9e6f81316c96060dca14d4215e33205fa342bb7128f35dee9154d6194d3cb1acca335697e69a81d3f78a95049007225ba4fc5af3ab6a8eec295566a54bbd302b44fa0031ab0b7acd390fb62c9bb3ba2d4b3c1aa8b7e30f03659aec9cf5fb0f5357670b0ef65c22e84cdc32660b1fe638f8c2a0b4231340ffbab65402d842b4908d010a8972e109af78ebfdfd3dfd61b243f523d488443754cfd49453de30be1c8597a3f87294ecfcae5bf54d20f25dd8f02db67c13297e17b77f4b04c2e33f47faf1e1283e64396eab3d6e7ffa11e1e18fc1fba273c1d5ef2700657fb8f8fee54f8576cb3786f0cc3d1c1c5ecd0af235f3b99a1b0415ad5145452e4cb9816c2525929c8d3c05161010a60afb5b6b73aa97128aecfd405d4b803b7535feabe1cc2819552f34e58e04be26d0e25c0d11d41e8ac139030acceaca5119282238a2f2f4a8e1fcb3c2b065595e12972146f795c1dd68ac6ec6ef86932b35faa82e876fde4caeffa2ee86afc76a7a7335be41e441328eaba830a41c68a5830180bb813954893a531b8e1f94248e72a891dd1fbe6e3a60d58931abeabada10a6ba8576efff06571e7f89c89e2d32f24beef9400cf9382d53fc3258a49425810fbdae39fa9cb8fc8124b222eccb6a2fb77df02778b0360279dcd2ae07cc31b073d52a24382ad101afe2a3ae6b543a88035005c53bca1a1b4e90a8e39490035ccd1871db004d993c931ddffdecc1576d28794b61a2422a8726779cd952371582b620df282ace56602a22250d4e808d8545206b0784e0b8d3b0d44ce46de6a95be75a01b67cf08011909d731218051ac9a075940618e31362f469f6b42acda97a7f7b754756afab76b144b633bf51838473caebabe164c07c83cb87da425e51732287977cbe7811920d4459e945699b36379fbd3a2c1d27d310a3a3ca417b612e7eb88f9100c1fa32e1fdcbfb884f63b316629e239593afef402adf29f610bdef20b955f96c00022aae15886a8027c20b9ff97c7c2e4224e52901d5356322ce1a65bb32757f0b595ff7bd10066ad7d431da32df3106783ee2049204e81440e42da71bcb42d744993b0b486aa2bd364b20ae4267318f037ea17f950ec4d376b10511967845019115d07ed7bd406a9b13002eac6b7c1749052f4032ce3e825ec50c1e6e4502a93e3f3350246f116e1bf3144a861b7431ccd086719c6e9b0a79d38356d0c707395c52c88502f43a279482a6a4d8721c2eb9c9d63e693256a22cbed3c6788d49a89c6e507f17a751504f3a866fd420835396d3a3a24e519429d158c74e829a04afb71810d8b0595a6e7440c258ae1805014ae8bcf4b522715b4e0d0cd366b446926c5527dd00b7f2ec3a028f4104dd8bf8cbcaba380b21a2d13128bde9a6d1d9834f7a52b964dab1e56cd4f2d444205b67a1abe9f8565d4fef6012c813e949de97500dc9204435fa389fc07dbe24201313bdafa4646741735955841889231752e5e89c0f8d4afee2b9e24ca581297d8f266e82a7d44290781c39fb12727b0e96738e1c1194eb48ecf7bdde05ef49cf4135f77aaaeea6afc7d7eaedf4c3f8edf8faee7680fdc5360e64c2bc471704c7a450b7eb9cc73709efd03dfa8a14fafeae3f6ba4443829b848f1d45391c6085f07a9a0395a4d268d1af41e0a34e8e67402763fea1ff563657327c5c0b7ec358a07adcc00523951b2cc838e583c064350ced34c6b6574c89a37e3d1f096e104e9e5560dafafc2c75f26773fabab8fd7c3b7934b351abe195e5f8ed5f066cc96b97dffeeddf4e66e7c95bad5f4facd47f5cbf4e6f5ad9afce435ed37def24e4ab84c76787535b99b4caf9fddbe1fdddd0c2fe9b37a0728f361f8fecd5d340f1bf5aa05deca5b6eaa50c24a06e3065883d4233dfe1cda696b978e7e047252e3ee4b1f4a231c89229b74da1f1584d7edfa5c006a6add9835bb9902a7fb5a201e7a504ef6e66822ab76bdaac36b5db1f39401380860aa794b6e8428a29c8446c03a1e32a0c8005a3086e15a1f38c8dcce9307430fa3e22810661f88d34857f568b49f6284ce2aa1e1fd9e5a4b4fc7e45d78c5cccb6ecc18ca3a9f4c7816e23d8221126510df334187b6100b51aea3be895e70ace3e9aa03121427668e74606994129bd903d34eee6b7dc2e27a2d8a964e20c819203bade7726e574602ab4bbfa1db93844e19cb96e27133dfc53352eff5895428d2a9e6d025335552e07d8bb4f2e27be01bef195d22c2f14c683e6d8932877e01051594888d07ea925db7de34aeea8627a80e057a67c2c20cadf95c5ecf3ef5f1933c27e9b84ed0985b91c701239106d27ce03be70e63e1d0b9b60e0eb8940177181b5bae7c24452ff57515d6ab3c0e510faee9ca14bbd5b8c3020ede8dce9acf88db03b74686e72625718101a962613c8e61d4cc69ba441bc7269379adaf5f5e07de29a313bdbfbd930eea92f212b93a4d5e10d4b5875f3c02106198c5a2a8669cda936ece0fee596d038f08183091c2739abdc2ed3cc0c019309c5d066423e7a127547bc2d001a77a4683c207b3258776010af687e71422967a8f30959c17e68bf5bd1e6b99ae097229a441de3831f4370b3d601dd442d94cf004e73fa86353db2eb39142127338c1ae797787d1c71b30ed75d504d0db4d11c344d645ac95deed1067c1f8a6f64eef338694d435cdf842dbccb34f60b276dd78cdca4d4ac4738c67391f10f24af8b84305d124c58c5d045d59bb321de290bd02afc11b4961bbfbf2d4eb6940f202b4208d55adf8eaa225b013f25157bea53e435d482187e66965daee74c3678c99f8ee06afef27934e820f17f7cc2eb18635bb43073fa1648b0cf67b535a3c87849ce8c20045bdfe78f96c655633a88fdb6ec2750f3ce9cad176d476c63d0f62011ac81ea8abdcceb0c2f92118fd475783984c38dc02c6e28767321cc4d35fe37522229795d1bb4c4c1e86bbc43ca791636936720abce1b4d3a3f581db23ff3ca5c77dd3243cf724e576cd678e41cceade3503f8f69d7ed78192ce1e13461ee25b6f543afa1aa35530f8f5c5f79fce65d1afcf3f9dd30c0b79b9e46f27ff1aec882da9f680dcd3f8e2ff25b867f5bf487e01c93f0d4e923e3235c0be250d251572c5cb0a0570d1bb1c4ebcbdd726a560938a34902e4f09b2a6e5dc3cd7b666d8441efb453af100b1c37a60aa76c57df9ba5a73cb9707c8d635813e2c646a603c92112ab45be2833b875e44f14cc610b894ab962d65326af72b196713aa5372f0c64f8584679b30e5d0e59c5d1bb9efe089afcf1a44c641835d3b92265dbed2dc18eaf5e50ab6959691d182079e7813aea9fab87410fa84d02807fcd0731f3288ecf35ede4165a726b7fb296647ab8ab2de968707a2602ebe3bcd7e10e919ddf9fc47eef7e2135639bb005ab9144b9fbc6aead60c4ec8014c1d1fce71087a2adf2fc59ea9ab8e3018edbc91beedf84e9ac366b23883ca7b442e996912994bd335c2d0e0783a0c891c0b731547a90713e4999ce1cc1b244d1171a3baf4e4fb4c830dfdc578b73c487384a17fdbb1fc9430bdecc754c7d16b99e68b689a75df19f86666d71bc87b62d8a43fd7206c3448e1497299d3c71993b7d48a0eafefa80b198b5ae9ac8db4e37c53144d5825b3a3a42122f50af8afe68de18b5d2c6b4b1e33d32f3cfc6d64fafb82de45590753aa1df912fdfa5c74d6e96dcf71a6f1f07d3b3254ecfdba61d76e67bc69d73582eebc19bfe61b5efcaff2e03587fcf03239f257b9a4ba39ca2c5d74d40523c04bfc2f857d3ed393b2b9a7264e57e3cbc9dbe11bcc3d6e719132beea03459e82934d37e8b7c368917e387066777ed1723ca9edd83b15f288b1ab38aae82bae7b1e46a73c6fe806b1927b33fa1d0783f05eee3c603ba677467cf6bc24cc43fa1284a7c7f8eff3b095dc69f68df521a9171d870fbd2ae25b4634317cf1e92b5032b1de19a284310b0dc8e6d43804a4204da7ec4f7f22e40eff4688e60933ba1dc78d068d204b9aee869f1a347b452c4c83c3440a8ed5c659c58e88ccdd4f878fe687c12e2c66226751597b4e93a8ad5fa7fbb67b3cb6ec082ff9f5d7a1d0de6718ecff14c7437eb2cf32523bc27372759c0fbf3b44dae6c7c879f37807ea930eefbc8b08a70886d9634e5d7ac441c48efe6afe88389ef09967fa8468b868e0fbd99d441a7e7cd41bacec6da25470fe841891c18130ad76bb8adee318a80c42b5eb63414aa011b1a7d7b54f07e29ec49d1c4742a0c7e02b317068dd31764f45418fd6d7c2e0e0c227b81e0f044fed7024a42f0f523f140b7ed3ef0f86f4a04f478397e8a970d8912efc5ee1683ca4d3c8bd5d8703624792c8021121fffe0d011bffc21bbf86cc199b02706170706c69636174696f6e2f6a736f6e03676465666c6174650462656e0000000000000000000000000000000000000000000000000000000000", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}