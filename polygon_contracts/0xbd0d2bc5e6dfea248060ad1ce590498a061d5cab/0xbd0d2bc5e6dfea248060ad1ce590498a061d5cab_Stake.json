{"SourceCode": "// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n// File: utistakenew.sol\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\npragma solidity ^0.8.8;\r\n\r\n  contract Stake {\r\n    mapping(address => mapping(uint => TransferDetails)) public transferHistory;\r\n\r\n    mapping(address => uint) public affiliateCount;\r\n\r\n    mapping(address => mapping(address => bool)) public userHasUsedAffiliate;\r\n    address payable public recipient;\r\n\r\n    constructor(address payable _recipient) {\r\n        recipient = _recipient;\r\n    }\r\n\r\n    struct TransferDetails {\r\n        uint amount;\r\n        uint recipientAmount;\r\n        uint contractAmount;\r\n        uint affiliateAmount;\r\n        address affiliateAddress;\r\n        uint timestamp;\r\n        uint withdrawnAmount;\r\n        uint withdrawTimestamp;\r\n    }\r\n\r\n    mapping(address => uint) transferCounter;\r\n\r\n    function getAllTransferHistory(address userAddress) external view returns (TransferDetails[] memory) {\r\n        uint totalTransfers = transferCounter[userAddress];\r\n        uint validTransferCount = 0;\r\n\r\n        for (uint i = 1; i <= totalTransfers; i++) {\r\n            TransferDetails storage transferInfo = transferHistory[userAddress][i];\r\n            if (transferInfo.recipientAmount > 0 || transferInfo.contractAmount > 0) {\r\n                validTransferCount++;\r\n            }\r\n        }\r\n\r\n        TransferDetails[] memory allTransfers = new TransferDetails[](validTransferCount);\r\n        uint currentValidTransferIndex = 0;\r\n\r\n        for (uint i = 1; i <= totalTransfers; i++) {\r\n            TransferDetails storage transferInfo = transferHistory[userAddress][i];\r\n            if (transferInfo.recipientAmount > 0 || transferInfo.contractAmount > 0) {\r\n                allTransfers[currentValidTransferIndex] = transferInfo;\r\n                currentValidTransferIndex++;\r\n            }\r\n        }\r\n\r\n        return allTransfers;\r\n    }\r\n\r\n    function uint2str(uint number) internal pure returns (string memory) {\r\n        if (number == 0) {\r\n            return \"0\";\r\n        }\r\n        uint length = 0;\r\n        uint temp = number;\r\n\r\n        while (temp > 0) {\r\n            length++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(length);\r\n\r\n        while (number > 0) {\r\n            length--;\r\n            buffer[length] = bytes1(uint8(48 + number % 10));\r\n            number /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    function transfer(IERC20 token, address payable affiliate, uint amount) external payable {\r\n        uint recipientAmount;\r\n        uint contractAmount;\r\n        uint affiliateAmount;\r\n\r\n        uint userTransferCounter = transferCounter[msg.sender];\r\n\r\n        if (affiliate == address(0)) {\r\n            recipientAmount = amount * 85 / 100;\r\n            contractAmount = amount - recipientAmount;\r\n        } else {\r\n            recipientAmount = amount * 75 / 100;\r\n            contractAmount = amount * 15 / 100;\r\n            affiliateAmount = amount * 10 / 100;\r\n\r\n            if (!userHasUsedAffiliate[msg.sender][affiliate]) {\r\n                affiliateCount[affiliate]++;\r\n                userHasUsedAffiliate[msg.sender][affiliate] = true;\r\n            }\r\n        }\r\n\r\n        if (recipientAmount > 0 || contractAmount > 0) {\r\n            userTransferCounter++;\r\n\r\n            transferCounter[msg.sender] = userTransferCounter;\r\n\r\n            TransferDetails storage transferInfo = transferHistory[msg.sender][userTransferCounter];\r\n            transferInfo.amount = amount;\r\n            transferInfo.recipientAmount = recipientAmount;\r\n            transferInfo.contractAmount = contractAmount;\r\n            transferInfo.affiliateAmount = affiliateAmount;\r\n            transferInfo.affiliateAddress = affiliate;\r\n            transferInfo.timestamp = block.timestamp;\r\n\r\n            IERC20(token).approve(msg.sender, amount);\r\n\r\n            if (recipientAmount > 0) {\r\n                IERC20(token).transferFrom(msg.sender, recipient, recipientAmount);\r\n            }\r\n            if (contractAmount > 0) {\r\n                IERC20(token).transferFrom(msg.sender, address(this), contractAmount);\r\n            }\r\n            if (affiliateAmount > 0) {\r\n                IERC20(token).transferFrom(msg.sender, affiliate, affiliateAmount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getCurrentTime() public view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function withdraw(uint256 transferId) external {\r\n    TransferDetails storage transferInfo = transferHistory[msg.sender][transferId];\r\n    uint256 withdrawalTimestamp = transferInfo.withdrawTimestamp;\r\n    uint256 updatedWithdrawTimestamp;\r\n    uint256 remainingAmount;\r\n    uint256 affiliateShare;\r\n\r\n    if (withdrawalTimestamp == 0) {\r\n        require(block.timestamp >= transferInfo.timestamp + 86400, \"Waiting period not over\");\r\n        updatedWithdrawTimestamp = block.timestamp;\r\n    } else {\r\n        require(block.timestamp >= withdrawalTimestamp + 86400, \"Waiting period not over\");\r\n        updatedWithdrawTimestamp = block.timestamp;\r\n    }\r\n\r\n    require(transferInfo.amount > 0, \"Transfer not found\");\r\n    require(transferInfo.recipientAmount > 0, \"Transfer not completed\");\r\n\r\n    if (affiliateCount[msg.sender] >= 10) {\r\n        remainingAmount = (transferInfo.amount * 5) / 1000; \r\n    } else if (affiliateCount[msg.sender] >= 7) {\r\n        remainingAmount = (transferInfo.amount * 4) / 1000; \r\n    } else if (affiliateCount[msg.sender] >= 5) {\r\n        remainingAmount = (transferInfo.amount * 3) / 1000; \r\n    } else if (affiliateCount[msg.sender] >= 3) {\r\n        remainingAmount = (transferInfo.amount * 2) / 1000; \r\n    } else {\r\n        remainingAmount = (transferInfo.amount * 1) / 1000; \r\n    }\r\n\r\n    uint256 minutesPassed;\r\n    if (withdrawalTimestamp == 0) {\r\n        minutesPassed = (block.timestamp - transferInfo.timestamp) / 86400;\r\n    } else {\r\n        minutesPassed = (block.timestamp - withdrawalTimestamp) / 86400;\r\n    }\r\n\r\n    remainingAmount = remainingAmount * minutesPassed;\r\n\r\n    if (transferInfo.withdrawnAmount + remainingAmount < transferInfo.amount * 2) {\r\n        remainingAmount = remainingAmount;\r\n    } else if (transferInfo.withdrawnAmount + remainingAmount >= transferInfo.amount * 2) {\r\n        remainingAmount = transferInfo.amount * 2 - transferInfo.withdrawnAmount;\r\n    }\r\n\r\n    affiliateShare = remainingAmount * 10 / 100;\r\n\r\n    IERC20(0xaE6e203ca4Ed0Fa0Eee96A797da670ea1D62CE95).transfer(msg.sender, remainingAmount);\r\n\r\n    if (transferInfo.affiliateAddress != address(0) && affiliateShare > 0) {\r\n        IERC20(0xaE6e203ca4Ed0Fa0Eee96A797da670ea1D62CE95).transfer(transferInfo.affiliateAddress, affiliateShare);\r\n    }\r\n\r\n    transferInfo.withdrawnAmount += remainingAmount;\r\n    transferInfo.withdrawTimestamp = updatedWithdrawTimestamp;\r\n}\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"_recipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliateCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getAllTransferHistory\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recipientAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"affiliateAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTimestamp\",\"type\":\"uint256\"}],\"internalType\":\"struct Stake.TransferDetails[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"affiliate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferHistory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"recipientAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"contractAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"affiliateAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTimestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userHasUsedAffiliate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"transferId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Stake", "CompilerVersion": "v0.8.8+commit.dddeac2f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001cc0c288e274cf6dd325f01a1dd884ad8d7a594b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://072301258b71cdb359303d5a968345ba06d1285c2549344ad15ba34d98d9cbda"}