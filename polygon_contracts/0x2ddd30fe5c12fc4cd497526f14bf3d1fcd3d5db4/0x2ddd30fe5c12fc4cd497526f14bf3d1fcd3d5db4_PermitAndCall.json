{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PermitAndCall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.19;\\n\\nimport {\\n  IERC2612,\\n  IERC20PermitAllowed\\n} from \\\"./interfaces/IERC2612.sol\\\";\\nimport {IERC20MetaTransaction} from \\\"./interfaces/INativeMetaTransaction.sol\\\";\\nimport {SafePermit} from \\\"./lib/SafePermit.sol\\\";\\nimport {Revert} from \\\"./lib/Revert.sol\\\";\\n\\ncontract PermitAndCall {\\n  using SafePermit for IERC2612;\\n  using SafePermit for IERC20PermitAllowed;\\n  using SafePermit for IERC20MetaTransaction;\\n  using Revert for bytes;\\n\\n  address payable public constant target = payable(0xDef1C0ded9bec7F1a1670819833240f027b25EfF);\\n\\n  function permitAndCall(\\n    IERC2612 token,\\n    address owner,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s,\\n    bytes calldata data\\n  ) external payable returns (bytes memory) {\\n    token.safePermit(owner, target, amount, deadline, v, r, s);\\n    (bool success, bytes memory returndata) = target.call{value: msg.value}(data);\\n    if (!success) {\\n      returndata.revert_();\\n    }\\n    return returndata;\\n  }\\n\\n  function permitAndCall(\\n    IERC20PermitAllowed token,\\n    address owner,\\n    uint256 nonce,\\n    uint256 deadline,\\n    bool allowed,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s,\\n    bytes calldata data\\n  ) external payable returns (bytes memory) {\\n    token.safePermit(owner, target, nonce, deadline, allowed, v, r, s);\\n    (bool success, bytes memory returndata) = target.call{value: msg.value}(data);\\n    if (!success) {\\n      returndata.revert_();\\n    }\\n    return returndata;\\n  }\\n\\n  function permitAndCall(\\n    IERC20MetaTransaction token,\\n    address owner,\\n    uint256 amount,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s,\\n    bytes calldata data\\n  ) external payable returns (bytes memory) {\\n    token.safePermit(owner, target, amount, v, r, s);\\n    (bool success, bytes memory returndata) = target.call{value: msg.value}(data);\\n    if (!success) {\\n      returndata.revert_();\\n    }\\n    return returndata;\\n  }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.19;\\n\\ninterface IERC20 {\\n  function totalSupply() external view returns (uint256);\\n\\n  function balanceOf(address _owner) external view returns (uint256 balance);\\n\\n  function transfer(address _to, uint256 _value) external returns (bool success);\\n\\n  function transferFrom(\\n    address _from,\\n    address _to,\\n    uint256 _value\\n  ) external returns (bool success);\\n\\n  function approve(address _spender, uint256 _value) external returns (bool success);\\n\\n  function allowance(\\n    address _owner,\\n    address _spender\\n  ) external view returns (uint256 remaining);\\n\\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\n}\\n\\ninterface IERC20Meta is IERC20 {\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IERC2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.19;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\ninterface IERC20PermitCommon is IERC20 {\\n  function nonces(address owner) external view returns (uint256);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\\ninterface IERC2612 is IERC20PermitCommon {\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n}\\n\\ninterface IERC20PermitAllowed is IERC20PermitCommon {\\n  function permit(\\n    address holder,\\n    address spender,\\n    uint256 nonce,\\n    uint256 expiry,\\n    bool allowed,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/INativeMetaTransaction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-or-later\\npragma solidity ^0.8.19;\\n\\nimport {IERC20PermitCommon} from \\\"./IERC2612.sol\\\";\\n\\ninterface INativeMetaTransaction {\\n  function executeMetaTransaction(\\n    address userAddress,\\n    bytes memory functionSignature,\\n    bytes32 sigR,\\n    bytes32 sigS,\\n    uint8 sigV\\n  ) external payable returns (bytes memory);\\n}\\n\\ninterface IERC20MetaTransaction is IERC20PermitCommon, INativeMetaTransaction {}\\n\"\r\n    },\r\n    \"src/lib/Revert.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.19;\\n\\nlibrary Revert {\\n  function revert_(bytes memory reason) internal pure {\\n    assembly (\\\"memory-safe\\\") {\\n      revert(add(reason, 0x20), mload(reason))\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"src/lib/SafePermit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.19;\\n\\nimport {\\n  IERC20PermitCommon,\\n  IERC2612,\\n  IERC20PermitAllowed\\n} from \\\"../interfaces/IERC2612.sol\\\";\\nimport {\\n  IERC20MetaTransaction\\n} from \\\"../interfaces/INativeMetaTransaction.sol\\\";\\nimport {Revert} from \\\"./Revert.sol\\\";\\n\\nlibrary SafePermit {\\n  using Revert for bytes;\\n\\n  bytes32 private constant _PERMIT_TYPEHASH = keccak256(\\n    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n  );\\n\\n  bytes32 private constant _PERMIT_ALLOWED_TYPEHASH = keccak256(\\n    \\\"Permit(address holder,address spender,uint256 nonce,uint256 expiry,bool allowed)\\\"\\n  );\\n\\n  bytes32 private constant _META_TRANSACTION_TYPEHASH = keccak256(\\n    \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\n  );\\n\\n  function _bubbleRevert(\\n    bool success,\\n    bytes memory returndata,\\n    string memory message\\n  ) internal pure {\\n    if (success) {\\n      revert(message);\\n    }\\n    returndata.revert_();\\n  }\\n\\n  function _checkEffects(\\n    IERC20PermitCommon token,\\n    address owner,\\n    address spender,\\n    uint256 amount,\\n    uint256 nonce,\\n    bool success,\\n    bytes memory returndata\\n  ) internal view {\\n    if (nonce == 0) {\\n      _bubbleRevert(success, returndata, \\\"SafePermit: zero nonce\\\");\\n    }\\n    if (token.allowance(owner, spender) != amount) {\\n      _bubbleRevert(success, returndata, \\\"SafePermit: failed\\\");\\n    }\\n  }\\n\\n  function _checkSignature(\\n    IERC20PermitCommon token,\\n    address owner,\\n    bytes32 structHash,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s,\\n    bool success,\\n    bytes memory returndata\\n  ) internal view {\\n    bytes32 signingHash = keccak256(\\n      bytes.concat(bytes2(\\\"\\\\x19\\\\x01\\\"), token.DOMAIN_SEPARATOR(), structHash)\\n    );\\n    address recovered = ecrecover(signingHash, v, r, s);\\n    if (recovered == address(0)) {\\n      _bubbleRevert(success, returndata, \\\"SafePermit: bad signature\\\");\\n    }\\n    if (recovered != owner) {\\n      _bubbleRevert(success, returndata, \\\"SafePermit: wrong signer\\\");\\n    }\\n  }\\n\\n  function safePermit(\\n    IERC2612 token,\\n    address owner,\\n    address spender,\\n    uint256 amount,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    // `permit` could succeed vacuously with no returndata if there's a fallback\\n    // function (e.g. WETH). `permit` could fail spuriously if it was\\n    // replayed/frontrun. Avoid these by manually verifying the effects and\\n    // signature. Insufficient gas griefing is defused by checking the effects.\\n    (bool success, bytes memory returndata) = address(token).call(\\n      abi.encodeCall(token.permit, (owner, spender, amount, deadline, v, r, s))\\n    );\\n    if (success && returndata.length > 0 && abi.decode(returndata, (bool))) {\\n      return;\\n    }\\n\\n    // Check effects and signature\\n    uint256 nonce = token.nonces(owner);\\n    if (block.timestamp > deadline) {\\n      _bubbleRevert(success, returndata, \\\"SafePermit: expired\\\");\\n    }\\n    _checkEffects(token, owner, spender, amount, nonce, success, returndata);\\n    unchecked { nonce--; }\\n    bytes32 structHash = keccak256(\\n      abi.encode(_PERMIT_TYPEHASH, owner, spender, amount, nonce, deadline)\\n    );\\n    _checkSignature(token, owner, structHash, v, r, s, success, returndata);\\n  }\\n\\n  function safePermit(\\n    IERC20PermitAllowed token,\\n    address owner,\\n    address spender,\\n    uint256 nonce,\\n    uint256 deadline,\\n    bool allowed,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    // See comments above\\n    (bool success, bytes memory returndata) = address(token).call(\\n      abi.encodeCall(token.permit, (owner, spender, nonce, deadline, allowed, v, r, s))\\n    );\\n    if (success && returndata.length > 0 && abi.decode(returndata, (bool))) {\\n      return;\\n    }\\n\\n    // Check effects and signature\\n    nonce = token.nonces(owner);\\n    if (block.timestamp > deadline && deadline > 0) {\\n      _bubbleRevert(success, returndata, \\\"SafePermit: expired\\\");\\n    }\\n    _checkEffects(\\n      token,\\n      owner,\\n      spender,\\n      allowed ? type(uint256).max : 0,\\n      nonce,\\n      success,\\n      returndata\\n    );\\n    unchecked { nonce--; }\\n    bytes32 structHash = keccak256(\\n      abi.encode(_PERMIT_ALLOWED_TYPEHASH, owner, spender, nonce, deadline, allowed)\\n    );\\n    _checkSignature(token, owner, structHash, v, r, s, success, returndata);\\n  }\\n\\n  function safePermit(\\n    IERC20MetaTransaction token,\\n    address owner,\\n    address spender,\\n    uint256 amount,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    // See comments above\\n    bytes memory functionSignature = abi.encodeCall(token.approve, (spender, amount));\\n    (bool success, bytes memory returndata) = address(token).call(\\n      abi.encodeCall(token.executeMetaTransaction, (owner, functionSignature, r, s, v))\\n    );\\n    if (success && returndata.length > 0 && abi.decode(abi.decode(returndata, (bytes)), (bool))) {\\n      return;\\n    }\\n\\n    // Check effects and signature\\n    uint256 nonce = token.nonces(owner);\\n    _checkEffects(token, owner, spender, amount, nonce, success, returndata);\\n    unchecked { nonce--; }\\n    bytes32 structHash = keccak256(\\n      abi.encode(_META_TRANSACTION_TYPEHASH, nonce, owner, keccak256(functionSignature))\\n    );\\n    _checkSignature(token, owner, structHash, v, r, s, success, returndata);\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/solmate/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC2612\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"permitAndCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20PermitAllowed\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"permitAndCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20MetaTransaction\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"permitAndCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PermitAndCall", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}