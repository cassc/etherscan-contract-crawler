{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.4;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    function relayTransfer(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function relayMint(address to, uint256 value) external;\\n\\n    function relayBurn(address from, uint256 value) external;\\n\\n    function ethTransfer(address from, uint256 value) external;\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity ^0.8.4;\\n\\n// a library for performing various math operations\\n\\nlibrary Math {\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\\n        if (y > 3) {\\n            z = y;\\n            uint256 x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UQ112x112.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity =0.8.4;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    //solhint-disable-next-line state-visibility\\n    uint224 constant Q112 = 2 ** 112;\\n    uint8 public constant RESOLUTION = 112;\\n    struct uq112x112 {\\n        uint224 _x;\\n    }\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n\\n    function encode1(uint112 x) internal pure returns (uq112x112 memory) {\\n        return uq112x112(uint224(x) << RESOLUTION);\\n    }\\n\\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\\n    function decode1(uq112x112 memory self) internal pure returns (uint112) {\\n        return uint112(self._x >> RESOLUTION);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniqueSwapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity ^0.8.4;\\n\\n//solhint-disable not-rely-on-time\\n//solhint-disable var-name-mixedcase\\n//solhint-disable reason-string\\n\\n// import \\\"./libraries/UniqueSwapV2Library.sol\\\";\\n// import \\\"hardhat/console.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\nimport \\\"./libraries/UQ112x112.sol\\\";\\n\\ncontract UniqueSwapV2 {\\n    using UQ112x112 for uint224;\\n    address public admin;\\n\\n    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;\\n    // a TIMEUNLOCK variable holding 5 years miliseconds\\n    uint256 public constant TIMEUNLOCK = 157680000;\\n\\n    uint112 private reserve0; // uses single storage slot, accessible via getReserves\\n    uint112 private reserve1; // uses single storage slot, accessible via getReserves\\n    uint32 private blockTimestampLast; // uses single storage slot, accessible via getReserves\\n\\n    address private WM;\\n    address private WW;\\n    address private WLDLP;\\n    address private WETH; // vault\\n    address private ULPT;\\n    address private Para;\\n    address private Treasury;\\n    address private LLPT;\\n    address private ULOCK;\\n    address private V1;\\n\\n    uint256 public price0CumulativeLast;\\n    uint256 public price1CumulativeLast;\\n    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n    uint256 public currentK; // reserve0 * reserve1, as of immediately after the most recent liquidity event\\n    event LiquidityLock(\\n        address sender,\\n        uint256 amount,\\n        uint256 timestamp,\\n        string lID,\\n        uint256 llpAmount,\\n        uint256 unlocksOn\\n    );\\n    event LiquidityUnLock(\\n        address sender,\\n        uint256 amount,\\n        uint256 timestamp,\\n        string lID\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n    event LiquidityCreated(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint256 lpMinted,\\n        uint256 pastK,\\n        uint256 blockTimestamp //* liquidity ID\\n    );\\n    event LiquidityRemoved(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint256 lpBurned,\\n        string lID //* liquidity ID\\n    );\\n\\n    event ClaimFee(\\n        address indexed claimer,\\n        uint256 fees,\\n        uint256 lpTokenBurned,\\n        string lID //* liquidity ID\\n    );\\n\\n    event ClaimBonus(uint256 amount, address to, string uid);\\n    event ClaimTax(uint256 amount, address to, string uid);\\n    event Swap(\\n        uint256 amount0In,\\n        uint256 amount1In,\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address indexed to\\n    );\\n    modifier ensure(uint256 deadline) {\\n        require(deadline >= block.timestamp, \\\"UniqueSwapV2Router: EXPIRED\\\");\\n        _;\\n    }\\n\\n    uint256 private unlocked = 1;\\n    modifier lock() {\\n        require(unlocked == 1, \\\"UniqueSwapV2: LOCKED\\\");\\n        unlocked = 0;\\n        _;\\n        unlocked = 1;\\n    }\\n\\n    constructor(\\n        address _WM,\\n        address _WW,\\n        address _WLDLP,\\n        address _WETH,\\n        address _ULPT,\\n        address _Para,\\n        address _Treasury,\\n        address _LLPT,\\n        address _ULOCK,\\n        address _V1,\\n        uint256 _KLast,\\n        uint256 _CurrentK\\n    ) {\\n        WM = _WM;\\n        WW = _WW;\\n        WLDLP = _WLDLP;\\n        WETH = _WETH;\\n        ULPT = _ULPT;\\n        Para = _Para;\\n        Treasury = _Treasury;\\n        LLPT = _LLPT;\\n        ULOCK = _ULOCK;\\n        V1 = _V1;\\n        kLast = _KLast;\\n        currentK = _CurrentK;\\n\\n        admin = msg.sender;\\n    }\\n\\n    receive() external payable {\\n        // assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\\n    }\\n\\n    function getReserves()\\n        public\\n        view\\n        returns (\\n            uint112 _reserve0,\\n            uint112 _reserve1,\\n            uint32 _blockTimestampLast\\n        )\\n    {\\n        // console.log(\\\"getReserves called\\\");\\n        _reserve0 = reserve0;\\n        _reserve1 = reserve1;\\n        _blockTimestampLast = blockTimestampLast;\\n    }\\n\\n    // fetches and sorts the reserves for a pair\\n    function getReservesWithSort(\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 _reserve0, uint256 _reserve1, ) = getReserves();\\n        (reserveA, reserveB) = tokenA == token0\\n            ? (_reserve0, _reserve1)\\n            : (_reserve1, _reserve0);\\n    }\\n\\n    // **** ADD LIQUIDITY ****\\n    function _addLiquidity(\\n        uint256 amountADesired,\\n        uint256 amountBDesired,\\n        uint256 amountAMin,\\n        uint256 amountBMin\\n    ) internal virtual returns (uint256 amountA, uint256 amountB) {\\n        (uint256 reserveA, uint256 reserveB, ) = getReserves();\\n        // console.log(\\\"_addLiquidity reserveA: \\\", reserveA);\\n        // console.log(\\\"_addLiquidity reserveB: \\\", reserveB);\\n        // console.log(\\\"amountADesired: \\\", amountADesired);\\n        // console.log(\\\"amountBDesired: \\\", amountBDesired);\\n        // console.log(\\\"amountAMin: \\\", amountAMin);\\n        // console.log(\\\"amountBMin: \\\", amountBMin);\\n        if (reserveA == 0 && reserveB == 0) {\\n            (amountA, amountB) = (amountADesired, amountBDesired);\\n        } else {\\n            uint256 amountBOptimal = quote(amountADesired, reserveA, reserveB);\\n            // console.log(\\\"amountBOptimal: \\\", amountBOptimal);\\n            if (amountBOptimal <= amountBDesired) {\\n                require(\\n                    amountBOptimal >= amountBMin,\\n                    \\\"UniqueSwapV2Router: INSUFFICIENT_B_AMOUNT\\\"\\n                );\\n                (amountA, amountB) = (amountADesired, amountBOptimal);\\n            } else {\\n                uint256 amountAOptimal = quote(\\n                    amountBDesired,\\n                    reserveB,\\n                    reserveA\\n                );\\n                // console.log(\\\"amountAOptimal: \\\", amountAOptimal);\\n                assert(amountAOptimal <= amountADesired);\\n                require(\\n                    amountAOptimal >= amountAMin,\\n                    \\\"UniqueSwapV2Router: INSUFFICIENT_A_AMOUNT\\\"\\n                );\\n                (amountA, amountB) = (amountAOptimal, amountBDesired);\\n            }\\n        }\\n    }\\n\\n    function addLiquidityETH(\\n        uint256 amountTokenB,\\n        uint256 amountTokenBMin,\\n        uint256 amountETHMin,\\n        // address to,\\n        uint256 deadline\\n    )\\n        external\\n        payable\\n        ensure(deadline)\\n        returns (uint256 amountETH, uint256 amountToken, uint256 liquidity)\\n    {\\n        (amountETH, amountToken) = _addLiquidity(\\n            msg.value,\\n            amountTokenB,\\n            amountETHMin,\\n            amountTokenBMin\\n        );\\n        payable(WETH).transfer(msg.value);\\n        IERC20(WLDLP).relayTransfer(msg.sender, address(this), amountTokenB);\\n        IERC20(WLDLP).relayTransfer(address(this), ULOCK, amountTokenB);\\n\\n        IERC20(WM).relayTransfer(WETH, address(this), msg.value);\\n        IERC20(WW).relayTransfer(ULOCK, address(this), amountTokenB);\\n\\n        liquidity = mint(msg.sender);\\n    }\\n\\n    // **** REMOVE LIQUIDITY ****\\n    function removeLiquidityETH(\\n        uint256 deadline,\\n        uint256 lpToken,\\n        string memory lID,\\n        bytes memory signature\\n    ) public ensure(deadline) returns (uint256 amountA, uint256 amountB) {\\n        bytes32 message = prefixed(\\n            keccak256(abi.encodePacked(msg.sender, deadline, lID))\\n        );\\n        // console.log(\\\"admin: \\\", admin);\\n        // console.log(\\\"recoverSigner: \\\", recoverSigner(message, signature));\\n        require(recoverSigner(message, signature) == admin, \\\"wrong signature\\\");\\n        (uint256 amount0, uint256 amount1) = burn(msg.sender, lID, lpToken);\\n        // (address token0, ) = sortTokens(WM, WW);\\n        // // console.log(\\\"token0: \\\", token0);\\n        // // console.log(\\\"WM: \\\", WM);\\n        // console.log(\\\"amountAMin: \\\", amountAMin);\\n        // console.log(\\\"amountBMin: \\\", amountBMin);\\n        // // console.log(\\\"amount0: \\\", amount0);\\n        // // console.log(\\\"amount1: \\\", amount1);\\n        (amountA, amountB) = (amount0, amount1);\\n    }\\n\\n    // **** SWAP ****\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(\\n        uint256[] memory amounts,\\n        address[] memory path,\\n        address sender\\n    ) internal {\\n        (address input, address output) = (path[0], path[1]);\\n        (address token0, ) = sortTokens(input, output);\\n        uint256 amountOut = amounts[1];\\n        // console.log(\\\"input token: \\\", input);\\n        // console.log(\\\"token0: \\\", token0);\\n        // console.log(\\\"amountOut: \\\", amountOut);\\n\\n        (uint256 amount0Out, uint256 amount1Out) = input == token0\\n            ? (uint256(0), amountOut)\\n            : (amountOut, uint256(0));\\n        swap(amount0Out, amount1Out, sender);\\n    }\\n\\n    // we give exact eth to the contract and then we swap it for tokens\\n    function swapExactETHForTokens(\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        uint256 deadline\\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\\n        require(path[0] == WM, \\\"UniqueSwapV2Router: INVALID_PATH\\\");\\n        amounts = getAmountsOut(msg.value, path);\\n\\n        require(\\n            amounts[amounts.length - 1] >= amountOutMin,\\n            \\\"UniqueSwapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        // console.log(\\\"path[0]: \\\", path[0]);\\n        // console.log(\\\"path[1]: \\\", path[1]);\\n\\n        payable(WETH).transfer(msg.value);\\n        IERC20(WM).relayTransfer(WETH, address(this), msg.value);\\n        _swap(amounts, path, msg.sender);\\n    }\\n\\n    // we give exact tokens to the contract and then we swap it for eth\\n    function swapExactTokensForETH(\\n        uint256 amountIn,\\n        uint256 amountOutMin,\\n        address[] calldata path,\\n        uint256 deadline\\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\\n        require(\\n            path[path.length - 1] == WM,\\n            \\\"UniqueSwapV2Router: INVALID_PATH\\\"\\n        );\\n        amounts = getAmountsOut(amountIn, path);\\n\\n        require(\\n            amounts[amounts.length - 1] >= amountOutMin,\\n            \\\"UniqueSwapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n\\n        IERC20(WLDLP).relayTransfer(msg.sender, address(this), amounts[0]);\\n        IERC20(WLDLP).relayTransfer(address(this), ULOCK, amounts[0]);\\n        IERC20(WW).relayTransfer(ULOCK, address(this), amounts[0]);\\n        _swap(amounts, path, msg.sender);\\n    }\\n\\n    function swapETHForExactTokens(\\n        uint256 amountOut,\\n        address[] calldata path,\\n        uint256 deadline\\n    ) external payable ensure(deadline) returns (uint256[] memory amounts) {\\n        require(path[0] == WM, \\\"UniqueSwapV2Router: INVALID_PATH\\\");\\n        amounts = getAmountsIn(amountOut, path);\\n        require(\\n            amounts[0] <= msg.value,\\n            \\\"UniqueSwapV2Router: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n        payable(WETH).transfer(msg.value);\\n        IERC20(WM).relayTransfer(WETH, address(this), msg.value);\\n        _swap(amounts, path, msg.sender);\\n\\n        // refund dust eth, if any\\n        // if (msg.value > amounts[0])\\n        //     TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\\n    }\\n\\n    function swapTokensForExactETH(\\n        uint256 amountOut,\\n        uint256 amountInMax,\\n        address[] calldata path,\\n        uint256 deadline\\n    ) external ensure(deadline) returns (uint256[] memory amounts) {\\n        require(\\n            path[path.length - 1] == WM,\\n            \\\"UniqueSwapV2Router: INVALID_PATH\\\"\\n        );\\n        amounts = getAmountsIn(amountOut, path);\\n        require(\\n            amounts[0] <= amountInMax,\\n            \\\"UniqueSwapV2Router: EXCESSIVE_INPUT_AMOUNT\\\"\\n        );\\n\\n        IERC20(WLDLP).relayTransfer(msg.sender, address(this), amounts[0]);\\n        IERC20(WLDLP).relayTransfer(address(this), ULOCK, amounts[0]);\\n        IERC20(WW).relayTransfer(ULOCK, address(this), amounts[0]);\\n        _swap(amounts, path, msg.sender);\\n    }\\n\\n    /// custom functions ****************************************************\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function mint(address to) internal lock returns (uint256 liquidity) {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        uint256 balance0 = IERC20(WM).balanceOf(address(this));\\n        uint256 balance1 = IERC20(WW).balanceOf(address(this));\\n        uint256 amount0 = balance0 - _reserve0;\\n        uint256 amount1 = balance1 - _reserve1;\\n        // console.log(\\\"amount0: \\\", amount0);\\n        // console.log(\\\"amount1: \\\", amount1);\\n\\n        uint256 _totalSupply = IERC20(ULPT).totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\\n        // console.log(\\\"_totalSupply: \\\", _totalSupply);\\n        if (_totalSupply == 0) {\\n            liquidity = Math.sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY;\\n            // console.log(\\\"1.liquidity: \\\", liquidity);\\n            IERC20(ULPT).relayMint(WLDLP, MINIMUM_LIQUIDITY); // here WLDLP is temporary address instead of zero address\\n        } else {\\n            liquidity = Math.min(\\n                (amount0 * _totalSupply) / _reserve0,\\n                (amount1 * _totalSupply) / _reserve1\\n            );\\n        }\\n        // console.log(\\\"2. liquidity: \\\", liquidity);\\n        require(liquidity > 0, \\\"UniqueSwapV2: INSUFFICIENT_LIQUIDITY_MINTED\\\");\\n        IERC20(ULPT).relayMint(to, liquidity);\\n        // console.log(\\\"Mint done: \\\");\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        // console.log(\\\"Update done: \\\");\\n        kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\\n        currentK = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\\n        emit LiquidityCreated(\\n            to,\\n            amount0,\\n            amount1,\\n            liquidity,\\n            kLast,\\n            block.timestamp\\n        );\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function burn(\\n        address to,\\n        string memory lID,\\n        uint256 lpToken\\n    ) internal lock returns (uint amount0, uint amount1) {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        address _token0 = WM; // gas savings\\n        address _token1 = WW; // gas savings\\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\\n        // uint liquidity = IERC20(ULPT).balanceOf(msg.sender);\\n\\n        uint _totalSupply = IERC20(ULPT).totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = (lpToken * balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = (lpToken * balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n\\n        require(\\n            amount0 > 0 && amount1 > 0,\\n            \\\"UniqueSwapV2: INSUFFICIENT_LIQUIDITY_BURNED\\\"\\n        );\\n        // console.log(\\\"burn balance0: \\\", balance0);\\n        // console.log(\\\"burn balance1: \\\", balance1);\\n        // console.log(\\\"burn amount0: \\\", amount0);\\n        // console.log(\\\"burn amount1: \\\", amount1);\\n        // console.log(\\\"burn liquidity: \\\", liquidity);\\n        // console.log(\\\"burn _totalSupply: \\\", _totalSupply);\\n\\n        IERC20(ULPT).relayBurn(to, lpToken);\\n\\n        IERC20(_token0).relayTransfer(address(this), WETH, amount0);\\n        IERC20(WETH).ethTransfer(address(this), amount0);\\n\\n        IERC20(_token1).relayTransfer(address(this), ULOCK, amount1);\\n        IERC20(WLDLP).relayTransfer(ULOCK, address(this), amount1);\\n        IERC20(WLDLP).relayTransfer(address(this), to, amount1);\\n\\n        payable(to).transfer(amount0);\\n\\n        balance0 = IERC20(_token0).balanceOf(address(this));\\n        balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        kLast = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\\n        currentK = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\\n        emit LiquidityRemoved(to, amount0, amount1, lpToken, lID);\\n    }\\n\\n    // this low-level function should be called from a contract which performs important safety checks\\n    function swap(\\n        uint256 amount0Out,\\n        uint256 amount1Out,\\n        address to\\n    ) internal lock {\\n        require(\\n            amount0Out > 0 || amount1Out > 0,\\n            \\\"UniqueSwapV2: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        // console.log(\\\"swap _reserve0: \\\", _reserve0);\\n        // console.log(\\\"swap _reserve1: \\\", _reserve1);\\n        // console.log(\\\"swap amount0Out: \\\", amount0Out);\\n        // console.log(\\\"swap amount1Out: \\\", amount1Out);\\n        require(\\n            amount0Out < _reserve0 && amount1Out < _reserve1,\\n            \\\"UniqueSwapV2: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n\\n        uint256 balance0;\\n        uint256 balance1;\\n        {\\n            // scope for _token{0,1}, avoids stack too deep errors\\n            address _token0 = WM;\\n            address _token1 = WW;\\n            require(to != _token0 && to != _token1, \\\"UniqueSwapV2: INVALID_TO\\\");\\n            if (amount0Out > 0) {\\n                // console.log(\\\"amount0Out: \\\", amount0Out);\\n                IERC20(_token0).relayTransfer(address(this), WETH, amount0Out); // _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens\\n                IERC20(WETH).ethTransfer(address(this), amount0Out);\\n                payable(to).transfer(amount0Out);\\n            }\\n\\n            if (amount1Out > 0) {\\n                // console.log(\\\"amount1Out: \\\", amount1Out);\\n                IERC20(_token1).relayTransfer(address(this), ULOCK, amount1Out); // _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens\\n                IERC20(WLDLP).relayTransfer(ULOCK, address(this), amount1Out);\\n                IERC20(WLDLP).relayTransfer(address(this), to, amount1Out);\\n            }\\n\\n            balance0 = IERC20(_token0).balanceOf(address(this));\\n            balance1 = IERC20(_token1).balanceOf(address(this));\\n            // console.log(\\\"swap balance0: \\\", balance0);\\n            // console.log(\\\"swap balance1: \\\", balance1);\\n        }\\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\\n            ? balance0 - (_reserve0 - amount0Out)\\n            : 0;\\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\\n            ? balance1 - (_reserve1 - amount1Out)\\n            : 0;\\n        // console.log(\\\"blc amount0In: \\\", amount0In);\\n        // console.log(\\\"blc amount1In: \\\", amount1In);\\n\\n        require(\\n            amount0In > 0 || amount1In > 0,\\n            \\\"UniqueSwapV2: INSUFFICIENT_INPUT_AMOUNT\\\"\\n        );\\n        {\\n            // scope for reserve{0,1}Adjusted, avoids stack too deep errors\\n            uint256 balance0Adjusted = balance0 * 1000 - amount0In * 3;\\n            uint256 balance1Adjusted = balance1 * 1000 - amount1In * 3;\\n            require(\\n                balance0Adjusted * balance1Adjusted >=\\n                    uint256(_reserve0) * _reserve1 * 1e6,\\n                \\\"UniqueSwapV2: K\\\"\\n            );\\n        }\\n        _update(balance0, balance1, _reserve0, _reserve1);\\n        currentK = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\\n        emit Swap(amount0In, amount1In, amount0Out, amount1Out, to);\\n    }\\n\\n    // update reserves and, on the first call per block, price accumulators\\n    function _update(\\n        uint256 balance0,\\n        uint256 balance1,\\n        uint112 _reserve0,\\n        uint112 _reserve1\\n    ) private {\\n        require(\\n            balance0 <= type(uint112).max && balance1 <= type(uint112).max,\\n            \\\"UniqueSwapV2: OVERFLOW\\\"\\n        );\\n        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);\\n        unchecked {\\n            uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\\n            if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {\\n                // * never overflows, and + overflow is desired\\n                price0CumulativeLast +=\\n                    uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) *\\n                    timeElapsed;\\n                price1CumulativeLast +=\\n                    uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) *\\n                    timeElapsed;\\n            }\\n        }\\n        reserve0 = uint112(balance0);\\n        reserve1 = uint112(balance1);\\n        blockTimestampLast = blockTimestamp;\\n        emit Sync(reserve0, reserve1);\\n    }\\n\\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\\n    function quote(\\n        uint256 amountA,\\n        uint256 reserveA,\\n        uint256 reserveB\\n    ) public pure returns (uint256 amountB) {\\n        require(amountA > 0, \\\"UniqueSwapV2Library: INSUFFICIENT_AMOUNT\\\");\\n        require(\\n            reserveA > 0 && reserveB > 0,\\n            \\\"UniqueSwapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        amountB = (amountA * reserveB) / reserveA;\\n    }\\n\\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) public pure returns (uint256 amountOut) {\\n        require(amountIn > 0, \\\"UniqueSwapV2Library: INSUFFICIENT_INPUT_AMOUNT\\\");\\n        require(\\n            reserveIn > 0 && reserveOut > 0,\\n            \\\"UniqueSwapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint256 amountInWithFee = amountIn * 997;\\n        uint256 numerator = amountInWithFee * reserveOut;\\n        uint256 denominator = (reserveIn * 1000) + amountInWithFee;\\n        amountOut = numerator / denominator;\\n    }\\n\\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) public pure returns (uint256 amountIn) {\\n        require(\\n            amountOut > 0,\\n            \\\"UniqueSwapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\\\"\\n        );\\n        require(\\n            reserveIn > 0 && reserveOut > 0,\\n            \\\"UniqueSwapV2Library: INSUFFICIENT_LIQUIDITY\\\"\\n        );\\n        uint256 numerator = reserveIn * amountOut * 1000;\\n        uint256 denominator = (reserveOut - amountOut) * 997;\\n        amountIn = numerator / denominator + 1;\\n    }\\n\\n    // performs chained getAmountOut calculations on any number of pairs\\n    function getAmountsOut(\\n        uint256 amountIn,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniqueSwapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[0] = amountIn;\\n        (uint256 reserveIn, uint256 reserveOut) = getReservesWithSort(\\n            path[0],\\n            path[1]\\n        );\\n        amounts[1] = getAmountOut(amountIn, reserveIn, reserveOut);\\n        // console.log(\\\"amounts[0]: \\\", amounts[0]);\\n        // console.log(\\\"amounts[1]: \\\", amounts[1]);\\n    }\\n\\n    // performs chained getAmountIn calculations on any number of pairs\\n    function getAmountsIn(\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2, \\\"UniqueSwapV2Library: INVALID_PATH\\\");\\n        amounts = new uint256[](path.length);\\n        amounts[1] = amountOut;\\n        (uint256 reserveIn, uint256 reserveOut) = getReservesWithSort(\\n            path[0],\\n            path[1]\\n        );\\n        amounts[0] = getAmountIn(amounts[1], reserveIn, reserveOut);\\n    }\\n\\n    function deposit(uint256 amount) public payable {\\n        // require(msg.value == amount);\\n        // reciever.transfer(amount);\\n        // nothing else to do!\\n    }\\n\\n    // function checkMatic() public view returns (uint256) {\\n    //     return address(this).balance;\\n    // }\\n\\n    // function checkWrapMatic() public view returns (uint256) {\\n    //     return IERC20(WM).balanceOf(address(this));\\n    // }\\n\\n    // function checkWrapWLDLP() public view returns (uint256) {\\n    //     return IERC20(WW).balanceOf(address(this));\\n    // }\\n\\n    // function checkOriginalWLDLP() public view returns (uint256) {\\n    //     return IERC20(WLDLP).balanceOf(address(this));\\n    // }\\n\\n    // function transfer() public {\\n    //     uint256 maticBalance = address(this).balance;\\n    //     uint256 originalBalance = IERC20(WLDLP).balanceOf(address(this));\\n    //     // console.log(\\\"sync maticBalance: \\\", maticBalance);\\n    //     // console.log(\\\"sync originalBalance: \\\", originalBalance);\\n    //     if (maticBalance > 0) {\\n    //         IERC20(WM).relayTransfer(WETH, address(this), maticBalance);\\n    //     }\\n    //     if (originalBalance > 0) {\\n    //         IERC20(WLDLP).relayTransfer(address(this), WETH, originalBalance);\\n    //         IERC20(WW).relayTransfer(\\n    //             WETH,\\n    //             address(this),\\n    //             originalBalance\\n    //         );\\n    //     }\\n    // }\\n\\n    // force reserves to match balances\\n    function sync() external lock {\\n        // check contract hold matic\\n        uint256 maticBalance = address(this).balance;\\n        uint256 originalWLDLPBalance = IERC20(WLDLP).balanceOf(address(this));\\n        // console.log(\\\"sync maticBalance: \\\", maticBalance);\\n        // console.log(\\\"sync originalWLDLPBalance: \\\", originalWLDLPBalance);\\n        if (maticBalance > 0) {\\n            ethTransfer(WETH, maticBalance);\\n            IERC20(WM).relayTransfer(WETH, address(this), maticBalance);\\n        }\\n        if (originalWLDLPBalance > 0) {\\n            IERC20(WLDLP).relayTransfer(\\n                address(this),\\n                ULOCK,\\n                originalWLDLPBalance\\n            );\\n            IERC20(WW).relayTransfer(\\n                ULOCK,\\n                address(this),\\n                originalWLDLPBalance\\n            );\\n        }\\n\\n        _update(\\n            IERC20(WM).balanceOf(address(this)),\\n            IERC20(WW).balanceOf(address(this)),\\n            reserve0,\\n            reserve1\\n        );\\n    }\\n\\n    function sortTokens(\\n        address tokenA,\\n        address tokenB\\n    ) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB, \\\"UniqueSwapV2Library: IDENTICAL_ADDRESSES\\\");\\n        (token0, token1) = tokenA < tokenB\\n            ? (tokenA, tokenB)\\n            : (tokenB, tokenA);\\n        require(token0 != address(0), \\\"UniqueSwapV2Library: ZERO_ADDRESS\\\");\\n    }\\n\\n    function readFees(uint256 myK) internal view returns (uint256) {\\n        address _token0 = WM; // gas savings\\n        address _token1 = WW; // gas savings\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        uint256 lpTokens = IERC20(ULPT).balanceOf(msg.sender);\\n        // console.log(\\\"currentK: \\\", currentK);\\n        // console.log(\\\"lpTokens: \\\", lpTokens);\\n\\n        uint256 totalLpTokens = IERC20(ULPT).totalSupply();\\n        // console.log(\\\"totalLpTokens: \\\", totalLpTokens);\\n\\n        uint256 share = (lpTokens * currentK) / totalLpTokens;\\n        // console.log(\\\"share: \\\", share);\\n        require(share > myK, \\\"No fees to claim\\\");\\n        uint256 shareOfFees = share - myK;\\n        // console.log(\\\"shareOfFees: \\\", shareOfFees);\\n\\n        // uint256 feeSharePercent = (shareOfFees * 100) / currentK;\\n        // // console.log(\\\"feeSharePercent: \\\", feeSharePercent);\\n        uint256 feeInLPToken = (shareOfFees * totalLpTokens) / currentK;\\n        // console.log(\\\"feeInLPToken: \\\", feeInLPToken);\\n\\n        // console.log(\\\"balance0: \\\", balance0);\\n        // console.log(\\\"balance1: \\\", balance1);\\n\\n        uint256 amount0 = (feeInLPToken * balance0) / totalLpTokens; // using balances ensures pro-rata distribution\\n        uint256 amount1 = (feeInLPToken * balance1) / totalLpTokens; // using balances ensures pro-rata distribution\\n        // console.log(\\\"amount0: \\\", amount0);\\n        // console.log(\\\"amount1: \\\", amount1);\\n\\n        uint256 amountOUt = getAmountOut(amount0, reserve0, reserve1);\\n        // console.log(\\\"amountOUt: \\\", amountOUt);\\n        // calculate 5 percent of amountOut\\n        uint256 amountOut5Percent = (amountOUt * 2) / 100;\\n        // console.log(\\\"amountOut5Percent: \\\", amountOut5Percent);\\n\\n        uint256 totalWldlp = amount1 + (amountOUt - amountOut5Percent);\\n        // console.log(\\\"totalWldlp: \\\", totalWldlp);\\n        return totalWldlp;\\n    }\\n\\n    function readFee(\\n        uint256 myK,\\n        address walletid\\n    ) public view returns (uint256) {\\n        address _token0 = WM; // gas savings\\n        address _token1 = WW; // gas savings\\n        uint256 balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint256 balance1 = IERC20(_token1).balanceOf(address(this));\\n\\n        uint256 lpTokens = IERC20(ULPT).balanceOf(walletid);\\n        // console.log(\\\"currentK: \\\", currentK);\\n        // console.log(\\\"lpTokens: \\\", lpTokens);\\n\\n        uint256 totalLpTokens = IERC20(ULPT).totalSupply();\\n        // console.log(\\\"totalLpTokens: \\\", totalLpTokens);\\n\\n        uint256 share = (lpTokens * currentK) / totalLpTokens;\\n        // console.log(\\\"share: \\\", share);\\n        require(share > myK, \\\"No fees to claim\\\");\\n        uint256 shareOfFees = share - myK;\\n        // console.log(\\\"shareOfFees: \\\", shareOfFees);\\n\\n        // uint256 feeSharePercent = (shareOfFees * 100) / currentK;\\n        // // console.log(\\\"feeSharePercent: \\\", feeSharePercent);\\n        uint256 feeInLPToken = (shareOfFees * totalLpTokens) / currentK;\\n        // console.log(\\\"feeInLPToken: \\\", feeInLPToken);\\n\\n        // console.log(\\\"balance0: \\\", balance0);\\n        // console.log(\\\"balance1: \\\", balance1);\\n\\n        uint256 amount0 = (feeInLPToken * balance0) / totalLpTokens; // using balances ensures pro-rata distribution\\n        uint256 amount1 = (feeInLPToken * balance1) / totalLpTokens; // using balances ensures pro-rata distribution\\n        // console.log(\\\"amount0: \\\", amount0);\\n        // console.log(\\\"amount1: \\\", amount1);\\n\\n        uint256 amountOUt = getAmountOut(amount0, reserve0, reserve1);\\n        // console.log(\\\"amountOUt: \\\", amountOUt);\\n        // calculate 5 percent of amountOut\\n        uint256 amountOut5Percent = (amountOUt * 2) / 100;\\n        // console.log(\\\"amountOut5Percent: \\\", amountOut5Percent);\\n\\n        uint256 totalWldlp = amount1 + (amountOUt - amountOut5Percent);\\n        // console.log(\\\"totalWldlp: \\\", totalWldlp);\\n        return totalWldlp;\\n    }\\n\\n    function liquidityLock(\\n        uint256 amountIn1,\\n        uint256 deadline,\\n        string memory lID,\\n        uint256 lpAmount,\\n        bytes memory signature\\n    ) public {\\n        bytes32 message = prefixed(\\n            keccak256(\\n                abi.encodePacked(msg.sender, amountIn1, deadline, lID, lpAmount)\\n            )\\n        );\\n        // console.log(\\\"admin: \\\", admin);\\n        // console.log(\\\"recoverSigner: \\\", recoverSigner(message, signature));\\n        require(recoverSigner(message, signature) == admin, \\\"wrong signature\\\");\\n        uint256 amountOut20Percent = _liquidityLock(amountIn1, lpAmount);\\n        uint256 unlocksOn = block.timestamp + TIMEUNLOCK;\\n        emit LiquidityLock(\\n            msg.sender,\\n            amountOut20Percent,\\n            block.timestamp,\\n            lID,\\n            lpAmount,\\n            unlocksOn\\n        );\\n    }\\n\\n    function _liquidityLock(\\n        uint256 amountIn1,\\n        uint256 lpAmount\\n    ) internal lock returns (uint256 amountOut20Percent) {\\n        amountOut20Percent = (amountIn1 * 50) / 100;\\n        // console.log(\\\"amountOut20Percent: \\\", amountOut20Percent);\\n        IERC20(WLDLP).relayMint(Para, amountOut20Percent);\\n        IERC20(LLPT).relayMint(msg.sender, lpAmount);\\n    }\\n\\n    function liquidityUnLock(\\n        uint256 lpAmount,\\n        string memory lID,\\n        bytes memory signature\\n    ) public {\\n        bytes32 message = prefixed(\\n            keccak256(abi.encodePacked(msg.sender, lpAmount, lID))\\n        );\\n        require(recoverSigner(message, signature) == admin, \\\"wrong signature\\\");\\n        IERC20(LLPT).relayBurn(msg.sender, lpAmount);\\n        emit LiquidityUnLock(msg.sender, lpAmount, block.timestamp, lID);\\n    }\\n\\n    function claimFees(\\n        uint256 myK,\\n        uint256 deadline,\\n        string memory lID,\\n        bytes memory signature\\n    ) public ensure(deadline) {\\n        bytes32 message = prefixed(\\n            keccak256(abi.encodePacked(msg.sender, myK, deadline, lID))\\n        );\\n        // console.log(\\\"admin: \\\", admin);\\n        // console.log(\\\"recoverSigner: \\\", recoverSigner(message, signature));\\n        require(recoverSigner(message, signature) == admin, \\\"wrong signature\\\");\\n        _feeClaim(myK, lID);\\n    }\\n\\n    function claimBonus(\\n        uint256 amount,\\n        string memory uid,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) public ensure(deadline) {\\n        bytes32 message = prefixed(\\n            keccak256(abi.encodePacked(msg.sender, amount, uid, deadline))\\n        );\\n        // console.log(\\\"admin: \\\", admin);\\n        // console.log(\\\"recoverSigner: \\\", recoverSigner(message, signature));\\n        require(recoverSigner(message, signature) == admin, \\\"wrong signature\\\");\\n        _claimBonus(amount, msg.sender, uid);\\n    }\\n\\n    function _claimBonus(\\n        uint256 amount,\\n        address to,\\n        string memory uid\\n    ) internal lock {\\n        IERC20(WLDLP).relayTransfer(Para, to, amount);\\n        emit ClaimBonus(amount, to, uid);\\n    }\\n\\n    function claimTax(\\n        uint256 amount,\\n        string memory uid,\\n        uint256 deadline,\\n        bytes memory signature\\n    ) public ensure(deadline) {\\n        bytes32 message = prefixed(\\n            keccak256(abi.encodePacked(amount, uid, deadline))\\n        );\\n        // console.log(\\\"admin: \\\", admin);\\n        // console.log(\\\"recoverSigner: \\\", recoverSigner(message, signature));\\n        require(recoverSigner(message, signature) == admin, \\\"wrong signature\\\");\\n        _claimTax(amount, uid);\\n    }\\n\\n    function _claimTax(uint256 amount, string memory uid) internal lock {\\n        IERC20(WLDLP).relayTransfer(Para, Treasury, amount);\\n        emit ClaimTax(amount, Treasury, uid);\\n    }\\n\\n    function _feeClaim(uint256 myK, string memory lID) internal lock {\\n        uint balance0 = IERC20(WM).balanceOf(address(this));\\n        uint balance1 = IERC20(WW).balanceOf(address(this));\\n\\n        uint256 lpTokens = IERC20(ULPT).balanceOf(msg.sender);\\n        // console.log(\\\"currentK:\\\", currentK);\\n        // console.log(\\\"lpTokens:\\\", lpTokens);\\n\\n        uint256 totalLpTokens = IERC20(ULPT).totalSupply();\\n        // console.log(\\\"totalLpTokens: \\\", totalLpTokens);\\n\\n        uint256 share = (lpTokens * currentK) / totalLpTokens;\\n        // console.log(\\\"share: \\\", share);\\n        require(share > myK, \\\"No fees to claim\\\");\\n        uint256 shareOfFees = share - myK;\\n        // console.log(\\\"shareOfFees: \\\", shareOfFees);\\n\\n        // uint256 feeSharePercent = (shareOfFees * 100) / currentK;\\n        // // console.log(\\\"feeSharePercent: \\\", feeSharePercent);\\n        uint256 feeInLPToken = (shareOfFees * totalLpTokens) / currentK;\\n        // console.log(\\\"feeInLPToken: \\\", feeInLPToken);\\n\\n        // console.log(\\\"balance0: \\\", balance0);\\n        // console.log(\\\"balance1: \\\", balance1);\\n\\n        uint256 amount0 = (feeInLPToken * balance0) / totalLpTokens; // using balances ensures pro-rata distribution\\n        uint256 amount1 = (feeInLPToken * balance1) / totalLpTokens; // using balances ensures pro-rata distribution\\n        // console.log(\\\"amount0: \\\", amount0);\\n        // console.log(\\\"amount1: \\\", amount1);\\n\\n        string memory lID2 = lID;\\n\\n        uint256 amountOUt = getAmountOut(amount0, reserve0, reserve1);\\n        // console.log(\\\"amountOUt: \\\", amountOUt);\\n        // calculate 5 percent of amountOut\\n        uint256 amountOut5Percent = (amountOUt * 2) / 100;\\n        // console.log(\\\"amountOut5Percent: \\\", amountOut5Percent);\\n\\n        uint256 totalWldlp = amount1 + (amountOUt - amountOut5Percent);\\n        // console.log(\\\"totalWldlp: \\\", totalWldlp);\\n        IERC20(ULPT).relayBurn(msg.sender, feeInLPToken);\\n\\n        IERC20(WW).relayTransfer(address(this), ULOCK, totalWldlp);\\n        IERC20(WLDLP).relayTransfer(ULOCK, address(this), totalWldlp);\\n        IERC20(WLDLP).relayTransfer(address(this), msg.sender, totalWldlp);\\n\\n        uint balance01 = IERC20(WM).balanceOf(address(this));\\n        uint balance11 = IERC20(WW).balanceOf(address(this));\\n        // console.log(\\\"updated balance01: \\\", balance01);\\n        // console.log(\\\"updated balance11: \\\", balance11);\\n\\n        _update(balance01, balance11, reserve0, reserve1);\\n        currentK = uint256(reserve0) * reserve1; // reserve0 and reserve1 are up-to-date\\n\\n        emit ClaimFee(msg.sender, totalWldlp, feeInLPToken, lID2);\\n    }\\n\\n    function lPRemove(\\n        uint256 lpToken\\n    ) public view returns (uint amount0, uint amount1) {\\n        address _token0 = WM; // gas savings\\n        address _token1 = WW; // gas savings\\n        uint balance0 = IERC20(_token0).balanceOf(address(this));\\n        uint balance1 = IERC20(_token1).balanceOf(address(this));\\n        // uint liquidity = IERC20(ULPT).balanceOf(msg.sender);\\n\\n        uint _totalSupply = IERC20(ULPT).totalSupply(); // gas savings, must be defined here since totalSupply can update in _mintFee\\n        amount0 = (lpToken * balance0) / _totalSupply; // using balances ensures pro-rata distribution\\n        amount1 = (lpToken * balance1) / _totalSupply; // using balances ensures pro-rata distribution\\n\\n        require(\\n            amount0 > 0 && amount1 > 0,\\n            \\\"UniqueSwapV2: INSUFFICIENT_LIQUIDITY_BURNING\\\"\\n        );\\n    }\\n\\n    function rate1() public view returns (uint amount0) {\\n        (uint112 _reserve0, uint112 _reserve1, ) = getReserves(); // gas savings\\n        amount0 = getAmountIn(1000000000000000000, _reserve0, _reserve1);\\n    }\\n\\n    // signer recovery function\\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n            );\\n    }\\n\\n    function recoverSigner(\\n        bytes32 message,\\n        bytes memory sig\\n    ) internal pure returns (address) {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n\\n        (v, r, s) = splitSignature(sig);\\n\\n        return ecrecover(message, v, r, s);\\n    }\\n\\n    function splitSignature(\\n        bytes memory sig\\n    ) internal pure returns (uint8, bytes32, bytes32) {\\n        require(sig.length == 65, \\\"invalid signature length\\\");\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            // first 32 bytes, after the length prefix\\n            r := mload(add(sig, 32))\\n            // second 32 bytes\\n            s := mload(add(sig, 64))\\n            // final byte (first byte of the next 32 bytes)\\n            v := byte(0, mload(add(sig, 96)))\\n        }\\n\\n        return (v, r, s);\\n    }\\n\\n    function ethTransfer(address to, uint256 amount) internal {\\n        payable(to).transfer(amount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_WM\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WW\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WLDLP\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_WETH\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ULPT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Para\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_Treasury\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_LLPT\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ULOCK\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_V1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_KLast\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_CurrentK\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"}],\"name\":\"ClaimBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokenBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lID\",\"type\":\"string\"}],\"name\":\"ClaimFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"}],\"name\":\"ClaimTax\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pastK\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"LiquidityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lID\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"llpAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unlocksOn\",\"type\":\"uint256\"}],\"name\":\"LiquidityLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lID\",\"type\":\"string\"}],\"name\":\"LiquidityRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lID\",\"type\":\"string\"}],\"name\":\"LiquidityUnLock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1In\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0Out\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1Out\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve0\",\"type\":\"uint112\"},{\"indexed\":false,\"internalType\":\"uint112\",\"name\":\"reserve1\",\"type\":\"uint112\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIMEUNLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountTokenB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountTokenBMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountETHMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"addLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountETH\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"claimBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"myK\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"lID\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"claimTax\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveOut\",\"type\":\"uint256\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_reserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"_blockTimestampLast\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpToken\",\"type\":\"uint256\"}],\"name\":\"lPRemove\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"lID\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"liquidityLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lpAmount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"lID\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"liquidityUnLock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveB\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate1\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"myK\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"walletid\",\"type\":\"address\"}],\"name\":\"readFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpToken\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"lID\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"removeLiquidityETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapETHForExactTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactETHForTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMin\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapExactTokensForETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMax\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swapTokensForExactETH\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "UniqueSwapV2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000059880d11f47f8d70b77ebf2e10c44b815e5d47a3000000000000000000000000900ca196bd581ababe3c66516522a11df0f207920000000000000000000000007872ef9f1187bae5a522ddd0f29258e09976ceae000000000000000000000000263fd9bc95fbf5488eddbfef03bdf31075a1b794000000000000000000000000915df98094185efb706e519aa0652ee3bbc167660000000000000000000000000ba3bebffc40edcbcf5ed788bd2bbeb42c3a6d9400000000000000000000000090f7dbd856d3213f274b6019b76784a44cdc9223000000000000000000000000f8baae80cb70d544f572bf1bd935f3fd5d46688b00000000000000000000000019367f620ff6e2060a77e737504e2b5800dc1c55000000000000000000000000306320db703c38fd831ba15efc6996f2811f2c4d00000000000000000000000001c2e7b0bd5d036ae5fd791377f1a12f5dac0afe00000000000000000000000001c2e7b0bd5d036ae5fd791377f1a12f5dac0afe", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}