{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/smart-contract-wallet/WalletFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n//import \\\"@openzeppelin/contracts/proxy/Clones.sol\\\";\\nimport \\\"./Proxy.sol\\\";\\nimport \\\"./SmartWallet.sol\\\"; \\n//@review\\n//possibly IWallet.sol\\n\\ncontract WalletFactory {\\n    address internal _defaultImpl; \\n\\n    //states : registry\\n    mapping (address => bool) public isWalletExist;\\n\\n    constructor(address _baseImpl) {\\n        require(_baseImpl != address(0), \\\"base wallet address can not be zero\\\");\\n        _defaultImpl = _baseImpl;\\n    }\\n\\n    event WalletCreated(address indexed _proxy, address indexed _implementation, address indexed _owner);\\n\\n    /**\\n     * @notice Deploys wallet using create2 and points it to _defaultImpl\\n     * @param _owner EOA signatory of the wallet\\n     * @param _entryPoint AA 4337 entry point address\\n     * @param _handler fallback handler address\\n     * @param _index extra salt that allows to deploy more wallets if needed for same EOA (default 0)\\n     */\\n    function deployCounterFactualWallet(address _owner, address _entryPoint, address _handler, uint _index) public returns(address proxy){\\n        bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\\n        }\\n        require(address(proxy) != address(0), \\\"Create2 call failed\\\");\\n        emit WalletCreated(proxy,_defaultImpl,_owner);\\n        SmartWallet(proxy).init(_owner, _entryPoint, _handler);\\n        isWalletExist[proxy] = true;\\n    }\\n\\n    /**\\n     * @notice Deploys wallet using create and points it to _defaultImpl\\n     * @param _owner EOA signatory of the wallet\\n     * @param _entryPoint AA 4337 entry point address\\n     * @param _handler fallback handler address\\n    */ \\n    function deployWallet(address _owner, address _entryPoint, address _handler) public returns(address proxy){ \\n        bytes memory deploymentData = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            proxy := create(0x0, add(0x20, deploymentData), mload(deploymentData))\\n        }\\n        emit WalletCreated(proxy,_defaultImpl,_owner);\\n        SmartWallet(proxy).init(_owner, _entryPoint, _handler);\\n        isWalletExist[proxy] = true;\\n    }\\n\\n    /**\\n     * @notice Allows to find out wallet address prior to deployment\\n     * @param _owner EOA signatory of the wallet\\n     * @param _index extra salt that allows to deploy more wallets if needed for same EOA (default 0)\\n    */\\n    function getAddressForCounterfactualWallet(address _owner, uint _index) external view returns (address _wallet) {\\n       bytes memory code = abi.encodePacked(type(Proxy).creationCode, uint(uint160(_defaultImpl)));\\n       bytes32 salt = keccak256(abi.encodePacked(_owner, address(uint160(_index))));\\n       bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), address(this), salt, keccak256(code)));\\n        _wallet = address(uint160(uint(hash)));\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/smart-contract-wallet/Proxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Proxy // This is the user's wallet\\n * @notice Basic proxy that delegates all calls to a fixed implementing contract.\\n */\\ncontract Proxy {\\n\\n    /* This is the keccak-256 hash of \\\"biconomy.scw.proxy.implementation\\\" subtracted by 1, and is validated in the constructor */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\\n\\n    event Received(uint indexed value, address indexed sender, bytes data);\\n\\n    constructor(address _implementation) {\\n         assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"biconomy.scw.proxy.implementation\\\")) - 1));\\n         assembly {\\n             sstore(_IMPLEMENTATION_SLOT,_implementation) \\n         }\\n    }\\n\\n    fallback() external payable {\\n        address target;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            target := sload(_IMPLEMENTATION_SLOT)\\n            calldatacopy(0, 0, calldatasize())\\n            let result := delegatecall(gas(), target, 0, calldatasize(), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            switch result\\n            case 0 {revert(0, returndatasize())}\\n            default {return (0, returndatasize())}\\n        }\\n    }\\n\\n    receive() external payable {\\n        emit Received(msg.value, msg.sender, \\\"\\\");\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/smart-contract-wallet/SmartWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n//TODO\\n//review Base licensing\\n//https://spdx.org/licenses/\\n\\nimport \\\"./libs/LibAddress.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./IWallet.sol\\\";\\nimport \\\"./common/Singleton.sol\\\";\\nimport \\\"./storage/WalletStorage.sol\\\";\\nimport \\\"./base/ModuleManager.sol\\\";\\nimport \\\"./base/FallbackManager.sol\\\";\\nimport \\\"./common/SignatureDecoder.sol\\\";\\n// import \\\"./common/Hooks.sol\\\";\\nimport \\\"./common/SecuredTokenTransfer.sol\\\";\\nimport \\\"./interfaces/ISignatureValidator.sol\\\";\\nimport \\\"./interfaces/IERC165.sol\\\";\\nimport \\\"./libs/ECDSA.sol\\\";\\n\\n// Hooks not made a base yet\\ncontract SmartWallet is \\n     Singleton,\\n     IWallet,\\n     IERC165,\\n     WalletStorage,\\n     ModuleManager,\\n     SignatureDecoder,\\n     SecuredTokenTransfer,\\n     ISignatureValidatorConstants,\\n     FallbackManager,\\n     Initializable     \\n    {\\n    using ECDSA for bytes32;\\n    using LibAddress for address;\\n\\n    event ImplementationUpdated(address newImplementation);\\n    event ExecutionFailure(bytes32 txHash, uint256 payment);\\n    event ExecutionSuccess(bytes32 txHash, uint256 payment);\\n    event EntryPointChanged(address oldEntryPoint, address newEntryPoint);\\n    event EOAChanged(address indexed _scw, address indexed _oldEOA, address indexed _newEOA);\\n\\n    // modifiers\\n    // onlyOwner\\n    /**\\n     * @notice Throws if the sender is not an the owner.\\n     */\\n    modifier onlyOwner {\\n        require(msg.sender == owner, \\\"Smart Account:: Sender is not authorized\\\");\\n        _;\\n    }\\n\\n    // onlyOwner OR self\\n    modifier mixedAuth {\\n    require(msg.sender == owner || msg.sender == address(this),\\\"Only owner or self\\\");\\n    _;\\n   }\\n\\n    // @notice authorized modifier (onlySelf) is already inherited\\n\\n    // Setters\\n\\n    function setOwner(address _newOwner) external mixedAuth {\\n        require(_newOwner != address(0), \\\"Smart Account:: new Signatory address cannot be zero\\\");\\n        owner = _newOwner;\\n        emit EOAChanged(address(this),owner,_newOwner);\\n    }\\n\\n    /**\\n     * @notice Updates the implementation of the base wallet\\n     * @param _implementation New wallet implementation\\n     */\\n    function updateImplementation(address _implementation) external mixedAuth {\\n        require(_implementation.isContract(), \\\"INVALID_IMPLEMENTATION\\\");\\n        _setImplementation(_implementation);\\n        emit ImplementationUpdated(_implementation);\\n    }\\n\\n    function updateEntryPoint(address _entryPoint) external mixedAuth {\\n        require(_entryPoint != address(0), \\\"Smart Account:: new entry point address cannot be zero\\\");\\n        emit EntryPointChanged(entryPoint, _entryPoint);\\n        entryPoint = _entryPoint;\\n    }\\n\\n    // Getters\\n\\n    function domainSeparator() public view returns (bytes32) {\\n        return keccak256(abi.encode(DOMAIN_SEPARATOR_TYPEHASH, getChainId(), this));\\n    }\\n\\n    /// @dev Returns the chain id used by this contract.\\n    function getChainId() public view returns (uint256) {\\n        uint256 id;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n\\n    /**\\n     * @dev returns a value from the nonces 2d mapping\\n     * @param batchId : the key of the user's batch being queried\\n     * @return nonce : the number of transaction made within said batch\\n     */\\n    function getNonce(uint256 batchId)\\n    public view\\n    returns (uint256) {\\n        return nonces[batchId];\\n    }\\n    \\n    // Initialize / Setup\\n    // Used to setup\\n    // i. owner ii. entry point iii. handlers\\n    function init(address _owner, address _entryPoint, address _handler) public initializer { \\n        require(owner == address(0), \\\"Already initialized\\\");\\n        require(entryPoint == address(0), \\\"Already initialized\\\");\\n        require(_owner != address(0),\\\"Invalid owner\\\");\\n        require(_entryPoint != address(0), \\\"Invalid Entrypoint\\\");\\n        owner = _owner;\\n        entryPoint = _entryPoint;\\n        if (_handler != address(0)) internalSetFallbackHandler(_handler);\\n        setupModules(address(0), bytes(\\\"\\\"));\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    // @review 2D nonces and args as default batchId 0 is always used\\n    // TODO : Update description\\n    // TODO : Add batchId and update in test cases, utils etc\\n    // Gnosis style transaction with optional repay in native tokens OR ERC20 \\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners and then pays the account that submitted the transaction.\\n    /// Note: The fees are always transferred, even if the user transaction fails.\\n    /// @param _tx Wallet transaction \\n    /// @param batchId batchId key for 2D nonces\\n    /// @param refundInfo Required information for gas refunds\\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\\n    function execTransaction(\\n        Transaction memory _tx,\\n        uint256 batchId,\\n        FeeRefund memory refundInfo,\\n        bytes memory signatures\\n    ) public payable virtual returns (bool success) {\\n        bytes32 txHash;\\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\\n        {\\n            bytes memory txHashData =\\n                encodeTransactionData(\\n                    // Transaction info\\n                    _tx,\\n                    // Payment info\\n                    refundInfo,\\n                    // Signature info\\n                    nonces[batchId]\\n                );\\n            // Increase nonce and execute transaction.\\n            // Default space aka batchId is 0\\n            nonces[batchId]++;\\n            txHash = keccak256(txHashData);\\n            checkSignatures(txHash, txHashData, signatures);\\n        }\\n\\n\\n        // We require some gas to emit the events (at least 2500) after the execution and some to perform code until the execution (500)\\n        // We also include the 1/64 in the check that is not send along with a call to counteract potential shortings because of EIP-150\\n        require(gasleft() >= max((_tx.targetTxGas * 64) / 63,_tx.targetTxGas + 2500) + 500, \\\"BSA010\\\");\\n        // Use scope here to limit variable lifetime and prevent `stack too deep` errors\\n        {\\n            uint256 gasUsed = gasleft();\\n            // If the gasPrice is 0 we assume that nearly all available gas can be used (it is always more than targetTxGas)\\n            // We only substract 2500 (compared to the 3000 before) to ensure that the amount passed is still higher than targetTxGas\\n            success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);\\n            gasUsed = gasUsed - gasleft();\\n            // If no targetTxGas and no gasPrice was set (e.g. both are 0), then the internal tx is required to be successful\\n            // This makes it possible to use `estimateGas` without issues, as it searches for the minimum gas where the tx doesn't revert\\n            require(success || _tx.targetTxGas != 0 || refundInfo.gasPrice != 0, \\\"BSA013\\\");\\n            // We transfer the calculated tx costs to the tx.origin to avoid sending it to intermediate contracts that have made calls\\n            uint256 payment = 0;\\n            if (refundInfo.gasPrice > 0) {\\n                payment = handlePayment(gasUsed, refundInfo.baseGas, refundInfo.gasPrice, refundInfo.gasToken, refundInfo.refundReceiver);\\n            }\\n            if (success) emit ExecutionSuccess(txHash, payment);\\n            else emit ExecutionFailure(txHash, payment);\\n        }\\n    }\\n\\n    function handlePayment(\\n        uint256 gasUsed,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver\\n    ) private returns (uint256 payment) {\\n        // solhint-disable-next-line avoid-tx-origin\\n        address payable receiver = refundReceiver == address(0) ? payable(tx.origin) : refundReceiver;\\n        if (gasToken == address(0)) {\\n            // For ETH we will only adjust the gas price to not be higher than the actual used gas price\\n            payment = (gasUsed + baseGas) * (gasPrice < tx.gasprice ? gasPrice : tx.gasprice);\\n            // Review: low level call value vs transfer\\n            (bool success,) = receiver.call{value: payment}(\\\"\\\");\\n            require(success, \\\"BSA011\\\");\\n        } else {\\n            payment = (gasUsed + baseGas) * (gasPrice);\\n            require(transferToken(gasToken, receiver, payment), \\\"BSA012\\\");\\n        }\\n    }\\n\\n    // @review\\n    /**\\n     * @dev Checks whether the signature provided is valid for the provided data, hash. Will revert otherwise.\\n     * @param dataHash Hash of the data (could be either a message hash or transaction hash)\\n     * @param signatures Signature data that should be verified. Can be ECDSA signature, contract signature (EIP-1271) or approved hash.\\n     */\\n    function checkSignatures(\\n        bytes32 dataHash,\\n        bytes memory data,\\n        bytes memory signatures\\n    ) public view {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 i = 0;\\n        address _signer;\\n        (v, r, s) = signatureSplit(signatures, i);\\n        // review if necessary v = 1\\n        // review sig verification from other wallets\\n        if(v == 0) {\\n            // If v is 0 then it is a contract signature\\n            // When handling contract signatures the address of the contract is encoded into r\\n            _signer = address(uint160(uint256(r)));\\n\\n            // Check that signature data pointer (s) is not pointing inside the static part of the signatures bytes\\n                // This check is not completely accurate, since it is possible that more signatures than the threshold are send.\\n                // Here we only check that the pointer is not pointing inside the part that is being processed\\n                require(uint256(s) >= uint256(1) * 65, \\\"BSA021\\\");\\n\\n                // Check that signature data pointer (s) is in bounds (points to the length of data -> 32 bytes)\\n                require(uint256(s) + 32 <= signatures.length, \\\"BSA022\\\");\\n\\n                // Check if the contract signature is in bounds: start of data is s + 32 and end is start + signature length\\n                uint256 contractSignatureLen;\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    contractSignatureLen := mload(add(add(signatures, s), 0x20))\\n                }\\n                require(uint256(s) + 32 + contractSignatureLen <= signatures.length, \\\"BSA023\\\");\\n\\n                // Check signature\\n                bytes memory contractSignature;\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    // The signature data for contract signatures is appended to the concatenated signatures and the offset is stored in s\\n                    contractSignature := add(add(signatures, s), 0x20)\\n                }\\n                require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, \\\"BSA024\\\");\\n        }\\n        else if(v > 30) {\\n            // If v > 30 then default va (27,28) has been adjusted for eth_sign flow\\n            // To support eth_sign and similar we adjust v and hash the messageHash with the Ethereum message prefix before applying ecrecover\\n            _signer = ecrecover(keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", dataHash)), v - 4, r, s);\\n            require(_signer == owner, \\\"INVALID_SIGNATURE\\\");\\n        } else {\\n            _signer = ecrecover(dataHash, v, r, s);\\n            require(_signer == owner, \\\"INVALID_SIGNATURE\\\");\\n        }\\n    }\\n\\n    /// review necessity for this method for estimating execute call\\n    /// @dev Allows to estimate a transaction.\\n    ///      This method is only meant for estimation purpose, therefore the call will always revert and encode the result in the revert data.\\n    ///      Since the `estimateGas` function includes refunds, call this method to get an estimated of the costs that are deducted from the safe with `execTransaction`\\n    /// @param to Destination address of Safe transaction.\\n    /// @param value Ether value of transaction.\\n    /// @param data Data payload of transaction.\\n    /// @param operation Operation type of transaction.\\n    /// @return Estimate without refunds and overhead fees (base transaction and payload data gas costs).\\n    function requiredTxGas(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation\\n    ) external returns (uint256) {\\n        uint256 startGas = gasleft();\\n        // We don't provide an error message here, as we use it to return the estimate\\n        require(execute(to, value, data, operation, gasleft()));\\n        uint256 requiredGas = startGas - gasleft();\\n        // Convert response to string and return via error message\\n        revert(string(abi.encodePacked(requiredGas)));\\n    }\\n\\n\\n    /// @dev Returns hash to be signed by owner.\\n    /// @param to Destination address.\\n    /// @param value Ether value.\\n    /// @param data Data payload.\\n    /// @param operation Operation type.\\n    /// @param targetTxGas Fas that should be used for the safe transaction.\\n    /// @param baseGas Gas costs for data used to trigger the safe transaction.\\n    /// @param gasPrice Maximum gas price that should be used for this transaction.\\n    /// @param gasToken Token address (or 0 if ETH) that is used for the payment.\\n    /// @param refundReceiver Address of receiver of gas payment (or 0 if tx.origin).\\n    /// @param _nonce Transaction nonce.\\n    /// @return Transaction hash.\\n    function getTransactionHash(\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Enum.Operation operation,\\n        uint256 targetTxGas,\\n        uint256 baseGas,\\n        uint256 gasPrice,\\n        address gasToken,\\n        address payable refundReceiver,\\n        uint256 _nonce\\n    ) public view returns (bytes32) {\\n        Transaction memory _tx = Transaction({\\n            to: to,\\n            value: value,\\n            data: data,\\n            operation: operation,\\n            targetTxGas: targetTxGas\\n        });\\n        FeeRefund memory refundInfo = FeeRefund({\\n            baseGas: baseGas,\\n            gasPrice: gasPrice,\\n            gasToken: gasToken,\\n            refundReceiver: refundReceiver\\n        });\\n        return keccak256(encodeTransactionData(_tx, refundInfo, _nonce));\\n    }\\n\\n\\n    /// @dev Returns the bytes that are hashed to be signed by owner.\\n    /// @param _tx Wallet transaction \\n    /// @param refundInfo Required information for gas refunds\\n    /// @param _nonce Transaction nonce.\\n    /// @return Transaction hash bytes.\\n    function encodeTransactionData(\\n        Transaction memory _tx,\\n        FeeRefund memory refundInfo,\\n        uint256 _nonce\\n    ) public view returns (bytes memory) {\\n        bytes32 safeTxHash =\\n            keccak256(\\n                abi.encode(\\n                    WALLET_TX_TYPEHASH,\\n                    _tx.to,\\n                    _tx.value,\\n                    keccak256(_tx.data),\\n                    _tx.operation,\\n                    _tx.targetTxGas,\\n                    refundInfo.baseGas,\\n                    refundInfo.gasPrice,\\n                    refundInfo.gasToken,\\n                    refundInfo.refundReceiver,\\n                    _nonce\\n                )\\n            );\\n        return abi.encodePacked(bytes1(0x19), bytes1(0x01), domainSeparator(), safeTxHash);\\n    }\\n\\n    // Extra Utils\\n    \\n    // Review: low level call value vs transfer // dest.transfer(amount);\\n    function transfer(address payable dest, uint amount) external onlyOwner {\\n        require(dest != address(0), \\\"this action will burn your funds\\\");\\n        (bool success,) = dest.call{value:amount}(\\\"\\\");\\n        require(success,\\\"transfer failed\\\");\\n    }\\n\\n    function pullTokens(address token, address dest, uint256 amount) external onlyOwner {\\n        IERC20 tokenContract = IERC20(token);\\n        SafeERC20.safeTransfer(tokenContract, dest, amount);\\n    }\\n\\n    function exec(address dest, uint value, bytes calldata func) external onlyOwner{\\n        _call(dest, value, func);\\n    }\\n\\n    function execBatch(address[] calldata dest, bytes[] calldata func) external onlyOwner{\\n        require(dest.length == func.length, \\\"wrong array lengths\\\");\\n        for (uint i = 0; i < dest.length;) {\\n            _call(dest[i], 0, func[i]);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    // AA implementation\\n    function _call(address sender, uint value, bytes memory data) internal {\\n        // @review linter\\n        (bool success, bytes memory result) = sender.call{value : value}(data);\\n        if (!success) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                revert(add(result,32), mload(result))\\n            }\\n        }\\n    }\\n\\n    function _requireFromEntryPoint() internal view {\\n        require(msg.sender == address(entryPoint), \\\"wallet: not from EntryPoint\\\");\\n    }\\n\\n    //called by entryPoint, only after validateUserOp succeeded.\\n    function execFromEntryPoint(address dest, uint value, bytes calldata func) external {\\n        _requireFromEntryPoint();\\n        _call(dest, value, func);\\n    }\\n\\n    function validateUserOp(UserOperation calldata userOp, bytes32 requestId, uint requiredPrefund) external override {\\n        _requireFromEntryPoint();\\n        _validateSignature(userOp, requestId);\\n        //during construction, the \\\"nonce\\\" field hold the salt.\\n        // if we assert it is zero, then we allow only a single wallet per owner.\\n        if (userOp.initCode.length == 0) {\\n            _validateAndUpdateNonce(userOp);\\n        }\\n        _payPrefund(requiredPrefund);\\n    }\\n\\n    // review nonce conflict with AA userOp nonce\\n    // userOp can omit nonce or have batchId as well!\\n    function _validateAndUpdateNonce(UserOperation calldata userOp) internal {\\n        require(nonces[0]++ == userOp.nonce, \\\"wallet: invalid nonce\\\");\\n    }\\n\\n    function _payPrefund(uint requiredPrefund) internal {\\n        if (requiredPrefund != 0) {\\n            //pay required prefund. make sure NOT to use the \\\"gas\\\" opcode, which is banned during validateUserOp\\n            // (and used by default by the \\\"call\\\")\\n            // @review linter\\n            (bool success,) = payable(msg.sender).call{value : requiredPrefund, gas : type(uint).max}(\\\"\\\");\\n            (success);\\n            //ignore failure (its EntryPoint's job to verify, not wallet.)\\n        }\\n    }\\n\\n    function _validateSignature(UserOperation calldata userOp, bytes32 requestId) internal view {\\n        bytes32 hash = requestId.toEthSignedMessageHash();\\n        require(owner == hash.recover(userOp.signature), \\\"wallet: wrong signature\\\");\\n    }\\n\\n    \\n    /**\\n     * @notice Query if a contract implements an interface\\n     * @param interfaceId The interface identifier, as specified in ERC165\\n     * @return `true` if the contract implements `_interfaceID`\\n    */\\n    function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId; // 0x01ffc9a7\\n    }\\n\\n    // Review\\n    // withdrawDepositTo\\n    // addDeposit\\n    // getDeposit\\n}\"\r\n    },\r\n    \"contracts/smart-contract-wallet/libs/LibAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary LibAddress {\\n  /**\\n   * @notice Will return true if provided address is a contract\\n   * @param account Address to verify if contract or not\\n   * @dev This contract will return false if called within the constructor of\\n   *      a contract's deployment, as the code is not yet stored on-chain.\\n   */\\n  function isContract(address account) internal view returns (bool) {\\n    uint256 csize;\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly { csize := extcodesize(account) }\\n    return csize != 0;\\n  }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !Address.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/IWallet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libs/UserOperation.sol\\\";\\n\\ninterface IWallet {\\n\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfuly.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param requestId hash of the user's request data. can be used as the basis for signature.\\n     * @param requiredPrefund the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\\n     */\\n    function validateUserOp(UserOperation calldata userOp, bytes32 requestId, uint requiredPrefund) external;\\n}\"\r\n    },\r\n    \"contracts/smart-contract-wallet/common/Singleton.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/// @title Singleton - Base for singleton contracts (should always be first super contract)\\n///         This contract is tightly coupled to the proxy contract\\ncontract Singleton {\\n    // singleton slot always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\\n\\n    /* This is the keccak-256 hash of \\\"biconomy.scw.proxy.implementation\\\" subtracted by 1 */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x37722d148fb373b961a84120b6c8d209709b45377878a466db32bbc40d95af26;\\n\\n    function _setImplementation(address _imp) internal {\\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\\\"biconomy.scw.proxy.implementation\\\")) - 1));\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n          sstore(_IMPLEMENTATION_SLOT, _imp)\\n         }\\n    }\\n\\n    function _getImplementation() internal view returns (address _imp) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n         _imp := sload(_IMPLEMENTATION_SLOT)\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/storage/WalletStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../common/Enum.sol\\\";\\n\\ncontract WalletStorage {\\n    // Version\\n    string public constant VERSION = \\\"0.0.1\\\";\\n\\n    // Domain Seperators\\n    // keccak256(\\n    //     \\\"EIP712Domain(uint256 chainId,address verifyingContract)\\\"\\n    // );\\n    bytes32 internal constant DOMAIN_SEPARATOR_TYPEHASH = 0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218;\\n\\n    // @review for any modifications\\n    // keccak256(\\n    //     \\\"WalletTx(address to,uint256 value,bytes data,uint8 operation,uint256 targetTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address refundReceiver,uint256 nonce)\\\"\\n    // );\\n    bytes32 internal constant WALLET_TX_TYPEHASH = 0xeedfef42e81fe8cd0e4185e4320e9f8d52fd97eb890b85fa9bd7ad97c9a18de2;\\n\\n    // Owner storage\\n    address public owner;\\n\\n    struct Transaction {\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        Enum.Operation operation;\\n        uint256 targetTxGas;\\n        // uint256 batchId;\\n    }\\n\\n    struct FeeRefund {\\n        uint256 baseGas;\\n        uint256 gasPrice; //gasPrice or tokenGasPrice\\n        address gasToken;\\n        address payable refundReceiver;\\n    }\\n\\n    // @review\\n    // uint256 public nonce; //changed to 2D nonce\\n    mapping(uint256 => uint256) public nonces;\\n\\n    // AA storage\\n    address public entryPoint;\\n}\"\r\n    },\r\n    \"contracts/smart-contract-wallet/base/ModuleManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"../common/Enum.sol\\\";\\nimport \\\"../common/SelfAuthorized.sol\\\";\\nimport \\\"./Executor.sol\\\";\\n\\n/// @title Module Manager - A contract that manages modules that can execute transactions via this contract\\ncontract ModuleManager is SelfAuthorized, Executor {    \\n    // Events\\n    event EnabledModule(address module);\\n    event DisabledModule(address module);\\n    event ExecutionFromModuleSuccess(address indexed module);\\n    event ExecutionFromModuleFailure(address indexed module);\\n\\n    address internal constant SENTINEL_MODULES = address(0x1);\\n\\n    mapping(address => address) internal modules;\\n\\n    function setupModules(address to, bytes memory data) internal {\\n        require(modules[SENTINEL_MODULES] == address(0), \\\"BSA100\\\");\\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\\n        if (to != address(0))\\n            // Setup has to complete successfully or transaction fails.\\n            require(execute(to, 0, data, Enum.Operation.DelegateCall, gasleft()), \\\"BSA000\\\");\\n    }\\n\\n    /// @dev Allows to add a module to the whitelist.\\n    ///      This can only be done via a Safe transaction.\\n    /// @notice Enables the module `module` for the Safe.\\n    /// @param module Module to be whitelisted.\\n    function enableModule(address module) public authorized {\\n        // Module address cannot be null or sentinel.\\n        require(module != address(0) && module != SENTINEL_MODULES, \\\"BSA101\\\");\\n        // Module cannot be added twice.\\n        require(modules[module] == address(0), \\\"BSA102\\\");\\n        modules[module] = modules[SENTINEL_MODULES];\\n        modules[SENTINEL_MODULES] = module;\\n        emit EnabledModule(module);\\n    }\\n\\n    /// @dev Allows to remove a module from the whitelist.\\n    ///      This can only be done via a Safe transaction.\\n    /// @notice Disables the module `module` for the Safe.\\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\\n    /// @param module Module to be removed.\\n    function disableModule(address prevModule, address module) public authorized {\\n        // Validate module address and check that it corresponds to module index.\\n        require(module != address(0) && module != SENTINEL_MODULES, \\\"BSA101\\\");\\n        require(modules[prevModule] == module, \\\"BSA103\\\");\\n        modules[prevModule] = modules[module];\\n        modules[module] = address(0);\\n        emit DisabledModule(module);\\n    }\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModule(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) public virtual returns (bool success) {\\n        // Only whitelisted modules are allowed.\\n        require(msg.sender != SENTINEL_MODULES && modules[msg.sender] != address(0), \\\"BSA104\\\");\\n        // Execute transaction without further confirmations.\\n        success = execute(to, value, data, operation, gasleft());\\n        if (success) emit ExecutionFromModuleSuccess(msg.sender);\\n        else emit ExecutionFromModuleFailure(msg.sender);\\n    }\\n\\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations and return data\\n    /// @param to Destination address of module transaction.\\n    /// @param value Ether value of module transaction.\\n    /// @param data Data payload of module transaction.\\n    /// @param operation Operation type of module transaction.\\n    function execTransactionFromModuleReturnData(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation\\n    ) public returns (bool success, bytes memory returnData) {\\n        success = execTransactionFromModule(to, value, data, operation);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // Load free memory location\\n            let ptr := mload(0x40)\\n            // We allocate memory for the return data by setting the free memory location to\\n            // current free memory location + data size + 32 bytes for data size value\\n            mstore(0x40, add(ptr, add(returndatasize(), 0x20)))\\n            // Store the size\\n            mstore(ptr, returndatasize())\\n            // Store the data\\n            returndatacopy(add(ptr, 0x20), 0, returndatasize())\\n            // Point the return data to the correct memory location\\n            returnData := ptr\\n        }\\n    }\\n\\n    /// @dev Returns if an module is enabled\\n    /// @return True if the module is enabled\\n    function isModuleEnabled(address module) public view returns (bool) {\\n        return SENTINEL_MODULES != module && modules[module] != address(0);\\n    }\\n\\n    /// @dev Returns array of modules. Useful for a widget\\n    /// @param start Start of the page.\\n    /// @param pageSize Maximum number of modules that should be returned.\\n    /// @return array Array of modules.\\n    /// @return next Start of the next page.\\n    function getModulesPaginated(address start, uint256 pageSize) external view returns (address[] memory array, address next) {\\n        // Init array with max page size\\n        array = new address[](pageSize);\\n\\n        // Populate return array\\n        uint256 moduleCount = 0;\\n        address currentModule = modules[start];\\n        while (currentModule != address(0x0) && currentModule != SENTINEL_MODULES && moduleCount < pageSize) {\\n            array[moduleCount] = currentModule;\\n            currentModule = modules[currentModule];\\n            moduleCount++;\\n        }\\n        next = currentModule;\\n        // Set correct size of returned array\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            mstore(array, moduleCount)\\n        }\\n    }\\n}\"\r\n    },\r\n    \"contracts/smart-contract-wallet/base/FallbackManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"../common/SelfAuthorized.sol\\\";\\n\\n/// @title Fallback Manager - A contract that manages fallback calls made to this contract\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract FallbackManager is SelfAuthorized {\\n    event ChangedFallbackHandler(address handler);\\n\\n    // keccak256(\\\"fallback_manager.handler.address\\\")\\n    bytes32 internal constant FALLBACK_HANDLER_STORAGE_SLOT = 0x6c9a6c4a39284e37ed1cf53d337577d14212a4870fb976a4366c693b939918d5;\\n\\n    function internalSetFallbackHandler(address handler) internal {\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            sstore(slot, handler)\\n        }\\n    }\\n\\n    /// @dev Allows to add a contract to handle fallback calls.\\n    ///      Only fallback calls without value and with data will be forwarded.\\n    ///      This can only be done via a Safe transaction.\\n    /// @param handler contract to handle fallback calls.\\n    function setFallbackHandler(address handler) public authorized {\\n        internalSetFallbackHandler(handler);\\n        emit ChangedFallbackHandler(handler);\\n    }\\n\\n    // solhint-disable-next-line payable-fallback,no-complex-fallback\\n    fallback() external {\\n        bytes32 slot = FALLBACK_HANDLER_STORAGE_SLOT;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let handler := sload(slot)\\n            if iszero(handler) {\\n                return(0, 0)\\n            }\\n            calldatacopy(0, 0, calldatasize())\\n            // The msg.sender address is shifted to the left by 12 bytes to remove the padding\\n            // Then the address without padding is stored right after the calldata\\n            mstore(calldatasize(), shl(96, caller()))\\n            // Add 20 bytes for the address appended add the end\\n            let success := call(gas(), handler, 0, 0, add(calldatasize(), 20), 0, 0)\\n            returndatacopy(0, 0, returndatasize())\\n            if iszero(success) {\\n                revert(0, returndatasize())\\n            }\\n            return(0, returndatasize())\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/common/SignatureDecoder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/// @title SignatureDecoder - Decodes signatures that a encoded as bytes\\ncontract SignatureDecoder {\\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`.\\n    /// @notice Make sure to perform a bounds check for @param pos, to avoid out of bounds access on @param signatures\\n    /// @param pos which signature to read. A prior bounds check of this parameter should be performed, to avoid out of bounds access\\n    /// @param signatures concatenated rsv signatures\\n    function signatureSplit(bytes memory signatures, uint256 pos)\\n        internal\\n        pure\\n        returns (\\n            uint8 v,\\n            bytes32 r,\\n            bytes32 s\\n        )\\n    {\\n        // The signature format is a compact form of:\\n        //   {bytes32 r}{bytes32 s}{uint8 v}\\n        // Compact means, uint8 is not padded to 32 bytes.\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let signaturePos := mul(0x41, pos)\\n            r := mload(add(signatures, add(signaturePos, 0x20)))\\n            s := mload(add(signatures, add(signaturePos, 0x40)))\\n            // Here we are loading the last 32 bytes, including 31 bytes\\n            // of 's'. There is no 'mload8' to do this.\\n            //\\n            // 'byte' is not working due to the Solidity parser, so lets\\n            // use the second best option, 'and'\\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/common/SecuredTokenTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/// @title SecuredTokenTransfer - Secure token transfer\\ncontract SecuredTokenTransfer {\\n    /// @dev Transfers a token and returns if it was a success\\n    /// @param token Token that should be transferred\\n    /// @param receiver Receiver to whom the token should be transferred\\n    /// @param amount The amount of tokens that should be transferred\\n    function transferToken(\\n        address token,\\n        address receiver,\\n        uint256 amount\\n    ) internal returns (bool transferred) {\\n        // 0xa9059cbb - keccack(\\\"transfer(address,uint256)\\\")\\n        // Review for sig collision and HAL-04\\n        bytes memory data = abi.encodeWithSelector(0xa9059cbb, receiver, amount);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // We write the return value to scratch space.\\n            // See https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html#layout-in-memory\\n            let success := call(sub(gas(), 10000), token, 0, add(data, 0x20), mload(data), 0, 0x20)\\n            switch returndatasize()\\n                case 0 {\\n                    transferred := success\\n                }\\n                case 0x20 {\\n                    transferred := iszero(or(iszero(success), iszero(mload(0))))\\n                }\\n                default {\\n                    transferred := 0\\n                }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/interfaces/ISignatureValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\ncontract ISignatureValidatorConstants {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes,bytes)\\\")\\n    bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;\\n}\\n\\nabstract contract ISignatureValidator is ISignatureValidatorConstants {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param _data Arbitrary length data signed on the behalf of address(this)\\n     * @param _signature Signature byte array associated with _data\\n     *\\n     * MUST return the bytes4 magic value 0x20c13b0b when function passes.\\n     * MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5)\\n     * MUST allow external calls\\n     */\\n    function isValidSignature(bytes memory _data, bytes memory _signature) public view virtual returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/// @notice More details at https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/introspection/IERC165.sol\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/libs/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// a copy of import \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\", with tiny modification:\\n// ecrecover should not use the \\\"GAS\\\" opcode.\\n// (its a precompile, and uses fixed gas anyway)\\n// instead, ecrecover2 uses assembly.\\n// Had to change \\\"pure\\\" to \\\"view\\\", since the compiler can't tell this \\\"staticcall\\\" is pure\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return;\\n            // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal view returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal view returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal view returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        // address signer = ecrecover(hash,v,r,s);\\n        address signer = ecrecover2(hash, v, r, s);\\n\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    function ecrecover2(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal view returns (address signer) {\\n        uint status;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let pointer := mload(0x40)\\n\\n            mstore(pointer, hash)\\n            mstore(add(pointer, 0x20), v)\\n            mstore(add(pointer, 0x40), r)\\n            mstore(add(pointer, 0x60), s)\\n\\n\\n            status := staticcall(not(0), 0x01, pointer, 0x80, pointer, 0x20)\\n            signer := mload(pointer)\\n        // not required by this code, but other solidity code assumes unused data is zero...\\n            mstore(pointer, 0)\\n            mstore(add(pointer, 0x20), 0)\\n        }\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/libs/UserOperation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\n    struct UserOperation {\\n        address sender;\\n        uint256 nonce;\\n        bytes initCode;\\n        bytes callData;\\n        uint callGas;\\n        uint verificationGas;\\n        uint preVerificationGas;\\n        uint maxFeePerGas;\\n        uint maxPriorityFeePerGas;\\n        address paymaster;\\n        bytes paymasterData;\\n        bytes signature;\\n    }\\n\\nlibrary UserOperationLib {\\n\\n    function getSender(UserOperation calldata userOp) internal pure returns (address ret) {\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {ret := calldataload(userOp)}\\n    }\\n\\n    //relayer/miner might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(UserOperation calldata userOp) internal view returns (uint) {\\n    unchecked {\\n        uint maxFeePerGas = userOp.maxFeePerGas;\\n        uint maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        if (maxFeePerGas == maxPriorityFeePerGas) {\\n            //legacy mode (for networks that don't support basefee opcode)\\n            return min(tx.gasprice, maxFeePerGas);\\n        }\\n        return min(tx.gasprice, min(maxFeePerGas, maxPriorityFeePerGas + block.basefee));\\n    }\\n    }\\n\\n    function requiredGas(UserOperation calldata userOp) internal pure returns (uint) {\\n    unchecked {\\n        //when using a Paymaster, the verificationGas is used also to cover the postOp call.\\n        // our security model might call postOp eventually twice\\n        uint mul = userOp.paymaster != address(0) ? 1 : 3;\\n        return userOp.callGas + userOp.verificationGas * mul + userOp.preVerificationGas;\\n    }\\n    }\\n\\n    function requiredPreFund(UserOperation calldata userOp) internal view returns (uint prefund) {\\n    unchecked {\\n        return requiredGas(userOp) * gasPrice(userOp);\\n    }\\n    }\\n\\n    function hasPaymaster(UserOperation calldata userOp) internal pure returns (bool) {\\n        return userOp.paymaster != address(0);\\n    }\\n\\n    function pack(UserOperation calldata userOp) internal pure returns (bytes memory ret) {\\n        //lighter signature scheme. must match UserOp.ts#packUserOp\\n        bytes calldata sig = userOp.signature;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let ofs := userOp\\n            let len := sub(sub(sig.offset, ofs), 32)\\n            ret := mload(0x40)\\n            mstore(0x40, add(ret, add(len, 32)))\\n            mstore(ret, len)\\n            calldatacopy(add(ret, 32), ofs, len)\\n        }\\n        return ret;\\n    }\\n\\n    function hash(UserOperation calldata userOp) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint a, uint b) internal pure returns (uint) {\\n        return a < b ? a : b;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/common/Enum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/// @title Enum - Collection of enums\\ncontract Enum {\\n    enum Operation {Call, DelegateCall}\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/common/SelfAuthorized.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/// @title SelfAuthorized - authorizes current contract to perform actions\\ncontract SelfAuthorized {\\n    function requireSelfCall() private view {\\n        require(msg.sender == address(this), \\\"BSA031\\\");\\n    }\\n\\n    modifier authorized() {\\n        // This is a function call as it minimized the bytecode size\\n        requireSelfCall();\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/smart-contract-wallet/base/Executor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"../common/Enum.sol\\\";\\n\\n/// @title Executor - A contract that can execute transactions\\ncontract Executor {\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        Enum.Operation operation,\\n        uint256 txGas\\n    ) internal returns (bool success) {\\n        if (operation == Enum.Operation.DelegateCall) {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\\n            }\\n        } else {\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseImpl\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_implementation\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"WalletCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_entryPoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_handler\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"deployCounterFactualWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_entryPoint\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_handler\",\"type\":\"address\"}],\"name\":\"deployWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getAddressForCounterfactualWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWalletExist\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WalletFactory", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000056dce811a2b695171274855e7246039df298158", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}