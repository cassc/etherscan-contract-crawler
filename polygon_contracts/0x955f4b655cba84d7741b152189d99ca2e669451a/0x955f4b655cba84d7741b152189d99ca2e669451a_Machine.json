{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/sales/Machine/Machine.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"../../tokens/BALL/IBall.sol\\\";\\nimport \\\"../../tokens/BALL/IBallStruct.sol\\\";\\nimport \\\"../../tokens/TICKET/ITicket.sol\\\";\\n\\nimport \\\"../../state/Editions/IEditions.sol\\\";\\n\\nimport \\\"../../common/BallContractCallerOwnable/BallContractCallerOwnable.sol\\\";\\nimport \\\"../../common/TicketContractCallerOwnable/TicketContractCallerOwnable.sol\\\";\\nimport \\\"../../common/GoldContractCallerOwnable/GoldContractCallerOwnable.sol\\\";\\nimport \\\"../../common/EditionsContractCallerOwnable/EditionsContractCallerOwnable.sol\\\";\\nimport \\\"../../common/ChainlinkPriceFeedCallerOwnable/ChainlinkPriceFeedCallerOwnable.sol\\\";\\n\\nimport \\\"../../oracles/BallBuyOracle/BallBuyOracleCaller.sol\\\";\\n\\ncontract Machine is\\n    BallContractCallerOwnable,\\n    TicketContractCallerOwnable,\\n    GoldContractCallerOwnable,\\n    EditionsContractCallerOwnable,\\n    BallBuyOracleCaller,\\n    ChainlinkPriceFeedCallerOwnable\\n{\\n    bool public constant IS_MACHINE_CONTRACT = true;\\n\\n    uint16 public machineServerId;\\n\\n    bool public isOpen;\\n    bool public isTicketOpen;\\n\\n    /// @dev - 18 decimals USD amount\\n    uint256 private _singleItemPrice;\\n    uint256 private _packItemPrice;\\n\\n    /// @dev - 18 decimals GOLD amount\\n    uint256 public singleItemGoldPrice;\\n    uint256 public packItemGoldPrice;\\n\\n    event MachineServerIdUpdated(\\n        uint16 previousMachineServerId,\\n        uint16 machineServerId\\n    );\\n    event IsOpenUpdated(bool previousIsOpen, bool isOpen);\\n    event IsTicketOpenUpdated(bool previousIsTicketOpen, bool isTicketOpen);\\n    event SingleItemPriceUpdated(\\n        uint256 previousSingleItemPrice,\\n        uint256 singleItemPrice\\n    );\\n    event PackItemPriceUpdated(\\n        uint256 previousPackItemPrice,\\n        uint256 packItemPrice\\n    );\\n    event SingleItemGoldPriceUpdated(\\n        uint256 previousSingleItemGoldPrice,\\n        uint256 singleItemGoldPrice\\n    );\\n    event PackItemGoldPriceUpdated(\\n        uint256 previousPackItemGoldPrice,\\n        uint256 packItemGoldPrice\\n    );\\n    event SingleItemBought(address indexed buyer, uint256 price);\\n    event PackItemBought(address indexed buyer, uint256 price);\\n    event SingleItemGoldBought(address indexed buyer, uint256 price);\\n    event PackItemGoldBought(address indexed buyer, uint256 price);\\n    event TicketRedeemed(\\n        address indexed redeemer,\\n        uint256 indexed ticketTokenId\\n    );\\n\\n    struct InitialPrices {\\n        uint256 singleItemPrice;\\n        uint256 packItemPrice;\\n        uint256 singleItemGoldPrice;\\n        uint256 packItemGoldPrice;\\n    }\\n\\n    constructor(\\n        uint16 _machineServerId,\\n        bool _isOpen,\\n        bool _isTicketOpen,\\n        InitialPrices memory _initialPrices,\\n        address _ballContractAddress,\\n        address _ticketContractAddress,\\n        address _goldContractAddress,\\n        address _editionsContractAddress,\\n        address _ballBuyOracleContractAddress,\\n        address _chainlinkMaticUsdPriceFeedAddress\\n    )\\n        BallContractCallerOwnable(_ballContractAddress)\\n        TicketContractCallerOwnable(_ticketContractAddress)\\n        GoldContractCallerOwnable(_goldContractAddress)\\n        EditionsContractCallerOwnable(_editionsContractAddress)\\n        BallBuyOracleCaller(_ballBuyOracleContractAddress)\\n        ChainlinkPriceFeedCallerOwnable(_chainlinkMaticUsdPriceFeedAddress)\\n    {\\n        setMachineServerId(_machineServerId);\\n        setIsOpen(_isOpen);\\n        setIsTicketOpen(_isTicketOpen);\\n        setSingleItemPrice(_initialPrices.singleItemPrice);\\n        setPackItemPrice(_initialPrices.packItemPrice);\\n        setSingleItemGoldPrice(_initialPrices.singleItemGoldPrice);\\n        setPackItemGoldPrice(_initialPrices.packItemGoldPrice);\\n    }\\n\\n    /* Parameters management */\\n    function setMachineServerId(uint16 _newMachineServerId) public onlyOwner {\\n        emit MachineServerIdUpdated(machineServerId, _newMachineServerId);\\n        machineServerId = _newMachineServerId;\\n    }\\n\\n    function setIsOpen(bool _newIsOpen) public onlyOwner {\\n        emit IsOpenUpdated(isOpen, _newIsOpen);\\n        isOpen = _newIsOpen;\\n    }\\n\\n    function setIsTicketOpen(bool _newIsTicketOpen) public onlyOwner {\\n        emit IsTicketOpenUpdated(isTicketOpen, _newIsTicketOpen);\\n        isTicketOpen = _newIsTicketOpen;\\n    }\\n\\n    function setSingleItemPrice(uint256 _newSingleItemPrice) public onlyOwner {\\n        emit SingleItemPriceUpdated(_singleItemPrice, _newSingleItemPrice);\\n        _singleItemPrice = _newSingleItemPrice;\\n    }\\n\\n    function setPackItemPrice(uint256 _newPackItemPrice) public onlyOwner {\\n        emit PackItemPriceUpdated(_packItemPrice, _newPackItemPrice);\\n        _packItemPrice = _newPackItemPrice;\\n    }\\n\\n    function setSingleItemGoldPrice(uint256 _newSingleItemGoldPrice)\\n        public\\n        onlyOwner\\n    {\\n        emit SingleItemGoldPriceUpdated(\\n            singleItemGoldPrice,\\n            _newSingleItemGoldPrice\\n        );\\n        singleItemGoldPrice = _newSingleItemGoldPrice;\\n    }\\n\\n    function setPackItemGoldPrice(uint256 _newPackItemGoldPrice)\\n        public\\n        onlyOwner\\n    {\\n        emit PackItemGoldPriceUpdated(packItemGoldPrice, _newPackItemGoldPrice);\\n        packItemGoldPrice = _newPackItemGoldPrice;\\n    }\\n\\n    /* Getters */\\n    function singleItemPrice() public view returns (uint256) {\\n        return (_singleItemPrice * 10**18) / _getLatestPrice(18);\\n    }\\n\\n    function packItemPrice() public view returns (uint256) {\\n        return (_packItemPrice * 10**18) / _getLatestPrice(18);\\n    }\\n\\n    /* Helpers */\\n    function _mintBall(\\n        address _to,\\n        string memory _ballTokenURIPrefix,\\n        BallMintData memory _ballMintData\\n    ) private returns (uint256) {\\n        Ball memory ballData = Ball(\\n            _ballMintData.serverId,\\n            _ballMintData.setId,\\n            editionsContract.getCurrentSetIdEdition(_ballMintData.setId),\\n            _ballMintData.minRunes,\\n            _ballMintData.maxRunes,\\n            _ballMintData.isShiny,\\n            _ballMintData.name\\n        );\\n\\n        editionsContract.increaseCurrentSetIdEditionItemsCount(ballData.setId);\\n\\n        uint256 ballTokenId = ballContract.mint(\\n            _to,\\n            _ballTokenURIPrefix,\\n            ballData\\n        );\\n\\n        return ballTokenId;\\n    }\\n\\n    function _buySingle(address _to) private {\\n        require(isOpen, \\\"MACHINE_IS_NOT_OPEN\\\");\\n\\n        _callBallBuyOracle(_to, machineServerId, 1, 0, false);\\n    }\\n\\n    function _buyPack(address _to) private {\\n        require(isOpen, \\\"MACHINE_IS_NOT_OPEN\\\");\\n\\n        _callBallBuyOracle(_to, machineServerId, 5, 0, false);\\n    }\\n\\n    function _redeemTicket(address _to, uint256 _ticketTokenId) private {\\n        require(isTicketOpen, \\\"TICKET_MACHINE_IS_NOT_OPEN\\\");\\n\\n        _callBallBuyOracle(_to, machineServerId, 1, _ticketTokenId, false);\\n    }\\n\\n    function _buySingleGold(address _to) private {\\n        require(isOpen, \\\"MACHINE_IS_NOT_OPEN\\\");\\n\\n        _callBallBuyOracle(_to, machineServerId, 1, 0, true);\\n    }\\n\\n    function _buyPackGold(address _to) private {\\n        require(isOpen, \\\"MACHINE_IS_NOT_OPEN\\\");\\n\\n        _callBallBuyOracle(_to, machineServerId, 5, 0, true);\\n    }\\n\\n    /* Entry points */\\n    function buySingle() external payable {\\n        uint256 price = singleItemPrice();\\n\\n        require(msg.value >= price, \\\"VALUE_TOO_LOW\\\");\\n\\n        uint256 leftovers = msg.value - price;\\n\\n        if (leftovers > 0) {\\n            (bool success, ) = _msgSender().call{value: leftovers}(\\\"\\\");\\n            require(success, \\\"LEFTOVERS_REFUND_FAILED\\\");\\n        }\\n\\n        emit SingleItemBought(_msgSender(), price);\\n\\n        _buySingle(_msgSender());\\n    }\\n\\n    function buyPack() external payable {\\n        uint256 price = packItemPrice();\\n\\n        require(msg.value >= price, \\\"VALUE_TOO_LOW\\\");\\n\\n        uint256 leftovers = msg.value - price;\\n\\n        if (leftovers > 0) {\\n            (bool success, ) = _msgSender().call{value: leftovers}(\\\"\\\");\\n            require(success, \\\"LEFTOVERS_REFUND_FAILED\\\");\\n        }\\n\\n        emit PackItemBought(_msgSender(), price);\\n\\n        _buyPack(_msgSender());\\n    }\\n\\n    function buySingleGold() external {\\n        require(\\n            goldContract.balanceOf(_msgSender()) >= singleItemGoldPrice,\\n            \\\"NOT_ENOUGH_GOLD\\\"\\n        );\\n\\n        goldContract.burnFrom(_msgSender(), singleItemGoldPrice);\\n\\n        emit SingleItemGoldBought(_msgSender(), singleItemGoldPrice);\\n\\n        _buySingleGold(_msgSender());\\n    }\\n\\n    function buyPackGold() external {\\n        require(\\n            goldContract.balanceOf(_msgSender()) >= packItemGoldPrice,\\n            \\\"NOT_ENOUGH_GOLD\\\"\\n        );\\n\\n        goldContract.burnFrom(_msgSender(), packItemGoldPrice);\\n\\n        emit PackItemGoldBought(_msgSender(), packItemGoldPrice);\\n\\n        _buyPackGold(_msgSender());\\n    }\\n\\n    function redeemTicket(uint256 _ticketTokenId) external {\\n        Ticket memory ticket = ticketContract.getTicket(_ticketTokenId);\\n\\n        require(\\n            ticket.redeemContractAddress == address(this),\\n            \\\"TICKET_IS_NOT_FOR_THIS_CONTRACT\\\"\\n        );\\n\\n        require(\\n            ticket.expirationDate == 0 ||\\n                ticket.expirationDate >= block.timestamp,\\n            \\\"TICKET_IS_EXPIRED\\\"\\n        );\\n\\n        require(\\n            ticketContract.ownerOf(_ticketTokenId) == _msgSender(),\\n            \\\"ONLY_TICKET_OWNER_ALLOWED\\\"\\n        );\\n\\n        require(\\n            ticketContract.getApproved(_ticketTokenId) == address(this),\\n            \\\"TICKET_NOT_APPROVED\\\"\\n        );\\n\\n        emit TicketRedeemed(_msgSender(), _ticketTokenId);\\n\\n        _redeemTicket(_msgSender(), _ticketTokenId);\\n    }\\n\\n    // Oracle callback\\n    function callback(\\n        uint256 _requestId,\\n        address _to,\\n        string calldata _ballTokenURIPrefix,\\n        BallMintData[] calldata _ballsMintData,\\n        uint256 _ticketTokenId,\\n        bool _isGoldBuy\\n    ) external override nonReentrant {\\n        _isGoldBuy; // not used\\n\\n        // Only oracle should be able to call\\n        require(\\n            _msgSender() == address(ballBuyOracleContract),\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Ensure this is a legitimate callback request\\n        require(\\n            _pendingBallBuyRequests[_requestId],\\n            \\\"REQUEST_ID_IS_NOT_PENDING\\\"\\n        );\\n\\n        // Remove the request from pending requests\\n        delete _pendingBallBuyRequests[_requestId];\\n\\n        // Burn ticket if any\\n        if (_ticketTokenId > 0) {\\n            ticketContract.burn(_ticketTokenId);\\n        }\\n\\n        // Mint Balls\\n        for (uint256 i = 0; i < _ballsMintData.length; i++) {\\n            _mintBall(_to, _ballTokenURIPrefix, _ballsMintData[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/BALL/IBall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"./IBallStruct.sol\\\";\\n\\ninterface IBall is IERC721 {\\n    function IS_BALL_CONTRACT() external pure returns (bool);\\n\\n    function getBall(uint256 _tokenId) external view returns (Ball memory);\\n\\n    function mint(\\n        address _to,\\n        string calldata _tokenURIPrefix,\\n        Ball calldata _ballData\\n    ) external returns (uint256);\\n\\n    function burn(uint256 _tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/BALL/IBallStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nstruct Ball {\\n    uint16 serverId;\\n    uint16 setId;\\n    uint8 edition;\\n    uint16 minRunes;\\n    uint16 maxRunes;\\n    bool isShiny;\\n    string name;\\n}\\n\\nstruct BallMintData {\\n    uint16 serverId;\\n    uint16 setId;\\n    // no edition\\n    uint16 minRunes;\\n    uint16 maxRunes;\\n    bool isShiny;\\n    string name;\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/TICKET/ITicket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\n\\nimport \\\"./ITicketStruct.sol\\\";\\n\\ninterface ITicket is IERC721 {\\n    function IS_TICKET_CONTRACT() external pure returns (bool);\\n\\n    function getTicket(uint256 _tokenId) external view returns (Ticket memory);\\n\\n    function tokenURI(uint256 _tokenId) external view returns (string memory);\\n\\n    function mint(\\n        address _to,\\n        string calldata _tokenURIPrefix,\\n        Ticket calldata _ticketData\\n    ) external returns (uint256);\\n\\n    function burn(uint256 _tokenId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/state/Editions/IEditions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\ninterface IEditions {\\n    function IS_EDITIONS_CONTRACT() external pure returns (bool);\\n\\n    function getCurrentSetIdEdition(uint16 _setId)\\n        external\\n        view\\n        returns (uint8 _currentSetIdEdition);\\n\\n    function getCurrentSetIdEditionItemsCount(uint16 _setId)\\n        external\\n        view\\n        returns (uint256 _currentSetIdItemsCount);\\n\\n    function increaseCurrentSetIdEditionItemsCount(uint16 _setId)\\n        external\\n        returns (uint8 _currentSetIdEdition);\\n}\\n\"\r\n    },\r\n    \"contracts/common/BallContractCallerOwnable/BallContractCallerOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../tokens/BALL/IBall.sol\\\";\\n\\ncontract BallContractCallerOwnable is Ownable {\\n    IBall public ballContract;\\n\\n    constructor(address _ballContractAddress) {\\n        setBallContract(_ballContractAddress);\\n    }\\n\\n    function setBallContract(address _address) public onlyOwner {\\n        IBall candidateContract = IBall(_address);\\n\\n        // Verify the contract is the one we expect\\n        require(\\n            candidateContract.IS_BALL_CONTRACT(),\\n            \\\"CONTRACT_ADDRES_IS_NOT_A_BALL_CONTRACT_INSTANCE\\\"\\n        );\\n\\n        // Set the new contract address\\n        ballContract = candidateContract;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/TicketContractCallerOwnable/TicketContractCallerOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../tokens/TICKET/ITicket.sol\\\";\\n\\ncontract TicketContractCallerOwnable is Ownable {\\n    ITicket public ticketContract;\\n\\n    constructor(address _ticketContractAddress) {\\n        setTicketContract(_ticketContractAddress);\\n    }\\n\\n    function setTicketContract(address _address) public onlyOwner {\\n        ITicket candidateContract = ITicket(_address);\\n\\n        // Verify the contract is the one we expect\\n        require(\\n            candidateContract.IS_TICKET_CONTRACT(),\\n            \\\"CONTRACT_ADDRES_IS_NOT_A_TICKET_CONTRACT_INSTANCE\\\"\\n        );\\n\\n        // Set the new contract address\\n        ticketContract = candidateContract;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/GoldContractCallerOwnable/GoldContractCallerOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../tokens/GOLD/IGold.sol\\\";\\n\\ncontract GoldContractCallerOwnable is Ownable {\\n    IGold public goldContract;\\n\\n    constructor(address _goldContractAddress) {\\n        setGoldContract(_goldContractAddress);\\n    }\\n\\n    function setGoldContract(address _address) public onlyOwner {\\n        IGold candidateContract = IGold(_address);\\n\\n        // Verify the contract is the one we expect\\n        require(\\n            candidateContract.IS_GOLD_CONTRACT(),\\n            \\\"CONTRACT_ADDRES_IS_NOT_A_GOLD_CONTRACT_INSTANCE\\\"\\n        );\\n\\n        // Set the new contract address\\n        goldContract = candidateContract;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/EditionsContractCallerOwnable/EditionsContractCallerOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"../../state/Editions/IEditions.sol\\\";\\n\\ncontract EditionsContractCallerOwnable is Ownable {\\n    IEditions public editionsContract;\\n\\n    constructor(address _editionsContractAddress) {\\n        setEditionsContract(_editionsContractAddress);\\n    }\\n\\n    function setEditionsContract(address _address) public onlyOwner {\\n        IEditions candidateContract = IEditions(_address);\\n\\n        // Verify the contract is the one we expect\\n        require(\\n            candidateContract.IS_EDITIONS_CONTRACT(),\\n            \\\"CONTRACT_ADDRES_IS_NOT_AN_EDITIONS_CONTRACT_INSTANCE\\\"\\n        );\\n\\n        // Set the new contract address\\n        editionsContract = candidateContract;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/ChainlinkPriceFeedCallerOwnable/ChainlinkPriceFeedCallerOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract ChainlinkPriceFeedCallerOwnable is Ownable {\\n    AggregatorV3Interface internal _priceFeed;\\n\\n    constructor(address _priceFeedAddress) {\\n        setPriceFeed(_priceFeedAddress);\\n    }\\n\\n    function setPriceFeed(address _priceFeedAddress) public onlyOwner {\\n        _priceFeed = AggregatorV3Interface(_priceFeedAddress);\\n    }\\n\\n    function _getLatestPrice(uint8 _decimals) internal view returns (uint256) {\\n        (, int256 price, , , ) = _priceFeed.latestRoundData();\\n\\n        if (price <= 0) {\\n            return 0;\\n        }\\n\\n        return _scalePrice(uint256(price), _priceFeed.decimals(), _decimals);\\n    }\\n\\n    function _scalePrice(\\n        uint256 _price,\\n        uint8 _priceDecimals,\\n        uint8 _decimals\\n    ) private pure returns (uint256) {\\n        if (_priceDecimals < _decimals) {\\n            return _price * (10**(_decimals - _priceDecimals));\\n        } else if (_priceDecimals > _decimals) {\\n            return _price / (10**(_priceDecimals - _decimals));\\n        }\\n        return _price;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/BallBuyOracle/BallBuyOracleCaller.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\n\\nimport \\\"../../common/FundsManagementOwnable/FundsManagementOwnable.sol\\\";\\n\\nimport \\\"../../tokens/BALL/IBallStruct.sol\\\";\\n\\nimport \\\"./IBallBuyOracle.sol\\\";\\n\\nabstract contract BallBuyOracleCaller is\\n    Ownable,\\n    ReentrancyGuard,\\n    FundsManagementOwnable\\n{\\n    bool public constant IS_BALL_BUY_ORACLE_CALLER = true;\\n\\n    IBallBuyOracle public ballBuyOracleContract;\\n\\n    mapping(uint256 => bool) internal _pendingBallBuyRequests;\\n\\n    constructor(address _initialBallBuyOracleContractAddress) {\\n        setBallBuyOracleContractAddress(_initialBallBuyOracleContractAddress);\\n    }\\n\\n    /* External contracts management */\\n    function setBallBuyOracleContractAddress(address _address)\\n        public\\n        onlyOwner\\n    {\\n        IBallBuyOracle candidateContract = IBallBuyOracle(_address);\\n\\n        // Verify the contract is the one we expect\\n        require(candidateContract.IS_BALL_BUY_ORACLE());\\n\\n        // Set the new contract address\\n        ballBuyOracleContract = candidateContract;\\n    }\\n\\n    // Entry point\\n    function _callBallBuyOracle(\\n        address _to,\\n        uint16 _machineServerId,\\n        uint16 _amount,\\n        uint256 _ticketTokenId,\\n        bool _isGoldBuy\\n    ) internal nonReentrant returns (uint256) {\\n        uint256 requestId = ballBuyOracleContract.requestBallBuy(\\n            _to,\\n            _machineServerId,\\n            _amount,\\n            _ticketTokenId,\\n            _isGoldBuy\\n        );\\n        _pendingBallBuyRequests[requestId] = true;\\n        return requestId;\\n    }\\n\\n    // Exit point, to be implemented by the use case contract\\n    function callback(\\n        uint256 _requestId,\\n        address _to,\\n        string calldata _ballTokenURIPrefix,\\n        BallMintData[] calldata _ballsMintData,\\n        uint256 _ticketTokenId,\\n        bool _isGoldBuy\\n    ) external virtual;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/TICKET/ITicketStruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nstruct Ticket {\\n    uint16 serverId;\\n    address redeemContractAddress;\\n    uint256 expirationDate; // 0 = never expires\\n    string name;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tokens/GOLD/IGold.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nimport \\\"../BALL/IBallStruct.sol\\\";\\n\\ninterface IGold is IERC20 {\\n    function IS_GOLD_CONTRACT() external pure returns (bool);\\n\\n    function mint(address _to, uint256 _amount) external;\\n\\n    function burnFrom(address _account, uint256 _amount) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/common/FundsManagementOwnable/FundsManagementOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nabstract contract FundsManagementOwnable is Ownable {\\n    event Received(address sender, uint256 amount);\\n\\n    receive() external payable {\\n        emit Received(_msgSender(), msg.value);\\n    }\\n\\n    function withdraw(address _to) external onlyOwner {\\n        (bool success, ) = _to.call{value: address(this).balance}(\\\"\\\");\\n        require(success, \\\"WITHDRAW_FAILED\\\");\\n    }\\n\\n    function recoverERC20(\\n        address _tokenAddress,\\n        address _to,\\n        uint256 _tokenAmount\\n    ) external onlyOwner {\\n        require(\\n            IERC20(_tokenAddress).transfer(_to, _tokenAmount),\\n            \\\"RECOVERY_FAILED\\\"\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/oracles/BallBuyOracle/IBallBuyOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity 0.8.7;\\n\\nimport \\\"../../tokens/BALL/IBallStruct.sol\\\";\\n\\ninterface IBallBuyOracle {\\n    function IS_BALL_BUY_ORACLE() external returns (bool);\\n\\n    function requestBallBuy(\\n        address _to,\\n        uint16 _machineServerId,\\n        uint16 _amount,\\n        uint256 _ticketTokenId,\\n        bool _isGoldBuy\\n    ) external returns (uint256);\\n\\n    function reportBallBuy(\\n        uint256 _requestId,\\n        address _callerAddress,\\n        address _to,\\n        string calldata _ballTokenURIPrefix,\\n        BallMintData[] calldata _ballsMintData,\\n        uint256 _ticketTokenId,\\n        bool _isGoldBuy\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_machineServerId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"_isOpen\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_isTicketOpen\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"singleItemPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packItemPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"singleItemGoldPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"packItemGoldPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct Machine.InitialPrices\",\"name\":\"_initialPrices\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"_ballContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ticketContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_goldContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_editionsContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ballBuyOracleContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_chainlinkMaticUsdPriceFeedAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"previousIsOpen\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isOpen\",\"type\":\"bool\"}],\"name\":\"IsOpenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"previousIsTicketOpen\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isTicketOpen\",\"type\":\"bool\"}],\"name\":\"IsTicketOpenUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"previousMachineServerId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"machineServerId\",\"type\":\"uint16\"}],\"name\":\"MachineServerIdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PackItemBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"PackItemGoldBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPackItemGoldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packItemGoldPrice\",\"type\":\"uint256\"}],\"name\":\"PackItemGoldPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousPackItemPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"packItemPrice\",\"type\":\"uint256\"}],\"name\":\"PackItemPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"SingleItemBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"SingleItemGoldBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousSingleItemGoldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"singleItemGoldPrice\",\"type\":\"uint256\"}],\"name\":\"SingleItemGoldPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousSingleItemPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"singleItemPrice\",\"type\":\"uint256\"}],\"name\":\"SingleItemPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ticketTokenId\",\"type\":\"uint256\"}],\"name\":\"TicketRedeemed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"IS_BALL_BUY_ORACLE_CALLER\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"IS_MACHINE_CONTRACT\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ballBuyOracleContract\",\"outputs\":[{\"internalType\":\"contract IBallBuyOracle\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ballContract\",\"outputs\":[{\"internalType\":\"contract IBall\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPack\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyPackGold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySingle\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buySingleGold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_ballTokenURIPrefix\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"uint16\",\"name\":\"serverId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"setId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"minRunes\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"maxRunes\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isShiny\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"internalType\":\"struct BallMintData[]\",\"name\":\"_ballsMintData\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_ticketTokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isGoldBuy\",\"type\":\"bool\"}],\"name\":\"callback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editionsContract\",\"outputs\":[{\"internalType\":\"contract IEditions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goldContract\",\"outputs\":[{\"internalType\":\"contract IGold\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isTicketOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"machineServerId\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"packItemGoldPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"packItemPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"recoverERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ticketTokenId\",\"type\":\"uint256\"}],\"name\":\"redeemTicket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setBallBuyOracleContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setBallContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setEditionsContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setGoldContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_newIsOpen\",\"type\":\"bool\"}],\"name\":\"setIsOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_newIsTicketOpen\",\"type\":\"bool\"}],\"name\":\"setIsTicketOpen\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_newMachineServerId\",\"type\":\"uint16\"}],\"name\":\"setMachineServerId\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPackItemGoldPrice\",\"type\":\"uint256\"}],\"name\":\"setPackItemGoldPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newPackItemPrice\",\"type\":\"uint256\"}],\"name\":\"setPackItemPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_priceFeedAddress\",\"type\":\"address\"}],\"name\":\"setPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSingleItemGoldPrice\",\"type\":\"uint256\"}],\"name\":\"setSingleItemGoldPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSingleItemPrice\",\"type\":\"uint256\"}],\"name\":\"setSingleItemPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setTicketContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"singleItemGoldPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"singleItemPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ticketContract\",\"outputs\":[{\"internalType\":\"contract ITicket\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Machine", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000001a055690d9db800000000000000000000000000000000000000000000000000055de6a779bbac000000000000000000000000000000000000000000000000001043561a882930000000000000000000000000000000000000000000000000003627e8f712373c0000000000000000000000000000e46c8a73d705180ffaf24b8cf497e022c1f3ba980000000000000000000000004ea78778e27f1a96f3c7142825cd7b87fc538ad900000000000000000000000052fdce87128f4be4ed27ecd2453a819fdb087ed5000000000000000000000000acfa1702a9297e92207e7e5ce44a7bcc0bc32c68000000000000000000000000c4f5cf95a3e7e80af628fca01a801d22c78ee0f3000000000000000000000000ab594600376ec9fd91f8e885dadf0ce036862de0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}