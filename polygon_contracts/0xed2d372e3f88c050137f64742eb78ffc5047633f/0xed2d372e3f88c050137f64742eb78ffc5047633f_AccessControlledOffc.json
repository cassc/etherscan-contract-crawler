{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.7.0;\r\n\r\n/**\r\n * @title The Owned contract\r\n * @notice A contract with helpers for basic contract ownership.\r\n */\r\ncontract Owned {\r\n\r\n  address payable public owner;\r\n  address private pendingOwner;\r\n\r\n  event OwnershipTransferRequested(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n  event OwnershipTransferred(\r\n    address indexed from,\r\n    address indexed to\r\n  );\r\n\r\n  constructor() {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an owner to begin transferring ownership to a new address,\r\n   * pending.\r\n   */\r\n  function transferOwnership(address _to)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    pendingOwner = _to;\r\n\r\n    emit OwnershipTransferRequested(owner, _to);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows an ownership transfer to be completed by the recipient.\r\n   */\r\n  function acceptOwnership()\r\n    external\r\n  {\r\n    require(msg.sender == pendingOwner, \"Must be proposed owner\");\r\n\r\n    address oldOwner = owner;\r\n    owner = msg.sender;\r\n    pendingOwner = address(0);\r\n\r\n    emit OwnershipTransferred(oldOwner, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if called by anyone other than the contract owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Only callable by owner\");\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ninterface LinkTokenInterface {\r\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n  function approve(address spender, uint256 value) external returns (bool success);\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n  function decimals() external view returns (uint8 decimalPlaces);\r\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\r\n  function increaseApproval(address spender, uint256 subtractedValue) external;\r\n  function name() external view returns (string memory tokenName);\r\n  function symbol() external view returns (string memory tokenSymbol);\r\n  function totalSupply() external view returns (uint256 totalTokensIssued);\r\n  function transfer(address to, uint256 value) external returns (bool success);\r\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\r\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\r\n}\r\n\r\n\r\n\r\ninterface AccessControllerInterface {\r\n  function hasAccess(address user, bytes calldata data) external view returns (bool);\r\n}\r\n\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals() external view returns (uint8);\r\n  function description() external view returns (string memory);\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n\r\n\r\ninterface AggregatorInterface {\r\n  function latestAnswer() external view returns (int256);\r\n  function latestTimestamp() external view returns (uint256);\r\n  function latestRound() external view returns (uint256);\r\n  function getAnswer(uint256 roundId) external view returns (int256);\r\n  function getTimestamp(uint256 roundId) external view returns (uint256);\r\n\r\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\r\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\r\n}\r\n\r\n\r\n\r\nabstract contract TypeAndVersionInterface{\r\n  function typeAndVersion()\r\n    external\r\n    pure\r\n    virtual\r\n    returns (string memory);\r\n}\r\n\r\n\r\ninterface AggregatorValidatorInterface {\r\n  function validate(\r\n    uint256 previousRoundId,\r\n    int256 previousAnswer,\r\n    uint256 currentRoundId,\r\n    int256 currentAnswer\r\n  ) external returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface\r\n{\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @notice tracks administration of oracle-reward and gas-reimbursement parameters.\r\n\r\n * @dev\r\n * If you read or change this, be sure to read or adjust the comments. They\r\n * track the units of the values under consideration, and are crucial to\r\n * the readability of the operations it specifies.\r\n\r\n * @notice\r\n * Trust Model:\r\n\r\n * Nothing in this contract prevents a billing admin from setting insane\r\n * values for the billing parameters in setBilling. Oracles\r\n * participating in this contract should regularly check that the\r\n * parameters make sense. Similarly, the outstanding obligations of this\r\n * contract to the oracles can exceed the funds held by the contract.\r\n * Oracles participating in this contract should regularly check that it\r\n * holds sufficient funds and stop interacting with it if funding runs\r\n * out.\r\n\r\n * This still leaves oracles with some risk due to TOCTOU issues.\r\n * However, since the sums involved are pretty small (Ethereum\r\n * transactions aren't that expensive in the end) and an oracle would\r\n * likely stop participating in a contract it repeatedly lost money on,\r\n * this risk is deemed acceptable. Oracles should also regularly\r\n * withdraw any funds in the contract to prevent issues where the\r\n * contract becomes underfunded at a later time, and different oracles\r\n * are competing for the left-over funds.\r\n\r\n * Finally, note that any change to the set of oracles or to the billing\r\n * parameters will trigger payout of all oracles first (using the old\r\n * parameters), a billing admin cannot take away funds that are already\r\n * marked for payment.\r\n*/\r\ncontract OffchainAggregatorBilling is Owned {\r\n\r\n  // Maximum number of oracles the offchain reporting protocol is designed for\r\n  uint256 constant internal maxNumOracles = 31;\r\n\r\n  // Parameters for oracle payments\r\n  struct Billing {\r\n\r\n    // Highest compensated gas price, in ETH-gwei uints\r\n    uint32 maximumGasPrice;\r\n\r\n    // If gas price is less (in ETH-gwei units), transmitter gets half the savings\r\n    uint32 reasonableGasPrice;\r\n\r\n    // Pay transmitter back this much LINK per unit eth spent on gas\r\n    // (1e-6LINK/ETH units)\r\n    uint32 microLinkPerEth;\r\n\r\n    // Fixed LINK reward for each observer, in LINK-gwei units\r\n    uint32 linkGweiPerObservation;\r\n\r\n    // Fixed reward for transmitter, in linkGweiPerObservation units\r\n    uint32 linkGweiPerTransmission;\r\n  }\r\n  Billing internal s_billing;\r\n\r\n  // We assume that the token contract is correct. This contract is not written\r\n  // to handle misbehaving ERC20 tokens!\r\n  LinkTokenInterface internal s_linkToken;\r\n\r\n  AccessControllerInterface internal s_billingAccessController;\r\n\r\n  // ith element is number of observation rewards due to ith process, plus one.\r\n  // This is expected to saturate after an oracle has submitted 65,535\r\n  // observations, or about 65535/(3*24*20) = 45 days, given a transmission\r\n  // every 3 minutes.\r\n  //\r\n  // This is always one greater than the actual value, so that when the value is\r\n  // reset to zero, we don't end up with a zero value in storage (which would\r\n  // result in a higher gas cost, the next time the value is incremented.)\r\n  // Calculations using this variable need to take that offset into account.\r\n  uint16[maxNumOracles] internal s_oracleObservationsCounts;\r\n\r\n  // Addresses at which oracles want to receive payments, by transmitter address\r\n  mapping (address /* transmitter */ => address /* payment address */)\r\n    internal\r\n    s_payees;\r\n\r\n  // Payee addresses which must be approved by the owner\r\n  mapping (address /* transmitter */ => address /* payment address */)\r\n    internal\r\n    s_proposedPayees;\r\n\r\n  // LINK-wei-denominated reimbursements for gas used by transmitters.\r\n  //\r\n  // This is always one greater than the actual value, so that when the value is\r\n  // reset to zero, we don't end up with a zero value in storage (which would\r\n  // result in a higher gas cost, the next time the value is incremented.)\r\n  // Calculations using this variable need to take that offset into account.\r\n  //\r\n  // Argument for overflow safety:\r\n  // We have the following maximum intermediate values:\r\n  // - 2**40 additions to this variable (epochAndRound is a uint40)\r\n  // - 2**32 gas price in ethgwei/gas\r\n  // - 1e9 ethwei/ethgwei\r\n  // - 2**32 gas since the block gas limit is at ~20 million\r\n  // - 2**32 (microlink/eth)\r\n  // And we have 2**40 * 2**32 * 1e9 * 2**32 * 2**32 < 2**166\r\n  // (we also divide in some places, but that only makes the value smaller)\r\n  // We can thus safely use uint256 intermediate values for the computation\r\n  // updating this variable.\r\n  uint256[maxNumOracles] internal s_gasReimbursementsLinkWei;\r\n\r\n  // Used for s_oracles[a].role, where a is an address, to track the purpose\r\n  // of the address, or to indicate that the address is unset.\r\n  enum Role {\r\n    // No oracle role has been set for address a\r\n    Unset,\r\n    // Signing address for the s_oracles[a].index'th oracle. I.e., report\r\n    // signatures from this oracle should ecrecover back to address a.\r\n    Signer,\r\n    // Transmission address for the s_oracles[a].index'th oracle. I.e., if a\r\n    // report is received by OffchainAggregator.transmit in which msg.sender is\r\n    // a, it is attributed to the s_oracles[a].index'th oracle.\r\n    Transmitter\r\n  }\r\n\r\n  struct Oracle {\r\n    uint8 index; // Index of oracle in s_signers/s_transmitters\r\n    Role role;   // Role of the address which mapped to this struct\r\n  }\r\n\r\n  mapping (address /* signer OR transmitter address */ => Oracle)\r\n    internal s_oracles;\r\n\r\n  // s_signers contains the signing address of each oracle\r\n  address[] internal s_signers;\r\n\r\n  // s_transmitters contains the transmission address of each oracle,\r\n  // i.e. the address the oracle actually sends transactions to the contract from\r\n  address[] internal s_transmitters;\r\n\r\n  uint256 constant private  maxUint16 = (1 << 16) - 1;\r\n  uint256 constant internal maxUint128 = (1 << 128) - 1;\r\n\r\n  constructor(\r\n    uint32 _maximumGasPrice,\r\n    uint32 _reasonableGasPrice,\r\n    uint32 _microLinkPerEth,\r\n    uint32 _linkGweiPerObservation,\r\n    uint32 _linkGweiPerTransmission,\r\n    LinkTokenInterface _link,\r\n    AccessControllerInterface _billingAccessController\r\n  )\r\n  {\r\n    setBillingInternal(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\r\n      _linkGweiPerObservation, _linkGweiPerTransmission);\r\n    s_linkToken = _link;\r\n    emit LinkTokenSet(LinkTokenInterface(address(0)), _link);\r\n    setBillingAccessControllerInternal(_billingAccessController);\r\n    uint16[maxNumOracles] memory counts; // See s_oracleObservationsCounts docstring\r\n    uint256[maxNumOracles] memory gas; // see s_gasReimbursementsLinkWei docstring\r\n    for (uint8 i = 0; i < maxNumOracles; i++) {\r\n      counts[i] = 1;\r\n      gas[i] = 1;\r\n    }\r\n    s_oracleObservationsCounts = counts;\r\n    s_gasReimbursementsLinkWei = gas;\r\n  }\r\n\r\n  /*\r\n   * @notice emitted when the LINK token contract is set\r\n   * @param _oldLinkToken the address of the old LINK token contract\r\n   * @param _newLinkToken the address of the new LINK token contract\r\n   */\r\n  event LinkTokenSet(\r\n    LinkTokenInterface indexed _oldLinkToken,\r\n    LinkTokenInterface indexed _newLinkToken\r\n  );\r\n\r\n  /*\r\n   * @notice sets the LINK token contract used for paying oracles\r\n   * @param _linkToken the address of the LINK token contract\r\n   * @param _recipient remaining funds from the previous token contract are transfered\r\n   * here\r\n   * @dev this function will return early (without an error) without changing any state\r\n   * if _linkToken equals getLinkToken().\r\n   * @dev this will trigger a payout so that a malicious owner cannot take from oracles\r\n   * what is already owed to them.\r\n   * @dev we assume that the token contract is correct. This contract is not written\r\n   * to handle misbehaving ERC20 tokens!\r\n   */\r\n  function setLinkToken(\r\n    LinkTokenInterface _linkToken,\r\n    address _recipient\r\n  ) external\r\n    onlyOwner()\r\n  {\r\n    LinkTokenInterface oldLinkToken = s_linkToken;\r\n    if (_linkToken == oldLinkToken) {\r\n      // No change, nothing to be done\r\n      return;\r\n    }\r\n    // call balanceOf as a sanity check on whether we're talking to a token\r\n    // contract\r\n    _linkToken.balanceOf(address(this));\r\n    // we break CEI here, but that's okay because we're dealing with a correct\r\n    // token contract (by assumption).\r\n    payOracles();\r\n    uint256 remainingBalance = oldLinkToken.balanceOf(address(this));\r\n    require(oldLinkToken.transfer(_recipient, remainingBalance), \"transfer remaining funds failed\");\r\n    s_linkToken = _linkToken;\r\n    emit LinkTokenSet(oldLinkToken, _linkToken);\r\n  }\r\n\r\n  /*\r\n   * @notice gets the LINK token contract used for paying oracles\r\n   * @return linkToken the address of the LINK token contract\r\n   */\r\n  function getLinkToken()\r\n    external\r\n    view\r\n    returns(LinkTokenInterface linkToken)\r\n  {\r\n    return s_linkToken;\r\n  }\r\n\r\n  /**\r\n   * @notice emitted when billing parameters are set\r\n   * @param maximumGasPrice highest gas price for which transmitter will be compensated\r\n   * @param reasonableGasPrice transmitter will receive reward for gas prices under this value\r\n   * @param microLinkPerEth reimbursement per ETH of gas cost, in 1e-6LINK units\r\n   * @param linkGweiPerObservation reward to oracle for contributing an observation to a successfully transmitted report, in 1e-9LINK units\r\n   * @param linkGweiPerTransmission reward to transmitter of a successful report, in 1e-9LINK units\r\n   */\r\n  event BillingSet(\r\n    uint32 maximumGasPrice,\r\n    uint32 reasonableGasPrice,\r\n    uint32 microLinkPerEth,\r\n    uint32 linkGweiPerObservation,\r\n    uint32 linkGweiPerTransmission\r\n  );\r\n\r\n  function setBillingInternal(\r\n    uint32 _maximumGasPrice,\r\n    uint32 _reasonableGasPrice,\r\n    uint32 _microLinkPerEth,\r\n    uint32 _linkGweiPerObservation,\r\n    uint32 _linkGweiPerTransmission\r\n  )\r\n    internal\r\n  {\r\n    s_billing = Billing(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\r\n      _linkGweiPerObservation, _linkGweiPerTransmission);\r\n    emit BillingSet(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\r\n      _linkGweiPerObservation, _linkGweiPerTransmission);\r\n  }\r\n\r\n  /**\r\n   * @notice sets billing parameters\r\n   * @param _maximumGasPrice highest gas price for which transmitter will be compensated\r\n   * @param _reasonableGasPrice transmitter will receive reward for gas prices under this value\r\n   * @param _microLinkPerEth reimbursement per ETH of gas cost, in 1e-6LINK units\r\n   * @param _linkGweiPerObservation reward to oracle for contributing an observation to a successfully transmitted report, in 1e-9LINK units\r\n   * @param _linkGweiPerTransmission reward to transmitter of a successful report, in 1e-9LINK units\r\n   * @dev access control provided by billingAccessController\r\n   */\r\n  function setBilling(\r\n    uint32 _maximumGasPrice,\r\n    uint32 _reasonableGasPrice,\r\n    uint32 _microLinkPerEth,\r\n    uint32 _linkGweiPerObservation,\r\n    uint32 _linkGweiPerTransmission\r\n  )\r\n    external\r\n  {\r\n    AccessControllerInterface access = s_billingAccessController;\r\n    require(msg.sender == owner || access.hasAccess(msg.sender, msg.data),\r\n      \"Only owner&billingAdmin can call\");\r\n    payOracles();\r\n    setBillingInternal(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\r\n      _linkGweiPerObservation, _linkGweiPerTransmission);\r\n  }\r\n\r\n  /**\r\n   * @notice gets billing parameters\r\n   * @param maximumGasPrice highest gas price for which transmitter will be compensated\r\n   * @param reasonableGasPrice transmitter will receive reward for gas prices under this value\r\n   * @param microLinkPerEth reimbursement per ETH of gas cost, in 1e-6LINK units\r\n   * @param linkGweiPerObservation reward to oracle for contributing an observation to a successfully transmitted report, in 1e-9LINK units\r\n   * @param linkGweiPerTransmission reward to transmitter of a successful report, in 1e-9LINK units\r\n   */\r\n  function getBilling()\r\n    external\r\n    view\r\n    returns (\r\n      uint32 maximumGasPrice,\r\n      uint32 reasonableGasPrice,\r\n      uint32 microLinkPerEth,\r\n      uint32 linkGweiPerObservation,\r\n      uint32 linkGweiPerTransmission\r\n    )\r\n  {\r\n    Billing memory billing = s_billing;\r\n    return (\r\n      billing.maximumGasPrice,\r\n      billing.reasonableGasPrice,\r\n      billing.microLinkPerEth,\r\n      billing.linkGweiPerObservation,\r\n      billing.linkGweiPerTransmission\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice emitted when a new access-control contract is set\r\n   * @param old the address prior to the current setting\r\n   * @param current the address of the new access-control contract\r\n   */\r\n  event BillingAccessControllerSet(AccessControllerInterface old, AccessControllerInterface current);\r\n\r\n  function setBillingAccessControllerInternal(AccessControllerInterface _billingAccessController)\r\n    internal\r\n  {\r\n    AccessControllerInterface oldController = s_billingAccessController;\r\n    if (_billingAccessController != oldController) {\r\n      s_billingAccessController = _billingAccessController;\r\n      emit BillingAccessControllerSet(\r\n        oldController,\r\n        _billingAccessController\r\n      );\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice sets billingAccessController\r\n   * @param _billingAccessController new billingAccessController contract address\r\n   * @dev only owner can call this\r\n   */\r\n  function setBillingAccessController(AccessControllerInterface _billingAccessController)\r\n    external\r\n    onlyOwner\r\n  {\r\n    setBillingAccessControllerInternal(_billingAccessController);\r\n  }\r\n\r\n  /**\r\n   * @notice gets billingAccessController\r\n   * @return address of billingAccessController contract\r\n   */\r\n  function billingAccessController()\r\n    external\r\n    view\r\n    returns (AccessControllerInterface)\r\n  {\r\n    return s_billingAccessController;\r\n  }\r\n\r\n  /**\r\n   * @notice withdraws an oracle's payment from the contract\r\n   * @param _transmitter the transmitter address of the oracle\r\n   * @dev must be called by oracle's payee address\r\n   */\r\n  function withdrawPayment(address _transmitter)\r\n    external\r\n  {\r\n    require(msg.sender == s_payees[_transmitter], \"Only payee can withdraw\");\r\n    payOracle(_transmitter);\r\n  }\r\n\r\n  /**\r\n   * @notice query an oracle's payment amount\r\n   * @param _transmitter the transmitter address of the oracle\r\n   */\r\n  function owedPayment(address _transmitter)\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    Oracle memory oracle = s_oracles[_transmitter];\r\n    if (oracle.role == Role.Unset) { return 0; }\r\n    Billing memory billing = s_billing;\r\n    uint256 linkWeiAmount =\r\n      uint256(s_oracleObservationsCounts[oracle.index] - 1) *\r\n      uint256(billing.linkGweiPerObservation) *\r\n      (1 gwei);\r\n    linkWeiAmount += s_gasReimbursementsLinkWei[oracle.index] - 1;\r\n    return linkWeiAmount;\r\n  }\r\n\r\n  /**\r\n   * @notice emitted when an oracle has been paid LINK\r\n   * @param transmitter address from which the oracle sends reports to the transmit method\r\n   * @param payee address to which the payment is sent\r\n   * @param amount amount of LINK sent\r\n   * @param linkToken address of the LINK token contract\r\n   */\r\n  event OraclePaid(\r\n    address indexed transmitter,\r\n    address indexed payee,\r\n    uint256 amount,\r\n    LinkTokenInterface indexed linkToken\r\n  );\r\n\r\n  // payOracle pays out _transmitter's balance to the corresponding payee, and zeros it out\r\n  function payOracle(address _transmitter)\r\n    internal\r\n  {\r\n    Oracle memory oracle = s_oracles[_transmitter];\r\n    uint256 linkWeiAmount = owedPayment(_transmitter);\r\n    if (linkWeiAmount > 0) {\r\n      address payee = s_payees[_transmitter];\r\n      // Poses no re-entrancy issues, because LINK.transfer does not yield\r\n      // control flow.\r\n      require(s_linkToken.transfer(payee, linkWeiAmount), \"insufficient funds\");\r\n      s_oracleObservationsCounts[oracle.index] = 1; // \"zero\" the counts. see var's docstring\r\n      s_gasReimbursementsLinkWei[oracle.index] = 1; // \"zero\" the counts. see var's docstring\r\n      emit OraclePaid(_transmitter, payee, linkWeiAmount, s_linkToken);\r\n    }\r\n  }\r\n\r\n  // payOracles pays out all transmitters, and zeros out their balances.\r\n  //\r\n  // It's much more gas-efficient to do this as a single operation, to avoid\r\n  // hitting storage too much.\r\n  function payOracles()\r\n    internal\r\n  {\r\n    Billing memory billing = s_billing;\r\n    LinkTokenInterface linkToken = s_linkToken;\r\n    uint16[maxNumOracles] memory observationsCounts = s_oracleObservationsCounts;\r\n    uint256[maxNumOracles] memory gasReimbursementsLinkWei =\r\n      s_gasReimbursementsLinkWei;\r\n    address[] memory transmitters = s_transmitters;\r\n    for (uint transmitteridx = 0; transmitteridx < transmitters.length; transmitteridx++) {\r\n      uint256 reimbursementAmountLinkWei = gasReimbursementsLinkWei[transmitteridx] - 1;\r\n      uint256 obsCount = observationsCounts[transmitteridx] - 1;\r\n      uint256 linkWeiAmount =\r\n        obsCount * uint256(billing.linkGweiPerObservation) * (1 gwei) + reimbursementAmountLinkWei;\r\n      if (linkWeiAmount > 0) {\r\n          address payee = s_payees[transmitters[transmitteridx]];\r\n          // Poses no re-entrancy issues, because LINK.transfer does not yield\r\n          // control flow.\r\n          require(linkToken.transfer(payee, linkWeiAmount), \"insufficient funds\");\r\n          observationsCounts[transmitteridx] = 1;       // \"zero\" the counts.\r\n          gasReimbursementsLinkWei[transmitteridx] = 1; // \"zero\" the counts.\r\n          emit OraclePaid(transmitters[transmitteridx], payee, linkWeiAmount, linkToken);\r\n        }\r\n    }\r\n    // \"Zero\" the accounting storage variables\r\n    s_oracleObservationsCounts = observationsCounts;\r\n    s_gasReimbursementsLinkWei = gasReimbursementsLinkWei;\r\n  }\r\n\r\n  function oracleRewards(\r\n    bytes memory observers,\r\n    uint16[maxNumOracles] memory observations\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint16[maxNumOracles] memory)\r\n  {\r\n    // reward each observer-participant with the observer reward\r\n    for (uint obsIdx = 0; obsIdx < observers.length; obsIdx++) {\r\n      uint8 observer = uint8(observers[obsIdx]);\r\n      observations[observer] = saturatingAddUint16(observations[observer], 1);\r\n    }\r\n    return observations;\r\n  }\r\n\r\n  // This value needs to change if maxNumOracles is increased, or the accounting\r\n  // calculations at the bottom of reimburseAndRewardOracles change.\r\n  //\r\n  // To recalculate it, run the profiler as described in\r\n  // ../../profile/README.md, and add up the gas-usage values reported for the\r\n  // lines in reimburseAndRewardOracles following the \"gasLeft = gasleft()\"\r\n  // line. E.g., you will see output like this:\r\n  //\r\n  //      7        uint256 gasLeft = gasleft();\r\n  //     29        uint256 gasCostEthWei = transmitterGasCostEthWei(\r\n  //      9          uint256(initialGas),\r\n  //      3          gasPrice,\r\n  //      3          callDataGasCost,\r\n  //      3          gasLeft\r\n  //      .\r\n  //      .\r\n  //      .\r\n  //     59        uint256 gasCostLinkWei = (gasCostEthWei * billing.microLinkPerEth)/ 1e6;\r\n  //      .\r\n  //      .\r\n  //      .\r\n  //   5047        s_gasReimbursementsLinkWei[txOracle.index] =\r\n  //    856          s_gasReimbursementsLinkWei[txOracle.index] + gasCostLinkWei +\r\n  //     26          uint256(billing.linkGweiPerTransmission) * (1 gwei);\r\n  //\r\n  // If those were the only lines to be accounted for, you would add up\r\n  // 29+9+3+3+3+59+5047+856+26=6035.\r\n  uint256 internal constant accountingGasCost = 6035;\r\n\r\n  // Uncomment the following declaration to compute the remaining gas cost after\r\n  // above gasleft(). (This must exist in a base class to OffchainAggregator, so\r\n  // it can't go in TestOffchainAggregator.)\r\n  //\r\n  // uint256 public gasUsedInAccounting;\r\n\r\n  // Gas price at which the transmitter should be reimbursed, in ETH-gwei/gas\r\n  function impliedGasPrice(\r\n    uint256 txGasPrice,         // ETH-gwei/gas units\r\n    uint256 reasonableGasPrice, // ETH-gwei/gas units\r\n    uint256 maximumGasPrice     // ETH-gwei/gas units\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    // Reward the transmitter for choosing an efficient gas price: if they manage\r\n    // to come in lower than considered reasonable, give them half the savings.\r\n    //\r\n    // The following calculations are all in units of gwei/gas, i.e. 1e-9ETH/gas\r\n    uint256 gasPrice = txGasPrice;\r\n    if (txGasPrice < reasonableGasPrice) {\r\n      // Give transmitter half the savings for coming in under the reasonable gas price\r\n      gasPrice += (reasonableGasPrice - txGasPrice) / 2;\r\n    }\r\n    // Don't reimburse a gas price higher than maximumGasPrice\r\n    return min(gasPrice, maximumGasPrice);\r\n  }\r\n\r\n  // gas reimbursement due the transmitter, in ETH-wei\r\n  //\r\n  // If this function is changed, accountingGasCost needs to change, too. See\r\n  // its docstring\r\n  function transmitterGasCostEthWei(\r\n    uint256 initialGas,\r\n    uint256 gasPrice, // ETH-gwei/gas units\r\n    uint256 callDataCost, // gas units\r\n    uint256 gasLeft\r\n  )\r\n    internal\r\n    pure\r\n    returns (uint128 gasCostEthWei)\r\n  {\r\n    require(initialGas >= gasLeft, \"gasLeft cannot exceed initialGas\");\r\n    uint256 gasUsed = // gas units\r\n      initialGas - gasLeft + // observed gas usage\r\n      callDataCost + accountingGasCost; // estimated gas usage\r\n    // gasUsed is in gas units, gasPrice is in ETH-gwei/gas units; convert to ETH-wei\r\n    uint256 fullGasCostEthWei = gasUsed * gasPrice * (1 gwei);\r\n    assert(fullGasCostEthWei < maxUint128); // the entire ETH supply fits in a uint128...\r\n    return uint128(fullGasCostEthWei);\r\n  }\r\n\r\n  /**\r\n   * @notice withdraw any available funds left in the contract, up to _amount, after accounting for the funds due to participants in past reports\r\n   * @param _recipient address to send funds to\r\n   * @param _amount maximum amount to withdraw, denominated in LINK-wei.\r\n   * @dev access control provided by billingAccessController\r\n   */\r\n  function withdrawFunds(address _recipient, uint256 _amount)\r\n    external\r\n  {\r\n    require(msg.sender == owner || s_billingAccessController.hasAccess(msg.sender, msg.data),\r\n      \"Only owner&billingAdmin can call\");\r\n    uint256 linkDue = totalLINKDue();\r\n    uint256 linkBalance = s_linkToken.balanceOf(address(this));\r\n    require(linkBalance >= linkDue, \"insufficient balance\");\r\n    require(s_linkToken.transfer(_recipient, min(linkBalance - linkDue, _amount)), \"insufficient funds\");\r\n  }\r\n\r\n  // Total LINK due to participants in past reports.\r\n  function totalLINKDue()\r\n    internal\r\n    view\r\n    returns (uint256 linkDue)\r\n  {\r\n    // Argument for overflow safety: We do all computations in\r\n    // uint256s. The inputs to linkDue are:\r\n    // - the <= 31 observation rewards each of which has less than\r\n    //   64 bits (32 bits for billing.linkGweiPerObservation, 32 bits\r\n    //   for wei/gwei conversion). Hence 69 bits are sufficient for this part.\r\n    // - the <= 31 gas reimbursements, each of which consists of at most 166\r\n    //   bits (see s_gasReimbursementsLinkWei docstring). Hence 171 bits are\r\n    //   sufficient for this part\r\n    // In total, 172 bits are enough.\r\n    uint16[maxNumOracles] memory observationCounts = s_oracleObservationsCounts;\r\n    for (uint i = 0; i < maxNumOracles; i++) {\r\n      linkDue += observationCounts[i] - 1; // Stored value is one greater than actual value\r\n    }\r\n    Billing memory billing = s_billing;\r\n    // Convert linkGweiPerObservation to uint256, or this overflows!\r\n    linkDue *= uint256(billing.linkGweiPerObservation) * (1 gwei);\r\n    address[] memory transmitters = s_transmitters;\r\n    uint256[maxNumOracles] memory gasReimbursementsLinkWei =\r\n      s_gasReimbursementsLinkWei;\r\n    for (uint i = 0; i < transmitters.length; i++) {\r\n      linkDue += uint256(gasReimbursementsLinkWei[i]-1); // Stored value is one greater than actual value\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice allows oracles to check that sufficient LINK balance is available\r\n   * @return availableBalance LINK available on this contract, after accounting for outstanding obligations. can become negative\r\n   */\r\n  function linkAvailableForPayment()\r\n    external\r\n    view\r\n    returns (int256 availableBalance)\r\n  {\r\n    // there are at most one billion LINK, so this cast is safe\r\n    int256 balance = int256(s_linkToken.balanceOf(address(this)));\r\n    // according to the argument in the definition of totalLINKDue,\r\n    // totalLINKDue is never greater than 2**172, so this cast is safe\r\n    int256 due = int256(totalLINKDue());\r\n    // safe from overflow according to above sizes\r\n    return int256(balance) - int256(due);\r\n  }\r\n\r\n  /**\r\n   * @notice number of observations oracle is due to be reimbursed for\r\n   * @param _signerOrTransmitter address used by oracle for signing or transmitting reports\r\n   */\r\n  function oracleObservationCount(address _signerOrTransmitter)\r\n    external\r\n    view\r\n    returns (uint16)\r\n  {\r\n    Oracle memory oracle = s_oracles[_signerOrTransmitter];\r\n    if (oracle.role == Role.Unset) { return 0; }\r\n    return s_oracleObservationsCounts[oracle.index] - 1;\r\n  }\r\n\r\n\r\n  function reimburseAndRewardOracles(\r\n    uint32 initialGas,\r\n    bytes memory observers\r\n  )\r\n    internal\r\n  {\r\n    Oracle memory txOracle = s_oracles[msg.sender];\r\n    Billing memory billing = s_billing;\r\n    // Reward oracles for providing observations. Oracles are not rewarded\r\n    // for providing signatures, because signing is essentially free.\r\n    s_oracleObservationsCounts =\r\n      oracleRewards(observers, s_oracleObservationsCounts);\r\n    // Reimburse transmitter of the report for gas usage\r\n    require(txOracle.role == Role.Transmitter,\r\n      \"sent by undesignated transmitter\"\r\n    );\r\n    uint256 gasPrice = impliedGasPrice(\r\n      tx.gasprice / (1 gwei), // convert to ETH-gwei units\r\n      billing.reasonableGasPrice,\r\n      billing.maximumGasPrice\r\n    );\r\n    // The following is only an upper bound, as it ignores the cheaper cost for\r\n    // 0 bytes. Safe from overflow, because calldata just isn't that long.\r\n    uint256 callDataGasCost = 16 * msg.data.length;\r\n    // If any changes are made to subsequent calculations, accountingGasCost\r\n    // needs to change, too.\r\n    uint256 gasLeft = gasleft();\r\n    uint256 gasCostEthWei = transmitterGasCostEthWei(\r\n      uint256(initialGas),\r\n      gasPrice,\r\n      callDataGasCost,\r\n      gasLeft\r\n    );\r\n\r\n    // microLinkPerEth is 1e-6LINK/ETH units, gasCostEthWei is 1e-18ETH units\r\n    // (ETH-wei), product is 1e-24LINK-wei units, dividing by 1e6 gives\r\n    // 1e-18LINK units, i.e. LINK-wei units\r\n    // Safe from over/underflow, since all components are non-negative,\r\n    // gasCostEthWei will always fit into uint128 and microLinkPerEth is a\r\n    // uint32 (128+32 < 256!).\r\n    uint256 gasCostLinkWei = (gasCostEthWei * billing.microLinkPerEth)/ 1e6;\r\n\r\n    // Safe from overflow, because gasCostLinkWei < 2**160 and\r\n    // billing.linkGweiPerTransmission * (1 gwei) < 2**64 and we increment\r\n    // s_gasReimbursementsLinkWei[txOracle.index] at most 2**40 times.\r\n    s_gasReimbursementsLinkWei[txOracle.index] =\r\n      s_gasReimbursementsLinkWei[txOracle.index] + gasCostLinkWei +\r\n      uint256(billing.linkGweiPerTransmission) * (1 gwei); // convert from linkGwei to linkWei\r\n\r\n    // Uncomment next line to compute the remaining gas cost after above gasleft().\r\n    // See OffchainAggregatorBilling.accountingGasCost docstring for more information.\r\n    //\r\n    // gasUsedInAccounting = gasLeft - gasleft();\r\n  }\r\n\r\n  /*\r\n   * Payee management\r\n   */\r\n\r\n  /**\r\n   * @notice emitted when a transfer of an oracle's payee address has been initiated\r\n   * @param transmitter address from which the oracle sends reports to the transmit method\r\n   * @param current the payeee address for the oracle, prior to this setting\r\n   * @param proposed the proposed new payee address for the oracle\r\n   */\r\n  event PayeeshipTransferRequested(\r\n    address indexed transmitter,\r\n    address indexed current,\r\n    address indexed proposed\r\n  );\r\n\r\n  /**\r\n   * @notice emitted when a transfer of an oracle's payee address has been completed\r\n   * @param transmitter address from which the oracle sends reports to the transmit method\r\n   * @param current the payeee address for the oracle, prior to this setting\r\n   */\r\n  event PayeeshipTransferred(\r\n    address indexed transmitter,\r\n    address indexed previous,\r\n    address indexed current\r\n  );\r\n\r\n  /**\r\n   * @notice sets the payees for transmitting addresses\r\n   * @param _transmitters addresses oracles use to transmit the reports\r\n   * @param _payees addresses of payees corresponding to list of transmitters\r\n   * @dev must be called by owner\r\n   * @dev cannot be used to change payee addresses, only to initially populate them\r\n   */\r\n  function setPayees(\r\n    address[] calldata _transmitters,\r\n    address[] calldata _payees\r\n  )\r\n    external\r\n    onlyOwner()\r\n  {\r\n    require(_transmitters.length == _payees.length, \"transmitters.size != payees.size\");\r\n\r\n    for (uint i = 0; i < _transmitters.length; i++) {\r\n      address transmitter = _transmitters[i];\r\n      address payee = _payees[i];\r\n      address currentPayee = s_payees[transmitter];\r\n      bool zeroedOut = currentPayee == address(0);\r\n      require(zeroedOut || currentPayee == payee, \"payee already set\");\r\n      s_payees[transmitter] = payee;\r\n\r\n      if (currentPayee != payee) {\r\n        emit PayeeshipTransferred(transmitter, currentPayee, payee);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice first step of payeeship transfer (safe transfer pattern)\r\n   * @param _transmitter transmitter address of oracle whose payee is changing\r\n   * @param _proposed new payee address\r\n   * @dev can only be called by payee address\r\n   */\r\n  function transferPayeeship(\r\n    address _transmitter,\r\n    address _proposed\r\n  )\r\n    external\r\n  {\r\n      require(msg.sender == s_payees[_transmitter], \"only current payee can update\");\r\n      require(msg.sender != _proposed, \"cannot transfer to self\");\r\n\r\n      address previousProposed = s_proposedPayees[_transmitter];\r\n      s_proposedPayees[_transmitter] = _proposed;\r\n\r\n      if (previousProposed != _proposed) {\r\n        emit PayeeshipTransferRequested(_transmitter, msg.sender, _proposed);\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @notice second step of payeeship transfer (safe transfer pattern)\r\n   * @param _transmitter transmitter address of oracle whose payee is changing\r\n   * @dev can only be called by proposed new payee address\r\n   */\r\n  function acceptPayeeship(\r\n    address _transmitter\r\n  )\r\n    external\r\n  {\r\n    require(msg.sender == s_proposedPayees[_transmitter], \"only proposed payees can accept\");\r\n\r\n    address currentPayee = s_payees[_transmitter];\r\n    s_payees[_transmitter] = msg.sender;\r\n    s_proposedPayees[_transmitter] = address(0);\r\n\r\n    emit PayeeshipTransferred(_transmitter, currentPayee, msg.sender);\r\n  }\r\n\r\n  /*\r\n   * Helper functions\r\n   */\r\n\r\n  function saturatingAddUint16(uint16 _x, uint16 _y)\r\n    internal\r\n    pure\r\n    returns (uint16)\r\n  {\r\n    return uint16(min(uint256(_x)+uint256(_y), maxUint16));\r\n  }\r\n\r\n  function min(uint256 a, uint256 b)\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n  {\r\n    if (a < b) { return a; }\r\n    return b;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n  * @notice Onchain verification of reports from the offchain reporting protocol\r\n\r\n  * @dev For details on its operation, see the offchain reporting protocol design\r\n  * @dev doc, which refers to this contract as simply the \"contract\".\r\n*/\r\ncontract OffchainAggregator is Owned, OffchainAggregatorBilling, AggregatorV2V3Interface, TypeAndVersionInterface {\r\n\r\n  uint256 constant private maxUint32 = (1 << 32) - 1;\r\n\r\n  // Storing these fields used on the hot path in a HotVars variable reduces the\r\n  // retrieval of all of them to a single SLOAD. If any further fields are\r\n  // added, make sure that storage of the struct still takes at most 32 bytes.\r\n  struct HotVars {\r\n    // Provides 128 bits of security against 2nd pre-image attacks, but only\r\n    // 64 bits against collisions. This is acceptable, since a malicious owner has\r\n    // easier way of messing up the protocol than to find hash collisions.\r\n    bytes16 latestConfigDigest;\r\n    uint40 latestEpochAndRound; // 32 most sig bits for epoch, 8 least sig bits for round\r\n    // Current bound assumed on number of faulty/dishonest oracles participating\r\n    // in the protocol, this value is referred to as f in the design\r\n    uint8 threshold;\r\n    // Chainlink Aggregators expose a roundId to consumers. The offchain reporting\r\n    // protocol does not use this id anywhere. We increment it whenever a new\r\n    // transmission is made to provide callers with contiguous ids for successive\r\n    // reports.\r\n    uint32 latestAggregatorRoundId;\r\n  }\r\n  HotVars internal s_hotVars;\r\n\r\n  // Transmission records the median answer from the transmit transaction at\r\n  // time timestamp\r\n  struct Transmission {\r\n    int192 answer; // 192 bits ought to be enough for anyone\r\n    uint64 timestamp;\r\n  }\r\n  mapping(uint32 /* aggregator round ID */ => Transmission) internal s_transmissions;\r\n\r\n  // incremented each time a new config is posted. This count is incorporated\r\n  // into the config digest, to prevent replay attacks.\r\n  uint32 internal s_configCount;\r\n  uint32 internal s_latestConfigBlockNumber; // makes it easier for offchain systems\r\n                                             // to extract config from logs.\r\n\r\n  // Lowest answer the system is allowed to report in response to transmissions\r\n  int192 immutable public minAnswer;\r\n  // Highest answer the system is allowed to report in response to transmissions\r\n  int192 immutable public maxAnswer;\r\n\r\n  /*\r\n   * @param _maximumGasPrice highest gas price for which transmitter will be compensated\r\n   * @param _reasonableGasPrice transmitter will receive reward for gas prices under this value\r\n   * @param _microLinkPerEth reimbursement per ETH of gas cost, in 1e-6LINK units\r\n   * @param _linkGweiPerObservation reward to oracle for contributing an observation to a successfully transmitted report, in 1e-9LINK units\r\n   * @param _linkGweiPerTransmission reward to transmitter of a successful report, in 1e-9LINK units\r\n   * @param _link address of the LINK contract\r\n   * @param _minAnswer lowest answer the median of a report is allowed to be\r\n   * @param _maxAnswer highest answer the median of a report is allowed to be\r\n   * @param _billingAccessController access controller for billing admin functions\r\n   * @param _requesterAccessController access controller for requesting new rounds\r\n   * @param _decimals answers are stored in fixed-point format, with this many digits of precision\r\n   * @param _description short human-readable description of observable this contract's answers pertain to\r\n   */\r\n  constructor(\r\n    uint32 _maximumGasPrice,\r\n    uint32 _reasonableGasPrice,\r\n    uint32 _microLinkPerEth,\r\n    uint32 _linkGweiPerObservation,\r\n    uint32 _linkGweiPerTransmission,\r\n    LinkTokenInterface _link,\r\n    int192 _minAnswer,\r\n    int192 _maxAnswer,\r\n    AccessControllerInterface _billingAccessController,\r\n    AccessControllerInterface _requesterAccessController,\r\n    uint8 _decimals,\r\n    string memory _description\r\n  )\r\n    OffchainAggregatorBilling(_maximumGasPrice, _reasonableGasPrice, _microLinkPerEth,\r\n      _linkGweiPerObservation, _linkGweiPerTransmission, _link,\r\n      _billingAccessController\r\n    )\r\n  {\r\n    decimals = _decimals;\r\n    s_description = _description;\r\n    setRequesterAccessController(_requesterAccessController);\r\n    setValidatorConfig(AggregatorValidatorInterface(0x0), 0);\r\n    minAnswer = _minAnswer;\r\n    maxAnswer = _maxAnswer;\r\n  }\r\n\r\n  /*\r\n   * Versioning\r\n   */\r\n  function typeAndVersion()\r\n    external\r\n    override\r\n    pure\r\n    virtual\r\n    returns (string memory)\r\n  {\r\n    return \"OffchainAggregator 3.0.0\";\r\n  }\r\n\r\n  /*\r\n   * Config logic\r\n   */\r\n\r\n  /**\r\n   * @notice triggers a new run of the offchain reporting protocol\r\n   * @param previousConfigBlockNumber block in which the previous config was set, to simplify historic analysis\r\n   * @param configCount ordinal number of this config setting among all config settings over the life of this contract\r\n   * @param signers ith element is address ith oracle uses to sign a report\r\n   * @param transmitters ith element is address ith oracle uses to transmit a report via the transmit method\r\n   * @param threshold maximum number of faulty/dishonest oracles the protocol can tolerate while still working correctly\r\n   * @param encodedConfigVersion version of the serialization format used for \"encoded\" parameter\r\n   * @param encoded serialized data used by oracles to configure their offchain operation\r\n   */\r\n  event ConfigSet(\r\n    uint32 previousConfigBlockNumber,\r\n    uint64 configCount,\r\n    address[] signers,\r\n    address[] transmitters,\r\n    uint8 threshold,\r\n    uint64 encodedConfigVersion,\r\n    bytes encoded\r\n  );\r\n\r\n  // Reverts transaction if config args are invalid\r\n  modifier checkConfigValid (\r\n    uint256 _numSigners, uint256 _numTransmitters, uint256 _threshold\r\n  ) {\r\n    require(_numSigners <= maxNumOracles, \"too many signers\");\r\n    require(_threshold > 0, \"threshold must be positive\");\r\n    require(\r\n      _numSigners == _numTransmitters,\r\n      \"oracle addresses out of registration\"\r\n    );\r\n    require(_numSigners > 3*_threshold, \"faulty-oracle threshold too high\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice sets offchain reporting protocol configuration incl. participating oracles\r\n   * @param _signers addresses with which oracles sign the reports\r\n   * @param _transmitters addresses oracles use to transmit the reports\r\n   * @param _threshold number of faulty oracles the system can tolerate\r\n   * @param _encodedConfigVersion version number for offchainEncoding schema\r\n   * @param _encoded encoded off-chain oracle configuration\r\n   */\r\n  function setConfig(\r\n    address[] calldata _signers,\r\n    address[] calldata _transmitters,\r\n    uint8 _threshold,\r\n    uint64 _encodedConfigVersion,\r\n    bytes calldata _encoded\r\n  )\r\n    external\r\n    checkConfigValid(_signers.length, _transmitters.length, _threshold)\r\n    onlyOwner()\r\n  {\r\n    while (s_signers.length != 0) { // remove any old signer/transmitter addresses\r\n      uint lastIdx = s_signers.length - 1;\r\n      address signer = s_signers[lastIdx];\r\n      address transmitter = s_transmitters[lastIdx];\r\n      payOracle(transmitter);\r\n      delete s_oracles[signer];\r\n      delete s_oracles[transmitter];\r\n      s_signers.pop();\r\n      s_transmitters.pop();\r\n    }\r\n\r\n    for (uint i = 0; i < _signers.length; i++) { // add new signer/transmitter addresses\r\n      require(\r\n        s_oracles[_signers[i]].role == Role.Unset,\r\n        \"repeated signer address\"\r\n      );\r\n      s_oracles[_signers[i]] = Oracle(uint8(i), Role.Signer);\r\n      require(s_payees[_transmitters[i]] != address(0), \"payee must be set\");\r\n      require(\r\n        s_oracles[_transmitters[i]].role == Role.Unset,\r\n        \"repeated transmitter address\"\r\n      );\r\n      s_oracles[_transmitters[i]] = Oracle(uint8(i), Role.Transmitter);\r\n      s_signers.push(_signers[i]);\r\n      s_transmitters.push(_transmitters[i]);\r\n    }\r\n    s_hotVars.threshold = _threshold;\r\n    uint32 previousConfigBlockNumber = s_latestConfigBlockNumber;\r\n    s_latestConfigBlockNumber = uint32(block.number);\r\n    s_configCount += 1;\r\n    uint64 configCount = s_configCount;\r\n    {\r\n      s_hotVars.latestConfigDigest = configDigestFromConfigData(\r\n        address(this),\r\n        configCount,\r\n        _signers,\r\n        _transmitters,\r\n        _threshold,\r\n        _encodedConfigVersion,\r\n        _encoded\r\n      );\r\n      s_hotVars.latestEpochAndRound = 0;\r\n    }\r\n    emit ConfigSet(\r\n      previousConfigBlockNumber,\r\n      configCount,\r\n      _signers,\r\n      _transmitters,\r\n      _threshold,\r\n      _encodedConfigVersion,\r\n      _encoded\r\n    );\r\n  }\r\n\r\n  function configDigestFromConfigData(\r\n    address _contractAddress,\r\n    uint64 _configCount,\r\n    address[] calldata _signers,\r\n    address[] calldata _transmitters,\r\n    uint8 _threshold,\r\n    uint64 _encodedConfigVersion,\r\n    bytes calldata _encodedConfig\r\n  ) internal pure returns (bytes16) {\r\n    return bytes16(keccak256(abi.encode(_contractAddress, _configCount,\r\n      _signers, _transmitters, _threshold, _encodedConfigVersion, _encodedConfig\r\n    )));\r\n  }\r\n\r\n  /**\r\n   * @notice information about current offchain reporting protocol configuration\r\n\r\n   * @return configCount ordinal number of current config, out of all configs applied to this contract so far\r\n   * @return blockNumber block at which this config was set\r\n   * @return configDigest domain-separation tag for current config (see configDigestFromConfigData)\r\n   */\r\n  function latestConfigDetails()\r\n    external\r\n    view\r\n    returns (\r\n      uint32 configCount,\r\n      uint32 blockNumber,\r\n      bytes16 configDigest\r\n    )\r\n  {\r\n    return (s_configCount, s_latestConfigBlockNumber, s_hotVars.latestConfigDigest);\r\n  }\r\n\r\n  /**\r\n   * @return list of addresses permitted to transmit reports to this contract\r\n\r\n   * @dev The list will match the order used to specify the transmitter during setConfig\r\n   */\r\n  function transmitters()\r\n    external\r\n    view\r\n    returns(address[] memory)\r\n  {\r\n      return s_transmitters;\r\n  }\r\n\r\n  /*\r\n   * On-chain validation logc\r\n   */\r\n\r\n  // Configuration for validator\r\n  struct ValidatorConfig {\r\n    AggregatorValidatorInterface validator;\r\n    uint32 gasLimit;\r\n  }\r\n  ValidatorConfig private s_validatorConfig;\r\n\r\n  /**\r\n   * @notice indicates that the validator configuration has been set\r\n   * @param previousValidator previous validator contract\r\n   * @param previousGasLimit previous gas limit for validate calls\r\n   * @param currentValidator current validator contract\r\n   * @param currentGasLimit current gas limit for validate calls\r\n   */\r\n  event ValidatorConfigSet(\r\n    AggregatorValidatorInterface indexed previousValidator,\r\n    uint32 previousGasLimit,\r\n    AggregatorValidatorInterface indexed currentValidator,\r\n    uint32 currentGasLimit\r\n  );\r\n\r\n  /**\r\n   * @notice validator configuration\r\n   * @return validator validator contract\r\n   * @return gasLimit gas limit for validate calls\r\n   */\r\n  function validatorConfig()\r\n    external\r\n    view\r\n    returns (AggregatorValidatorInterface validator, uint32 gasLimit)\r\n  {\r\n    ValidatorConfig memory vc = s_validatorConfig;\r\n    return (vc.validator, vc.gasLimit);\r\n  }\r\n\r\n  /**\r\n   * @notice sets validator configuration\r\n   * @dev set _newValidator to 0x0 to disable validate calls\r\n   * @param _newValidator address of the new validator contract\r\n   * @param _newGasLimit new gas limit for validate calls\r\n   */\r\n  function setValidatorConfig(AggregatorValidatorInterface _newValidator, uint32 _newGasLimit)\r\n    public\r\n    onlyOwner()\r\n  {\r\n    ValidatorConfig memory previous = s_validatorConfig;\r\n\r\n    if (previous.validator != _newValidator || previous.gasLimit != _newGasLimit) {\r\n      s_validatorConfig = ValidatorConfig({\r\n        validator: _newValidator,\r\n        gasLimit: _newGasLimit\r\n      });\r\n\r\n      emit ValidatorConfigSet(previous.validator, previous.gasLimit, _newValidator, _newGasLimit);\r\n    }\r\n  }\r\n\r\n  function validateAnswer(\r\n    uint32 _aggregatorRoundId,\r\n    int256 _answer\r\n  )\r\n    private\r\n  {\r\n    ValidatorConfig memory vc = s_validatorConfig;\r\n\r\n    if (address(vc.validator) == address(0)) {\r\n      return;\r\n    }\r\n\r\n    uint32 prevAggregatorRoundId = _aggregatorRoundId - 1;\r\n    int256 prevAggregatorRoundAnswer = s_transmissions[prevAggregatorRoundId].answer;\r\n    // We do not want the validator to ever prevent reporting, so we limit its\r\n    // gas usage and catch any errors that may arise.\r\n    try vc.validator.validate{gas: vc.gasLimit}(\r\n      prevAggregatorRoundId,\r\n      prevAggregatorRoundAnswer,\r\n      _aggregatorRoundId,\r\n      _answer\r\n    ) {} catch {}\r\n  }\r\n\r\n  /*\r\n   * requestNewRound logic\r\n   */\r\n\r\n  AccessControllerInterface internal s_requesterAccessController;\r\n\r\n  /**\r\n   * @notice emitted when a new requester access controller contract is set\r\n   * @param old the address prior to the current setting\r\n   * @param current the address of the new access controller contract\r\n   */\r\n  event RequesterAccessControllerSet(AccessControllerInterface old, AccessControllerInterface current);\r\n\r\n  /**\r\n   * @notice emitted to immediately request a new round\r\n   * @param requester the address of the requester\r\n   * @param configDigest the latest transmission's configDigest\r\n   * @param epoch the latest transmission's epoch\r\n   * @param round the latest transmission's round\r\n   */\r\n  event RoundRequested(address indexed requester, bytes16 configDigest, uint32 epoch, uint8 round);\r\n\r\n  /**\r\n   * @notice address of the requester access controller contract\r\n   * @return requester access controller address\r\n   */\r\n  function requesterAccessController()\r\n    external\r\n    view\r\n    returns (AccessControllerInterface)\r\n  {\r\n    return s_requesterAccessController;\r\n  }\r\n\r\n  /**\r\n   * @notice sets the requester access controller\r\n   * @param _requesterAccessController designates the address of the new requester access controller\r\n   */\r\n  function setRequesterAccessController(AccessControllerInterface _requesterAccessController)\r\n    public\r\n    onlyOwner()\r\n  {\r\n    AccessControllerInterface oldController = s_requesterAccessController;\r\n    if (_requesterAccessController != oldController) {\r\n      s_requesterAccessController = AccessControllerInterface(_requesterAccessController);\r\n      emit RequesterAccessControllerSet(oldController, _requesterAccessController);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice immediately requests a new round\r\n   * @return the aggregatorRoundId of the next round. Note: The report for this round may have been\r\n   * transmitted (but not yet mined) *before* requestNewRound() was even called. There is *no*\r\n   * guarantee of causality between the request and the report at aggregatorRoundId.\r\n   */\r\n  function requestNewRound() external returns (uint80) {\r\n    require(msg.sender == owner || s_requesterAccessController.hasAccess(msg.sender, msg.data),\r\n      \"Only owner&requester can call\");\r\n\r\n    HotVars memory hotVars = s_hotVars;\r\n\r\n    emit RoundRequested(\r\n      msg.sender,\r\n      hotVars.latestConfigDigest,\r\n      uint32(s_hotVars.latestEpochAndRound >> 8),\r\n      uint8(s_hotVars.latestEpochAndRound)\r\n    );\r\n    return hotVars.latestAggregatorRoundId + 1;\r\n  }\r\n\r\n  /*\r\n   * Transmission logic\r\n   */\r\n\r\n  /**\r\n   * @notice indicates that a new report was transmitted\r\n   * @param aggregatorRoundId the round to which this report was assigned\r\n   * @param answer median of the observations attached this report\r\n   * @param transmitter address from which the report was transmitted\r\n   * @param observations observations transmitted with this report\r\n   * @param rawReportContext signature-replay-prevention domain-separation tag\r\n   */\r\n  event NewTransmission(\r\n    uint32 indexed aggregatorRoundId,\r\n    int192 answer,\r\n    address transmitter,\r\n    int192[] observations,\r\n    bytes observers,\r\n    bytes32 rawReportContext\r\n  );\r\n\r\n  // decodeReport is used to check that the solidity and go code are using the\r\n  // same format. See TestOffchainAggregator.testDecodeReport and TestReportParsing\r\n  function decodeReport(bytes memory _report)\r\n    internal\r\n    pure\r\n    returns (\r\n      bytes32 rawReportContext,\r\n      bytes32 rawObservers,\r\n      int192[] memory observations\r\n    )\r\n  {\r\n    (rawReportContext, rawObservers, observations) = abi.decode(_report,\r\n      (bytes32, bytes32, int192[]));\r\n  }\r\n\r\n  // Used to relieve stack pressure in transmit\r\n  struct ReportData {\r\n    HotVars hotVars; // Only read from storage once\r\n    bytes observers; // ith element is the index of the ith observer\r\n    int192[] observations; // ith element is the ith observation\r\n    bytes vs; // jth element is the v component of the jth signature\r\n    bytes32 rawReportContext;\r\n  }\r\n\r\n  /*\r\n   * @notice details about the most recent report\r\n\r\n   * @return configDigest domain separation tag for the latest report\r\n   * @return epoch epoch in which the latest report was generated\r\n   * @return round OCR round in which the latest report was generated\r\n   * @return latestAnswer median value from latest report\r\n   * @return latestTimestamp when the latest report was transmitted\r\n   */\r\n  function latestTransmissionDetails()\r\n    external\r\n    view\r\n    returns (\r\n      bytes16 configDigest,\r\n      uint32 epoch,\r\n      uint8 round,\r\n      int192 latestAnswer,\r\n      uint64 latestTimestamp\r\n    )\r\n  {\r\n    require(msg.sender == tx.origin, \"Only callable by EOA\");\r\n    return (\r\n      s_hotVars.latestConfigDigest,\r\n      uint32(s_hotVars.latestEpochAndRound >> 8),\r\n      uint8(s_hotVars.latestEpochAndRound),\r\n      s_transmissions[s_hotVars.latestAggregatorRoundId].answer,\r\n      s_transmissions[s_hotVars.latestAggregatorRoundId].timestamp\r\n    );\r\n  }\r\n\r\n  // The constant-length components of the msg.data sent to transmit.\r\n  // See the \"If we wanted to call sam\" example on for example reasoning\r\n  // https://solidity.readthedocs.io/en/v0.7.2/abi-spec.html\r\n  uint16 private constant TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT =\r\n    4 + // function selector\r\n    32 + // word containing start location of abiencoded _report value\r\n    32 + // word containing location start of abiencoded  _rs value\r\n    32 + // word containing start location of abiencoded _ss value\r\n    32 + // _rawVs value\r\n    32 + // word containing length of _report\r\n    32 + // word containing length _rs\r\n    32 + // word containing length of _ss\r\n    0; // placeholder\r\n\r\n  function expectedMsgDataLength(\r\n    bytes calldata _report, bytes32[] calldata _rs, bytes32[] calldata _ss\r\n  ) private pure returns (uint256 length)\r\n  {\r\n    // calldata will never be big enough to make this overflow\r\n    return uint256(TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT) +\r\n      _report.length + // one byte pure entry in _report\r\n      _rs.length * 32 + // 32 bytes per entry in _rs\r\n      _ss.length * 32 + // 32 bytes per entry in _ss\r\n      0; // placeholder\r\n  }\r\n\r\n  /**\r\n   * @notice transmit is called to post a new report to the contract\r\n   * @param _report serialized report, which the signatures are signing. See parsing code below for format. The ith element of the observers component must be the index in s_signers of the address for the ith signature\r\n   * @param _rs ith element is the R components of the ith signature on report. Must have at most maxNumOracles entries\r\n   * @param _ss ith element is the S components of the ith signature on report. Must have at most maxNumOracles entries\r\n   * @param _rawVs ith element is the the V component of the ith signature\r\n   */\r\n  function transmit(\r\n    // NOTE: If these parameters are changed, expectedMsgDataLength and/or\r\n    // TRANSMIT_MSGDATA_CONSTANT_LENGTH_COMPONENT need to be changed accordingly\r\n    bytes calldata _report,\r\n    bytes32[] calldata _rs, bytes32[] calldata _ss, bytes32 _rawVs // signatures\r\n  )\r\n    external\r\n  {\r\n    uint256 initialGas = gasleft(); // This line must come first\r\n    // Make sure the transmit message-length matches the inputs. Otherwise, the\r\n    // transmitter could append an arbitrarily long (up to gas-block limit)\r\n    // string of 0 bytes, which we would reimburse at a rate of 16 gas/byte, but\r\n    // which would only cost the transmitter 4 gas/byte. (Appendix G of the\r\n    // yellow paper, p. 25, for G_txdatazero and EIP 2028 for G_txdatanonzero.)\r\n    // This could amount to reimbursement profit of 36 million gas, given a 3MB\r\n    // zero tail.\r\n    require(msg.data.length == expectedMsgDataLength(_report, _rs, _ss),\r\n      \"transmit message too long\");\r\n    ReportData memory r; // Relieves stack pressure\r\n    {\r\n      r.hotVars = s_hotVars; // cache read from storage\r\n\r\n      bytes32 rawObservers;\r\n      (r.rawReportContext, rawObservers, r.observations) = abi.decode(\r\n        _report, (bytes32, bytes32, int192[])\r\n      );\r\n\r\n      // rawReportContext consists of:\r\n      // 11-byte zero padding\r\n      // 16-byte configDigest\r\n      // 4-byte epoch\r\n      // 1-byte round\r\n\r\n      bytes16 configDigest = bytes16(r.rawReportContext << 88);\r\n      require(\r\n        r.hotVars.latestConfigDigest == configDigest,\r\n        \"configDigest mismatch\"\r\n      );\r\n\r\n      uint40 epochAndRound = uint40(uint256(r.rawReportContext));\r\n\r\n      // direct numerical comparison works here, because\r\n      //\r\n      //   ((e,r) <= (e',r')) implies (epochAndRound <= epochAndRound')\r\n      //\r\n      // because alphabetic ordering implies e <= e', and if e = e', then r<=r',\r\n      // so e*256+r <= e'*256+r', because r, r' < 256\r\n      require(r.hotVars.latestEpochAndRound < epochAndRound, \"stale report\");\r\n\r\n      require(_rs.length > r.hotVars.threshold, \"not enough signatures\");\r\n      require(_rs.length <= maxNumOracles, \"too many signatures\");\r\n      require(_ss.length == _rs.length, \"signatures out of registration\");\r\n      require(r.observations.length <= maxNumOracles,\r\n              \"num observations out of bounds\");\r\n      require(r.observations.length > 2 * r.hotVars.threshold,\r\n              \"too few values to trust median\");\r\n\r\n      // Copy signature parities in bytes32 _rawVs to bytes r.v\r\n      r.vs = new bytes(_rs.length);\r\n      for (uint8 i = 0; i < _rs.length; i++) {\r\n        r.vs[i] = _rawVs[i];\r\n      }\r\n\r\n      // Copy observer identities in bytes32 rawObservers to bytes r.observers\r\n      r.observers = new bytes(r.observations.length);\r\n      bool[maxNumOracles] memory seen;\r\n      for (uint8 i = 0; i < r.observations.length; i++) {\r\n        uint8 observerIdx = uint8(rawObservers[i]);\r\n        require(!seen[observerIdx], \"observer index repeated\");\r\n        seen[observerIdx] = true;\r\n        r.observers[i] = rawObservers[i];\r\n      }\r\n\r\n      Oracle memory transmitter = s_oracles[msg.sender];\r\n      require( // Check that sender is authorized to report\r\n        transmitter.role == Role.Transmitter &&\r\n        msg.sender == s_transmitters[transmitter.index],\r\n        \"unauthorized transmitter\"\r\n      );\r\n      // record epochAndRound here, so that we don't have to carry the local\r\n      // variable in transmit. The change is reverted if something fails later.\r\n      r.hotVars.latestEpochAndRound = epochAndRound;\r\n    }\r\n\r\n    { // Verify signatures attached to report\r\n      bytes32 h = keccak256(_report);\r\n      bool[maxNumOracles] memory signed;\r\n\r\n      Oracle memory o;\r\n      for (uint i = 0; i < _rs.length; i++) {\r\n        address signer = ecrecover(h, uint8(r.vs[i])+27, _rs[i], _ss[i]);\r\n        o = s_oracles[signer];\r\n        require(o.role == Role.Signer, \"address not authorized to sign\");\r\n        require(!signed[o.index], \"non-unique signature\");\r\n        signed[o.index] = true;\r\n      }\r\n    }\r\n\r\n    { // Check the report contents, and record the result\r\n      for (uint i = 0; i < r.observations.length - 1; i++) {\r\n        bool inOrder = r.observations[i] <= r.observations[i+1];\r\n        require(inOrder, \"observations not sorted\");\r\n      }\r\n\r\n      int192 median = r.observations[r.observations.length/2];\r\n      require(minAnswer <= median && median <= maxAnswer, \"median is out of min-max range\");\r\n      r.hotVars.latestAggregatorRoundId++;\r\n      s_transmissions[r.hotVars.latestAggregatorRoundId] =\r\n        Transmission(median, uint64(block.timestamp));\r\n\r\n      emit NewTransmission(\r\n        r.hotVars.latestAggregatorRoundId,\r\n        median,\r\n        msg.sender,\r\n        r.observations,\r\n        r.observers,\r\n        r.rawReportContext\r\n      );\r\n      // Emit these for backwards compatability with offchain consumers\r\n      // that only support legacy events\r\n      emit NewRound(\r\n        r.hotVars.latestAggregatorRoundId,\r\n        address(0x0), // use zero address since we don't have anybody \"starting\" the round here\r\n        block.timestamp\r\n      );\r\n      emit AnswerUpdated(\r\n        median,\r\n        r.hotVars.latestAggregatorRoundId,\r\n        block.timestamp\r\n      );\r\n\r\n      validateAnswer(r.hotVars.latestAggregatorRoundId, median);\r\n    }\r\n    s_hotVars = r.hotVars;\r\n    assert(initialGas < maxUint32);\r\n    reimburseAndRewardOracles(uint32(initialGas), r.observers);\r\n  }\r\n\r\n  /*\r\n   * v2 Aggregator interface\r\n   */\r\n\r\n  /**\r\n   * @notice median from the most recent report\r\n   */\r\n  function latestAnswer()\r\n    public\r\n    override\r\n    view\r\n    virtual\r\n    returns (int256)\r\n  {\r\n    return s_transmissions[s_hotVars.latestAggregatorRoundId].answer;\r\n  }\r\n\r\n  /**\r\n   * @notice timestamp of block in which last report was transmitted\r\n   */\r\n  function latestTimestamp()\r\n    public\r\n    override\r\n    view\r\n    virtual\r\n    returns (uint256)\r\n  {\r\n    return s_transmissions[s_hotVars.latestAggregatorRoundId].timestamp;\r\n  }\r\n\r\n  /**\r\n   * @notice Aggregator round (NOT OCR round) in which last report was transmitted\r\n   */\r\n  function latestRound()\r\n    public\r\n    override\r\n    view\r\n    virtual\r\n    returns (uint256)\r\n  {\r\n    return s_hotVars.latestAggregatorRoundId;\r\n  }\r\n\r\n  /**\r\n   * @notice median of report from given aggregator round (NOT OCR round)\r\n   * @param _roundId the aggregator round of the target report\r\n   */\r\n  function getAnswer(uint256 _roundId)\r\n    public\r\n    override\r\n    view\r\n    virtual\r\n    returns (int256)\r\n  {\r\n    if (_roundId > 0xFFFFFFFF) { return 0; }\r\n    return s_transmissions[uint32(_roundId)].answer;\r\n  }\r\n\r\n  /**\r\n   * @notice timestamp of block in which report from given aggregator round was transmitted\r\n   * @param _roundId aggregator round (NOT OCR round) of target report\r\n   */\r\n  function getTimestamp(uint256 _roundId)\r\n    public\r\n    override\r\n    view\r\n    virtual\r\n    returns (uint256)\r\n  {\r\n    if (_roundId > 0xFFFFFFFF) { return 0; }\r\n    return s_transmissions[uint32(_roundId)].timestamp;\r\n  }\r\n\r\n  /*\r\n   * v3 Aggregator interface\r\n   */\r\n\r\n  string constant private V3_NO_DATA_ERROR = \"No data present\";\r\n\r\n  /**\r\n   * @return answers are stored in fixed-point format, with this many digits of precision\r\n   */\r\n  uint8 immutable public override decimals;\r\n\r\n  /**\r\n   * @notice aggregator contract version\r\n   */\r\n  uint256 constant public override version = 4;\r\n\r\n  string internal s_description;\r\n\r\n  /**\r\n   * @notice human-readable description of observable this contract is reporting on\r\n   */\r\n  function description()\r\n    public\r\n    override\r\n    view\r\n    virtual\r\n    returns (string memory)\r\n  {\r\n    return s_description;\r\n  }\r\n\r\n  /**\r\n   * @notice details for the given aggregator round\r\n   * @param _roundId target aggregator round (NOT OCR round). Must fit in uint32\r\n   * @return roundId _roundId\r\n   * @return answer median of report from given _roundId\r\n   * @return startedAt timestamp of block in which report from given _roundId was transmitted\r\n   * @return updatedAt timestamp of block in which report from given _roundId was transmitted\r\n   * @return answeredInRound _roundId\r\n   */\r\n  function getRoundData(uint80 _roundId)\r\n    public\r\n    override\r\n    view\r\n    virtual\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    )\r\n  {\r\n    require(_roundId <= 0xFFFFFFFF, V3_NO_DATA_ERROR);\r\n    Transmission memory transmission = s_transmissions[uint32(_roundId)];\r\n    return (\r\n      _roundId,\r\n      transmission.answer,\r\n      transmission.timestamp,\r\n      transmission.timestamp,\r\n      _roundId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice aggregator details for the most recently transmitted report\r\n   * @return roundId aggregator round of latest report (NOT OCR round)\r\n   * @return answer median of latest report\r\n   * @return startedAt timestamp of block containing latest report\r\n   * @return updatedAt timestamp of block containing latest report\r\n   * @return answeredInRound aggregator round of latest report\r\n   */\r\n  function latestRoundData()\r\n    public\r\n    override\r\n    view\r\n    virtual\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    )\r\n  {\r\n    roundId = s_hotVars.latestAggregatorRoundId;\r\n\r\n    // Skipped for compatability with existing FluxAggregator in which latestRoundData never reverts.\r\n    // require(roundId != 0, V3_NO_DATA_ERROR);\r\n\r\n    Transmission memory transmission = s_transmissions[uint32(roundId)];\r\n    return (\r\n      roundId,\r\n      transmission.answer,\r\n      transmission.timestamp,\r\n      transmission.timestamp,\r\n      roundId\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SimpleWriteAccessController\r\n * @notice Gives access to accounts explicitly added to an access list by the\r\n * controller's owner.\r\n * @dev does not make any special permissions for externally, see\r\n * SimpleReadAccessController for that.\r\n */\r\ncontract SimpleWriteAccessController is AccessControllerInterface, Owned {\r\n\r\n  bool public checkEnabled;\r\n  mapping(address => bool) internal accessList;\r\n\r\n  event AddedAccess(address user);\r\n  event RemovedAccess(address user);\r\n  event CheckAccessEnabled();\r\n  event CheckAccessDisabled();\r\n\r\n  constructor()\r\n  {\r\n    checkEnabled = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Returns the access of an address\r\n   * @param _user The address to query\r\n   */\r\n  function hasAccess(\r\n    address _user,\r\n    bytes memory\r\n  )\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return accessList[_user] || !checkEnabled;\r\n  }\r\n\r\n  /**\r\n   * @notice Adds an address to the access list\r\n   * @param _user The address to add\r\n   */\r\n  function addAccess(address _user) external onlyOwner() {\r\n    addAccessInternal(_user);\r\n  }\r\n\r\n  function addAccessInternal(address _user) internal {\r\n    if (!accessList[_user]) {\r\n      accessList[_user] = true;\r\n      emit AddedAccess(_user);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Removes an address from the access list\r\n   * @param _user The address to remove\r\n   */\r\n  function removeAccess(address _user)\r\n    external\r\n    onlyOwner()\r\n  {\r\n    if (accessList[_user]) {\r\n      accessList[_user] = false;\r\n\r\n      emit RemovedAccess(_user);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice makes the access check enforced\r\n   */\r\n  function enableAccessCheck()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    if (!checkEnabled) {\r\n      checkEnabled = true;\r\n\r\n      emit CheckAccessEnabled();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice makes the access check unenforced\r\n   */\r\n  function disableAccessCheck()\r\n    external\r\n    onlyOwner()\r\n  {\r\n    if (checkEnabled) {\r\n      checkEnabled = false;\r\n\r\n      emit CheckAccessDisabled();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev reverts if the caller does not have access\r\n   */\r\n  modifier checkAccess() {\r\n    require(hasAccess(msg.sender, msg.data), \"No access\");\r\n    _;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SimpleReadAccessController\r\n * @notice Gives access to:\r\n * - any externally owned account (note that offchain actors can always read\r\n * any contract storage regardless of onchain access control measures, so this\r\n * does not weaken the access control while improving usability)\r\n * - accounts explicitly added to an access list\r\n * @dev SimpleReadAccessController is not suitable for access controlling writes\r\n * since it grants any externally owned account access! See\r\n * SimpleWriteAccessController for that.\r\n */\r\ncontract SimpleReadAccessController is SimpleWriteAccessController {\r\n\r\n  /**\r\n   * @notice Returns the access of an address\r\n   * @param _user The address to query\r\n   */\r\n  function hasAccess(\r\n    address _user,\r\n    bytes memory _calldata\r\n  )\r\n    public\r\n    view\r\n    virtual\r\n    override\r\n    returns (bool)\r\n  {\r\n    return super.hasAccess(_user, _calldata) || _user == tx.origin;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @notice Wrapper of OffchainAggregator which checks read access on Aggregator-interface methods\r\n */\r\ncontract AccessControlledOffchainAggregator is OffchainAggregator, SimpleReadAccessController {\r\n\r\n  constructor(\r\n    uint32 _maximumGasPrice,\r\n    uint32 _reasonableGasPrice,\r\n    uint32 _microLinkPerEth,\r\n    uint32 _linkGweiPerObservation,\r\n    uint32 _linkGweiPerTransmission,\r\n    LinkTokenInterface _link,\r\n    int192 _minAnswer,\r\n    int192 _maxAnswer,\r\n    AccessControllerInterface _billingAccessController,\r\n    AccessControllerInterface _requesterAccessController,\r\n    uint8 _decimals,\r\n    string memory description\r\n  )\r\n    OffchainAggregator(\r\n      _maximumGasPrice,\r\n      _reasonableGasPrice,\r\n      _microLinkPerEth,\r\n      _linkGweiPerObservation,\r\n      _linkGweiPerTransmission,\r\n      _link,\r\n      _minAnswer,\r\n      _maxAnswer,\r\n      _billingAccessController,\r\n      _requesterAccessController,\r\n      _decimals,\r\n      description\r\n    ) {\r\n    }\r\n\r\n  /*\r\n   * Versioning\r\n   */\r\n\r\n  function typeAndVersion()\r\n    external\r\n    override\r\n    pure\r\n    virtual\r\n    returns (string memory)\r\n  {\r\n    return \"AccessControlledOffchainAggregator 3.0.0\";\r\n  }\r\n\r\n\r\n  /*\r\n   * v2 Aggregator interface\r\n   */\r\n\r\n  /// @inheritdoc OffchainAggregator\r\n  function latestAnswer()\r\n    public\r\n    override\r\n    view\r\n    checkAccess()\r\n    returns (int256)\r\n  {\r\n    return super.latestAnswer();\r\n  }\r\n\r\n  /// @inheritdoc OffchainAggregator\r\n  function latestTimestamp()\r\n    public\r\n    override\r\n    view\r\n    checkAccess()\r\n    returns (uint256)\r\n  {\r\n    return super.latestTimestamp();\r\n  }\r\n\r\n  /// @inheritdoc OffchainAggregator\r\n  function latestRound()\r\n    public\r\n    override\r\n    view\r\n    checkAccess()\r\n    returns (uint256)\r\n  {\r\n    return super.latestRound();\r\n  }\r\n\r\n  /// @inheritdoc OffchainAggregator\r\n  function getAnswer(uint256 _roundId)\r\n    public\r\n    override\r\n    view\r\n    checkAccess()\r\n    returns (int256)\r\n  {\r\n    return super.getAnswer(_roundId);\r\n  }\r\n\r\n  /// @inheritdoc OffchainAggregator\r\n  function getTimestamp(uint256 _roundId)\r\n    public\r\n    override\r\n    view\r\n    checkAccess()\r\n    returns (uint256)\r\n  {\r\n    return super.getTimestamp(_roundId);\r\n  }\r\n\r\n  /*\r\n   * v3 Aggregator interface\r\n   */\r\n\r\n  /// @inheritdoc OffchainAggregator\r\n  function description()\r\n    public\r\n    override\r\n    view\r\n    checkAccess()\r\n    returns (string memory)\r\n  {\r\n    return super.description();\r\n  }\r\n\r\n  /// @inheritdoc OffchainAggregator\r\n  function getRoundData(uint80 _roundId)\r\n    public\r\n    override\r\n    view\r\n    checkAccess()\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    )\r\n  {\r\n    return super.getRoundData(_roundId);\r\n  }\r\n\r\n  /// @inheritdoc OffchainAggregator\r\n  function latestRoundData()\r\n    public\r\n    override\r\n    view\r\n    checkAccess()\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    )\r\n  {\r\n    return super.latestRoundData();\r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_maximumGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_reasonableGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_microLinkPerEth\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_linkGweiPerObservation\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_linkGweiPerTransmission\",\"type\":\"uint32\"},{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_link\",\"type\":\"address\"},{\"internalType\":\"int192\",\"name\":\"_minAnswer\",\"type\":\"int192\"},{\"internalType\":\"int192\",\"name\":\"_maxAnswer\",\"type\":\"int192\"},{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_billingAccessController\",\"type\":\"address\"},{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_requesterAccessController\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"AddedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"int256\",\"name\":\"current\",\"type\":\"int256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"}],\"name\":\"AnswerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract AccessControllerInterface\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract AccessControllerInterface\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"BillingAccessControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"maximumGasPrice\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"reasonableGasPrice\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"microLinkPerEth\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"linkGweiPerObservation\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"linkGweiPerTransmission\",\"type\":\"uint32\"}],\"name\":\"BillingSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CheckAccessEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"previousConfigBlockNumber\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"configCount\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"transmitters\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"threshold\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"encodedConfigVersion\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"encoded\",\"type\":\"bytes\"}],\"name\":\"ConfigSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_oldLinkToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_newLinkToken\",\"type\":\"address\"}],\"name\":\"LinkTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"startedBy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"aggregatorRoundId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int192\",\"name\":\"answer\",\"type\":\"int192\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"int192[]\",\"name\":\"observations\",\"type\":\"int192[]\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"observers\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"rawReportContext\",\"type\":\"bytes32\"}],\"name\":\"NewTransmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"contract LinkTokenInterface\",\"name\":\"linkToken\",\"type\":\"address\"}],\"name\":\"OraclePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposed\",\"type\":\"address\"}],\"name\":\"PayeeshipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"transmitter\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"PayeeshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RemovedAccess\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract AccessControllerInterface\",\"name\":\"old\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract AccessControllerInterface\",\"name\":\"current\",\"type\":\"address\"}],\"name\":\"RequesterAccessControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes16\",\"name\":\"configDigest\",\"type\":\"bytes16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"}],\"name\":\"RoundRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"previousValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"previousGasLimit\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"currentValidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"currentGasLimit\",\"type\":\"uint32\"}],\"name\":\"ValidatorConfigSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmitter\",\"type\":\"address\"}],\"name\":\"acceptPayeeship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"addAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"billingAccessController\",\"outputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableAccessCheck\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBilling\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"maximumGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"reasonableGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"microLinkPerEth\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"linkGweiPerObservation\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"linkGweiPerTransmission\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLinkToken\",\"outputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"linkToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint80\",\"name\":\"_roundId\",\"type\":\"uint80\"}],\"name\":\"getRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"hasAccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestAnswer\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestConfigDetails\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"configCount\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"blockNumber\",\"type\":\"uint32\"},{\"internalType\":\"bytes16\",\"name\":\"configDigest\",\"type\":\"bytes16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRound\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestRoundData\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"roundId\",\"type\":\"uint80\"},{\"internalType\":\"int256\",\"name\":\"answer\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"startedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"updatedAt\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"answeredInRound\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestTransmissionDetails\",\"outputs\":[{\"internalType\":\"bytes16\",\"name\":\"configDigest\",\"type\":\"bytes16\"},{\"internalType\":\"uint32\",\"name\":\"epoch\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"round\",\"type\":\"uint8\"},{\"internalType\":\"int192\",\"name\":\"latestAnswer\",\"type\":\"int192\"},{\"internalType\":\"uint64\",\"name\":\"latestTimestamp\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"linkAvailableForPayment\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"availableBalance\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxAnswer\",\"outputs\":[{\"internalType\":\"int192\",\"name\":\"\",\"type\":\"int192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAnswer\",\"outputs\":[{\"internalType\":\"int192\",\"name\":\"\",\"type\":\"int192\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signerOrTransmitter\",\"type\":\"address\"}],\"name\":\"oracleObservationCount\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmitter\",\"type\":\"address\"}],\"name\":\"owedPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"removeAccess\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestNewRound\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"\",\"type\":\"uint80\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requesterAccessController\",\"outputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_maximumGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_reasonableGasPrice\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_microLinkPerEth\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_linkGweiPerObservation\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_linkGweiPerTransmission\",\"type\":\"uint32\"}],\"name\":\"setBilling\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_billingAccessController\",\"type\":\"address\"}],\"name\":\"setBillingAccessController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_transmitters\",\"type\":\"address[]\"},{\"internalType\":\"uint8\",\"name\":\"_threshold\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"_encodedConfigVersion\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_encoded\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LinkTokenInterface\",\"name\":\"_linkToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"setLinkToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_transmitters\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_payees\",\"type\":\"address[]\"}],\"name\":\"setPayees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AccessControllerInterface\",\"name\":\"_requesterAccessController\",\"type\":\"address\"}],\"name\":\"setRequesterAccessController\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"_newValidator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"_newGasLimit\",\"type\":\"uint32\"}],\"name\":\"setValidatorConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmitter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proposed\",\"type\":\"address\"}],\"name\":\"transferPayeeship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_report\",\"type\":\"bytes\"},{\"internalType\":\"bytes32[]\",\"name\":\"_rs\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"_ss\",\"type\":\"bytes32[]\"},{\"internalType\":\"bytes32\",\"name\":\"_rawVs\",\"type\":\"bytes32\"}],\"name\":\"transmit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transmitters\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typeAndVersion\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorConfig\",\"outputs\":[{\"internalType\":\"contract AggregatorValidatorInterface\",\"name\":\"validator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"gasLimit\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_transmitter\",\"type\":\"address\"}],\"name\":\"withdrawPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AccessControlledOffchainAggregator", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "20000", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000002bc00000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000019a280000000000000000000000000000000000000000000000000000000000017f2a0000000000000000000000000000000000000000000000000000000000090c65000000000000000000000000b0897686c545045afc77cf20ec7a532e3120e0f1000000000000000000000000000000000000000000000000000000000000000100000000000000000000ffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000494e19780c3fe5b2a61ee6d6380fea4b408a2c070000000000000000000000006a9f4359350172ac4b1d4132639fe23f9562d77800000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000000942524c202f205553440000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://757bff216f6d81152fcaa510caac9632619adc3b29bcb61ba73c0af8d453fb28"}