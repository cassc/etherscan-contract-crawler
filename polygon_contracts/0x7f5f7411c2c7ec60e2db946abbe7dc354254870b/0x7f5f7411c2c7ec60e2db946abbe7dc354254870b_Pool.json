{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n// File: contracts/Const.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.8.12;\r\n\r\nlibrary Const {\r\n    uint256 public constant ONE                       = 10**18;\r\n\r\n    uint256 public constant MIN_BOUND_TOKENS           = 2;\r\n    uint256 public constant MAX_BOUND_TOKENS           = 8;\r\n\r\n    uint256 public constant MIN_FEE                    = ONE / 10**6;\r\n    uint256 public constant BASE_FEE                   = 25 * ONE / 10**5;\r\n    uint256 public constant MAX_FEE                    = ONE / 10;\r\n    uint256 public constant EXIT_FEE                   = 0;\r\n\r\n    uint80 public constant MIN_WEIGHT                  = uint80(ONE);\r\n    uint80 public constant MAX_WEIGHT                  = uint80(ONE * 50);\r\n    uint80 public constant MAX_TOTAL_WEIGHT            = uint80(ONE * 50);\r\n    uint256 public constant MIN_BALANCE                = ONE / 10**12;\r\n\r\n    uint256 public constant INIT_POOL_SUPPLY           = ONE * 100;\r\n\r\n    uint256 public constant MIN_POW_BASE              = 1 wei;\r\n    uint256 public constant MAX_POW_BASE              = (2 * ONE) - 1 wei;\r\n    uint256 public constant POW_PRECISION             = ONE / 10**10;\r\n\r\n    uint public constant MAX_IN_RATIO                  = ONE / 2;\r\n    uint public constant MAX_OUT_RATIO                 = (ONE / 3) + 1 wei;\r\n\r\n    uint64 public constant BASE_Z                      = uint64(6 * ONE);\r\n\r\n    uint256 public constant MIN_HORIZON                = 1 * ONE;\r\n    uint256 public constant BASE_HORIZON               = 5 * ONE;\r\n\r\n    uint8 public constant MIN_LOOKBACK_IN_ROUND        = 1;\r\n    uint8 public constant BASE_LOOKBACK_IN_ROUND       = 5;\r\n    uint8 public constant MAX_LOOKBACK_IN_ROUND        = 100;\r\n\r\n    uint256 public constant MIN_LOOKBACK_IN_SEC        = 1;\r\n    uint256 public constant BASE_LOOKBACK_IN_SEC       = 3600;\r\n\r\n    uint256 public constant MIN_MAX_PRICE_UNPEG_RATIO  = ONE + ONE / 800;\r\n    uint256 public constant BASE_MAX_PRICE_UNPEG_RATIO = ONE + ONE / 40;\r\n    uint256 public constant MAX_MAX_PRICE_UNPEG_RATIO  = ONE + ONE / 10;\r\n\r\n    uint64 public constant PAUSE_WINDOW                = 86400 * 60;\r\n\r\n    uint256 public constant FALLBACK_SPREAD            = 3 * ONE / 1000;\r\n\r\n    uint256 public constant ORACLE_TIMEOUT             = 2 * 60;\r\n\r\n    uint8 public constant MIN_LOOKBACK_STEP_IN_ROUND   = 1;\r\n    uint8 public constant LOOKBACK_STEP_IN_ROUND       = 4;\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: contracts/interfaces/IPoolHelpers/IPoolToken.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/**\r\n* @title Contains the external methods implemented by PoolToken\r\n*/\r\ninterface IPoolToken is IERC20 {\r\n    \r\n    /**\r\n    * @notice Returns token's name\r\n    */\r\n    function name() external pure returns (string memory name);\r\n\r\n    /**\r\n    * @notice Returns token's symbol\r\n    */\r\n    function symbol() external pure returns (string memory symbol);\r\n    \r\n    /**\r\n    * @notice Returns token's decimals\r\n    */\r\n    function decimals() external pure returns(uint8 decimals);\r\n\r\n    /**\r\n    * @notice Increases an address approval by the input amount\r\n    */\r\n    function increaseApproval(address dst, uint256 amt) external returns (bool);\r\n\r\n    /**\r\n    * @notice Decreases an address approval by the input amount\r\n    */\r\n    function decreaseApproval(address dst, uint256 amt) external returns (bool);\r\n\r\n}\r\n\r\n// File: contracts/Errors.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/**\r\n * @author Forked from contracts developed by Balancer Labs and adapted by Swaap Labs\r\n */\r\nlibrary Err {\r\n\r\n    uint256 internal constant REENTRY = 0;\r\n    uint256 internal constant NOT_FINALIZED = 1;\r\n    uint256 internal constant NOT_BOUND = 2;\r\n    uint256 internal constant NOT_CONTROLLER = 3;\r\n    uint256 internal constant IS_FINALIZED = 4;\r\n    uint256 internal constant MATH_APPROX = 5;\r\n    uint256 internal constant NOT_FACTORY = 6;\r\n    uint256 internal constant FACTORY_CONTROL_REVOKED = 7;\r\n    uint256 internal constant LIMIT_IN = 8;\r\n    uint256 internal constant LIMIT_OUT = 9;\r\n    uint256 internal constant SWAP_NOT_PUBLIC = 10;\r\n    uint256 internal constant BAD_LIMIT_PRICE = 11;\r\n    uint256 internal constant NOT_ADMIN = 12;\r\n    uint256 internal constant NULL_CONTROLLER = 13;\r\n    uint256 internal constant MIN_FEE = 14;\r\n    uint256 internal constant MAX_FEE = 15;\r\n    uint256 internal constant NON_POSITIVE_PRICE = 16;\r\n    uint256 internal constant NOT_POOL = 17;\r\n    uint256 internal constant MIN_TOKENS = 18;\r\n    uint256 internal constant INSUFFICIENT_BALANCE = 19;\r\n    uint256 internal constant NOT_PENDING_SWAAPLABS = 20;\r\n    uint256 internal constant INSUFFICIENT_ALLOWANCE = 21;\r\n    uint256 internal constant MIN_HORIZON = 22;\r\n    uint256 internal constant MAX_HORIZON = 23;\r\n    uint256 internal constant MIN_LB_PERIODS = 24;\r\n    uint256 internal constant MAX_LB_PERIODS = 25;\r\n    uint256 internal constant MIN_LB_SECS = 26;\r\n    // uint256 internal constant MAX_LB_SECS = 27;\r\n    uint256 internal constant IS_BOUND = 28;\r\n    uint256 internal constant MAX_TOKENS = 29;\r\n    uint256 internal constant MIN_WEIGHT = 30;\r\n    uint256 internal constant MAX_WEIGHT = 31;\r\n    uint256 internal constant MIN_BALANCE = 32;\r\n    uint256 internal constant MAX_TOTAL_WEIGHT = 33;\r\n    uint256 internal constant NOT_SWAAPLABS = 34;\r\n    uint256 internal constant NULL_ADDRESS = 35;\r\n    uint256 internal constant PAUSED_FACTORY = 36;\r\n    uint256 internal constant X_OUT_OF_BOUNDS = 37;\r\n    uint256 internal constant Y_OUT_OF_BOUNDS = 38;\r\n    uint256 internal constant POW_BASE_TOO_LOW = 39;\r\n    uint256 internal constant POW_BASE_TOO_HIGH = 40;\r\n    uint256 internal constant PRODUCT_OUT_OF_BOUNDS = 41;\r\n    uint256 internal constant INVALID_EXPONENT = 42;\r\n    uint256 internal constant OUT_OF_BOUNDS = 43;\r\n    uint256 internal constant MAX_PRICE_UNPEG_RATIO = 44;\r\n    uint256 internal constant PAUSE_WINDOW_EXCEEDED = 45;\r\n    // uint256 internal constant MAX_PRICE_DELAY_SEC = 46;\r\n    uint256 internal constant NOT_PENDING_CONTROLLER = 47;\r\n    uint256 internal constant EXCEEDED_ORACLE_TIMEOUT = 48;\r\n    uint256 internal constant NEGATIVE_PRICE = 49;\r\n    uint256 internal constant BINDED_TOKENS = 50;\r\n    uint256 internal constant PENDING_NEW_CONTROLLER = 51;\r\n    uint256 internal constant UNEXPECTED_BALANCE = 52;\r\n    uint256 internal constant MIN_LB_STEP_PERIODS = 53;\r\n    uint256 internal constant INPUT_LENGTH_MISMATCH = 54;\r\n    uint256 internal constant MIN_MAX_PRICE_UNPEG_RATIO = 55;\r\n    uint256 internal constant MAX_MAX_PRICE_UNPEG_RATIO = 56;\r\n    uint256 internal constant MAX_IN_RATIO = 57;\r\n    uint256 internal constant MAX_OUT_RATIO = 58;\r\n}\r\n\r\n/**\r\n* @dev Reverts if `condition` is false, with a revert reason containing `errorCode`. Only codes up to 99 are\r\n* supported.\r\n*/\r\nfunction _require(bool condition, uint256 errorCode) pure {\r\n    if (!condition) _revert(errorCode);\r\n}\r\n\r\n\r\n/**\r\n * @dev Reverts with a revert reason containing `errorCode`. Only codes up to 99 are supported.\r\n */\r\nfunction _revert(uint256 errorCode) pure {\r\n    // We're going to dynamically create a revert uint256 based on the error code, with the following format:\r\n    // 'SWAAP#{errorCode}'\r\n    // where the code is left-padded with zeroes to three digits (so they range from 00 to 99).\r\n    //\r\n    // We don't have revert uint256s embedded in the contract to save bytecode size: it takes much less space to store a\r\n    // number (8 to 16 bits) than the individual uint256 characters.\r\n    //\r\n    // The dynamic uint256 creation algorithm that follows could be implemented in Solidity, but assembly allows for a\r\n    // much denser implementation, again saving bytecode size. Given this function unconditionally reverts, this is a\r\n    // safe place to rely on it without worrying about how its usage might affect e.g. memory contents.\r\n    assembly {\r\n        // First, we need to compute the ASCII representation of the error code. We assume that it is in the 0-99\r\n        // range, so we only need to convert three digits. To convert the digits to ASCII, we add 0x30, the value for\r\n        // the '0' character.\r\n\r\n        let units := add(mod(errorCode, 10), 0x30)\r\n\r\n        errorCode := div(errorCode, 10)\r\n        let tenths := add(mod(errorCode, 10), 0x30)\r\n\r\n        // With the individual characters, we can now construct the full uint256. The SWAAP# part is a known constant\r\n        // (0x535741415023): we simply shift this by 16 (to provide space for the 2 bytes of the error code), and add\r\n        // the characters to it, each shifted by a multiple of 8.\r\n        // The revert reason is then shifted left by 192 bits (256 minus the length of the uint256, 8 characters * 8\r\n        // bits per character = 64) to locate it in the most significant part of the 256 slot (the beginning of a byte\r\n        // array).\r\n\r\n        let revertReason := shl(192, add(0x5357414150230000, add(units, shl(8, tenths))))\r\n\r\n        // We can now encode the reason in memory, which can be safely overwritten as we're about to revert. The encoded\r\n        // message will have the following layout:\r\n        // [ revert reason identifier ] [ uint256 location offset ] [ uint256 length ] [ uint256 contents ]\r\n\r\n        // The Solidity revert reason identifier is 0x08c739a0, the function selector of the Error(uint256) function. We\r\n        // also write zeroes to the next 29 bytes of memory, but those are about to be overwritten.\r\n        mstore(0x0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\r\n        // Next is the offset to the location of the uint256, which will be placed immediately after (20 bytes away).\r\n        mstore(0x04, 0x0000000000000000000000000000000000000000000000000000000000000020)\r\n        // The uint256 length is fixed: 8 characters.\r\n        mstore(0x24, 8)\r\n        // Finally, the uint256 itself is stored.\r\n        mstore(0x44, revertReason)\r\n\r\n        // Even if the uint256 is only 8 bytes long, we need to return a full 32 byte slot containing it. The length of\r\n        // the encoded message is therefore 4 + 32 + 32 + 32 = 100.\r\n        revert(0, 100)\r\n    }\r\n}\r\n\r\n// File: contracts/PoolToken.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n\r\n// Highly opinionated token implementation\r\n\r\ncontract PoolToken is IPoolToken {\r\n\r\n    mapping(address => uint256)                   internal _balance;\r\n    mapping(address => mapping(address=>uint256)) internal _allowance;\r\n    uint256 internal _totalSupply;\r\n\r\n    function _mint(uint256 amt) internal {\r\n        _balance[address(this)] = _balance[address(this)] + amt;\r\n        _totalSupply = _totalSupply + amt;\r\n        emit Transfer(address(0), address(this), amt);\r\n    }\r\n\r\n    function _burn(uint256 amt) internal {\r\n        _balance[address(this)] = _balance[address(this)] - amt;\r\n        _totalSupply = _totalSupply - amt;\r\n        emit Transfer(address(this), address(0), amt);\r\n    }\r\n\r\n    function _move(address src, address dst, uint256 amt) internal {\r\n        _require(dst != address(0), Err.NULL_ADDRESS);\r\n        \r\n        uint256 fromBalance = _balance[src];\r\n        _require(fromBalance >= amt, Err.INSUFFICIENT_BALANCE);\r\n        unchecked {\r\n            _balance[src] = fromBalance - amt;\r\n        }\r\n        _balance[dst] += amt;\r\n\r\n        emit Transfer(src, dst, amt);\r\n    }\r\n\r\n    function _push(address to, uint256 amt) internal {\r\n        _move(address(this), to, amt);\r\n    }\r\n\r\n    function _pull(address from, uint256 amt) internal {\r\n        _move(from, address(this), amt);\r\n    }\r\n\r\n    string constant private _name     = \"Swaap Pool Token\";\r\n    string constant private _symbol   = \"SPT\";\r\n    uint8  constant private _decimals = 18;\r\n\r\n    function name() external pure returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() external pure returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() external pure returns(uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n\r\n    function allowance(address src, address dst) external view returns (uint256) {\r\n        return _allowance[src][dst];\r\n    }\r\n\r\n    function balanceOf(address whom) external view returns (uint256) {\r\n        return _balance[whom];\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function approve(address dst, uint256 amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = amt;\r\n        emit Approval(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address dst, uint256 amt) external returns (bool) {\r\n        _allowance[msg.sender][dst] = _allowance[msg.sender][dst] + amt;\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address dst, uint256 amt) external returns (bool) {\r\n        uint256 oldValue = _allowance[msg.sender][dst];\r\n        if (amt > oldValue) {\r\n            _allowance[msg.sender][dst] = 0;\r\n        } else {\r\n            _allowance[msg.sender][dst] = oldValue - amt;\r\n        }\r\n        emit Approval(msg.sender, dst, _allowance[msg.sender][dst]);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint256 amt) external returns (bool) {\r\n        _move(msg.sender, dst, amt);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 amt) external returns (bool) {\r\n        if (msg.sender != src && _allowance[src][msg.sender] != type(uint256).max) {\r\n            uint256 currentAllowance = _allowance[src][msg.sender];\r\n            _require(currentAllowance >= amt, Err.INSUFFICIENT_ALLOWANCE);\r\n            unchecked {\r\n                _allowance[src][msg.sender] = currentAllowance - amt;\r\n            }\r\n            emit Approval(msg.sender, dst, _allowance[src][msg.sender]);\r\n        }\r\n        _move(src, dst, amt);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/Num.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n\r\nlibrary Num {\r\n\r\n    function toi(uint256 a)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        return a / Const.ONE;\r\n    }\r\n\r\n    function floor(uint256 a)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        return toi(a) * Const.ONE;\r\n    }\r\n\r\n    function subSign(uint256 a, uint256 b)\r\n        internal pure\r\n        returns (uint256, bool)\r\n    {\r\n        if (a >= b) {\r\n            return (a - b, false);\r\n        } else {\r\n            return (b - a, true);\r\n        }\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c0 = a * b;\r\n        uint256 c1 = c0 + (Const.ONE / 2);\r\n        uint256 c2 = c1 / Const.ONE;\r\n        return c2;\r\n    }\r\n\r\n    function mulTruncated(uint256 a, uint256 b)\r\n    internal pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c0 = a * b;\r\n        return c0 / Const.ONE;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c0 = a * Const.ONE;\r\n        uint256 c1 = c0 + (b / 2);\r\n        uint256 c2 = c1 / b;\r\n        return c2;\r\n    }\r\n\r\n    function divTruncated(uint256 a, uint256 b)\r\n    internal pure\r\n    returns (uint256)\r\n    {\r\n        uint256 c0 = a * Const.ONE;\r\n        return c0 / b;\r\n    }\r\n\r\n    // DSMath.wpow\r\n    function powi(uint256 a, uint256 n)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        uint256 z = n % 2 != 0 ? a : Const.ONE;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            a = mul(a, a);\r\n\r\n            if (n % 2 != 0) {\r\n                z = mul(z, a);\r\n            }\r\n        }\r\n        return z;\r\n    }\r\n\r\n    // Compute b^(e.w) by splitting it into (b^e)*(b^0.w).\r\n    // Use `powi` for `b^e` and `powK` for k iterations\r\n    // of approximation of b^0.w\r\n    function pow(uint256 base, uint256 exp)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        _require(base >= Const.MIN_POW_BASE, Err.POW_BASE_TOO_LOW);\r\n        _require(base <= Const.MAX_POW_BASE, Err.POW_BASE_TOO_HIGH);\r\n\r\n        uint256 whole  = floor(exp);\r\n        uint256 remain = exp - whole;\r\n\r\n        uint256 wholePow = powi(base, toi(whole));\r\n\r\n        if (remain == 0) {\r\n            return wholePow;\r\n        }\r\n\r\n        uint256 partialResult = powApprox(base, remain, Const.POW_PRECISION);\r\n        return mul(wholePow, partialResult);\r\n    }\r\n\r\n    function powApprox(uint256 base, uint256 exp, uint256 precision)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        // term 0:\r\n        uint256 a     = exp;\r\n        (uint256 x, bool xneg)  = subSign(base, Const.ONE);\r\n        uint256 term = Const.ONE;\r\n        uint256 sum   = term;\r\n        bool negative = false;\r\n\r\n\r\n        // term(k) = numer / denom \r\n        //         = (product(a - i - 1, i=1-->k) * x^k) / (k!)\r\n        // each iteration, multiply previous term by (a-(k-1)) * x / k\r\n        // continue until term is less than precision\r\n        for (uint256 i = 1; term >= precision; i++) {\r\n            uint256 bigK = i * Const.ONE;\r\n            (uint256 c, bool cneg) = subSign(a, bigK - Const.ONE);\r\n            term = mul(term, mul(c, x));\r\n            term = div(term, bigK);\r\n            if (term == 0) break;\r\n\r\n            if (xneg) negative = !negative;\r\n            if (cneg) negative = !negative;\r\n            if (negative) {\r\n                sum -= term;\r\n            } else {\r\n                sum += term;\r\n            }\r\n        }\r\n\r\n        return sum;\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the division of 2 int256 with ONE precision\r\n    * @dev Converts inputs to uint256 if needed, and then uses div(uint256, uint256)\r\n    * @param a The int256 representation of a floating point number with ONE precision\r\n    * @param b The int256 representation of a floating point number with ONE precision\r\n    * @return b The division of 2 int256 with ONE precision\r\n    */\r\n    function divInt256(int256 a, int256 b) internal pure returns (int256) {\r\n        if (a < 0) {\r\n            if (b < 0) {\r\n                return int256(div(uint256(-a), uint256(-b))); // both negative\r\n            } else {\r\n                return -int256(div(uint256(-a), uint256(b))); // a < 0, b >= 0\r\n            }\r\n        } else {\r\n            if (b < 0) {\r\n                return -int256(div(uint256(a), uint256(-b))); // a >= 0, b < 0\r\n            } else {\r\n                return int256(div(uint256(a), uint256(b))); // both positive\r\n            }\r\n        }\r\n    }\r\n\r\n    function positivePart(int256 value) internal pure returns (uint256) {\r\n        if (value <= 0) {\r\n            return uint256(0);\r\n        }\r\n        return uint256(value);\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a < b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/LogExpMath.sol\r\n\r\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated\r\n// documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the\r\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\r\n// permit persons to whom the Software is furnished to do so, subject to the following conditions:\r\n\r\n// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the\r\n// Software.\r\n\r\n// THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE\r\n// WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\r\n// COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\r\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n\r\n\r\n/* solhint-disable */\r\n\r\n/**\r\n * @dev Exponentiation and logarithm functions for 18 decimal fixed point numbers (both base and exponent/argument).\r\n *\r\n * Exponentiation and logarithm with arbitrary bases (x^y and log_x(y)) are implemented by conversion to natural\r\n * exponentiation and logarithm (where the base is Euler's number).\r\n *\r\n * @author Fernando Martinelli - @fernandomartinelli\r\n * @author Sergio Yuhjtman - @sergioyuhjtman\r\n * @author Daniel Fernandez - @dmf7z\r\n */\r\nlibrary LogExpMath {\r\n    // All fixed point multiplications and divisions are inlined. This means we need to divide by ONE when multiplying\r\n    // two numbers, and multiply by ONE when dividing them.\r\n\r\n    // All arguments and return values are 18 decimal fixed point numbers.\r\n    int256 constant ONE_18 = 1e18;\r\n\r\n    // Internally, intermediate values are computed with higher precision as 20 decimal fixed point numbers, and in the\r\n    // case of ln36, 36 decimals.\r\n    int256 constant ONE_20 = 1e20;\r\n    int256 constant ONE_36 = 1e36;\r\n\r\n    // The domain of natural exponentiation is bound by the word size and number of decimals used.\r\n    //\r\n    // Because internally the result will be stored using 20 decimals, the largest possible result is\r\n    // (2^255 - 1) / 10^20, which makes the largest exponent ln((2^255 - 1) / 10^20) = 130.700829182905140221.\r\n    // The smallest possible result is 10^(-18), which makes largest negative argument\r\n    // ln(10^(-18)) = -41.446531673892822312.\r\n    // We use 130.0 and -41.0 to have some safety margin.\r\n    int256 constant MAX_NATURAL_EXPONENT = 130e18;\r\n    int256 constant MIN_NATURAL_EXPONENT = -41e18;\r\n\r\n    // Bounds for ln_36's argument. Both ln(0.9) and ln(1.1) can be represented with 36 decimal places in a fixed point\r\n    // 256 bit integer.\r\n    int256 constant LN_36_LOWER_BOUND = ONE_18 - 1e17;\r\n    int256 constant LN_36_UPPER_BOUND = ONE_18 + 1e17;\r\n\r\n    uint256 constant MILD_EXPONENT_BOUND = 2**254 / uint256(ONE_20);\r\n\r\n    // 18 decimal constants\r\n    int256 constant x0 = 128000000000000000000; // 2\u02c67\r\n    int256 constant a0 = 38877084059945950922200000000000000000000000000000000000; // e\u02c6(x0) (no decimals)\r\n    int256 constant x1 = 64000000000000000000; // 2\u02c66\r\n    int256 constant a1 = 6235149080811616882910000000; // e\u02c6(x1) (no decimals)\r\n\r\n    // 20 decimal constants\r\n    int256 constant x2 = 3200000000000000000000; // 2\u02c65\r\n    int256 constant a2 = 7896296018268069516100000000000000; // e\u02c6(x2)\r\n    int256 constant x3 = 1600000000000000000000; // 2\u02c64\r\n    int256 constant a3 = 888611052050787263676000000; // e\u02c6(x3)\r\n    int256 constant x4 = 800000000000000000000; // 2\u02c63\r\n    int256 constant a4 = 298095798704172827474000; // e\u02c6(x4)\r\n    int256 constant x5 = 400000000000000000000; // 2\u02c62\r\n    int256 constant a5 = 5459815003314423907810; // e\u02c6(x5)\r\n    int256 constant x6 = 200000000000000000000; // 2\u02c61\r\n    int256 constant a6 = 738905609893065022723; // e\u02c6(x6)\r\n    int256 constant x7 = 100000000000000000000; // 2\u02c60\r\n    int256 constant a7 = 271828182845904523536; // e\u02c6(x7)\r\n    int256 constant x8 = 50000000000000000000; // 2\u02c6-1\r\n    int256 constant a8 = 164872127070012814685; // e\u02c6(x8)\r\n    int256 constant x9 = 25000000000000000000; // 2\u02c6-2\r\n    int256 constant a9 = 128402541668774148407; // e\u02c6(x9)\r\n    int256 constant x10 = 12500000000000000000; // 2\u02c6-3\r\n    int256 constant a10 = 113314845306682631683; // e\u02c6(x10)\r\n    int256 constant x11 = 6250000000000000000; // 2\u02c6-4\r\n    int256 constant a11 = 106449445891785942956; // e\u02c6(x11)\r\n\r\n    /**\r\n     * @dev Exponentiation (x^y) with unsigned 18 decimal fixed point base and exponent.\r\n     *\r\n     * Reverts if ln(x) * y is smaller than `MIN_NATURAL_EXPONENT`, or larger than `MAX_NATURAL_EXPONENT`.\r\n     */\r\n    function pow(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (y == 0) {\r\n            // We solve the 0^0 indetermination by making it equal one.\r\n            return uint256(ONE_18);\r\n        }\r\n\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Instead of computing x^y directly, we instead rely on the properties of logarithms and exponentiation to\r\n        // arrive at that result. In particular, exp(ln(x)) = x, and ln(x^y) = y * ln(x). This means\r\n        // x^y = exp(y * ln(x)).\r\n\r\n        // The ln function takes a signed value, so we need to make sure x fits in the signed 256 bit range.\r\n        _require(x < 2**255, Err.X_OUT_OF_BOUNDS);\r\n        int256 x_int256 = int256(x);\r\n\r\n        // We will compute y * ln(x) in a single step. Depending on the value of x, we can either use ln or ln_36. In\r\n        // both cases, we leave the division by ONE_18 (due to fixed point multiplication) to the end.\r\n\r\n        // This prevents y * ln(x) from overflowing, and at the same time guarantees y fits in the signed 256 bit range.\r\n        _require(y < MILD_EXPONENT_BOUND, Err.Y_OUT_OF_BOUNDS);\r\n        int256 y_int256 = int256(y);\r\n\r\n        int256 logx_times_y;\r\n        if (LN_36_LOWER_BOUND < x_int256 && x_int256 < LN_36_UPPER_BOUND) {\r\n            int256 ln_36_x = _ln_36(x_int256);\r\n\r\n            // ln_36_x has 36 decimal places, so multiplying by y_int256 isn't as straightforward, since we can't just\r\n            // bring y_int256 to 36 decimal places, as it might overflow. Instead, we perform two 18 decimal\r\n            // multiplications and add the results: one with the first 18 decimals of ln_36_x, and one with the\r\n            // (downscaled) last 18 decimals.\r\n            logx_times_y = ((ln_36_x / ONE_18) * y_int256 + ((ln_36_x % ONE_18) * y_int256) / ONE_18);\r\n        } else {\r\n            logx_times_y = _ln(x_int256) * y_int256;\r\n        }\r\n        logx_times_y /= ONE_18;\r\n\r\n        // Finally, we compute exp(y * ln(x)) to arrive at x^y\r\n        _require(\r\n            MIN_NATURAL_EXPONENT <= logx_times_y && logx_times_y <= MAX_NATURAL_EXPONENT,\r\n            Err.PRODUCT_OUT_OF_BOUNDS\r\n        );\r\n\r\n        return uint256(exp(logx_times_y));\r\n    }\r\n\r\n    /**\r\n     * @dev Natural exponentiation (e^x) with signed 18 decimal fixed point exponent.\r\n     *\r\n     * Reverts if `x` is smaller than MIN_NATURAL_EXPONENT, or larger than `MAX_NATURAL_EXPONENT`.\r\n     */\r\n    function exp(int256 x) internal pure returns (int256) {\r\n        _require(x >= MIN_NATURAL_EXPONENT && x <= MAX_NATURAL_EXPONENT, Err.INVALID_EXPONENT);\r\n\r\n        if (x < 0) {\r\n            // We only handle positive exponents: e^(-x) is computed as 1 / e^x. We can safely make x positive since it\r\n            // fits in the signed 256 bit range (as it is larger than MIN_NATURAL_EXPONENT).\r\n            // Fixed point division requires multiplying by ONE_18.\r\n            return ((ONE_18 * ONE_18) / exp(-x));\r\n        }\r\n\r\n        // First, we use the fact that e^(x+y) = e^x * e^y to decompose x into a sum of powers of two, which we call x_n,\r\n        // where x_n == 2^(7 - n), and e^x_n = a_n has been precomputed. We choose the first x_n, x0, to equal 2^7\r\n        // because all larger powers are larger than MAX_NATURAL_EXPONENT, and therefore not present in the\r\n        // decomposition.\r\n        // At the end of this process we will have the product of all e^x_n = a_n that apply, and the remainder of this\r\n        // decomposition, which will be lower than the smallest x_n.\r\n        // exp(x) = k_0 * a_0 * k_1 * a_1 * ... + k_n * a_n * exp(remainder), where each k_n equals either 0 or 1.\r\n        // We mutate x by subtracting x_n, making it the remainder of the decomposition.\r\n\r\n        // The first two a_n (e^(2^7) and e^(2^6)) are too large if stored as 18 decimal numbers, and could cause\r\n        // intermediate overflows. Instead we store them as plain integers, with 0 decimals.\r\n        // Additionally, x0 + x1 is larger than MAX_NATURAL_EXPONENT, which means they will not both be present in the\r\n        // decomposition.\r\n\r\n        // For each x_n, we test if that term is present in the decomposition (if x is larger than it), and if so deduct\r\n        // it and compute the accumulated product.\r\n\r\n        int256 firstAN;\r\n        if (x >= x0) {\r\n            x -= x0;\r\n            firstAN = a0;\r\n        } else if (x >= x1) {\r\n            x -= x1;\r\n            firstAN = a1;\r\n        } else {\r\n            firstAN = 1; // One with no decimal places\r\n        }\r\n\r\n        // We now transform x into a 20 decimal fixed point number, to have enhanced precision when computing the\r\n        // smaller terms.\r\n        x *= 100;\r\n\r\n        // `product` is the accumulated product of all a_n (except a0 and a1), which starts at 20 decimal fixed point\r\n        // one. Recall that fixed point multiplication requires dividing by ONE_20.\r\n        int256 product = ONE_20;\r\n\r\n        if (x >= x2) {\r\n            x -= x2;\r\n            product = (product * a2) / ONE_20;\r\n        }\r\n        if (x >= x3) {\r\n            x -= x3;\r\n            product = (product * a3) / ONE_20;\r\n        }\r\n        if (x >= x4) {\r\n            x -= x4;\r\n            product = (product * a4) / ONE_20;\r\n        }\r\n        if (x >= x5) {\r\n            x -= x5;\r\n            product = (product * a5) / ONE_20;\r\n        }\r\n        if (x >= x6) {\r\n            x -= x6;\r\n            product = (product * a6) / ONE_20;\r\n        }\r\n        if (x >= x7) {\r\n            x -= x7;\r\n            product = (product * a7) / ONE_20;\r\n        }\r\n        if (x >= x8) {\r\n            x -= x8;\r\n            product = (product * a8) / ONE_20;\r\n        }\r\n        if (x >= x9) {\r\n            x -= x9;\r\n            product = (product * a9) / ONE_20;\r\n        }\r\n\r\n        // x10 and x11 are unnecessary here since we have high enough precision already.\r\n\r\n        // Now we need to compute e^x, where x is small (in particular, it is smaller than x9). We use the Taylor series\r\n        // expansion for e^x: 1 + x + (x^2 / 2!) + (x^3 / 3!) + ... + (x^n / n!).\r\n\r\n        int256 seriesSum = ONE_20; // The initial one in the sum, with 20 decimal places.\r\n        int256 term; // Each term in the sum, where the nth term is (x^n / n!).\r\n\r\n        // The first term is simply x.\r\n        term = x;\r\n        seriesSum += term;\r\n\r\n        // Each term (x^n / n!) equals the previous one times x, divided by n. Since x is a fixed point number,\r\n        // multiplying by it requires dividing by ONE_20, but dividing by the non-fixed point n values does not.\r\n\r\n        term = ((term * x) / ONE_20) / 2;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 3;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 4;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 5;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 6;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 7;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 8;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 9;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 10;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 11;\r\n        seriesSum += term;\r\n\r\n        term = ((term * x) / ONE_20) / 12;\r\n        seriesSum += term;\r\n\r\n        // 12 Taylor terms are sufficient for 18 decimal precision.\r\n\r\n        // We now have the first a_n (with no decimals), and the product of all other a_n present, and the Taylor\r\n        // approximation of the exponentiation of the remainder (both with 20 decimals). All that remains is to multiply\r\n        // all three (one 20 decimal fixed point multiplication, dividing by ONE_20, and one integer multiplication),\r\n        // and then drop two digits to return an 18 decimal value.\r\n\r\n        return (((product * seriesSum) / ONE_20) * firstAN) / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Logarithm (log(arg, base), with signed 18 decimal fixed point base and argument.\r\n     */\r\n    function log(int256 arg, int256 base) internal pure returns (int256) {\r\n        // This performs a simple base change: log(arg, base) = ln(arg) / ln(base).\r\n\r\n        // Both logBase and logArg are computed as 36 decimal fixed point numbers, either by using ln_36, or by\r\n        // upscaling.\r\n\r\n        int256 logBase;\r\n        if (LN_36_LOWER_BOUND < base && base < LN_36_UPPER_BOUND) {\r\n            logBase = _ln_36(base);\r\n        } else {\r\n            logBase = _ln(base) * ONE_18;\r\n        }\r\n\r\n        int256 logArg;\r\n        if (LN_36_LOWER_BOUND < arg && arg < LN_36_UPPER_BOUND) {\r\n            logArg = _ln_36(arg);\r\n        } else {\r\n            logArg = _ln(arg) * ONE_18;\r\n        }\r\n\r\n        // When dividing, we multiply by ONE_18 to arrive at a result with 18 decimal places\r\n        return (logArg * ONE_18) / logBase;\r\n    }\r\n\r\n    /**\r\n     * @dev Natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\r\n     */\r\n    function ln(int256 a) internal pure returns (int256) {\r\n        // The real natural logarithm is not defined for negative numbers or zero.\r\n        _require(a > 0, Err.OUT_OF_BOUNDS);\r\n        if (LN_36_LOWER_BOUND < a && a < LN_36_UPPER_BOUND) {\r\n            return _ln_36(a) / ONE_18;\r\n        } else {\r\n            return _ln(a);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal natural logarithm (ln(a)) with signed 18 decimal fixed point argument.\r\n     */\r\n    function _ln(int256 a) private pure returns (int256) {\r\n        if (a < ONE_18) {\r\n            // Since ln(a^k) = k * ln(a), we can compute ln(a) as ln(a) = ln((1/a)^(-1)) = - ln((1/a)). If a is less\r\n            // than one, 1/a will be greater than one, and this if statement will not be entered in the recursive call.\r\n            // Fixed point division requires multiplying by ONE_18.\r\n            return (-_ln((ONE_18 * ONE_18) / a));\r\n        }\r\n\r\n        // First, we use the fact that ln^(a * b) = ln(a) + ln(b) to decompose ln(a) into a sum of powers of two, which\r\n        // we call x_n, where x_n == 2^(7 - n), which are the natural logarithm of precomputed quantities a_n (that is,\r\n        // ln(a_n) = x_n). We choose the first x_n, x0, to equal 2^7 because the exponential of all larger powers cannot\r\n        // be represented as 18 fixed point decimal numbers in 256 bits, and are therefore larger than a.\r\n        // At the end of this process we will have the sum of all x_n = ln(a_n) that apply, and the remainder of this\r\n        // decomposition, which will be lower than the smallest a_n.\r\n        // ln(a) = k_0 * x_0 + k_1 * x_1 + ... + k_n * x_n + ln(remainder), where each k_n equals either 0 or 1.\r\n        // We mutate a by subtracting a_n, making it the remainder of the decomposition.\r\n\r\n        // For reasons related to how `exp` works, the first two a_n (e^(2^7) and e^(2^6)) are not stored as fixed point\r\n        // numbers with 18 decimals, but instead as plain integers with 0 decimals, so we need to multiply them by\r\n        // ONE_18 to convert them to fixed point.\r\n        // For each a_n, we test if that term is present in the decomposition (if a is larger than it), and if so divide\r\n        // by it and compute the accumulated sum.\r\n\r\n        int256 sum = 0;\r\n        if (a >= a0 * ONE_18) {\r\n            a /= a0; // Integer, not fixed point division\r\n            sum += x0;\r\n        }\r\n\r\n        if (a >= a1 * ONE_18) {\r\n            a /= a1; // Integer, not fixed point division\r\n            sum += x1;\r\n        }\r\n\r\n        // All other a_n and x_n are stored as 20 digit fixed point numbers, so we convert the sum and a to this format.\r\n        sum *= 100;\r\n        a *= 100;\r\n\r\n        // Because further a_n are  20 digit fixed point numbers, we multiply by ONE_20 when dividing by them.\r\n\r\n        if (a >= a2) {\r\n            a = (a * ONE_20) / a2;\r\n            sum += x2;\r\n        }\r\n\r\n        if (a >= a3) {\r\n            a = (a * ONE_20) / a3;\r\n            sum += x3;\r\n        }\r\n\r\n        if (a >= a4) {\r\n            a = (a * ONE_20) / a4;\r\n            sum += x4;\r\n        }\r\n\r\n        if (a >= a5) {\r\n            a = (a * ONE_20) / a5;\r\n            sum += x5;\r\n        }\r\n\r\n        if (a >= a6) {\r\n            a = (a * ONE_20) / a6;\r\n            sum += x6;\r\n        }\r\n\r\n        if (a >= a7) {\r\n            a = (a * ONE_20) / a7;\r\n            sum += x7;\r\n        }\r\n\r\n        if (a >= a8) {\r\n            a = (a * ONE_20) / a8;\r\n            sum += x8;\r\n        }\r\n\r\n        if (a >= a9) {\r\n            a = (a * ONE_20) / a9;\r\n            sum += x9;\r\n        }\r\n\r\n        if (a >= a10) {\r\n            a = (a * ONE_20) / a10;\r\n            sum += x10;\r\n        }\r\n\r\n        if (a >= a11) {\r\n            a = (a * ONE_20) / a11;\r\n            sum += x11;\r\n        }\r\n\r\n        // a is now a small number (smaller than a_11, which roughly equals 1.06). This means we can use a Taylor series\r\n        // that converges rapidly for values of `a` close to one - the same one used in ln_36.\r\n        // Let z = (a - 1) / (a + 1).\r\n        // ln(a) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\r\n\r\n        // Recall that 20 digit fixed point division requires multiplying by ONE_20, and multiplication requires\r\n        // division by ONE_20.\r\n        int256 z = ((a - ONE_20) * ONE_20) / (a + ONE_20);\r\n        int256 z_squared = (z * z) / ONE_20;\r\n\r\n        // num is the numerator of the series: the z^(2 * n + 1) term\r\n        int256 num = z;\r\n\r\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\r\n        int256 seriesSum = num;\r\n\r\n        // In each step, the numerator is multiplied by z^2\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 3;\r\n\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 5;\r\n\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 7;\r\n\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 9;\r\n\r\n        num = (num * z_squared) / ONE_20;\r\n        seriesSum += num / 11;\r\n\r\n        // 6 Taylor terms are sufficient for 36 decimal precision.\r\n\r\n        // Finally, we multiply by 2 (non fixed point) to compute ln(remainder)\r\n        seriesSum *= 2;\r\n\r\n        // We now have the sum of all x_n present, and the Taylor approximation of the logarithm of the remainder (both\r\n        // with 20 decimals). All that remains is to sum these two, and then drop two digits to return a 18 decimal\r\n        // value.\r\n\r\n        return (sum + seriesSum) / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Intrnal high precision (36 decimal places) natural logarithm (ln(x)) with signed 18 decimal fixed point argument,\r\n     * for x close to one.\r\n     *\r\n     * Should only be used if x is between LN_36_LOWER_BOUND and LN_36_UPPER_BOUND.\r\n     */\r\n    function _ln_36(int256 x) private pure returns (int256) {\r\n        // Since ln(1) = 0, a value of x close to one will yield a very small result, which makes using 36 digits\r\n        // worthwhile.\r\n\r\n        // First, we transform x to a 36 digit fixed point value.\r\n        x *= ONE_18;\r\n\r\n        // We will use the following Taylor expansion, which converges very rapidly. Let z = (x - 1) / (x + 1).\r\n        // ln(x) = 2 * (z + z^3 / 3 + z^5 / 5 + z^7 / 7 + ... + z^(2 * n + 1) / (2 * n + 1))\r\n\r\n        // Recall that 36 digit fixed point division requires multiplying by ONE_36, and multiplication requires\r\n        // division by ONE_36.\r\n        int256 z = ((x - ONE_36) * ONE_36) / (x + ONE_36);\r\n        int256 z_squared = (z * z) / ONE_36;\r\n\r\n        // num is the numerator of the series: the z^(2 * n + 1) term\r\n        int256 num = z;\r\n\r\n        // seriesSum holds the accumulated sum of each term in the series, starting with the initial z\r\n        int256 seriesSum = num;\r\n\r\n        // In each step, the numerator is multiplied by z^2\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 3;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 5;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 7;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 9;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 11;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 13;\r\n\r\n        num = (num * z_squared) / ONE_36;\r\n        seriesSum += num / 15;\r\n\r\n        // 8 Taylor terms are sufficient for 36 decimal precision.\r\n\r\n        // All that remains is multiplying by 2 (non fixed point).\r\n        return seriesSum * 2;\r\n    }\r\n}\r\n\r\n// File: @chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\r\n\r\n\r\ninterface AggregatorV3Interface {\r\n\r\n  function decimals()\r\n    external\r\n    view\r\n    returns (\r\n      uint8\r\n    );\r\n\r\n  function description()\r\n    external\r\n    view\r\n    returns (\r\n      string memory\r\n    );\r\n\r\n  function version()\r\n    external\r\n    view\r\n    returns (\r\n      uint256\r\n    );\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(\r\n    uint80 _roundId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n}\r\n\r\n// File: contracts/structs/Struct.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\ncontract Struct {\r\n\r\n    struct TokenGlobal {\r\n        TokenRecord info;\r\n        LatestRound latestRound;\r\n    }\r\n\r\n    struct LatestRound {\r\n        address oracle;\r\n        uint80  roundId;\r\n        uint256 price;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    struct OracleState {\r\n        address oracle;\r\n        uint256 price;\r\n    }\r\n\r\n    struct HistoricalPricesParameters {\r\n        uint8   lookbackInRound;\r\n        uint256 lookbackInSec;\r\n        uint256 timestamp;\r\n        uint8   lookbackStepInRound;\r\n    }\r\n    \r\n    struct HistoricalPricesData {\r\n        uint256   startIndex;\r\n        uint256[] timestamps;\r\n        uint256[] prices;\r\n    }\r\n    \r\n    struct SwapResult {\r\n        uint256 amount;\r\n        uint256 spread;\r\n        uint256 taxBaseIn;\r\n    }\r\n\r\n    struct PriceResult {\r\n        uint256 spotPriceBefore;\r\n        uint256 spotPriceAfter;\r\n        uint256 priceIn;\r\n        uint256 priceOut;\r\n    }\r\n\r\n    struct GBMEstimation {\r\n        int256  mean;\r\n        uint256 variance;\r\n        bool    success;\r\n    }\r\n\r\n    struct TokenRecord {\r\n        uint8 decimals; // token decimals + oracle decimals\r\n        uint256 balance;\r\n        uint256 weight;\r\n    }\r\n\r\n    struct SwapParameters {\r\n        uint256 amount;\r\n        uint256 fee;\r\n        uint256 fallbackSpread;\r\n    }\r\n\r\n    struct JoinExitSwapParameters {\r\n        uint256 amount;\r\n        uint256 fee;\r\n        uint256 fallbackSpread;\r\n        uint256 poolSupply;\r\n    }\r\n\r\n    struct GBMParameters {\r\n        uint256 z;\r\n        uint256 horizon;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ChainlinkUtils.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlibrary ChainlinkUtils {\r\n\r\n    /**\r\n    * @notice Retrieves the oracle latest price, its decimals and description\r\n    * @dev We consider the token price to be > 0\r\n    * @param oracle The price feed oracle's address\r\n    * @return The latest price's value\r\n    * @return The latest price's number of decimals\r\n    * @return The oracle description\r\n    */\r\n    function getTokenLatestPrice(address oracle) internal view returns (uint256, uint8, string memory) {\r\n        AggregatorV3Interface feed = AggregatorV3Interface(oracle);\r\n        (, int256 latestPrice, , uint256 latestTimestamp,) = feed.latestRoundData();\r\n        // we assume that block.timestamp >= latestTimestamp, else => revert\r\n        _require(block.timestamp - latestTimestamp <= Const.ORACLE_TIMEOUT, Err.EXCEEDED_ORACLE_TIMEOUT);\r\n        _require(latestPrice > 0, Err.NON_POSITIVE_PRICE);\r\n        return (uint256(latestPrice), feed.decimals(), feed.description()); // we consider the token price to be > 0\r\n    }\r\n\r\n    function getLatestRound(address oracle) internal view returns (Struct.LatestRound memory) {\r\n        (\r\n            uint80 latestRoundId, int256 latestPrice, , uint256 latestTimestamp,\r\n        ) = AggregatorV3Interface(oracle).latestRoundData();\r\n        // we assume that block.timestamp >= latestTimestamp, else => revert\r\n        _require(block.timestamp - latestTimestamp <= Const.ORACLE_TIMEOUT, Err.EXCEEDED_ORACLE_TIMEOUT);\r\n        _require(latestPrice > 0, Err.NON_POSITIVE_PRICE);\r\n        return Struct.LatestRound(\r\n            oracle,\r\n            latestRoundId,\r\n            uint256(latestPrice),\r\n            latestTimestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Retrieves historical data from round id.\r\n    * @dev Special cases:\r\n    * - if retrieved price is negative --> fails\r\n    * - if no data can be found --> returns (0,0)\r\n    * @param oracle The price feed oracle\r\n    * @param _roundId The the round of interest ID\r\n    * @return The round price\r\n    * @return The round timestamp\r\n    */\r\n    function getRoundData(address oracle, uint80 _roundId) internal view returns (uint256, uint256) {\r\n        try AggregatorV3Interface(oracle).getRoundData(_roundId) returns (\r\n            uint80 ,\r\n            int256 _price,\r\n            uint256 ,\r\n            uint256 _timestamp,\r\n            uint80\r\n        ) {\r\n            _require(_price >= 0, Err.NEGATIVE_PRICE);\r\n            return (uint256(_price), _timestamp);\r\n        } catch {}\r\n        return (0, 0);\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Computes the price of token 2 in terms of token 1\r\n    * @param price_1 The latest price data for token 1\r\n    * @param decimals_1 The sum of the decimals of token 1 its oracle\r\n    * @param price_2 The latest price data for token 2\r\n    * @param decimals_2 The sum of the decimals of token 2 its oracle\r\n    * @return The last price of token 2 divded by the last price of token 1\r\n    */\r\n    function getTokenRelativePrice(\r\n        uint256 price_1, uint8 decimals_1,\r\n        uint256 price_2, uint8 decimals_2\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint256) {\r\n        // we consider tokens price to be > 0\r\n        if (decimals_1 > decimals_2) {\r\n            return Num.div(\r\n                Num.mul(price_2, (10**(decimals_1 - decimals_2))*Const.ONE),\r\n                price_1\r\n            );\r\n        } else if (decimals_1 < decimals_2) {\r\n            return Num.div(\r\n                Num.div(price_2, price_1),\r\n                (10**(decimals_2 - decimals_1))*Const.ONE\r\n            );\r\n        } else { // decimals_1 == decimals_2\r\n            return Num.div(price_2, price_1);\r\n         }\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the previous price of tokenIn in terms of tokenOut 's upper bound\r\n    * @param latestRound_1 The token_1's latest round\r\n    * @param decimals_1 The sum of the decimals of token 1 its oracle \r\n    * @param latestRound_2 The token_2's latest round\r\n    * @param decimals_2 The sum of the decimals of token 2 its oracle\r\n    * @return The ratio of token 2 and token 1 values if well defined, else 0\r\n    */\r\n    function getMaxRelativePriceInLastBlock(\r\n        Struct.LatestRound memory latestRound_1,\r\n        uint8 decimals_1,\r\n        Struct.LatestRound memory latestRound_2,\r\n        uint8 decimals_2\r\n    ) internal view returns (uint256) {\r\n        \r\n        uint256 minPrice_1 = latestRound_1.price;\r\n        {\r\n            uint256 timestamp_1  = latestRound_1.timestamp;\r\n            uint256 temp_price_1;\r\n            uint80  roundId_1    = latestRound_1.roundId;\r\n            address oracle_1     = latestRound_1.oracle;\r\n\r\n            while (timestamp_1 == block.timestamp) {\r\n                --roundId_1;\r\n                (temp_price_1, timestamp_1) = ChainlinkUtils.getRoundData(\r\n                    oracle_1, roundId_1\r\n                );\r\n                if (temp_price_1 == 0) {\r\n                    return 0;\r\n                }\r\n                if (temp_price_1 < minPrice_1) {\r\n                    minPrice_1 = temp_price_1;\r\n                }\r\n            }\r\n        }\r\n\r\n        uint maxPrice_2 = latestRound_2.price;\r\n        {\r\n            uint256 timestamp_2  = latestRound_2.timestamp;\r\n            uint256 temp_price_2;\r\n            uint80  roundId_2    = latestRound_2.roundId;\r\n            address oracle_2     = latestRound_2.oracle;\r\n\r\n            while (timestamp_2 == block.timestamp) {\r\n                --roundId_2;\r\n                (temp_price_2, timestamp_2) = ChainlinkUtils.getRoundData(\r\n                    oracle_2, roundId_2\r\n                );\r\n                if (temp_price_2 == 0) {\r\n                    return 0;\r\n                }\r\n                if (temp_price_2 > maxPrice_2) {\r\n                    maxPrice_2 = temp_price_2;\r\n                }\r\n            }\r\n        }\r\n\r\n        return getTokenRelativePrice(\r\n            minPrice_1, decimals_1,\r\n            maxPrice_2, decimals_2\r\n        );\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/GeometricBrownianMotionOracle.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title Library in charge of historical prices statistics computations\r\n* @author borelien\r\n* @notice This library implements a method to retrieve the mean/variance of a given pair of assets, from Chainlink data\r\n* @dev Because Chainlink data feeds' samplings are usually sparse and with varying time spacings, the estimation\r\n* of mean / variance objects are only approximations.\r\n*/\r\nlibrary GeometricBrownianMotionOracle {\r\n\r\n    /**\r\n    * @notice Gets asset-pair approximate historical return's mean and variance\r\n    * @param oracleIn The address of tokenIn's oracle\r\n    * @param oracleOut The address of tokenOut's oracle\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return gbmEstimation The asset-pair historical return's mean and variance\r\n    */\r\n    function getParametersEstimation(\r\n        address oracleIn,\r\n        address oracleOut,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n    external view returns (Struct.GBMEstimation memory gbmEstimation) {\r\n        Struct.LatestRound memory latestRoundIn = ChainlinkUtils.getLatestRound(oracleIn);\r\n        Struct.LatestRound memory latestRoundOut = ChainlinkUtils.getLatestRound(oracleOut);\r\n        return (\r\n            getParametersEstimation(\r\n                latestRoundIn,\r\n                latestRoundOut,\r\n                hpParameters\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Gets asset-pair approximate historical return's mean and variance\r\n    * @param latestRoundIn The round-to-start-from's data including its ID of tokenIn\r\n    * @param latestRoundOut The round-to-start-from's data including its ID of tokenOut\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return gbmEstimation The asset-pair historical return's mean and variance\r\n    */\r\n    function getParametersEstimation(\r\n        Struct.LatestRound memory latestRoundIn,\r\n        Struct.LatestRound memory latestRoundOut,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n    internal view returns (Struct.GBMEstimation memory gbmEstimation) {\r\n\r\n        // retrieve historical prices of tokenIn\r\n        (\r\n            uint256[] memory pricesIn, uint256[] memory timestampsIn, uint256 startIndexIn, bool noMoreDataPointIn\r\n        ) = getHistoricalPrices(\r\n            latestRoundIn, hpParameters\r\n        );\r\n        if (!noMoreDataPointIn && (startIndexIn < hpParameters.lookbackInRound - 1)) {\r\n            return Struct.GBMEstimation(0, 0, false);\r\n        }\r\n\r\n        uint256 reducedLookbackInSecCandidate = hpParameters.timestamp - timestampsIn[startIndexIn];\r\n        if (reducedLookbackInSecCandidate < hpParameters.lookbackInSec) {\r\n            hpParameters.lookbackInSec = reducedLookbackInSecCandidate;\r\n        }\r\n\r\n        // retrieve historical prices of tokenOut\r\n        (\r\n            uint256[] memory pricesOut, uint256[] memory timestampsOut, uint256 startIndexOut, bool noMoreDataPointOut\r\n        ) = getHistoricalPrices(\r\n            latestRoundOut, hpParameters\r\n        );\r\n        if (!noMoreDataPointOut && (startIndexOut < hpParameters.lookbackInRound - 1)) {\r\n            return Struct.GBMEstimation(0, 0, false);\r\n        }\r\n\r\n        return _getParametersEstimation(\r\n            noMoreDataPointIn && noMoreDataPointOut,\r\n            Struct.HistoricalPricesData(startIndexIn, timestampsIn, pricesIn),\r\n            Struct.HistoricalPricesData(startIndexOut, timestampsOut, pricesOut),\r\n            hpParameters\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Gets asset-pair historical data return's mean and variance\r\n    * @param noMoreDataPoints True if and only if the retrieved data span over the whole time window of interest\r\n    * @param hpDataIn Historical prices data of tokenIn\r\n    * @param hpDataOut Historical prices data of tokenOut\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return gbmEstimation The asset-pair historical return's mean and variance\r\n    */\r\n    function _getParametersEstimation(\r\n        bool noMoreDataPoints,\r\n        Struct.HistoricalPricesData memory hpDataIn,\r\n        Struct.HistoricalPricesData memory hpDataOut,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n    internal pure returns (Struct.GBMEstimation memory gbmEstimation) {\r\n\r\n        // no price return can be calculated with only 1 data point\r\n        if (hpDataIn.startIndex == 0 && hpDataOut.startIndex == 0) {\r\n            return gbmEstimation = Struct.GBMEstimation(0, 0, true);\r\n        }\r\n\r\n        if (noMoreDataPoints) {\r\n            uint256 ts = hpParameters.timestamp - hpParameters.lookbackInSec;\r\n            hpDataIn.timestamps[hpDataIn.startIndex] = ts;\r\n            hpDataOut.timestamps[hpDataOut.startIndex] = ts;\r\n        } else {\r\n            consolidateStartIndices(\r\n                hpDataIn,\r\n                hpDataOut\r\n            );\r\n            // no price return can be calculated with only 1 data point\r\n            if (hpDataIn.startIndex == 0 && hpDataOut.startIndex == 0) {\r\n                return gbmEstimation = Struct.GBMEstimation(0, 0, true);\r\n            }\r\n        }\r\n        (int256[] memory values, uint256[] memory timestamps) = getSeries(\r\n            hpDataIn.prices, hpDataIn.timestamps, hpDataIn.startIndex,\r\n            hpDataOut.prices, hpDataOut.timestamps, hpDataOut.startIndex\r\n        );\r\n        (int256 mean, uint256 variance) = getStatistics(values, timestamps);\r\n\r\n        return gbmEstimation = Struct.GBMEstimation(mean, variance, true);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Gets asset-pair historical prices with timestamps\r\n    * @param pricesIn The historical prices of tokenIn\r\n    * @param timestampsIn The timestamps corresponding to the tokenIn's historical prices\r\n    * @param startIndexIn The tokenIn historical data's last valid index\r\n    * @param pricesOut The tokenIn historical data's last valid index\r\n    * @param timestampsOut The timestamps corresponding to the tokenOut's historical prices\r\n    * @param startIndexOut The tokenOut historical data's last valid index\r\n    * @return values The asset-pair historical prices array\r\n    * @return timestamps The asset-pair historical timestamps array\r\n    */\r\n    function getSeries(\r\n        uint256[] memory pricesIn, uint256[] memory timestampsIn, uint256 startIndexIn,\r\n        uint256[] memory pricesOut, uint256[] memory timestampsOut, uint256 startIndexOut\r\n    ) internal pure returns (int256[] memory values, uint256[] memory timestamps) {\r\n\r\n        // compute the number of returns\r\n        uint256 count = 1;\r\n        {\r\n            uint256 _startIndexIn = startIndexIn;\r\n            uint256 _startIndexOut = startIndexOut;\r\n            bool skip = true;\r\n            while (_startIndexIn > 0 || _startIndexOut > 0) {\r\n                (skip, _startIndexIn, _startIndexOut) = getNextSample(\r\n                    _startIndexIn, _startIndexOut, timestampsIn, timestampsOut\r\n                );\r\n                if (!skip) {\r\n                    count += 1;\r\n                }\r\n            }\r\n            values = new int256[](count);\r\n            timestamps = new uint256[](count);\r\n            values[0] = int256(Num.div(pricesOut[startIndexOut], pricesIn[startIndexIn]));\r\n            timestamps[0] = Num.max(timestampsOut[startIndexOut], timestampsIn[startIndexIn]) * Const.ONE;\r\n        }\r\n\r\n        // compute actual returns\r\n        {\r\n            count = 1;\r\n            bool skip = true;\r\n            while (startIndexIn > 0 || startIndexOut > 0) {\r\n                (skip, startIndexIn, startIndexOut) = getNextSample(\r\n                    startIndexIn, startIndexOut, timestampsIn, timestampsOut\r\n                );\r\n                if (!skip) {\r\n                    values[count] = int256(Num.div(pricesOut[startIndexOut], pricesIn[startIndexIn]));\r\n                    timestamps[count] = Num.max(timestampsOut[startIndexOut], timestampsIn[startIndexIn]) * Const.ONE;\r\n                    count += 1;\r\n                }\r\n            }\r\n        }\r\n\r\n        return (values, timestamps);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Gets asset-pair historical mean/variance from timestamped data\r\n    * @param values The historical values\r\n    * @param timestamps The corresponding time deltas, in seconds\r\n    * @return mean The asset-pair historical return's mean\r\n    * @return variance asset-pair historical return's variance\r\n    */\r\n    function getStatistics(int256[] memory values, uint256[] memory timestamps)\r\n    internal pure returns (int256, uint256) {\r\n\r\n        uint256 n = values.length;\r\n        if (n < 2) {\r\n            return (0, 0);\r\n        }\r\n        n -= 1;\r\n\r\n        uint256 tWithPrecision = timestamps[n] - timestamps[0];\r\n\r\n        // mean\r\n        int256 mean = Num.divInt256(LogExpMath.ln(Num.divInt256(values[n], values[0])), int256(tWithPrecision));\r\n        uint256 meanSquare;\r\n        if (mean < 0) {\r\n            meanSquare = Num.mul(uint256(-mean), uint256(-mean));\r\n        } else {\r\n            meanSquare = Num.mul(uint256(mean), uint256(mean));\r\n        }\r\n        // variance\r\n        int256 variance = -int256(Num.mul(meanSquare, tWithPrecision));\r\n        for (uint256 i = 1; i <= n; i++) {\r\n            int256 d = LogExpMath.ln(Num.divInt256(values[i], values[i - 1]));\r\n            if (d < 0) {\r\n                d = -d;\r\n            }\r\n            uint256 dAbs = uint256(d);\r\n            variance += int256(Num.div(Num.mul(dAbs, dAbs), timestamps[i] - timestamps[i - 1]));\r\n        }\r\n        variance = Num.divInt256(variance, int256(n * Const.ONE));\r\n\r\n        return (mean, Num.positivePart(variance));\r\n    }\r\n\r\n    /**\r\n    * @notice Finds the next data point in chronological order\r\n    * @dev Few considerations:\r\n    * - data point with same timestamp as previous point are tagged with a 'skip=true'\r\n    * - when we reach the last point of a token, we consider it's value constant going forward with the other token\r\n    * As a result the variance of those returns will be underestimated.\r\n    * @param startIndexIn  The tokenIn historical data's last valid index\r\n    * @param startIndexOut The tokenOut historical data's last valid index\r\n    * @param timestampsIn  The timestamps corresponding to the tokenIn's historical prices\r\n    * @param timestampsOut The timestamps corresponding to the tokenOut's historical prices\r\n    * @return skip The 'skip' tag\r\n    * @return startIndexIn The updated startIndexIn\r\n    * @return startIndexOut The updated startIndexOut\r\n    */\r\n    function getNextSample(\r\n        uint256 startIndexIn, uint256 startIndexOut,\r\n        uint256[] memory timestampsIn, uint256[] memory timestampsOut\r\n    ) internal pure returns (bool, uint256, uint256) {\r\n        bool skip = true;\r\n        uint256 nextStartIndexIn = startIndexIn > 0 ? startIndexIn - 1 : startIndexIn;\r\n        uint256 nextStartIndexOut = startIndexOut > 0 ? startIndexOut - 1 : startIndexOut;\r\n        if (timestampsIn[nextStartIndexIn] == timestampsOut[nextStartIndexOut]) {\r\n            if (\r\n                (timestampsIn[nextStartIndexIn] != timestampsIn[startIndexIn])\r\n                && (timestampsOut[nextStartIndexOut] != timestampsOut[startIndexOut])\r\n            ) {\r\n                skip = false;\r\n            }\r\n            if (startIndexIn > 0) {\r\n                startIndexIn--;\r\n            }\r\n            if (startIndexOut > 0) {\r\n                startIndexOut--;\r\n            }\r\n        } else {\r\n            if (startIndexOut == 0) {\r\n                if (timestampsIn[nextStartIndexIn] != timestampsIn[startIndexIn]) {\r\n                    skip = false;\r\n                }\r\n                if (startIndexIn > 0) {\r\n                    startIndexIn--;\r\n                }\r\n            } else if (startIndexIn == 0) {\r\n                if (timestampsOut[nextStartIndexOut] != timestampsOut[startIndexOut]) {\r\n                    skip = false;\r\n                }\r\n                if (startIndexOut > 0) {\r\n                    startIndexOut--;\r\n                }\r\n            } else {\r\n                if (timestampsIn[nextStartIndexIn] < timestampsOut[nextStartIndexOut]) {\r\n                    if (timestampsIn[nextStartIndexIn] != timestampsIn[startIndexIn]) {\r\n                        skip = false;\r\n                    }\r\n                    if (startIndexIn > 0) {\r\n                        startIndexIn--;\r\n                    }\r\n                } else {\r\n                    if (timestampsOut[nextStartIndexOut] != timestampsOut[startIndexOut]) {\r\n                        skip = false;\r\n                    }\r\n                    if (startIndexOut > 0) {\r\n                        startIndexOut--;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return  (skip, startIndexIn, startIndexOut);\r\n    }\r\n\r\n    /**\r\n    * @notice Gets historical prices from a Chainlink data feed\r\n    * @dev Few specificities:\r\n    * - it filters out round data with null price or timestamp\r\n    * - it stops filling the prices/timestamps when:\r\n    * a) hpParameters.lookbackInRound rounds have already been found\r\n    * b) time window induced by hpParameters.lookbackInSec is no more satisfied\r\n    * @param latestRound The round-to-start-from's data including its ID\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return historicalPrices The historical prices of a token\r\n    * @return historicalTimestamps The timestamps of the reported prices\r\n    * @return index The last valid index of the returned arrays\r\n    * @return noMoreDataPoints True if the reported historical prices reaches the lookback time limit\r\n    */\r\n    function getHistoricalPrices(\r\n        Struct.LatestRound memory latestRound,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n    internal view returns (uint256[] memory, uint256[] memory, uint256, bool)\r\n    {\r\n        uint256 latestTimestamp = latestRound.timestamp;\r\n\r\n        // historical price endtimestamp >= lookback window or it reverts\r\n        uint256 timeLimit = hpParameters.timestamp - hpParameters.lookbackInSec;\r\n\r\n        // result variables\r\n        uint256[] memory prices = new uint256[](hpParameters.lookbackInRound);\r\n        uint256[] memory timestamps = new uint256[](hpParameters.lookbackInRound);\r\n        uint256 idx = 1;\r\n\r\n        {\r\n\r\n            prices[0] = latestRound.price; // is supposed to be well valid\r\n            timestamps[0] = latestTimestamp; // is supposed to be well valid\r\n\r\n            if (latestTimestamp < timeLimit) {\r\n                return (prices, timestamps, 0, true);\r\n            }\r\n\r\n            uint80 count = 1;\r\n\r\n            // buffer variables\r\n            uint80 _roundId = latestRound.roundId;\r\n\r\n            while ((_roundId >= hpParameters.lookbackStepInRound) && (count < hpParameters.lookbackInRound)) {\r\n\r\n                _roundId -= hpParameters.lookbackStepInRound;\r\n                (uint256 _price, uint256 _timestamp) = ChainlinkUtils.getRoundData(latestRound.oracle, _roundId);\r\n\r\n                if (_price > 0 && _timestamp > 0) {\r\n\r\n                    prices[idx] = _price;\r\n                    timestamps[idx] = _timestamp;\r\n                    idx += 1;\r\n\r\n                    if (_timestamp < timeLimit) {\r\n                        return (prices, timestamps, idx - 1, true);\r\n                    }\r\n\r\n                }\r\n\r\n                count += 1;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return (prices, timestamps, idx - 1, false);\r\n    }\r\n\r\n    /**\r\n    * @notice Consolidate the last valid indexes of tokenIn and tokenOut\r\n    * @param hpDataIn Historical prices data of tokenIn\r\n    * @param hpDataOut Historical prices data of tokenOut\r\n    */\r\n    function consolidateStartIndices(\r\n        Struct.HistoricalPricesData memory hpDataIn,\r\n        Struct.HistoricalPricesData memory hpDataOut\r\n    )\r\n    internal pure\r\n    {\r\n\r\n        // trim prices/timestamps by adjusting startIndexes\r\n        if (hpDataIn.timestamps[hpDataIn.startIndex] > hpDataOut.timestamps[hpDataOut.startIndex]) {\r\n            while (\r\n                (hpDataOut.startIndex > 0)\r\n                && (hpDataOut.timestamps[hpDataOut.startIndex - 1] <= hpDataIn.timestamps[hpDataIn.startIndex])\r\n            ) {\r\n                --hpDataOut.startIndex;\r\n            }\r\n        } else if (hpDataIn.timestamps[hpDataIn.startIndex] < hpDataOut.timestamps[hpDataOut.startIndex]) {\r\n            while (\r\n                (hpDataIn.startIndex > 0)\r\n                && (hpDataIn.timestamps[hpDataIn.startIndex - 1] <= hpDataOut.timestamps[hpDataOut.startIndex])\r\n            ) {\r\n                --hpDataIn.startIndex;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Math.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title Library in charge of the Swaap pricing computations\r\n* @dev few definitions\r\n* shortage of tokenOut is when (balanceIn * weightOut) / (balanceOut * weightIn) > oraclePriceOut / oraclePriceIn\r\n* abundance of tokenOut is when (balanceIn * weightOut) / (balanceOut * weightIn) < oraclePriceOut / oraclePriceIn\r\n* equilibrium is when (balanceIn * weightOut) / (balanceOut * weightIn) = oraclePriceOut / oraclePriceIn\r\n*/\r\nlibrary Math {\r\n\r\n    /**********************************************************************************************\r\n    // calcSpotPrice                                                                             //\r\n    // sP = spotPrice                                                                            //\r\n    // bI = tokenBalanceIn                      ( bI * w0 )                                      //\r\n    // bO = tokenBalanceOut         sP =  ------------------------                               //\r\n    // wI = tokenWeightIn                 ( bO * wI ) * ( 1 - sF )                               //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcSpotPrice(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 swapFee\r\n    )\r\n    external pure\r\n    returns (uint256 spotPrice)\r\n    {\r\n        uint256 numer = Num.mul(tokenBalanceIn, tokenWeightOut);\r\n        uint256 denom = Num.mul(Num.mul(tokenBalanceOut, tokenWeightIn), Const.ONE - swapFee);\r\n        return (spotPrice = Num.div(numer, denom));\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcOutGivenIn                                                                            //\r\n    // aO = tokenAmountOut                                                                       //\r\n    // bO = tokenBalanceOut                                                                      //\r\n    // bI = tokenBalanceIn              /      /            bI             \\    (wI / wO) \\      //\r\n    // aI = tokenAmountIn    aO = bO * |  1 - | --------------------------  | ^            |     //\r\n    // wI = tokenWeightIn               \\      \\ ( bI + ( aI * ( 1 - sF )) /              /      //\r\n    // wO = tokenWeightOut                                                                       //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcOutGivenIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    )\r\n    internal pure\r\n    returns (uint256 tokenAmountOut)\r\n    {\r\n        uint256 weightRatio = Num.div(tokenWeightIn, tokenWeightOut);\r\n        uint256 adjustedIn = Const.ONE - swapFee;\r\n        adjustedIn = Num.mul(tokenAmountIn, adjustedIn);\r\n        uint256 y = Num.div(tokenBalanceIn, tokenBalanceIn + adjustedIn);\r\n        uint256 foo = Num.pow(y, weightRatio);\r\n        uint256 bar = Const.ONE - foo;\r\n        tokenAmountOut = Num.mul(tokenBalanceOut, bar);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcInGivenOut                                                                            //\r\n    // aI = tokenAmountIn                                                                        //\r\n    // bO = tokenBalanceOut               /  /     bO      \\    (wO / wI)      \\                 //\r\n    // bI = tokenBalanceIn          bI * |  | ------------  | ^            - 1  |                //\r\n    // aO = tokenAmountOut    aI =        \\  \\ ( bO - aO ) /                   /                 //\r\n    // wI = tokenWeightIn           --------------------------------------------                 //\r\n    // wO = tokenWeightOut                          ( 1 - sF )                                   //\r\n    // sF = swapFee                                                                              //\r\n    **********************************************************************************************/\r\n    function calcInGivenOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 swapFee\r\n    )\r\n        internal pure\r\n        returns (uint256 tokenAmountIn)\r\n    {\r\n        uint256 weightRatio = Num.div(tokenWeightOut, tokenWeightIn);\r\n        uint256 diff = tokenBalanceOut - tokenAmountOut;\r\n        uint256 y = Num.div(tokenBalanceOut, diff);\r\n        uint256 foo = Num.pow(y, weightRatio);\r\n        foo = foo - Const.ONE;\r\n        tokenAmountIn = Const.ONE - swapFee;\r\n        tokenAmountIn = Num.div(Num.mul(tokenBalanceIn, foo), tokenAmountIn);\r\n        return tokenAmountIn;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcPoolOutGivenSingleIn                                                                  //\r\n    // pAo = poolAmountOut                                                                       //\r\n    // tAi = tokenAmountIn        //                                      \\    wI   \\            //\r\n    // wI = tokenWeightIn        //                                        \\  ----   \\           //\r\n    // tW = totalWeight          ||   tAi * ( tW - ( tW - wI ) * sF )      | ^ tW    |           //\r\n    // tBi = tokenBalanceIn pAo= ||  --------------------------------- + 1 |         | * pS - pS //\r\n    // pS = poolSupply            \\\\             tBi * tW                  /         /           //\r\n    // sF = swapFee                \\\\                                     /         /            //\r\n    **********************************************************************************************/\r\n    function calcPoolOutGivenSingleIn(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 tokenAmountIn,\r\n        uint256 swapFee\r\n    )\r\n        internal pure\r\n        returns (uint256 poolAmountOut)\r\n    {\r\n        // Charge the trading fee for the proportion of tokenAi\r\n        //  which is implicitly traded to the other pool tokens.\r\n        // That proportion is (1- weightTokenIn)\r\n        // tokenAiAfterFee = tAi * (1 - (1-weightTi) * poolFee);\r\n\r\n        uint256 innerNumer = Num.mul(\r\n            tokenAmountIn,\r\n            totalWeight -  Num.mul(\r\n                totalWeight - tokenWeightIn,\r\n                swapFee\r\n            )\r\n        );\r\n        uint256 innerDenom = Num.mul(tokenBalanceIn, totalWeight);\r\n\r\n        uint256 inner = Num.pow(Num.div(innerNumer, innerDenom) + Const.ONE, Num.div(tokenWeightIn, totalWeight));\r\n\r\n        return (poolAmountOut = Num.mul(inner, poolSupply) - poolSupply);\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the pool token out when joining with a single asset\r\n    * @param tokenGlobalIn The pool global information on tokenIn\r\n    * @param remainingTokens The pool global information on the remaining tokens\r\n    * @param joinswapParameters The joinswap's parameters (amount in, fee, fallback-spread and pool supply)\r\n    * @param gbmParameters The GBM forecast parameters (Z, horizon)\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return poolAmountOut The amount of pool tokens to be received\r\n    */\r\n    function calcPoolOutGivenSingleInMMM(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal[] memory remainingTokens,\r\n        Struct.JoinExitSwapParameters memory joinswapParameters,\r\n        Struct.GBMParameters memory gbmParameters,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n        external view\r\n        returns (uint256 poolAmountOut)\r\n    {\r\n\r\n        // to get the total adjusted weight, we assume all the tokens Out are in shortage\r\n        uint256 totalAdjustedWeight = getTotalWeightMMM(\r\n            true,\r\n            joinswapParameters.fallbackSpread,\r\n            tokenGlobalIn,\r\n            remainingTokens,\r\n            gbmParameters,\r\n            hpParameters\r\n        );\r\n\r\n        uint256 fee = joinswapParameters.fee;\r\n\r\n        bool blockHasPriceUpdate = block.timestamp == tokenGlobalIn.latestRound.timestamp;\r\n        {\r\n            uint8 i;\r\n            while ((!blockHasPriceUpdate) && (i < remainingTokens.length)) {\r\n                if (block.timestamp == remainingTokens[i].latestRound.timestamp) {\r\n                    blockHasPriceUpdate = true;\r\n                }\r\n                unchecked { ++i; }\r\n            }\r\n        }\r\n        if (blockHasPriceUpdate) {\r\n            uint256 poolValueInTokenIn = getPoolTotalValue(tokenGlobalIn, remainingTokens);\r\n            fee = Num.min(\r\n                Const.ONE,\r\n                fee + calcPoolOutGivenSingleInAdaptiveFees(\r\n                    poolValueInTokenIn,\r\n                    tokenGlobalIn.info.balance,\r\n                    Num.div(tokenGlobalIn.info.weight, totalAdjustedWeight),\r\n                    joinswapParameters.amount\r\n                )\r\n            );\r\n        }\r\n\r\n        poolAmountOut = calcPoolOutGivenSingleIn(\r\n            tokenGlobalIn.info.balance,\r\n            tokenGlobalIn.info.weight,\r\n            joinswapParameters.poolSupply,\r\n            totalAdjustedWeight,\r\n            joinswapParameters.amount,\r\n            fee\r\n        );\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**********************************************************************************************\r\n    // calcSingleOutGivenPoolIn                                                                  //\r\n    // tAo = tokenAmountOut            /      /                                          \\\\      //\r\n    // bO = tokenBalanceOut           /      // pS - (pAi * (1 - eF)) \\     /  tW  \\      \\\\     //\r\n    // pAi = poolAmountIn            | bO - || ----------------------- | ^ | ------ | * b0 ||    //\r\n    // ps = poolSupply                \\      \\\\          pS           /     \\  wO  /      //     //\r\n    // wI = tokenWeightIn      tAo =   \\      \\                                          //      //\r\n    // tW = totalWeight                    /     /      wO \\       \\                             //\r\n    // sF = swapFee                    *  | 1 - |  1 - ---- | * sF  |                            //\r\n    // eF = exitFee                        \\     \\      tW /       /                             //\r\n    **********************************************************************************************/\r\n    function calcSingleOutGivenPoolIn(\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenWeightOut,\r\n        uint256 poolSupply,\r\n        uint256 totalWeight,\r\n        uint256 poolAmountIn,\r\n        uint256 swapFee\r\n    )\r\n    internal pure\r\n    returns (uint256 tokenAmountOut)\r\n    {\r\n        // charge exit fee on the pool token side\r\n        // pAiAfterExitFee = pAi*(1-exitFee)\r\n        uint256 poolAmountInAfterExitFee = Num.mul(poolAmountIn, Const.ONE - Const.EXIT_FEE);\r\n        uint256 newPoolSupply = poolSupply - poolAmountInAfterExitFee;\r\n        uint256 poolRatio = Num.div(newPoolSupply, poolSupply);\r\n\r\n        // newBalTo = poolRatio^(1/weightTo) * balTo;\r\n        uint256 tokenOutRatio = Num.pow(poolRatio, Num.div(totalWeight, tokenWeightOut));\r\n        uint256 newTokenBalanceOut = Num.mul(tokenOutRatio, tokenBalanceOut);\r\n\r\n        uint256 tokenAmountOutBeforeSwapFee = tokenBalanceOut - newTokenBalanceOut;\r\n\r\n        // charge swap fee on the output token side\r\n        //uint256 tAo = tAoBeforeSwapFee * (1 - (1-weightTo) * swapFee)\r\n        uint256 zaz = Num.mul(Const.ONE - Num.div(tokenWeightOut, totalWeight), swapFee);\r\n        tokenAmountOut = Num.mul(tokenAmountOutBeforeSwapFee, Const.ONE - zaz);\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the token amount out to be received when exiting the pool with a single asset\r\n    * @param tokenGlobalOut The pool global information on tokenOut\r\n    * @param remainingTokens The pool global information on the remaining tokens\r\n    * @param exitswapParameters The exitswap's parameters (amount in, fee, fallback-spread and pool supply)\r\n    * @param gbmParameters The GBM forecast parameters (Z, horizon)\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return tokenAmountOut The amount of tokenOut to be received\r\n    */\r\n    function calcSingleOutGivenPoolInMMM(\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        Struct.TokenGlobal[] memory remainingTokens,\r\n        Struct.JoinExitSwapParameters memory exitswapParameters,\r\n        Struct.GBMParameters memory gbmParameters,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n    external view\r\n    returns (uint256 tokenAmountOut)\r\n    {\r\n        // to get the total adjusted weight, we assume all the remaining tokens are in shortage\r\n        uint256 totalAdjustedWeight = getTotalWeightMMM(\r\n            false,\r\n            exitswapParameters.fallbackSpread,\r\n            tokenGlobalOut,\r\n            remainingTokens,\r\n            gbmParameters,\r\n            hpParameters\r\n        );\r\n\r\n        uint256 fee = exitswapParameters.fee;\r\n\r\n        bool blockHasPriceUpdate = block.timestamp == tokenGlobalOut.latestRound.timestamp;\r\n        {\r\n            uint8 i;\r\n            while ((!blockHasPriceUpdate) && (i < remainingTokens.length)) {\r\n                if (block.timestamp == remainingTokens[i].latestRound.timestamp) {\r\n                    blockHasPriceUpdate = true;\r\n                }\r\n                unchecked { ++i; }\r\n            }\r\n        }\r\n        if (blockHasPriceUpdate) {\r\n            uint256 poolValueInTokenOut = getPoolTotalValue(tokenGlobalOut, remainingTokens);\r\n            fee = Num.min(\r\n                Const.ONE,\r\n                fee + calcSingleOutGivenPoolInAdaptiveFees(\r\n                    poolValueInTokenOut,\r\n                    tokenGlobalOut.info.balance,\r\n                    Num.div(tokenGlobalOut.info.weight, totalAdjustedWeight),\r\n                    Num.div(exitswapParameters.amount, exitswapParameters.poolSupply)\r\n                )\r\n            );\r\n        }\r\n\r\n        tokenAmountOut = calcSingleOutGivenPoolIn(\r\n            tokenGlobalOut.info.balance,\r\n            tokenGlobalOut.info.weight,\r\n            exitswapParameters.poolSupply,\r\n            totalAdjustedWeight,\r\n            exitswapParameters.amount,\r\n            fee\r\n        );\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the log spread factor\r\n    * @dev We define it as the log of the p-quantile of a GBM process (log-normal distribution),\r\n    * which is given by the following:\r\n    * mean * horizon + z * sqrt(2 * variance * horizon)\r\n    * where z = ierf(2p - 1), with ierf being the inverse error function.\r\n    * GBM: https://en.wikipedia.org/wiki/Geometric_Brownian_motion\r\n    * Log-normal distribution: https://en.wikipedia.org/wiki/Log-normal_distribution\r\n    * erf: https://en.wikipedia.org/wiki/Error_function\r\n    * @param mean The percentage drift\r\n    * @param variance The percentage volatility\r\n    * @param horizon The GBM forecast horizon parameter\r\n    * @param z The GBM forecast z parameter\r\n    * @return x The log spread factor\r\n    */\r\n    function getLogSpreadFactor(\r\n        int256 mean, uint256 variance,\r\n        uint256 horizon, uint256 z\r\n    )\r\n    internal pure\r\n    returns (int256 x)\r\n    {\r\n        if (mean == 0 && variance == 0) {\r\n            return 0;\r\n        }\r\n        if (mean < 0) {\r\n            mean = -int256(Num.mul(uint256(-mean), horizon));\r\n        } else {\r\n            mean = int256(Num.mul(uint256(mean), horizon));\r\n        }\r\n        uint256 diffusion;\r\n        if (variance > 0) {\r\n            diffusion = Num.mul(\r\n                z,\r\n                LogExpMath.pow(\r\n                    Num.mul(variance, 2 * horizon),\r\n                    Const.ONE / 2\r\n                )\r\n            );\r\n        }\r\n        return (x = int256(diffusion) + mean);\r\n    }\r\n\r\n    /**\r\n    * @notice Apply to the tokenWeight a 'spread' factor\r\n    * @dev The spread factor is defined as the maximum between:\r\n    a) the expected relative tokenOut increase in tokenIn terms\r\n    b) 1\r\n    * The function multiplies the tokenWeight by the spread factor if\r\n    * the token is in shortage, or divides it by the spread factor if it is in abundance\r\n    * @param shortage true when the token is in shortage, false if in abundance\r\n    * @param fallbackSpread The default spread in case the it couldn't be calculated using oracle prices\r\n    * @param tokenWeight The token's weight\r\n    * @param gbmEstimation The GBM's 2 first moments estimation\r\n    * @param gbmParameters The GBM forecast parameters (Z, horizon)\r\n    * @return adjustedWeight The adjusted weight based on spread\r\n    * @return spread The spread\r\n    */\r\n    function getMMMWeight(\r\n        bool shortage,\r\n        uint256 fallbackSpread,\r\n        uint256 tokenWeight,\r\n        Struct.GBMEstimation memory gbmEstimation,\r\n        Struct.GBMParameters memory gbmParameters\r\n    )\r\n    internal pure\r\n    returns (uint256 adjustedWeight, uint256 spread)\r\n    {\r\n\r\n        if (!gbmEstimation.success) {\r\n            if (shortage) {\r\n                return (Num.mul(tokenWeight, Const.ONE + fallbackSpread), fallbackSpread);\r\n            } else {\r\n                return (Num.div(tokenWeight, Const.ONE + fallbackSpread), fallbackSpread);\r\n            }\r\n        }\r\n\r\n        if (gbmParameters.horizon == 0) {\r\n            return (tokenWeight, 0);\r\n        }\r\n\r\n        int256 logSpreadFactor = getLogSpreadFactor(\r\n            gbmEstimation.mean, gbmEstimation.variance,\r\n            gbmParameters.horizon, gbmParameters.z\r\n        );\r\n        if (logSpreadFactor <= 0) {\r\n            return (tokenWeight, 0);\r\n        }\r\n        uint256 spreadFactor = uint256(LogExpMath.exp(logSpreadFactor));\r\n        // if spread < 1 --> rounding error --> set to 1\r\n        if (spreadFactor <= Const.ONE) {\r\n            return (tokenWeight, 0);\r\n        }\r\n\r\n        spread = spreadFactor - Const.ONE;\r\n\r\n        if (shortage) {\r\n            return (Num.mul(tokenWeight, spreadFactor), spread);\r\n        } else {\r\n            return (Num.div(tokenWeight, spreadFactor), spread);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Adjusts every token's weight (except from the pivotToken) with a spread factor and computes the sum\r\n    * @dev The initial weights of the tokens are the ones adjusted by their price performance only\r\n    * @param pivotTokenIsInput True if and only if pivotToken should be considered as an input token\r\n    * @param fallbackSpread The default spread in case the it couldn't be calculated using oracle prices\r\n    * @param pivotToken The pivot token's global information (token records + latest round info)\r\n    * @param otherTokens Other pool's tokens' global information (token records + latest rounds info)\r\n    * @param gbmParameters The GBM forecast parameters (Z, horizon)\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return totalAdjustedWeight The total adjusted weight\r\n    */\r\n    function getTotalWeightMMM(\r\n        bool pivotTokenIsInput,\r\n        uint256 fallbackSpread,\r\n        Struct.TokenGlobal memory pivotToken,\r\n        Struct.TokenGlobal[] memory otherTokens,\r\n        Struct.GBMParameters memory gbmParameters,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n    internal view\r\n    returns (uint256 totalAdjustedWeight)\r\n    {\r\n\r\n        bool noMoreDataPointPivot;\r\n        Struct.HistoricalPricesData memory hpDataPivot;\r\n\r\n        {\r\n            uint256[] memory pricesPivot;\r\n            uint256[] memory timestampsPivot;\r\n            uint256 startIndexPivot;\r\n            // retrieve historical prices of tokenIn\r\n            (pricesPivot,\r\n            timestampsPivot,\r\n            startIndexPivot,\r\n            noMoreDataPointPivot) = GeometricBrownianMotionOracle.getHistoricalPrices(\r\n                pivotToken.latestRound,\r\n                hpParameters\r\n            );\r\n\r\n            hpDataPivot = Struct.HistoricalPricesData(startIndexPivot, timestampsPivot, pricesPivot);\r\n\r\n            // reducing lookback time window\r\n            uint256 reducedLookbackInSecCandidate = hpParameters.timestamp - timestampsPivot[startIndexPivot];\r\n            if (reducedLookbackInSecCandidate < hpParameters.lookbackInSec) {\r\n                hpParameters.lookbackInSec = reducedLookbackInSecCandidate;\r\n            }\r\n        }\r\n\r\n        // to get the total adjusted weight, we apply a spread factor on every weight except from the pivotToken's one.\r\n        totalAdjustedWeight = pivotToken.info.weight;\r\n        for (uint256 i; i < otherTokens.length;) {\r\n\r\n            (uint256[] memory pricesOthers,\r\n            uint256[] memory timestampsOthers,\r\n            uint256 startIndexOthers,\r\n            bool noMoreDataPointOthers) = GeometricBrownianMotionOracle.getHistoricalPrices(\r\n                otherTokens[i].latestRound,\r\n                hpParameters\r\n            );\r\n\r\n            Struct.GBMEstimation memory gbmEstimation;\r\n            if (pivotTokenIsInput) {\r\n                // weight is increased\r\n                gbmEstimation = GeometricBrownianMotionOracle._getParametersEstimation(\r\n                    noMoreDataPointPivot && noMoreDataPointOthers,\r\n                    hpDataPivot,\r\n                    Struct.HistoricalPricesData(startIndexOthers, timestampsOthers, pricesOthers),\r\n                    hpParameters\r\n                );\r\n            } else {\r\n                // weight is reduced\r\n                gbmEstimation = GeometricBrownianMotionOracle._getParametersEstimation(\r\n                    noMoreDataPointPivot && noMoreDataPointOthers,\r\n                    Struct.HistoricalPricesData(startIndexOthers, timestampsOthers, pricesOthers),\r\n                    hpDataPivot,\r\n                    hpParameters\r\n                );\r\n            }\r\n\r\n            (otherTokens[i].info.weight, ) = getMMMWeight(\r\n                pivotTokenIsInput,\r\n                fallbackSpread,\r\n                otherTokens[i].info.weight,\r\n                gbmEstimation,\r\n                gbmParameters\r\n            );\r\n\r\n            totalAdjustedWeight += otherTokens[i].info.weight;\r\n            unchecked {++i;}\r\n        }\r\n\r\n        return totalAdjustedWeight;\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the net value of a given tokenIn amount in tokenOut terms\r\n    * @dev A spread is applied as soon as entering a \"shortage of tokenOut\" phase\r\n    * cf whitepaper: https://www.swaap.finance/whitepaper.pdf\r\n    * @param tokenGlobalIn The pool global information on tokenIn\r\n    * @param tokenGlobalOut The pool global information on tokenOut\r\n    * @param relativePrice The price of tokenOut in tokenIn terms\r\n    * @param swapParameters Amount of token in and swap fee\r\n    * @param gbmParameters The GBM forecast parameters (Z, horizon)\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return swapResult The swap result (amount out, spread and tax base in)\r\n    */\r\n    function calcOutGivenInMMM(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        uint256 relativePrice,\r\n        Struct.SwapParameters memory swapParameters,\r\n        Struct.GBMParameters memory gbmParameters,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n    external view\r\n    returns (Struct.SwapResult memory swapResult)\r\n    {\r\n\r\n        // determines the balance of tokenIn at equilibrium (cf definitions)\r\n        uint256 balanceInAtEquilibrium = getTokenBalanceAtEquilibrium(\r\n            tokenGlobalIn.info.balance,\r\n            tokenGlobalIn.info.weight,\r\n            tokenGlobalOut.info.balance,\r\n            tokenGlobalOut.info.weight,\r\n            relativePrice\r\n        );\r\n\r\n        // from abundance of tokenOut to abundance of tokenOut --> no spread\r\n        {\r\n            if (\r\n                (tokenGlobalIn.info.balance < balanceInAtEquilibrium)\r\n                && (swapParameters.amount < balanceInAtEquilibrium - tokenGlobalIn.info.balance)\r\n            ) {\r\n                return Struct.SwapResult(\r\n                    _calcOutGivenInMMMAbundance(\r\n                        tokenGlobalIn, tokenGlobalOut,\r\n                        relativePrice,\r\n                        swapParameters.amount,\r\n                        swapParameters.fee,\r\n                        swapParameters.fallbackSpread\r\n                    ),\r\n                    0,\r\n                    0\r\n                );\r\n            }\r\n        }\r\n\r\n        {\r\n            Struct.GBMEstimation memory gbmEstimation = GeometricBrownianMotionOracle.getParametersEstimation(\r\n                tokenGlobalIn.latestRound, tokenGlobalOut.latestRound,\r\n                hpParameters\r\n            );\r\n\r\n            (uint256 adjustedTokenOutWeight, uint256 spread) = getMMMWeight(\r\n                true,\r\n                swapParameters.fallbackSpread,\r\n                tokenGlobalOut.info.weight,\r\n                gbmEstimation, gbmParameters\r\n            );\r\n\r\n            if (tokenGlobalIn.info.balance >= balanceInAtEquilibrium) {\r\n                // shortage to shortage\r\n                return (\r\n                    Struct.SwapResult(\r\n                        calcOutGivenIn(\r\n                            tokenGlobalIn.info.balance,\r\n                            tokenGlobalIn.info.weight,\r\n                            tokenGlobalOut.info.balance,\r\n                            adjustedTokenOutWeight,\r\n                            swapParameters.amount,\r\n                            swapParameters.fee\r\n                        ),\r\n                        spread,\r\n                        swapParameters.amount\r\n                    )\r\n                );\r\n            }\r\n            else {\r\n                // abundance to shortage\r\n                (uint256 amount, uint256 taxBaseIn) = _calcOutGivenInMMMMixed(\r\n                    tokenGlobalIn,\r\n                    tokenGlobalOut,\r\n                    swapParameters,\r\n                    relativePrice,\r\n                    adjustedTokenOutWeight,\r\n                    balanceInAtEquilibrium\r\n                );\r\n                return (\r\n                    Struct.SwapResult(\r\n                        amount,\r\n                        spread,\r\n                        taxBaseIn\r\n                    )\r\n                );\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Implements calcOutGivenInMMM in the case of abundance of tokenOut\r\n    * @dev A spread is applied as soon as entering a \"shortage of tokenOut\" phase\r\n    * cf whitepaper: https://www.swaap.finance/whitepaper.pdf\r\n    * @param tokenGlobalIn The pool global information on tokenIn\r\n    * @param tokenGlobalOut The pool global information on tokenOut\r\n    * @param relativePrice The price of tokenOut in tokenIn terms\r\n    * @param tokenAmountIn The amount of tokenIn that will be swaped\r\n    * @param baseFee The base fee\r\n    * @param fallbackSpread The default spread in case the it couldn't be calculated using oracle prices\r\n    * @return tokenAmountOut The tokenAmountOut when the tokenOut is in abundance\r\n    */\r\n    function _calcOutGivenInMMMAbundance(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        uint256 relativePrice,\r\n        uint256 tokenAmountIn,\r\n        uint256 baseFee,\r\n        uint256 fallbackSpread\r\n    ) internal view returns (uint256) {\r\n        uint256 adaptiveFees = getAdaptiveFees(\r\n            tokenGlobalIn,\r\n            tokenAmountIn,\r\n            tokenGlobalOut,\r\n            Num.div(tokenAmountIn, relativePrice),\r\n            relativePrice,\r\n            baseFee,\r\n            fallbackSpread\r\n        );\r\n        return (\r\n            calcOutGivenIn(\r\n                tokenGlobalIn.info.balance,\r\n                tokenGlobalIn.info.weight,\r\n                tokenGlobalOut.info.balance,\r\n                tokenGlobalOut.info.weight,\r\n                tokenAmountIn,\r\n                adaptiveFees\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Implements 'calcOutGivenInMMM' in the case of mixed regime of tokenOut (abundance then shortage)\r\n    * @param tokenGlobalIn The pool global information on tokenIn\r\n    * @param tokenGlobalOut The pool global information on tokenOut\r\n    * @param swapParameters The parameters of the swap\r\n    * @param relativePrice The price of tokenOut in tokenIn terms\r\n    * @param adjustedTokenWeightOut The spread-augmented tokenOut's weight\r\n    * @param balanceInAtEquilibrium TokenIn balance at equilibrium\r\n    * @return tokenAmountOut The total amount of token out\r\n    * @return taxBaseIn The amount of tokenIn swapped when in shortage of tokenOut\r\n    */\r\n    function _calcOutGivenInMMMMixed(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        Struct.SwapParameters memory swapParameters,\r\n        uint256 relativePrice,\r\n        uint256 adjustedTokenWeightOut,\r\n        uint256 balanceInAtEquilibrium\r\n    )\r\n    internal view\r\n    returns (uint256, uint256)\r\n    {\r\n\r\n        uint256 tokenInSellAmountForEquilibrium = balanceInAtEquilibrium - tokenGlobalIn.info.balance;\r\n        uint256 taxBaseIn = swapParameters.amount - tokenInSellAmountForEquilibrium;\r\n\r\n        // 'abundance of tokenOut' phase --> no spread\r\n        uint256 tokenAmountOutPart1 = _calcOutGivenInMMMAbundance(\r\n            tokenGlobalIn,\r\n            tokenGlobalOut,\r\n            relativePrice,\r\n            tokenInSellAmountForEquilibrium,\r\n            swapParameters.fee,\r\n            swapParameters.fallbackSpread\r\n        );\r\n\r\n        // 'shortage of tokenOut phase' --> apply spread\r\n        uint256 tokenAmountOutPart2 = calcOutGivenIn(\r\n            tokenGlobalIn.info.balance + tokenInSellAmountForEquilibrium,\r\n            tokenGlobalIn.info.weight,\r\n            tokenGlobalOut.info.balance - tokenAmountOutPart1,\r\n            adjustedTokenWeightOut,\r\n            taxBaseIn, // tokenAmountIn > tokenInSellAmountForEquilibrium\r\n            swapParameters.fee\r\n        );\r\n\r\n        return (tokenAmountOutPart1 + tokenAmountOutPart2, taxBaseIn);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the amount of tokenIn needed in order to receive a given amount of tokenOut\r\n    * @dev A spread is applied as soon as entering a \"shortage of tokenOut\" phase\r\n    * cf whitepaper: https://www.swaap.finance/whitepaper.pdf\r\n    * @param tokenGlobalIn The pool global information on tokenIn\r\n    * @param tokenGlobalOut The pool global information on tokenOut\r\n    * @param relativePrice The price of tokenOut in tokenIn terms\r\n    * @param swapParameters Amount of token out and swap fee\r\n    * @param gbmParameters The GBM forecast parameters (Z, horizon)\r\n    * @param hpParameters The parameters for historical prices retrieval\r\n    * @return swapResult The swap result (amount in, spread and tax base in)\r\n    */\r\n    function calcInGivenOutMMM(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        uint256 relativePrice,\r\n        Struct.SwapParameters memory swapParameters,\r\n        Struct.GBMParameters memory gbmParameters,\r\n        Struct.HistoricalPricesParameters memory hpParameters\r\n    )\r\n    external view\r\n    returns (Struct.SwapResult memory)\r\n    {\r\n\r\n        // determines the balance of tokenOut at equilibrium (cf definitions)\r\n        uint256 balanceOutAtEquilibrium = getTokenBalanceAtEquilibrium(\r\n            tokenGlobalOut.info.balance,\r\n            tokenGlobalOut.info.weight,\r\n            tokenGlobalIn.info.balance,\r\n            tokenGlobalIn.info.weight,\r\n            Num.div(Const.ONE, relativePrice)\r\n        );\r\n\r\n        // from abundance of tokenOut to abundance of tokenOut --> no spread\r\n        if (\r\n            (tokenGlobalOut.info.balance > balanceOutAtEquilibrium)\r\n            && (swapParameters.amount < tokenGlobalOut.info.balance - balanceOutAtEquilibrium)\r\n        ) {\r\n            return (\r\n                Struct.SwapResult(\r\n                    _calcInGivenOutMMMAbundance(\r\n                        tokenGlobalIn, tokenGlobalOut,\r\n                        relativePrice,\r\n                        swapParameters.amount,\r\n                        swapParameters.fee,\r\n                        swapParameters.fallbackSpread\r\n                    ),\r\n                    0,\r\n                    0\r\n                )\r\n            );\r\n        }\r\n\r\n        {\r\n            Struct.GBMEstimation memory gbmEstimation = GeometricBrownianMotionOracle.getParametersEstimation(\r\n                tokenGlobalIn.latestRound, tokenGlobalOut.latestRound,\r\n                hpParameters\r\n            );\r\n\r\n            (uint256 adjustedTokenOutWeight, uint256 spread) = getMMMWeight(\r\n                true,\r\n                swapParameters.fallbackSpread,\r\n                tokenGlobalOut.info.weight,\r\n                gbmEstimation, gbmParameters\r\n            );\r\n\r\n            if (tokenGlobalOut.info.balance <= balanceOutAtEquilibrium) {\r\n                // shortage to shortage\r\n                return (\r\n                    Struct.SwapResult(\r\n                        calcInGivenOut(\r\n                            tokenGlobalIn.info.balance,\r\n                            tokenGlobalIn.info.weight,\r\n                            tokenGlobalOut.info.balance,\r\n                            adjustedTokenOutWeight,\r\n                            swapParameters.amount,\r\n                            swapParameters.fee\r\n                        ),\r\n                        spread,\r\n                        swapParameters.amount\r\n                    )\r\n                );\r\n            }\r\n            else {\r\n                // abundance to shortage\r\n                (uint256 amount, uint256 taxBaseIn) = _calcInGivenOutMMMMixed(\r\n                    tokenGlobalIn,\r\n                    tokenGlobalOut,\r\n                    swapParameters,\r\n                    relativePrice,\r\n                    adjustedTokenOutWeight,\r\n                    balanceOutAtEquilibrium\r\n                );\r\n                return (\r\n                    Struct.SwapResult(\r\n                        amount,\r\n                        spread,\r\n                        taxBaseIn\r\n                    )\r\n                );\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Implements calcOutGivenInMMM in the case of abundance of tokenOut\r\n    * @dev A spread is applied as soon as entering a \"shortage of tokenOut\" phase\r\n    * cf whitepaper: https://www.swaap.finance/whitepaper.pdf\r\n    * @param tokenGlobalIn The pool global information on tokenIn\r\n    * @param tokenGlobalOut The pool global information on tokenOut\r\n    * @param relativePrice The price of tokenOut in tokenIn terms\r\n    * @param tokenAmountOut The amount of tokenOut that will be received\r\n    * @param baseFee The base fee\r\n    * @param fallbackSpread The default spread in case the it couldn't be calculated using oracle prices\r\n    * @return tokenAmountIn The amount of tokenIn needed for the swap\r\n    */\r\n    function _calcInGivenOutMMMAbundance(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        uint256 relativePrice,\r\n        uint256 tokenAmountOut,\r\n        uint256 baseFee,\r\n        uint256 fallbackSpread\r\n    ) internal view returns (uint256) {\r\n        uint256 adaptiveFees = getAdaptiveFees(\r\n            tokenGlobalIn,\r\n            Num.mul(tokenAmountOut, relativePrice),\r\n            tokenGlobalOut,\r\n            tokenAmountOut,\r\n            relativePrice,\r\n            baseFee,\r\n            fallbackSpread\r\n        );\r\n        return (\r\n            calcInGivenOut(\r\n                tokenGlobalIn.info.balance,\r\n                tokenGlobalIn.info.weight,\r\n                tokenGlobalOut.info.balance,\r\n                tokenGlobalOut.info.weight,\r\n                tokenAmountOut,\r\n                adaptiveFees\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Implements 'calcInGivenOutMMM' in the case of abundance of tokenOut\r\n    * @dev Two cases to consider:\r\n    * 1) amount of tokenIn won't drive the pool from abundance of tokenOut to shortage ==> 1 pricing (no spread)\r\n    * 2) amount of tokenIn will drive the pool from abundance of tokenOut to shortage ==> 2 pricing, one for each phase\r\n    * @param tokenGlobalIn The pool global information on tokenIn\r\n    * @param tokenGlobalOut The pool global information on tokenOut\r\n    * @param swapParameters The parameters of the swap\r\n    * @param relativePrice The price of tokenOut in tokenIn terms\r\n    * @param adjustedTokenWeightOut The spread-augmented tokenOut's weight\r\n    * @return tokenAmountIn The total amount of tokenIn needed for the swap\r\n    * @return taxBaseIn The amount of tokenIn swapped when in shortage of tokenOut\r\n    */\r\n    function _calcInGivenOutMMMMixed(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        Struct.SwapParameters memory swapParameters,\r\n        uint256 relativePrice,\r\n        uint256 adjustedTokenWeightOut,\r\n        uint256 balanceOutAtEquilibrium\r\n    )\r\n    internal view\r\n    returns (uint256, uint256)\r\n    {\r\n        \r\n        uint256 tokenOutBuyAmountForEquilibrium =  tokenGlobalOut.info.balance - balanceOutAtEquilibrium;\r\n\r\n        // 'abundance of tokenOut' phase --> no spread\r\n        uint256 tokenAmountInPart1 = _calcInGivenOutMMMAbundance(\r\n            tokenGlobalIn,\r\n            tokenGlobalOut,\r\n            relativePrice,\r\n            tokenOutBuyAmountForEquilibrium,\r\n            swapParameters.fee,\r\n            swapParameters.fallbackSpread\r\n        );\r\n\r\n        // 'shortage of tokenOut phase' --> apply spread\r\n        uint256 tokenAmountInPart2 = calcInGivenOut(\r\n            tokenGlobalIn.info.balance + tokenAmountInPart1,\r\n            tokenGlobalIn.info.weight,\r\n            tokenGlobalOut.info.balance - tokenOutBuyAmountForEquilibrium,\r\n            adjustedTokenWeightOut,\r\n            swapParameters.amount - tokenOutBuyAmountForEquilibrium, // tokenAmountOut > tokenOutBuyAmountForEquilibrium\r\n            swapParameters.fee\r\n        );\r\n\r\n        return (tokenAmountInPart1 + tokenAmountInPart2, tokenAmountInPart2);\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the balance of token1 the pool must have in order to have token1/token2 at equilibrium\r\n    * while satisfying the pricing curve prod^k balance_k^w_k = K\r\n    * @dev We only rely on the following equations:\r\n    * a) priceTokenOutOutInTokenIn = balance_in / balance_out * w_out / w_in\r\n    * b) tokenBalanceOut = (K / prod_k!=in balance_k^w_k)^(1/w_out) = (localInvariant / balance_in^w_in)^(1/w_out)\r\n    * with localInvariant = balance_in^w_in * balance_out^w_out which can be computed with only In/Out\r\n    * @param tokenBalance1 The balance of token1 initially\r\n    * @param tokenWeight1 The weight of token1\r\n    * @param tokenBalance2 The balance of token2 initially\r\n    * @param tokenWeight2 The weight of token2\r\n    * @param relativePrice The price of tokenOut in tokenIn terms\r\n    * @return balance1AtEquilibrium The balance of token1 in order to have a token1/token2 at equilibrium\r\n    */\r\n    function getTokenBalanceAtEquilibrium( \r\n        uint256 tokenBalance1,\r\n        uint256 tokenWeight1,\r\n        uint256 tokenBalance2,\r\n        uint256 tokenWeight2,\r\n        uint256 relativePrice\r\n    )\r\n    internal pure\r\n    returns (uint256 balance1AtEquilibrium)\r\n    {\r\n        {\r\n            uint256 weightSum = tokenWeight1 + tokenWeight2;\r\n            // relativePrice * weight1/weight2\r\n            uint256 foo = Num.mul(relativePrice, Num.div(tokenWeight1, tokenWeight2));\r\n            // relativePrice * balance2 * (weight1/weight2)\r\n            foo = Num.mul(foo, tokenBalance2);\r\n            \r\n            balance1AtEquilibrium = Num.mul(\r\n                LogExpMath.pow(\r\n                    foo,\r\n                    Num.div(tokenWeight2, weightSum)\r\n                ),\r\n                LogExpMath.pow(\r\n                    tokenBalance1,\r\n                    Num.div(tokenWeight1, weightSum)\r\n                )\r\n            );\r\n        }\r\n        return balance1AtEquilibrium;\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the fee needed to maintain the pool's value constant\r\n    * @dev We use oracle to evaluate pool's value\r\n    * @param tokenBalanceIn The balance of tokenIn initially\r\n    * @param tokenAmountIn The amount of tokenIn to be added\r\n    * @param tokenWeightIn The weight of tokenIn\r\n    * @param tokenBalanceOut The balance of tokenOut initially\r\n    * @param tokenAmountOut The amount of tokenOut to be removed from the pool\r\n    * @param tokenWeightOut The weight of tokenOut\r\n    * @return adaptiveFee The computed adaptive fee to be added to the base fees\r\n    */\r\n    function calcAdaptiveFeeGivenInAndOut(\r\n        uint256 tokenBalanceIn,\r\n        uint256 tokenAmountIn,\r\n        uint256 tokenWeightIn,\r\n        uint256 tokenBalanceOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 tokenWeightOut\r\n    )\r\n    internal pure\r\n    returns (uint256)\r\n    {\r\n        uint256 weightRatio = Num.div(tokenWeightOut, tokenWeightIn);\r\n        uint256 y = Num.div(tokenBalanceOut, tokenBalanceOut - tokenAmountOut);\r\n        uint256 foo = Num.mul(tokenBalanceIn, Num.pow(y, weightRatio));\r\n\r\n        uint256 afterSwapTokenInBalance = tokenBalanceIn + tokenAmountIn;\r\n\r\n        if (foo > afterSwapTokenInBalance) {\r\n            return 0;\r\n        }\r\n        return (\r\n            Num.div(\r\n                afterSwapTokenInBalance - foo,\r\n                tokenAmountIn\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the fee amount that will ensure we maintain the pool's value, according to oracle prices.\r\n    * @dev We apply this fee regime only if Out-In price increased in the same block as now.\r\n    * @param tokenGlobalIn The pool global information on tokenIn\r\n    * @param tokenAmountIn The swap desired amount for tokenIn\r\n    * @param tokenGlobalOut The pool global information on tokenOut\r\n    * @param tokenAmountOut The swap desired amount for tokenOut\r\n    * @param relativePrice The price of tokenOut in tokenIn terms\r\n    * @param baseFee The base fee amount\r\n    * @param fallbackSpread The default spread in case the it couldn't be calculated using oracle prices\r\n    * @return alpha The potentially augmented fee amount\r\n    */\r\n    function getAdaptiveFees(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        uint256 tokenAmountIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 relativePrice,\r\n        uint256 baseFee,\r\n        uint256 fallbackSpread\r\n    ) internal view returns (uint256 alpha) {\r\n\r\n        // we only consider same block as last price update\r\n        if (\r\n            (block.timestamp != tokenGlobalIn.latestRound.timestamp)\r\n            && (block.timestamp != tokenGlobalOut.latestRound.timestamp)\r\n        ) {\r\n            // no additional fees\r\n            return alpha = baseFee;\r\n        }\r\n        uint256 recentPriceUpperBound = ChainlinkUtils.getMaxRelativePriceInLastBlock(\r\n            tokenGlobalIn.latestRound,\r\n            tokenGlobalIn.info.decimals,\r\n            tokenGlobalOut.latestRound,\r\n            tokenGlobalOut.info.decimals\r\n        );\r\n        if (recentPriceUpperBound == 0) {\r\n            // we were not able to retrieve the previous price\r\n            return alpha = fallbackSpread;\r\n        } else if (recentPriceUpperBound <= relativePrice) {\r\n            // no additional fees\r\n            return alpha = baseFee;\r\n        }\r\n\r\n        return (\r\n            // additional fees indexed on price increase and imbalance\r\n            alpha = Num.min(\r\n                Const.ONE,\r\n                baseFee + calcAdaptiveFeeGivenInAndOut(\r\n                    tokenGlobalIn.info.balance,\r\n                    tokenAmountIn,\r\n                    tokenGlobalIn.info.weight,\r\n                    tokenGlobalOut.info.balance,\r\n                    tokenAmountOut,\r\n                    tokenGlobalOut.info.weight\r\n                )\r\n            )\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the adaptive fees when joining a pool\r\n    * @dev Adaptive fees are the fees related to the price increase of tokenIn with respect to tokenOut\r\n    * reported by the oracles in the same block as the transaction\r\n    * @param poolValueInTokenIn The pool value in terms of tokenIn\r\n    * @param tokenBalanceIn The pool's balance of tokenIn\r\n    * @param normalizedTokenWeightIn The normalized weight of tokenIn\r\n    * @param tokenAmountIn The amount of tokenIn to be swapped\r\n    * @return adaptiveFees The adaptive fees (should be added to the pool's swap fees)\r\n    */\r\n    function calcPoolOutGivenSingleInAdaptiveFees(\r\n        uint256 poolValueInTokenIn,\r\n        uint256 tokenBalanceIn,\r\n        uint256 normalizedTokenWeightIn,\r\n        uint256 tokenAmountIn\r\n    ) internal pure returns (uint256) {\r\n        uint256 foo = Num.mul(\r\n            Num.div(tokenBalanceIn, tokenAmountIn),\r\n            Num.pow(\r\n                Num.div(\r\n                    poolValueInTokenIn + tokenAmountIn,\r\n                    poolValueInTokenIn\r\n                ),\r\n                Num.div(Const.ONE, normalizedTokenWeightIn)\r\n            ) - Const.ONE\r\n        );\r\n        if (foo >= Const.ONE) {\r\n            return 0;\r\n        }\r\n        return (\r\n            Num.div(\r\n                Const.ONE - foo,\r\n                Const.ONE - normalizedTokenWeightIn\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the adaptive fees when exiting a pool\r\n    * @dev Adaptive fees are the fees related to the price increase of tokenIn with respect to tokenOut\r\n    * reported by the oracles in the same block as the transaction\r\n    * @param poolValueInTokenOut The pool value in terms of tokenOut\r\n    * @param tokenBalanceOut The pool's balance of tokenOut\r\n    * @param normalizedTokenWeightOut The normalized weight of tokenOut\r\n    * @param normalizedPoolAmountOut The normalized amount of pool token's to be burned\r\n    * @return adaptiveFees The adaptive fees (should be added to the pool's swap fees)\r\n    */\r\n    function calcSingleOutGivenPoolInAdaptiveFees(\r\n        uint256 poolValueInTokenOut,\r\n        uint256 tokenBalanceOut,\r\n        uint256 normalizedTokenWeightOut,\r\n        uint256 normalizedPoolAmountOut\r\n    ) internal pure returns (uint256) {\r\n        uint256 foo = Num.div(\r\n            Num.mul(poolValueInTokenOut, normalizedPoolAmountOut),\r\n            Num.mul(\r\n                tokenBalanceOut,\r\n                    Const.ONE -\r\n                    Num.pow(\r\n                        Const.ONE - normalizedPoolAmountOut,\r\n                        Num.div(Const.ONE, normalizedTokenWeightOut)\r\n                    )\r\n            )\r\n        );\r\n        if (foo >= Const.ONE) {\r\n            return 0;\r\n        }\r\n        return (\r\n        Num.div(\r\n            Const.ONE - foo,\r\n            Const.ONE - normalizedTokenWeightOut\r\n        )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the total value of the pool in terms of the quote token\r\n    */\r\n    function getPoolTotalValue(Struct.TokenGlobal memory quoteToken, Struct.TokenGlobal[] memory baseTokens)\r\n    internal pure returns (uint256 basesTotalValue){\r\n        basesTotalValue = quoteToken.info.balance;\r\n        for (uint256 i; i < baseTokens.length;) {\r\n            basesTotalValue += Num.mul(\r\n                baseTokens[i].info.balance,\r\n                ChainlinkUtils.getTokenRelativePrice(\r\n                    quoteToken.latestRound.price,\r\n                    quoteToken.info.decimals,\r\n                    baseTokens[i].latestRound.price,\r\n                    baseTokens[i].info.decimals\r\n                )\r\n            );\r\n            unchecked { ++i; }\r\n        }\r\n        return basesTotalValue;\r\n    }\r\n\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Address.sol\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IFactory.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/**\r\n* @title The interface for a Swaap V1 Pool Factory\r\n*/\r\ninterface IFactory {\r\n    \r\n    /**\r\n    * @notice Emitted when a controller creates a pool\r\n    * @param caller The pool's creator\r\n    * @param pool The created pool's address\r\n    */\r\n    event LOG_NEW_POOL(\r\n        address indexed caller,\r\n        address indexed pool\r\n    );\r\n\r\n    /**\r\n    * @notice Emitted when a Swaap labs transfer is requested\r\n    * @param from The current Swaap labs address\r\n    * @param to The pending new Swaap labs address\r\n    */\r\n    event LOG_TRANSFER_REQUESTED(\r\n        address indexed from,\r\n        address indexed to\r\n    );\r\n\r\n    /**\r\n    * @notice Emitted when a new address accepts the Swaap labs role\r\n    * @param from The old Swaap labs address\r\n    * @param to The new Swaap labs address\r\n    */\r\n    event LOG_NEW_SWAAPLABS(\r\n        address indexed from,\r\n        address indexed to\r\n    );\r\n\r\n    /*\r\n    * @notice Create new pool with default parameters\r\n    */\r\n    function newPool() external returns (address);\r\n    \r\n    /**\r\n    * @notice Returns if an address corresponds to a pool created by the factory\r\n    */\r\n    function isPool(address b) external view returns (bool);\r\n    \r\n    /**\r\n    * @notice Returns swaap labs' address\r\n    */\r\n    function getSwaapLabs() external view returns (address);\r\n\r\n    /**\r\n    * @notice Allows an owner to begin transferring ownership to a new address,\r\n    * pending.\r\n    */\r\n    function transferOwnership(address _to) external;\r\n\r\n    /**\r\n    * @notice Allows an ownership transfer to be completed by the recipient.\r\n    */\r\n    function acceptOwnership() external;\r\n   \r\n    /**\r\n    * @notice Sends the exit fees accumulated to swaap labs\r\n    */\r\n    function collect(address erc20) external;\r\n\r\n    /**\r\n    * @notice Pause the factory's pools\r\n    * @dev Pause disables most of the pools functionalities (swap, joinPool & joinswap)\r\n    * and only allows LPs to withdraw their funds\r\n    */\r\n    function pauseProtocol() external;\r\n    \r\n    /**\r\n    * @notice Resume the factory's pools\r\n    * @dev Unpausing re-enables all the pools functionalities\r\n    */\r\n    function resumeProtocol() external;\r\n    \r\n    /**\r\n    * @notice Reverts pools if the factory is paused\r\n    * @dev This function is called by the pools whenever a swap or a joinPool is being made\r\n    */\r\n    function whenNotPaused() external view;\r\n\r\n    /**\r\n    * @notice Revoke factory control over a pool's parameters\r\n    */\r\n    function revokePoolFactoryControl(address pool) external;\r\n    \r\n    /**\r\n    * @notice Sets a pool's swap fee\r\n    */\r\n    function setPoolSwapFee(address pool, uint256 swapFee) external;\r\n    \r\n    /**\r\n    * @notice Sets a pool's dynamic coverage fees Z\r\n    */\r\n    function setPoolDynamicCoverageFeesZ(address pool, uint64 dynamicCoverageFeesZ) external;\r\n\r\n    /**\r\n    * @notice Sets a pool's dynamic coverage fees horizon\r\n    */\r\n    function setPoolDynamicCoverageFeesHorizon(address pool, uint256 dynamicCoverageFeesHorizon) external;\r\n\r\n    /**\r\n    * @notice Sets a pool's price statistics lookback in round\r\n    */    \r\n    function setPoolPriceStatisticsLookbackInRound(address pool, uint8 priceStatisticsLookbackInRound) external;\r\n\r\n    /**\r\n    * @notice Sets a pool's price statistics lookback in seconds\r\n    */    \r\n    function setPoolPriceStatisticsLookbackInSec(address pool, uint64 priceStatisticsLookbackInSec) external;\r\n\r\n    /**\r\n    * @notice Sets a pool's statistics lookback step in round\r\n    */\r\n    function setPoolPriceStatisticsLookbackStepInRound(address pool, uint8 priceStatisticsLookbackStepInRound) external;\r\n\r\n    /**\r\n    * @notice Sets a pool's maximum price unpeg ratio\r\n    */\r\n    function setPoolMaxPriceUnpegRatio(address pool, uint256 maxPriceUnpegRatio) external;\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IPoolHelpers/IPoolLP.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/**\r\n* @title Contains the useful methods to a liquidity provider\r\n*/\r\ninterface IPoolLP {\r\n    \r\n    /**\r\n    * @notice Add liquidity to a pool and credit msg.sender\r\n    * @dev The order of maxAmount of each token must be the same as the _tokens' addresses stored in the pool\r\n    * @param poolAmountOut Amount of pool shares a LP wishes to receive\r\n    * @param maxAmountsIn Maximum accepted token amount in\r\n    */\r\n    function joinPool(\r\n        uint256 poolAmountOut,\r\n        uint256[] calldata maxAmountsIn\r\n    )\r\n    external;\r\n\r\n    /**\r\n    * @notice Get the token amounts in required and pool shares received when joining\r\n    * the pool given an amount of tokenIn\r\n    * @dev The amountIn of the specified token as input may differ at the exit due to\r\n    * rounding discrepancies\r\n    * @param  tokenIn The address of tokenIn\r\n    * @param  tokenAmountIn The approximate amount of tokenIn to be swapped\r\n    * @return poolAmountOut The pool amount out received\r\n    * @return tokenAmountsIn The exact amounts of tokenIn needed\r\n    */\r\n    function getJoinPool(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn\r\n    )\r\n    external\r\n    view\r\n    returns (uint256 poolAmountOut, uint256[] memory tokenAmountsIn);\r\n\r\n    /**\r\n    * @notice Remove liquidity from a pool\r\n    * @dev The order of minAmount of each token must be the same as the _tokens' addresses stored in the pool\r\n    * @param poolAmountIn Amount of pool shares a LP wishes to liquidate for tokens\r\n    * @param minAmountsOut Minimum accepted token amount out\r\n    */\r\n    function exitPool(\r\n        uint256 poolAmountIn,\r\n        uint256[] calldata minAmountsOut\r\n    )\r\n    external;\r\n    \r\n    /**\r\n    * @notice Get the token amounts received for a given pool shares in\r\n    * @param poolAmountIn The amount of pool shares a LP wishes to liquidate for tokens\r\n    * @return tokenAmountsOut The token amounts received\r\n    */\r\n    function getExitPool(uint256 poolAmountIn)\r\n    external\r\n    view\r\n    returns (uint256[] memory tokenAmountsOut);\r\n\r\n    /**\r\n    * @notice Join a pool with a single asset with a fixed amount in\r\n    * @dev The remaining tokens designate the tokens whose balances do not change during the joinswap\r\n    * @param tokenIn The address of tokenIn\r\n    * @param tokenAmountIn The amount of tokenIn to be added to the pool\r\n    * @param minPoolAmountOut The minimum amount of pool tokens that can be received\r\n    * @return poolAmountOut The received pool amount out\r\n    */\r\n    function joinswapExternAmountInMMM(\r\n        address tokenIn,\r\n        uint tokenAmountIn,\r\n        uint minPoolAmountOut\r\n    )\r\n    external\r\n    returns (uint poolAmountOut);\r\n\r\n    /**\r\n    * @notice Computes the amount of pool tokens received when joining a pool with a single asset of fixed amount in\r\n    * @dev The remaining tokens designate the tokens whose balances do not change during the joinswap\r\n    * @param tokenIn The address of tokenIn\r\n    * @param tokenAmountIn The amount of tokenIn to be added to the pool\r\n    * @return poolAmountOut The received pool token amount out\r\n    */\r\n    function getJoinswapExternAmountInMMM(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn\r\n    )\r\n    external\r\n    view\r\n    returns (uint256 poolAmountOut);\r\n\r\n    /**\r\n    * @notice Exit a pool with a single asset given the pool token amount in\r\n    * @dev The remaining tokens designate the tokens whose balances do not change during the exitswap\r\n    * @param tokenOut The address of tokenOut\r\n    * @param poolAmountIn The fixed amount of pool tokens in\r\n    * @param minAmountOut The minimum amount of token out that can be receied\r\n    * @return tokenAmountOut The received token amount out\r\n    */\r\n    function exitswapPoolAmountInMMM(\r\n        address tokenOut,\r\n        uint poolAmountIn,\r\n        uint minAmountOut\r\n    )\r\n    external\r\n    returns (uint tokenAmountOut);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IPoolHelpers/IPoolSwap.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/**\r\n* @title Contains the useful methods to a trader\r\n*/\r\ninterface IPoolSwap{\r\n\r\n    /**\r\n    * @notice Swap two tokens given the exact amount of token in\r\n    * @param tokenIn The address of the input token\r\n    * @param tokenAmountIn The exact amount of tokenIn to be swapped\r\n    * @param tokenOut The address of the received token\r\n    * @param minAmountOut The minimum accepted amount of tokenOut to be received\r\n    * @param maxPrice The maximum spot price accepted before the swap\r\n    * @return tokenAmountOut The token amount out received\r\n    * @return spotPriceAfter The spot price of tokenOut in terms of tokenIn after the swap\r\n    */\r\n    function swapExactAmountInMMM(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    external\r\n    returns (uint256 tokenAmountOut, uint256 spotPriceAfter);\r\n\r\n    /**\r\n    * @notice Computes the amount of tokenOut received when swapping a fixed amount of tokenIn\r\n    * @param tokenIn The address of the input token\r\n    * @param tokenAmountIn The fixed amount of tokenIn to be swapped\r\n    * @param tokenOut The address of the received token\r\n    * @param minAmountOut The minimum amount of tokenOut that can be received\r\n    * @param maxPrice The maximum spot price accepted before the swap\r\n    * @return swapResult The swap result (amount out, spread and tax base in)\r\n    * @return priceResult The price result (spot price before & after the swap, latest oracle price in & out)\r\n    */\r\n    function getAmountOutGivenInMMM(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    external view\r\n    returns (Struct.SwapResult memory swapResult, Struct.PriceResult memory priceResult);\r\n\r\n    /**\r\n    * @notice Swap two tokens given the exact amount of token out\r\n    * @param tokenIn The address of the input token\r\n    * @param maxAmountIn The maximum amount of tokenIn that can be swapped\r\n    * @param tokenOut The address of the received token\r\n    * @param tokenAmountOut The exact amount of tokenOut to be received\r\n    * @param maxPrice The maximum spot price accepted before the swap\r\n    * @return tokenAmountIn The amount of tokenIn added to the pool\r\n    * @return spotPriceAfter The spot price of token out in terms of token in after the swap\r\n    */\r\n    function swapExactAmountOutMMM(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    external\r\n    returns (uint256 tokenAmountIn, uint256 spotPriceAfter);\r\n\r\n    /**\r\n    * @notice Computes the amount of tokenIn needed to receive a fixed amount of tokenOut\r\n    * @param tokenIn The address of the input token\r\n    * @param maxAmountIn The maximum amount of tokenIn that can be swapped\r\n    * @param tokenOut The address of the received token\r\n    * @param tokenAmountOut The fixed accepted amount of tokenOut to be received\r\n    * @param maxPrice The maximum spot price accepted before the swap\r\n    * @return swapResult The swap result (amount in, spread and tax base in)\r\n    * @return priceResult The price result (spot price before & after the swap, latest oracle price in & out)\r\n    */\r\n    function getAmountInGivenOutMMM(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    external view\r\n    returns (Struct.SwapResult memory swapResult, Struct.PriceResult memory priceResult);\r\n}\r\n\r\n// File: contracts/interfaces/IPoolHelpers/IPoolState.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/**\r\n* @title Contains the useful methods to get the Pool's parameters and state\r\n*/\r\ninterface IPoolState{\r\n    \r\n    /**\r\n    * @dev Returns true if a trader can swap on the pool\r\n    */\r\n    function isPublicSwap() external view returns (bool);\r\n\r\n    /**\r\n    * @dev Returns true if a liquidity provider can join the pool\r\n    * A trader can swap on the pool if the pool is either finalized or isPublicSwap\r\n    */\r\n    function isFinalized() external view returns (bool);\r\n\r\n    /**\r\n    * @dev Returns true if the token is binded to the pool\r\n    */\r\n    function isBound(address t) external view returns (bool);\r\n\r\n    /**\r\n    * @dev Returns the binded tokens\r\n    */\r\n    function getTokens() external view returns (address[] memory tokens);\r\n    \r\n    /**\r\n    * @dev Returns the initial weight of a binded token\r\n    * The initial weight is the un-adjusted weight set by the controller at bind\r\n    * The adjusted weight is the corrected weight based on the token's price performance:\r\n    * adjusted_weight = initial_weight * current_price / initial_price\r\n    */\r\n    function getDenormalizedWeight(address token) external view returns (uint256);\r\n    \r\n    /**\r\n    * @dev Returns the balance of a binded token\r\n    */\r\n    function getBalance(address token) external view returns (uint256);\r\n    \r\n    /**\r\n    * @dev Returns the swap fee of the pool\r\n    */\r\n    function getSwapFee() external view returns (uint256);\r\n    \r\n    /**\r\n    * @dev Returns the current controller of the pool\r\n    */\r\n    function getController() external view returns (address);\r\n    \r\n    /**\r\n    * @dev Returns the coverage parameters of the pool\r\n    */\r\n    function getCoverageParameters() external view returns (\r\n        uint8   priceStatisticsLBInRound,\r\n        uint8   priceStatisticsLBStepInRound,\r\n        uint64  dynamicCoverageFeesZ,\r\n        uint256 dynamicCoverageFeesHorizon,\r\n        uint256 priceStatisticsLBInSec,\r\n        uint256 maxPriceUnpegRatio\r\n    );\r\n\r\n    /**\r\n    * @dev Returns the token's price when it was binded to the pool\r\n    */\r\n    function getTokenOracleInitialPrice(address token) external view returns (uint256);\r\n\r\n    /**\r\n    * @dev Returns the oracle's address of a token\r\n    */\r\n    function getTokenPriceOracle(address token) external view returns (address);\r\n\r\n    /**\r\n    * @dev Absorb any tokens that have been sent to this contract into the pool\r\n    * @param token The token's address\r\n    */\r\n    function gulp(address token) external;\r\n\r\n    /**\r\n    * @notice Returns the spot price without fees of a token pair\r\n    * @return spotPrice The spot price of tokenOut in terms of tokenIn\r\n    */\r\n    function getSpotPriceSansFee(address tokenIn, address tokenOut) \r\n    external view\r\n    returns (uint256 spotPrice);\r\n}\r\n\r\n// File: contracts/interfaces/IPoolHelpers/IPoolEvents.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/**\r\n* @title Contains the pool's events\r\n*/\r\ninterface IPoolEvents {\r\n    \r\n    /**\r\n    * @notice Emitted after each swap\r\n    * @param caller The trader's address\r\n    * @param tokenIn The tokenIn's address\r\n    * @param tokenOut The tokenOut's address\r\n    * @param tokenAmountIn The amount of the swapped tokenIn\r\n    * @param tokenAmountOut The amount of the swapped tokenOut\r\n    * @param spread The spread\r\n    * @param taxBaseIn The amount of tokenIn swapped when in shortage of tokenOut\r\n    * @param priceIn The latest price of tokenIn given by the oracle\r\n    * @param priceOut The latest price of tokenOut given by the oracle\r\n    */\r\n    event LOG_SWAP(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountIn,\r\n        uint256         tokenAmountOut,\r\n        uint256         spread,\r\n        uint256         taxBaseIn,\r\n        uint256         priceIn,\r\n        uint256         priceOut\r\n    );\r\n\r\n    /**\r\n    * @notice Emitted when an LP joins the pool with 1 or multiple assets\r\n    * @param caller The LP's address\r\n    * @param tokenIn The dposited token's address\r\n    * @param tokenAmountIn The deposited amount of tokenIn\r\n    */\r\n    event LOG_JOIN(\r\n        address indexed caller,\r\n        address indexed tokenIn,\r\n        uint256         tokenAmountIn\r\n    );\r\n\r\n    /**\r\n    * @notice Emitted when an LP withdraws one or multiple assets from the pool\r\n    * @param caller The LP's address\r\n    * @param tokenOut The withdrawn token's address\r\n    * @param tokenAmountOut The withdrawn amount of tokenOut\r\n    */\r\n    event LOG_EXIT(\r\n        address indexed caller,\r\n        address indexed tokenOut,\r\n        uint256         tokenAmountOut\r\n    );\r\n\r\n    /**\r\n    * @param sig The function's signature\r\n    * @param caller The caller's address\r\n    * @param data The input data of the call\r\n    */\r\n    event LOG_CALL(\r\n        bytes4  indexed sig,\r\n        address indexed caller,\r\n        bytes           data\r\n    ) anonymous;\r\n\r\n    /**\r\n    * @notice Emitted when a new controller is assigned to the pool\r\n    * @param from The previous controller's address\r\n    * @param to The new controller's address\r\n    */\r\n    event LOG_NEW_CONTROLLER(\r\n        address indexed from,\r\n        address indexed to\r\n    );\r\n\r\n    /**\r\n    * @notice Emitted when a token is binded/rebinded\r\n    * @param token The binded token's address\r\n    * @param oracle The assigned oracle's address\r\n    * @param price The latest token's price reported by the oracle\r\n    * @param description The oracle's description\r\n    */\r\n    event LOG_NEW_ORACLE_STATE(\r\n        address indexed token,\r\n        address oracle,\r\n        uint256 price,\r\n        uint8   decimals,\r\n        string  description\r\n    );\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IPoolHelpers/IPoolControl.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n/**\r\n* @title Contains the useful methods to a pool controller\r\n*/\r\ninterface IPoolControl {\r\n\r\n    /**\r\n    * @notice Revokes factory control over pool parameters\r\n    * @dev Factory control can only be revoked by the factory and not the pool controller\r\n    */\r\n    function revokeFactoryControl() external;\r\n\r\n    /**\r\n    * @notice Gives back factory control over the pool parameters\r\n    */\r\n    function giveFactoryControl() external;\r\n    \r\n    /**\r\n    * @notice Allows a controller to transfer ownership to a new address\r\n    * @dev It is recommended to use transferOwnership/acceptOwnership logic for safer transfers\r\n    * to avoid any faulty input\r\n    * This function is useful when creating pools using a proxy contract and transfer pool assets\r\n    * WARNING: Binded assets are also transferred to the new controller if the pool is not finalized\r\n    */  \r\n    function setControllerAndTransfer(address controller) external;\r\n    \r\n    /**\r\n    * @notice Allows a controller to begin transferring ownership to a new address\r\n    * @dev The function will revert if there are binded tokens in an un-finalized pool\r\n    * This prevents any accidental loss of funds for the current controller\r\n    */\r\n    function transferOwnership(address pendingController) external;\r\n    \r\n    /**\r\n    * @notice Allows a controller transfer to be completed by the recipient\r\n    */\r\n    function acceptOwnership() external;\r\n    \r\n    /**\r\n    * @notice Bind a new token to the pool\r\n    * @param token The token's address\r\n    * @param balance The token's balance\r\n    * @param denorm The token's weight\r\n    * @param priceFeedAddress The token's Chainlink price feed\r\n    */\r\n    function bindMMM(address token, uint256 balance, uint80 denorm, address priceFeedAddress) external;\r\n    \r\n    /**\r\n    * @notice Replace a binded token's balance, weight and price feed's address\r\n    * @param token The token's address\r\n    * @param balance The token's balance\r\n    * @param denorm The token's weight\r\n    * @param priceFeedAddress The token's Chainlink price feed\r\n    */\r\n    function rebindMMM(address token, uint256 balance, uint80 denorm, address priceFeedAddress) external;\r\n    \r\n    /**\r\n    * @notice Unbind a token from the pool\r\n    * @dev The function will return the token's balance back to the controller\r\n    * @param token The token's address\r\n    */\r\n    function unbindMMM(address token) external;\r\n    \r\n    /**\r\n    * @notice Enables public swaps on the pool but does not finalize the parameters\r\n    * @dev Unfinalized pool enables exclusively the controller to add liquidity into the pool\r\n    */\r\n    function setPublicSwap(bool publicSwap) external;\r\n\r\n    /**\r\n    * @notice Enables publicswap and finalizes the pool's tokens, price feeds, initial shares, balances and weights\r\n    */\r\n    function finalize() external;\r\n    \r\n    /** \r\n    * @notice Sets swap fee\r\n    */\r\n    function setSwapFee(uint256 swapFee) external;\r\n    \r\n    /**\r\n    * @notice Sets dynamic coverage fees Z\r\n    */\r\n    function setDynamicCoverageFeesZ(uint64 dynamicCoverageFeesZ) external;\r\n    \r\n    /**\r\n    * @notice Sets dynamic coverage fees horizon\r\n    */\r\n    function setDynamicCoverageFeesHorizon(uint256 dynamicCoverageFeesHorizon) external;\r\n    \r\n    /**\r\n    * @notice Sets price statistics maximum lookback in round\r\n    */\r\n    function setPriceStatisticsLookbackInRound(uint8 priceStatisticsLookbackInRound) external;\r\n    \r\n    /** \r\n    * @notice Sets price statistics maximum lookback in seconds\r\n    */\r\n    function setPriceStatisticsLookbackStepInRound(uint8 priceStatisticsLookbackStepInRound) external;\r\n    \r\n    /**\r\n    * @notice Sets price statistics lookback step in round\r\n    * @dev This corresponds to the roundId lookback step when looking for historical prices\r\n    */\r\n    function setPriceStatisticsLookbackInSec(uint256 priceStatisticsLookbackInSec) external;\r\n\r\n    /**\r\n    * @notice Sets price statistics maximum unpeg ratio\r\n    */\r\n    function setMaxPriceUnpegRatio(uint256 maxPriceUnpegRatio) external;\r\n}\r\n\r\n// File: contracts/interfaces/IPool.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @title The interface for a Swaap V1 Pool\r\n*/\r\ninterface IPool is \r\n    IPoolLP,\r\n    IPoolSwap,\r\n    IPoolState,\r\n    IPoolToken,\r\n    IPoolEvents,\r\n    IPoolControl\r\n{\r\n\r\n}\r\n\r\n// File: contracts/interfaces/IDecimals.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\ninterface IDecimals {\r\n    function decimals() external view returns(uint8);\r\n}\r\n\r\n// File: contracts/Pool.sol\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\r\n// GNU Affero General Public License for more details.\r\n\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program. If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Pool is PoolToken, IPool {\r\n\r\n    using SafeERC20 for IERC20; \r\n\r\n    struct Record {\r\n        bool bound;   // is token bound to pool\r\n        uint8 index;   // private\r\n        uint8 decimals; // token decimals + oracle decimals\r\n        uint80 denorm;  // denormalized weight\r\n        uint256 balance;\r\n    }\r\n\r\n    // putting modifier logic in functions enables contract size optimization\r\n    function _emitLog() private {\r\n        emit LOG_CALL(msg.sig, msg.sender, msg.data);\r\n    }\r\n\r\n    modifier _logs_() {\r\n        _emitLog();\r\n        _;\r\n    }\r\n\r\n    function _lock() private {\r\n        _require(!_mutex, Err.REENTRY);\r\n        _mutex = true;\r\n    }\r\n\r\n    function _unlock() private {\r\n        _mutex = false;\r\n    }\r\n\r\n    modifier _lock_() {\r\n        _lock();\r\n        _;\r\n        _unlock();\r\n    }\r\n\r\n    modifier _viewlock_() {\r\n        _require(!_mutex, Err.REENTRY);\r\n        _;\r\n    }\r\n\r\n    function _whenNotPaused() private view {\r\n        IFactory(_factory).whenNotPaused();\r\n    }\r\n\r\n    modifier _whenNotPaused_() {\r\n        _whenNotPaused();\r\n        _;\r\n    }\r\n\r\n    function _onlyAdmins() private view {\r\n        if (msg.sender == _controller) {\r\n            _require(!_finalized, Err.IS_FINALIZED);\r\n        }\r\n        else if (msg.sender == _factory) {\r\n            _require(!_revokedFactoryControl, Err.FACTORY_CONTROL_REVOKED);\r\n        }\r\n        else {\r\n            _revert(Err.NOT_ADMIN);\r\n        }\r\n    }\r\n\r\n    modifier _onlyAdmins_() {\r\n        _onlyAdmins();\r\n        _;\r\n    }\r\n\r\n    // prevents token transfers with fees\r\n    modifier _checkBalanceAfterTransfer_(address erc20, uint amount) {\r\n        uint expectedBalance = IERC20(erc20).balanceOf(address(this)) + amount;\r\n        _;\r\n        uint currentBalance = IERC20(erc20).balanceOf(address(this));\r\n        _require(expectedBalance == currentBalance, Err.UNEXPECTED_BALANCE);\r\n    }\r\n\r\n    address[] private _tokens;\r\n    mapping(address=>Record) private _records;\r\n\r\n    bool    private _mutex;\r\n    // `finalize` sets `PUBLIC can SWAP`, `PUBLIC can JOIN`\r\n    bool    private _publicSwap; // true if PUBLIC can call SWAP functions\r\n    \r\n    bool    private _finalized;\r\n    bool    private _revokedFactoryControl; // if true factory cannot change pool parameters\r\n    address immutable private _factory; // Factory address to push token exitFee to\r\n\r\n    // Coverage parameters\r\n    uint8   private _priceStatisticsLookbackInRound;\r\n    uint8   private _priceStatisticsLookbackStepInRound;\r\n    uint64  private _dynamicCoverageFeesZ;\r\n    uint256 private _dynamicCoverageFeesHorizon;\r\n    uint256 private _priceStatisticsLookbackInSec;\r\n    uint256 private _maxPriceUnpegRatio;\r\n\r\n    // Pool's swap fee\r\n    uint256 private _swapFee;\r\n\r\n    uint80  private _totalWeight;\r\n    address private _controller; // has CONTROL role\r\n    address private _pendingController;\r\n        \r\n    mapping(address=>Struct.OracleState) private _oraclesInitialState;\r\n\r\n\r\n    constructor() {\r\n        _controller = msg.sender;\r\n        _factory = msg.sender;\r\n        // Pool swap fee\r\n        _swapFee = Const.MIN_FEE;\r\n        // Coverage parameters\r\n        _priceStatisticsLookbackInRound = Const.BASE_LOOKBACK_IN_ROUND;\r\n        _priceStatisticsLookbackStepInRound = Const.LOOKBACK_STEP_IN_ROUND;\r\n        _dynamicCoverageFeesZ = Const.BASE_Z;\r\n        _dynamicCoverageFeesHorizon = Const.BASE_HORIZON;\r\n        _priceStatisticsLookbackInSec = Const.BASE_LOOKBACK_IN_SEC;\r\n        _maxPriceUnpegRatio = Const.BASE_MAX_PRICE_UNPEG_RATIO;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns true if a trader can swap on the pool\r\n    */\r\n    function isPublicSwap()\r\n    external view\r\n    _viewlock_\r\n    returns (bool)\r\n    {\r\n        return _publicSwap;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns true if a liquidity provider can join the pool\r\n    * A trader can swap on the pool if the pool is either finalized or isPublicSwap\r\n    */\r\n    function isFinalized()\r\n    external view\r\n    _viewlock_\r\n    returns (bool)\r\n    {\r\n        return _finalized;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns true if the token is binded to the pool\r\n    */\r\n    function isBound(address t)\r\n    external view\r\n    _viewlock_\r\n    returns (bool)\r\n    {\r\n        return _records[t].bound;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the binded tokens\r\n    */\r\n    function getTokens()\r\n    external view\r\n    _viewlock_\r\n    returns (address[] memory tokens)\r\n    {\r\n        return _tokens;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the initial weight of a binded token\r\n    * The initial weight is the un-adjusted weight set by the controller at bind\r\n    * The adjusted weight is the corrected weight based on the token's price performance:\r\n    * adjusted_weight = initial_weight * current_price / initial_price\r\n    */\r\n    function getDenormalizedWeight(address token)\r\n    external view\r\n    _viewlock_\r\n    returns (uint256)\r\n    {\r\n        _require(_records[token].bound, Err.NOT_BOUND);\r\n        return _records[token].denorm;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the balance of a binded token\r\n    */\r\n    function getBalance(address token)\r\n    external view\r\n    _viewlock_\r\n    returns (uint256)\r\n    {\r\n        _require(_records[token].bound, Err.NOT_BOUND);\r\n        return _records[token].balance;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the swap fee of the pool\r\n    */\r\n    function getSwapFee()\r\n    external view\r\n    _viewlock_\r\n    returns (uint256)\r\n    {\r\n        return _swapFee;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the current controller of the pool\r\n    */\r\n    function getController()\r\n    external view\r\n    _viewlock_\r\n    returns (address)\r\n    {\r\n        return _controller;\r\n    }\r\n\r\n    /**\r\n    * @notice Sets swap fee\r\n    */\r\n    function setSwapFee(uint256 swapFee)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _onlyAdmins_\r\n    {\r\n        _require(swapFee >= Const.MIN_FEE, Err.MIN_FEE);\r\n        _require(swapFee <= Const.MAX_FEE, Err.MAX_FEE);\r\n        _swapFee = swapFee;\r\n    }\r\n\r\n    /**\r\n    * @notice Allows a controller to transfer ownership to a new address\r\n    * @dev It is recommended to use transferOwnership/acceptOwnership logic for safer transfers\r\n    * to avoid any faulty input\r\n    * This function is useful when creating pools using a proxy contract and transfer pool assets\r\n    * WARNING: Binded assets are also transferred to the new controller if the pool is not finalized\r\n    */  \r\n    function setControllerAndTransfer(address controller)\r\n    external\r\n    _lock_\r\n    {\r\n        _require(msg.sender == _controller, Err.NOT_CONTROLLER);\r\n        _require(controller != address(0), Err.NULL_CONTROLLER);\r\n        _controller = controller;\r\n        _pendingController = address(0);\r\n        emit LOG_NEW_CONTROLLER(msg.sender, controller);\r\n    }\r\n    \r\n    /**\r\n    * @notice Allows a controller to begin transferring ownership to a new address\r\n    * @dev The function will revert if there are binded tokens in an un-finalized pool\r\n    * This prevents any accidental loss of funds for the current controller\r\n    */\r\n    function transferOwnership(address pendingController)\r\n    external\r\n    _logs_\r\n    {\r\n        _require(msg.sender == _controller, Err.NOT_CONTROLLER);\r\n        if(!_finalized){\r\n            // This condition prevents any accidental transfer of funds between the old and new controller\r\n            // when the pool is not finalized\r\n            _require(_tokens.length == 0 ,Err.BINDED_TOKENS);\r\n        }\r\n        _pendingController = pendingController;\r\n    }\r\n\r\n    /**\r\n    * @notice Allows a controller transfer to be completed by the recipient\r\n    */\r\n    function acceptOwnership()\r\n    external\r\n    {\r\n        _require(msg.sender == _pendingController, Err.NOT_PENDING_CONTROLLER);\r\n\r\n        address oldController = _controller;\r\n        _controller = msg.sender;\r\n        _pendingController = address(0);\r\n\r\n        emit LOG_NEW_CONTROLLER(oldController, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @notice Revokes factory control over pool parameters\r\n    * @dev Factory control can only be revoked by the factory and not the pool controller\r\n    */\r\n    function revokeFactoryControl()\r\n    external\r\n    _logs_\r\n    {\r\n        _require(msg.sender == _factory, Err.NOT_FACTORY);\r\n        _revokedFactoryControl = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Gives back factory control over the pool parameters\r\n    */\r\n    function giveFactoryControl()\r\n    external\r\n    _logs_\r\n    {\r\n        _require(msg.sender == _controller, Err.NOT_CONTROLLER);\r\n        _revokedFactoryControl = false;\r\n    }\r\n\r\n    /**\r\n    * @notice Enables public swaps on the pool but does not finalize the parameters\r\n    * @dev Unfinalized pool enables exclusively the controller to add liquidity into the pool\r\n    */\r\n    function setPublicSwap(bool publicSwap)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    {\r\n        _require(!_finalized, Err.IS_FINALIZED);\r\n        _require(msg.sender == _controller, Err.NOT_CONTROLLER);\r\n        _publicSwap = publicSwap;\r\n    }\r\n\r\n    /**\r\n    * @notice Enables publicswap and finalizes the pool's tokens, price feeds, initial shares, balances and weights\r\n    */\r\n    function finalize()\r\n    external\r\n    _logs_\r\n    _lock_\r\n    {\r\n        _require(!_finalized, Err.IS_FINALIZED);\r\n        _require(msg.sender == _controller, Err.NOT_CONTROLLER);\r\n        _require(_tokens.length >= Const.MIN_BOUND_TOKENS, Err.MIN_TOKENS);\r\n\r\n        _finalized = true;\r\n        _publicSwap = true;\r\n\r\n        _mintPoolShare(Const.INIT_POOL_SUPPLY);\r\n        _pushPoolShare(msg.sender, Const.INIT_POOL_SUPPLY);\r\n    }\r\n\r\n    /**\r\n    * @dev Absorb any tokens that have been sent to this contract into the pool\r\n    * @param token The token's address\r\n    */\r\n    function gulp(address token)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    {\r\n        _require(_records[token].bound, Err.NOT_BOUND);\r\n        _records[token].balance = IERC20(token).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n    * @notice Get the token amounts in required and pool shares received when joining\r\n    * the pool given an amount of tokenIn\r\n    * @dev The amountIn of the specified token as input may differ at the exit due to\r\n    * rounding discrepancies\r\n    * @param  tokenIn The address of tokenIn\r\n    * @param  tokenAmountIn The approximate amount of tokenIn to be swapped\r\n    * @return poolAmountOut The pool amount out received\r\n    * @return tokenAmountsIn The exact amounts of tokenIn needed\r\n    */\r\n    function getJoinPool(address tokenIn, uint256 tokenAmountIn)\r\n    external\r\n    view\r\n    _viewlock_\r\n    _whenNotPaused_\r\n    returns (uint256 poolAmountOut, uint256[] memory tokenAmountsIn)\r\n    {\r\n        _require(_finalized, Err.NOT_FINALIZED);\r\n        _require(_records[tokenIn].bound, Err.NOT_BOUND);\r\n\r\n        uint256 ratio = Num.divTruncated(tokenAmountIn, _records[tokenIn].balance);\r\n        \r\n        uint256 poolTotal = _totalSupply;\r\n        poolAmountOut = Num.mul(ratio, poolTotal);\r\n        // ratio is re-evaluated to avoid any calculation discrepancies with joinPool\r\n        ratio = Num.div(poolAmountOut, poolTotal);\r\n        _require(ratio != 0, Err.MATH_APPROX);\r\n\r\n        uint256 tokensLength = _tokens.length;\r\n        tokenAmountsIn = new uint256[](tokensLength);\r\n\r\n        for (uint256 i; i < tokensLength;) {\r\n            address t     = _tokens[i];\r\n            uint256 bal   = _records[t].balance;\r\n            tokenAmountIn = Num.mul(ratio, bal);\r\n            _require(tokenAmountIn != 0, Err.MATH_APPROX);\r\n            tokenAmountsIn[i] = tokenAmountIn;\r\n            unchecked{++i;}\r\n        }\r\n        \r\n        return (poolAmountOut, tokenAmountsIn);\r\n\r\n    }\r\n\r\n\r\n    /**\r\n    * @notice Add liquidity to a pool and credit msg.sender\r\n    * @dev The order of maxAmount of each token must be the same as the _tokens' addresses stored in the pool\r\n    * @param poolAmountOut Amount of pool shares a LP wishes to receive\r\n    * @param maxAmountsIn Maximum accepted token amount in\r\n    */\r\n    function joinPool(uint256 poolAmountOut, uint256[] calldata maxAmountsIn)\r\n    _logs_\r\n    _lock_\r\n    _whenNotPaused_\r\n    external\r\n    {\r\n        _require(_finalized, Err.NOT_FINALIZED);\r\n        _require(maxAmountsIn.length == _tokens.length, Err.INPUT_LENGTH_MISMATCH);\r\n\r\n        uint256 ratio = Num.div(poolAmountOut, _totalSupply);\r\n        _require(ratio != 0, Err.MATH_APPROX);\r\n\r\n        for (uint256 i; i < maxAmountsIn.length;) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountIn = Num.mul(ratio, bal);\r\n            _require(tokenAmountIn != 0, Err.MATH_APPROX);\r\n            _require(tokenAmountIn <= maxAmountsIn[i], Err.LIMIT_IN);\r\n            _records[t].balance = bal + tokenAmountIn;\r\n            emit LOG_JOIN(msg.sender, t, tokenAmountIn);\r\n            _pullUnderlying(t, msg.sender, tokenAmountIn);\r\n            unchecked{++i;}\r\n        }\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n    }\r\n\r\n    /**\r\n    * @notice Get the token amounts received for a given pool shares in\r\n    * @param poolAmountIn The amount of pool shares a LP wishes to liquidate for tokens\r\n    * @return tokenAmountsOut The token amounts received\r\n    */\r\n    function getExitPool(uint256 poolAmountIn)\r\n    external\r\n    view\r\n    _viewlock_\r\n    returns (uint256[] memory tokenAmountsOut)\r\n    {\r\n\r\n        _require(_finalized, Err.NOT_FINALIZED);\r\n\r\n        uint256 exitFee = Num.mul(poolAmountIn, Const.EXIT_FEE);\r\n        uint256 pAiAfterExitFee = poolAmountIn - exitFee;\r\n        uint256 ratio = Num.divTruncated(pAiAfterExitFee, _totalSupply);\r\n\r\n        uint256 tokensLength = _tokens.length;\r\n        tokenAmountsOut = new uint256[](tokensLength);\r\n\r\n        for (uint256 i; i < tokensLength;) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountOut = Num.mulTruncated(ratio, bal);\r\n            _require(tokenAmountOut != 0, Err.MATH_APPROX);\r\n            tokenAmountsOut[i] = tokenAmountOut;\r\n            unchecked{++i;}\r\n        }\r\n\r\n        return tokenAmountsOut;\r\n    }\r\n\r\n    /**\r\n    * @notice Remove liquidity from a pool\r\n    * @dev The order of minAmount of each token must be the same as the _tokens' addresses stored in the pool\r\n    * @param poolAmountIn Amount of pool shares a LP wishes to liquidate for tokens\r\n    * @param minAmountsOut Minimum accepted token amount out\r\n    */\r\n    function exitPool(uint256 poolAmountIn, uint256[] calldata minAmountsOut)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    {\r\n        _require(_finalized, Err.NOT_FINALIZED);\r\n        _require(minAmountsOut.length == _tokens.length, Err.INPUT_LENGTH_MISMATCH);\r\n\r\n        uint256 exitFee = Num.mul(poolAmountIn, Const.EXIT_FEE);\r\n        uint256 pAiAfterExitFee = poolAmountIn - exitFee;\r\n        uint256 ratio = Num.divTruncated(pAiAfterExitFee, _totalSupply);\r\n        _require(ratio != 0, Err.MATH_APPROX);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _pushPoolShare(_factory, exitFee);\r\n        _burnPoolShare(pAiAfterExitFee);\r\n\r\n        for (uint256 i; i < minAmountsOut.length;) {\r\n            address t = _tokens[i];\r\n            uint256 bal = _records[t].balance;\r\n            uint256 tokenAmountOut = Num.mulTruncated(ratio, bal);\r\n            _require(tokenAmountOut != 0, Err.MATH_APPROX);\r\n            _require(tokenAmountOut >= minAmountsOut[i], Err.LIMIT_OUT);\r\n\r\n            _records[t].balance = _records[t].balance - tokenAmountOut;\r\n            emit LOG_EXIT(msg.sender, t, tokenAmountOut);\r\n            _pushUnderlying(t, msg.sender, tokenAmountOut);\r\n            unchecked{++i;}\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the amount of pool tokens received when joining a pool with a single asset of fixed amount in\r\n    * @dev The remaining tokens designate the tokens whose balances do not change during the joinswap\r\n    * @param tokenIn The address of tokenIn\r\n    * @param tokenAmountIn The amount of tokenIn to be added to the pool\r\n    * @return poolAmountOut The received pool token amount out\r\n    */\r\n    function getJoinswapExternAmountInMMM(address tokenIn, uint256 tokenAmountIn)\r\n    external\r\n    view\r\n    _viewlock_\r\n    _whenNotPaused_\r\n    returns (uint256 poolAmountOut)\r\n    {\r\n        return (poolAmountOut = _getJoinswapExternAmountInMMM(tokenIn, tokenAmountIn));\r\n    }\r\n\r\n    function _getJoinswapExternAmountInMMM(address tokenIn, uint256 tokenAmountIn)\r\n    internal\r\n    view\r\n    returns (uint256 poolAmountOut)\r\n    {\r\n        _require(_finalized, Err.NOT_FINALIZED);\r\n        _require(_records[tokenIn].bound, Err.NOT_BOUND);\r\n        _require(tokenAmountIn <= Num.mul(_records[tokenIn].balance, Const.MAX_IN_RATIO), Err.MAX_IN_RATIO);\r\n\r\n        Struct.TokenGlobal memory tokenInInfo;\r\n        Struct.TokenGlobal[] memory remainingTokensInfo;\r\n        (tokenInInfo, remainingTokensInfo) = _getAllTokensInfo(tokenIn);\r\n\r\n        {\r\n            Struct.JoinExitSwapParameters memory joinswapParameters = Struct.JoinExitSwapParameters(\r\n                tokenAmountIn,\r\n                _swapFee,\r\n                Const.FALLBACK_SPREAD,\r\n                _totalSupply\r\n            );\r\n            Struct.GBMParameters memory gbmParameters = Struct.GBMParameters(\r\n                _dynamicCoverageFeesZ,\r\n                _dynamicCoverageFeesHorizon\r\n            );\r\n            Struct.HistoricalPricesParameters memory hpParameters = Struct.HistoricalPricesParameters(\r\n                _priceStatisticsLookbackInRound,\r\n                _priceStatisticsLookbackInSec,\r\n                block.timestamp,\r\n                _priceStatisticsLookbackStepInRound\r\n            );\r\n\r\n            poolAmountOut = Math.calcPoolOutGivenSingleInMMM(\r\n                tokenInInfo,\r\n                remainingTokensInfo,\r\n                joinswapParameters,\r\n                gbmParameters,\r\n                hpParameters\r\n            );\r\n\r\n            tokenInInfo.info.balance += tokenAmountIn;\r\n            _checkJoinSwapPrices(tokenInInfo, remainingTokensInfo);\r\n\r\n            return poolAmountOut;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Join a pool with a single asset with a fixed amount in\r\n    * @dev The remaining tokens designate the tokens whose balances do not change during the joinswap\r\n    * @param tokenIn The address of tokenIn\r\n    * @param tokenAmountIn The amount of tokenIn to be added to the pool\r\n    * @param minPoolAmountOut The minimum amount of pool tokens that can be received\r\n    * @return poolAmountOut The received pool amount out\r\n    */\r\n    function joinswapExternAmountInMMM(address tokenIn, uint tokenAmountIn, uint minPoolAmountOut)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _whenNotPaused_\r\n    returns (uint poolAmountOut)\r\n    {        \r\n        poolAmountOut = _getJoinswapExternAmountInMMM(\r\n            tokenIn, tokenAmountIn\r\n        );\r\n\r\n        _require(poolAmountOut >= minPoolAmountOut, Err.LIMIT_OUT);\r\n\r\n        _records[tokenIn].balance = _records[tokenIn].balance + tokenAmountIn;\r\n\r\n        emit LOG_JOIN(msg.sender, tokenIn, tokenAmountIn);\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _mintPoolShare(poolAmountOut);\r\n        _pushPoolShare(msg.sender, poolAmountOut);\r\n\r\n        return poolAmountOut;\r\n    }\r\n\r\n    /**\r\n    * @notice Exit a pool with a single asset given the pool token amount in\r\n    * @dev The remaining tokens designate the tokens whose balances do not change during the exitswap\r\n    * @param tokenOut The address of tokenOut\r\n    * @param poolAmountIn The fixed amount of pool tokens in\r\n    * @param minAmountOut The minimum amount of token out that can be receied\r\n    * @return tokenAmountOut The received token amount out\r\n    */\r\n    function exitswapPoolAmountInMMM(address tokenOut, uint poolAmountIn, uint minAmountOut)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _whenNotPaused_\r\n    returns (uint tokenAmountOut)\r\n    {\r\n        _require(_finalized, Err.NOT_FINALIZED);\r\n        _require(_records[tokenOut].bound, Err.NOT_BOUND);\r\n\r\n        Struct.TokenGlobal memory tokenOutInfo;\r\n        Struct.TokenGlobal[] memory remainingTokensInfo;\r\n\r\n        (tokenOutInfo, remainingTokensInfo) = _getAllTokensInfo(tokenOut);\r\n\r\n        {\r\n            Struct.JoinExitSwapParameters memory exitswapParameters = Struct.JoinExitSwapParameters(\r\n                poolAmountIn,\r\n                _swapFee,\r\n                Const.FALLBACK_SPREAD,\r\n                _totalSupply\r\n            );\r\n            Struct.GBMParameters memory gbmParameters = Struct.GBMParameters(\r\n                _dynamicCoverageFeesZ,\r\n                _dynamicCoverageFeesHorizon\r\n            );\r\n            Struct.HistoricalPricesParameters memory hpParameters = Struct.HistoricalPricesParameters(\r\n                _priceStatisticsLookbackInRound,\r\n                _priceStatisticsLookbackInSec,\r\n                block.timestamp,\r\n                _priceStatisticsLookbackStepInRound\r\n            );\r\n\r\n            tokenAmountOut = Math.calcSingleOutGivenPoolInMMM(\r\n                tokenOutInfo,\r\n                remainingTokensInfo,\r\n                exitswapParameters,\r\n                gbmParameters,\r\n                hpParameters\r\n            );\r\n            _require(tokenAmountOut <= Num.mul(_records[tokenOut].balance, Const.MAX_OUT_RATIO), Err.MAX_OUT_RATIO);\r\n        }\r\n\r\n        _require(tokenAmountOut >= minAmountOut, Err.LIMIT_OUT);\r\n\r\n        tokenOutInfo.info.balance -= tokenAmountOut;\r\n        _checkExitSwapPrices(tokenOutInfo, remainingTokensInfo);\r\n        _records[tokenOut].balance = tokenOutInfo.info.balance;\r\n\r\n        uint exitFee =  Num.mul(poolAmountIn, Const.EXIT_FEE);\r\n\r\n        emit LOG_EXIT(msg.sender, tokenOut, tokenAmountOut);\r\n\r\n        _pullPoolShare(msg.sender, poolAmountIn);\r\n        _burnPoolShare(poolAmountIn - exitFee);\r\n        _pushPoolShare(_factory, exitFee);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return tokenAmountOut;\r\n    }\r\n\r\n    /**\r\n    * @dev 'Underlying' token-manipulation functions make external calls but are NOT locked\r\n    * You must `_lock_` or otherwise ensure reentry-safety\r\n    */\r\n    function _pullUnderlying(address erc20, address from, uint256 amount)\r\n    internal\r\n    _checkBalanceAfterTransfer_(erc20, amount)\r\n    {\r\n        IERC20(erc20).safeTransferFrom(from, address(this), amount);\r\n    }\r\n\r\n    /**\r\n    * @dev 'Underlying' token-manipulation functions make external calls but are NOT locked\r\n    * You must `_lock_` or otherwise ensure reentry-safety\r\n    */\r\n    function _pushUnderlying(address erc20, address to, uint256 amount)\r\n    internal\r\n    {\r\n        IERC20(erc20).safeTransfer(to, amount);\r\n    }\r\n\r\n    function _pullPoolShare(address from, uint256 amount)\r\n    internal\r\n    {\r\n        _pull(from, amount);\r\n    }\r\n\r\n    function _pushPoolShare(address to, uint256 amount)\r\n    internal\r\n    {\r\n        _push(to, amount);\r\n    }\r\n\r\n    function _mintPoolShare(uint256 amount)\r\n    internal\r\n    {\r\n        _mint(amount);\r\n    }\r\n\r\n    function _burnPoolShare(uint256 amount)\r\n    internal\r\n    {\r\n        _burn(amount);\r\n    }\r\n\r\n    /**\r\n    * @notice Sets dynamic coverage fees Z\r\n    */\r\n    function setDynamicCoverageFeesZ(uint64 dynamicCoverageFeesZ)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _onlyAdmins_\r\n    {\r\n        _dynamicCoverageFeesZ = dynamicCoverageFeesZ;\r\n    }\r\n\r\n    /**\r\n    * @notice Sets dynamic coverage fees horizon\r\n    */\r\n    function setDynamicCoverageFeesHorizon(uint256 dynamicCoverageFeesHorizon)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _onlyAdmins_\r\n    {\r\n        _require(dynamicCoverageFeesHorizon >= Const.MIN_HORIZON, Err.MIN_HORIZON);\r\n        _dynamicCoverageFeesHorizon = dynamicCoverageFeesHorizon;\r\n    }\r\n\r\n    /**\r\n    * @notice Sets price statistics maximum lookback in round\r\n    */\r\n    function setPriceStatisticsLookbackInRound(uint8 priceStatisticsLookbackInRound)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _onlyAdmins_\r\n    {\r\n        _require(priceStatisticsLookbackInRound >= Const.MIN_LOOKBACK_IN_ROUND, Err.MIN_LB_PERIODS);\r\n        _require(priceStatisticsLookbackInRound <= Const.MAX_LOOKBACK_IN_ROUND, Err.MAX_LB_PERIODS);\r\n        _priceStatisticsLookbackInRound = priceStatisticsLookbackInRound;\r\n    }\r\n\r\n    /** \r\n    * @notice Sets price statistics maximum lookback in seconds\r\n    */\r\n    function setPriceStatisticsLookbackInSec(uint256 priceStatisticsLookbackInSec)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _onlyAdmins_\r\n    {\r\n        _require(priceStatisticsLookbackInSec >= Const.MIN_LOOKBACK_IN_SEC, Err.MIN_LB_SECS);\r\n        _priceStatisticsLookbackInSec = priceStatisticsLookbackInSec;\r\n    }\r\n\r\n    /**\r\n    * @notice Sets price statistics lookback step in round\r\n    * @dev This corresponds to the roundId lookback step when looking for historical prices\r\n    */\r\n    function setPriceStatisticsLookbackStepInRound(uint8 priceStatisticsLookbackStepInRound)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _onlyAdmins_\r\n    {\r\n        _require(priceStatisticsLookbackStepInRound >= Const.MIN_LOOKBACK_STEP_IN_ROUND, Err.MIN_LB_STEP_PERIODS);\r\n        _priceStatisticsLookbackStepInRound = priceStatisticsLookbackStepInRound;\r\n    }\r\n\r\n    /**\r\n    * @notice Sets price statistics maximum unpeg ratio\r\n    */\r\n    function setMaxPriceUnpegRatio(uint256 maxPriceUnpegRatio)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    {\r\n        _require(msg.sender == _factory, Err.NOT_FACTORY);\r\n        _require(!_revokedFactoryControl, Err.FACTORY_CONTROL_REVOKED);\r\n        _require(maxPriceUnpegRatio >= Const.MIN_MAX_PRICE_UNPEG_RATIO, Err.MIN_MAX_PRICE_UNPEG_RATIO);\r\n        _require(maxPriceUnpegRatio <= Const.MAX_MAX_PRICE_UNPEG_RATIO, Err.MAX_MAX_PRICE_UNPEG_RATIO);\r\n        _maxPriceUnpegRatio = maxPriceUnpegRatio;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the coverage parameters of the pool\r\n    */\r\n    function getCoverageParameters()\r\n    external view\r\n    _viewlock_\r\n    returns (\r\n            uint8   priceStatisticsLBInRound,\r\n            uint8   priceStatisticsLBStepInRound,\r\n            uint64  dynamicCoverageFeesZ,\r\n            uint256 dynamicCoverageFeesHorizon,\r\n            uint256 priceStatisticsLBInSec,\r\n            uint256 maxPriceUnpegRatio\r\n        )\r\n    {\r\n        return (\r\n            priceStatisticsLBInRound     = _priceStatisticsLookbackInRound,\r\n            priceStatisticsLBStepInRound = _priceStatisticsLookbackStepInRound,\r\n            dynamicCoverageFeesZ         = _dynamicCoverageFeesZ,\r\n            dynamicCoverageFeesHorizon   = _dynamicCoverageFeesHorizon,\r\n            priceStatisticsLBInSec       = _priceStatisticsLookbackInSec,\r\n            maxPriceUnpegRatio           = _maxPriceUnpegRatio\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the token's price when it was binded to the pool\r\n    */\r\n    function getTokenOracleInitialPrice(address token)\r\n    external view\r\n    _viewlock_\r\n    returns (uint256)\r\n    {\r\n        _require(_records[token].bound, Err.NOT_BOUND);\r\n        return _oraclesInitialState[token].price;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the oracle's address of a token\r\n    */\r\n    function getTokenPriceOracle(address token)\r\n    external view\r\n    _viewlock_\r\n    returns (address)\r\n    {\r\n        _require(_records[token].bound, Err.NOT_BOUND);\r\n        return _oraclesInitialState[token].oracle;\r\n    }\r\n\r\n    /**\r\n    * @notice Bind a new token to the pool\r\n    * @param token The token's address\r\n    * @param balance The token's balance\r\n    * @param denorm The token's weight\r\n    * @param priceFeedAddress The token's Chainlink price feed\r\n    */\r\n    function bindMMM(address token, uint256 balance, uint80 denorm, address priceFeedAddress)\r\n    external\r\n    {\r\n        _require(!_records[token].bound, Err.IS_BOUND);\r\n\r\n        _require(_tokens.length < Const.MAX_BOUND_TOKENS, Err.MAX_TOKENS);\r\n\r\n        _records[token] = Record(\r\n            {\r\n                bound: true,\r\n                index: uint8(_tokens.length),\r\n                decimals: 0,\r\n                denorm: 0,    // balance and denorm will be validated\r\n                balance: 0   // and set by `rebind`\r\n            }\r\n        );\r\n        _tokens.push(token);\r\n        _rebindMMM(token, balance, denorm, priceFeedAddress);\r\n    }\r\n\r\n    /**\r\n    * @notice Replace a binded token's balance, weight and price feed's address\r\n    * @param token The token's address\r\n    * @param balance The token's balance\r\n    * @param denorm The token's weight\r\n    * @param priceFeedAddress The token's Chainlink price feed\r\n    */\r\n    function rebindMMM(address token, uint256 balance, uint80 denorm, address priceFeedAddress)\r\n    external\r\n    {\r\n        _require(_records[token].bound, Err.NOT_BOUND);\r\n\r\n        _rebindMMM(token, balance, denorm, priceFeedAddress);\r\n    }\r\n\r\n    function _rebindMMM(address token, uint256 balance, uint80 denorm, address priceFeedAddress)\r\n    internal \r\n    _logs_\r\n    _lock_\r\n    _whenNotPaused_\r\n    {\r\n        _require(msg.sender == _controller, Err.NOT_CONTROLLER);\r\n        _require(!_finalized, Err.IS_FINALIZED);\r\n        _require(_pendingController == address(0), Err.PENDING_NEW_CONTROLLER);\r\n\r\n        _require(denorm >= Const.MIN_WEIGHT, Err.MIN_WEIGHT);\r\n        _require(denorm <= Const.MAX_WEIGHT, Err.MAX_WEIGHT);\r\n        _require(balance >= Const.MIN_BALANCE, Err.MIN_BALANCE);\r\n\r\n        // Adjust the denorm and totalWeight\r\n        uint80 oldWeight = _records[token].denorm;\r\n        if (denorm > oldWeight) {\r\n            _totalWeight = _totalWeight + (denorm - oldWeight);\r\n            _require(_totalWeight <= Const.MAX_TOTAL_WEIGHT, Err.MAX_TOTAL_WEIGHT);\r\n        } else if (denorm < oldWeight) {\r\n            _totalWeight = (_totalWeight - oldWeight) + denorm;\r\n        }\r\n        _records[token].denorm = denorm;\r\n\r\n        // Adjust the balance record and actual token balance\r\n        uint256 oldBalance = _records[token].balance;\r\n        _records[token].balance = balance;\r\n        if (balance > oldBalance) {\r\n            _pullUnderlying(token, msg.sender, balance - oldBalance);\r\n        } else if (balance < oldBalance) {\r\n            // In this case liquidity is being withdrawn, so charge EXIT_FEE\r\n            uint256 tokenBalanceWithdrawn = oldBalance - balance;\r\n            uint256 tokenExitFee = Num.mul(tokenBalanceWithdrawn, Const.EXIT_FEE);\r\n            _pushUnderlying(token, msg.sender, tokenBalanceWithdrawn - tokenExitFee);\r\n            _pushUnderlying(token, _factory, tokenExitFee);\r\n        }\r\n\r\n        (\r\n            uint256 price,\r\n            uint8 decimals,\r\n            string memory description\r\n        ) = ChainlinkUtils.getTokenLatestPrice(priceFeedAddress);\r\n\r\n        _records[token].decimals = decimals + _tryGetTokenDecimals(token);\r\n\r\n        // Updating oracle state\r\n        _oraclesInitialState[token] = Struct.OracleState(\r\n            {\r\n                oracle: priceFeedAddress,\r\n                price: price // set right below\r\n            }\r\n        );\r\n\r\n        emit LOG_NEW_ORACLE_STATE(\r\n            token,\r\n            priceFeedAddress,\r\n            price,\r\n            decimals,\r\n            description\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Unbind a token from the pool\r\n    * @dev The function will return the token's balance back to the controller\r\n    * @param token The token's address\r\n    */\r\n    function unbindMMM(address token)\r\n    external\r\n    _logs_\r\n    _lock_\r\n    {\r\n\r\n        _require(msg.sender == _controller, Err.NOT_CONTROLLER);\r\n        _require(_records[token].bound, Err.NOT_BOUND);\r\n        _require(!_finalized, Err.IS_FINALIZED);\r\n\r\n        uint256 tokenBalance = _records[token].balance;\r\n        uint256 tokenExitFee = Num.mul(tokenBalance, Const.EXIT_FEE);\r\n\r\n        _totalWeight = _totalWeight - _records[token].denorm;\r\n\r\n        // Swap the token-to-unbind with the last token,\r\n        // then delete the last token\r\n        uint8 index = _records[token].index;\r\n        uint256 last = _tokens.length - 1;\r\n        _tokens[index] = _tokens[last];\r\n        _records[_tokens[index]].index = index;\r\n        _tokens.pop();\r\n        delete _records[token];\r\n        delete _oraclesInitialState[token];\r\n\r\n        _pushUnderlying(token, msg.sender, tokenBalance - tokenExitFee);\r\n        _pushUnderlying(token, _factory, tokenExitFee);\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Returns the spot price without fees of a token pair\r\n    * @return spotPrice The spot price of tokenOut in terms of tokenIn\r\n    */\r\n    function getSpotPriceSansFee(address tokenIn, address tokenOut)\r\n    external view\r\n    _viewlock_\r\n    returns (uint256 spotPrice)\r\n    {\r\n        _require(_records[tokenIn].bound && _records[tokenOut].bound, Err.NOT_BOUND);\r\n        // The weights are corrected by the price change of each token\r\n        Struct.TokenGlobal memory tokenGlobalIn = getTokenLatestInfo(tokenIn);\r\n        Struct.TokenGlobal memory tokenGlobalOut = getTokenLatestInfo(tokenOut);\r\n        return spotPrice = Math.calcSpotPrice(\r\n            tokenGlobalIn.info.balance,\r\n            tokenGlobalIn.info.weight,\r\n            tokenGlobalOut.info.balance,\r\n            tokenGlobalOut.info.weight,\r\n            0\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Swap two tokens given the exact amount of token in\r\n    * @param tokenIn The address of the input token\r\n    * @param tokenAmountIn The exact amount of tokenIn to be swapped\r\n    * @param tokenOut The address of the received token\r\n    * @param minAmountOut The minimum accepted amount of tokenOut to be received\r\n    * @param maxPrice The maximum spot price accepted before the swap\r\n    * @return tokenAmountOut The token amount out received\r\n    * @return spotPriceAfter The spot price of tokenOut in terms of tokenIn after the swap\r\n    */\r\n    function swapExactAmountInMMM(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _whenNotPaused_\r\n    returns (uint256 tokenAmountOut, uint256 spotPriceAfter)\r\n    {\r\n        (Struct.SwapResult memory swapResult, Struct.PriceResult memory priceResult) = _getAmountOutGivenInMMM(\r\n            tokenIn,\r\n            tokenAmountIn,\r\n            tokenOut,\r\n            minAmountOut,\r\n            maxPrice\r\n        );\r\n\r\n        _records[tokenIn].balance += tokenAmountIn;\r\n        _records[tokenOut].balance -= swapResult.amount;\r\n\r\n        emit LOG_SWAP(\r\n            msg.sender, tokenIn, tokenOut, tokenAmountIn,\r\n            swapResult.amount, swapResult.spread, swapResult.taxBaseIn,\r\n            priceResult.priceIn, priceResult.priceOut\r\n        );\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, tokenAmountIn);\r\n        _pushUnderlying(tokenOut, msg.sender, swapResult.amount);\r\n\r\n        return (tokenAmountOut = swapResult.amount, spotPriceAfter = priceResult.spotPriceAfter);\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the amount of tokenOut received when swapping a fixed amount of tokenIn\r\n    * @param tokenIn The address of the input token\r\n    * @param tokenAmountIn The fixed amount of tokenIn to be swapped\r\n    * @param tokenOut The address of the received token\r\n    * @param minAmountOut The minimum amount of tokenOut that can be received\r\n    * @param maxPrice The maximum spot price accepted before the swap\r\n    * @return swapResult The swap result (amount out, spread and tax base in)\r\n    * @return priceResult The price result (spot price before & after the swap, latest oracle price in & out)\r\n    */\r\n    function getAmountOutGivenInMMM(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    external view\r\n    _viewlock_\r\n    _whenNotPaused_\r\n    returns (Struct.SwapResult memory swapResult, Struct.PriceResult memory priceResult)\r\n    {\r\n        return _getAmountOutGivenInMMM(\r\n            tokenIn,\r\n            tokenAmountIn,\r\n            tokenOut,\r\n            minAmountOut,\r\n            maxPrice\r\n        );\r\n    }\r\n\r\n    function _getAmountOutGivenInMMM(\r\n        address tokenIn,\r\n        uint256 tokenAmountIn,\r\n        address tokenOut,\r\n        uint256 minAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    internal view\r\n    returns (Struct.SwapResult memory swapResult, Struct.PriceResult memory priceResult)\r\n    {\r\n\r\n        _require(_records[tokenIn].bound && _records[tokenOut].bound, Err.NOT_BOUND);\r\n        _require(_publicSwap, Err.SWAP_NOT_PUBLIC);\r\n\r\n        _require(tokenAmountIn <= Num.mul(_records[tokenIn].balance, Const.MAX_IN_RATIO), Err.MAX_IN_RATIO);\r\n\r\n        Struct.TokenGlobal memory tokenGlobalIn = getTokenLatestInfo(tokenIn);\r\n        Struct.TokenGlobal memory tokenGlobalOut = getTokenLatestInfo(tokenOut);\r\n\r\n        priceResult.spotPriceBefore = Math.calcSpotPrice(\r\n            tokenGlobalIn.info.balance,\r\n            tokenGlobalIn.info.weight,\r\n            tokenGlobalOut.info.balance,\r\n            tokenGlobalOut.info.weight,\r\n            _swapFee\r\n        );\r\n\r\n        _require(priceResult.spotPriceBefore <= maxPrice, Err.BAD_LIMIT_PRICE);\r\n\r\n        swapResult = _getAmountOutGivenInMMMWithTimestamp(\r\n            tokenGlobalIn,\r\n            tokenGlobalOut,\r\n            tokenAmountIn,\r\n            block.timestamp\r\n        );\r\n        _require(swapResult.amount >= minAmountOut, Err.LIMIT_OUT);\r\n\r\n        priceResult.spotPriceAfter = Math.calcSpotPrice(\r\n            tokenGlobalIn.info.balance + tokenAmountIn,\r\n            tokenGlobalIn.info.weight,\r\n            tokenGlobalOut.info.balance - swapResult.amount,\r\n            tokenGlobalOut.info.weight,\r\n            _swapFee\r\n        );\r\n\r\n        _require(priceResult.spotPriceAfter >= priceResult.spotPriceBefore, Err.MATH_APPROX);\r\n        uint256 maxAmount = Num.divTruncated(tokenAmountIn, priceResult.spotPriceBefore);\r\n        if (swapResult.amount > maxAmount) {\r\n            swapResult.amount = maxAmount;\r\n        }\r\n        _require(\r\n            Num.div(\r\n                Num.mul(priceResult.spotPriceAfter, Const.ONE - _swapFee),\r\n                ChainlinkUtils.getTokenRelativePrice(\r\n                    tokenGlobalIn.latestRound.price,\r\n                    tokenGlobalIn.info.decimals,\r\n                    tokenGlobalOut.latestRound.price,\r\n                    tokenGlobalOut.info.decimals\r\n                )\r\n            ) <= _maxPriceUnpegRatio,\r\n            Err.MAX_PRICE_UNPEG_RATIO\r\n        );\r\n\r\n        priceResult.priceIn = tokenGlobalIn.latestRound.price;\r\n        priceResult.priceOut = tokenGlobalOut.latestRound.price;\r\n\r\n        return (swapResult, priceResult);\r\n    }\r\n\r\n    function _getAmountOutGivenInMMMWithTimestamp(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        uint256 tokenAmountIn,\r\n        uint256 timestamp\r\n    )\r\n    internal view\r\n    returns (Struct.SwapResult memory)\r\n    {\r\n\r\n        Struct.SwapParameters memory swapParameters = Struct.SwapParameters(\r\n            tokenAmountIn,\r\n            _swapFee,\r\n            Const.FALLBACK_SPREAD\r\n        );\r\n        Struct.GBMParameters memory gbmParameters = Struct.GBMParameters(\r\n            _dynamicCoverageFeesZ,\r\n            _dynamicCoverageFeesHorizon\r\n        );\r\n        Struct.HistoricalPricesParameters memory hpParameters = Struct.HistoricalPricesParameters(\r\n            _priceStatisticsLookbackInRound,\r\n            _priceStatisticsLookbackInSec,\r\n            timestamp,\r\n            _priceStatisticsLookbackStepInRound\r\n        );\r\n\r\n        return Math.calcOutGivenInMMM(\r\n            tokenGlobalIn,\r\n            tokenGlobalOut,\r\n            ChainlinkUtils.getTokenRelativePrice(\r\n                tokenGlobalIn.latestRound.price,\r\n                tokenGlobalIn.info.decimals,\r\n                tokenGlobalOut.latestRound.price,\r\n                tokenGlobalOut.info.decimals\r\n            ),\r\n            swapParameters,\r\n            gbmParameters,\r\n            hpParameters\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Swap two tokens given the exact amount of token out\r\n    * @param tokenIn The address of the input token\r\n    * @param maxAmountIn The maximum amount of tokenIn that can be swapped\r\n    * @param tokenOut The address of the received token\r\n    * @param tokenAmountOut The exact amount of tokenOut to be received\r\n    * @param maxPrice The maximum spot price accepted before the swap\r\n    * @return tokenAmountIn The amount of tokenIn added to the pool\r\n    * @return spotPriceAfter The spot price of token out in terms of token in after the swap\r\n    */\r\n    function swapExactAmountOutMMM(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    external\r\n    _logs_\r\n    _lock_\r\n    _whenNotPaused_\r\n    returns (uint256 tokenAmountIn, uint256 spotPriceAfter)\r\n    {\r\n\r\n        (Struct.SwapResult memory swapResult, Struct.PriceResult memory priceResult) = _getAmountInGivenOutMMM(\r\n            tokenIn,\r\n            maxAmountIn,\r\n            tokenOut,\r\n            tokenAmountOut,\r\n            maxPrice\r\n        );\r\n\r\n        _records[tokenIn].balance += swapResult.amount;\r\n        _records[tokenOut].balance -= tokenAmountOut;\r\n\r\n        emit LOG_SWAP(\r\n            msg.sender, tokenIn, tokenOut, swapResult.amount,\r\n            tokenAmountOut, swapResult.spread, swapResult.taxBaseIn,\r\n            priceResult.priceIn, priceResult.priceOut\r\n        );\r\n\r\n        _pullUnderlying(tokenIn, msg.sender, swapResult.amount);\r\n        _pushUnderlying(tokenOut, msg.sender, tokenAmountOut);\r\n\r\n        return (tokenAmountIn = swapResult.amount, spotPriceAfter = priceResult.spotPriceAfter);\r\n    }\r\n\r\n    /**\r\n    * @notice Computes the amount of tokenIn needed to receive a fixed amount of tokenOut\r\n    * @param tokenIn The address of the input token\r\n    * @param maxAmountIn The maximum amount of tokenIn that can be swapped\r\n    * @param tokenOut The address of the received token\r\n    * @param tokenAmountOut The fixed accepted amount of tokenOut to be received\r\n    * @param maxPrice The maximum spot price accepted before the swap\r\n    * @return swapResult The swap result (amount in, spread and tax base in)\r\n    * @return priceResult The price result (spot price before & after the swap, latest oracle price in & out)\r\n    */\r\n    function getAmountInGivenOutMMM(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    external view\r\n    _viewlock_\r\n    _whenNotPaused_\r\n    returns (Struct.SwapResult memory swapResult, Struct.PriceResult memory priceResult)\r\n    {\r\n        return _getAmountInGivenOutMMM(\r\n            tokenIn,\r\n            maxAmountIn,\r\n            tokenOut,\r\n            tokenAmountOut,\r\n            maxPrice\r\n        );\r\n    }\r\n\r\n    function _getAmountInGivenOutMMM(\r\n        address tokenIn,\r\n        uint256 maxAmountIn,\r\n        address tokenOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 maxPrice\r\n    )\r\n    internal view\r\n    returns (Struct.SwapResult memory swapResult, Struct.PriceResult memory priceResult)\r\n    {\r\n\r\n        _require(_records[tokenIn].bound && _records[tokenOut].bound, Err.NOT_BOUND);\r\n        _require(_publicSwap, Err.SWAP_NOT_PUBLIC);\r\n\r\n        _require(tokenAmountOut <= Num.mul(_records[tokenOut].balance, Const.MAX_OUT_RATIO), Err.MAX_OUT_RATIO);\r\n\r\n        Struct.TokenGlobal memory tokenGlobalIn = getTokenLatestInfo(tokenIn);\r\n        Struct.TokenGlobal memory tokenGlobalOut = getTokenLatestInfo(tokenOut);\r\n\r\n        priceResult.spotPriceBefore = Math.calcSpotPrice(\r\n            tokenGlobalIn.info.balance,\r\n            tokenGlobalIn.info.weight,\r\n            tokenGlobalOut.info.balance,\r\n            tokenGlobalOut.info.weight,\r\n            _swapFee\r\n        );\r\n\r\n        _require(priceResult.spotPriceBefore <= maxPrice, Err.BAD_LIMIT_PRICE);\r\n\r\n        swapResult = _getAmountInGivenOutMMMWithTimestamp(\r\n            tokenGlobalIn,\r\n            tokenGlobalOut,\r\n            tokenAmountOut,\r\n            block.timestamp\r\n        );\r\n\r\n        _require(swapResult.amount <= maxAmountIn, Err.LIMIT_IN);\r\n\r\n        priceResult.spotPriceAfter = Math.calcSpotPrice(\r\n            tokenGlobalIn.info.balance + swapResult.amount,\r\n            tokenGlobalIn.info.weight,\r\n            tokenGlobalOut.info.balance - tokenAmountOut,\r\n            tokenGlobalOut.info.weight,\r\n            _swapFee\r\n        );\r\n\r\n        _require(priceResult.spotPriceAfter >= priceResult.spotPriceBefore, Err.MATH_APPROX);\r\n        uint256 minAmount = Num.mul(priceResult.spotPriceBefore, tokenAmountOut) + 1;\r\n        if (swapResult.amount < minAmount) {\r\n            swapResult.amount = minAmount;\r\n        }\r\n        _require(\r\n            Num.div(\r\n                Num.mul(priceResult.spotPriceAfter, Const.ONE - _swapFee),\r\n                ChainlinkUtils.getTokenRelativePrice(\r\n                    tokenGlobalIn.latestRound.price,\r\n                    tokenGlobalIn.info.decimals,\r\n                    tokenGlobalOut.latestRound.price,\r\n                    tokenGlobalOut.info.decimals\r\n                )\r\n            ) <= _maxPriceUnpegRatio,\r\n            Err.MAX_PRICE_UNPEG_RATIO\r\n        );\r\n\r\n        priceResult.priceIn = tokenGlobalIn.latestRound.price;\r\n        priceResult.priceOut = tokenGlobalOut.latestRound.price;\r\n\r\n        return (swapResult, priceResult);\r\n    }\r\n\r\n    function _getAmountInGivenOutMMMWithTimestamp(\r\n        Struct.TokenGlobal memory tokenGlobalIn,\r\n        Struct.TokenGlobal memory tokenGlobalOut,\r\n        uint256 tokenAmountOut,\r\n        uint256 timestamp\r\n    )\r\n    internal view\r\n    returns (Struct.SwapResult memory)\r\n    {\r\n        \r\n        Struct.SwapParameters memory swapParameters = Struct.SwapParameters(\r\n            tokenAmountOut,\r\n            _swapFee,\r\n            Const.FALLBACK_SPREAD\r\n        );\r\n        Struct.GBMParameters memory gbmParameters = Struct.GBMParameters(\r\n            _dynamicCoverageFeesZ,\r\n            _dynamicCoverageFeesHorizon\r\n        );\r\n        Struct.HistoricalPricesParameters memory hpParameters = Struct.HistoricalPricesParameters(\r\n            _priceStatisticsLookbackInRound,\r\n            _priceStatisticsLookbackInSec,\r\n            timestamp,\r\n            _priceStatisticsLookbackStepInRound\r\n        );\r\n\r\n        return Math.calcInGivenOutMMM(\r\n            tokenGlobalIn,\r\n            tokenGlobalOut,\r\n            ChainlinkUtils.getTokenRelativePrice(\r\n                        tokenGlobalIn.latestRound.price,\r\n                        tokenGlobalIn.info.decimals,\r\n                        tokenGlobalOut.latestRound.price,\r\n                        tokenGlobalOut.info.decimals\r\n            ),\r\n            swapParameters,\r\n            gbmParameters,\r\n            hpParameters\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Compute the token historical performance since pool's inception\r\n    * @param initialPrice The token's initial price\r\n    * @param latestPrice The token's latest price\r\n    * @return tokenGlobal The token historical performance since pool's inception\r\n    */\r\n    function _getTokenPerformance(uint256 initialPrice, uint256 latestPrice)\r\n    internal pure returns (uint256) {\r\n        return Num.div(\r\n            latestPrice,\r\n            initialPrice\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Retrieves the given token's latest oracle data.\r\n    * @dev We get:\r\n    * - latest round Id\r\n    * - latest price\r\n    * - latest round timestamp\r\n    * - token historical performance since pool's inception\r\n    * @param token The token's address\r\n    * @return tokenGlobal The latest tokenIn oracle data\r\n    */\r\n    function getTokenLatestInfo(address token)\r\n    internal view returns (Struct.TokenGlobal memory tokenGlobal) {\r\n        Record memory record = _records[token];\r\n        Struct.OracleState memory initialOracleState = _oraclesInitialState[token];\r\n        Struct.LatestRound memory latestRound = ChainlinkUtils.getLatestRound(initialOracleState.oracle);\r\n        Struct.TokenRecord memory info = Struct.TokenRecord(\r\n            record.decimals,\r\n            record.balance,\r\n            // we adjust the token's target weight (in value) based on its appreciation since the inception of the pool.\r\n            Num.mul(\r\n                record.denorm,\r\n                _getTokenPerformance(\r\n                    initialOracleState.price,\r\n                    latestRound.price\r\n                )\r\n            )\r\n        );\r\n        return (\r\n            tokenGlobal = Struct.TokenGlobal(\r\n                info,\r\n                latestRound\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @notice Returns all the binded token's global information (token record + latest round info)  \r\n    * @param swappedToken the address of the swapped token \r\n    * @return swappedTokenInfo swapped token's global information\r\n    * @return remainingTokensInfo remaining tokens' global information\r\n    */\r\n    function _getAllTokensInfo(address swappedToken)\r\n    private view returns (\r\n        Struct.TokenGlobal memory swappedTokenInfo,\r\n        Struct.TokenGlobal[] memory remainingTokensInfo\r\n    ) {\r\n\r\n        swappedTokenInfo = getTokenLatestInfo(swappedToken);\r\n\r\n        uint nRemainingTokens = _tokens.length - 1;\r\n        remainingTokensInfo = new Struct.TokenGlobal[](nRemainingTokens);\r\n        \r\n        // Extracting the remaining un-traded tokens' info\r\n        uint count;\r\n        for (uint i; count < nRemainingTokens;) {\r\n            if (_tokens[i] != swappedToken) {\r\n                remainingTokensInfo[count] = getTokenLatestInfo(_tokens[i]);\r\n                unchecked{++count;}\r\n            }\r\n            unchecked{++i;}\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n    * @notice Check if the spot prices falls within the limits of the oracle price\r\n    * - spot prices of the remaining tokens must be < oraclePrice * _maxPriceUnpegRatio\r\n    * @dev tokenInInfo.info.balance should contain the balance after the trade\r\n    * - spot prices of the remaining tokens are computed in terms of tokenIn\r\n    * @param tokenInInfo swapped token's info\r\n    * @param remainingTokensInfo remaining tokens' info\r\n    */\r\n    function _checkJoinSwapPrices (\r\n        Struct.TokenGlobal memory tokenInInfo,\r\n        Struct.TokenGlobal[] memory remainingTokensInfo\r\n    ) internal view {\r\n        \r\n        uint256 spotPriceAfter;\r\n\r\n        for (uint256 i; i < remainingTokensInfo.length;)\r\n        {\r\n            spotPriceAfter = Math.calcSpotPrice(\r\n                tokenInInfo.info.balance,\r\n                tokenInInfo.info.weight,\r\n                remainingTokensInfo[i].info.balance,\r\n                remainingTokensInfo[i].info.weight,\r\n                0\r\n            );\r\n\r\n            _require(\r\n                Num.div(\r\n                    spotPriceAfter,\r\n                    ChainlinkUtils.getTokenRelativePrice(\r\n                        tokenInInfo.latestRound.price,\r\n                        tokenInInfo.info.decimals,\r\n                        remainingTokensInfo[i].latestRound.price,\r\n                        remainingTokensInfo[i].info.decimals\r\n                    )\r\n                ) <= _maxPriceUnpegRatio,\r\n                Err.MAX_PRICE_UNPEG_RATIO\r\n            );\r\n            unchecked{++i;}\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice Check if the spot prices falls within the limits of the oracle price\r\n    * - spot price of tokenOut must be < oraclePrice * _maxPriceUnpegRatio\r\n    * @dev tokenOutInfo.info.balance should contain the balance after the trade\r\n    * - spot price of tokenOut is computed in terms of the remaining tokens independently\r\n    * @param tokenOutInfo swapped token's info\r\n    * @param remainingTokensInfo remaining tokens' info\r\n    */\r\n    function _checkExitSwapPrices (\r\n        Struct.TokenGlobal memory tokenOutInfo,\r\n        Struct.TokenGlobal[] memory remainingTokensInfo\r\n    ) internal view {\r\n        \r\n        uint256 spotPriceAfter;\r\n\r\n        for (uint256 i; i < remainingTokensInfo.length;)\r\n        {\r\n            spotPriceAfter = Math.calcSpotPrice(\r\n                remainingTokensInfo[i].info.balance,\r\n                remainingTokensInfo[i].info.weight,\r\n                tokenOutInfo.info.balance,\r\n                tokenOutInfo.info.weight,\r\n                0\r\n            );\r\n\r\n            _require(\r\n                Num.div(\r\n                    spotPriceAfter,\r\n                    ChainlinkUtils.getTokenRelativePrice(\r\n                        remainingTokensInfo[i].latestRound.price,\r\n                        remainingTokensInfo[i].info.decimals,\r\n                        tokenOutInfo.latestRound.price,\r\n                        tokenOutInfo.info.decimals\r\n                    )    \r\n                ) <= _maxPriceUnpegRatio,\r\n                Err.MAX_PRICE_UNPEG_RATIO\r\n            );\r\n            unchecked{++i;}\r\n        }\r\n    }\r\n\r\n    function _tryGetTokenDecimals(address token) internal view returns (uint8) {\r\n        try IDecimals(token).decimals() returns (uint8 d) {\r\n            return d;\r\n        } catch {}\r\n        return 0;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":true,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"sig\",\"type\":\"bytes4\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"LOG_CALL\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"name\":\"LOG_EXIT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"LOG_JOIN\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"LOG_NEW_CONTROLLER\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"decimals\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"}],\"name\":\"LOG_NEW_ORACLE_STATE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spread\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"taxBaseIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceOut\",\"type\":\"uint256\"}],\"name\":\"LOG_SWAP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"whom\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"denorm\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"priceFeedAddress\",\"type\":\"address\"}],\"name\":\"bindMMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"minAmountsOut\",\"type\":\"uint256[]\"}],\"name\":\"exitPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"}],\"name\":\"exitswapPoolAmountInMMM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"getAmountInGivenOutMMM\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spread\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxBaseIn\",\"type\":\"uint256\"}],\"internalType\":\"struct Struct.SwapResult\",\"name\":\"swapResult\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"spotPriceBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceOut\",\"type\":\"uint256\"}],\"internalType\":\"struct Struct.PriceResult\",\"name\":\"priceResult\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"getAmountOutGivenInMMM\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spread\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"taxBaseIn\",\"type\":\"uint256\"}],\"internalType\":\"struct Struct.SwapResult\",\"name\":\"swapResult\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"spotPriceBefore\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceOut\",\"type\":\"uint256\"}],\"internalType\":\"struct Struct.PriceResult\",\"name\":\"priceResult\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCoverageParameters\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"priceStatisticsLBInRound\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"priceStatisticsLBStepInRound\",\"type\":\"uint8\"},{\"internalType\":\"uint64\",\"name\":\"dynamicCoverageFeesZ\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"dynamicCoverageFeesHorizon\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceStatisticsLBInSec\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPriceUnpegRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDenormalizedWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountIn\",\"type\":\"uint256\"}],\"name\":\"getExitPool\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenAmountsOut\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"getJoinPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenAmountsIn\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"}],\"name\":\"getJoinswapExternAmountInMMM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"}],\"name\":\"getSpotPriceSansFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"spotPrice\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSwapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenOracleInitialPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenPriceOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"giveFactoryControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"gulp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"t\",\"type\":\"address\"}],\"name\":\"isBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPublicSwap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"maxAmountsIn\",\"type\":\"uint256[]\"}],\"name\":\"joinPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minPoolAmountOut\",\"type\":\"uint256\"}],\"name\":\"joinswapExternAmountInMMM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"poolAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint80\",\"name\":\"denorm\",\"type\":\"uint80\"},{\"internalType\":\"address\",\"name\":\"priceFeedAddress\",\"type\":\"address\"}],\"name\":\"rebindMMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revokeFactoryControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"}],\"name\":\"setControllerAndTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dynamicCoverageFeesHorizon\",\"type\":\"uint256\"}],\"name\":\"setDynamicCoverageFeesHorizon\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"dynamicCoverageFeesZ\",\"type\":\"uint64\"}],\"name\":\"setDynamicCoverageFeesZ\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPriceUnpegRatio\",\"type\":\"uint256\"}],\"name\":\"setMaxPriceUnpegRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"priceStatisticsLookbackInRound\",\"type\":\"uint8\"}],\"name\":\"setPriceStatisticsLookbackInRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"priceStatisticsLookbackInSec\",\"type\":\"uint256\"}],\"name\":\"setPriceStatisticsLookbackInSec\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"priceStatisticsLookbackStepInRound\",\"type\":\"uint8\"}],\"name\":\"setPriceStatisticsLookbackStepInRound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"publicSwap\",\"type\":\"bool\"}],\"name\":\"setPublicSwap\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"swapFee\",\"type\":\"uint256\"}],\"name\":\"setSwapFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountInMMM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPrice\",\"type\":\"uint256\"}],\"name\":\"swapExactAmountOutMMM\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spotPriceAfter\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"src\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dst\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingController\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"unbindMMM\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Pool", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "Math:3f572c24d371c289578f76e5bb8b74e3473828a8", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0500981b356ba740425f7cf6c845a7370658dabbfb717b848962643ac68617f6"}