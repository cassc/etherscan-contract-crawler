{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\\n     * 0 before setting it to a non-zero value.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721Receiver.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC721Receiver} interface.\\n *\\n * Accepts all token transfers.\\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\\n */\\ncontract ERC721Holder is IERC721Receiver {\\n    /**\\n     * @dev See {IERC721Receiver-onERC721Received}.\\n     *\\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/NFTLootbox.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol\\\";\\n\\n/// Local imports\\nimport \\\"./random/VRFv2Consumer.sol\\\";\\n\\n/**\\n * @title NFTLootbox\\n * @notice A smart contract for creating and managing lootboxes containing NFTs and USD prizes.\\n * Players can participate in the lootbox game by paying a fee and have a chance to win NFTs or USD prizes.\\n * The contract uses Chainlink VRF (Verifiable Random Function) to generate random numbers for determining the winners.\\n */\\ncontract NFTLootbox is Ownable, ERC721Holder {\\n    error PrizeMissing();\\n    error InvalidProbabilitiesSum(uint256 expectedMaxValue, uint256 actual);\\n    error InvalidProbabilitiesCount(uint256 expected, uint256 actual);\\n    error InvalidLootboxDuration(uint256 maxValue, uint256 actual);\\n    error OutOfRangeBet(uint256 minValue, uint256 maxValue);\\n    error ClosedLootbox(uint256 lootboxId);\\n    error LootboxNotClosed(uint256 lootboxId);\\n    error InsufficientLootboxBalance();\\n    error InvalidLootbox();\\n    error NotFulfilled();\\n    error PrizeNotWon();\\n    error WinNotClaimed();\\n    error ActivePlayersExceed();\\n\\n    struct Lootbox {\\n        uint256 finishTs;\\n        uint256 priceForPlay;\\n        NFT[] nftTokens;\\n        uint256[] usdPrizes;\\n        uint256[] probabilities;\\n        string name;\\n    }\\n\\n    struct NFT {\\n        address contractAddress;\\n        uint256 tokenId;\\n    }\\n\\n    struct BetDetail {\\n        uint256 betNum;\\n        uint256 lootboxId;\\n        uint256 randomNumRequestId;\\n    }\\n\\n    using SafeERC20 for IERC20;\\n\\n    uint256 constant MAX_PROBABILITY = 100000;\\n    uint256 constant LOOTBOX_MAX_DURATION = 10 days;\\n    uint256 constant FULFILL_PHASE = 600; // 10 minutes\\n    uint256 constant MAX_ACTIVE_PLAYERS = 200;\\n    IERC20 public betCoin;\\n    VRFv2Consumer public vrfV2Consumer;\\n    uint256 public lastLootboxId;\\n\\n    address[] public activePlayers;\\n    mapping(address => uint256) public lockedPrizes;\\n    mapping(uint256 => Lootbox) public lootboxes;\\n    mapping(address => BetDetail) public betDetails;\\n\\n    event LootboxCreated(\\n        uint256 _priceForPlay,\\n        uint256 indexed _lootboxId,\\n        uint256 _finishTS,\\n        string _name,\\n        NFT[] nfts,\\n        uint256[] prizes,\\n        uint256[] probabilities\\n    );\\n    event Play(\\n        address indexed _player,\\n        uint256 _timestamp,\\n        uint256 _priceForPlay,\\n        uint256 indexed _lootboxId\\n    );\\n    event TakenNft(\\n        address indexed _user,\\n        address contractAddress,\\n        uint256 _tokenId,\\n        uint256 indexed _lootboxId,\\n        uint256 _timeStamp\\n    );\\n    event TakenUsd(\\n        address indexed _user,\\n        uint256 _amount,\\n        uint256 _timeStamp,\\n        uint256 indexed _lootboxId\\n    );\\n    event BetCoinChanged(IERC20 _betCoin);\\n\\n    /**\\n     * @dev Constructor function\\n     * @param _betCoin The address of the ERC20 token used for betting\\n     * @param _vrfV2Consumer The address of the new VRFv2Consumer contract\\n     */\\n    constructor(IERC20 _betCoin, VRFv2Consumer _vrfV2Consumer) {\\n        betCoin = _betCoin;\\n        vrfV2Consumer = _vrfV2Consumer;\\n    }\\n\\n    /**\\n     * @dev Changes the address of the ERC20 token used for betting.\\n     * @param _betCoin The address of the new ERC20 token.\\n     * Emits a `BetCoinChanged` event indicating the change in ERC20 token address.\\n     */\\n    function changeBetCoin(IERC20 _betCoin) external onlyOwner {\\n        for (uint256 i = lastLootboxId; i > 0; --i) {\\n            if (lootboxes[i].finishTs > block.timestamp) {\\n                revert LootboxNotClosed(i);\\n            }\\n            if (\\n                lootboxes[i].finishTs + LOOTBOX_MAX_DURATION < block.timestamp\\n            ) {\\n                break;\\n            }\\n        }\\n        betCoin = _betCoin;\\n        emit BetCoinChanged(_betCoin);\\n    }\\n\\n    /**\\n     * @dev Creates a new lootbox with the specified parameters\\n     * @param _priceForPlay The price in betCoin to play the lootbox\\n     * @param _duration The duration of the lootbox in seconds\\n     * @param _name The name of the lootbox\\n     * @param nfts An array of NFTs to be included in the lootbox\\n     * @param prizes An array of USD prizes to be included in the lootbox\\n     * @param _probabilities An array of probabilities corresponding to the NFTs and USD prizes.\\n     * Each number in the array represents the probability of winning the corresponding prize and is\\n     * expressed as a value between 1 and 100000.\\n     * The range of 1-100000 corresponds to a probability range of 0.001% to 100%, where a higher number\\n     * indicates a higher probability of winning the associated prize.\\n     */\\n    function createLootbox(\\n        uint256 _priceForPlay,\\n        uint256 _duration,\\n        string calldata _name,\\n        NFT[] calldata nfts,\\n        uint256[] calldata prizes,\\n        uint256[] calldata _probabilities\\n    ) external onlyOwner {\\n        if (nfts.length + prizes.length == 0) {\\n            revert PrizeMissing();\\n        }\\n        if (nfts.length + prizes.length != _probabilities.length) {\\n            revert InvalidProbabilitiesCount(\\n                nfts.length + prizes.length,\\n                _probabilities.length\\n            );\\n        }\\n        uint256 maxProbability;\\n        for (uint256 i; i < _probabilities.length; ++i) {\\n            maxProbability += _probabilities[i];\\n        }\\n        if (maxProbability > MAX_PROBABILITY) {\\n            revert InvalidProbabilitiesSum(MAX_PROBABILITY, maxProbability);\\n        }\\n        if (_duration > LOOTBOX_MAX_DURATION) {\\n            revert InvalidLootboxDuration(LOOTBOX_MAX_DURATION, _duration);\\n        }\\n        ++lastLootboxId;\\n        Lootbox storage loot = lootboxes[lastLootboxId];\\n        for (uint256 i; i < nfts.length; ++i) {\\n            IERC721(nfts[i].contractAddress).safeTransferFrom(\\n                msg.sender,\\n                address(this),\\n                nfts[i].tokenId\\n            );\\n            loot.nftTokens.push(nfts[i]);\\n        }\\n        loot.usdPrizes = prizes;\\n        loot.probabilities = _probabilities;\\n        loot.priceForPlay = _priceForPlay;\\n        loot.name = _name;\\n        loot.finishTs = block.timestamp + _duration;\\n        emit LootboxCreated(\\n            _priceForPlay,\\n            lastLootboxId,\\n            loot.finishTs,\\n            _name,\\n            nfts,\\n            prizes,\\n            _probabilities\\n        );\\n    }\\n\\n    /**\\n     * @dev Allows a player to participate in a lootbox game\\n     * Players need to pay the priceForPlay in betCoin to play the lootbox.\\n     * If they win, they will receive a randomly selected NFT or a USD prize.\\n     * @param _lootboxId The ID of the lootbox to play.\\n     * @param _betNum The bet number, must be between 1 and 25.\\n     */\\n    function play(uint256 _lootboxId, uint256 _betNum) external {\\n        if (_betNum == 0 || _betNum > 25) {\\n            revert OutOfRangeBet(1, 25);\\n        }\\n        uint256 lootBoxMaxPrize = getLootboxMaxPrize(_lootboxId);\\n        Lootbox storage loot = lootboxes[_lootboxId];\\n        if (loot.finishTs < block.timestamp) {\\n            revert ClosedLootbox(_lootboxId);\\n        }\\n        if (\\n            lootBoxMaxPrize + updateLockedPrizes() >\\n            betCoin.balanceOf(address(this)) + loot.priceForPlay\\n        ) {\\n            revert InsufficientLootboxBalance();\\n        }\\n        (bool fulfilled, bool isWin, , , ) = checkWin(msg.sender);\\n        if (!fulfilled || isWin) {\\n            revert WinNotClaimed();\\n        }\\n        if (activePlayers.length >= MAX_ACTIVE_PLAYERS) {\\n            revert ActivePlayersExceed();\\n        }\\n        betCoin.safeTransferFrom(msg.sender, address(this), loot.priceForPlay);\\n        activePlayers.push(msg.sender);\\n        lockedPrizes[msg.sender] = lootBoxMaxPrize;\\n        BetDetail storage bet = betDetails[msg.sender];\\n        bet.betNum = _betNum;\\n        bet.lootboxId = _lootboxId;\\n        bet.randomNumRequestId = vrfV2Consumer.requestRandomWords();\\n        emit Play(msg.sender, block.timestamp, loot.priceForPlay, _lootboxId);\\n    }\\n\\n    /**\\n     * @dev Claims the prize for the player\\n     */\\n    function getPrize() external {\\n        (\\n            ,\\n            bool isWin,\\n            bool isNft,\\n            uint256 winIndex,\\n            uint256 lootboxId\\n        ) = checkWin(msg.sender);\\n        if (!isWin) {\\n            revert PrizeNotWon();\\n        }\\n        Lootbox storage loot = lootboxes[lootboxId];\\n        if (isNft) {\\n            NFT storage _nft = loot.nftTokens[winIndex];\\n            IERC721 token = IERC721(_nft.contractAddress);\\n            token.safeTransferFrom(address(this), msg.sender, _nft.tokenId);\\n            loot.finishTs = block.timestamp;\\n            emit TakenNft(\\n                msg.sender,\\n                _nft.contractAddress,\\n                _nft.tokenId,\\n                lootboxId,\\n                block.timestamp\\n            );\\n        } else {\\n            betCoin.safeTransfer(\\n                msg.sender,\\n                loot.usdPrizes[winIndex - loot.nftTokens.length]\\n            );\\n            emit TakenUsd(\\n                msg.sender,\\n                loot.usdPrizes[winIndex - loot.nftTokens.length],\\n                block.timestamp,\\n                lootboxId\\n            );\\n        }\\n        delete betDetails[msg.sender];\\n    }\\n\\n    /**\\n     * @dev Withdraws ERC20 tokens from the contract\\n     * @param _tokenAddress The address of the ERC20 token\\n     * @param _amount The amount of tokens to withdraw\\n     */\\n    function withdrawERC20(\\n        IERC20 _tokenAddress,\\n        uint256 _amount\\n    ) external onlyOwner {\\n        uint256 _lockedPrizes = updateLockedPrizes();\\n        if (\\n            _tokenAddress == betCoin &&\\n            _lockedPrizes + _amount > _tokenAddress.balanceOf(address(this))\\n        ) {\\n            revert InsufficientLootboxBalance();\\n        }\\n        uint256 initialBalance = betCoin.balanceOf(address(this));\\n        _tokenAddress.safeTransfer(msg.sender, _amount);\\n        uint256 finalBalance = betCoin.balanceOf(address(this));\\n        if (\\n            initialBalance != finalBalance &&\\n            _tokenAddress != betCoin &&\\n            _lockedPrizes > finalBalance\\n        ) {\\n            revert InsufficientLootboxBalance();\\n        }\\n    }\\n\\n    /**\\n     * @dev Withdraws ERC721 tokens from the contract\\n     * @param _tokenAddress The address of the ERC721 token\\n     * @param _tokenId The ID of the ERC721 token to withdraw\\n     * @param _lootboxId The ID of the lootbox associated with the token\\n     */\\n    function withdrawERC721(\\n        IERC721 _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _lootboxId\\n    ) external onlyOwner {\\n        if (lootboxes[_lootboxId].finishTs + FULFILL_PHASE > block.timestamp) {\\n            revert LootboxNotClosed(_lootboxId);\\n        }\\n        if (!checkLootboxId(address(_tokenAddress), _tokenId, _lootboxId)) {\\n            revert InvalidLootbox();\\n        }\\n        if (checkNftWon(address(_tokenAddress), _tokenId, _lootboxId)) {\\n            revert WinNotClaimed();\\n        }\\n        _tokenAddress.safeTransferFrom(address(this), msg.sender, _tokenId);\\n        emit TakenNft(\\n            msg.sender,\\n            address(_tokenAddress),\\n            _tokenId,\\n            _lootboxId,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns the NFTs, USD prizes, and probabilities of a lootbox\\n     * @param _lootboxId The ID of the lootbox\\n     * @return _nfts The array of NFTs in the lootbox\\n     * @return _usdPrizes The array of USD prizes in the lootbox\\n     * @return _probabilities The array of probabilities corresponding to the prizes\\n     */\\n    function getLootboxPrizesAndProbabilities(\\n        uint256 _lootboxId\\n    )\\n        external\\n        view\\n        returns (\\n            NFT[] memory _nfts,\\n            uint256[] memory _usdPrizes,\\n            uint256[] memory _probabilities\\n        )\\n    {\\n        Lootbox storage loot = lootboxes[_lootboxId];\\n        _nfts = loot.nftTokens;\\n        _usdPrizes = loot.usdPrizes;\\n        _probabilities = loot.probabilities;\\n    }\\n\\n    /**\\n     * @dev Returns the random number generated by VRF for a given request ID\\n     * @param _randomNumRequestId The request ID for the random number\\n     * @return fulfilled True if random num fulfilled\\n     * @return randNum The generated random number\\n     */\\n    function getRandomNumVRF(\\n        uint256 _randomNumRequestId\\n    ) public view returns (bool fulfilled, uint256 randNum) {\\n        (fulfilled, randNum) = vrfV2Consumer.getRequestStatus(\\n            _randomNumRequestId\\n        );\\n    }\\n\\n    /**\\n     * @dev Checks if a player has won in a bet and provides additional details\\n     * @param player The address of the player\\n     * @return fulfilled True if random num fulfilled\\n     * @return isWin True if the player has won, false otherwise\\n     * @return isNft True if the player has won an NFT prize, false otherwise\\n     * @return winIndex The index of the winning prize\\n     * @return lootboxId The ID of the lootbox associated with the bet\\n     */\\n    function checkWin(\\n        address player\\n    )\\n        public\\n        view\\n        returns (\\n            bool fulfilled,\\n            bool isWin,\\n            bool isNft,\\n            uint256 winIndex,\\n            uint256 lootboxId\\n        )\\n    {\\n        BetDetail storage bet = betDetails[player];\\n        lootboxId = bet.lootboxId;\\n\\n        // If the player hasn't made a bet, return false and the lootbox ID\\n        if (bet.randomNumRequestId == 0) {\\n            return (true, false, false, 0, lootboxId);\\n        }\\n        uint256 randomNumber;\\n        (fulfilled, randomNumber) = getRandomNumVRF(bet.randomNumRequestId);\\n        if (!fulfilled) {\\n            return (fulfilled, false, false, 0, lootboxId);\\n        }\\n        Lootbox storage loot = lootboxes[bet.lootboxId];\\n        uint256 prizesCount = loot.nftTokens.length + loot.usdPrizes.length;\\n\\n        // Generate a random number based on the player's bet\\n        randomNumber += bet.betNum;\\n\\n        // Modulo operation to ensure the number is within the range of 0 to 99,999 (inclusive),\\n        // corresponding to the entire probability range from 0.001% to 100%.\\n        // This allows for a fair distribution of random numbers across the entire probability spectrum.\\n        randomNumber %= MAX_PROBABILITY;\\n\\n        // Get the index of the prize won by the player\\n        winIndex = getPrizeIndex(lootboxId, randomNumber);\\n\\n        // Check if the player has won a prize\\n        if (winIndex < prizesCount) {\\n            isWin = true;\\n            if (winIndex < loot.nftTokens.length) {\\n                NFT storage _nft = lootboxes[lootboxId].nftTokens[winIndex];\\n                IERC721 token = IERC721(_nft.contractAddress);\\n                if (token.ownerOf(_nft.tokenId) != address(this)) {\\n                    return (true, false, false, 0, lootboxId);\\n                }\\n                isNft = true;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the index of the prize based on the generated random number and the probabilities\\n     * @param _lootboxId The ID of the lootbox\\n     * @param _randomNumber The generated random number\\n     * @return The index of the prize\\n     */\\n    function getPrizeIndex(\\n        uint256 _lootboxId,\\n        uint256 _randomNumber\\n    ) public view returns (uint256) {\\n        uint256[] storage _probabilities = lootboxes[_lootboxId].probabilities;\\n        uint256 sum;\\n\\n        // Calculate the cumulative sum of probabilities and find the winning prize\\n        for (uint256 i; i < _probabilities.length; ++i) {\\n            sum += _probabilities[i];\\n            if (_randomNumber <= sum) {\\n                return i;\\n            }\\n        }\\n\\n        // If no prize is won, return a missing prize index (100001)\\n        return MAX_PROBABILITY + 1;\\n    }\\n\\n    /**\\n     * @dev Returns the maximum prize amount among NFTs and USD prizes in a lootbox\\n     * @param _lootboxId The ID of the lootbox\\n     * @return maxPrize The maximum prize amount\\n     */\\n    function getLootboxMaxPrize(\\n        uint256 _lootboxId\\n    ) public view returns (uint256 maxPrize) {\\n        Lootbox storage loot = lootboxes[_lootboxId];\\n        for (uint256 i; i < loot.usdPrizes.length; ++i) {\\n            if (loot.usdPrizes[i] > maxPrize) {\\n                maxPrize = loot.usdPrizes[i];\\n            }\\n        }\\n        return maxPrize;\\n    }\\n\\n    /**\\n     * @dev Checks if a given NFT is included in a specific lootbox\\n     * @param _tokenAddress The address of the NFT contract\\n     * @param _tokenId The ID of the NFT\\n     * @param _lootboxId The ID of the lootbox\\n     * @return True if the NFT is included in the lootbox, false otherwise\\n     */\\n    function checkLootboxId(\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _lootboxId\\n    ) public view returns (bool) {\\n        NFT[] storage _nfts = lootboxes[_lootboxId].nftTokens;\\n        for (uint256 i; i < _nfts.length; ++i) {\\n            if (\\n                _nfts[i].contractAddress == _tokenAddress &&\\n                _nfts[i].tokenId == _tokenId\\n            ) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /**\\n     * @notice Updates the locked prizes for a specific player in a bet of a lootbox.\\n     */\\n    function updateLockedPrizes() internal returns (uint256) {\\n        bool win;\\n        bool fulfilled;\\n        bool isNft;\\n        uint256 winAmount;\\n        for (uint256 i = 0; i < activePlayers.length; ) {\\n            (fulfilled, win, , , ) = checkWin(activePlayers[i]);\\n            if (fulfilled && !win) {\\n                delete lockedPrizes[activePlayers[i]];\\n                activePlayers[i] = activePlayers[activePlayers.length - 1];\\n                activePlayers.pop();\\n            } else if (isNft) {\\n                ++i;\\n            } else {\\n                winAmount += lockedPrizes[activePlayers[i]];\\n                ++i;\\n            }\\n        }\\n        return winAmount;\\n    }\\n\\n    /**\\n     * @notice Checks if a specific player has won an NFT prize in a bet of a lootbox.\\n     * @return A boolean value indicating whether the player has won an NFT prize.\\n     */\\n    function checkNftWon(\\n        address _tokenAddress,\\n        uint256 _tokenId,\\n        uint256 _lootboxId\\n    ) internal view returns (bool) {\\n        bool isNft;\\n        uint256 winIndex;\\n        uint256 lootboxId;\\n        for (uint256 i = 0; i < activePlayers.length; ++i) {\\n            (, , isNft, winIndex, lootboxId) = checkWin(activePlayers[i]);\\n            if (isNft && lootboxId == _lootboxId) {\\n                NFT storage _nft = lootboxes[lootboxId].nftTokens[winIndex];\\n                if (\\n                    _nft.contractAddress == _tokenAddress &&\\n                    _nft.tokenId == _tokenId\\n                ) {\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/random/VRFv2Consumer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// An example of a consumer contract that relies on a subscription for funding.\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\\\";\\r\\n\\r\\ncontract VRFv2Consumer is VRFConsumerBaseV2, ConfirmedOwner {\\r\\n    error RequestNotFound(uint256 requestId);\\r\\n    error UnauthorizedAccess(address account);\\r\\n    error AdminAlreadySet();\\r\\n\\r\\n    struct RequestStatus {\\r\\n        bool fulfilled; // whether the request has been successfully fulfilled\\r\\n        bool exists; // whether a requestId exists\\r\\n        uint256 randomWord;\\r\\n    }\\r\\n\\r\\n    // Depends on the number of requested values that you want sent to the\\r\\n    // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\\r\\n    // so 100,000 is a safe default for this contract.\\r\\n    uint32 internal constant CALLBACK_GAS_LIMIT = 100000;\\r\\n\\r\\n    uint32 internal constant NUM_WORDS = 1;\\r\\n\\r\\n    // Your subscription ID.\\r\\n    uint64 internal subscriptionId;\\r\\n    VRFCoordinatorV2Interface internal coordinator;\\r\\n\\r\\n    uint16 public requestConfirmations;\\r\\n    bytes32 public keyHash;\\r\\n\\r\\n    // past requestStatuses Id.\\r\\n    uint256[] public requestIds;\\r\\n    uint256 public lastRequestId;\\r\\n\\r\\n    address public admin;\\r\\n    mapping(uint256 => RequestStatus) public requestStatuses;\\r\\n\\r\\n    event RequestSent(uint256 requestId, uint32 NUM_WORDS);\\r\\n    event RequestFulfilled(uint256 requestId, uint256[] randomWords);\\r\\n    event AdminSet(address admin);\\r\\n    event KeyHashChanged(bytes32 keyHash);\\r\\n    event RequestConfirmationsChanged(uint16 requestConfirmations);\\r\\n\\r\\n    /**\\r\\n     * @dev Contract constructor.\\r\\n     * @param _subscriptionId The subscription ID.\\r\\n     * @param _keyHash The key hash for generating random numbers.\\r\\n     * @param _coordinator The address of the VRF coordinator.\\r\\n     */\\r\\n    constructor(\\r\\n        uint64 _subscriptionId,\\r\\n        uint16 _requestConfirmations,\\r\\n        bytes32 _keyHash,\\r\\n        address _coordinator\\r\\n    ) VRFConsumerBaseV2(_coordinator) ConfirmedOwner(msg.sender) {\\r\\n        coordinator = VRFCoordinatorV2Interface(_coordinator);\\r\\n        subscriptionId = _subscriptionId;\\r\\n        requestConfirmations = _requestConfirmations;\\r\\n        keyHash = _keyHash;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        if (admin != msg.sender) {\\r\\n            revert UnauthorizedAccess(msg.sender);\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Changes the key hash for generating random numbers.\\r\\n     * @param _keyHash The new key hash.\\r\\n     * Emits a `KeyHashChanged` event indicating the change in key hash.\\r\\n     */\\r\\n    function changeKeyHash(bytes32 _keyHash) external onlyOwner {\\r\\n        keyHash = _keyHash;\\r\\n        emit KeyHashChanged(_keyHash);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Changes the request confirmations amount for generating random numbers.\\r\\n     * @param _requestConfirmations The new request confirmations amount.\\r\\n     * Emits a `RequestConfirmationsChanged` event indicating the change in request confirmations.\\r\\n     */\\r\\n    function changeRequestConfirmations(uint16 _requestConfirmations) external onlyOwner {\\r\\n        requestConfirmations = _requestConfirmations;\\r\\n        emit RequestConfirmationsChanged(_requestConfirmations);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the admin address for the contract.\\r\\n     * @dev Only the contract owner can call this function.\\r\\n     * @param _admin The address to set as the admin.\\r\\n     * @dev If the admin address has already been set, the function reverts.\\r\\n     * @dev Emits an `AdminSet` event upon successful execution.\\r\\n     */\\r\\n    function setAdmin(address _admin) external onlyOwner {\\r\\n        if(admin != address(0)){\\r\\n            revert AdminAlreadySet();\\r\\n        }\\r\\n        admin = _admin;\\r\\n        emit AdminSet(_admin);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Requests random words from the VRF coordinator.\\r\\n     * Assumes the subscription is funded sufficiently.\\r\\n     * Only callable by admins.\\r\\n     * @return requestId The ID of the request.\\r\\n     */\\r\\n    function requestRandomWords()\\r\\n        external\\r\\n        onlyAdmin\\r\\n        returns (uint256 requestId)\\r\\n    {\\r\\n        // Will revert if subscription is not set and funded.\\r\\n        requestId = coordinator.requestRandomWords(\\r\\n            keyHash,\\r\\n            subscriptionId,\\r\\n            requestConfirmations,\\r\\n            CALLBACK_GAS_LIMIT,\\r\\n            NUM_WORDS\\r\\n        );\\r\\n        requestStatuses[requestId] = RequestStatus({\\r\\n            randomWord: 0,\\r\\n            exists: true,\\r\\n            fulfilled: false\\r\\n        });\\r\\n        requestIds.push(requestId);\\r\\n        lastRequestId = requestId;\\r\\n        emit RequestSent(requestId, NUM_WORDS);\\r\\n        return requestId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal callback function to fulfill random words received from the VRF coordinator.\\r\\n     * @param _requestId The ID of the request.\\r\\n     * @param _randomWords The array of random words.\\r\\n     */\\r\\n    function fulfillRandomWords(\\r\\n        uint256 _requestId,\\r\\n        uint256[] memory _randomWords\\r\\n    ) internal override {\\r\\n        if (!requestStatuses[_requestId].exists) {\\r\\n            revert RequestNotFound(_requestId);\\r\\n        }\\r\\n        requestStatuses[_requestId].fulfilled = true;\\r\\n        requestStatuses[_requestId].randomWord = _randomWords[0];\\r\\n        emit RequestFulfilled(_requestId, _randomWords);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieves the status of a request.\\r\\n     * @param _requestId The ID of the request.\\r\\n     * @return fulfilled Whether the request has been fulfilled.\\r\\n     * @return randomWord The random word associated with the request.\\r\\n     */\\r\\n    function getRequestStatus(\\r\\n        uint256 _requestId\\r\\n    ) external view returns (bool fulfilled, uint256 randomWord) {\\r\\n        if (!requestStatuses[_requestId].exists) {\\r\\n            revert RequestNotFound(_requestId);\\r\\n        }\\r\\n        RequestStatus storage request = requestStatuses[_requestId];\\r\\n        return (request.fulfilled, request.randomWord);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_betCoin\",\"type\":\"address\"},{\"internalType\":\"contract VRFv2Consumer\",\"name\":\"_vrfV2Consumer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ActivePlayersExceed\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lootboxId\",\"type\":\"uint256\"}],\"name\":\"ClosedLootbox\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLootboxBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLootbox\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InvalidLootboxDuration\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expected\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InvalidProbabilitiesCount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"expectedMaxValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InvalidProbabilitiesSum\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lootboxId\",\"type\":\"uint256\"}],\"name\":\"LootboxNotClosed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotFulfilled\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxValue\",\"type\":\"uint256\"}],\"name\":\"OutOfRangeBet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrizeMissing\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PrizeNotWon\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WinNotClaimed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"_betCoin\",\"type\":\"address\"}],\"name\":\"BetCoinChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_priceForPlay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_finishTS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct NFTLootbox.NFT[]\",\"name\":\"nfts\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"prizes\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"probabilities\",\"type\":\"uint256[]\"}],\"name\":\"LootboxCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_player\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_priceForPlay\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"}],\"name\":\"Play\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"}],\"name\":\"TakenNft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_timeStamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"}],\"name\":\"TakenUsd\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"activePlayers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"betCoin\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"betDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"betNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootboxId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"randomNumRequestId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_betCoin\",\"type\":\"address\"}],\"name\":\"changeBetCoin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"}],\"name\":\"checkLootboxId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"}],\"name\":\"checkWin\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWin\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isNft\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"winIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lootboxId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceForPlay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_duration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTLootbox.NFT[]\",\"name\":\"nfts\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"prizes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_probabilities\",\"type\":\"uint256[]\"}],\"name\":\"createLootbox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"}],\"name\":\"getLootboxMaxPrize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxPrize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"}],\"name\":\"getLootboxPrizesAndProbabilities\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct NFTLootbox.NFT[]\",\"name\":\"_nfts\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_usdPrizes\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_probabilities\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPrize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_randomNumber\",\"type\":\"uint256\"}],\"name\":\"getPrizeIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_randomNumRequestId\",\"type\":\"uint256\"}],\"name\":\"getRandomNumVRF\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"randNum\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastLootboxId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockedPrizes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lootboxes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finishTs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceForPlay\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_betNum\",\"type\":\"uint256\"}],\"name\":\"play\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vrfV2Consumer\",\"outputs\":[{\"internalType\":\"contract VRFv2Consumer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lootboxId\",\"type\":\"uint256\"}],\"name\":\"withdrawERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NFTLootbox", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f00000000000000000000000018e91bdf84d24e285bc87923ae9339e53ce7feee", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}