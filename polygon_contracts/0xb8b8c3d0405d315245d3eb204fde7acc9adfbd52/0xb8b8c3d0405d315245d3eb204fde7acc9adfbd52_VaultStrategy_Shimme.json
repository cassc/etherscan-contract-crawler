{"SourceCode": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity ^0.8.0;\r\n\r\n//File: [IERC20Permit.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n//File: [Address.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\r\n\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n//File: [ITest_SmartChef.sol]\r\n\r\ninterface ITest_SmartChef\r\n{\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    function rewardToken() external view returns (address);\r\n    function depositToken() external view returns (address);\r\n\r\n    function rewardPerClaim() external view returns (uint256);\r\n\r\n    function userInfo(address _user) external view returns (uint256);\r\n\r\n    function totalDeposit() external view returns (uint256);\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf(address _user) external view returns (uint256);\r\n    function pendingReward(address _user) external view returns (uint256);\r\n\r\n    //========================\r\n    // DEPOSIT / WITHDRAW / CLAIM FUNCTIONS\r\n    //========================\r\n\r\n    function deposit(uint256 _amount) external;\r\n\r\n    function withdraw(uint256 _amount) external;\r\n    function emergencyWithdraw() external;\r\n\r\n    function claim() external;    \r\n}\r\n\r\n//File: [IMigrationManager.sol]\r\n\r\ninterface IMigrationManager\r\n{\r\n    //========================\r\n    // MIGRATION FUNCTIONS\r\n    //========================\r\n\r\n    function requestMigration(address _user, string memory _topic) external returns (uint256);\r\n    function cancelMigration(address _user, uint256 _id) external;\r\n    function executeMigration(address _user, uint256 _id) external returns (bool);\r\n}\r\n\r\n//File: [ML_ProtectedBalance.sol]\r\n\r\ncontract ML_ProtectedBalance\r\n{\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    mapping(address => uint256) private protectedBalances;\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\r\n    function getProtectedBalance(address _asset) internal view returns (uint256)\r\n    {\r\n        return protectedBalances[_asset];\r\n    }\r\n\r\n    //========================\r\n    // FUNCTIONS\r\n    //========================\r\n\r\n    function increaseProtectedBalance(address _asset, uint256 _amount) internal\r\n    {\r\n        protectedBalances[_asset] += _amount;\r\n    }\r\n\r\n    function decreaseProtectedBalance(address _asset, uint256 _amount) internal\r\n    {\r\n        protectedBalances[_asset] -= _amount;\r\n    }\r\n\r\n    function resetProtectedBalance(address _asset) internal\r\n    {\r\n        protectedBalances[_asset] = 0;\r\n    }\r\n}\r\n\r\n//File: [Context.sol]\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n//File: [IRouter.sol]\r\n\r\ninterface IUniRouterV1\r\n{\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IUniRouterV2 is IUniRouterV1\r\n{\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}\r\n\r\n//File: [IERC20.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n//File: [IMoonAccessManager.sol]\r\n\r\ninterface IMoonAccessManager\r\n{\r\n    //========================\r\n    // SECURITY FUNCTIONS\r\n    //========================\r\n\r\n    function requireAdmin(address _user) external view;\r\n    function requireManager(address _user) external view;\r\n    function requireSecurityAdmin(address _user) external view;\r\n    function requireSecurityMod(address _user) external view;\r\n    function requireDeployer(address _user) external view;    \r\n}\r\n\r\n//File: [IToken.sol]\r\n\r\ninterface IToken\r\n{\r\n\t//========================\r\n    // EVENTS FUNCTIONS\r\n    //========================\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n\t//========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\t\r\n\tfunction decimals() external view returns (uint8);\t\r\n\tfunction symbol() external view returns (string memory);\r\n\tfunction name() external view returns (string memory);\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction allowance(address owner, address spender) external view returns (uint256);\r\n\r\n\t//========================\r\n    // USER INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    //========================\r\n    // TRANSFER / APPROVE FUNCTIONS\r\n    //========================\r\n\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\tfunction transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);    \r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n}\r\n\r\n//File: [ML_TransferETH.sol]\r\n\r\ncontract ML_TransferETH\r\n{\r\n    //========================\r\n    // ATTRIBUTES\r\n    //======================== \r\n\r\n    uint256 public transferGas = 30000;\r\n\r\n    //========================\r\n    // CONFIG FUNCTIONS\r\n    //======================== \r\n\r\n    function _setTransferGas(uint256 _gas) internal\r\n    {\r\n        require(_gas >= 30000, \"Gas to low\");\r\n        require(_gas <= 250000, \"Gas to high\");\r\n        transferGas = _gas;\r\n    }\r\n\r\n    //========================\r\n    // TRANSFER FUNCTIONS\r\n    //======================== \r\n\r\n    function transferETH(address _to, uint256 _amount) internal\r\n    {\r\n        (bool success, ) = payable(_to).call{ value: _amount, gas: transferGas }(\"\");\r\n        success; //prevent warning\r\n    }\r\n}\r\n\r\n//File: [IRouterSwap.sol]\r\n\r\ncontract IRouterSwap\r\n{\r\n    //========================\r\n    // STRUCTS\r\n    //========================\r\n\r\n    struct SwapResult\r\n    {\r\n        uint256 fromBefore;     //balance of from-token, before swap\r\n        uint256 toBefore;       //balance of to-token, before swap\r\n        uint256 toAfter;        //balance of to-token, after swap\r\n        uint256 swapped;        //swapped amount of to-token\r\n    }\r\n}\r\n\r\n//File: [ITokenPair.sol]\r\n\r\ninterface ITokenPair is IToken\r\n{\t\r\n\t//========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\t\r\n\tfunction token0() external view returns (address);\t\r\n\tfunction token1() external view returns (address);\t\r\n\tfunction getReserves() external view returns (uint112, uint112, uint32);\t\r\n}\r\n\r\n//File: [Ownable.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n//File: [IWrappedCoin.sol]\r\n\r\ninterface IWrappedCoin is IToken\r\n{\r\n\tfunction deposit() external payable;\r\n    function withdraw(uint256 _amount) external;\r\n}\r\n\r\n//File: [IBank.sol]\r\n\r\ninterface IBank\r\n{  \r\n    //========================\r\n    // USER INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf(IToken _token, address _user) external view returns (uint256);\r\n    function allowance(IToken _token, address _user, address _spender) external view returns (uint256);\r\n    \r\n    //========================\r\n    // DEPOSIT FUNCTIONS\r\n    //========================\r\n\r\n    function depositETHFor(address _user) external payable;\r\n    function depositFor(IToken _token, address _user, uint256 _amount) external;\r\n\r\n    //========================\r\n    // TRANSFER FUNCTIONS\r\n    //========================\r\n\r\n    function transfer(IToken _token, address _from, address _to, uint256 _amount) external;\r\n    function transferToAccount(IToken _token, address _from, address _to, uint256 _amount) external;\r\n\r\n    //========================\r\n    // ALLOWANCE FUNCTIONS\r\n    //========================\r\n\r\n    function approve(IToken _token, address _spender, uint256 _amount) external;\r\n    function increaseAllowance(IToken _token, address _spender, uint256 _amount) external;\r\n    function decreaseAllowance(IToken _token, address _spender, uint256 _amount) external;\r\n}\r\n\r\n//File: [SafeERC20.sol]\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\r\n     * Revert on invalid signature.\r\n     */\r\n    function safePermit(\r\n        IERC20Permit token,\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) internal {\r\n        uint256 nonceBefore = token.nonces(owner);\r\n        token.permit(owner, spender, value, deadline, v, r, s);\r\n        uint256 nonceAfter = token.nonces(owner);\r\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return\r\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\r\n    }\r\n}\r\n\r\n//File: [IVaultPoolInfo.sol]\r\n\r\ninterface IVaultPoolInfo\r\n{\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    function depositToken() external view returns (address);\r\n    function rewardToken() external view returns (IToken);\r\n\r\n    function poolTotalDeposit() external view returns (uint256);   \r\n\r\n    function poolPending() external view returns (uint256);\r\n    function poolAllocPoints() external view returns (uint256);\r\n    function poolTotalAllocPoints() external view returns (uint256);  \r\n    function poolRewardEmission() external view returns (uint256);\r\n    function poolTotalRewardEmission() external view returns (uint256);    \r\n\r\n    function poolAdditionalReward_Pending(uint256 _rewardIndex) external view returns (uint256);\r\n    function poolAdditionalReward_AllocPoints(uint256 _rewardIndex) external view returns (uint256);\r\n    function poolAdditionalReward_TotalAllocPoints(uint256 _rewardIndex) external view returns (uint256);\r\n    function poolAdditionalReward_RewardEmission(uint256 _rewardIndex) external view returns (uint256);\r\n    function poolAdditionalReward_TotalRewardEmission(uint256 _rewardIndex) external view returns (uint256);\r\n\r\n    function poolBlockOrTime() external view returns (bool);\r\n    function poolDepositFee() external view returns (uint256);\r\n    function poolWithdrawFee() external view returns (uint256); \r\n    function poolStart() external view returns (uint256);\r\n    function poolEnd() external view returns (uint256);\r\n    function poolHarvestLockUntil() external view returns (uint256);\r\n    function poolHarvestLockDelay() external view returns (uint256);\r\n\r\n    //========================\r\n    // STATIC POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    function isPoolFarmable() external view returns (bool);\r\n    function poolPendingETH() external view returns (uint256);    \r\n    function poolCompoundRewardETH() external view returns (uint256);\r\n}\r\n\r\n//File: [VaultStrategy_withPoolInfo.sol]\r\n\r\n///@notice This contract defines the interface for all pool info\r\n///Should be overriden in strategy implementation.\r\n///Is optional but required for analytics.\r\nabstract contract VaultStrategy_withPoolInfo is\r\n    IVaultPoolInfo\r\n{\r\n    //========================\r\n    // REQUIRED POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice pending reward of the pool (including additional rewards)\r\n    function poolPending() public view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }    \r\n\r\n    ///@notice total alloc points of the pool provider (to calculate pool reward emission)\r\n    function poolTotalAllocPoints() public view virtual override returns (uint256)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    ///@notice alloc points of utilized pool (to calculate pool reward emission and check if active)\r\n    function poolAllocPoints() public view virtual override returns (uint256)\r\n    {\r\n        return 1;\r\n    }\r\n\r\n    ///@notice pool provider total reward emission (to calculate pool reward emission)\r\n    function poolTotalRewardEmission() public view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    ///@notice pool provider total deposit (to calculate pool reward emission)\r\n    function poolTotalDeposit() public view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    //========================\r\n    // OPTIONAL POOL ADDITIONAL REWARD INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice pending reward of the pool (including additional rewards)\r\n    function poolAdditionalReward_Pending(uint256 _rewardIndex) public view virtual override returns (uint256)\r\n    {\r\n        _rewardIndex;\r\n        return 0;\r\n    }    \r\n\r\n    ///@notice total alloc points of the pool provider (to calculate pool reward emission)\r\n    function poolAdditionalReward_TotalAllocPoints(uint256 _rewardIndex) public view virtual override returns (uint256)\r\n    {\r\n        _rewardIndex;\r\n        return 1;\r\n    }\r\n\r\n    ///@notice alloc points of utilized pool (to calculate pool reward emission and check if active)\r\n    function poolAdditionalReward_AllocPoints(uint256 _rewardIndex) public view virtual override returns (uint256)\r\n    {\r\n        _rewardIndex;\r\n        return 1;\r\n    }\r\n\r\n    ///@notice pool provider total reward emission (to calculate pool reward emission)\r\n    function poolAdditionalReward_TotalRewardEmission(uint256 _rewardIndex) public view virtual override returns (uint256)\r\n    {\r\n        _rewardIndex;\r\n        return 0;\r\n    }\r\n\r\n    //========================\r\n    // OPTIONAL POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice are rewards distributed per block (false) or per second (true)\r\n    function poolBlockOrTime() public view virtual override returns (bool)\r\n    {\r\n        return false; //block\r\n    }\r\n\r\n    ///@notice pool deposit fee (for frontend)\r\n    function poolDepositFee() external view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    ///@notice pool withdraw fee (for frontend)\r\n    function poolWithdrawFee() external view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    ///@notice start time/block of pool (optional, as we assume it already started)\r\n    function poolStart() public view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    ///@notice end time/block of pool (optional, to show end in frontend)\r\n    function poolEnd() public view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    ///@notice harvest lock until timestamp (lastHarvestTimestamp + harvestLockDelay)\r\n    function poolHarvestLockUntil() external view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    ///@notice harvest lock delay time\r\n    function poolHarvestLockDelay() external view virtual override returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    //========================\r\n    // STATIC POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice is farming still possible for pool\r\n    function isPoolFarmable() external view virtual override returns (bool)\r\n    {\r\n        return (poolRewardEmission() > 0); //simplified. If there is reward, it is farmable\r\n    }\r\n\r\n    ///@notice pool reward share for main reward (to estimate theoretical APR)\r\n    function poolRewardEmission() public view virtual override returns (uint256)\r\n    {\r\n        return (poolTotalRewardEmission() * poolAllocPoints()) / poolTotalAllocPoints();\r\n    }    \r\n\r\n    ///@notice pool provider total deposit (to calculate pool reward emission)\r\n    function poolAdditionalReward_RewardEmission(uint256 _rewardIndex) public view virtual override returns (uint256)\r\n    {\r\n        return (poolAdditionalReward_TotalRewardEmission(_rewardIndex)\r\n                * poolAdditionalReward_AllocPoints(_rewardIndex))\r\n            / poolAdditionalReward_TotalAllocPoints(_rewardIndex);\r\n    }\r\n}\r\n\r\n//File: [ML_RecoverFunds.sol]\r\n\r\ncontract ML_RecoverFunds is ML_TransferETH\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    //========================\r\n    // EMERGENCY FUNCTIONS\r\n    //======================== \r\n\r\n    function _recoverETH(uint256 _amount, address _to) internal\r\n    {\r\n        transferETH(_to, _amount);\r\n    }\r\n\r\n    function _recoverToken(IToken _token, uint256 _amount, address _to) internal\r\n    {\r\n        IERC20(address(_token)).safeTransfer(_to, _amount);\r\n    }  \r\n}\r\n\r\n//File: [ML_Transfer.sol]\r\n\r\nlibrary ML_Transfer\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    //========================\r\n    // ENUM FUNCTIONS\r\n    //========================\r\n\r\n    enum TokenType\r\n    {\r\n        ERC20\r\n    }\r\n\r\n    //========================\r\n    // TOKEN FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf_token(\r\n        address _token,\r\n        TokenType _type,\r\n        address _user\r\n    ) internal view returns (uint256)\r\n    {\r\n        if (_type == TokenType.ERC20)\r\n        {\r\n            return IERC20(_token).balanceOf(_user);\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    //========================\r\n    // ERC20 FUNCTIONS\r\n    //========================\r\n\r\n    function transferFrom_ERC20(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount        \r\n    ) internal\r\n    {\r\n        //transfer\r\n        IERC20(_token).safeTransferFrom(\r\n            _from, \r\n            _to, \r\n            _amount\r\n        );\r\n    }\r\n\r\n    function transfer_ERC20(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount        \r\n    ) internal\r\n    {\r\n        //transfer\r\n        IERC20(_token).safeTransfer(\r\n            _to, \r\n            _amount\r\n        );\r\n    }\r\n\r\n    function safeApprove_ERC20(\r\n        address _token, \r\n        address _spender, \r\n        uint256 _amount\r\n    ) internal\r\n    {\r\n        IERC20(_token).approve(_spender, 0); //first reset to 0 to be safe\r\n        if (_amount != 0)\r\n        {\r\n            IERC20(_token).approve(_spender, _amount);\r\n        }\r\n    }\r\n}\r\n\r\n//File: [IVaultConfig.sol]\r\n\r\ninterface IVaultConfig\r\n{\r\n    //========================\r\n    // CONSTANTS\r\n    //========================\r\n\r\n    function PERCENT_FACTOR() external view returns (uint256);\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n    \r\n    //fees\r\n    function feeReceiver() external view returns (address);\r\n    function compoundFee() external view returns (uint256);\r\n    function rewardFee() external view returns (uint256);\r\n    function payoutFee() external view returns (uint256);\r\n    function withdrawFee() external view returns (uint256);\r\n    function withdrawFeePeriod() external view returns (uint256);\r\n\r\n    //contracts\r\n    function getAccessManager() external view returns (IMoonAccessManager);\r\n    function migrationManager() external view returns (IMigrationManager);\r\n    function bank() external view returns (IBank);\r\n\r\n    //tokens\r\n    function wrappedCoin() external view returns (IWrappedCoin);\r\n}\r\n\r\n//File: [VaultConfigAccessRequest.sol]\r\n\r\nabstract contract VaultConfigAccessRequest\r\n{\r\n    //========================\r\n    // OVERRIDE FUNCTIONS\r\n    //========================\r\n\r\n    function getAccessManager() public virtual view returns (IMoonAccessManager);\r\n\r\n    //========================\r\n    // SECURITY FUNCTIONS                                                              \r\n    //========================\r\n\r\n    function requireAdmin() internal view\r\n    {\r\n        getAccessManager().requireAdmin(msg.sender);\r\n    }\r\n\r\n    function requireManager() internal view\r\n    {\r\n        getAccessManager().requireManager(msg.sender);\r\n    }\r\n\r\n    function requireDeployer() internal view\r\n    {\r\n        getAccessManager().requireDeployer(msg.sender);\r\n    }\r\n\r\n    function requireSecurityAdmin() internal view\r\n    {\r\n        getAccessManager().requireSecurityAdmin(msg.sender);\r\n    }\r\n\r\n    function requireSecurityMod() internal view\r\n    {\r\n        getAccessManager().requireSecurityMod(msg.sender);\r\n    }\r\n}\r\n\r\n//File: [ML_TransferWithInfo.sol]\r\n\r\nlibrary ML_TransferWithInfo\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using ML_Transfer for address;\r\n\r\n    //========================\r\n    // STRUCTS\r\n    //========================\r\n\r\n    struct TransferResult\r\n    {\r\n        uint256 fromBefore;     //balance of sender, before transfer\r\n        uint256 toBefore;       //balance of receiver, before transfer\r\n        uint256 toAfter;        //balance of receiver, after transfer\r\n        uint256 transferred;    //transferred amount \r\n    }\r\n\r\n    //========================\r\n    // ERC20 FUNCTIONS\r\n    //========================\r\n\r\n    function transferFromWithInfo_ERC20(\r\n        address _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _amount        \r\n    ) internal returns (TransferResult memory)\r\n    {\r\n        //init\r\n        TransferResult memory result = TransferResult(\r\n        {\r\n            fromBefore: IERC20(_token).balanceOf(_from),\r\n            toBefore: IERC20(_token).balanceOf(_to),\r\n            toAfter: 0,\r\n            transferred: 0\r\n        });\r\n\r\n        //transfer\r\n        _token.transferFrom_ERC20(\r\n            _from, \r\n            _to,            \r\n            _amount           \r\n        );\r\n\r\n        //process\r\n        result.toAfter = IERC20(_token).balanceOf(_to);\r\n        result.transferred = result.toAfter - result.toBefore;\r\n\r\n        return result;\r\n    }\r\n\r\n    function transferWithInfo_ERC20(\r\n        address _token,\r\n        address _to,\r\n        uint256 _amount        \r\n    ) internal returns (TransferResult memory)\r\n    {\r\n        //init\r\n        TransferResult memory result = TransferResult(\r\n        {\r\n            fromBefore: IERC20(_token).balanceOf(msg.sender),\r\n            toBefore: IERC20(_token).balanceOf(_to),\r\n            toAfter: 0,\r\n            transferred: 0\r\n        });\r\n\r\n        //transfer\r\n        _token.transfer_ERC20(\r\n            _to,\r\n            _amount            \r\n        );\r\n\r\n        //process\r\n        result.toAfter = IERC20(_token).balanceOf(_to);\r\n        result.transferred = result.toAfter - result.toBefore;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n//File: [ML_RouterSwap_UniSwapV2.sol]\r\n\r\ncontract ML_RouterSwap_UniSwapV2 is\r\n    IRouterSwap\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using ML_Transfer for address;\r\n\r\n    //========================\r\n    // FUNCTIONS\r\n    //========================\r\n\r\n    function swapTokens(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address _router,\r\n        address[] memory _path,\r\n        address _to\r\n    ) internal returns (SwapResult memory)\r\n    {\r\n        //init\r\n        IToken from = IToken(_path[0]);\r\n        IToken to = IToken(_path[_path.length - 1]);\r\n        SwapResult memory result = SwapResult(\r\n        {\r\n            fromBefore: from.balanceOf(address(this)),\r\n            toBefore: to.balanceOf(_to),\r\n            toAfter: 0,\r\n            swapped: 0\r\n        });\r\n\r\n        //swap\r\n        address(from).safeApprove_ERC20(\r\n            address(_router),\r\n            _amountIn\r\n        );\r\n        IUniRouterV2(_router).swapExactTokensForTokens(\r\n            _amountIn,\r\n            _amountOutMin,\r\n            _path,\r\n            _to,\r\n            block.timestamp\r\n        );\r\n\r\n        //process\r\n        result.toAfter = to.balanceOf(_to);\r\n        result.swapped = result.toAfter - result.toBefore;\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n//File: [IVault.sol]\r\n\r\ninterface IVault\r\n{\r\n    //========================\r\n    // STRUCTS\r\n    //========================\r\n    \r\n    struct UserInfo\r\n    {\r\n        uint256 layer;              //layer the user is in\r\n        uint256 layerShares;        //user share of layer        \r\n        uint256 lastDepositTime;    //timestamp of last deposit\r\n        uint256 lastActionAtBlock;  //block at last performed action   \r\n        uint256 payoutDebt;         //reward debt for current layer\r\n        uint256 totalClaimed;       //total claimed payout across all layers\r\n    }\r\n\r\n    struct LayerInfo\r\n    {\r\n        uint256 payoutPercent;      //equal to layer ID. say how much % get converted to payout on compound\r\n        uint256 totalLayerShares;   //total shares of user => layer\r\n        uint256 poolShares;         //shares of layer => pool. Gets adjusted each compound)\r\n        uint256 totalClaimed;       //total claimed payout\r\n        uint256 totalPayouts;       //total deposited payouts\r\n        uint256 accPayoutPerShare;  //accumulated payout per share        \r\n        uint256 payoutShares;       //payout part of pool shares\r\n        uint256 compoundShares;     //compound part of pool shares\r\n    }    \r\n\r\n    struct LayerShareInfo\r\n    {\r\n        uint256 layer;              //layer ID / payout %\r\n        uint256 balancePerShare;    //balance per layerShare\r\n        uint256 payoutPerShare;     //payout per layerShare\r\n    }\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //======================== \r\n\r\n    function config() external view returns (IVaultConfig);  \r\n\r\n    function totalPayoutShares() external view returns (uint256);  \r\n    function totalCompoundShares() external view returns (uint256);  \r\n\r\n    //========================\r\n    // USER INFO FUNCTIONS\r\n    //======================== \r\n\r\n    function userRemainingWithdrawFeeTime(address _user) external view returns (uint256);\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //======================== \r\n\r\n    function balanceOfVault() external view returns (uint256);\r\n\r\n    //========================\r\n    // LAYER INFO FUNCTIONS\r\n    //======================== \r\n\r\n    function getLayers() external view returns (LayerInfo[] memory);\r\n\r\n    //========================\r\n    // PAYOUT FUNCTIONS\r\n    //======================== \r\n\r\n    function depositPayout(uint256 _amount) external;\r\n    function claim() external;\r\n    function claimFor(address _user) external;\r\n}\r\n\r\n//File: [Test_SmartChef.sol]\r\n\r\ncontract Test_SmartChef is\r\n    ITest_SmartChef,\r\n    Ownable,\r\n    ML_ProtectedBalance,\r\n    ML_RecoverFunds\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using ML_Transfer for address;\r\n    using ML_TransferWithInfo for address;\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    address public override rewardToken;\r\n    address public override depositToken;\r\n\r\n    uint256 public override rewardPerClaim;\r\n\r\n    mapping(address => uint256) public override userInfo;\r\n\r\n    uint256 public override totalDeposit;\r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor(\r\n        address _depositToken,\r\n        address _rewardToken\r\n    )\r\n    {\r\n        depositToken = _depositToken;\r\n        rewardToken = _rewardToken;\r\n        rewardPerClaim = 10**16;\r\n\r\n        _transferOwnership(tx.origin);\r\n    }\r\n\r\n    //========================\r\n    // CONFIG FUNCTIONS\r\n    //========================\r\n\r\n    function setRewardPerClaim(uint256 _amount) external onlyOwner\r\n    {\r\n        rewardPerClaim = _amount;\r\n    }\r\n\r\n    //========================\r\n    // ADMIN FUNCTIONS\r\n    //========================\r\n\r\n    function depositReward(uint256 _amount) external\r\n    {\r\n        rewardToken.transferFrom_ERC20(\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        );\r\n    }\r\n\r\n    function eject() external onlyOwner\r\n    {\r\n        //eject reward\r\n        rewardToken.transfer_ERC20(\r\n            msg.sender,\r\n            rewardToken.balanceOf_token(\r\n                ML_Transfer.TokenType.ERC20,\r\n                address(this)\r\n            ) - getProtectedBalance(rewardToken)\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf(address _user) public override view returns (uint256)\r\n    {\r\n        return userInfo[_user];\r\n    }\r\n\r\n    function pendingReward(address _user) public override view returns (uint256)\r\n    {\r\n        if (totalDeposit == 0)\r\n        {\r\n            return 0;\r\n        }\r\n        return (rewardPerClaim * balanceOf(_user)) / totalDeposit;\r\n    }\r\n\r\n    //========================\r\n    // DEPOSIT / WITHDRAW / CLAIM FUNCTIONS\r\n    //========================\r\n\r\n    function deposit(uint256 _amount) external override\r\n    {\r\n        //check\r\n        require(_amount > 0, \"0 deposit\");\r\n        require(depositToken.balanceOf_token(ML_Transfer.TokenType.ERC20, msg.sender) >= _amount, \"Insufficient balance\");\r\n\r\n        //transfer\r\n        uint256 transferred = depositToken.transferFromWithInfo_ERC20(\r\n            msg.sender,\r\n            address(this),\r\n            _amount\r\n        ).transferred;\r\n\r\n        //update\r\n        totalDeposit += transferred;\r\n        userInfo[msg.sender] += transferred;\r\n\r\n        //protect\r\n        increaseProtectedBalance(\r\n            depositToken, \r\n            transferred\r\n        );\r\n    }\r\n\r\n    function withdraw(uint256 _amount) public override\r\n    {\r\n        //check\r\n        require(_amount > 0, \"0 withdraw\");\r\n        require(balanceOf(msg.sender) >= _amount, \"Insufficient balance\");\r\n\r\n        //update\r\n        userInfo[msg.sender] -= _amount;\r\n        totalDeposit -= _amount;\r\n\r\n        //transfer\r\n        depositToken.transfer_ERC20(\r\n            msg.sender,\r\n            _amount\r\n        );\r\n\r\n        //unprotect\r\n        decreaseProtectedBalance(\r\n            depositToken, \r\n            _amount\r\n        );\r\n    }    \r\n\r\n    function emergencyWithdraw() external override\r\n    {\r\n        withdraw(userInfo[msg.sender]);\r\n    }\r\n\r\n    function claim() external override\r\n    {\r\n        uint256 reward = pendingReward(msg.sender);\r\n        if (reward > 0)\r\n        {\r\n            //check protected\r\n            require(\r\n                getProtectedBalance(rewardToken) + reward\r\n                    <= rewardToken.balanceOf_token(\r\n                            ML_Transfer.TokenType.ERC20,\r\n                            address(this)\r\n                    ),\r\n                \"Insufficient reward\"\r\n            );\r\n\r\n            //transfer\r\n            rewardToken.transfer_ERC20(\r\n                msg.sender,\r\n                reward\r\n            );\r\n        }\r\n    }\r\n\r\n    //========================\r\n    // EMERGENCY FUNCTIONS\r\n    //========================\r\n\r\n    function recoverETH(uint256 _amount, address _to) external onlyOwner\r\n    {\r\n        //recover\r\n        _recoverETH(_amount, _to);        \r\n    }\r\n\r\n    function recoverToken(IToken _token, uint256 _amount, address _to) external onlyOwner\r\n    {\r\n        //recover\r\n        _recoverToken(_token, _amount, _to);\r\n    }  \r\n}\r\n\r\n//File: [IVaultStrategy.sol]\r\n\r\ninterface IVaultStrategy is\r\n    IVaultPoolInfo\r\n{\r\n    \r\n    //========================\r\n    // STRUCTS\r\n    //========================\r\n\r\n    struct SwapPath\r\n    {\r\n        address router; //router to use for swap\r\n        address[] path; //only the inbetween path\r\n    }\r\n\r\n    struct Reward\r\n    {\r\n        IToken token; //utilized token\r\n        SwapPath swap; //swap path to swap token to mainReward\r\n    }\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    function vault() external view returns (IVault);\r\n\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOf() external view returns (uint256);\r\n    function rewardsContainsDepositToken() external view returns (bool);\r\n\r\n    //========================\r\n    // DEPOSIT / WITHDRAW FUNCTIONS / COMPOUND\r\n    //========================\r\n\r\n    function deposit() external returns (uint256);\r\n    function withdraw(address _user, uint256 _amount) external returns (uint256);\r\n    function compound(address _user) external returns (bool);\r\n    function harvest() external;\r\n\r\n    //========================\r\n    // STRATEGY FUNCTIONS\r\n    //========================\r\n\r\n    function retireStrategy(IVaultStrategy _newStrategy) external;  \r\n}\r\n\r\n//File: [VaultStrategy_base.sol]\r\n\r\nabstract contract VaultStrategy_base is\r\n    IVaultStrategy,\r\n    VaultConfigAccessRequest,    \r\n    ML_ProtectedBalance\r\n{\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    //base\r\n    IVault public immutable override vault; //parent vault\r\n    address public override depositToken; //deposit token    \r\n\r\n    //rewards\r\n    Reward[] public rewards; //reward (at least 1)\r\n    mapping(uint256 => SwapPath) public rewardToDepositTokenChild; //reward => depositChild\r\n    SwapPath public rewardToETH; //path to convert reward to ETH\r\n\r\n    //harvest / compound\r\n    uint256 public lastHarvestBlock; //timestamp of last harvest\r\n\r\n    //========================\r\n    // EVENTS\r\n    //========================\r\n\r\n    event Compound(\r\n        address indexed _user,\r\n        uint256 _totalDepositBefore,\r\n        uint256 _totalDepositAfter,\r\n        uint256 _reward,\r\n        uint256 _dust\r\n    );\r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor(IVault _vault)\r\n    {\r\n        vault = _vault;\r\n    }\r\n\r\n    //========================\r\n    // CONFIG FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice path to convert main reward to ETH (for price oracle)\r\n    function setRewardToETHSwapPath(SwapPath memory _swapPath) external\r\n    {\r\n        rewardToETH = _swapPath;\r\n    }\r\n\r\n    ///@notice remove rewards (except main reward)\r\n    function removeReward(uint256 _index) external\r\n    {\r\n        //check\r\n        requireValidRewardIndex(_index);\r\n        require(_index == 0, \"Can't delete main reward\");\r\n\r\n        //clone\r\n        if (_index != rewards.length - 1)\r\n        {\r\n            rewards[_index] = rewards[rewards.length - 1];\r\n        }        \r\n\r\n        //remove\r\n        rewards.pop();        \r\n    }\r\n\r\n    ///@notice add a reward\r\n    function addReward(Reward memory _reward) public\r\n    {\r\n        //check\r\n        require((rewards.length != 0\r\n                || _reward.swap.path.length == 0\r\n            ),\r\n            \"Main reward can't have path\"\r\n        );\r\n\r\n        //add\r\n        rewards.push(_reward);\r\n    }    \r\n\r\n    ///@notice set path of additional rewards to main reward\r\n    function setRewardSwapPath(uint256 _index, SwapPath memory _swapPath) external\r\n    {\r\n        //check\r\n        requireValidRewardIndex(_index);\r\n        require((_index != 0\r\n                || _swapPath.path.length == 0\r\n            ),\r\n            \"Main reward can't have path\"\r\n        );\r\n\r\n        //set\r\n        rewards[_index].swap = _swapPath;\r\n    }\r\n\r\n    ///@notice set reward to deposit token child path\r\n    function setRewardToDepositTokenChild(uint256 _index, SwapPath memory _swapPath) public \r\n    {\r\n        //check\r\n        require((_index < getDepositTokenChildLength()\r\n                || (_index == 0\r\n                    && getDepositTokenChildLength() == 0)\r\n            ),\r\n            \"Invalid deposit token child\"\r\n        );\r\n\r\n        //set\r\n        rewardToDepositTokenChild[_index] = _swapPath;\r\n    }\r\n\r\n    ///@notice set reward to deposit token child path\r\n    function _setRewardToDepositTokenChild(uint256 _index, address _router) internal \r\n    {\r\n        address[] memory path;\r\n        setRewardToDepositTokenChild(\r\n            _index,\r\n            SwapPath(\r\n            {\r\n                router: _router,\r\n                path: path\r\n            })\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice main reward token\r\n    function rewardToken() public view override returns (IToken)\r\n    {\r\n        return rewards[0].token;\r\n    }\r\n\r\n    ///@notice get additional reward token\r\n    ///@dev index 0 is main reward and should be skipped\r\n    function additionalRewardToken(uint256 _index) public view returns (IToken)\r\n    {\r\n        return rewards[_index].token;\r\n    }    \r\n\r\n    ///@notice length of all rewards\r\n    function rewardsLength() external view returns (uint256)\r\n    {\r\n        return rewards.length;\r\n    }\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //========================    \r\n\r\n    ///@notice balance of main reward, including protected\r\n    function balanceOfReward() public view returns (uint256)\r\n    {\r\n        return rewardToken().balanceOf(address(this));\r\n    }\r\n\r\n    ///@notice balance of additional reward, including protected\r\n    function balanceOfAdditionalReward(uint256 _index) public view returns (uint256)\r\n    {\r\n        return additionalRewardToken(_index).balanceOf(address(this));\r\n    }\r\n\r\n    ///@notice balance of deposit token, excluding protected (harvest protection)\r\n    function balanceOfStrategy() public view returns (uint256)\r\n    {\r\n        return IToken(depositToken).balanceOf(address(this))\r\n            - getProtectedBalance(depositToken);\r\n    }\r\n\r\n    ///@notice is one of the rewards = deposit token\r\n    function rewardsContainsDepositToken() external view override returns (bool)\r\n    {\r\n        for (uint256 n = 0; n < rewards.length; n++)\r\n        {\r\n            if (address(rewards[n].token) == depositToken)\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    ///@notice get swap info for reward to deposit token child (LPs have children)\r\n    function getRewardToDepositTokenChild(\r\n        uint256 _index\r\n    ) external view returns(\r\n        address router,\r\n        address[] memory path\r\n    )\r\n    {\r\n        return (\r\n            rewardToDepositTokenChild[_index].router,\r\n            rewardToDepositTokenChild[_index].path\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // INFO FUNCTIONS (OVERRIDE in extension:deposit)\r\n    //========================\r\n\r\n    ///@notice depending on deposit extension, it returns the child tokens, for example token0/token1 from an LP\r\n    function getDepositTokenChild(uint256 _index) public view virtual returns (address)\r\n    {        \r\n        if (_index == 0\r\n            && getDepositTokenChildLength() == 0)\r\n        {\r\n            return address(depositToken);\r\n        }\r\n        return address(0);\r\n    }\r\n\r\n    ///@notice depending on deposit extension, it returns how many children the deposit token has\r\n    function getDepositTokenChildLength() public view virtual returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    //========================\r\n    // SWAP FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice convert main reward => deposit\r\n    function swapRewardToDeposit() internal virtual\r\n    {\r\n        //check if swap required\r\n        if (address(rewardToken()) == depositToken)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //swap reward to deposit\r\n        swap(\r\n            balanceOfReward(),\r\n            rewards[0].swap.router,\r\n            createSwapPath(\r\n                address(rewardToken()),\r\n                address(depositToken),\r\n                rewards[0].swap.path\r\n            )\r\n        );\r\n    }\r\n\r\n    ///@notice swaps given additional reward to main reward (thereby skips 0)\r\n    function swapAdditionalRewardToReward(uint256 _index) internal\r\n    {\r\n        //check if swap required\r\n        address tokenFrom = address(additionalRewardToken(_index));\r\n        if (_index == 0\r\n            || tokenFrom == address(depositToken)\r\n            || tokenFrom == address(rewardToken()))\r\n        {\r\n            return;\r\n        }\r\n\r\n        //swap reward to deposit\r\n        swap(\r\n            balanceOfAdditionalReward(_index),\r\n            rewards[_index].swap.router, \r\n            createSwapPath(\r\n                tokenFrom,\r\n                address(rewardToken()),\r\n                rewards[_index].swap.path\r\n            )\r\n        );\r\n    }\r\n\r\n    ///@notice convert main reward => depositTokenChild\r\n    function swapRewardToDepositTokenChild(uint256 _index, uint256 _amount) internal\r\n    {\r\n        //check if swap required\r\n        address depositTokenChild = getDepositTokenChild(_index);\r\n        if (address(rewardToken()) == depositTokenChild)\r\n        {\r\n            return;\r\n        }\r\n        \r\n        //swap reward to deposit\r\n        swap(\r\n            _amount,\r\n            rewards[0].swap.router, \r\n            createSwapPath(\r\n                address(rewardToken()),\r\n                depositTokenChild,\r\n                rewards[0].swap.path\r\n            )\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // 3rd PARTY FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice swaps amount via given router and paath and returns gained target balance\r\n    function swap(uint256 _amount, address _router, address[] memory _path) internal virtual returns (uint256);\r\n\r\n    ///@notice get the price for swap\r\n    function getPrice(uint256 _amount, address _router, address[] memory _path) internal view virtual returns (uint256);\r\n\r\n    //========================\r\n    // HELPER FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice creates a swap path\r\n    function createSwapPath(\r\n        address _start, \r\n        address _end, \r\n        address[] memory _path\r\n    ) internal pure returns (address[] memory)\r\n    {\r\n        address[] memory fullPath = new address[](2 + _path.length);\r\n\r\n        //fill\r\n        fullPath[0] = _start;\r\n        for (uint256 n = 0; n < _path.length; n++)\r\n        {\r\n            fullPath[n + 1] = _path[n];\r\n        }        \r\n        fullPath[fullPath.length - 1] = _end;\r\n\r\n        return fullPath;\r\n    }\r\n    \r\n    ///@notice creates a swap path\r\n    function createSwapPath(\r\n        address _start, \r\n        address _end\r\n    ) internal pure returns (address[] memory)\r\n    {\r\n        address[] memory path;\r\n        return createSwapPath(\r\n            _start, \r\n            _end, \r\n            path\r\n        );\r\n    }\r\n\r\n    ///@notice create a reward that is harvested from pool\r\n    function createReward(\r\n        IToken _token, \r\n        address _router, \r\n        address[] memory _path\r\n    ) internal pure returns (Reward memory)\r\n    {\r\n        return Reward(\r\n            {\r\n                token: _token,\r\n                swap: SwapPath(\r\n                    {\r\n                        router: _router,\r\n                        path: _path\r\n                    }\r\n                )\r\n            }\r\n        );\r\n    }\r\n\r\n    ///@notice create a reward that is harvested from pool\r\n    function createReward(IToken _token, address _router) internal pure returns (Reward memory)\r\n    {\r\n        address[] memory path;\r\n        return createReward(\r\n            _token,\r\n            _router,\r\n            path\r\n        );\r\n    }\r\n\r\n    ///@notice check if reward index is valid\r\n    function requireValidRewardIndex(uint256 _index) internal view\r\n    {\r\n        require(_index < rewards.length, \"Invalid reward index\");\r\n    }\r\n\r\n    //========================\r\n    // OVERRIDE FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice get access manager\r\n    function getAccessManager() public override view returns (IMoonAccessManager)\r\n    {\r\n        return VaultConfigAccessRequest(address(vault)).getAccessManager();\r\n    }\r\n}\r\n\r\n//File: [VaultStrategy_withPoolAccess.sol]\r\n\r\n///@notice This contract defines the interface for pool interaction.\r\n///These functions shoul be overriden by strategy implementation.\r\n///They are required for base functionality\r\nabstract contract VaultStrategy_withPoolAccess is\r\n    VaultStrategy_base\r\n{\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    //3rd party contracts\r\n    address public poolProvider; //address of the pool contract\r\n    uint256 public poolID; //ID of pool\r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor(IVault _vault, address _poolProvider, uint256 _poolID)\r\n    VaultStrategy_base(_vault)\r\n    {\r\n        poolProvider = _poolProvider;\r\n        poolID = _poolID;\r\n    }\r\n\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice balance of pool\r\n    function balanceOfPool() public view virtual returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    //========================\r\n    // OVERRIDE DEPOSIT / WITHDRAW / CLAIM FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice deposit into pool\r\n    function poolDeposit(uint256 _amount) internal virtual\r\n    {\r\n        _amount; //hide warning\r\n    }\r\n\r\n    ///@notice withdraw from pool\r\n    function poolWithdraw(uint256 _amount) internal virtual\r\n    {\r\n        _amount; //hide warning\r\n    }    \r\n\r\n    ///@notice emergency withdraw from pool\r\n    function poolEmergencyWithdraw() internal virtual\r\n    {\r\n        poolWithdraw(balanceOfPool());\r\n    }\r\n\r\n    ///@notice harvest pool\r\n    function poolHarvest() internal virtual\r\n    {\r\n        poolWithdraw(0);\r\n    }\r\n}\r\n\r\n//File: [VaultStrategy_withFees.sol]\r\n\r\n///@notice This part only handles protocol fees\r\nabstract contract VaultStrategy_withFees is\r\n    VaultStrategy_base,\r\n    ML_TransferETH\r\n{\r\n    //========================\r\n    // FEE FUNCTIONS\r\n    //======================== \r\n\r\n    ///@notice take withdraw fee and let it in pool\r\n    ///@return _amount after fee is deducted\r\n    function takeWithdrawFee(address _user, uint256 _amount) internal view returns (uint256)\r\n    {\r\n        //check if withdraw fee period\r\n        if (vault.userRemainingWithdrawFeeTime(_user) == 0)\r\n        {\r\n            return _amount;\r\n        }\r\n\r\n        //take withdraw fee\r\n        uint256 withdrawFeeAmount = (_amount * vault.config().withdrawFee()) / vault.config().PERCENT_FACTOR();\r\n        return _amount - withdrawFeeAmount;\r\n    }\r\n\r\n    ///@notice take reward fee and send it to compounder and reward distributor\r\n    ///@return _amount after fee is deducted\r\n    function takeRewardFee(address _compoundUser, uint256 _amount) internal returns (uint256)\r\n    {        \r\n        //check fee\r\n        uint256 feeShare = vault.config().compoundFee();\r\n        if (vault.config().feeReceiver() != address(0))\r\n        {\r\n            feeShare += vault.config().rewardFee();\r\n        }\r\n\r\n        //take reward fee\r\n        uint256 rewardFeeAmount = (_amount * feeShare) / vault.config().PERCENT_FACTOR();\r\n        if (rewardFeeAmount == 0)\r\n        {\r\n            return _amount;\r\n        }\r\n\r\n        //swap to ETH\r\n        uint256 rewardFeeETH = (address(rewardToken()) == address(vault.config().wrappedCoin())\r\n            ? rewardFeeAmount\r\n            : swap(\r\n                rewardFeeAmount,\r\n                rewardToETH.router,\r\n                rewardToETH.path\r\n            )\r\n        );\r\n\r\n        if (rewardFeeETH > 0)\r\n        {\r\n            //unwrap\r\n            vault.config().wrappedCoin().withdraw(rewardFeeETH);\r\n\r\n            //transfer to compounder & fee receiver     \r\n            if (vault.config().compoundFee() > 0)\r\n            {\r\n                uint256 compoundFeeAmount = (rewardFeeAmount * vault.config().compoundFee()) / feeShare;\r\n                transferETH(_compoundUser, compoundFeeAmount);\r\n                rewardFeeETH -= compoundFeeAmount;            \r\n            }        \r\n            if (rewardFeeETH > 0)\r\n            {\r\n                transferETH(vault.config().feeReceiver(), rewardFeeETH);\r\n            }\r\n        }\r\n\r\n        return (_amount - rewardFeeAmount);\r\n    }\r\n\r\n    ///@notice take payout fee and send it to reward distributor\r\n    ///@return _amount after fee is deducted\r\n    function takePayoutFee(uint256 _amount) internal returns (uint256)\r\n    {\r\n        //take payout fee\r\n        uint256 payoutFeeAmount = (_amount * vault.config().payoutFee()) / vault.config().PERCENT_FACTOR();\r\n        if (payoutFeeAmount > 0)\r\n        {\r\n            //unwrap\r\n            vault.config().wrappedCoin().withdraw(payoutFeeAmount);\r\n\r\n            //transfer to fee receiver     \r\n            transferETH(vault.config().feeReceiver(), payoutFeeAmount);\r\n        }\r\n\r\n        return _amount - payoutFeeAmount;\r\n    }\r\n}\r\n\r\n//File: [VaultStrategy.sol]\r\n\r\n///@notice combines all base features but should be inherited by strategy implementation\r\nabstract contract VaultStrategyV2 is\r\n    VaultStrategy_base,\r\n    VaultStrategy_withPoolInfo,\r\n    VaultStrategy_withPoolAccess,\r\n    VaultStrategy_withFees,\r\n    ML_RecoverFunds\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using ML_Transfer for address;\r\n    using ML_TransferWithInfo for address;\r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor(\r\n        IVault _vault,\r\n        address _poolProvider,\r\n        uint256 _poolID\r\n    )\r\n    VaultStrategy_withPoolAccess(\r\n        _vault,\r\n        _poolProvider,\r\n        _poolID\r\n    )\r\n    {\r\n        \r\n    }\r\n\r\n    //========================\r\n    // INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice total balance of strategy + pool, excluding protected\r\n    function balanceOf() external view override returns (uint256)\r\n    {\r\n        return balanceOfStrategy() + balanceOfPool();\r\n    }   \r\n\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice pending rewards in ETH\r\n    function poolPendingETH() public view virtual override returns (uint256)\r\n    {\r\n        return getPrice(\r\n            poolPending(),\r\n            rewardToETH.router,\r\n            createSwapPath(\r\n                address(rewardToken()), \r\n                address(vault.config().wrappedCoin()),\r\n                rewardToETH.path\r\n            )\r\n        );\r\n    }    \r\n\r\n    ///@notice total reward for compounding in ETH (sum of all pending rewards => ETH)\r\n    function poolCompoundRewardETH() external view virtual override returns (uint256)\r\n    {\r\n        return (poolPendingETH() * vault.config().compoundFee()) / vault.config().PERCENT_FACTOR();\r\n    }\r\n\r\n    //========================\r\n    // DEPOSIT FUNCTIONS\r\n    //========================    \r\n\r\n    ///@notice deposit all funds (except protected) into the pool\r\n    function deposit() public virtual override returns (uint256)\r\n    {\r\n        //check\r\n        requireVault();\r\n\r\n        //get balance of strategy without protected amount\r\n        uint256 currentBalance = balanceOfStrategy();\r\n        if (currentBalance > 0)\r\n        {\r\n            uint256 poolBalanceBeforeDeposit = balanceOfPool();\r\n\r\n            //approve\r\n            depositToken.safeApprove_ERC20(\r\n                poolProvider, \r\n                currentBalance\r\n            );\r\n\r\n            //deposit into pool\r\n            poolDeposit(currentBalance);\r\n\r\n            //unapprove\r\n            depositToken.safeApprove_ERC20( \r\n                poolProvider, \r\n                0\r\n            );\r\n\r\n            //return the amount that pool received after taxes\r\n            return balanceOfPool() - poolBalanceBeforeDeposit;\r\n        }\r\n\r\n        return 0;\r\n    } \r\n\r\n    //========================\r\n    // WITHDRAW FUNCTIONS\r\n    //======================== \r\n\r\n    ///@notice withdraw funds from pool and send to user\r\n    function withdraw(address _user, uint256 _amount) external virtual override returns (uint256)\r\n    {\r\n        //check\r\n        requireVault();\r\n\r\n        //take withdraw fee\r\n        uint256 amount = takeWithdrawFee(_user, _amount);\r\n\r\n        //withdraw from pool\r\n        (uint256 poolWithdrawAmount, uint256 receivedWithdraw) = withdrawFromPool(amount);\r\n\r\n        //withdraw from strategy\r\n        uint256 strategyWithdrawAmount = amount - poolWithdrawAmount; //remaining after tax\r\n        uint256 userWithdrawAmount = strategyWithdrawAmount + receivedWithdraw; //actual withdraw for user\r\n        return withdrawFromStrategy(_user, userWithdrawAmount);\r\n    }\r\n\r\n    ///@notice withdraw required amount from pool\r\n    function withdrawFromPool(uint256 _amount) internal virtual returns (uint256 poolWithdrawAmount, uint256 receivedWithdraw)\r\n    {\r\n        //check if not enough in strategy\r\n        uint256 strategyBalanceBefore = balanceOfStrategy();\r\n        if (strategyBalanceBefore < _amount)\r\n        {\r\n            //withdraw from pool\r\n            poolWithdrawAmount = _amount - strategyBalanceBefore;\r\n            poolWithdraw(poolWithdrawAmount);\r\n            receivedWithdraw = balanceOfStrategy() - strategyBalanceBefore;\r\n        }\r\n\r\n        return (poolWithdrawAmount, receivedWithdraw);\r\n    }\r\n\r\n    ///@notice withdraw funds from strategy to user\r\n    function withdrawFromStrategy(address _user, uint256 _amount) internal virtual returns (uint256)\r\n    {\r\n        return depositToken.transferWithInfo_ERC20(\r\n            _user,\r\n            _amount\r\n        ).transferred;\r\n    }\r\n\r\n    //========================\r\n    // COMPOUND FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice harvest pool\r\n    function harvest() external override\r\n    {   \r\n        //check\r\n        requireVault();\r\n\r\n        //harvest\r\n        _harvest();\r\n    }  \r\n    \r\n    ///@notice harvest pool and check for protected deposit\r\n    function _harvest() internal virtual\r\n    {   \r\n        //check\r\n        if (block.number == lastHarvestBlock)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //get balance before harvest\r\n        uint256 balanceBeforeHarvest = balanceOfStrategy();\r\n\r\n        //harvest\r\n        poolHarvest();\r\n        lastHarvestBlock = block.number;\r\n\r\n        //keep track of harvested deposit tokens\r\n        increaseProtectedBalance(\r\n            depositToken,\r\n            balanceOfStrategy() - balanceBeforeHarvest\r\n        );\r\n    }  \r\n\r\n    ///@notice compound rewards\r\n    function compound(address _user) external override returns (bool)\r\n    {\r\n        //check\r\n        requireVault();\r\n\r\n        //harvest all rewards from pool\r\n        _harvest();\r\n\r\n        //convert additional rewards into reward\r\n        for (uint256 n = 1; n < rewards.length; n++)\r\n        {\r\n            swapAdditionalRewardToReward(n);\r\n        }\r\n\r\n        //process rewards\r\n        uint256 rewardBalance = balanceOfReward();\r\n        if (rewardBalance > 0)\r\n        {\r\n            //take protocol fees\r\n            takeRewardFee(_user, rewardBalance);\r\n\r\n            //handle payout shares\r\n            handlePayout();\r\n\r\n            //convert from reward to deposit token\r\n            if (balanceOfReward() > 0)\r\n            {\r\n                swapRewardToDeposit();\r\n            }\r\n        }        \r\n\r\n        //reset protected\r\n        resetProtectedBalance(depositToken);\r\n\r\n        //deposit\r\n        return (deposit() > 0);\r\n    }\r\n\r\n    //========================\r\n    // PAYOUT FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice handle payout to vault\r\n    function handlePayout() private\r\n    {\r\n        //check amount\r\n        uint256 amount = (balanceOfReward() * vault.totalPayoutShares())\r\n            / (vault.totalPayoutShares() + vault.totalCompoundShares());\r\n        if (amount == 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //swap reward to wETH\r\n        uint256 payout = (address(rewardToken()) == address(vault.config().wrappedCoin())\r\n            ? amount\r\n            : swap(\r\n                amount,\r\n                rewardToETH.router,\r\n                createSwapPath(\r\n                    address(rewardToken()), \r\n                    address(vault.config().wrappedCoin()),\r\n                    rewardToETH.path\r\n                )\r\n            )\r\n        );\r\n\r\n        //take fees\r\n        payout = takePayoutFee(payout);\r\n\r\n        //approve payout\r\n        address(vault.config().wrappedCoin()).safeApprove_ERC20(\r\n            address(vault),\r\n            payout\r\n        );\r\n\r\n        //process vault payout\r\n        vault.depositPayout(payout);\r\n\r\n        //undo approval\r\n        address(vault.config().wrappedCoin()).safeApprove_ERC20(\r\n            address(vault),\r\n            0\r\n        );\r\n    }\r\n\r\n    //========================\r\n    // STATIC POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    ///@notice pending additional reward of the pool converted to main reward\r\n    function poolAdditionalReward_PendingAsMainReward(uint256 _rewardIndex) public view returns (uint256)\r\n    {\r\n        if (_rewardIndex != 1\r\n            && _rewardIndex < rewards.length)\r\n        {\r\n            return getPrice(\r\n                poolAdditionalReward_Pending(_rewardIndex),\r\n                rewards[_rewardIndex].swap.router, \r\n                createSwapPath(\r\n                    address(rewards[_rewardIndex].token),\r\n                    address(rewardToken()),\r\n                    rewards[_rewardIndex].swap.path\r\n                )\r\n            );            \r\n        }\r\n        return 0;\r\n    }  \r\n\r\n    //========================\r\n    // HELPER FUNCTIONS\r\n    //========================  \r\n\r\n    receive() external payable {}\r\n\r\n    //========================\r\n    // STRATEGY MIGRATION FUNCTIONS\r\n    //======================== \r\n\r\n    ///@notice retire strategy by emergency withdrawing deposit into the new strategy\r\n    function retireStrategy(IVaultStrategy _newStrategy) external override\r\n    {\r\n        //check\r\n        requireVault();\r\n        require(address(_newStrategy) != address(0), \"Invalid new strategy\");\r\n        require(depositToken == _newStrategy.depositToken(), \"Deposit token mismatch\");\r\n\r\n        //emergency withdraw\r\n        poolEmergencyWithdraw();\r\n\r\n        //transfer to new strategy\r\n        depositToken.transfer_ERC20(\r\n            address(_newStrategy),       \r\n            IToken(depositToken).balanceOf(address(this))                \r\n        );\r\n    }\r\n\r\n    //========================\r\n    // SECURITY FUNCTIONS\r\n    //======================== \r\n\r\n    ///@notice ensure that function is only called from vault\r\n    function requireVault() internal view\r\n    {\r\n        require(msg.sender == address(vault), \"Not called by Vault\");\r\n    } \r\n}\r\n\r\n//File: [VaultStrategy_deposit_LP.sol]\r\n\r\n///@notice This part only handles Uniswap V1/V2 deposits (LPs)\r\nabstract contract VaultStrategy_deposit_LP is\r\n    VaultStrategy_base,\r\n    VaultStrategyV2\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using ML_Transfer for address;\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    bool public isLPToken; //use LP swap instead of direct\r\n    address public routerForLP; //router used to add liquidity\r\n\r\n    //========================\r\n    // CREATE FUNCTIONS\r\n    //========================\r\n\r\n    constructor(\r\n        IVault _vault,\r\n        address _poolProvider,\r\n        uint256 _poolID,\r\n        bool _isLP,\r\n        address _router\r\n    )\r\n    VaultStrategyV2(\r\n        _vault,\r\n        _poolProvider,\r\n        _poolID\r\n    )\r\n    {\r\n        isLPToken = _isLP;\r\n        routerForLP = _router;\r\n    }\r\n\r\n    //========================\r\n    // INFO FUNCTIONS (OVERRIDE in extension:deposit)\r\n    //========================\r\n\r\n    ///@inheritdoc VaultStrategy_base\r\n    function getDepositTokenChild(uint256 _index) public view virtual override returns (address)\r\n    {\r\n        if (isLPToken)\r\n        {\r\n            if (_index == 0)\r\n                return ITokenPair(address(depositToken)).token0();\r\n            if (_index == 1)\r\n                return ITokenPair(address(depositToken)).token1();\r\n        }\r\n        return super.getDepositTokenChild(_index);\r\n    }\r\n\r\n    ///@inheritdoc VaultStrategy_base\r\n    function getDepositTokenChildLength() public view virtual override returns (uint256)\r\n    {\r\n        return (isLPToken ? 2 : 0);\r\n    }\r\n\r\n    //========================\r\n    // SWAP FUNCTIONS\r\n    //========================\r\n\r\n    ///@inheritdoc VaultStrategy_base\r\n    ///@dev swap reward to token0/token1 and add liquidity\r\n    function swapRewardToDeposit() internal virtual override\r\n    {\r\n        //check if swap required\r\n        if (!isLPToken)\r\n        {\r\n            super.swapRewardToDeposit();\r\n            return;\r\n        }        \r\n        uint256 halfReward = balanceOfReward() / 2;\r\n\r\n        //swap reward to token0 (only swap balance - half)\r\n        address token0 = getDepositTokenChild(0);        \r\n        swapRewardToDepositTokenChild(0, balanceOfReward() - halfReward);\r\n\r\n        //swap reward to token1\r\n        address token1 = getDepositTokenChild(1);\r\n        swapRewardToDepositTokenChild(1, halfReward);\r\n\r\n        //approval\r\n        token0.safeApprove_ERC20(\r\n            routerForLP,\r\n            IToken(token0).balanceOf(address(this))\r\n        );\r\n        token1.safeApprove_ERC20(\r\n            routerForLP,\r\n            IToken(token1).balanceOf(address(this))\r\n        );\r\n\r\n        //add liquidity\r\n        IUniRouterV2(routerForLP).addLiquidity(\r\n            token0,\r\n            token1,\r\n            IToken(token0).balanceOf(address(this)),\r\n            IToken(token1).balanceOf(address(this)),\r\n            1,\r\n            1,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n\r\n        //undo approval\r\n        token0.safeApprove_ERC20(\r\n            routerForLP,\r\n            0\r\n        );\r\n        token1.safeApprove_ERC20(\r\n            routerForLP,\r\n            0\r\n        );      \r\n    }\r\n}\r\n\r\n//File: [VaultStrategy_swap_UniSwapV2.sol]\r\n\r\n///@notice This part only handles swaps via UniSwapV1\r\nabstract contract VaultStrategy_swap_UniSwapV2 is\r\n    VaultStrategy_base,\r\n    VaultStrategyV2,\r\n    ML_RouterSwap_UniSwapV2\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using ML_Transfer for address;\r\n\r\n    //========================\r\n    // 3rd PARTY FUNCTIONS\r\n    //========================\r\n\r\n    ///@inheritdoc VaultStrategy_base\r\n    function swap(uint256 _amount, address _router, address[] memory _path) internal virtual override returns (uint256)\r\n    {\r\n        //swap\r\n        uint256 swapped = swapTokens(\r\n            _amount,\r\n            0,\r\n            _router,\r\n            _path,\r\n            address(this)\r\n        ).swapped;\r\n\r\n        //unapprove\r\n        _path[0].safeApprove_ERC20(\r\n            address(_router),\r\n            0\r\n        );\r\n\r\n        return swapped;\r\n    }\r\n\r\n    ///@inheritdoc VaultStrategy_base\r\n    function getPrice(uint256 _amount, address _router, address[] memory _path) internal view virtual override returns (uint256)\r\n    {\r\n        try IUniRouterV1(_router).getAmountsOut(_amount, _path) returns (uint256[] memory out)\r\n        {\r\n            return out[out.length - 1];\r\n        }\r\n        catch\r\n        {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\n//File: [VaultStrategy_LP_UniSwapV2.sol]\r\n\r\nabstract contract VaultStrategy_LP_UniSwapV2 is\r\n    VaultStrategy_base,\r\n    VaultStrategy_withPoolInfo,\r\n    VaultStrategy_deposit_LP,\r\n    VaultStrategy_swap_UniSwapV2\r\n{\r\n    //========================\r\n    // INHERIT FUNCTIONS\r\n    //========================\r\n\r\n    ///@inheritdoc VaultStrategy_base\r\n    function swapRewardToDeposit() internal virtual override(VaultStrategy_base, VaultStrategy_deposit_LP)\r\n    {\r\n        super.swapRewardToDeposit();     \r\n    }\r\n\r\n    ///@inheritdoc VaultStrategy_base\r\n    function getDepositTokenChild(uint256 _index) public view virtual override(VaultStrategy_base, VaultStrategy_deposit_LP) returns (address)\r\n    {        \r\n        return super.getDepositTokenChild(_index);\r\n    }\r\n\r\n    ///@inheritdoc VaultStrategy_base\r\n    function getDepositTokenChildLength() public view virtual override(VaultStrategy_base, VaultStrategy_deposit_LP) returns (uint256)\r\n    {\r\n        return super.getDepositTokenChildLength(); \r\n    }\r\n}\r\n\r\ncontract VaultStrategy_Shimmer_Test_SmartChef is\r\n    IVaultPoolInfo,\r\n    VaultStrategy_withPoolInfo,\r\n    VaultStrategy_LP_UniSwapV2\r\n{\r\n    //========================\r\n    // LIBS\r\n    //========================\r\n\r\n    using SafeERC20 for IToken;\r\n\r\n    //========================\r\n    // CONSTANTS\r\n    //========================\r\n\r\n    string public constant POOL_VERSION = \"1.0.0\";\r\n    address private constant ROUTER = 0xBbB4CCfc93657AC125F4b1f734111349d1bFF611;\r\n\r\n    //========================\r\n    // ATTRIBUTES\r\n    //========================\r\n\r\n    Test_SmartChef public masterChef;\r\n\r\n    //========================\r\n    // CREATE\r\n    //========================\r\n\r\n    constructor(\r\n        IVault _vault,\r\n        address _depositToken,\r\n        address _rewardToken,\r\n        bool _isLP\r\n    )\r\n    VaultStrategy_deposit_LP(\r\n        _vault,\r\n        address(0),\r\n        0,\r\n        _isLP,\r\n        ROUTER\r\n    )\r\n    {\r\n        //init   \r\n        masterChef = new Test_SmartChef(\r\n            _depositToken,\r\n            _rewardToken\r\n        );\r\n        poolProvider = address(masterChef);\r\n        depositToken = masterChef.depositToken();\r\n        addReward(createReward(IToken(masterChef.rewardToken()), ROUTER));\r\n        rewardToETH.router = ROUTER;\r\n        _setRewardToDepositTokenChild(0, ROUTER);   \r\n        if (isLPToken)\r\n        {\r\n            _setRewardToDepositTokenChild(1, ROUTER);\r\n        }\r\n    }    \r\n\r\n    //========================\r\n    // POOL INFO FUNCTIONS\r\n    //========================\r\n\r\n    function balanceOfPool() public view virtual override returns (uint256)\r\n    {\r\n        return masterChef.balanceOf(address(this));\r\n    }\r\n\r\n    function poolPending() public view virtual override(IVaultPoolInfo, VaultStrategy_withPoolInfo) returns (uint256)\r\n    {\r\n        return masterChef.pendingReward(address(this));\r\n    }\r\n\r\n    //========================\r\n    // DEPOSIT / WITHDRAW / COMPOUND FUNCTIONS\r\n    //========================\r\n\r\n    function poolDeposit(uint256 _amount) internal override\r\n    {\r\n        masterChef.deposit(_amount);\r\n    }\r\n\r\n    function poolWithdraw(uint256 _amount) internal override\r\n    {\r\n        masterChef.withdraw(_amount);\r\n    }\r\n\r\n    function poolEmergencyWithdraw() internal override\r\n    {\r\n        masterChef.emergencyWithdraw();\r\n    }\r\n\r\n    function poolHarvest() internal override\r\n    {\r\n        masterChef.claim();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IVault\",\"name\":\"_vault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_depositToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isLP\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalDepositBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_totalDepositAfter\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_dust\",\"type\":\"uint256\"}],\"name\":\"Compound\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"POOL_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract IToken\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"internalType\":\"struct IVaultStrategy.SwapPath\",\"name\":\"swap\",\"type\":\"tuple\"}],\"internalType\":\"struct IVaultStrategy.Reward\",\"name\":\"_reward\",\"type\":\"tuple\"}],\"name\":\"addReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"additionalRewardToken\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"balanceOfAdditionalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balanceOfStrategy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"compound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depositToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAccessManager\",\"outputs\":[{\"internalType\":\"contract IMoonAccessManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getDepositTokenChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDepositTokenChildLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getRewardToDepositTokenChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isLPToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPoolFarmable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastHarvestBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterChef\",\"outputs\":[{\"internalType\":\"contract Test_SmartChef\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_AllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_Pending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_PendingAsMainReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_RewardEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_TotalAllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_rewardIndex\",\"type\":\"uint256\"}],\"name\":\"poolAdditionalReward_TotalRewardEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolAllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolBlockOrTime\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolCompoundRewardETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolDepositFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolHarvestLockDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolHarvestLockUntil\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPending\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolPendingETH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolRewardEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTotalAllocPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTotalDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolTotalRewardEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolWithdrawFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IVaultStrategy\",\"name\":\"_newStrategy\",\"type\":\"address\"}],\"name\":\"retireStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardToDepositTokenChild\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToETH\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardToken\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"token\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"internalType\":\"struct IVaultStrategy.SwapPath\",\"name\":\"swap\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsContainsDepositToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerForLP\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"internalType\":\"struct IVaultStrategy.SwapPath\",\"name\":\"_swapPath\",\"type\":\"tuple\"}],\"name\":\"setRewardSwapPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"internalType\":\"struct IVaultStrategy.SwapPath\",\"name\":\"_swapPath\",\"type\":\"tuple\"}],\"name\":\"setRewardToDepositTokenChild\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"router\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"internalType\":\"struct IVaultStrategy.SwapPath\",\"name\":\"_swapPath\",\"type\":\"tuple\"}],\"name\":\"setRewardToETHSwapPath\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"contract IVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "VaultStrategy_Shimmer_Test_SmartChef", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f47b4bf6e5f0d08936f8ac6931a2871de2c5609f0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf12700000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3fcde7218a613429a303a0fd9da9b157c45aa3a709eed4a70ed3151871b278b2"}