{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/GemSwapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./utils/ReentrancyGuard.sol\\\";\\nimport \\\"./markets/MarketRegistry.sol\\\";\\nimport \\\"./SpecialTransferHelper.sol\\\";\\nimport \\\"../../interfaces/markets/tokens/IERC20.sol\\\";\\nimport \\\"../../interfaces/markets/tokens/IERC721.sol\\\";\\nimport \\\"../../interfaces/markets/tokens/IERC1155.sol\\\";\\n\\ncontract GemSwapV2 is SpecialTransferHelper, MarketRegistry, ReentrancyGuard {\\n    struct ERC20Details {\\n        address[] tokenAddrs;\\n        uint256[] amounts;\\n    }\\n\\n    struct ERC1155Details {\\n        address tokenAddr;\\n        uint256[] ids;\\n        uint256[] amounts;\\n    }\\n\\n    struct TradeDetails {\\n        uint256 marketId;\\n        uint256 value;\\n        bytes tradeData;\\n    }\\n\\n    struct ConverstionDetails {\\n        bytes conversionData;\\n    }\\n\\n    address public constant GOV = 0x073Ab1C0CAd3677cDe9BDb0cDEEDC2085c029579;\\n    address public guardian;\\n    address public converter;\\n    address public punkProxy;\\n\\n    constructor(address _converter, address _guardian) {\\n        converter = _converter;\\n        guardian = _guardian;\\n\\n        // Seaport\\n        markets.push(\\n            Market({\\n                proxy: 0x00000000000000ADc04C56Bf30aC9d3c0aAF14dC,\\n                isLib: false,\\n                isActive: true\\n            })\\n        );\\n    }\\n    \\n    // TODO: figure out one time approval with Parmesh\\n\\n    // @audit This function is used to approve specific tokens to specific market contracts with high volume.\\n    // This is done in very rare cases for the gas optimization purposes.\\n    function setOneTimeApproval(\\n        IERC20 token,\\n        address operator,\\n        uint256 amount\\n    ) external onlyOwner {\\n        token.approve(operator, amount);\\n    }\\n\\n    function setConverter(address _converter) external onlyOwner {\\n        converter = _converter;\\n    }\\n\\n    function updateGuardian(address _guardian) external onlyOwner {\\n        guardian = _guardian;\\n    }\\n\\n    function _transferEth(address _to, uint256 _amount) internal {\\n        bool callStatus;\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            callStatus := call(gas(), _to, _amount, 0, 0, 0, 0)\\n        }\\n        require(callStatus, \\\"_transferEth: Eth transfer failed\\\");\\n    }\\n\\n    function _checkCallResult(bool _success) internal pure {\\n        if (!_success) {\\n            // Copy revert reason from call\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    function _transferFromHelper(\\n        ERC20Details memory erc20Details,\\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\\n        ERC1155Details[] memory erc1155Details\\n    ) internal {\\n        // transfer ERC20 tokens from the sender to this contract\\n        uint256 length = erc20Details.tokenAddrs.length;\\n\\n        for (uint256 i; i < length; ) {\\n            erc20Details.tokenAddrs[i].call(\\n                abi.encodeWithSelector(\\n                    0x23b872dd,\\n                    msg.sender,\\n                    address(this),\\n                    erc20Details.amounts[i]\\n                )\\n            );\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        // transfer ERC721 tokens from the sender to this contract\\n        length = erc721Details.length;\\n\\n        for (uint256 i; i < length; ) {\\n\\n            // default\\n            uint256 _length = erc721Details[i].ids.length;\\n\\n            for (uint256 j; j < _length; ) {\\n                IERC721(erc721Details[i].tokenAddr).transferFrom(\\n                    _msgSender(),\\n                    address(this),\\n                    erc721Details[i].ids[j]\\n                );\\n\\n                unchecked {\\n                    j++;\\n                }\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        // transfer ERC1155 tokens from the sender to this contract\\n        length = erc1155Details.length;\\n\\n        for (uint256 i; i < length; ) {\\n            IERC1155(erc1155Details[i].tokenAddr).safeBatchTransferFrom(\\n                _msgSender(),\\n                address(this),\\n                erc1155Details[i].ids,\\n                erc1155Details[i].amounts,\\n                \\\"\\\"\\n            );\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n// TODO: add logic in converter\\n    function _conversionHelper(ConverstionDetails[] memory _converstionDetails)\\n        internal\\n    {\\n        uint256 length = _converstionDetails.length;\\n        bool success;\\n\\n        for (uint256 i; i < length; ) {\\n            // convert to desired asset\\n            (success, ) = converter.delegatecall(\\n                _converstionDetails[i].conversionData\\n            );\\n            // check if the call passed successfully\\n            _checkCallResult(success);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function _trade(TradeDetails[] memory _tradeDetails) internal {\\n        uint256 length = _tradeDetails.length;\\n        bool success;\\n\\n        for (uint256 i; i < length; ) {\\n            // get market details\\n            Market memory market = _getMarket(_tradeDetails[i].marketId);\\n\\n            // execute trade\\n            (success, ) = market.isLib\\n                ? market.proxy.delegatecall(_tradeDetails[i].tradeData)\\n                : market.proxy.call{value: _tradeDetails[i].value}(\\n                    _tradeDetails[i].tradeData\\n                );\\n\\n            // check if the call passed successfully\\n            _checkCallResult(success);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function _tradeWithLimit(\\n        TradeDetails[] memory _tradeDetails,\\n        uint256 maxItemLimit\\n    ) internal {\\n        uint256 length = _tradeDetails.length;\\n        uint256 successCount;\\n        bool success;\\n\\n        for (uint256 i; i < length; ) {\\n            // get market details\\n            Market memory market = _getMarket(_tradeDetails[i].marketId);\\n\\n            // execute trade\\n            (success, ) = market.isLib\\n                ? market.proxy.delegatecall(_tradeDetails[i].tradeData)\\n                : market.proxy.call{value: _tradeDetails[i].value}(\\n                    _tradeDetails[i].tradeData\\n                );\\n\\n            // check if the call passed successfully\\n            _checkCallResult(success);\\n\\n            if (success) {\\n                unchecked {\\n                    successCount++;\\n                }\\n\\n                if (successCount >= maxItemLimit) {\\n                    break;\\n                }\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    /* function _tradeWithLimitV2(\\n        TradeDetails[] memory _tradeDetails,\\n        uint256 maxItemLimit\\n    ) internal {\\n        uint256 length = _tradeDetails.length;\\n        uint256 successCount;\\n        bool success;\\n        bytes memory successCountData;\\n\\n        for (uint256 i; i < length; ) {\\n            // get market details\\n            Market memory market = markets[_tradeDetails[i].marketId];\\n            // market should be active\\n            require(market.isActive, \\\"_trade: InActive Market\\\");\\n            // execute trade\\n            (success, successCountData) = market.isLib\\n                ? market.proxy.delegatecall(\\n                    abi.encodeWithSelector(\\n                        SeaportMarketV1.buyAssetsForEthWithLimit.selector,\\n                        _tradeDetails[i].tradeData,\\n                        maxItemLimit\\n                    )\\n                )\\n                : market.proxy.call{value: _tradeDetails[i].value}(\\n                    _tradeDetails[i].tradeData\\n                );\\n            // check if the call passed successfully\\n            _checkCallResult(success);\\n\\n            if (success) {\\n                uint256 _successCount;\\n                (_successCount) = abi.decode(successCountData, (uint256));\\n\\n                unchecked {\\n                    successCount = successCount + _successCount;\\n                }\\n\\n                if (successCount >= maxItemLimit) {\\n                    break;\\n                }\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    } */\\n\\n    function _returnDust(address[] memory _tokens) internal {\\n        // return remaining ETH (if any)\\n        assembly {\\n            if gt(selfbalance(), 0) {\\n                let callStatus := call(\\n                    gas(),\\n                    caller(),\\n                    selfbalance(),\\n                    0,\\n                    0,\\n                    0,\\n                    0\\n                )\\n            }\\n        }\\n\\n        // return remaining tokens (if any)\\n        uint256 length = _tokens.length;\\n\\n        for (uint256 i; i < length; ) {\\n            if (IERC20(_tokens[i]).balanceOf(address(this)) > 0) {\\n                _tokens[i].call(\\n                    abi.encodeWithSelector(\\n                        0xa9059cbb,\\n                        msg.sender,\\n                        IERC20(_tokens[i]).balanceOf(address(this))\\n                    )\\n                );\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function batchSellERC721Assets(\\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\\n        TradeDetails[] memory tradeDetails\\n    ) external payable nonReentrant {\\n        // transfer assets to sell\\n        uint256 length = erc721Details.length;\\n\\n        for (uint256 i; i < length; ) {\\n            uint256 _length = erc721Details[i].ids.length;\\n\\n            for (uint256 j; j < _length; ) {\\n                IERC721(erc721Details[i].tokenAddr).transferFrom(\\n                    _msgSender(),\\n                    address(this),\\n                    erc721Details[i].ids[j]\\n                );\\n\\n                unchecked {\\n                    j++;\\n                }\\n            }\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        // execute trades\\n        _trade(tradeDetails);\\n\\n        // return remaining ETH (if any)\\n        assembly {\\n            if gt(selfbalance(), 0) {\\n                let callStatus := call(\\n                    gas(),\\n                    caller(),\\n                    selfbalance(),\\n                    0,\\n                    0,\\n                    0,\\n                    0\\n                )\\n            }\\n        }\\n    }\\n\\n    function batchSell(\\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\\n        ERC1155Details[] memory erc1155Details,\\n        TradeDetails[] memory tradeDetails\\n    ) external payable nonReentrant {\\n        // transfer ERC721 assets to sell\\n        uint256 length = erc721Details.length;\\n\\n        for (uint256 i; i < length; ) {\\n            uint256 _length = erc721Details[i].ids.length;\\n\\n            for (uint256 j; j < _length; ) {\\n                IERC721(erc721Details[i].tokenAddr).transferFrom(\\n                    _msgSender(),\\n                    address(this),\\n                    erc721Details[i].ids[j]\\n                );\\n\\n                unchecked {\\n                    j++;\\n                }\\n            }\\n        }\\n\\n        // transfer ERC1155 assets to sell\\n        length = erc1155Details.length;\\n\\n        for (uint256 i; i < length; ) {\\n            IERC1155(erc1155Details[i].tokenAddr).safeBatchTransferFrom(\\n                _msgSender(),\\n                address(this),\\n                erc1155Details[i].ids,\\n                erc1155Details[i].amounts,\\n                \\\"\\\"\\n            );\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        // execute trades\\n        _trade(tradeDetails);\\n\\n        // return remaining ETH (if any)\\n        assembly {\\n            if gt(selfbalance(), 0) {\\n                let callStatus := call(\\n                    gas(),\\n                    caller(),\\n                    selfbalance(),\\n                    0,\\n                    0,\\n                    0,\\n                    0\\n                )\\n            }\\n        }\\n    }\\n\\n    function batchBuyWithEth(TradeDetails[] memory tradeDetails)\\n        external\\n        payable\\n        nonReentrant\\n    {\\n        // execute trades\\n        _trade(tradeDetails);\\n\\n        // return remaining ETH (if any)\\n        assembly {\\n            if gt(selfbalance(), 0) {\\n                let callStatus := call(\\n                    gas(),\\n                    caller(),\\n                    selfbalance(),\\n                    0,\\n                    0,\\n                    0,\\n                    0\\n                )\\n            }\\n        }\\n    }\\n\\n    function batchBuyWithEthWithLimit(\\n        TradeDetails[] memory tradeDetails,\\n        uint256 maxItemLimit\\n    ) external payable nonReentrant {\\n        // execute trades\\n        _tradeWithLimit(tradeDetails, maxItemLimit);\\n\\n        // return remaining ETH (if any)\\n        assembly {\\n            if gt(selfbalance(), 0) {\\n                let callStatus := call(\\n                    gas(),\\n                    caller(),\\n                    selfbalance(),\\n                    0,\\n                    0,\\n                    0,\\n                    0\\n                )\\n            }\\n        }\\n    }\\n\\n    function batchBuyWithERC20sWithLimit(\\n        ERC20Details memory erc20Details,\\n        TradeDetails[] memory tradeDetails,\\n        ConverstionDetails[] memory converstionDetails,\\n        address[] memory dustTokens,\\n        uint256 maxItemLimit\\n    ) external payable nonReentrant {\\n        // transfer ERC20 tokens from the sender to this contract\\n        uint256 length = erc20Details.tokenAddrs.length;\\n\\n        for (uint256 i; i < length; ) {\\n            erc20Details.tokenAddrs[i].call(\\n                abi.encodeWithSelector(\\n                    0x23b872dd,\\n                    msg.sender,\\n                    address(this),\\n                    erc20Details.amounts[i]\\n                )\\n            );\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        // Convert any assets if needed\\n        _conversionHelper(converstionDetails);\\n\\n        // execute trades\\n        _tradeWithLimit(tradeDetails, maxItemLimit);\\n\\n        // return dust tokens (if any)\\n        _returnDust(dustTokens);\\n    }\\n\\n    /* function batchBuyWithEthWithLimitV2(\\n        TradeDetails[] memory tradeDetails,\\n        uint256 maxItemLimit\\n    ) external payable nonReentrant {\\n        // execute trades\\n        _tradeWithLimitV2(tradeDetails, maxItemLimit);\\n\\n        // return remaining ETH (if any)\\n        assembly {\\n            if gt(selfbalance(), 0) {\\n                let callStatus := call(\\n                    gas(),\\n                    caller(),\\n                    selfbalance(),\\n                    0,\\n                    0,\\n                    0,\\n                    0\\n                )\\n            }\\n        }\\n    } */\\n\\n    function batchBuyWithERC20s(\\n        ERC20Details memory erc20Details,\\n        TradeDetails[] memory tradeDetails,\\n        ConverstionDetails[] memory converstionDetails,\\n        address[] memory dustTokens\\n    ) external payable nonReentrant {\\n        // transfer ERC20 tokens from the sender to this contract\\n        uint256 length = erc20Details.tokenAddrs.length;\\n\\n        for (uint256 i; i < length; ) {\\n            erc20Details.tokenAddrs[i].call(\\n                abi.encodeWithSelector(\\n                    0x23b872dd,\\n                    msg.sender,\\n                    address(this),\\n                    erc20Details.amounts[i]\\n                )\\n            );\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        // Convert any assets if needed\\n        _conversionHelper(converstionDetails);\\n\\n        // execute trades\\n        _trade(tradeDetails);\\n\\n        // return dust tokens (if any)\\n        _returnDust(dustTokens);\\n    }\\n\\n    // swaps any combination of ERC-20/721/1155\\n    // User needs to approve assets before invoking swap\\n    // WARNING: DO NOT SEND TOKENS TO THIS FUNCTION DIRECTLY!!!\\n    function multiAssetSwap(\\n        ERC20Details memory erc20Details,\\n        SpecialTransferHelper.ERC721Details[] memory erc721Details,\\n        ERC1155Details[] memory erc1155Details,\\n        ConverstionDetails[] memory converstionDetails,\\n        TradeDetails[] memory tradeDetails,\\n        address[] memory dustTokens\\n    ) external payable nonReentrant {\\n        // transfer all tokens\\n        _transferFromHelper(erc20Details, erc721Details, erc1155Details);\\n\\n        // Convert any assets if needed\\n        _conversionHelper(converstionDetails);\\n\\n        // execute trades\\n        _trade(tradeDetails);\\n\\n        // return dust tokens (if any)\\n        _returnDust(dustTokens);\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) public virtual returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) public virtual returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return 0x150b7a02;\\n    }\\n\\n    // Used by ERC721BasicToken.sol\\n    function onERC721Received(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return 0xf0b9e5ba;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        external\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        return interfaceId == this.supportsInterface.selector;\\n    }\\n\\n    receive() external payable {}\\n\\n    // Emergency function: In case any ETH get stuck in the contract unintentionally\\n    // Only owner can retrieve the asset balance to a recipient address\\n    function rescueETH(address recipient) external onlyOwner {\\n        _transferEth(recipient, address(this).balance);\\n    }\\n\\n    // Emergency function: In case any ERC20 tokens get stuck in the contract unintentionally\\n    // Only owner can retrieve the asset balance to a recipient address\\n    function rescueERC20(address asset, address recipient) external onlyOwner {\\n        asset.call(\\n            abi.encodeWithSelector(\\n                0xa9059cbb,\\n                recipient,\\n                IERC20(asset).balanceOf(address(this))\\n            )\\n        );\\n    }\\n\\n    // Emergency function: In case any ERC721 tokens get stuck in the contract unintentionally\\n    // Only owner can retrieve the asset balance to a recipient address\\n    function rescueERC721(\\n        address asset,\\n        uint256[] calldata ids,\\n        address recipient\\n    ) external onlyOwner {\\n        uint256 length = ids.length;\\n\\n        for (uint256 i; i < length; ) {\\n            IERC721(asset).transferFrom(address(this), recipient, ids[i]);\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    // Emergency function: In case any ERC1155 tokens get stuck in the contract unintentionally\\n    // Only owner can retrieve the asset balance to a recipient address\\n    function rescueERC1155(\\n        address asset,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        address recipient\\n    ) external onlyOwner {\\n        uint256 length = ids.length;\\n\\n        for (uint256 i; i < length; ) {\\n            IERC1155(asset).safeTransferFrom(\\n                address(this),\\n                recipient,\\n                ids[i],\\n                amounts[i],\\n                \\\"\\\"\\n            );\\n\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/markets/MarketRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract MarketRegistry is Ownable {\\n    struct Market {\\n        address proxy;\\n        bool isLib;\\n        bool isActive;\\n    }\\n\\n    Market[] public markets;\\n\\n    function _getMarket(uint256 marketId)\\n        internal\\n        view\\n        returns (Market memory)\\n    {\\n        Market memory market = markets[marketId];\\n\\n        // market should be active\\n        // NOTE: We can just skip this check by setting the proxy address of the exploited markets.\\n        require(market.isActive, \\\"_trade: InActive Market\\\");\\n\\n        return market;\\n    }\\n\\n    function addMarket(address proxy, bool isLib) external onlyOwner {\\n        markets.push(Market(proxy, isLib, true));\\n    }\\n\\n    function setMarketStatus(uint256 marketId, bool newStatus)\\n        external\\n        onlyOwner\\n    {\\n        Market storage market = markets[marketId];\\n        market.isActive = newStatus;\\n    }\\n\\n    function setMarketProxy(\\n        uint256 marketId,\\n        address newProxy,\\n        bool isLib\\n    ) external onlyOwner {\\n        Market storage market = markets[marketId];\\n        market.proxy = newProxy;\\n        market.isLib = isLib;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/SpecialTransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"../../interfaces/punks/ICryptoPunks.sol\\\";\\nimport \\\"../../interfaces/punks/IWrappedPunk.sol\\\";\\nimport \\\"../../interfaces/mooncats/IMoonCatsRescue.sol\\\";\\n\\ncontract SpecialTransferHelper is Context {\\n    struct ERC721Details {\\n        address tokenAddr;\\n        address[] to;\\n        uint256[] ids;\\n    }\\n\\n    function _uintToBytes5(uint256 id)\\n        internal\\n        pure\\n        returns (bytes5 slicedDataBytes5)\\n    {\\n        bytes memory _bytes = new bytes(32);\\n        assembly {\\n            mstore(add(_bytes, 32), id)\\n        }\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // The first word of the slice result is potentially a partial\\n            // word read from the original array. To read it, we calculate\\n            // the length of that partial word and start copying that many\\n            // bytes into the array. The first word we copy will start with\\n            // data we don't care about, but the last `lengthmod` bytes will\\n            // land at the beginning of the contents of the new array. When\\n            // we're done copying, we overwrite the full first word with\\n            // the actual length of the slice.\\n            let lengthmod := and(5, 31)\\n\\n            // The multiplication in the next line is necessary\\n            // because when slicing multiples of 32 bytes (lengthmod == 0)\\n            // the following copy loop was copying the origin's length\\n            // and then ending prematurely not copying everything it should.\\n            let mc := add(\\n                add(tempBytes, lengthmod),\\n                mul(0x20, iszero(lengthmod))\\n            )\\n            let end := add(mc, 5)\\n\\n            for {\\n                // The multiplication in the next line has the same exact purpose\\n                // as the one above.\\n                let cc := add(\\n                    add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))),\\n                    27\\n                )\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            mstore(tempBytes, 5)\\n\\n            //update free-memory pointer\\n            //allocating the array padded to 32 bytes like the compiler does now\\n            mstore(0x40, and(add(mc, 31), not(31)))\\n        }\\n\\n        assembly {\\n            slicedDataBytes5 := mload(add(tempBytes, 32))\\n        }\\n    }\\n\\n    function _acceptMoonCat(ERC721Details memory erc721Details) internal {\\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\\n            bytes5 catId = _uintToBytes5(erc721Details.ids[i]);\\n            address owner = IMoonCatsRescue(erc721Details.tokenAddr).catOwners(\\n                catId\\n            );\\n            require(\\n                owner == _msgSender(),\\n                \\\"_acceptMoonCat: invalid mooncat owner\\\"\\n            );\\n            IMoonCatsRescue(erc721Details.tokenAddr).acceptAdoptionOffer(catId);\\n        }\\n    }\\n\\n    function _transferMoonCat(ERC721Details memory erc721Details) internal {\\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\\n            IMoonCatsRescue(erc721Details.tokenAddr).giveCat(\\n                _uintToBytes5(erc721Details.ids[i]),\\n                erc721Details.to[i]\\n            );\\n        }\\n    }\\n\\n    function _acceptCryptoPunk(ERC721Details memory erc721Details) internal {\\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\\n            address owner = ICryptoPunks(erc721Details.tokenAddr)\\n                .punkIndexToAddress(erc721Details.ids[i]);\\n            require(\\n                owner == _msgSender(),\\n                \\\"_acceptCryptoPunk: invalid punk owner\\\"\\n            );\\n            ICryptoPunks(erc721Details.tokenAddr).buyPunk(erc721Details.ids[i]);\\n        }\\n    }\\n\\n    function _transferCryptoPunk(ERC721Details memory erc721Details) internal {\\n        for (uint256 i = 0; i < erc721Details.ids.length; i++) {\\n            ICryptoPunks(erc721Details.tokenAddr).transferPunk(\\n                erc721Details.to[i],\\n                erc721Details.ids[i]\\n            );\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private reentrancyStatus = 1;\\n\\n    modifier nonReentrant() {\\n        require(reentrancyStatus == 1, \\\"REENTRANCY\\\");\\n\\n        reentrancyStatus = 2;\\n\\n        _;\\n\\n        reentrancyStatus = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IERC1155 {\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external;\\n\\n    function balanceOf(address _owner, uint256 _id)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function isApprovedForAll(address account, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"interfaces/markets/tokens/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IERC721 {\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\n    ///  THEY MAY BE PERMANENTLY LOST\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\n    ///  `_tokenId` is not a valid NFT.\\n    /// @param _from The current owner of the NFT\\n    /// @param _to The new owner\\n    /// @param _tokenId The NFT to transfer\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    ) external payable;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) external;\\n\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    function balanceOf(address _owner) external view returns (uint256);\\n\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"interfaces/mooncats/IMoonCatsRescue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IMoonCatsRescue {\\n    function acceptAdoptionOffer(bytes5 catId) external payable;\\n\\n    function makeAdoptionOfferToAddress(\\n        bytes5 catId,\\n        uint256 price,\\n        address to\\n    ) external;\\n\\n    function giveCat(bytes5 catId, address to) external;\\n\\n    function catOwners(bytes5 catId) external view returns (address);\\n\\n    function rescueOrder(uint256 rescueIndex)\\n        external\\n        view\\n        returns (bytes5 catId);\\n}\\n\"\r\n    },\r\n    \"interfaces/punks/ICryptoPunks.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface ICryptoPunks {\\n    function punkIndexToAddress(uint256 index)\\n        external\\n        view\\n        returns (address owner);\\n\\n    function offerPunkForSaleToAddress(\\n        uint256 punkIndex,\\n        uint256 minSalePriceInWei,\\n        address toAddress\\n    ) external;\\n\\n    function buyPunk(uint256 punkIndex) external payable;\\n\\n    function transferPunk(address to, uint256 punkIndex) external;\\n}\\n\"\r\n    },\r\n    \"interfaces/punks/IWrappedPunk.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IWrappedPunk {\\n    /**\\n     * @dev Mints a wrapped punk\\n     */\\n    function mint(uint256 punkIndex) external;\\n\\n    /**\\n     * @dev Burns a specific wrapped punk\\n     */\\n    function burn(uint256 punkIndex) external;\\n\\n    /**\\n     * @dev Registers proxy\\n     */\\n    function registerProxy() external;\\n\\n    /**\\n     * @dev Gets proxy address\\n     */\\n    function proxyInfo(address user) external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000000,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_converter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"GOV\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLib\",\"type\":\"bool\"}],\"name\":\"addMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GemSwapV2.ERC20Details\",\"name\":\"erc20Details\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"conversionData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.ConverstionDetails[]\",\"name\":\"converstionDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"dustTokens\",\"type\":\"address[]\"}],\"name\":\"batchBuyWithERC20s\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GemSwapV2.ERC20Details\",\"name\":\"erc20Details\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"conversionData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.ConverstionDetails[]\",\"name\":\"converstionDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"dustTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"maxItemLimit\",\"type\":\"uint256\"}],\"name\":\"batchBuyWithERC20sWithLimit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"}],\"name\":\"batchBuyWithEth\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"maxItemLimit\",\"type\":\"uint256\"}],\"name\":\"batchBuyWithEthWithLimit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SpecialTransferHelper.ERC721Details[]\",\"name\":\"erc721Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GemSwapV2.ERC1155Details[]\",\"name\":\"erc1155Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"}],\"name\":\"batchSell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SpecialTransferHelper.ERC721Details[]\",\"name\":\"erc721Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"}],\"name\":\"batchSellERC721Assets\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLib\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GemSwapV2.ERC20Details\",\"name\":\"erc20Details\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"internalType\":\"struct SpecialTransferHelper.ERC721Details[]\",\"name\":\"erc721Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GemSwapV2.ERC1155Details[]\",\"name\":\"erc1155Details\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"bytes\",\"name\":\"conversionData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.ConverstionDetails[]\",\"name\":\"converstionDetails\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"tradeData\",\"type\":\"bytes\"}],\"internalType\":\"struct GemSwapV2.TradeDetails[]\",\"name\":\"tradeDetails\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"dustTokens\",\"type\":\"address[]\"}],\"name\":\"multiAssetSwap\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"punkProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC1155\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"setConverter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"newProxy\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isLib\",\"type\":\"bool\"}],\"name\":\"setMarketProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"marketId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"setMarketStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setOneTimeApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guardian\",\"type\":\"address\"}],\"name\":\"updateGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "GemSwapV2", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "10000000", "ConstructorArguments": "000000000000000000000000073ab1c0cad3677cde9bdb0cdeedc2085c029579000000000000000000000000073ab1c0cad3677cde9bdb0cdeedc2085c029579", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}