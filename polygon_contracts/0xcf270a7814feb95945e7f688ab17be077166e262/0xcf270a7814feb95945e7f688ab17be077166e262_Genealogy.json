{"SourceCode": "// File: @openzeppelin/contracts/security/ReentrancyGuard.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/IERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns the decimals places of the token.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: @openzeppelin/contracts/token/ERC20/ERC20.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Implementation of the {IERC20} interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using {_mint}.\r\n * For a generic mechanism see {ERC20PresetMinterPauser}.\r\n *\r\n * TIP: For a detailed writeup see our guide\r\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\r\n * to implement supply mechanisms].\r\n *\r\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\r\n * instead returning `false` on failure. This behavior is nonetheless\r\n * conventional and does not conflict with the expectations of ERC20\r\n * applications.\r\n *\r\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See {IERC20-approve}.\r\n */\r\ncontract ERC20 is Context, IERC20, IERC20Metadata {\r\n    mapping(address => uint256) private _balances;\r\n\r\n    mapping(address => mapping(address => uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    string private _name;\r\n    string private _symbol;\r\n\r\n    /**\r\n     * @dev Sets the values for {name} and {symbol}.\r\n     *\r\n     * The default value of {decimals} is 18. To select a different value for\r\n     * {decimals} you should overload it.\r\n     *\r\n     * All two of these values are immutable: they can only be set once during\r\n     * construction.\r\n     */\r\n    constructor(string memory name_, string memory symbol_) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the name of the token.\r\n     */\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the symbol of the token, usually a shorter version of the\r\n     * name.\r\n     */\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of decimals used to get its user representation.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between\r\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\r\n     * overridden;\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it in\r\n     * no way affects any of the arithmetic of the contract, including\r\n     * {IERC20-balanceOf} and {IERC20-transfer}.\r\n     */\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 18;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-totalSupply}.\r\n     */\r\n    function totalSupply() public view virtual override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-balanceOf}.\r\n     */\r\n    function balanceOf(address account) public view virtual override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transfer}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _transfer(owner, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-allowance}.\r\n     */\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-approve}.\r\n     *\r\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\r\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC20-transferFrom}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of {ERC20}.\r\n     *\r\n     * NOTE: Does not update the allowance if the current allowance\r\n     * is the maximum `uint256`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` and `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     * - the caller must have allowance for ``from``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual override returns (bool) {\r\n        address spender = _msgSender();\r\n        _spendAllowance(from, spender, amount);\r\n        _transfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to {approve} that can be used as a mitigation for\r\n     * problems described in {IERC20-approve}.\r\n     *\r\n     * Emits an {Approval} event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\r\n        address owner = _msgSender();\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\r\n        unchecked {\r\n            _approve(owner, spender, currentAllowance - subtractedValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves `amount` of tokens from `from` to `to`.\r\n     *\r\n     * This internal function is equivalent to {transfer}, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `from` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(from != address(0), \"ERC20: transfer from the zero address\");\r\n        require(to != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _beforeTokenTransfer(from, to, amount);\r\n\r\n        uint256 fromBalance = _balances[from];\r\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\r\n        unchecked {\r\n            _balances[from] = fromBalance - amount;\r\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\r\n            // decrementing then incrementing.\r\n            _balances[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        _afterTokenTransfer(from, to, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _beforeTokenTransfer(address(0), account, amount);\r\n\r\n        _totalSupply += amount;\r\n        unchecked {\r\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\r\n            _balances[account] += amount;\r\n        }\r\n        emit Transfer(address(0), account, amount);\r\n\r\n        _afterTokenTransfer(address(0), account, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a {Transfer} event with `to` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        unchecked {\r\n            _balances[account] = accountBalance - amount;\r\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\r\n            _totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(account, address(0), amount);\r\n\r\n        _afterTokenTransfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\r\n     *\r\n     * This internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = amount;\r\n        emit Approval(owner, spender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\r\n     *\r\n     * Does not update the allowance amount in case of infinite allowance.\r\n     * Revert if not enough allowance is available.\r\n     *\r\n     * Might emit an {Approval} event.\r\n     */\r\n    function _spendAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    ) internal virtual {\r\n        uint256 currentAllowance = allowance(owner, spender);\r\n        if (currentAllowance != type(uint256).max) {\r\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\r\n            unchecked {\r\n                _approve(owner, spender, currentAllowance - amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * has been transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _afterTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal virtual {}\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/SignedMath.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/math/Math.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/utils/Strings.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(int256 value) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}\r\n\r\n// File: github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol\r\n\r\n/*\r\n * @title String & slice utility library for Solidity contracts.\r\n * @author Nick Johnson <arachnid@notdot.net>\r\n *\r\n * @dev Functionality in this library is largely implemented using an\r\n *      abstraction called a 'slice'. A slice represents a part of a string -\r\n *      anything from the entire string to a single character, or even no\r\n *      characters at all (a 0-length slice). Since a slice only has to specify\r\n *      an offset and a length, copying and manipulating slices is a lot less\r\n *      expensive than copying and manipulating the strings they reference.\r\n *\r\n *      To further reduce gas costs, most functions on slice that need to return\r\n *      a slice modify the original one instead of allocating a new one; for\r\n *      instance, `s.split(\".\")` will return the text up to the first '.',\r\n *      modifying s to only contain the remainder of the string after the '.'.\r\n *      In situations where you do not want to modify the original slice, you\r\n *      can make a copy first with `.copy()`, for example:\r\n *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since\r\n *      Solidity has no memory management, it will result in allocating many\r\n *      short-lived slices that are later discarded.\r\n *\r\n *      Functions that return two slices come in two versions: a non-allocating\r\n *      version that takes the second slice as an argument, modifying it in\r\n *      place, and an allocating version that allocates and returns the second\r\n *      slice; see `nextRune` for example.\r\n *\r\n *      Functions that have to copy string data will return strings rather than\r\n *      slices; these can be cast back to slices for further processing if\r\n *      required.\r\n *\r\n *      For convenience, some functions are provided with non-modifying\r\n *      variants that create a new slice and return both; for instance,\r\n *      `s.splitNew('.')` leaves s unmodified, and returns two values\r\n *      corresponding to the left and right parts of the string.\r\n */\r\n\r\npragma solidity ^0.8.0;\r\n\r\nlibrary strings {\r\n    struct slice {\r\n        uint _len;\r\n        uint _ptr;\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint length) private pure {\r\n        // Copy word-length chunks while possible\r\n        for(; length >= 32; length -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = type(uint).max;\r\n        if (length > 0) {\r\n            mask = 256 ** (32 - length) - 1;\r\n        }\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire string.\r\n     * @param self The string to make a slice from.\r\n     * @return A newly allocated slice containing the entire string.\r\n     */\r\n    function toSlice(string memory self) internal pure returns (slice memory) {\r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(self, 0x20)\r\n        }\r\n        return slice(bytes(self).length, ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length of a null-terminated bytes32 string.\r\n     * @param self The value to find the length of.\r\n     * @return The length of the string, from 0 to 32.\r\n     */\r\n    function len(bytes32 self) internal pure returns (uint) {\r\n        uint ret;\r\n        if (self == 0)\r\n            return 0;\r\n        if (uint(self) & type(uint128).max == 0) {\r\n            ret += 16;\r\n            self = bytes32(uint(self) / 0x100000000000000000000000000000000);\r\n        }\r\n        if (uint(self) & type(uint64).max == 0) {\r\n            ret += 8;\r\n            self = bytes32(uint(self) / 0x10000000000000000);\r\n        }\r\n        if (uint(self) & type(uint32).max == 0) {\r\n            ret += 4;\r\n            self = bytes32(uint(self) / 0x100000000);\r\n        }\r\n        if (uint(self) & type(uint16).max == 0) {\r\n            ret += 2;\r\n            self = bytes32(uint(self) / 0x10000);\r\n        }\r\n        if (uint(self) & type(uint8).max == 0) {\r\n            ret += 1;\r\n        }\r\n        return 32 - ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a slice containing the entire bytes32, interpreted as a\r\n     *      null-terminated utf-8 string.\r\n     * @param self The bytes32 value to convert to a slice.\r\n     * @return A new slice containing the value of the input argument up to the\r\n     *         first null.\r\n     */\r\n    function toSliceB32(bytes32 self) internal pure returns (slice memory ret) {\r\n        // Allocate space for `self` in memory, copy it there, and point ret at it\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(0x40, add(ptr, 0x20))\r\n            mstore(ptr, self)\r\n            mstore(add(ret, 0x20), ptr)\r\n        }\r\n        ret._len = len(self);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a new slice containing the same data as the current slice.\r\n     * @param self The slice to copy.\r\n     * @return A new slice containing the same data as `self`.\r\n     */\r\n    function copy(slice memory self) internal pure returns (slice memory) {\r\n        return slice(self._len, self._ptr);\r\n    }\r\n\r\n    /*\r\n     * @dev Copies a slice to a new string.\r\n     * @param self The slice to copy.\r\n     * @return A newly allocated string containing the slice's text.\r\n     */\r\n    function toString(slice memory self) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        memcpy(retptr, self._ptr, self._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the length in runes of the slice. Note that this operation\r\n     *      takes time proportional to the length of the slice; avoid using it\r\n     *      in loops, and call `slice.empty()` if you only need to know whether\r\n     *      the slice is empty or not.\r\n     * @param self The slice to operate on.\r\n     * @return The length of the slice in runes.\r\n     */\r\n    function len(slice memory self) internal pure returns (uint l) {\r\n        // Starting at ptr-31 means the LSB will be the byte we care about\r\n        uint ptr = self._ptr - 31;\r\n        uint end = ptr + self._len;\r\n        for (l = 0; ptr < end; l++) {\r\n            uint8 b;\r\n            assembly { b := and(mload(ptr), 0xFF) }\r\n            if (b < 0x80) {\r\n                ptr += 1;\r\n            } else if(b < 0xE0) {\r\n                ptr += 2;\r\n            } else if(b < 0xF0) {\r\n                ptr += 3;\r\n            } else if(b < 0xF8) {\r\n                ptr += 4;\r\n            } else if(b < 0xFC) {\r\n                ptr += 5;\r\n            } else {\r\n                ptr += 6;\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice is empty (has a length of 0).\r\n     * @param self The slice to operate on.\r\n     * @return True if the slice is empty, False otherwise.\r\n     */\r\n    function empty(slice memory self) internal pure returns (bool) {\r\n        return self._len == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a positive number if `other` comes lexicographically after\r\n     *      `self`, a negative number if it comes before, or zero if the\r\n     *      contents of the two slices are equal. Comparison is done per-rune,\r\n     *      on unicode codepoints.\r\n     * @param self The first slice to compare.\r\n     * @param other The second slice to compare.\r\n     * @return The result of the comparison.\r\n     */\r\n    function compare(slice memory self, slice memory other) internal pure returns (int) {\r\n        uint shortest = self._len;\r\n        if (other._len < self._len)\r\n            shortest = other._len;\r\n\r\n        uint selfptr = self._ptr;\r\n        uint otherptr = other._ptr;\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint mask = type(uint).max; // 0xffff...\r\n                if(shortest < 32) {\r\n                  mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                unchecked {\r\n                    uint diff = (a & mask) - (b & mask);\r\n                    if (diff != 0)\r\n                        return int(diff);\r\n                }\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n        return int(self._len) - int(other._len);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the two slices contain the same text.\r\n     * @param self The first slice to compare.\r\n     * @param self The second slice to compare.\r\n     * @return True if the slices are equal, false otherwise.\r\n     */\r\n    function equals(slice memory self, slice memory other) internal pure returns (bool) {\r\n        return compare(self, other) == 0;\r\n    }\r\n\r\n    /*\r\n     * @dev Extracts the first rune in the slice into `rune`, advancing the\r\n     *      slice to point to the next rune and returning `self`.\r\n     * @param self The slice to operate on.\r\n     * @param rune The slice that will contain the first rune.\r\n     * @return `rune`.\r\n     */\r\n    function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) {\r\n        rune._ptr = self._ptr;\r\n\r\n        if (self._len == 0) {\r\n            rune._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        uint l;\r\n        uint b;\r\n        // Load the first byte of the rune into the LSBs of b\r\n        assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) }\r\n        if (b < 0x80) {\r\n            l = 1;\r\n        } else if(b < 0xE0) {\r\n            l = 2;\r\n        } else if(b < 0xF0) {\r\n            l = 3;\r\n        } else {\r\n            l = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (l > self._len) {\r\n            rune._len = self._len;\r\n            self._ptr += self._len;\r\n            self._len = 0;\r\n            return rune;\r\n        }\r\n\r\n        self._ptr += l;\r\n        self._len -= l;\r\n        rune._len = l;\r\n        return rune;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the first rune in the slice, advancing the slice to point\r\n     *      to the next rune.\r\n     * @param self The slice to operate on.\r\n     * @return A slice containing only the first rune from `self`.\r\n     */\r\n    function nextRune(slice memory self) internal pure returns (slice memory ret) {\r\n        nextRune(self, ret);\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the number of the first codepoint in the slice.\r\n     * @param self The slice to operate on.\r\n     * @return The number of the first codepoint in the slice.\r\n     */\r\n    function ord(slice memory self) internal pure returns (uint ret) {\r\n        if (self._len == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint word;\r\n        uint length;\r\n        uint divisor = 2 ** 248;\r\n\r\n        // Load the rune into the MSBs of b\r\n        assembly { word:= mload(mload(add(self, 32))) }\r\n        uint b = word / divisor;\r\n        if (b < 0x80) {\r\n            ret = b;\r\n            length = 1;\r\n        } else if(b < 0xE0) {\r\n            ret = b & 0x1F;\r\n            length = 2;\r\n        } else if(b < 0xF0) {\r\n            ret = b & 0x0F;\r\n            length = 3;\r\n        } else {\r\n            ret = b & 0x07;\r\n            length = 4;\r\n        }\r\n\r\n        // Check for truncated codepoints\r\n        if (length > self._len) {\r\n            return 0;\r\n        }\r\n\r\n        for (uint i = 1; i < length; i++) {\r\n            divisor = divisor / 256;\r\n            b = (word / divisor) & 0xFF;\r\n            if (b & 0xC0 != 0x80) {\r\n                // Invalid UTF-8 sequence\r\n                return 0;\r\n            }\r\n            ret = (ret * 64) | (b & 0x3F);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns the keccak-256 hash of the slice.\r\n     * @param self The slice to hash.\r\n     * @return The hash of the slice.\r\n     */\r\n    function keccak(slice memory self) internal pure returns (bytes32 ret) {\r\n        assembly {\r\n            ret := keccak256(mload(add(self, 32)), mload(self))\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if `self` starts with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function startsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        if (self._ptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let selfptr := mload(add(self, 0x20))\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` starts with `needle`, `needle` is removed from the\r\n     *      beginning of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        bool equal = true;\r\n        if (self._ptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let selfptr := mload(add(self, 0x20))\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n            self._ptr += needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns true if the slice ends with `needle`.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return True if the slice starts with the provided text, false otherwise.\r\n     */\r\n    function endsWith(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        if (self._len < needle._len) {\r\n            return false;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n\r\n        if (selfptr == needle._ptr) {\r\n            return true;\r\n        }\r\n\r\n        bool equal;\r\n        assembly {\r\n            let length := mload(needle)\r\n            let needleptr := mload(add(needle, 0x20))\r\n            equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n        }\r\n\r\n        return equal;\r\n    }\r\n\r\n    /*\r\n     * @dev If `self` ends with `needle`, `needle` is removed from the\r\n     *      end of `self`. Otherwise, `self` is unmodified.\r\n     * @param self The slice to operate on.\r\n     * @param needle The slice to search for.\r\n     * @return `self`\r\n     */\r\n    function until(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        if (self._len < needle._len) {\r\n            return self;\r\n        }\r\n\r\n        uint selfptr = self._ptr + self._len - needle._len;\r\n        bool equal = true;\r\n        if (selfptr != needle._ptr) {\r\n            assembly {\r\n                let length := mload(needle)\r\n                let needleptr := mload(add(needle, 0x20))\r\n                equal := eq(keccak256(selfptr, length), keccak256(needleptr, length))\r\n            }\r\n        }\r\n\r\n        if (equal) {\r\n            self._len -= needle._len;\r\n        }\r\n\r\n        return self;\r\n    }\r\n\r\n    // Returns the memory address of the first byte of the first occurrence of\r\n    // `needle` in `self`, or the first byte after `self` if not found.\r\n    function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr = selfptr;\r\n        uint idx;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask;\r\n                if (needlelen > 0) {\r\n                    mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n                }\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                uint end = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr >= end)\r\n                        return selfptr + selflen;\r\n                    ptr++;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n\r\n                for (idx = 0; idx <= selflen - needlelen; idx++) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr;\r\n                    ptr += 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr + selflen;\r\n    }\r\n\r\n    // Returns the memory address of the first byte after the last occurrence of\r\n    // `needle` in `self`, or the address of `self` if not found.\r\n    function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n        uint ptr;\r\n\r\n        if (needlelen <= selflen) {\r\n            if (needlelen <= 32) {\r\n                bytes32 mask;\r\n                if (needlelen > 0) {\r\n                    mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n                }\r\n\r\n                bytes32 needledata;\r\n                assembly { needledata := and(mload(needleptr), mask) }\r\n\r\n                ptr = selfptr + selflen - needlelen;\r\n                bytes32 ptrdata;\r\n                assembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n                while (ptrdata != needledata) {\r\n                    if (ptr <= selfptr)\r\n                        return selfptr;\r\n                    ptr--;\r\n                    assembly { ptrdata := and(mload(ptr), mask) }\r\n                }\r\n                return ptr + needlelen;\r\n            } else {\r\n                // For long needles, use hashing\r\n                bytes32 hash;\r\n                assembly { hash := keccak256(needleptr, needlelen) }\r\n                ptr = selfptr + (selflen - needlelen);\r\n                while (ptr >= selfptr) {\r\n                    bytes32 testHash;\r\n                    assembly { testHash := keccak256(ptr, needlelen) }\r\n                    if (hash == testHash)\r\n                        return ptr + needlelen;\r\n                    ptr -= 1;\r\n                }\r\n            }\r\n        }\r\n        return selfptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain everything from the first occurrence of\r\n     *      `needle` to the end of the slice. `self` is set to the empty slice\r\n     *      if `needle` is not found.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function find(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len -= ptr - self._ptr;\r\n        self._ptr = ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Modifies `self` to contain the part of the string from the start of\r\n     *      `self` to the end of the first occurrence of `needle`. If `needle`\r\n     *      is not found, `self` is set to the empty slice.\r\n     * @param self The slice to search and modify.\r\n     * @param needle The text to search for.\r\n     * @return `self`.\r\n     */\r\n    function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        self._len = ptr - self._ptr;\r\n        return self;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and `token` to everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = self._ptr;\r\n        token._len = ptr - self._ptr;\r\n        if (ptr == self._ptr + self._len) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n            self._ptr = ptr + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything after the first\r\n     *      occurrence of `needle`, and returning everything before it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` up to the first occurrence of `delim`.\r\n     */\r\n    function split(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        split(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and `token` to everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and `token` is set to the entirety of `self`.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @param token An output parameter to which the first token is written.\r\n     * @return `token`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) {\r\n        uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n        token._ptr = ptr;\r\n        token._len = self._len - (ptr - self._ptr);\r\n        if (ptr == self._ptr) {\r\n            // Not found\r\n            self._len = 0;\r\n        } else {\r\n            self._len -= token._len + needle._len;\r\n        }\r\n        return token;\r\n    }\r\n\r\n    /*\r\n     * @dev Splits the slice, setting `self` to everything before the last\r\n     *      occurrence of `needle`, and returning everything after it. If\r\n     *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n     *      and the entirety of `self` is returned.\r\n     * @param self The slice to split.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The part of `self` after the last occurrence of `delim`.\r\n     */\r\n    function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) {\r\n        rsplit(self, needle, token);\r\n    }\r\n\r\n    /*\r\n     * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return The number of occurrences of `needle` found in `self`.\r\n     */\r\n    function count(slice memory self, slice memory needle) internal pure returns (uint cnt) {\r\n        uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n        while (ptr <= self._ptr + self._len) {\r\n            cnt++;\r\n            ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Returns True if `self` contains `needle`.\r\n     * @param self The slice to search.\r\n     * @param needle The text to search for in `self`.\r\n     * @return True if `needle` is found in `self`, false otherwise.\r\n     */\r\n    function contains(slice memory self, slice memory needle) internal pure returns (bool) {\r\n        return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr;\r\n    }\r\n\r\n    /*\r\n     * @dev Returns a newly allocated string containing the concatenation of\r\n     *      `self` and `other`.\r\n     * @param self The first slice to concatenate.\r\n     * @param other The second slice to concatenate.\r\n     * @return The concatenation of the two strings.\r\n     */\r\n    function concat(slice memory self, slice memory other) internal pure returns (string memory) {\r\n        string memory ret = new string(self._len + other._len);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n        memcpy(retptr, self._ptr, self._len);\r\n        memcpy(retptr + self._len, other._ptr, other._len);\r\n        return ret;\r\n    }\r\n\r\n    /*\r\n     * @dev Joins an array of slices, using `self` as a delimiter, returning a\r\n     *      newly allocated string.\r\n     * @param self The delimiter to use.\r\n     * @param parts A list of slices to join.\r\n     * @return A newly allocated string containing all the slices in `parts`,\r\n     *         joined with `self`.\r\n     */\r\n    function join(slice memory self, slice[] memory parts) internal pure returns (string memory) {\r\n        if (parts.length == 0)\r\n            return \"\";\r\n\r\n        uint length = self._len * (parts.length - 1);\r\n        for(uint i = 0; i < parts.length; i++)\r\n            length += parts[i]._len;\r\n\r\n        string memory ret = new string(length);\r\n        uint retptr;\r\n        assembly { retptr := add(ret, 32) }\r\n\r\n        for(uint i = 0; i < parts.length; i++) {\r\n            memcpy(retptr, parts[i]._ptr, parts[i]._len);\r\n            retptr += parts[i]._len;\r\n            if (i < parts.length - 1) {\r\n                memcpy(retptr, self._ptr, self._len);\r\n                retptr += self._len;\r\n            }\r\n        }\r\n\r\n        return ret;\r\n    }\r\n}\r\n\r\n// File: genealogy.sol\r\n\r\n\r\npragma solidity ^0.8;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Genealogy is Ownable, ReentrancyGuard {\r\n\r\n    using strings for *;\r\n    struct Partner {\r\n        uint256 position_id;\r\n        address wallet_address;\r\n        string ebr_code;\r\n        string direction; // left or right of the upline\r\n        uint256 balance;\r\n        uint256 sum_left_balance;\r\n        uint256 sum_right_balance;\r\n        uint256 childs_count;\r\n        uint256 full_fill_level;\r\n        uint256 created_at;\r\n        uint256 last_update;\r\n        bool isValue;\r\n    }\r\n\r\n    function log_2(uint256 number) internal pure returns (uint8) {\r\n        require(number > 0, \"0\");\r\n        for (uint8 n = 0; n < 256; n++) {\r\n            if (number >= 2**n && number < 2**(n + 1)) {\r\n                return n;\r\n                }\r\n            }\r\n        }\r\n\r\n    function stringToUint(string memory s) internal pure returns (uint256) {\r\n        bytes memory b = bytes(s);\r\n        uint256 result = 0;\r\n        for (uint256 i = 0; i < b.length; i++) {\r\n            uint256 c = uint256(uint8(b[i]));\r\n            if (c >= 48 && c <= 57) {\r\n                result = result * 10 + (c - 48);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function createReffralString(\r\n        string memory _invitation_ebr_code,\r\n        string memory _refferal_ebr_code,\r\n        uint256 _position_id\r\n    ) internal pure returns (string memory) {\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    _invitation_ebr_code,\r\n                    \"-\",\r\n                    _refferal_ebr_code,\r\n                    \"-\",\r\n                    Strings.toString(_position_id),\r\n                    \"-\"\r\n                )\r\n            );\r\n    }\r\n\r\n    struct TransactionsLog {\r\n        address from;\r\n        uint256 amount;\r\n        string transaction_type;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    mapping(uint256 => Partner) public partnersByPositionId;\r\n    mapping(address => Partner) public partnersByWalletAddress;\r\n    mapping(string => Partner) partnersByEbrCode;\r\n    mapping(address => TransactionsLog[]) public transactionLogsByAddress;\r\n    mapping(address => string[]) invitationLinksByreferallWalletAdress;\r\n    mapping(address => string[]) invitationEbrPartnersByreferallWalletAddress;\r\n    uint256[] Childs;\r\n    uint256[] assume_full_fill_level_partners;\r\n    uint256[] each_level_childs_number;\r\n    string[] refferalCodes;\r\n    uint256 position_id_from_ebr_code;\r\n    uint256 partnerCount;\r\n    uint256[] position_ids;\r\n    address _owner;\r\n    address public StakingContractAddress;\r\n    address public DappTokenContractAddress;\r\n    address[] walletAddresses;\r\n\r\n    constructor(address stakeContractAddress, address dappTokenContractAddress)\r\n        payable\r\n    {\r\n        _owner=msg.sender;\r\n        StakingContractAddress = stakeContractAddress;\r\n        DappTokenContractAddress = dappTokenContractAddress;\r\n        Partner memory partner = Partner(\r\n            0,\r\n            msg.sender,\r\n            \"admin\",\r\n            \"none\",\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            block.timestamp,\r\n            block.timestamp,\r\n            true\r\n        );\r\n        partnersByEbrCode[\"admin\"] = partner;\r\n        position_ids.push(0);\r\n        partnersByPositionId[0] = partner;\r\n        partnersByWalletAddress[msg.sender] = partner;\r\n        walletAddresses.push(msg.sender);\r\n        partnerCount=1;\r\n    }\r\n\r\n    function isValidEbrCode(string memory _ebr_code)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (partnersByEbrCode[_ebr_code].isValue) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isValidPositionId(uint256 _position_id)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (partnersByPositionId[_position_id].isValue) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function isValidDirection(string memory _direction)\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        if (\r\n            keccak256(abi.encodePacked(_direction)) ==\r\n            keccak256(abi.encodePacked(\"l\")) ||\r\n            keccak256(abi.encodePacked(_direction)) ==\r\n            keccak256(abi.encodePacked(\"r\"))\r\n        ) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function getDirectionByPositionId(uint256 _position_id)\r\n        internal\r\n        pure\r\n        returns (string memory)\r\n    {\r\n        if (_position_id % 2 == 0) {\r\n            return \"r\";\r\n        } else {\r\n            return \"l\";\r\n        }\r\n    }\r\n\r\n    function IsValidEbrCode(string memory _ebr_code)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (partnersByEbrCode[_ebr_code].isValue) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function addRefferalCode(string memory _refferalCode) internal {\r\n        refferalCodes.push(_refferalCode);\r\n    }\r\n\r\n    function addInvitaionLinksByWalletAddress(string memory _refferalLink)\r\n        internal\r\n    {\r\n        invitationLinksByreferallWalletAdress[msg.sender].push(_refferalLink);\r\n    }\r\n\r\n    function addInvitationEbrCodesByWalletAddress(\r\n        string memory _invitation_code\r\n    ) internal {\r\n        invitationEbrPartnersByreferallWalletAddress[msg.sender].push(\r\n            _invitation_code\r\n        );\r\n    }\r\n\r\n    function isValidWalletAddress() internal view returns (bool) {\r\n        address sender = msg.sender;\r\n        if (partnersByWalletAddress[sender].isValue == true) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function myInvitationLinks() public view returns (string[] memory) {\r\n        return invitationLinksByreferallWalletAdress[msg.sender];\r\n    }\r\n\r\n    function isValidInvitationLink(string memory _invitation_link)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        for (uint256 i = 0; i < refferalCodes.length; i++) {\r\n            if (\r\n                keccak256(abi.encodePacked(refferalCodes[i])) ==\r\n                keccak256(abi.encodePacked(_invitation_link))\r\n            ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function createRefferalCode(\r\n        string memory _invitation_ebr_code,\r\n        uint256 _position_id\r\n    ) public returns (string memory) {\r\n        require(\r\n           IsValidEbrCode(_invitation_ebr_code) == false,\r\n           \"1\"\r\n        );\r\n        uint256 _upline = calcUplineFromPositionId(_position_id);\r\n        require(\r\n           isValidPositionId(_upline),\r\n            \"2\"\r\n        );\r\n        require(\r\n           isValidPositionId(_position_id) == false,\r\n            \"3\"\r\n        );\r\n        Partner memory refferal_partner = partnersByWalletAddress[msg.sender];\r\n        string memory refferalCode = createReffralString(\r\n            _invitation_ebr_code,\r\n            refferal_partner.ebr_code,\r\n            _position_id\r\n        );\r\n        addInvitaionLinksByWalletAddress(refferalCode);\r\n        addInvitationEbrCodesByWalletAddress(_invitation_ebr_code);\r\n        refferalCodes.push(refferalCode);\r\n        return refferalCode;\r\n    }\r\n\r\n    function addPartnerFromLink(string memory _invitation_link)\r\n        public\r\n        // returns (string memory result)\r\n    {\r\n        require(userIsStaker(), \"4\");\r\n        string memory direction;\r\n        string memory invitation_link = _invitation_link;\r\n        require(isValidWalletAddress() == false, \"5\");\r\n        require(\r\n            isValidInvitationLink(invitation_link),\r\n            \"1\"\r\n       );\r\n        strings.slice memory s = invitation_link.toSlice();\r\n        strings.slice memory delim = \"-\".toSlice();\r\n        string[] memory parts = new string[](s.count(delim));\r\n        for (uint256 i = 0; i < parts.length; i++) {\r\n            parts[i] = s.split(delim).toString();\r\n        }\r\n\r\n        string memory invited_ebr_code = parts[0];\r\n        uint256 position_id = stringToUint(parts[2]);\r\n        require(isValidPositionId(position_id) == false,\"1\");\r\n        string memory refferer_ebr_code = parts[1];\r\n        if (position_id % 2 == 0) {\r\n            direction = \"r\";\r\n        } else {\r\n            direction = \"l\";\r\n        }\r\n        uint256 balance = MyStakingBalance();\r\n        Partner memory partner = Partner(\r\n            position_id,\r\n            msg.sender,\r\n            invited_ebr_code,\r\n            direction,\r\n            balance,\r\n            0,\r\n            0,\r\n            0,\r\n            0,\r\n            block.timestamp,\r\n            block.timestamp,\r\n            true\r\n        );\r\n        // referral bonus\r\n        uint256 _amount = (balance * 1) / 10;\r\n        string memory _ebr_code = refferer_ebr_code;\r\n        Partner memory _referrer_partner = partnersByEbrCode[_ebr_code];\r\n        address _referrer_partner_address = _referrer_partner.wallet_address;\r\n        transferFromDappContract(_referrer_partner_address, _amount);\r\n        referralBonusLogs(msg.sender, _referrer_partner_address, _amount);\r\n        partnersByEbrCode[invited_ebr_code] = partner;\r\n        position_ids.push(position_id);\r\n        partnersByPositionId[position_id] = partner;\r\n        partnersByWalletAddress[msg.sender] = partner;\r\n        updateUplinesChildsCount(position_id);\r\n        updateUplinesFullFillLevel(position_id);\r\n        updateUplinesBalances(position_id, balance);\r\n        partnerCount++;\r\n        // return \"successfully add partner\";\r\n    }\r\n\r\n    function generatePositionId(\r\n        uint256 _upline_postion_id,\r\n        string memory _direction\r\n    ) internal view returns (uint256) {\r\n        require(\r\n            isValidDirection(_direction) == true,\r\n            \"6\"\r\n        );\r\n        require(\r\n           isValidPositionId(_upline_postion_id) == true,\r\n            \"2\"\r\n        );\r\n        if (\r\n            keccak256(abi.encodePacked(_direction)) ==\r\n            keccak256(abi.encodePacked(\"r\"))\r\n        ) {\r\n            return _upline_postion_id * 2 + 2;\r\n        } else {\r\n            return _upline_postion_id * 2 + 1;\r\n        }\r\n    }\r\n\r\n    function getPositionIdFromEbrCode(string memory _ebr_code)\r\n        internal\r\n        onlyOwner\r\n        returns (string memory)\r\n    {\r\n        if (isValidEbrCode(_ebr_code) == true) {\r\n            Partner storage partner = partnersByEbrCode[_ebr_code];\r\n            position_id_from_ebr_code = partner.position_id;\r\n            return Strings.toString(position_id_from_ebr_code);\r\n        } else {\r\n            return \"none\";\r\n        }\r\n    }\r\n\r\n    \r\n    function getPositionIdList() internal view returns (uint256[] memory) {\r\n        return position_ids;\r\n    }\r\n\r\n    function countPositionIds() internal view returns (uint256) {\r\n        return position_ids.length;\r\n    }\r\n\r\n    function getPartner(uint256 _position_id)\r\n        internal\r\n        view\r\n        onlyOwner\r\n        returns (Partner memory)\r\n    {\r\n        require(isValidPositionId(_position_id), \"3\");\r\n        return partnersByPositionId[_position_id];\r\n    }\r\n\r\n    // function calcNextChilds(uint256 _position_id)\r\n    //     public\r\n    //     pure\r\n    //     returns (uint256, uint256)\r\n    // {\r\n    //     uint256 left_child_position = _position_id * 2 + 1;\r\n    //     uint256 right_child_position = _position_id * 2 + 2;\r\n    //     return (left_child_position, right_child_position);\r\n    // }\r\n\r\n    function calcUplineFromPositionId(uint256 _position_id)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_position_id == 1 || _position_id == 0 || _position_id==2) {\r\n            return 0;\r\n        }\r\n        if (_position_id % 2 == 0) {\r\n            return (_position_id - 2) / 2;\r\n        } else {\r\n            return (_position_id - 1) / 2;\r\n        }\r\n    }\r\n\r\n    function getBalanceByPositionId(uint256 _position_id)\r\n        internal\r\n        view\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        Partner memory partner = partnersByPositionId[_position_id];\r\n        require(isValidPositionId(_position_id), \"3\");\r\n        return partner.balance;\r\n    }\r\n\r\n    function userIsStaker() internal returns (bool result) {\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"isStaker(address)\",\r\n            msg.sender\r\n        );\r\n        (, bytes memory returnData) = StakingContractAddress.call(\r\n            payload\r\n        );\r\n        result = abi.decode(returnData, (bool));\r\n        return result;\r\n    }\r\n\r\n    function _userIsStaker(address partner_wallet) internal returns (bool result) {\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"isStaker(address)\",\r\n            partner_wallet\r\n        );\r\n        (, bytes memory returnData) = StakingContractAddress.call(\r\n            payload\r\n        );\r\n        result = abi.decode(returnData, (bool));\r\n        return result;\r\n    }\r\n\r\n    function stakingBalance(address _staker_addr)\r\n        internal\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"getTotalUserStake(address)\",\r\n            _staker_addr\r\n        );\r\n        (, bytes memory returnData) = StakingContractAddress.call(\r\n            payload\r\n        );\r\n        uint256 balance = abi.decode(returnData, (uint256));\r\n        return balance;\r\n    }\r\n\r\n    function MyStakingBalance() internal returns (uint256) {\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"getTotalUserStake(address)\",\r\n            msg.sender\r\n        );\r\n        (, bytes memory returnData) = StakingContractAddress.call(\r\n            payload\r\n        );\r\n        uint256 balance = abi.decode(returnData, (uint256));\r\n        return balance;\r\n    }\r\n\r\n    function updateBalance(address _wallet_address)\r\n        internal\r\n        onlyOwner\r\n        returns (uint256)\r\n    {\r\n        Partner memory partner = partnersByWalletAddress[_wallet_address];\r\n        uint256 new_balance = stakingBalance(_wallet_address);\r\n        partner.balance = new_balance;\r\n        return new_balance;\r\n    }\r\n\r\n    function updateBalances() internal onlyOwner {\r\n        for (uint256 i = 0; i < walletAddresses.length; i++) {\r\n            updateBalance(walletAddresses[i]);\r\n        }\r\n    }\r\n\r\n    function updatePartner(Partner memory partner) internal {\r\n        address wallet_address = partner.wallet_address;\r\n        uint256 position_id = partner.position_id;\r\n        string memory ebr_code = partner.ebr_code;\r\n        partner.last_update = block.timestamp;\r\n        partnersByPositionId[position_id] = partner;\r\n        partnersByWalletAddress[wallet_address] = partner;\r\n        partnersByEbrCode[ebr_code] = partner;\r\n    }\r\n\r\n    function updateUplinesBalances(uint256 _position_id, uint256 amount)\r\n        internal\r\n    {\r\n        require(isValidPositionId(_position_id), \"3\");\r\n        bool not_done = true;\r\n        uint256 upline_position_id = calcUplineFromPositionId(_position_id);\r\n        if (_position_id == 1 || _position_id == 2) {\r\n            Partner memory partner = partnersByPositionId[0];\r\n            if (_position_id == 1) {\r\n                uint256 old_balance = partner.sum_left_balance;\r\n                uint256 new_balance = old_balance + amount;\r\n                partner.sum_left_balance = new_balance;\r\n                updatePartner(partner);\r\n            } else {\r\n                uint256 old_balance = partner.sum_right_balance;\r\n                uint256 new_balance = old_balance + amount;\r\n                partner.sum_right_balance = new_balance;\r\n                updatePartner(partner);\r\n            }\r\n        } else {\r\n            while (not_done) {\r\n                Partner memory partner = partnersByPositionId[\r\n                    upline_position_id\r\n                ];\r\n                if (\r\n                    keccak256(\r\n                        abi.encodePacked(getDirectionByPositionId(_position_id))\r\n                    ) == keccak256(abi.encodePacked(\"r\"))\r\n                ) {\r\n                    uint256 old_balance = partner.sum_right_balance;\r\n                    uint256 new_balance = old_balance + amount;\r\n                    partner.sum_right_balance = new_balance;\r\n                    updatePartner(partner);\r\n                } else {\r\n                    uint256 old_balance = partner.sum_left_balance;\r\n                    uint256 new_balance = old_balance + amount;\r\n                    partner.sum_left_balance = new_balance;\r\n                    updatePartner(partner);\r\n                }\r\n                uint256 previous_position_id = upline_position_id;\r\n                upline_position_id = calcUplineFromPositionId(upline_position_id);\r\n                if (upline_position_id == 0) {\r\n                    Partner memory partner = partnersByPositionId[0];\r\n                    if (previous_position_id == 1) {\r\n                        uint256 old_balance = partner.sum_left_balance;\r\n                        uint256 new_balance = old_balance + amount;\r\n                        partner.sum_left_balance = new_balance;\r\n                        updatePartner(partner);\r\n                    } else {\r\n                        uint256 old_balance = partner.sum_right_balance;\r\n                        uint256 new_balance = old_balance + amount;\r\n                        partner.sum_right_balance = new_balance;\r\n                        updatePartner(partner);\r\n                    }\r\n                    not_done = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateUplinesChildsCount(uint256 _position_id) internal {\r\n        require(isValidPositionId(_position_id), \"3\");\r\n        bool not_done = true;\r\n        uint256 upline_position_id = calcUplineFromPositionId(_position_id);\r\n        if (_position_id == 1 || _position_id == 2) {\r\n            Partner memory partner = partnersByPositionId[0];\r\n            uint256 old_child_count = partner.childs_count;\r\n            uint256 new_child_count = old_child_count + 1;\r\n            partner.childs_count = new_child_count;\r\n            updatePartner(partner);\r\n        } else {\r\n            while (not_done) {\r\n                if (upline_position_id == 0) {\r\n                    Partner memory partner = partnersByPositionId[0];\r\n                    partner.childs_count = partner.childs_count + 1;\r\n                    updatePartner(partner);\r\n                    break;\r\n                }\r\n                Partner memory partner = partnersByPositionId[upline_position_id];\r\n                partner.childs_count = partner.childs_count + 1;\r\n                updatePartner(partner);\r\n                upline_position_id = calcUplineFromPositionId(upline_position_id);\r\n            }\r\n        }\r\n    }\r\n\r\n    function calcFirstLeftChild(uint256 _number) internal pure returns (uint256) {\r\n        uint256 left_child = _number * 2 + 1;\r\n        return left_child;\r\n    }\r\n\r\n    // function getChildsByLevel(uint256 _position_id, uint256 _level)\r\n    //     public\r\n    //     returns (uint256[] memory)\r\n    // {\r\n    //     delete Childs;\r\n    //     for (uint256 i = 1; i <= _level; i++) {\r\n    //         uint256 left_child = calcFirstLeftChild(_position_id);\r\n    //         uint256 sub_child_numbers = 2**i;\r\n    //         for (uint256 j = 0; j < sub_child_numbers; j++) {\r\n    //             uint256 sub_child = left_child + j;\r\n    //             Childs.push(sub_child);\r\n    //             _position_id = left_child;\r\n    //         }\r\n    //     }\r\n    //     return Childs;\r\n    // }\r\n\r\n    function getChildsCountByLevel(uint256 _level) internal returns (uint256) {\r\n        delete each_level_childs_number;\r\n        uint256 result;\r\n        for (uint256 i = 1; i <= _level; i++) {\r\n            uint256 _level_childs_number = 2**i;\r\n            each_level_childs_number.push(_level_childs_number);\r\n        }\r\n        for (uint256 i = 0; i < each_level_childs_number.length; i++) {\r\n            uint256 previous_result = each_level_childs_number[i];\r\n            result = previous_result + result;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    function getFullLevelByChildsCount(uint256 _childs_number)\r\n        internal pure\r\n        returns (uint256)\r\n    {\r\n        return log_2(_childs_number);\r\n    }\r\n\r\n    function getChildsInSpecificLevel(uint256 _position_id, uint256 _level)\r\n        internal\r\n        returns (uint256[] memory)\r\n    {\r\n        delete Childs;\r\n        if (_level == 0) {\r\n            Childs.push(_position_id);\r\n            return Childs;\r\n        }\r\n        for (uint256 i = 1; i <= _level; i++) {\r\n            uint256 left_child = calcFirstLeftChild(_position_id);\r\n            _position_id = left_child;\r\n            if (i == _level) {\r\n                uint256 sub_child_numbers = 2**i;\r\n                for (uint256 j = 0; j < sub_child_numbers; j++) {\r\n                    uint256 sub_child = left_child + j;\r\n                    Childs.push(sub_child);\r\n                }\r\n                return Childs;\r\n            }\r\n        }\r\n    }\r\n\r\n    function FullFillLevel(uint256 _position_id) internal returns (uint256) {\r\n        delete assume_full_fill_level_partners;\r\n        Partner memory partner = partnersByPositionId[_position_id];\r\n        uint256 childs_count = partner.childs_count;\r\n        if (childs_count == 0) {\r\n            return 0;\r\n        }\r\n        bool not_done = true;\r\n        uint256 assume_full_fill_level = getFullLevelByChildsCount(\r\n            childs_count\r\n        );\r\n        while (not_done) {\r\n            assume_full_fill_level_partners = getChildsInSpecificLevel(\r\n                _position_id,\r\n                assume_full_fill_level\r\n            );\r\n            for (\r\n                uint256 i = 0;\r\n                i < assume_full_fill_level_partners.length;\r\n                i++\r\n            ) {\r\n                if (assume_full_fill_level == 0){\r\n                    break;\r\n                }\r\n                Partner memory child_partner = partnersByPositionId[\r\n                    assume_full_fill_level_partners[i]\r\n                ];\r\n                if (child_partner.isValue == false) {\r\n                    assume_full_fill_level = assume_full_fill_level - 1;\r\n                }\r\n            }\r\n            not_done = false;\r\n        }\r\n        uint256 full_fill_level = assume_full_fill_level;\r\n        return full_fill_level;\r\n    }\r\n\r\n    function updateUplinesFullFillLevel(uint256 _position_id) internal {\r\n        require(isValidPositionId(_position_id), \"3\");\r\n        bool not_done = true;\r\n        uint256 upline_position_id = calcUplineFromPositionId(_position_id);\r\n        if (_position_id == 1 || _position_id == 2) {\r\n            Partner memory partner = partnersByPositionId[0];\r\n            uint256 old_level = partner.full_fill_level;\r\n            uint256 new_level = FullFillLevel(0);\r\n            partner.full_fill_level = new_level;\r\n            updatePartner(partner);\r\n        } else {\r\n            while (not_done) {\r\n                Partner memory partner = partnersByPositionId[\r\n                    upline_position_id\r\n                ];\r\n                uint256 old_level = partner.full_fill_level;\r\n                uint256 new_level = FullFillLevel(0);\r\n                partner.full_fill_level = new_level;\r\n                updatePartner(partner);\r\n                upline_position_id = calcUplineFromPositionId(upline_position_id);\r\n                uint256 _position_id = upline_position_id;\r\n                if (_position_id == 0 && upline_position_id == 0) {\r\n                    Partner memory partner = partnersByPositionId[0];\r\n                    uint256 old_level = partner.full_fill_level;\r\n                    uint256 new_level = FullFillLevel(0);\r\n                    partner.full_fill_level = new_level;\r\n                    updatePartner(partner);\r\n                    not_done = false;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function transferFromDappContract(address _to, uint256 _amount) internal {\r\n        IERC20(DappTokenContractAddress).transfer(_to, _amount);\r\n    }\r\n\r\n    function calcPartnerStakingReward(address _staker_addr)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"getTotalUserRewards(address)\",\r\n            _staker_addr\r\n        );\r\n        (, bytes memory returnData) = StakingContractAddress.call(\r\n            payload\r\n        );\r\n        uint256 reward = abi.decode(returnData, (uint256));\r\n        return reward;\r\n    }\r\n\r\n    function calcUplinesPositionIdsFromPositionId(uint256 _position_id)\r\n        internal\r\n        returns (uint256[] memory)\r\n    {\r\n        delete Childs;\r\n        require(isValidPositionId(_position_id), \"3\");\r\n        bool not_done = true;\r\n        while (not_done) {\r\n            uint256 _upline_postion_id = calcUplineFromPositionId(_position_id);\r\n            Childs.push(_upline_postion_id);\r\n            _position_id = _upline_postion_id;\r\n            if (_position_id == 0) {\r\n                not_done = false;\r\n            }\r\n        }\r\n        return Childs;\r\n    }\r\n\r\n    function updateUplinesUniLevelRewards(uint256 _position_id)\r\n        public\r\n        payable\r\n        onlyOwner\r\n    {\r\n        require(isValidPositionId(_position_id), \"3\");\r\n        bool not_done = true;\r\n        while (not_done) {\r\n            Partner memory partner = partnersByPositionId[_position_id];\r\n            address partner_wallet_address = partner.wallet_address;\r\n            uint256 _reward = getStakerRewardsUpToNow(partner_wallet_address) /\r\n                100;\r\n            uint256[]\r\n                memory _upline_position_ids = calcUplinesPositionIdsFromPositionId(\r\n                    _position_id\r\n                );\r\n            for (uint256 i = 0; i < _upline_position_ids.length; i++) {\r\n                if (i < 20) {\r\n                    Partner\r\n                        memory one_of_upline_partners = partnersByPositionId[\r\n                            _upline_position_ids[i]\r\n                        ];\r\n                    address one_of_upline_partners_wallet_address = one_of_upline_partners\r\n                            .wallet_address;\r\n                    transferFromDappContract(\r\n                        one_of_upline_partners_wallet_address,\r\n                        _reward\r\n                    );\r\n                    TransactionsLog memory transactionslog = TransactionsLog(\r\n                        partner_wallet_address,\r\n                        _reward,\r\n                        \"uni_level_bonus\",\r\n                        block.timestamp\r\n                    );\r\n                    transactionLogsByAddress[\r\n                        one_of_upline_partners_wallet_address\r\n                    ].push(transactionslog);\r\n                }\r\n            }\r\n            _position_id = calcUplineFromPositionId(_position_id);\r\n            if (_position_id == 0) {\r\n                not_done = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getStakerRewardsUpToNow(address _staker_addr)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        bytes memory payload = abi.encodeWithSignature(\r\n            \"getTotalUserStake(address)\",\r\n            _staker_addr\r\n        );\r\n        (, bytes memory returnData) = StakingContractAddress.call(\r\n            payload\r\n        );\r\n        uint256 _reward = abi.decode(returnData, (uint256)) / 10;\r\n        return _reward;\r\n    }\r\n\r\n    function hasChild(address _user) external payable returns (bool){\r\n        Partner memory user = partnersByWalletAddress[_user];\r\n        uint256 user_position = user.position_id;\r\n        Partner memory right_child = partnersByPositionId[user_position*2+1];\r\n        Partner memory left_child = partnersByPositionId[user_position*2+2];\r\n        return  right_child.isValue || left_child.isValue;\r\n    }\r\n\r\n    function binaryBonus() public onlyOwner  {\r\n        for (uint256 i = 0; i < position_ids.length; i++) {\r\n            Partner memory partner = partnersByPositionId[position_ids[i]];\r\n            address partner_wallet_address = partner.wallet_address;\r\n            if (_userIsStaker(partner_wallet_address)){\r\n                uint256 left_balance = partner.sum_left_balance;\r\n                uint256 right_balance = partner.sum_right_balance;\r\n                if (left_balance < right_balance) {\r\n                    uint256 binary_reward = left_balance / 10;\r\n                    matchingBonus(position_ids[i], binary_reward);\r\n                    transferFromDappContract(partner_wallet_address, binary_reward);\r\n                    TransactionsLog memory transactionslog = TransactionsLog(\r\n                        partner_wallet_address,\r\n                        binary_reward,\r\n                        \"binary_reward\",\r\n                        block.timestamp\r\n                    );\r\n                    transactionLogsByAddress[partner_wallet_address].push(\r\n                        transactionslog\r\n                    );\r\n                    uint256 left_and_right_balance_difference = right_balance -\r\n                        left_balance;\r\n                    partner.sum_left_balance = 0;\r\n                    partner.sum_right_balance = left_and_right_balance_difference;\r\n                    updatePartner(partner);\r\n                } else {\r\n                    uint256 binary_reward = right_balance / 10;\r\n                    matchingBonus(position_ids[i], binary_reward);\r\n                    transferFromDappContract(partner_wallet_address, binary_reward);\r\n                    TransactionsLog memory transactionslog = TransactionsLog(\r\n                        partner_wallet_address,\r\n                        binary_reward,\r\n                        \"binary_reward\",\r\n                        block.timestamp\r\n                    );\r\n                    transactionLogsByAddress[partner_wallet_address].push(\r\n                        transactionslog\r\n                    );\r\n                    uint256 left_and_right_balance_difference = left_balance -\r\n                        right_balance;\r\n                    partner.sum_left_balance = left_and_right_balance_difference;\r\n                    partner.sum_right_balance = 0;\r\n                    updatePartner(partner);\r\n                }\r\n            }\r\n        }// return \"binary and matching bonuses shared successfully.\";\r\n    }\r\n    \r\n\r\n    function matchingBonus(uint256 _position_id, uint256 _binary_reward)\r\n        internal\r\n        onlyOwner\r\n    {\r\n        uint256 _level_one_reward = (_binary_reward * 5) / 100;\r\n        uint256 _level_two_reward = (_binary_reward * 3) / 100;\r\n        uint256 _level_three_reward = (_binary_reward * 2) / 100;\r\n        if (_binary_reward != 0) {\r\n            if (_position_id > 0) {\r\n                uint256 _first_upline = calcUplineFromPositionId(_position_id);\r\n                Partner memory _first_upline_partner = partnersByPositionId[\r\n                    _first_upline\r\n                ];\r\n                address _first_upline_partner_wallet_address = _first_upline_partner\r\n                        .wallet_address;\r\n                transferFromDappContract(\r\n                    _first_upline_partner_wallet_address,\r\n                    _level_one_reward\r\n                );\r\n                address _behalf_of = partnersByPositionId[_position_id]\r\n                    .wallet_address;\r\n                TransactionsLog memory transactionslog = TransactionsLog(\r\n                    _behalf_of,\r\n                    _level_one_reward,\r\n                    \"matching_bonus_being_level_one\",\r\n                    block.timestamp\r\n                );\r\n                transactionLogsByAddress[_first_upline_partner_wallet_address]\r\n                    .push(transactionslog);\r\n                if (_position_id > 2) {\r\n                    uint256 _second_upline = calcUplineFromPositionId(\r\n                        _first_upline\r\n                    );\r\n                    Partner\r\n                        memory _second_upline_partner = partnersByPositionId[\r\n                            _second_upline\r\n                        ];\r\n                    address _second_upline_partner_wallet_address = _second_upline_partner\r\n                            .wallet_address;\r\n                    transferFromDappContract(\r\n                        _second_upline_partner_wallet_address,\r\n                        _level_two_reward\r\n                    );\r\n                    TransactionsLog memory transactionslog = TransactionsLog(\r\n                        _behalf_of,\r\n                        _level_two_reward,\r\n                        \"mathing_bonus_being_level_two\",\r\n                        block.timestamp\r\n                    );\r\n                    transactionLogsByAddress[\r\n                        _second_upline_partner_wallet_address\r\n                    ].push(transactionslog);\r\n                    if (_position_id > 6) {\r\n                        uint256 _third_upline = calcUplineFromPositionId(\r\n                            _second_upline\r\n                        );\r\n                        Partner\r\n                            memory _third_upline_partner = partnersByPositionId[\r\n                                _third_upline\r\n                            ];\r\n                        address _third_upline_partner_wallet_address = _third_upline_partner\r\n                                .wallet_address;\r\n                        transferFromDappContract(\r\n                            _third_upline_partner_wallet_address,\r\n                            _level_three_reward\r\n                        );\r\n                        TransactionsLog\r\n                            memory transactionslog = TransactionsLog(\r\n                                _behalf_of,\r\n                                _level_three_reward,\r\n                                \"matching_bonus_being_level_three\",\r\n                                block.timestamp\r\n                            );\r\n                        transactionLogsByAddress[\r\n                            _third_upline_partner_wallet_address\r\n                        ].push(transactionslog);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function referralBonusLogs(\r\n        address _reffered_address,\r\n        address _referrer_partner_address,\r\n        uint256 _amount\r\n    ) internal returns (string memory) {\r\n        TransactionsLog memory transactionslog = TransactionsLog(\r\n            msg.sender,\r\n            _amount,\r\n            \"referral_bonus\",\r\n            block.timestamp\r\n        );\r\n        transactionLogsByAddress[_referrer_partner_address].push(\r\n            transactionslog\r\n        );\r\n    }\r\n\r\n    // function partnerBonusesHistory() public returns (TransactionsLog[] memory) {\r\n    //     require(isValidWalletAddress(), \"5\");\r\n    //     return transactionLogsByAddress[msg.sender];\r\n    // }\r\n\r\n    // function allBonusesHistory(address _wallet_address)\r\n    //     public\r\n    //     onlyOwner\r\n    //     returns (TransactionsLog[] memory)\r\n    // {\r\n    //     require(isValidWalletAddress(), \"5\");\r\n    //     return transactionLogsByAddress[_wallet_address];\r\n    // }\r\n    // function transferTokenFromContract(address _tokenAddress,address reciever,uint256 amount) public onlyOwner {\r\n    //     ERC20 transferToken = ERC20(_tokenAddress);\r\n    //     require(transferToken.balanceOf(address(this))>amount,\"contract don't have enough token to transfer\");\r\n    //     transferToken.transfer(reciever,amount);\r\n    // }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakeContractAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dappTokenContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DappTokenContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"StakingContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_invitation_link\",\"type\":\"string\"}],\"name\":\"addPartnerFromLink\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"binaryBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_invitation_ebr_code\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_position_id\",\"type\":\"uint256\"}],\"name\":\"createRefferalCode\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"hasChild\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"myInvitationLinks\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"partnersByPositionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"position_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"ebr_code\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"direction\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sum_left_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sum_right_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childs_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"full_fill_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"created_at\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_update\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isValue\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partnersByWalletAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"position_id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"ebr_code\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"direction\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sum_left_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sum_right_balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childs_count\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"full_fill_level\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"created_at\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_update\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isValue\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transactionLogsByAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"transaction_type\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_position_id\",\"type\":\"uint256\"}],\"name\":\"updateUplinesUniLevelRewards\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "Genealogy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "2", "ConstructorArguments": "000000000000000000000000c94c2bea5d471121212576bc99accb5a90e7d2dd00000000000000000000000074fe11d7ca92ad03a917406005341f4cc68791b8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5b07e7db8d84d9ffc332be9c13315b638ff6e4cbe829b69aa40c57b8ae412b94"}