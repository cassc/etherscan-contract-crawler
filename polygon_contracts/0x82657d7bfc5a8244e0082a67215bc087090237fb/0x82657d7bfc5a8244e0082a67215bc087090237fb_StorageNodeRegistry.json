{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized < type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20Upgradeable.sol\\\";\\nimport \\\"./extensions/IERC20MetadataUpgradeable.sol\\\";\\nimport \\\"../../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\\n        __ERC20_init_unchained(name_, symbol_);\\n    }\\n\\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[45] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary MathUpgradeable {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/MathUpgradeable.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = MathUpgradeable.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSetUpgradeable.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMapUpgradeable {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSetUpgradeable.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key), errorMessage));\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`. O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`. O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, key, errorMessage));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"@verida/vda-verification-contract/contracts/VDAVerificationContract.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\\\";\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\n\\nerror RegisteredSigner();\\nerror UnregisteredSigner();\\nerror NoSigners();\\nerror InvalidSignature();\\n\\ncontract VDAVerificationContract is OwnableUpgradeable {\\n\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n\\n    /** @notice Nonce for dids */\\n    mapping(address => uint) internal _nonce;\\n\\n    /** @notice Trusted signer addresses */\\n    EnumerableSetUpgradeable.AddressSet internal _trustedSigners;\\n\\n    /**\\n     * @notice Emitted when the contract owner adds a trusted signer\\n     * @param signerAddress Address of signer\\n     */\\n    event AddTrustedSigner(address signerAddress);\\n\\n    /**\\n     * @notice Emitted when the contract owner removes a trusted signer\\n     * @param signerAddress Address of signer\\n     */\\n    event RemoveTrustedSigner(address signerAddress);\\n    \\n    /**\\n     * @notice Initializer for deploying the contract\\n     * @dev This contract can't be deployed directly. Should be used as a parent class only\\n     */\\n    function __VDAVerificationContract_init() internal onlyInitializing {\\n        __Ownable_init();\\n        __VDAVerificationContract_init_unchained();\\n    }\\n\\n    /**\\n     * @notice Initializer for deploying the contract\\n     * @dev Initialze the necessary stuffs that are unique to this contract\\n     */\\n    function __VDAVerificationContract_init_unchained() internal onlyInitializing {\\n    }\\n\\n    /**\\n     * @notice Add a trusted signer\\n     * @dev Only the contract owner can add\\n     * @param didAddress Trusted signer address\\n     */\\n    function addTrustedSigner(address didAddress) external virtual payable onlyOwner {\\n        if (_trustedSigners.contains(didAddress)) {\\n            revert RegisteredSigner();\\n        }\\n        _trustedSigners.add(didAddress);\\n        emit AddTrustedSigner(didAddress);\\n    }\\n\\n    /**\\n     * @notice Remove a trusted signer\\n     * @dev Only the contract owner can remove\\n     * @param didAddress Trusted signer address\\n     */\\n    function removeTrustedSigner(address didAddress) external virtual payable onlyOwner {\\n        if (!_trustedSigners.contains(didAddress)) {\\n            revert UnregisteredSigner();\\n        }\\n        _trustedSigners.remove(didAddress);\\n        emit RemoveTrustedSigner(didAddress);\\n    }\\n\\n\\n    /**\\n     * @notice Get a nonce for DID\\n     * @dev This is used to sign the message. It's for against replay-attack of the transactions\\n     * @param did DID for nonce\\n     * @return uint Current nonce of the DID\\n     */\\n    function nonce(address did) external view  virtual returns(uint) {\\n        return _nonce[did];\\n    }\\n\\n    /**\\n     * Verify any data is signed by a trusted signering DID address\\n     *\\n     * @param data Any type of raw data\\n     * @param signature Data signed by a Verida application context signing key\\n     * @param proof Signed proof that a Verida DID controls a Verida application context signing key\\n     */\\n    function verifyData(\\n        bytes memory data, \\n        bytes memory signature,\\n        bytes memory proof\\n    ) internal virtual {\\n        if (_trustedSigners.length() == 0) {\\n            revert NoSigners();\\n        }\\n\\n        if (data.length == 0 || signature.length == 0 || proof.length == 0) {\\n            revert InvalidSignature();\\n        }\\n\\n        bytes32 dataHash = keccak256(data);\\n        address contextSigner = ECDSAUpgradeable.recover(dataHash, signature);\\n        string memory strContextSigner = StringsUpgradeable.toHexString(uint256(uint160(contextSigner)));\\n\\n        bool isVerified;\\n        uint index;\\n\\n        while (index < _trustedSigners.length() && !isVerified) {\\n            address account = _trustedSigners.at(index);\\n\\n            string memory strAccount = StringsUpgradeable.toHexString(uint256(uint160(account)));\\n            bytes memory proofString = abi.encodePacked(\\n                strAccount,\\n                strContextSigner\\n            );\\n            bytes32 proofHash = keccak256(proofString);\\n            address didSigner = ECDSAUpgradeable.recover(proofHash, proof);\\n\\n            if (didSigner == account) {\\n                isVerified = true;\\n                break;\\n            }\\n            unchecked { ++index; }\\n        }\\n\\n        if (!isVerified) {\\n            revert InvalidSignature();\\n        }\\n    }\\n    \\n    /**\\n     * Verify any data is signed by a particular array of DID addresses\\n     *\\n     * @param data Any type of raw data\\n     * @param signature Data signed by a Verida application context signing key\\n     * @param proof Signed proof that a Verida DID controls a Verida application context signing key\\n     * @param validSigners Array of did addresses that are valid signers of data\\n     */\\n    function verifyDataWithSigners(\\n        bytes memory data, \\n        bytes memory signature,\\n        bytes memory proof,\\n        address[] memory validSigners\\n    ) internal virtual {\\n        if (validSigners.length == 0) {\\n            revert NoSigners();\\n        }\\n\\n        if (data.length == 0 || signature.length == 0 || proof.length == 0) {\\n            revert InvalidSignature();\\n        }\\n\\n        bytes32 dataHash = keccak256(data);\\n        address contextSigner = ECDSAUpgradeable.recover(dataHash, signature);\\n        string memory strContextSigner = StringsUpgradeable.toHexString(uint256(uint160(contextSigner)));\\n\\n        bool isVerified;\\n        uint index;\\n\\n        while (index < validSigners.length && !isVerified) {\\n            address account = validSigners[index];\\n\\n            string memory strAccount = StringsUpgradeable.toHexString(uint256(uint160(account)));\\n            bytes memory proofString = abi.encodePacked(\\n                strAccount,\\n                strContextSigner\\n            );\\n            bytes32 proofHash = keccak256(proofString);\\n            address didSigner = ECDSAUpgradeable.recover(proofHash, proof);\\n\\n            if (didSigner == account) {\\n                isVerified = true;\\n                break;\\n            }\\n            unchecked { ++index; }\\n        }\\n\\n        if (!isVerified) {\\n            revert InvalidSignature();\\n        }\\n    }\\n    \\n     /**\\n     * @notice Verify whether a given request is valid. Verifies the nonce of the DID making the request.\\n     * \\n     * @dev Verify the signature & proof signed by valid signers\\n     * \\n     * @param did DID that made the request. Nonce will be incremented against this DID to avoid replay attacks.\\n     * @param params Parameters of the message.\\n     * @param signature A signature that matches sign(${didSignAddress}, params)\\n     * @param proof Proof A signature that matches sign(did, `${didAddress}${didSignAddress}`)\\n     */\\n    function verifyRequest(\\n        address did, \\n        bytes memory params, \\n        bytes memory signature, \\n        bytes memory proof\\n    ) internal virtual {\\n        // Verify the nonce is valid by including it in the unsignedData to be checked\\n        uint didNonce = _nonce[did];\\n        bytes memory unsignedParams = abi.encodePacked(\\n            params,\\n            didNonce\\n        );\\n\\n        address[] memory signers = new address[](1);\\n        signers[0] = did;\\n\\n        // Verify the params were signed by the DID making the request\\n        verifyDataWithSigners(\\n            unsignedParams,\\n            signature,\\n            proof,\\n            signers\\n        );\\n\\n        // Increment the nonce to prevent replay attacks\\n        _nonce[did]++;\\n    }\\n}\"\r\n    },\r\n    \"contracts/IStorageNodeRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\ninterface IStorageNodeRegistry {\\n\\n    /**\\n     * @notice Struct representing a data center\\n     * @dev `id` starts from 1. If `id` is 0, it means removed.\\n     * @param id Data center Id\\n     * @param name Data center name\\n     * @param countryCode Unique two-character string code\\n     * @param regionCode Unique region string code\\n     * @param lat Latitude\\n     * @param long Longitude\\n     */\\n    struct Datacenter {\\n        string name;\\n        string countryCode;\\n        string regionCode;\\n        int lat;\\n        int long;\\n    }\\n\\n    /**\\n     * @notice Struct representing a storage node\\n     * @param didAddress DID address that is associated with the storage node\\n     * @param endpointUri The storage node endpoint\\n     * @param countryCode Unique two-character string code\\n     * @param regionCode Unique region string code\\n     * @param datacenterId Unique datacenter identifier that is created by `addDataCenter()` method.\\n     * @param lat Latitude\\n     * @param long Longitude\\n     * @param slotCount Number of slots indicationg how many storage slots the node will provide\\n     * @param establishmentDate Node added time in seconds\\n     */\\n    struct StorageNode {\\n        address didAddress;\\n        string endpointUri;\\n        string countryCode;\\n        string regionCode;\\n        uint datacenterId;\\n        int lat;\\n        int long;\\n        uint slotCount;\\n        uint establishmentDate;\\n    }\\n\\n    /**\\n     * @notice Struct for StorageNodeInput\\n     * @dev Used in `addNode()` function\\n     * @param didAddress DID address that is associated with the storage node\\n     * @param endpointUri The storage node endpoint\\n     * @param countryCode Unique two-character string code\\n     * @param regionCode Unique region string code\\n     * @param datacenterId Unique datacenter identifier that is created by `addDataCenter()` method.\\n     * @param lat Latitude\\n     * @param long Longitude\\n     * @param slotCount Number of slots indicationg how many storage slots the node will provide\\n     */\\n    struct StorageNodeInput {\\n        address didAddress;\\n        string endpointUri;\\n        string countryCode;\\n        string regionCode;\\n        uint datacenterId;\\n        int lat;\\n        int long;\\n        uint slotCount;\\n    }\\n\\n    /**\\n     * @notice Emitted when a datacenter added\\n     * @param datacenterId Added datacenterId\\n     * @param name Datacenter name\\n     * @param countryCode Unique two-character string code\\n     * @param regionCode Unique region string code\\n     * @param lat Latitude\\n     * @param long Longitude\\n     */\\n    event AddDataCenter(\\n        uint indexed datacenterId,\\n        string indexed name,\\n        string countryCode,\\n        string regionCode,\\n        int lat,\\n        int long\\n    );\\n\\n    /**\\n     * @notice Emitted when a datacenter removed\\n     * @param datacenterId datacenterId to be removed\\n     */\\n    event RemoveDataCenter(uint indexed datacenterId);\\n\\n    /**\\n     * @notice Emitted when a storage node added\\n     * @param didAddress DID address that is associated with the storage node\\n     * @param endpointUri The storage node endpoint\\n     * @param countryCode Unique two-character string code\\n     * @param regionCode Unique region string code\\n     * @param datacenterId Unique datacenter identifier that is created by `addDataCenter()` method.\\n     * @param slotCount Number of slots indicationg how many storage slots the node will provide\\n     * @param establishmentDate Node added time in seconds\\n     */\\n    event AddNode(\\n        address indexed didAddress, \\n        string indexed endpointUri,\\n        string countryCode,\\n        string regionCode,\\n        uint datacenterId,\\n        int lat,\\n        int long,\\n        uint slotCount,\\n        uint establishmentDate\\n    );\\n\\n    /**\\n     * @notice Emitted when a removing node is requested\\n     * @param didAddress DID address that is to be removed from the network\\n     * @param unregisterDateTime The unix timestamp of when the storage node should no logner be available for selection.\\n        Must be at leaset 28 dayse in the future from calling function point\\n     */\\n    event RemoveNodeStart(address indexed didAddress, uint unregisterDateTime);\\n\\n    /**\\n     * @notice Emitted when a removing node is completed\\n     * @param didAddress DID address that is to be removed from the network\\n     */\\n    event RemoveNodeComplete(address indexed didAddress);\\n\\n    /**\\n     * @notice Emitted when the `isStakingRequired` value of `_slotInfo` is updated\\n     * @param newVal New value updated\\n     */\\n    event UpdateStakingRequired(bool newVal);\\n\\n    /**\\n     * @notice Emitted when the `STAKE_PER_SLOT` value of `_slotInfo` is updated\\n     * @param newVal New value updated\\n     */\\n    event UpdateStakePerSlot(uint newVal);\\n\\n    /**\\n     * @notice Emitted when the `MIN_SLOTS` value of `_slotInfo` is updated\\n     * @param newVal New value updated\\n     */\\n    event UpdateMinSlotCount(uint newVal);\\n\\n    /**\\n     * @notice Emitted when the `MAX_SLOTS` value of `_slotInfo` is updated\\n     * @param newVal New value updated\\n     */\\n    event UpdateMaxSlotCount(uint newVal);\\n\\n    /**\\n     * @notice Emitted when the excess tokens are withdrawn\\n     * @param didAddress DID address\\n     * @param to Token receiving address\\n     * @param amount Withdrawn amount\\n     */\\n    event TokenWithdrawn(address indexed didAddress, address to, uint amount);\\n\\n    /**\\n     * @notice Emitted when the tokens are deposited\\n     * @param didAddress DID address\\n     * @param from Wallet address from which tokens are deposited\\n     * @param amount Deposited amount\\n     */\\n    event TokenDeposited(address indexed didAddress, address from, uint amount);\\n\\n    /**\\n     * @notice Emitted when the NODE_ISSUE_FEE updated\\n     * @param orgFee Original fee value\\n     * @param newFee Updated fee value\\n     */\\n    event UpdateNodeIssueFee(uint orgFee, uint newFee);\\n\\n    /**\\n     * @notice Emitted when the SAME_NODE_LOG_DURATION updated\\n     * @param orgVal Original value\\n     * @param newVal Updated value\\n     */\\n    event UpdateSameNodeLogDuration(uint orgVal, uint newVal);\\n\\n    /**\\n     * @notice Emitted when the LOG_LIMIT_PER_DAY updated\\n     * @param orgVal Original value\\n     * @param newVal Updated value\\n     */\\n    event UpdateLogLimitPerDay(uint orgVal, uint newVal);\\n\\n    /**\\n     * @notice Emitted when user logged an node issue by `logNodeIssue()` function\\n     * @param from DID address that logs this issue\\n     * @param nodeDID DID address of the node\\n     * @param reasonCode Reason code\\n     */\\n    event LoggedNodeIssue(address indexed from, address nodeDID, uint reasonCode);\\n\\n    /**\\n     * @notice Emitted when stakes VDA tokens of `nodeDID` was slashed by contract owner\\n     * @param nodeDID DID address of the node\\n     * @param reasonCode Reason code\\n     * @param Amount Slashed amount. This can be a bit different from the parameter of `slash()` function\\n     * @param rewardedCount Number of dids who received the rewards\\n     * @param moreInfoUrl On-chain pointer to where more information can be fournd about this slashing\\n     */\\n    event Slash(address indexed nodeDID, uint reasonCode, uint Amount, uint rewardedCount, string moreInfoUrl);\\n\\n    /**\\n     * @notice Emitted when the contract owner withdraw tokens staked by logging issues\\n     * @param to Receiver address\\n     * @param amount Token amount to be withdrawn\\n     */\\n    event WithdrawIssueFee(address indexed to, uint amount);\\n\\n    /**\\n     * @notice Add a data center to the network. `id` will be auto-incremented.\\n     * @dev Only the contract owner can call this function\\n     * @param data Datacenter info\\n     * @return datacenterId Created datacetnerId\\n     */\\n    function addDatacenter(Datacenter calldata data) external payable returns(uint);\\n\\n    /**\\n     * @notice Remove a data center\\n     * @dev Only the contract owner can call this function.\\n     *  Will only remove the data center if there are no storage nodes using this datacenterId\\n     * @param datacenterId datacenterId created by `addDatacenter()` function\\n     */\\n    function removeDatacenter(uint datacenterId) external payable;\\n\\n    /**\\n     * @notice Return an array of `Datacenter` structs for given array of datacenterIds\\n     * @param ids Array of datacenterIds\\n     * @return Datacenter[] Array of `Datacenter` structs \\n     */\\n    function getDatacenters(uint[] calldata ids) external view returns(Datacenter[] memory);\\n\\n    /**\\n     * @notice Return an array of `Datacenter` structs for country code\\n     * @param countryCode Unique two-character string code\\n     * @return Datacenter[] Array of `Datacenter` structs \\n     */\\n    function getDataCentersByCountry(string calldata countryCode) external view returns(Datacenter[] memory);\\n\\n    /**\\n     * @notice Return an array of `Datacenter` structs for region\\n     * @param regionCode Unique region string code\\n     * @return Datacenter[] Array of `Datacenter` structs \\n     */\\n    function getDataCentersByRegion(string calldata regionCode) external view returns(Datacenter[] memory);\\n    \\n    /**\\n     * @notice Registers a new endpoint on the network\\n     * @dev A did can register only one storage-node\\n     * @param nodeInfo Node information to be added\\n     * @param requestSignature The request parameters signed by the `didAddress` private key\\n     * @param requestProof Used to verify request\\n     * @param authSignature Signature signed by a trusted signer\\n     */\\n    function addNode(\\n        StorageNodeInput calldata nodeInfo,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof,\\n        bytes calldata authSignature\\n    ) external;\\n\\n    /**\\n     * @notice Unregister a storage node from the network at the specified date\\n     * @param didAddress DID address that is to be removed from the network\\n     * @param unregisterDateTime The unix timestamp in secods of when the storage node should no logner be available for selection.\\n        Must be at leaset 28 dayse in the future from calling function point\\n     * @param requestSignature The request parameters signed by the `didAddress` private key\\n     * @param requestProof Used to verify request\\n     */\\n    function removeNodeStart(\\n        address didAddress,\\n        uint unregisterDateTime,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof\\n    ) external;\\n\\n    /**\\n     * @notice Complete storage node unregisteration\\n     * @param didAddress DID address that is to be removed from the network\\n     * @param requestSignature The request parameters signed by the `didAddress` private key\\n     * @param requestProof Used to verify request\\n     */\\n    function removeNodeComplete(\\n        address didAddress,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof\\n    ) external;\\n\\n    /**\\n     * @notice Returns a storage node for didAddress\\n     * @param didAddress DID address that is associated with the storage node\\n     * @return StorageNode Returns storage node\\n     * @return string Status - \\\"active\\\" or \\\"removed\\\"\\n     */\\n    function getNodeByAddress(address didAddress) external view returns(StorageNode memory, string memory);\\n\\n    /**\\n     * @notice Returns a storage node for endpoint uri\\n     * @param endpointUri The storage node endpoint\\n     * @return StorageNode Returns storage node\\n     * @return string Status - \\\"active\\\" or \\\"removed\\\"\\n     */\\n    function getNodeByEndpoint(string calldata endpointUri) external view returns(StorageNode memory, string memory);\\n\\n    /**\\n     * @notice Return an array of `Storagenode` structs for countryCode\\n     * @param countryCode Unique two-character string code\\n     * @return StorageNode[] An array of `Storagenode` structs\\n     */\\n    function getNodesByCountry(string calldata countryCode) external view returns(StorageNode[] memory);\\n\\n    /**\\n     * @notice Return an array of `Storagenode` structs for regionCode\\n     * @param regionCode Unique region string code\\n     * @return StorageNode[] An array of `Storagenode` structs\\n     */\\n    function getNodesByRegion(string calldata regionCode) external view returns(StorageNode[] memory);\\n\\n    /**\\n     * @notice Returns whether staking is required to call `addNode()` function\\n     * @return bool The value of required status\\n     */\\n    function isStakingRequired() external view returns(bool);\\n\\n    /**\\n     * @notice Update the `isStakingRequired` value of `_slotInfo` struct\\n     * @dev Only the contract owner is allowed to call this function\\n     * @param isRequired The new value to be updated\\n     */\\n    function setStakingRequired(bool isRequired) external payable;\\n\\n    /**\\n     * @notice Returns the `STAKE_PER_SLOT` value of `_slotInfo` struct\\n     * @return uint Required token amount for one slot\\n     */\\n    function getStakePerSlot() external view returns(uint);\\n    \\n    /**\\n     * @notice Update the `STAKE_PER_SLOT` value of `_slotInfo` struct\\n     * @dev Only the contract owner is allowed to call this function\\n     * @param newVal The new value to be updated\\n     */\\n    function updateStakePerSlot(uint newVal) external payable;\\n\\n    /**\\n     * @notice Return the range of `slotCount` value by pair of minimum and maximum value\\n     * @dev Return the `MinSlots` and `MaxSlots` value of `_slotInfo` struct\\n     * @return uint available minimum value of `slotCount`\\n     * @return uint available maximum value of `slotCount`\\n     */\\n    function getSlotCountRange() external view returns(uint, uint);\\n\\n    /**\\n     * @notice Update the `MIN_SLOTS` value of `_slotInfo` struct\\n     * @dev Only the contract owner is allowed to call this function\\n     * @param minSlots The new value to be updated\\n     */\\n    function updateMinSlotCount(uint minSlots) external payable;\\n\\n    /**\\n     * @notice Update the `MAX_SLOTS` value of `_slotInfo` struct\\n     * @dev Only the contract owner is allowed to call this function\\n     * @param maxSlots The new value to be updated\\n     */\\n    function updateMaxSlotCount(uint maxSlots) external payable;\\n\\n    /**\\n     * @notice Returns the amount of staked token.\\n     * @dev Will return 0 for unregistered dids\\n     * @param didAddress DID address that addedn a storage node\\n     * @return uint Amount of staked token\\n     */\\n    function getBalance(address didAddress) external view returns(uint);\\n\\n    /**\\n     * @notice Returns the amount of excess tokens. This happens when the `STAKE_PER_SLOT` value decreased or increased\\n     * @param didAddress DID address\\n     * @return int Excess token amount. 0 if no excess tokens\\n     */\\n    function excessTokenAmount(address didAddress) external view returns(int);\\n\\n    /**\\n     * @notice Withdraw amount of tokens to the requestor\\n     * @dev Will send tokens to the `tx.origin`\\n     * @param didAddress DID address\\n     * @param amount Token amount to be withdrawn\\n     * @param requestSignature The request parameters signed by the `didAddress` private key\\n     * @param requestProof Used to verify request\\n     */\\n    function withdraw(\\n        address didAddress, \\n        uint amount,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof\\n    ) external;\\n\\n    /**\\n     * @notice Depoist verida tokens to the didAddress\\n     * @dev Work for only the registered DIDs\\n     * @param didAddress DID address\\n     * @param tokenAmount Depositing amount of Verida token\\n     */\\n    function depositToken(address didAddress, uint tokenAmount) external;\\n\\n    /**\\n     * @notice Get current `NODE_ISSUE_FEE`\\n     * @return uint value of `_slotInfo.NODE_ISSUE_FEE`\\n     */\\n    function getNodeIssueFee() external view returns(uint);\\n\\n    /**\\n     * @notice Update the `NODE_ISSUE_FEE` in the _slotInfo.\\n     * @param value New fee value to be set.\\n     */\\n    function updateNodeIssueFee(uint value) external payable;\\n\\n    /**\\n     * @notice Return the current token amount staked by logging issues\\n     * @return uint Amount of VDA tokens for issues\\n     */\\n    function getTotalIssueFee() external view returns(uint);\\n\\n    /**\\n     * @notice Withdraw the VDA tokens that was deposited by `logNodeIssue()` function\\n     * @dev Only the contract owner can withdraw fees\\n     * @param to Receiving address\\n     * @param amount Amount to be withdrawn\\n     */\\n    function withdrawIssueFee(address to, uint amount) external payable;\\n\\n    /**\\n     * @notice Return the current same node log duration\\n     * @return uint Same node log duration in seconds\\n     */\\n    function getSameNodeLogDuration() external view returns(uint);\\n\\n    /**\\n     * @notice Update the `SAME_NODE_LOG_DURATION` value\\n     * @dev Only the contract owner call call this function\\n     * @param value Time in seconds unit\\n     */\\n    function updateSameNodeLogDuration(uint value) external payable;\\n\\n    /**\\n     * @notice Return the current log limit per day\\n     * @return uint Log limit count per day\\n     */\\n    function getLogLimitPerDay() external view returns(uint);\\n\\n    /**\\n     * @notice Update the `LOG_LIMIT_PER_DAY` value\\n     * @dev Only the contract owner call call this function\\n     * @param value Log limit count per day\\n     */\\n    function updateLogLimitPerDay(uint value) external payable;\\n\\n    /**\\n     * @notice Log an issue\\n     * @param didAddress DID who logs this issue\\n     * @param nodeAddress DIDAddress of the node\\n     * @param reasonCode reason code of the issue\\n     * @param requestSignature The request parameters signed by the `didAddress` private key\\n     * @param requestProof Used to verify request\\n     */\\n    function logNodeIssue(\\n        address didAddress,\\n        address nodeAddress,\\n        uint reasonCode,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof\\n    ) external;\\n\\n    /**\\n     * @notice Slash the tokens\\n     * @dev Only the contract owner can call this\\n     * @param nodeDID DID address that points the node to be slashed\\n     * @param reasonCode Reascon code to be slashed\\n     * @param amount Token amount to be slashed\\n     * @param moreInfoUrl On-chain pointer to where more information can be fournd about this slashing\\n     */\\n    function slash(\\n        address nodeDID,\\n        uint reasonCode,\\n        uint amount,\\n        string calldata moreInfoUrl\\n    ) external payable;\\n\\n    \\n}\"\r\n    },\r\n    \"contracts/StorageNodeRegistry.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\\\";\\n\\nimport \\\"@verida/vda-verification-contract/contracts/VDAVerificationContract.sol\\\";\\n\\nimport \\\"./IStorageNodeRegistry.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\n\\n/**\\n * @title Verida StorageNodeRegistry contract\\n */\\ncontract StorageNodeRegistry is IStorageNodeRegistry, VDAVerificationContract {\\n\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.AddressToUintMap;\\n\\n    /**\\n     * @notice Datacenter infos by `datacenterId`\\n     */\\n    mapping (uint => Datacenter) internal _dataCenterMap;\\n\\n    /**\\n     * @notice Mapping of datacenter name to ID.\\n     */\\n    mapping (string => uint) internal _dataCenterNameToID;\\n    /**\\n     * @notice `datacenterId` list per country code\\n     */\\n    mapping (string => EnumerableSetUpgradeable.UintSet) internal _countryDataCenterIds;\\n    /**\\n     * @notice `datacenterId` list per region code\\n     */\\n    mapping (string => EnumerableSetUpgradeable.UintSet) internal _regionDataCenterIds;\\n\\n    /**\\n     * @notice Additional information for `datacenterId`\\n     * @dev Contains removed status & number of connected storage nodes\\n     */\\n    mapping (uint => DatacenterInfo) internal _datacenterInfo;\\n\\n    /**\\n     * @notice StorageNode by nodeId\\n     */\\n    mapping (uint => StorageNode) internal _nodeMap;\\n\\n    /**\\n     * @notice UnregisterTime of each storage node\\n     * @dev Value is over 0 if unregistered\\n     */\\n    mapping (uint => uint) internal _nodeUnregisterTime;\\n\\n    /**\\n     * @notice nodeId per did address\\n     */\\n    mapping (address => uint) internal _didNodeId;\\n\\n    /** \\n     * @notice nodeId per endpointUri\\n     */\\n    mapping (string => uint) internal _endpointNodeId;\\n\\n    /**\\n     * @notice nodeId list per country code\\n     */\\n    mapping (string => EnumerableSetUpgradeable.UintSet) internal _countryNodeIds;\\n\\n    /**\\n     * @notice nodeId list per region code\\n     */\\n    mapping (string => EnumerableSetUpgradeable.UintSet) internal _regionNodeIds;\\n\\n    /**\\n     * @notice Staked Verida token amount per each DID address\\n     */\\n    mapping (address => uint) internal _stakedTokenAmount;\\n\\n    /**\\n     * @notice Logged token amount by node & reason code\\n     * @dev Mapping of `Node DID => reason code => DID(logger) => Amount, Used to calculate proportion in `slash()` function\\n     */\\n    mapping (address => mapping(uint => EnumerableMapUpgradeable.AddressToUintMap)) internal _loggedTokenAmount;\\n\\n    /**\\n     * @notice Total VDA token amount deposited by the `logNodeIssue()` function\\n     * @dev Mapping of `Node DID => reason code => total amount` Used in `slash()` function\\n     */\\n    mapping (address => mapping(uint => uint)) internal _issueTotalAmount;\\n\\n    /**\\n     * @notice Issue log list per DID\\n     * @dev Each did \\n     */\\n    mapping (address => DIDLogInformation) internal _didLogs;\\n\\n    /**\\n     * @notice datacenterId counter\\n     * @dev starts from 1\\n     */\\n    CountersUpgradeable.Counter internal _datacenterIdCounter;\\n    /**\\n     * @notice nodeId counter\\n     * @dev starts from 1\\n     */\\n    CountersUpgradeable.Counter internal _nodeIdCounter;\\n\\n    /**\\n     * @notice Slot information\\n     */\\n    SlotInfo internal _slotInfo;\\n\\n    /**\\n     * @notice Verida Token contract address\\n     * @dev Verida Token is required in `addNode()` and `removeNode()` functions\\n     */\\n    address public vdaTokenAddress;\\n\\n    /**\\n     * @notice Denominator for latitude & longitude values\\n     */\\n    uint8 public constant DECIMAL = 8;\\n\\n    /**\\n     * @notice Gap for later use\\n     */\\n    uint256[20] private __gap;\\n\\n    /**\\n     * @notice Additional information for a data center\\n     * @dev Used internally inside the contract\\n     * @param isActive True when added. False after removed\\n     * @param nodeCount Number of connected storage nodes\\n     */\\n    struct DatacenterInfo {\\n        bool isActive;\\n        uint nodeCount;\\n    }\\n\\n    /**\\n     * @notice Additional information related to staking slots\\n     * @dev Used internally inside the contract\\n     * @param isStakingRequired true if staking required, otherwise false\\n     * @param STAKE_PER_SLOT The number of tokens required to stake for one storage slot.\\n     * @param MIN_SLOTS The minimum value of `STAKE_PER_SLOT`\\n     * @param MAX_SLOTS The maximum value of `STAKE_PER_SLOT`\\n     * @param NODE_ISSUE_FEE The number of VDA tokens that must be deposited when recording an issue against a storage node. `default=5`\\n     * @param SAME_NODE_LOG_DURATION Time after which log available for same node\\n     */\\n    struct SlotInfo {\\n        bool isStakingRequired;\\n        uint STAKE_PER_SLOT;\\n        uint MIN_SLOTS;\\n        uint MAX_SLOTS;\\n\\n        uint NODE_ISSUE_FEE;\\n        uint SAME_NODE_LOG_DURATION;\\n        uint LOG_LIMIT_PER_DAY;\\n\\n        uint totalIssueFee;\\n    }\\n\\n    /**\\n     * @notice Represent a each log information\\n     * @dev Every DID keeps `LOG_LIMIT_PER_DAY` DIDLogInformations to restrict logs per day\\n     * @param nodeDID Node DID from `nodeLogIssue()` function\\n     * @param reasonCode Reason code from `nodeLogIssue()` function\\n     * @param time Issue logged time\\n     */\\n    struct IssueInformation {\\n        address nodeDID;\\n        uint reasonCode;\\n        uint time;\\n    }\\n\\n    /**\\n     * @notice Represent the log list for a DID\\n     * @dev It keeps last `LOG_LIMIT_PER_DAY` logs recorded by `logNodeIssue()` function\\n     * @param _issueList Issue information list\\n     * @param index The earliest issue index in the list\\n     */\\n    struct DIDLogInformation {\\n        IssueInformation[] _issueList;\\n        uint index;\\n    }\\n\\n    error InvalidDatacenterName();\\n    error InvalidCountryCode();\\n    error InvalidRegionCode();\\n    error InvalidLatitude();\\n    error InvalidLongitude();\\n    error InvalidDatacenterId(uint id);\\n    error HasDependingNodes();\\n    error InvalidEndpointUri();\\n    error InvalidDIDAddress();\\n    error InvalidUnregisterTime();\\n    error InvalidTokenAddress();\\n    error InvalidSlotCount();\\n    error InvalidValue();\\n    error NoExcessTokenAmount();\\n    error TimeNotElapsed(); // `LOG_LIMIT_PER_DAY` logs in 24 hour\\n    error InvalidSameNodeTime(); \\n    error InvalidAmount();\\n    error InvalidReasonCode();\\n\\n    // constructor() {\\n    //     _disableInitializers();\\n    // }\\n\\n    /**\\n     * @dev initializer of deployment\\n     */\\n    function initialize(address tokenAddress) initializer public {\\n        __VDAVerificationContract_init();\\n\\n        _slotInfo.STAKE_PER_SLOT = 3 * (10 ** ERC20Upgradeable(tokenAddress).decimals());\\n        _slotInfo.isStakingRequired = false;\\n        _slotInfo.MIN_SLOTS = 20000;\\n        _slotInfo.MAX_SLOTS = 20000;\\n\\n        _slotInfo.NODE_ISSUE_FEE = 5 * (10 ** ERC20Upgradeable(tokenAddress).decimals());\\n        _slotInfo.SAME_NODE_LOG_DURATION = 1 hours;\\n        _slotInfo.LOG_LIMIT_PER_DAY = 4;\\n\\n        vdaTokenAddress = tokenAddress;\\n    }\\n\\n    /**\\n     * @notice Check whether the value is lowercase string\\n     * @param value String value to check\\n     * @return true if value is lowercase\\n     */\\n    function isLowerCase(string calldata value) internal pure returns(bool) {\\n        bytes memory _baseBytes = bytes(value);\\n        for (uint i; i < _baseBytes.length;) {\\n            if (_baseBytes[i] >= 0x41 && _baseBytes[i] <= 0x5A) {\\n                return false;\\n            }\\n            unchecked { ++i; }\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Check validity of country code\\n     * @param countryCode Unique two-character string code\\n     */\\n    function validateCountryCode(string calldata countryCode) internal pure {\\n        if (bytes(countryCode).length != 2 || !isLowerCase(countryCode)) {\\n            revert InvalidCountryCode();\\n        }\\n    }\\n\\n    /**\\n     * @notice Check validity of region code\\n     * @param regionCode Unique region string code\\n     */\\n    function validateRegionCode(string calldata regionCode) internal pure {\\n        if (bytes(regionCode).length == 0 || !isLowerCase(regionCode)) {\\n            revert InvalidRegionCode();\\n        }\\n    }\\n\\n    /**\\n     * @notice Check validity of latitude and longitude values\\n     * @param lat Latitude\\n     * @param long Longitude\\n     */\\n    function validateGeoPosition(int lat, int long) internal pure {\\n        if ( lat < -90 * int(10 ** DECIMAL) || lat > 90 * int(10 ** DECIMAL)) {\\n            revert InvalidLatitude();\\n        }\\n\\n        if (long < -180 * int(10 ** DECIMAL) || long > 180 * int(10 ** DECIMAL)) {\\n            revert InvalidLongitude();\\n        }\\n    }\\n\\n    /**\\n     * @notice Check validity of datacenterId\\n     * @dev `datacenterId` should be the one that was added by contract owner\\n     * @param id datacenterId\\n     */\\n    function checkDatacenterIdExistance(uint id) internal view {\\n        if (!_datacenterInfo[id].isActive) {\\n            revert InvalidDatacenterId(id);\\n        }\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function addDatacenter(Datacenter calldata data) external payable onlyOwner override\\n         returns(uint) {\\n        {\\n            if (bytes(data.name).length == 0 || !isLowerCase(data.name)) {\\n                revert InvalidDatacenterName();\\n            }\\n\\n            if (_dataCenterNameToID[data.name] != 0) {\\n                revert InvalidDatacenterName();\\n            }\\n\\n            validateCountryCode(data.countryCode);\\n            validateRegionCode(data.regionCode);\\n            validateGeoPosition(data.lat, data.long);\\n        }\\n\\n        _datacenterIdCounter.increment();\\n        uint datacenterId = _datacenterIdCounter.current();\\n\\n        _dataCenterMap[datacenterId] = data;\\n        _dataCenterNameToID[data.name] = datacenterId;\\n        \\n        _datacenterInfo[datacenterId].isActive = true;\\n\\n        _countryDataCenterIds[data.countryCode].add(datacenterId);\\n        _regionDataCenterIds[data.regionCode].add(datacenterId);\\n\\n        emit AddDataCenter(datacenterId, data.name, data.countryCode, data.regionCode, data.lat, data.long);\\n\\n        return datacenterId;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function removeDatacenter(uint datacenterId) external payable onlyOwner override {\\n        {\\n            checkDatacenterIdExistance(datacenterId);\\n            \\n            if (_datacenterInfo[datacenterId].nodeCount != 0) {\\n                revert HasDependingNodes();\\n            }\\n        }\\n\\n        Datacenter storage datacenter = _dataCenterMap[datacenterId];\\n        \\n        _countryDataCenterIds[datacenter.countryCode].remove(datacenterId);\\n        _regionDataCenterIds[datacenter.regionCode].remove(datacenterId);\\n        delete _dataCenterNameToID[datacenter.name];\\n        delete _dataCenterMap[datacenterId];\\n        delete _datacenterInfo[datacenterId];\\n\\n        emit RemoveDataCenter(datacenterId);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getDatacenters(uint[] calldata ids) external view override returns(Datacenter[] memory) {\\n        uint count = ids.length;\\n        Datacenter[] memory list = new Datacenter[](count);\\n\\n        for (uint i; i < count;) {\\n            if (!_datacenterInfo[ids[i]].isActive) {\\n                revert InvalidDatacenterId(ids[i]);\\n            }\\n\\n            list[i] = _dataCenterMap[ids[i]];\\n\\n            unchecked { ++i; }\\n        }\\n\\n        return list;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getDataCentersByCountry(string calldata countryCode) external view override returns(Datacenter[] memory) {\\n        validateCountryCode(countryCode);\\n        \\n        uint count = _countryDataCenterIds[countryCode].length();\\n        Datacenter[] memory list = new Datacenter[](count);\\n\\n        EnumerableSetUpgradeable.UintSet storage countryIds = _countryDataCenterIds[countryCode];\\n\\n        for (uint i; i < count;) {\\n            list[i] = _dataCenterMap[countryIds.at(i)];\\n            unchecked { ++i; }\\n        }\\n\\n        return list;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getDataCentersByRegion(string calldata regionCode) external view override returns(Datacenter[] memory) {\\n        validateRegionCode(regionCode);\\n        \\n        uint count = _regionDataCenterIds[regionCode].length();\\n        Datacenter[] memory list = new Datacenter[](count);\\n\\n        EnumerableSetUpgradeable.UintSet storage regionIds = _regionDataCenterIds[regionCode];\\n\\n        for (uint i; i < count;) {\\n            list[i] = _dataCenterMap[regionIds.at(i)];\\n            unchecked { ++i; }\\n        }\\n\\n        return list;\\n    }\\n\\n    /**\\n     * @notice Check the `authSignature` parameter of `addNode()` function\\n     * @param didAddress DID address that is associated with the storage node\\n     * @param authSignature Signature signed by a trusted signer\\n     */\\n    function verifyAuthSignature(address didAddress, bytes calldata authSignature) internal view {\\n        EnumerableSetUpgradeable.AddressSet storage signers = _trustedSigners;\\n\\n        if (signers.length() == 0) {\\n            revert NoSigners();\\n        }\\n\\n        if (authSignature.length == 0) {\\n            revert InvalidSignature();\\n        }\\n\\n        bytes memory rawMsg = abi.encodePacked(didAddress);\\n        bytes32 msgHash = keccak256(rawMsg);\\n\\n        address authSigner = ECDSAUpgradeable.recover(msgHash, authSignature);\\n\\n        bool isVerified;\\n        uint index;\\n        \\n        while (index < signers.length() && !isVerified) {\\n            address account = signers.at(index);\\n\\n            if (authSigner == account) {\\n                isVerified = true;\\n                break;\\n            }\\n\\n            unchecked { ++index; }\\n        }\\n\\n        if (!isVerified) {\\n            revert InvalidSignature();\\n        }   \\n    }\\n\\n    /**\\n     * @notice Store node information to the storage and emit the event\\n     * @dev Internal function used in the `addNode()` function. Created for stack deep error\\n     * @param nodeInfo Node information to store\\n     */\\n    function storeNodeInfo(\\n        StorageNodeInput memory nodeInfo\\n        ) internal {\\n        {\\n            _nodeIdCounter.increment();\\n            uint nodeId = _nodeIdCounter.current();\\n\\n            _nodeMap[nodeId].didAddress = nodeInfo.didAddress;\\n            _nodeMap[nodeId].endpointUri = nodeInfo.endpointUri;\\n            _nodeMap[nodeId].countryCode = nodeInfo.countryCode;\\n            _nodeMap[nodeId].regionCode = nodeInfo.regionCode;\\n            _nodeMap[nodeId].datacenterId = nodeInfo.datacenterId;\\n            _nodeMap[nodeId].lat = nodeInfo.lat;\\n            _nodeMap[nodeId].long = nodeInfo.long;\\n            _nodeMap[nodeId].slotCount = nodeInfo.slotCount;\\n            _nodeMap[nodeId].establishmentDate = block.timestamp;\\n\\n            _didNodeId[nodeInfo.didAddress] = nodeId;\\n            _endpointNodeId[nodeInfo.endpointUri] = nodeId;\\n            _countryNodeIds[nodeInfo.countryCode].add(nodeId);\\n            _regionNodeIds[nodeInfo.regionCode].add(nodeId);\\n\\n            ++_datacenterInfo[nodeInfo.datacenterId].nodeCount;\\n        }\\n\\n        emit AddNode(\\n            nodeInfo.didAddress, \\n            nodeInfo.endpointUri, \\n            nodeInfo.countryCode, \\n            nodeInfo.regionCode, \\n            nodeInfo.datacenterId,\\n            nodeInfo.lat,\\n            nodeInfo.long,\\n            nodeInfo.slotCount,\\n            block.timestamp\\n            );\\n\\n    }\\n\\n    /**\\n     * @notice Calculate the required token amount for slots\\n     * @dev Internal function. Used in `stakeToken()` and `getExcessTokenAmount()` functions\\n     * @param numberSlot Number of slots\\n     * @return uint Required token amount\\n     */\\n    function requiredTokenAmount(uint numberSlot) internal view returns(uint) {\\n        return numberSlot * _slotInfo.STAKE_PER_SLOT;\\n    }\\n\\n    /**\\n     * @notice Stake required tokens from the requestor of `addNode()` function\\n     * @dev Internal function. Called inside of `addNode()` function\\n     * @param didAddress DID address that calls the `addNode()` function\\n     * @param from EOA wallet that provide necessary Verida token for `addNode()` function\\n     * @param numberSlot Number of slots being added in the `addNode()` function\\n     */\\n    function stakeToken(address didAddress, address from, uint numberSlot) internal {\\n        uint totalAmount = requiredTokenAmount(numberSlot);\\n\\n        IERC20Upgradeable tokenContract = IERC20Upgradeable(vdaTokenAddress);\\n\\n        tokenContract.transferFrom(from, address(this), totalAmount);\\n\\n        _stakedTokenAmount[didAddress] = totalAmount;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function addNode(\\n        StorageNodeInput calldata nodeInfo,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof,\\n        bytes calldata authSignature\\n    ) external override {\\n        {\\n            // Check whether endpointUri is empty\\n            if (bytes(nodeInfo.endpointUri).length == 0) {\\n                revert InvalidEndpointUri();\\n            }\\n\\n            validateCountryCode(nodeInfo.countryCode);\\n            validateRegionCode(nodeInfo.regionCode);\\n            checkDatacenterIdExistance(nodeInfo.datacenterId);\\n            validateGeoPosition(nodeInfo.lat, nodeInfo.long);\\n\\n            \\n            // Check whether didAddress was registered before\\n            if (_didNodeId[nodeInfo.didAddress] != 0) {\\n                revert InvalidDIDAddress();\\n            }\\n\\n            // Check whether endpoint was registered before\\n            if (_endpointNodeId[nodeInfo.endpointUri] != 0) {\\n                revert InvalidEndpointUri();\\n            }\\n\\n            // Check whether the slotCount is zero\\n            if (nodeInfo.slotCount < _slotInfo.MIN_SLOTS || nodeInfo.slotCount > _slotInfo.MAX_SLOTS) {\\n                revert InvalidSlotCount();\\n            }\\n            \\n            bytes memory params = abi.encodePacked(\\n                nodeInfo.didAddress,\\n                nodeInfo.endpointUri,\\n                nodeInfo.countryCode);\\n\\n            params = abi.encodePacked(\\n                params,\\n                nodeInfo.regionCode,\\n                nodeInfo.datacenterId);\\n                \\n            params = abi.encodePacked(\\n                params,\\n                nodeInfo.lat,\\n                nodeInfo.long,\\n                nodeInfo.slotCount\\n            );\\n\\n            verifyRequest(nodeInfo.didAddress, params, requestSignature, requestProof);\\n\\n            verifyAuthSignature(nodeInfo.didAddress, authSignature);\\n        }\\n\\n        if (_slotInfo.isStakingRequired) {\\n            stakeToken(nodeInfo.didAddress, tx.origin, nodeInfo.slotCount);\\n        }\\n\\n        storeNodeInfo(nodeInfo);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function removeNodeStart(\\n        address didAddress,\\n        uint unregisterDateTime,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof\\n    ) external override {\\n        uint nodeId = _didNodeId[didAddress];\\n\\n        // Check whether didAddress was registered before\\n        if (nodeId == 0 || _nodeUnregisterTime[nodeId] != 0) {\\n            revert InvalidDIDAddress();\\n        }\\n\\n        if (unregisterDateTime < (block.timestamp + 28 days)) {\\n            revert InvalidUnregisterTime();\\n        }\\n\\n        bytes memory params = abi.encodePacked(didAddress, unregisterDateTime);\\n        verifyRequest(didAddress, params, requestSignature, requestProof);\\n\\n        _nodeUnregisterTime[nodeId] = unregisterDateTime;\\n\\n        emit RemoveNodeStart(didAddress, unregisterDateTime);\\n    }\\n\\n    /**\\n     * @notice Release staked token to the requestor of `removeNodeComplete()` function\\n     * @dev Internal function. Called inside of `removeNodeComplete()` function\\n     * @param didAddress DID address that calls the `removeNodeComplete()` function\\n     * @param to EOA wallet that will received the released token\\n     */\\n    function releaseToken(address didAddress, address to) internal {\\n        uint totalAmount = _stakedTokenAmount[didAddress];\\n\\n        if (totalAmount != 0) {\\n            IERC20Upgradeable(vdaTokenAddress).transfer(to, totalAmount);\\n            _stakedTokenAmount[didAddress] = 0;\\n        }        \\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function removeNodeComplete(\\n        address didAddress,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof\\n    ) external override {\\n        uint nodeId = _didNodeId[didAddress];\\n        {\\n            if (nodeId == 0) {\\n                revert InvalidDIDAddress();\\n            }\\n\\n            if (_nodeUnregisterTime[nodeId] == 0 || _nodeUnregisterTime[nodeId] > block.timestamp) {\\n                revert InvalidUnregisterTime();\\n            }\\n\\n            bytes memory params = abi.encodePacked(didAddress);\\n            verifyRequest(didAddress, params, requestSignature, requestProof);\\n        }\\n\\n        // Release staked token\\n        releaseToken(didAddress, tx.origin);\\n\\n        // Clear registered information\\n        StorageNode storage nodeInfo = _nodeMap[nodeId];\\n\\n        --_datacenterInfo[nodeInfo.datacenterId].nodeCount;\\n\\n        _countryNodeIds[nodeInfo.countryCode].remove(nodeId);\\n        _regionNodeIds[nodeInfo.regionCode].remove(nodeId);\\n        delete _endpointNodeId[nodeInfo.endpointUri];\\n        delete _didNodeId[didAddress];\\n        delete _nodeMap[nodeId];\\n\\n        delete _nodeUnregisterTime[nodeId];\\n\\n        emit RemoveNodeComplete(didAddress);\\n    }\\n\\n    /**\\n     * @notice Create tuple for StorageNode with status\\n     * @param nodeId StorageNode ID created by `addNode()` function\\n     * @return StorageNode StoargeNode struct\\n     * @return string Status string\\n     */\\n    function getNodeWithStatus(uint nodeId) internal view returns(StorageNode memory, string memory) {\\n        string memory status = \\\"active\\\";\\n        if (_nodeUnregisterTime[nodeId] != 0) {\\n            status = \\\"removed\\\";\\n        }\\n\\n        return (_nodeMap[nodeId], status);\\n    }\\n    \\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getNodeByAddress(address didAddress) external view override returns(StorageNode memory, string memory) {\\n        uint nodeId = _didNodeId[didAddress];\\n        if (nodeId == 0) {\\n            revert InvalidDIDAddress();\\n        }\\n\\n        return getNodeWithStatus(nodeId);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getNodeByEndpoint(string calldata endpointUri) external view override returns(StorageNode memory, string memory) {\\n        uint nodeId = _endpointNodeId[endpointUri];\\n\\n        if (nodeId == 0) {\\n            revert InvalidEndpointUri();\\n        }\\n\\n        return getNodeWithStatus(nodeId);\\n    }\\n\\n    /**\\n     * @notice Filter active node IDs from set\\n     * @dev Used for `getNodesByCountry()` and `getNodesByRegion()` functions\\n     * @param ids ID set\\n     * @return StorageNode[] Array of active storage nodes\\n     */\\n    function filterActiveStorageNodes(EnumerableSetUpgradeable.UintSet storage ids) internal view returns(StorageNode[] memory) {\\n        uint count = ids.length();\\n        uint removedCount;\\n\\n        {\\n            uint nodeId;\\n            for (uint i; i < count;) {\\n                nodeId = ids.at(i);\\n                if (_nodeUnregisterTime[nodeId] != 0) {\\n                    ++removedCount;\\n                }\\n                unchecked { ++i; }\\n            }\\n        }\\n\\n        StorageNode[] memory nodeList = new StorageNode[](count - removedCount);\\n        {\\n            uint nodeId;\\n            uint index;\\n            for (uint i; i < count;) {\\n                nodeId = ids.at(i);\\n                if (_nodeUnregisterTime[nodeId] == 0) {\\n                    nodeList[index] = _nodeMap[nodeId];\\n                    ++index;\\n                }\\n                unchecked { ++i; }\\n            }\\n        }\\n\\n        return nodeList;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getNodesByCountry(string calldata countryCode) external view override returns(StorageNode[] memory) {\\n        return filterActiveStorageNodes(_countryNodeIds[countryCode]);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getNodesByRegion(string calldata regionCode) external view override returns(StorageNode[] memory) {\\n        return filterActiveStorageNodes(_regionNodeIds[regionCode]);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function isStakingRequired() external view returns(bool) {\\n        return _slotInfo.isStakingRequired;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function setStakingRequired(bool isRequired) external payable onlyOwner override {\\n        if (isRequired == _slotInfo.isStakingRequired) {\\n            revert InvalidValue();\\n        }\\n\\n        _slotInfo.isStakingRequired = isRequired;\\n        emit UpdateStakingRequired(isRequired);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getStakePerSlot() external view returns(uint) {\\n        return _slotInfo.STAKE_PER_SLOT;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function updateStakePerSlot(uint newVal) external payable onlyOwner override {\\n        if (newVal == 0 || newVal == _slotInfo.STAKE_PER_SLOT) {\\n            revert InvalidValue();\\n        }\\n\\n        _slotInfo.STAKE_PER_SLOT = newVal;\\n        emit UpdateStakePerSlot(newVal);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getSlotCountRange() external view returns(uint, uint) {\\n        return (_slotInfo.MIN_SLOTS, _slotInfo.MAX_SLOTS);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function updateMinSlotCount(uint minSlots) external payable onlyOwner override {\\n        if (minSlots == 0 || minSlots == _slotInfo.MIN_SLOTS || minSlots > _slotInfo.MAX_SLOTS) {\\n            revert InvalidValue();\\n        }\\n\\n        _slotInfo.MIN_SLOTS = minSlots;\\n        emit UpdateMinSlotCount(minSlots);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function updateMaxSlotCount(uint maxSlots) external payable onlyOwner override {\\n        if (maxSlots == 0 || maxSlots == _slotInfo.MAX_SLOTS || maxSlots < _slotInfo.MIN_SLOTS) {\\n            revert InvalidValue();\\n        }\\n\\n        _slotInfo.MAX_SLOTS = maxSlots;\\n        emit UpdateMaxSlotCount(maxSlots);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getBalance(address didAddress) external view returns(uint) {\\n        return _stakedTokenAmount[didAddress];\\n    }\\n\\n    /**\\n     * @notice Calculate the excess token amount for a DID address\\n     * @dev Internal function used in `excessTokenAmount()` and `withdraw()` functions\\n     * @param didAddress DID address\\n     * @return uint Return 0 if staked amount is less than the required amount\\n     */\\n    function getExcessTokenAmount(address didAddress) internal view returns(int) {\\n        uint totalAmount;\\n\\n        uint nodeId = _didNodeId[didAddress];\\n        if (nodeId != 0) {\\n            totalAmount = requiredTokenAmount(_nodeMap[nodeId].slotCount);    \\n        }\\n        \\n        return (int(_stakedTokenAmount[didAddress]) - int(totalAmount));\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function excessTokenAmount(address didAddress) external view returns(int) {\\n        return getExcessTokenAmount(didAddress);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function withdraw(\\n        address didAddress,\\n        uint amount,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof\\n    ) external {\\n        {\\n            bytes memory params = abi.encodePacked(didAddress, amount);\\n            verifyRequest(didAddress, params, requestSignature, requestProof);\\n        }\\n\\n        int excessAmount = getExcessTokenAmount(didAddress);\\n\\n        if (excessAmount <= 0) {\\n            revert NoExcessTokenAmount();\\n        }\\n\\n        if (amount > uint(excessAmount)) {\\n            revert InvalidAmount();\\n        }\\n\\n        IERC20Upgradeable(vdaTokenAddress).transfer(tx.origin, amount);\\n\\n        _stakedTokenAmount[didAddress] = _stakedTokenAmount[didAddress] - amount;\\n\\n        emit TokenWithdrawn(didAddress, tx.origin, amount);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function depositToken(address didAddress, uint tokenAmount) external {\\n        uint nodeId = _didNodeId[didAddress];\\n        if (nodeId == 0) {\\n            revert InvalidDIDAddress();\\n        }\\n\\n        IERC20Upgradeable(vdaTokenAddress).transferFrom(tx.origin, address(this), tokenAmount);\\n\\n        _stakedTokenAmount[didAddress] = _stakedTokenAmount[didAddress] + tokenAmount;\\n\\n        emit TokenDeposited(didAddress, tx.origin, tokenAmount);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getNodeIssueFee() external view returns(uint){\\n        return _slotInfo.NODE_ISSUE_FEE;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function updateNodeIssueFee(uint value) external payable onlyOwner {\\n        if (value == 0 || value == _slotInfo.NODE_ISSUE_FEE) {\\n            revert InvalidValue();\\n        }\\n        uint orgFee = _slotInfo.NODE_ISSUE_FEE;\\n        _slotInfo.NODE_ISSUE_FEE = value;\\n\\n        emit UpdateNodeIssueFee(orgFee, value);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getTotalIssueFee() external view returns(uint) {\\n        return _slotInfo.totalIssueFee;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function withdrawIssueFee(address to, uint amount) external payable onlyOwner {\\n        if (amount > _slotInfo.totalIssueFee) {\\n            revert InvalidValue();\\n        }\\n        IERC20Upgradeable(vdaTokenAddress).transfer(to, amount);\\n\\n        _slotInfo.totalIssueFee = _slotInfo.totalIssueFee - amount;\\n\\n        emit WithdrawIssueFee(to, amount);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getSameNodeLogDuration() external view returns(uint) {\\n        return _slotInfo.SAME_NODE_LOG_DURATION;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function updateSameNodeLogDuration(uint value) external payable onlyOwner {\\n        if (value == 0 || value == _slotInfo.SAME_NODE_LOG_DURATION) {\\n            revert InvalidValue();\\n        }\\n        uint orgVal = _slotInfo.SAME_NODE_LOG_DURATION;\\n        _slotInfo.SAME_NODE_LOG_DURATION = value;\\n\\n        emit UpdateSameNodeLogDuration(orgVal, value);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function getLogLimitPerDay() external view returns(uint) {\\n        return _slotInfo.LOG_LIMIT_PER_DAY;\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function updateLogLimitPerDay(uint value) external payable onlyOwner {\\n        if (value == 0 || value == _slotInfo.LOG_LIMIT_PER_DAY) {\\n            revert InvalidValue();\\n        }\\n        uint orgVal = _slotInfo.LOG_LIMIT_PER_DAY;\\n        _slotInfo.LOG_LIMIT_PER_DAY = value;\\n\\n        emit UpdateLogLimitPerDay(orgVal, value);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function logNodeIssue(\\n        address didAddress,\\n        address nodeAddress,\\n        uint reasonCode,\\n        bytes calldata requestSignature,\\n        bytes calldata requestProof\\n    ) external {\\n        {\\n            // Check whether nodeDID is registered\\n            uint nodeId = _didNodeId[nodeAddress];\\n            if (nodeId == 0) {\\n                revert InvalidDIDAddress();\\n            }\\n\\n            bytes memory params = abi.encodePacked(didAddress, nodeAddress, reasonCode);\\n            verifyRequest(didAddress, params, requestSignature, requestProof);\\n        }\\n\\n        \\n        DIDLogInformation storage logs = _didLogs[didAddress];\\n        // Check log limit per day\\n        if (logs._issueList.length >= _slotInfo.LOG_LIMIT_PER_DAY) {\\n            uint earlistTime = logs._issueList[logs.index].time;\\n            if (block.timestamp - earlistTime < 24 hours) {\\n                revert TimeNotElapsed();\\n            }\\n        }\\n        // Check 1 hour condition for same node\\n        for (uint i; i < logs._issueList.length;) {\\n            if (logs._issueList[i].nodeDID == nodeAddress && \\n                (block.timestamp - logs._issueList[i].time) < _slotInfo.SAME_NODE_LOG_DURATION) {\\n                revert InvalidSameNodeTime();\\n            }\\n            unchecked { ++i; }\\n        }\\n\\n        // Add or update\\n        if (logs._issueList.length < _slotInfo.LOG_LIMIT_PER_DAY) {\\n            logs._issueList.push(IssueInformation(nodeAddress, reasonCode, block.timestamp));\\n        } else {\\n            uint index = logs.index;\\n            logs._issueList[index].nodeDID = nodeAddress;\\n            logs._issueList[index].reasonCode = reasonCode;\\n            logs._issueList[index].time = block.timestamp;\\n            ++index;\\n            logs.index = index % _slotInfo.LOG_LIMIT_PER_DAY;\\n        }\\n\\n        // Transfer fees to this contract\\n        IERC20Upgradeable(vdaTokenAddress).transferFrom(msg.sender, address(this), _slotInfo.NODE_ISSUE_FEE);\\n\\n        _slotInfo.totalIssueFee = _slotInfo.totalIssueFee + _slotInfo.NODE_ISSUE_FEE;\\n\\n        uint val;\\n        EnumerableMapUpgradeable.AddressToUintMap storage didReasonLogAmount = _loggedTokenAmount[nodeAddress][reasonCode];\\n        if (didReasonLogAmount.contains(didAddress)) {\\n            val = didReasonLogAmount.get(didAddress);\\n        }\\n\\n        didReasonLogAmount.set(didAddress, val + _slotInfo.NODE_ISSUE_FEE);\\n        _issueTotalAmount[nodeAddress][reasonCode] = _issueTotalAmount[nodeAddress][reasonCode] + _slotInfo.NODE_ISSUE_FEE;\\n\\n        emit LoggedNodeIssue(didAddress, nodeAddress, reasonCode);\\n    }\\n\\n    /**\\n     * @dev see { IStorageNodeRegistry }\\n     */\\n    function slash(\\n        address nodeDID,\\n        uint reasonCode,\\n        uint amount,\\n        string calldata moreInfoUrl\\n    ) external payable onlyOwner {\\n\\n        if (amount == 0 || amount > _stakedTokenAmount[nodeDID]) {\\n            revert InvalidAmount();\\n        }\\n\\n        uint issueAmount = _issueTotalAmount[nodeDID][reasonCode];\\n        if (issueAmount == 0) {\\n            revert InvalidReasonCode();\\n        }\\n\\n        EnumerableMapUpgradeable.AddressToUintMap storage logInfo = _loggedTokenAmount[nodeDID][reasonCode];\\n        uint loggerCount = logInfo.length();\\n        uint distributeTotalAmount;\\n\\n        for (uint i; i < loggerCount;) {\\n            (address didAddress, uint loggerStaked) = logInfo.at(i);\\n            uint distAmount = amount * loggerStaked / issueAmount;\\n            distributeTotalAmount += distAmount;\\n\\n            _stakedTokenAmount[didAddress] = _stakedTokenAmount[didAddress] + distAmount;\\n\\n            unchecked { ++i; }\\n        }\\n\\n        _stakedTokenAmount[nodeDID] = _stakedTokenAmount[nodeDID] - distributeTotalAmount;\\n\\n        emit Slash(nodeDID, reasonCode, distributeTotalAmount, loggerCount, moreInfoUrl);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"HasDependingNodes\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidCountryCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDIDAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"InvalidDatacenterId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidDatacenterName\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidEndpointUri\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLatitude\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidLongitude\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReasonCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRegionCode\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSameNodeTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSlotCount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidUnregisterTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoExcessTokenAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSigners\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RegisteredSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimeNotElapsed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnregisteredSigner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"}],\"name\":\"AddDataCenter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"endpointUri\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"slotCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"establishmentDate\",\"type\":\"uint256\"}],\"name\":\"AddNode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"AddTrustedSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nodeDID\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reasonCode\",\"type\":\"uint256\"}],\"name\":\"LoggedNodeIssue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"}],\"name\":\"RemoveDataCenter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"}],\"name\":\"RemoveNodeComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unregisterDateTime\",\"type\":\"uint256\"}],\"name\":\"RemoveNodeStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"RemoveTrustedSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nodeDID\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reasonCode\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardedCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"moreInfoUrl\",\"type\":\"string\"}],\"name\":\"Slash\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orgVal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"UpdateLogLimitPerDay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxSlotCount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"UpdateMinSlotCount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orgFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"UpdateNodeIssueFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orgVal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"UpdateSameNodeLogDuration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"UpdateStakePerSlot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"newVal\",\"type\":\"bool\"}],\"name\":\"UpdateStakingRequired\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawIssueFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DECIMAL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"}],\"internalType\":\"struct IStorageNodeRegistry.Datacenter\",\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"addDatacenter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"endpointUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"slotCount\",\"type\":\"uint256\"}],\"internalType\":\"struct IStorageNodeRegistry.StorageNodeInput\",\"name\":\"nodeInfo\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"requestSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"requestProof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"authSignature\",\"type\":\"bytes\"}],\"name\":\"addNode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"}],\"name\":\"addTrustedSigner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"depositToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"}],\"name\":\"excessTokenAmount\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"}],\"name\":\"getDataCentersByCountry\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"}],\"internalType\":\"struct IStorageNodeRegistry.Datacenter[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"}],\"name\":\"getDataCentersByRegion\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"}],\"internalType\":\"struct IStorageNodeRegistry.Datacenter[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"getDatacenters\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"}],\"internalType\":\"struct IStorageNodeRegistry.Datacenter[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLogLimitPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"}],\"name\":\"getNodeByAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"endpointUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"slotCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"establishmentDate\",\"type\":\"uint256\"}],\"internalType\":\"struct IStorageNodeRegistry.StorageNode\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"endpointUri\",\"type\":\"string\"}],\"name\":\"getNodeByEndpoint\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"endpointUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"slotCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"establishmentDate\",\"type\":\"uint256\"}],\"internalType\":\"struct IStorageNodeRegistry.StorageNode\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNodeIssueFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"}],\"name\":\"getNodesByCountry\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"endpointUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"slotCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"establishmentDate\",\"type\":\"uint256\"}],\"internalType\":\"struct IStorageNodeRegistry.StorageNode[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"}],\"name\":\"getNodesByRegion\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"endpointUri\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"regionCode\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"lat\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"long\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"slotCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"establishmentDate\",\"type\":\"uint256\"}],\"internalType\":\"struct IStorageNodeRegistry.StorageNode[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSameNodeLogDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSlotCountRange\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStakePerSlot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalIssueFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isStakingRequired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nodeAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reasonCode\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"requestSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"requestProof\",\"type\":\"bytes\"}],\"name\":\"logNodeIssue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"did\",\"type\":\"address\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"datacenterId\",\"type\":\"uint256\"}],\"name\":\"removeDatacenter\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"requestSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"requestProof\",\"type\":\"bytes\"}],\"name\":\"removeNodeComplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"unregisterDateTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"requestSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"requestProof\",\"type\":\"bytes\"}],\"name\":\"removeNodeStart\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"}],\"name\":\"removeTrustedSigner\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isRequired\",\"type\":\"bool\"}],\"name\":\"setStakingRequired\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nodeDID\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"reasonCode\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"moreInfoUrl\",\"type\":\"string\"}],\"name\":\"slash\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateLogLimitPerDay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxSlots\",\"type\":\"uint256\"}],\"name\":\"updateMaxSlotCount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minSlots\",\"type\":\"uint256\"}],\"name\":\"updateMinSlotCount\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateNodeIssueFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateSameNodeLogDuration\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newVal\",\"type\":\"uint256\"}],\"name\":\"updateStakePerSlot\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vdaTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"didAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"requestSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"requestProof\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawIssueFee\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "StorageNodeRegistry", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}