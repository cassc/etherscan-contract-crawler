{"SourceCode": "# @version 0.3.0\r\n\"\"\"\r\n@title Curve Sidechain StableSwap Proxy\r\n@author Curve Finance\r\n@license MIT\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface Burner:\r\n    def burn(_coin: address) -> bool: payable\r\n\r\ninterface Bridger:\r\n    def bridge(_coin: address) -> bool: nonpayable\r\n    def set_root_receiver(_receiver: address): nonpayable\r\n\r\ninterface Curve:\r\n    def withdraw_admin_fees(): nonpayable\r\n    def kill_me(): nonpayable\r\n    def unkill_me(): nonpayable\r\n    def commit_transfer_ownership(new_owner: address): nonpayable\r\n    def apply_transfer_ownership(): nonpayable\r\n    def accept_transfer_ownership(): nonpayable\r\n    def revert_transfer_ownership(): nonpayable\r\n    def commit_new_parameters(amplification: uint256, new_fee: uint256, new_admin_fee: uint256): nonpayable\r\n    def apply_new_parameters(): nonpayable\r\n    def revert_new_parameters(): nonpayable\r\n    def commit_new_fee(new_fee: uint256, new_admin_fee: uint256): nonpayable\r\n    def apply_new_fee(): nonpayable\r\n    def ramp_A(_future_A: uint256, _future_time: uint256): nonpayable\r\n    def stop_ramp_A(): nonpayable\r\n    def donate_admin_fees(): nonpayable\r\n    def set_reward_receiver(_receiver: address): nonpayable\r\n    def set_admin_fee_receiver(_receiver: address): nonpayable\r\n\r\n\r\ninterface AddressProvider:\r\n    def get_registry() -> address: view\r\n\r\ninterface Registry:\r\n    def get_decimals(_pool: address) -> uint256[8]: view\r\n    def get_underlying_balances(_pool: address) -> uint256[8]: view\r\n\r\n\r\nevent AddBurner:\r\n    burner: address\r\n\r\nevent CommitOwnership:\r\n    admin: address\r\n\r\nevent ApplyOwnership:\r\n    admin: address\r\n\r\n\r\nburners: public(HashMap[address, address])\r\nburner_kill: public(bool)\r\n\r\nbridging_contract: public(address)\r\nbridge_minimums: public(HashMap[address, uint256])\r\n\r\n\r\nadmin: public(address)\r\nfuture_admin: public(address)\r\n\r\n\r\n@external\r\ndef __init__(_admin: address, _bridging_contract: address):\r\n    self.admin = _admin\r\n    self.bridging_contract = _bridging_contract\r\n\r\n\r\n@payable\r\n@external\r\ndef __default__():\r\n    # required to receive fees in the native protocol token\r\n    pass\r\n\r\n\r\n@external\r\ndef commit_new_admin(addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of GaugeController to `addr`\r\n    @param addr Address to have ownership transferred to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n\r\n    self.future_admin = addr\r\n    log CommitOwnership(addr)\r\n\r\n\r\n@external\r\ndef accept_new_admin():\r\n    \"\"\"\r\n    @notice Accept a pending ownership transfer\r\n    \"\"\"\r\n    _admin: address = self.future_admin\r\n    assert msg.sender == _admin  # dev: future admin only\r\n\r\n    self.admin = _admin\r\n    log ApplyOwnership(_admin)\r\n\r\n\r\n@internal\r\ndef _set_burner(_coin: address, _burner: address):\r\n    old_burner: address = self.burners[_coin]\r\n    if _coin != 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        if old_burner != ZERO_ADDRESS:\r\n            # revoke approval on previous burner\r\n            response: Bytes[32] = raw_call(\r\n                _coin,\r\n                _abi_encode(old_burner, EMPTY_BYTES32, method_id=method_id(\"approve(address,uint256)\")),\r\n                max_outsize=32,\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)\r\n\r\n        if _burner != ZERO_ADDRESS:\r\n            # infinite approval for current burner\r\n            response: Bytes[32] = raw_call(\r\n                _coin,\r\n                _abi_encode(_burner, MAX_UINT256, method_id=method_id(\"approve(address,uint256)\")),\r\n                max_outsize=32,\r\n            )\r\n            if len(response) != 0:\r\n                assert convert(response, bool)\r\n\r\n    self.burners[_coin] = _burner\r\n\r\n    log AddBurner(_burner)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef set_burner(_coin: address, _burner: address):\r\n    \"\"\"\r\n    @notice Set burner of `_coin` to `_burner` address\r\n    @param _coin Token address\r\n    @param _burner Burner contract address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n\r\n    self._set_burner(_coin, _burner)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef set_many_burners(_coins: address[20], _burners: address[20]):\r\n    \"\"\"\r\n    @notice Set burner of `_coin` to `_burner` address\r\n    @param _coins Token address\r\n    @param _burners Burner contract address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n\r\n    for i in range(20):\r\n        coin: address = _coins[i]\r\n        if coin == ZERO_ADDRESS:\r\n            break\r\n        self._set_burner(coin, _burners[i])\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw_admin_fees(_pool: address):\r\n    \"\"\"\r\n    @notice Withdraw admin fees from `_pool`\r\n    @param _pool Pool address to withdraw admin fees from\r\n    \"\"\"\r\n    Curve(_pool).withdraw_admin_fees()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef withdraw_many(_pools: address[20]):\r\n    \"\"\"\r\n    @notice Withdraw admin fees from multiple pools\r\n    @param _pools List of pool address to withdraw admin fees from\r\n    \"\"\"\r\n    for pool in _pools:\r\n        if pool == ZERO_ADDRESS:\r\n            break\r\n        Curve(pool).withdraw_admin_fees()\r\n\r\n\r\n@external\r\n@nonreentrant('burn')\r\ndef burn(_coin: address):\r\n    \"\"\"\r\n    @notice Burn accrued `_coin` via a preset burner\r\n    @dev Only callable by an EOA to prevent flashloan exploits\r\n    @param _coin Coin address\r\n    \"\"\"\r\n    assert tx.origin == msg.sender\r\n    assert not self.burner_kill\r\n\r\n    _value: uint256 = 0\r\n    if _coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n        _value = self.balance\r\n\r\n    Burner(self.burners[_coin]).burn(_coin, value=_value)  # dev: should implement burn()\r\n\r\n\r\n@external\r\n@nonreentrant('burn')\r\ndef burn_many(_coins: address[20]):\r\n    \"\"\"\r\n    @notice Burn accrued admin fees from multiple coins\r\n    @dev Only callable by an EOA to prevent flashloan exploits\r\n    @param _coins List of coin addresses\r\n    \"\"\"\r\n    assert tx.origin == msg.sender\r\n    assert not self.burner_kill\r\n\r\n    for coin in _coins:\r\n        if coin == ZERO_ADDRESS:\r\n            break\r\n\r\n        _value: uint256 = 0\r\n        if coin == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            _value = self.balance\r\n\r\n        Burner(self.burners[coin]).burn(coin, value=_value)  # dev: should implement burn()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef kill_me(_pool: address):\r\n    \"\"\"\r\n    @notice Pause the pool `_pool` - only remove_liquidity will be callable\r\n    @param _pool Pool address to pause\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).kill_me()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef unkill_me(_pool: address):\r\n    \"\"\"\r\n    @notice Unpause the pool `_pool`, re-enabling all functionality\r\n    @param _pool Pool address to unpause\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).unkill_me()\r\n\r\n\r\n@external\r\ndef set_burner_kill(_is_killed: bool):\r\n    \"\"\"\r\n    @notice Kill or unkill `burn` functionality\r\n    @param _is_killed Burner kill status\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    self.burner_kill = _is_killed\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef commit_transfer_ownership(_pool: address, new_owner: address):\r\n    \"\"\"\r\n    @notice Transfer ownership for `_pool` pool to `new_owner` address\r\n    @param _pool Pool which ownership is to be transferred\r\n    @param new_owner New pool owner address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).commit_transfer_ownership(new_owner)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef apply_transfer_ownership(_pool: address):\r\n    \"\"\"\r\n    @notice Apply transferring ownership of `_pool`\r\n    @param _pool Pool address\r\n    \"\"\"\r\n    Curve(_pool).apply_transfer_ownership()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef accept_transfer_ownership(_pool: address):\r\n    \"\"\"\r\n    @notice Apply transferring ownership of `_pool`\r\n    @param _pool Pool address\r\n    \"\"\"\r\n    Curve(_pool).accept_transfer_ownership()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef revert_transfer_ownership(_pool: address):\r\n    \"\"\"\r\n    @notice Revert commited transferring ownership for `_pool`\r\n    @param _pool Pool address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).revert_transfer_ownership()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef commit_new_parameters(_pool: address,\r\n                          amplification: uint256,\r\n                          new_fee: uint256,\r\n                          new_admin_fee: uint256,\r\n                          min_asymmetry: uint256):\r\n    \"\"\"\r\n    @notice Commit new parameters for `_pool`, A: `amplification`, fee: `new_fee` and admin fee: `new_admin_fee`\r\n    @param _pool Pool address\r\n    @param amplification Amplification coefficient\r\n    @param new_fee New fee\r\n    @param new_admin_fee New admin fee\r\n    @param min_asymmetry Minimal asymmetry factor allowed.\r\n            Asymmetry factor is:\r\n            Prod(balances) / (Sum(balances) / N) ** N\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).commit_new_parameters(amplification, new_fee, new_admin_fee)  # dev: if implemented by the pool\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef apply_new_parameters(_pool: address):\r\n    \"\"\"\r\n    @notice Apply new parameters for `_pool` pool\r\n    @dev Only callable by an EOA\r\n    @param _pool Pool address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).apply_new_parameters()  # dev: if implemented by the pool\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef revert_new_parameters(_pool: address):\r\n    \"\"\"\r\n    @notice Revert comitted new parameters for `_pool` pool\r\n    @param _pool Pool address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).revert_new_parameters()  # dev: if implemented by the pool\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef commit_new_fee(_pool: address, new_fee: uint256, new_admin_fee: uint256):\r\n    \"\"\"\r\n    @notice Commit new fees for `_pool` pool, fee: `new_fee` and admin fee: `new_admin_fee`\r\n    @param _pool Pool address\r\n    @param new_fee New fee\r\n    @param new_admin_fee New admin fee\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).commit_new_fee(new_fee, new_admin_fee)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef apply_new_fee(_pool: address):\r\n    \"\"\"\r\n    @notice Apply new fees for `_pool` pool\r\n    @param _pool Pool address\r\n    \"\"\"\r\n    Curve(_pool).apply_new_fee()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef ramp_A(_pool: address, _future_A: uint256, _future_time: uint256):\r\n    \"\"\"\r\n    @notice Start gradually increasing A of `_pool` reaching `_future_A` at `_future_time` time\r\n    @param _pool Pool address\r\n    @param _future_A Future A\r\n    @param _future_time Future time\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).ramp_A(_future_A, _future_time)\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef stop_ramp_A(_pool: address):\r\n    \"\"\"\r\n    @notice Stop gradually increasing A of `_pool`\r\n    @param _pool Pool address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Curve(_pool).stop_ramp_A()\r\n\r\n\r\n@external\r\n@nonreentrant('lock')\r\ndef donate_admin_fees(_pool: address):\r\n    \"\"\"\r\n    @notice Donate admin fees of `_pool` pool\r\n    @param _pool Pool address\r\n    \"\"\"\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n\r\n    Curve(_pool).donate_admin_fees()  # dev: if implemented by the pool\r\n\r\n\r\n@external\r\ndef set_reward_receiver(_pool: address, _receiver: address):\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n\r\n    Curve(_pool).set_reward_receiver(_receiver)\r\n\r\n\r\n@external\r\ndef set_admin_fee_receiver(_pool: address, _receiver: address):\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n\r\n    Curve(_pool).set_admin_fee_receiver(_receiver)\r\n\r\n\r\n@external\r\ndef set_bridging_contract(_bridging_contract: address):\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n\r\n    self.bridging_contract = _bridging_contract\r\n\r\n\r\n@external\r\ndef set_bridge_minimum(_coin: address, _min_amount: uint256):\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n\r\n    self.bridge_minimums[_coin] = _min_amount\r\n\r\n\r\n@external\r\ndef set_bridge_root_receiver(_receiver: address):\r\n    assert msg.sender == self.admin, \"Access denied\"\r\n    Bridger(self.bridging_contract).set_root_receiver(_receiver)\r\n\r\n\r\n@external\r\ndef bridge(_coin: address):\r\n    \"\"\"\r\n    @notice Transfer a coin to the root chain via the bridging contract.\r\n    @dev The contract owner can bridge any token in any quantity,\r\n         other accounts can only bridge approved tokens, where\r\n         the balance exceeds a minimum amount defined by the owner.\r\n         This prevents bridging tokens when the amount is so small\r\n         that claiming on the root chain becomes economically unfeasible.\r\n    @param _coin Address of the coin to be bridged.\r\n    \"\"\"\r\n    bridging_contract: address = self.bridging_contract\r\n    amount: uint256 = ERC20(_coin).balanceOf(self)\r\n    if amount > 0:\r\n        response: Bytes[32] = raw_call(\r\n            _coin,\r\n            _abi_encode(bridging_contract, amount, method_id=method_id(\"transfer(address,uint256)\")),\r\n            max_outsize=32,\r\n        )\r\n\r\n    if msg.sender != self.admin:\r\n        minimum: uint256 = self.bridge_minimums[_coin]\r\n        assert minimum != 0,  \"Coin not approved for bridging\"\r\n        assert minimum <= ERC20(_coin).balanceOf(bridging_contract), \"Balance below minimum bridge amount\"\r\n\r\n    Bridger(bridging_contract).bridge(_coin)", "ABI": "[{\"name\":\"AddBurner\",\"inputs\":[{\"name\":\"burner\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"CommitOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"ApplyOwnership\",\"inputs\":[{\"name\":\"admin\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_bridging_contract\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_new_admin\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":39572},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_new_admin\",\"inputs\":[],\"outputs\":[],\"gas\":39460},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_burner\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"},{\"name\":\"_burner\",\"type\":\"address\"}],\"outputs\":[],\"gas\":114551},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_many_burners\",\"inputs\":[{\"name\":\"_coins\",\"type\":\"address[20]\"},{\"name\":\"_burners\",\"type\":\"address[20]\"}],\"outputs\":[],\"gas\":1157106},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_admin_fees\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":62824},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw_many\",\"inputs\":[{\"name\":\"_pools\",\"type\":\"address[20]\"}],\"outputs\":[],\"gas\":164066},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":98948},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"burn_many\",\"inputs\":[{\"name\":\"_coins\",\"type\":\"address[20]\"}],\"outputs\":[],\"gas\":841915},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"kill_me\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":65190},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"unkill_me\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":65220},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_burner_kill\",\"inputs\":[{\"name\":\"_is_killed\",\"type\":\"bool\"}],\"outputs\":[],\"gas\":38088},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"new_owner\",\"type\":\"address\"}],\"outputs\":[],\"gas\":65509},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_transfer_ownership\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":63064},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":63094},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revert_transfer_ownership\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":65370},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_new_parameters\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"amplification\",\"type\":\"uint256\"},{\"name\":\"new_fee\",\"type\":\"uint256\"},{\"name\":\"new_admin_fee\",\"type\":\"uint256\"},{\"name\":\"min_asymmetry\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":65496},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_new_parameters\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":65430},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revert_new_parameters\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":65460},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_new_fee\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"new_fee\",\"type\":\"uint256\"},{\"name\":\"new_admin_fee\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":65574},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"apply_new_fee\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":63274},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"ramp_A\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_future_A\",\"type\":\"uint256\"},{\"name\":\"_future_time\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":65634},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"stop_ramp_A\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":65580},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"donate_admin_fees\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[],\"gas\":65610},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_reward_receiver\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[],\"gas\":8636},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_admin_fee_receiver\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[],\"gas\":8666},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_bridging_contract\",\"inputs\":[{\"name\":\"_bridging_contract\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38538},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_bridge_minimum\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"}],\"outputs\":[],\"gas\":38683},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_bridge_root_receiver\",\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[],\"gas\":12793},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"bridge\",\"inputs\":[{\"name\":\"_coin\",\"type\":\"address\"}],\"outputs\":[],\"gas\":22471},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"burners\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3758},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"burner_kill\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3516},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bridging_contract\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3546},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"bridge_minimums\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3848},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3606},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3636}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.3.0", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000007eeac6cddbd1d0b8af061742d41877d7f707289a00000000000000000000000028542e4af3de534ca36daf342febda541c937c5a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}