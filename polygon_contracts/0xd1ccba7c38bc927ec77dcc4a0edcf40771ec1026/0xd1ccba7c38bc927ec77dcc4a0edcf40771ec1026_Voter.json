{"SourceCode": "pragma solidity 0.8.13;\r\n\r\n\r\nlibrary Math {\r\n    function max(uint a, uint b) internal pure returns (uint) {\r\n        return a >= b ? a : b;\r\n    }\r\n    function min(uint a, uint b) internal pure returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n    function sqrt(uint y) internal pure returns (uint z) {\r\n        if (y > 3) {\r\n            z = y;\r\n            uint x = y / 2 + 1;\r\n            while (x < z) {\r\n                z = x;\r\n                x = (y / x + x) / 2;\r\n            }\r\n        } else if (y != 0) {\r\n            z = 1;\r\n        }\r\n    }\r\n    function cbrt(uint256 n) internal pure returns (uint256) { unchecked {\r\n        uint256 x = 0;\r\n        for (uint256 y = 1 << 255; y > 0; y >>= 3) {\r\n            x <<= 1;\r\n            uint256 z = 3 * x * (x + 1) + 1;\r\n            if (n / y >= z) {\r\n                n -= y * z;\r\n                x += 1;\r\n            }\r\n        }\r\n        return x;\r\n    }}\r\n}\r\n\r\ninterface IBribe {\r\n    function _deposit(uint amount, uint tokenId) external;\r\n    function _withdraw(uint amount, uint tokenId) external;\r\n    function getRewardForOwner(uint tokenId, address[] memory tokens) external;\r\n    function notifyRewardAmount(address token, uint amount) external;\r\n    function left(address token) external view returns (uint);\r\n}\r\n\r\ninterface IBribeFactory {\r\n    function createInternalBribe(address[] memory) external returns (address);\r\n    function createExternalBribe(address[] memory) external returns (address);\r\n}\r\n\r\ninterface IGauge {\r\n    function notifyRewardAmount(address token, uint amount) external;\r\n    function getReward(address account, address[] memory tokens) external;\r\n    function claimFees() external returns (uint claimed0, uint claimed1);\r\n    function left(address token) external view returns (uint);\r\n    function isForPair() external view returns (bool);\r\n}\r\n\r\ninterface IGaugeFactory {\r\n    function createGauge(address, address, address, address, bool, address[] memory) external returns (address);\r\n}\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function transfer(address recipient, uint amount) external returns (bool);\r\n    function decimals() external view returns (uint8);\r\n    function symbol() external view returns (string memory);\r\n    function balanceOf(address) external view returns (uint);\r\n    function transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n}\r\n\r\ninterface IMinter {\r\n    function update_period() external returns (uint);\r\n}\r\n\r\ninterface IPair {\r\n    function metadata() external view returns (uint dec0, uint dec1, uint r0, uint r1, bool st, address t0, address t1);\r\n    function claimFees() external returns (uint, uint);\r\n    function tokens() external returns (address, address);\r\n    function transferFrom(address src, address dst, uint amount) external returns (bool);\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function mint(address to) external returns (uint liquidity);\r\n    function getReserves() external view returns (uint _reserve0, uint _reserve1, uint _blockTimestampLast);\r\n    function getAmountOut(uint, address) external view returns (uint);\r\n}\r\n\r\ninterface IPairFactory {\r\n    function allPairsLength() external view returns (uint);\r\n    function isPair(address pair) external view returns (bool);\r\n    function pairCodeHash() external pure returns (bytes32);\r\n    function getPair(address tokenA, address token, bool stable) external view returns (address);\r\n    function createPair(address tokenA, address tokenB, bool stable) external returns (address pair);\r\n}\r\n\r\ninterface IVoter {\r\n    function _ve() external view returns (address);\r\n    function governor() external view returns (address);\r\n    function emergencyCouncil() external view returns (address);\r\n    function attachTokenToGauge(uint _tokenId, address account) external;\r\n    function detachTokenFromGauge(uint _tokenId, address account) external;\r\n    function emitDeposit(uint _tokenId, address account, uint amount) external;\r\n    function emitWithdraw(uint _tokenId, address account, uint amount) external;\r\n    function isWhitelisted(address token) external view returns (bool);\r\n    function notifyRewardAmount(uint amount) external;\r\n    function distribute(address _gauge) external;\r\n}\r\n\r\ninterface IVotingEscrow {\r\n\r\n    struct Point {\r\n        int128 bias;\r\n        int128 slope; // # -dweight / dt\r\n        uint256 ts;\r\n        uint256 blk; // block\r\n    }\r\n\r\n    function token() external view returns (address);\r\n    function team() external returns (address);\r\n    function epoch() external view returns (uint);\r\n    function point_history(uint loc) external view returns (Point memory);\r\n    function user_point_history(uint tokenId, uint loc) external view returns (Point memory);\r\n    function user_point_epoch(uint tokenId) external view returns (uint);\r\n\r\n    function ownerOf(uint) external view returns (address);\r\n    function isApprovedOrOwner(address, uint) external view returns (bool);\r\n    function transferFrom(address, address, uint) external;\r\n\r\n    function voting(uint tokenId) external;\r\n    function abstain(uint tokenId) external;\r\n    function attach(uint tokenId) external;\r\n    function detach(uint tokenId) external;\r\n\r\n    function checkpoint() external;\r\n    function deposit_for(uint tokenId, uint value) external;\r\n    function create_lock_for(uint, uint, address) external returns (uint);\r\n\r\n    function balanceOfNFT(uint) external view returns (uint);\r\n    function totalSupply() external view returns (uint);\r\n}\r\n\r\n// SPDX-License-Identifier: MIT\r\ncontract Voter is IVoter {\r\n\r\n    address public immutable _ve; // the ve token that governs these contracts\r\n    address public immutable factory; // the PairFactory\r\n    address internal immutable base;\r\n    address public immutable gaugefactory;\r\n    address public immutable bribefactory;\r\n    uint internal constant DURATION = 7 days; // rewards are released over 7 days\r\n    address public minter;\r\n    address public governor; // should be set to an IGovernor\r\n    address public emergencyCouncil; // credibly neutral party similar to Curve's Emergency DAO\r\n\r\n    uint public totalWeight; // total voting weight\r\n\r\n    address[] public pools; // all pools viable for incentives\r\n    mapping(address => address) public gauges; // pool => gauge\r\n    mapping(address => address) public poolForGauge; // gauge => pool\r\n    mapping(address => address) public internal_bribes; // gauge => internal bribe (only fees)\r\n    mapping(address => address) public external_bribes; // gauge => external bribe (real bribes)\r\n    mapping(address => uint256) public weights; // pool => weight\r\n    mapping(uint => mapping(address => uint256)) public votes; // nft => pool => votes\r\n    mapping(uint => address[]) public poolVote; // nft => pools\r\n    mapping(uint => uint) public usedWeights;  // nft => total voting weight of user\r\n    mapping(uint => uint) public lastVoted; // nft => timestamp of last vote, to ensure one vote per epoch\r\n    mapping(address => bool) public isGauge;\r\n    mapping(address => bool) public isWhitelisted;\r\n    mapping(address => bool) public isAlive;\r\n\r\n    event GaugeCreated(address indexed gauge, address creator, address internal_bribe, address indexed external_bribe, address indexed pool);\r\n    event GaugeKilled(address indexed gauge);\r\n    event GaugeRevived(address indexed gauge);\r\n    event Voted(address indexed voter, uint tokenId, uint256 weight);\r\n    event Abstained(uint tokenId, uint256 weight);\r\n    event Deposit(address indexed lp, address indexed gauge, uint tokenId, uint amount);\r\n    event Withdraw(address indexed lp, address indexed gauge, uint tokenId, uint amount);\r\n    event NotifyReward(address indexed sender, address indexed reward, uint amount);\r\n    event DistributeReward(address indexed sender, address indexed gauge, uint amount);\r\n    event Attach(address indexed owner, address indexed gauge, uint tokenId);\r\n    event Detach(address indexed owner, address indexed gauge, uint tokenId);\r\n    event Whitelisted(address indexed whitelister, address indexed token);\r\n\r\n    constructor(address __ve, address _factory, address  _gauges, address _bribes) {\r\n        _ve = __ve;\r\n        factory = _factory;\r\n        base = IVotingEscrow(__ve).token();\r\n        gaugefactory = _gauges;\r\n        bribefactory = _bribes;\r\n        minter = msg.sender;\r\n        governor = msg.sender;\r\n        emergencyCouncil = msg.sender;\r\n    }\r\n\r\n    // simple re-entrancy check\r\n    uint internal _unlocked = 1;\r\n    modifier lock() {\r\n        require(_unlocked == 1);\r\n        _unlocked = 2;\r\n        _;\r\n        _unlocked = 1;\r\n    }\r\n\r\n    modifier onlyNewEpoch(uint _tokenId) {\r\n        // ensure new epoch since last vote \r\n        require((block.timestamp / DURATION) * DURATION > lastVoted[_tokenId], \"TOKEN_ALREADY_VOTED_THIS_EPOCH\");\r\n        _;\r\n    }\r\n\r\n    function initialize(address[] memory _tokens, address _minter) external {\r\n        require(msg.sender == minter);\r\n        for (uint i = 0; i < _tokens.length; i++) {\r\n            _whitelist(_tokens[i]);\r\n        }\r\n        minter = _minter;\r\n    }\r\n\r\n    function setGovernor(address _governor) public {\r\n        require(msg.sender == governor);\r\n        governor = _governor;\r\n    }\r\n\r\n    function setEmergencyCouncil(address _council) public {\r\n        require(msg.sender == emergencyCouncil);\r\n        emergencyCouncil = _council;\r\n    }\r\n\r\n    function reset(uint _tokenId) external onlyNewEpoch(_tokenId) {\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\r\n        lastVoted[_tokenId] = block.timestamp;\r\n        _reset(_tokenId);\r\n        IVotingEscrow(_ve).abstain(_tokenId);\r\n    }\r\n\r\n    function _reset(uint _tokenId) internal {\r\n        address[] storage _poolVote = poolVote[_tokenId];\r\n        uint _poolVoteCnt = _poolVote.length;\r\n        uint256 _totalWeight = 0;\r\n\r\n        for (uint i = 0; i < _poolVoteCnt; i ++) {\r\n            address _pool = _poolVote[i];\r\n            uint256 _votes = votes[_tokenId][_pool];\r\n\r\n            if (_votes != 0) {\r\n                _updateFor(gauges[_pool]);\r\n                weights[_pool] -= _votes;\r\n                votes[_tokenId][_pool] -= _votes;\r\n                if (_votes > 0) {\r\n                    IBribe(internal_bribes[gauges[_pool]])._withdraw(uint256(_votes), _tokenId);\r\n                    IBribe(external_bribes[gauges[_pool]])._withdraw(uint256(_votes), _tokenId);\r\n                    _totalWeight += _votes;\r\n                } else {\r\n                    _totalWeight -= _votes;\r\n                }\r\n                emit Abstained(_tokenId, _votes);\r\n            }\r\n        }\r\n        totalWeight -= uint256(_totalWeight);\r\n        usedWeights[_tokenId] = 0;\r\n        delete poolVote[_tokenId];\r\n    }\r\n\r\n    function poke(uint _tokenId) external {\r\n        address[] memory _poolVote = poolVote[_tokenId];\r\n        uint _poolCnt = _poolVote.length;\r\n        uint256[] memory _weights = new uint256[](_poolCnt);\r\n\r\n        for (uint i = 0; i < _poolCnt; i ++) {\r\n            _weights[i] = votes[_tokenId][_poolVote[i]];\r\n        }\r\n\r\n        _vote(_tokenId, _poolVote, _weights);\r\n    }\r\n\r\n    function _vote(uint _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\r\n        _reset(_tokenId);\r\n        uint _poolCnt = _poolVote.length;\r\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\r\n        uint256 _totalVoteWeight = 0;\r\n        uint256 _totalWeight = 0;\r\n        uint256 _usedWeight = 0;\r\n\r\n        for (uint i = 0; i < _poolCnt; i++) {\r\n            _totalVoteWeight += _weights[i];\r\n        }\r\n\r\n        for (uint i = 0; i < _poolCnt; i++) {\r\n            address _pool = _poolVote[i];\r\n            address _gauge = gauges[_pool];\r\n\r\n            if (isGauge[_gauge]) {\r\n                uint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight;\r\n                require(votes[_tokenId][_pool] == 0);\r\n                require(_poolWeight != 0);\r\n                _updateFor(_gauge);\r\n\r\n                poolVote[_tokenId].push(_pool);\r\n\r\n                weights[_pool] += _poolWeight;\r\n                votes[_tokenId][_pool] += _poolWeight;\r\n                IBribe(internal_bribes[_gauge])._deposit(uint256(_poolWeight), _tokenId);\r\n                IBribe(external_bribes[_gauge])._deposit(uint256(_poolWeight), _tokenId);\r\n                _usedWeight += _poolWeight;\r\n                _totalWeight += _poolWeight;\r\n                emit Voted(msg.sender, _tokenId, _poolWeight);\r\n            }\r\n        }\r\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\r\n        totalWeight += uint256(_totalWeight);\r\n        usedWeights[_tokenId] = uint256(_usedWeight);\r\n    }\r\n\r\n    function vote(uint tokenId, address[] calldata _poolVote, uint256[] calldata _weights) external onlyNewEpoch(tokenId) {\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, tokenId));\r\n        require(_poolVote.length == _weights.length);\r\n        lastVoted[tokenId] = block.timestamp;\r\n        _vote(tokenId, _poolVote, _weights);\r\n    }\r\n\r\n    function whitelist(address _token) public {\r\n        require(msg.sender == governor);\r\n        _whitelist(_token);\r\n    }\r\n\r\n    function _whitelist(address _token) internal {\r\n        require(!isWhitelisted[_token]);\r\n        isWhitelisted[_token] = true;\r\n        emit Whitelisted(msg.sender, _token);\r\n    }\r\n\r\n    function createGauge(address _pool) external returns (address) {\r\n        require(gauges[_pool] == address(0x0), \"exists\");\r\n        address[] memory allowedRewards = new address[](3);\r\n        address[] memory internalRewards = new address[](2);\r\n        bool isPair = IPairFactory(factory).isPair(_pool);\r\n        address tokenA;\r\n        address tokenB;\r\n\r\n        if (isPair) {\r\n            (tokenA, tokenB) = IPair(_pool).tokens();\r\n            allowedRewards[0] = tokenA;\r\n            allowedRewards[1] = tokenB;\r\n            internalRewards[0] = tokenA;\r\n            internalRewards[1] = tokenB;\r\n\r\n            if (base != tokenA && base != tokenB) {\r\n              allowedRewards[2] = base;\r\n            }\r\n        }\r\n\r\n        if (msg.sender != governor) { // gov can create for any pool, even non-Dionysus pairs\r\n            require(isPair, \"!_pool\");\r\n            require(isWhitelisted[tokenA] && isWhitelisted[tokenB], \"!whitelisted\");\r\n        }\r\n\r\n        address _internal_bribe = IBribeFactory(bribefactory).createInternalBribe(internalRewards);\r\n        address _external_bribe = IBribeFactory(bribefactory).createExternalBribe(allowedRewards);\r\n        address _gauge = IGaugeFactory(gaugefactory).createGauge(_pool, _internal_bribe, _external_bribe, _ve, isPair, allowedRewards);\r\n\r\n        IERC20(base).approve(_gauge, type(uint).max);\r\n        internal_bribes[_gauge] = _internal_bribe;\r\n        external_bribes[_gauge] = _external_bribe;\r\n        gauges[_pool] = _gauge;\r\n        poolForGauge[_gauge] = _pool;\r\n        isGauge[_gauge] = true;\r\n        isAlive[_gauge] = true;\r\n        _updateFor(_gauge);\r\n        pools.push(_pool);\r\n        emit GaugeCreated(_gauge, msg.sender, _internal_bribe, _external_bribe, _pool);\r\n        return _gauge;\r\n    }\r\n\r\n    function killGauge(address _gauge) external {\r\n        require(msg.sender == emergencyCouncil, \"not emergency council\");\r\n        require(isAlive[_gauge], \"gauge already dead\");\r\n        isAlive[_gauge] = false;\r\n        claimable[_gauge] = 0;\r\n        emit GaugeKilled(_gauge);\r\n    }\r\n\r\n    function reviveGauge(address _gauge) external {\r\n        require(msg.sender == emergencyCouncil, \"not emergency council\");\r\n        require(!isAlive[_gauge], \"gauge already alive\");\r\n        isAlive[_gauge] = true;\r\n        emit GaugeRevived(_gauge);\r\n    }\r\n\r\n    function attachTokenToGauge(uint tokenId, address account) external {\r\n        require(isGauge[msg.sender]);\r\n        require(isAlive[msg.sender]); // killed gauges cannot attach tokens to themselves\r\n        if (tokenId > 0) IVotingEscrow(_ve).attach(tokenId);\r\n        emit Attach(account, msg.sender, tokenId);\r\n    }\r\n\r\n    function emitDeposit(uint tokenId, address account, uint amount) external {\r\n        require(isGauge[msg.sender]);\r\n        require(isAlive[msg.sender]);\r\n        emit Deposit(account, msg.sender, tokenId, amount);\r\n    }\r\n\r\n    function detachTokenFromGauge(uint tokenId, address account) external {\r\n        require(isGauge[msg.sender]);\r\n        if (tokenId > 0) IVotingEscrow(_ve).detach(tokenId);\r\n        emit Detach(account, msg.sender, tokenId);\r\n    }\r\n\r\n    function emitWithdraw(uint tokenId, address account, uint amount) external {\r\n        require(isGauge[msg.sender]);\r\n        emit Withdraw(account, msg.sender, tokenId, amount);\r\n    }\r\n\r\n    function length() external view returns (uint) {\r\n        return pools.length;\r\n    }\r\n\r\n    uint internal index;\r\n    mapping(address => uint) internal supplyIndex;\r\n    mapping(address => uint) public claimable;\r\n\r\n    function notifyRewardAmount(uint amount) external {\r\n        _safeTransferFrom(base, msg.sender, address(this), amount); // transfer the distro in\r\n        uint256 _ratio = amount * 1e18 / totalWeight; // 1e18 adjustment is removed during claim\r\n        if (_ratio > 0) {\r\n            index += _ratio;\r\n        }\r\n        emit NotifyReward(msg.sender, base, amount);\r\n    }\r\n\r\n    function updateFor(address[] memory _gauges) external {\r\n        for (uint i = 0; i < _gauges.length; i++) {\r\n            _updateFor(_gauges[i]);\r\n        }\r\n    }\r\n\r\n    function updateForRange(uint start, uint end) public {\r\n        for (uint i = start; i < end; i++) {\r\n            _updateFor(gauges[pools[i]]);\r\n        }\r\n    }\r\n\r\n    function updateAll() external {\r\n        updateForRange(0, pools.length);\r\n    }\r\n\r\n    function updateGauge(address _gauge) external {\r\n        _updateFor(_gauge);\r\n    }\r\n\r\n    function _updateFor(address _gauge) internal {\r\n        address _pool = poolForGauge[_gauge];\r\n        uint256 _supplied = weights[_pool];\r\n        if (_supplied > 0) {\r\n            uint _supplyIndex = supplyIndex[_gauge];\r\n            uint _index = index; // get global index0 for accumulated distro\r\n            supplyIndex[_gauge] = _index; // update _gauge current position to global position\r\n            uint _delta = _index - _supplyIndex; // see if there is any difference that need to be accrued\r\n            if (_delta > 0) {\r\n                uint _share = uint(_supplied) * _delta / 1e18; // add accrued difference for each supplied token\r\n                if (isAlive[_gauge]) {\r\n                    claimable[_gauge] += _share;\r\n                }\r\n            }\r\n        } else {\r\n            supplyIndex[_gauge] = index; // new users are set to the default global state\r\n        }\r\n    }\r\n\r\n    function claimRewards(address[] memory _gauges, address[][] memory _tokens) external {\r\n        for (uint i = 0; i < _gauges.length; i++) {\r\n            IGauge(_gauges[i]).getReward(msg.sender, _tokens[i]);\r\n        }\r\n    }\r\n\r\n    function claimBribes(address[] memory _bribes, address[][] memory _tokens, uint _tokenId) external {\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\r\n        for (uint i = 0; i < _bribes.length; i++) {\r\n            IBribe(_bribes[i]).getRewardForOwner(_tokenId, _tokens[i]);\r\n        }\r\n    }\r\n\r\n    function claimFees(address[] memory _fees, address[][] memory _tokens, uint _tokenId) external {\r\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId));\r\n        for (uint i = 0; i < _fees.length; i++) {\r\n            IBribe(_fees[i]).getRewardForOwner(_tokenId, _tokens[i]);\r\n        }\r\n    }\r\n\r\n    function distributeFees(address[] memory _gauges) external {\r\n        for (uint i = 0; i < _gauges.length; i++) {\r\n            if (IGauge(_gauges[i]).isForPair()){\r\n                IGauge(_gauges[i]).claimFees();\r\n            }\r\n        }\r\n    }\r\n\r\n    function distribute(address _gauge) public lock {\r\n        IMinter(minter).update_period();\r\n        _updateFor(_gauge); // should set claimable to 0 if killed\r\n        uint _claimable = claimable[_gauge];\r\n        if (_claimable > IGauge(_gauge).left(base) && _claimable / DURATION > 0) {\r\n            claimable[_gauge] = 0;\r\n            IGauge(_gauge).notifyRewardAmount(base, _claimable);\r\n            emit DistributeReward(msg.sender, _gauge, _claimable);\r\n        }\r\n    }\r\n\r\n    function distro() external {\r\n        distribute(0, pools.length);\r\n    }\r\n\r\n    function distribute() external {\r\n        distribute(0, pools.length);\r\n    }\r\n\r\n    function distribute(uint start, uint finish) public {\r\n        for (uint x = start; x < finish; x++) {\r\n            distribute(gauges[pools[x]]);\r\n        }\r\n    }\r\n\r\n    function distribute(address[] memory _gauges) external {\r\n        for (uint x = 0; x < _gauges.length; x++) {\r\n            distribute(_gauges[x]);\r\n        }\r\n    }\r\n\r\n    function _safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        require(token.code.length > 0);\r\n        (bool success, bytes memory data) =\r\n        token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"__ve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gauges\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bribes\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Abstained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Attach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Detach\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"DistributeReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"internal_bribe\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"external_bribe\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"GaugeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeKilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"}],\"name\":\"GaugeRevived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotifyReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"weight\",\"type\":\"uint256\"}],\"name\":\"Voted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"whitelister\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"gauge\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_ve\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"attachTokenToGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bribefactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_bribes\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimBribes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_fees\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"},{\"internalType\":\"address[][]\",\"name\":\"_tokens\",\"type\":\"address[][]\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pool\",\"type\":\"address\"}],\"name\":\"createGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"detachTokenFromGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"distributeFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"distro\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyCouncil\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"emitWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"external_bribes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaugefactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"gauges\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"internal_bribes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAlive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isGauge\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"killGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastVoted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"notifyRewardAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"poke\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"poolForGauge\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolVote\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"reset\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"reviveGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_council\",\"type\":\"address\"}],\"name\":\"setEmergencyCouncil\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"}],\"name\":\"setGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalWeight\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_gauges\",\"type\":\"address[]\"}],\"name\":\"updateFor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"updateForRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"}],\"name\":\"updateGauge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"usedWeights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_poolVote\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_weights\",\"type\":\"uint256[]\"}],\"name\":\"vote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"votes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"weights\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Voter", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000005c0fa75faa7a23166c4d09856aeefd0565098a33000000000000000000000000c03c125359111d188b1c4cd7e5ccd935edbb58330000000000000000000000003fb74787ac95d435684d035e29f29e70b917c5690000000000000000000000002cebb3925eb9ff6b0b057c5db185282388b96901", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3e7439b1a96b2c1b345f74b1ef3de16a3e338671c94c8efa114710acd7fff6a4"}