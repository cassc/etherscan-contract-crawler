{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/MobiusBand.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.19;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./Bucket.sol\\\";\\r\\nimport \\\"./IV3SwapRouter.sol\\\";\\r\\nimport \\\"./INonfungiblePositionManager.sol\\\";\\r\\n\\r\\ninterface IERC20EX is IERC20{\\r\\n    function _mint(address account, uint256 amount) external;\\r\\n    function _burn(address account, uint256 amount) external;\\r\\n    function getTokenAmountFromMatic(uint256 account) external view returns (uint256);\\r\\n}\\r\\n\\r\\ncontract MobiusBand is ReentrancyGuard, Bucket {\\r\\n    uint256 public constant PRINCIPAL_RATIO = 500000; //50%\\r\\n    uint256 public constant INVEST_RATIO = 300000; //30%\\r\\n    uint256 public constant RECOMMENDREWARD_RATIO = 20000; //2%\\r\\n    uint256 public constant REFERRER_RATIO = 60000; //6%\\r\\n    uint256 public constant BUYBACK_RATIO = 50000; //5%\\r\\n    uint256 public constant SUPERNODE_RATIO = 10000; //1%\\r\\n    uint256 public constant BONUS_RATIO = 20000; //2%\\r\\n    uint256 public constant COMMUNITY_RATIO = 20000; //2%\\r\\n    uint256 public constant PLATFORM_RATIO = 20000; //2%\\r\\n    uint256 public constant PRICE_PRECISION = 1e6;\\r\\n\\r\\n    uint256 public constant ACCURACY = 1e18;\\r\\n    uint256 public constant DEFAULT_INVEST_RETURN_RATE = 10000;\\r\\n\\r\\n    uint256 public constant MAX_INVEST = 1e3 * ACCURACY;\\r\\n    uint256 public constant MIN_INVEST = 1e2 * ACCURACY;\\r\\n\\r\\n    uint256 public constant TIME_UNIT = 1 days;\\r\\n\\r\\n    uint256 public constant MAX_SEARCH_DEPTH = 50;\\r\\n    uint256 public constant RANKED_INCENTIVE = 60;\\r\\n\\r\\n    address public bonusAddress;\\r\\n    address public communityAddress;\\r\\n    address public platformAddress;\\r\\n    uint256 public currentEpochs;\\r\\n\\r\\n    mapping(uint256 => mapping(address => PositionInfo[]))[6] public roundLedgers;\\r\\n    mapping(uint256 => RoundInfo)[6] public roundInfos;\\r\\n    mapping(address => UserRoundInfo[])[6] public userRoundsInfos;\\r\\n    mapping(address => UserGlobalInfo) public userGlobalInfos;\\r\\n    mapping(address => UserCapitalFlowInfo) public userCapitalFlowInfs;\\r\\n\\r\\n    mapping(address => address[]) public children;\\r\\n    uint256 public totalFlowAmount;\\r\\n    mapping(uint256 => uint256) public epochCurrentInvestAmount;\\r\\n    mapping(uint256 => uint256) public epochCurrentPrincipalAmount;\\r\\n\\r\\n    uint256 internal temporaryTokenAmount;\\r\\n    uint256 internal temporaryTotalProperty;\\r\\n    uint256 internal temporaryTotalMatic;\\r\\n\\r\\n    bool[] public epochStopLoss;\\r\\n    uint256 public totalLosePrincipal;\\r\\n    uint256 public stopLossAmount;\\r\\n\\r\\n    address public operator;\\r\\n    bool public gamePaused;\\r\\n\\r\\n    IV3SwapRouter router = IV3SwapRouter(0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45);\\r\\n    INonfungiblePositionManager positionManager =\\r\\n    INonfungiblePositionManager(0xC36442b4a4522E871399CD717aBDD847Ab11FE88);\\r\\n    uint24 constant defaultFee = 3000;\\r\\n    address public tokenAddress = 0xF70e40031adf2EF46B8fa600BdE1CEbAbBcE0065;\\r\\n    address public maticAddress = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\\r\\n    uint256 public positionId = 1015851;\\r\\n    uint256 public lpMaticAmount;\\r\\n    uint256 public lpMaticLimit;\\r\\n\\r\\n    uint256 public tokenConsumeRatio;\\r\\n    uint256 public startUseTokenNum;\\r\\n    uint256[9] public levelSales = [1000 * ACCURACY, 3000 * ACCURACY, 5000 * ACCURACY, 10000 * ACCURACY, 50000 * ACCURACY, 100000 * ACCURACY, 500000 * ACCURACY, 1000000 * ACCURACY, 5000000 * ACCURACY];\\r\\n    uint256[5] public tokenOutputRatio;\\r\\n\\r\\n    struct FundTarget {\\r\\n        uint256 lastCheckTime;\\r\\n        uint256 amount;\\r\\n        uint256 achievedAmount;\\r\\n    }\\r\\n\\r\\n    struct UserGlobalInfo {\\r\\n        address referrer;\\r\\n        uint256 totalReferrerReward;\\r\\n        uint256 referrerRewardClaimed;\\r\\n        uint256 maxChildrenSales;\\r\\n        uint256 sales;\\r\\n        uint256 totalPositionAmount;\\r\\n        uint256 reportedSales;\\r\\n        uint8 salesLevel;\\r\\n        bool supernode;\\r\\n        address supernodeAddress;\\r\\n    }\\r\\n\\r\\n    struct UserCapitalFlowInfo {\\r\\n        uint256 totalPrincipalClaimed;\\r\\n        uint256 totalRecommendReward;\\r\\n        uint256 totalExpectedInvestReturnAmount;\\r\\n        uint256 totalExpectedInvestRewardAmount;\\r\\n        uint256 totalConvertTokenAmount;\\r\\n    }\\r\\n\\r\\n    struct PositionInfo {\\r\\n        uint256 amount;\\r\\n        uint256 openTime;\\r\\n        uint256 expiryTime;\\r\\n        uint256 investReturnRate;\\r\\n        uint256 withdrawnAmount;\\r\\n        uint256 investReturnAmount;\\r\\n        uint256 index;\\r\\n        uint256 removalTime;\\r\\n    }\\r\\n\\r\\n    struct LinkedPosition {\\r\\n        address user;\\r\\n        uint256 userPositionIndex;\\r\\n    }\\r\\n\\r\\n    struct RoundInfo {\\r\\n        FundTarget fundTarget;\\r\\n        uint256 totalPositionAmount;\\r\\n        uint256 currentPrincipalAmount;\\r\\n        uint256 currentInvestAmount;\\r\\n        uint256 totalPositionCount;\\r\\n        uint256 currentPositionCount;\\r\\n        uint256 incentiveSnapshot;\\r\\n        uint256 head;\\r\\n        mapping(uint256 => LinkedPosition) linkedPositions;\\r\\n        mapping(address => uint256) ledgerRoundToUserRoundIndex;\\r\\n        bool stopLoss;\\r\\n    }\\r\\n\\r\\n    struct UserRoundInfo {\\r\\n        uint256 epoch;\\r\\n        uint256 totalPositionAmount;\\r\\n        uint256 currentPrincipalAmount;\\r\\n        uint256 totalWithdrawnAmount;\\r\\n        uint256 totalClosedPositionCount;\\r\\n    }\\r\\n\\r\\n    struct ReferrerSearch {\\r\\n        uint256 currentUserSales;\\r\\n        uint256 currentReferrerSales;\\r\\n        address currentReferrer;\\r\\n        uint256 currentReferrerAmount;\\r\\n        uint256 levelDiffAmount;\\r\\n        uint256 leftLevelDiffAmount;\\r\\n        uint256 levelDiffAmountPerLevel;\\r\\n        uint256 currentReferrerMaxChildSales;\\r\\n        uint256 currentUserTotalPosAmount;\\r\\n        uint256 currentUserReportedSales;\\r\\n        address currentUser;\\r\\n        uint256 currentReferrerRoundsLength;\\r\\n        uint256 currentReferrerNewEpoch;\\r\\n        uint8 depth;\\r\\n        uint8 currentLevelDiff;\\r\\n        uint8 baseSalesLevel;\\r\\n        uint8 currentReferrerLevel;\\r\\n        bool levelDiffDone;\\r\\n        bool levelSearchDone;\\r\\n        bool levelSalesDone;\\r\\n    }\\r\\n\\r\\n    struct OpenPositionParams {\\r\\n        uint256 principalAmount;\\r\\n        uint256 investAmount;\\r\\n        uint256 referrerAmount;\\r\\n        uint256 investReturnRate;\\r\\n    }\\r\\n\\r\\n    struct AssetPackageInfo {\\r\\n        uint256 birthday;\\r\\n        uint256 amount;\\r\\n        uint256 release;\\r\\n        uint256 withdrawn;\\r\\n        bool state;\\r\\n    }\\r\\n\\r\\n    event PositionOpened(address indexed user, uint256 indexed ledgeType, uint256 indexed epoch, uint256 positionIndex, uint256 amount);\\r\\n    event PositionClosed(address indexed user, uint256 indexed ledgeType, uint256 indexed epoch, uint256 positionIndex, uint256 amount);\\r\\n    event NewReferrer(address indexed user, address indexed referrer);\\r\\n    event NewRound(uint256 indexed epoch, uint256 indexed ledgeType);\\r\\n    event ReferrerRewardAdded(address indexed user, uint256 amount, uint256 indexed rewardType);\\r\\n    event ReferrerRewardClaimed(address indexed user, uint256 amount);\\r\\n    event SalesLevelUpdated(address indexed user, uint8 level);\\r\\n    event SllocationAmount(address form, address to, uint256 amount);\\r\\n\\r\\n    mapping(address => AssetPackageInfo[]) public AssetPackage;\\r\\n\\r\\n    modifier notContract() {\\r\\n        require(msg.sender == tx.origin, \\\"Contract not allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    constructor(\\r\\n        address _bonusAddress,\\r\\n        address _communityAddress,\\r\\n        address _platformAddress,\\r\\n        address _operator\\r\\n    ) {\\r\\n        require(\\r\\n            _bonusAddress != address(0) && _communityAddress != address(0) && _platformAddress != address(0) && _operator != address(0),\\r\\n            \\\"Invalid address provided\\\"\\r\\n        );\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo;\\r\\n        userGlobalInfo = userGlobalInfos[_platformAddress];\\r\\n        userGlobalInfo.referrer = address(0);\\r\\n        userGlobalInfo.salesLevel = 12;\\r\\n        children[address(0)].push(_platformAddress);\\r\\n\\r\\n        bonusAddress = _bonusAddress;\\r\\n        communityAddress = _communityAddress;\\r\\n        platformAddress = _platformAddress;\\r\\n        operator = _operator;\\r\\n        gamePaused = false;\\r\\n\\r\\n        IERC20(tokenAddress).approve(address(router),type(uint).max);\\r\\n        IERC20(tokenAddress).approve(address(positionManager),type(uint).max);\\r\\n\\r\\n        tokenConsumeRatio = 100000;\\r\\n        tokenOutputRatio = [100 * PRICE_PRECISION, 50 * PRICE_PRECISION, 25 * PRICE_PRECISION, 10 * PRICE_PRECISION, PRICE_PRECISION];\\r\\n        lpMaticLimit = 500000 * ACCURACY;\\r\\n        startUseTokenNum = 25000000 * ACCURACY;\\r\\n    }\\r\\n\\r\\n    function addCurrentInvestAmount(uint256 epoch, bool _add, uint256 num) external {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        if(_add){\\r\\n            epochCurrentInvestAmount[epoch] += num;\\r\\n        }else{\\r\\n            epochCurrentInvestAmount[epoch] -= num;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setTokenConsumeRatio(uint256 _ratio) external {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        tokenConsumeRatio = _ratio;\\r\\n    }\\r\\n\\r\\n    function updateTokenOutputRatio(uint256[] memory _ratio) external {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        for (uint256 i = 0; i < 5; i++) {\\r\\n            tokenOutputRatio[i] = _ratio[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setPause(bool _paused) external {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        gamePaused = _paused;\\r\\n    }\\r\\n\\r\\n    function setlpMaticLimit(uint256 amount) public {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        lpMaticLimit = amount;\\r\\n    }\\r\\n\\r\\n    function setStartUseTokenNum(uint256 amount) public {\\r\\n        require(msg.sender == operator, \\\"Only operator\\\");\\r\\n        startUseTokenNum = amount;\\r\\n    }\\r\\n\\r\\n    function batchSetReferrerInfo(\\r\\n        address[] memory users,\\r\\n        address[] memory referrers,\\r\\n        uint8[] memory salesLevels,\\r\\n        bool[] memory supernodes,\\r\\n        address[] memory supernodeAddresss\\r\\n    ) external {\\r\\n        require(msg.sender == operator, \\\"Only admin\\\");\\r\\n        require(users.length == referrers.length && users.length == salesLevels.length && users.length == supernodes.length && users.length == supernodeAddresss.length, \\\"Invalid input\\\");\\r\\n        UserGlobalInfo storage userGlobalInfo;\\r\\n        uint256 userLength = users.length;\\r\\n        for (uint256 i = 0; i < userLength; ++i) {\\r\\n            require(users[i] != address(0), \\\"Invalid address provided\\\");\\r\\n            userGlobalInfo = userGlobalInfos[users[i]];\\r\\n            require(userGlobalInfo.referrer == address(0), \\\"Referrer already set\\\");\\r\\n            userGlobalInfo.referrer = referrers[i];\\r\\n            userGlobalInfo.salesLevel = salesLevels[i];\\r\\n            userGlobalInfo.supernode = supernodes[i];\\r\\n            userGlobalInfo.supernodeAddress = supernodeAddresss[i];\\r\\n            children[referrers[i]].push(users[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setStock(\\r\\n        uint256 ledgerType,\\r\\n        uint8[] memory typeDays,\\r\\n        uint16[] memory stock\\r\\n    ) public {\\r\\n        require(ledgerType > 0, \\\"Invalid ledger type\\\");\\r\\n        require(ledgerType < 4, \\\"Invalid ledger type\\\");\\r\\n        require(stock.length > 0, \\\"Invalid stock array\\\");\\r\\n        require(typeDays.length == stock.length, \\\"Invalid params\\\");\\r\\n\\r\\n        _setStock(ledgerType, typeDays, stock);\\r\\n    }\\r\\n\\r\\n    function openPosition(\\r\\n        address referrer\\r\\n    ) public payable notContract nonReentrant {\\r\\n        require(msg.value >= MIN_INVEST, \\\"Too small\\\");\\r\\n        require(msg.value <= MAX_INVEST, \\\"Too large\\\");\\r\\n        require(!gamePaused, \\\"Paused\\\");\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n        address _referrer = userGlobalInfo.referrer;\\r\\n\\r\\n        if (_referrer == address(0) && children[msg.sender].length == 0) {\\r\\n            _referrer = referrer;\\r\\n            require((referrer != address(0) && referrer != msg.sender) || referrer == platformAddress, \\\"Invalid referrer 1\\\");\\r\\n\\r\\n            require(userGlobalInfos[referrer].totalPositionAmount > 0 || referrer == platformAddress, \\\"Invalid referrer 2\\\");\\r\\n\\r\\n            require(userGlobalInfos[referrer].referrer != address(0) || children[referrer].length > 0 || referrer == platformAddress,  \\\"Invalid referrer 3\\\");\\r\\n\\r\\n            userGlobalInfo.referrer = referrer;\\r\\n            children[referrer].push(msg.sender);\\r\\n\\r\\n        }\\r\\n\\r\\n        if(userGlobalInfo.supernodeAddress == address(0)){\\r\\n            if(userGlobalInfos[_referrer].supernode == true){\\r\\n                userGlobalInfo.supernodeAddress = _referrer;\\r\\n            }else if(userGlobalInfos[_referrer].supernodeAddress != address(0)){\\r\\n                userGlobalInfo.supernodeAddress = userGlobalInfos[_referrer].supernodeAddress;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if(totalFlowAmount >= startUseTokenNum){\\r\\n            uint256 useTokenAmount = msg.value * tokenConsumeRatio / PRICE_PRECISION;\\r\\n            require(IERC20(tokenAddress).balanceOf(msg.sender) >= useTokenAmount, \\\"Insufficient Token amount\\\");\\r\\n            require(IERC20(tokenAddress).allowance(msg.sender, address(this)) >= useTokenAmount, \\\"Insufficient Token allowance\\\");\\r\\n            IERC20EX(tokenAddress)._burn(msg.sender, useTokenAmount);\\r\\n        }\\r\\n\\r\\n        bool success;\\r\\n\\r\\n        {\\r\\n            uint256 recommendReward = msg.value * RECOMMENDREWARD_RATIO / PRICE_PRECISION;\\r\\n            userCapitalFlowInfs[_referrer].totalRecommendReward += recommendReward;\\r\\n            (success, ) = _referrer.call{value: recommendReward}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n            emit SllocationAmount(address(this), _referrer, recommendReward);\\r\\n        }\\r\\n\\r\\n        {\\r\\n            uint256 buybackAmount = msg.value * BUYBACK_RATIO / PRICE_PRECISION;\\r\\n            if(lpMaticAmount < lpMaticLimit){\\r\\n                uint256 backTokenAmount = IERC20EX(tokenAddress).getTokenAmountFromMatic(buybackAmount);\\r\\n                if(IERC20EX(tokenAddress).balanceOf(address(this)) >= backTokenAmount){\\r\\n                    addLiquitidyWithId(backTokenAmount,buybackAmount);\\r\\n                    lpMaticAmount += buybackAmount;\\r\\n                }\\r\\n            }else{\\r\\n                uint256 historyTokenAmount = IERC20(tokenAddress).balanceOf(address(this));\\r\\n                buyBurn(buybackAmount);\\r\\n                uint256 nowTokenAmount = IERC20(tokenAddress).balanceOf(address(this));\\r\\n                uint256 differenceTokenAmount = nowTokenAmount - historyTokenAmount;\\r\\n                if(differenceTokenAmount > 0){\\r\\n                    IERC20EX(tokenAddress)._burn(address(this), differenceTokenAmount);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n        {\\r\\n            if(userGlobalInfo.supernodeAddress != address(0)){\\r\\n                uint256 supernodeAmount = msg.value * SUPERNODE_RATIO / PRICE_PRECISION;\\r\\n                (success, ) = userGlobalInfo.supernodeAddress.call{value: supernodeAmount}(\\\"\\\");\\r\\n                require(success, \\\"Transfer failed.\\\");\\r\\n                emit SllocationAmount(address(this), userGlobalInfo.supernodeAddress, supernodeAmount);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        {\\r\\n            uint256 organization = msg.value * BONUS_RATIO / PRICE_PRECISION;\\r\\n            (success, ) = bonusAddress.call{value: organization}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n            emit SllocationAmount(address(this), bonusAddress, organization);\\r\\n            (success, ) = communityAddress.call{value: organization}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n            emit SllocationAmount(address(this), communityAddress, organization);\\r\\n            (success, ) = platformAddress.call{value: organization}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n            emit SllocationAmount(address(this), platformAddress, organization);\\r\\n        }\\r\\n\\r\\n        uint256 MagicBoxAmount1 =  msg.value * 20 / 100;\\r\\n        uint256 MagicBoxAmount2 =  msg.value * 15 / 100;\\r\\n        uint256 MagicBoxAmount3 =  msg.value * 25 / 100;\\r\\n        uint256 MagicBoxAmount4 =  msg.value * 40 / 100;\\r\\n        uint256 distributionAmount = 0;\\r\\n        distributionAmount += setPosition(MagicBoxAmount1,0);\\r\\n        distributionAmount += setPosition(MagicBoxAmount2,1);\\r\\n        distributionAmount += setPosition(MagicBoxAmount3,2);\\r\\n        distributionAmount += setPosition(MagicBoxAmount4,3);\\r\\n\\r\\n        totalFlowAmount += msg.value;\\r\\n    }\\r\\n\\r\\n    function setPosition (\\r\\n        uint256 amountValue,\\r\\n        uint256 ledgerType\\r\\n    ) internal returns (uint256) {\\r\\n        require(ledgerType < 4, \\\"Invalid ledger type\\\");\\r\\n\\r\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][currentEpochs];\\r\\n\\r\\n        UserRoundInfo storage userRoundInfo;\\r\\n\\r\\n        OpenPositionParams memory params = OpenPositionParams({\\r\\n            principalAmount: (amountValue * PRINCIPAL_RATIO) / PRICE_PRECISION,\\r\\n            investAmount: (amountValue * INVEST_RATIO) / PRICE_PRECISION,\\r\\n            referrerAmount: (amountValue * REFERRER_RATIO) / PRICE_PRECISION,\\r\\n            investReturnRate: DEFAULT_INVEST_RETURN_RATE\\r\\n        });\\r\\n\\r\\n        uint256 userRoundInfoLength = userRoundsInfos[ledgerType][msg.sender].length;\\r\\n        if (\\r\\n            userRoundInfoLength == 0 ||\\r\\n            userRoundsInfos[ledgerType][msg.sender][userRoundInfoLength - 1].epoch < currentEpochs\\r\\n        ) {\\r\\n\\r\\n            UserRoundInfo memory _userRoundInfo;\\r\\n            _userRoundInfo = UserRoundInfo({\\r\\n                epoch: currentEpochs,\\r\\n                totalPositionAmount: 0,\\r\\n                currentPrincipalAmount: 0,\\r\\n                totalWithdrawnAmount: 0,\\r\\n                totalClosedPositionCount: 0\\r\\n            });\\r\\n\\r\\n            userRoundsInfos[ledgerType][msg.sender].push(_userRoundInfo);\\r\\n            roundInfo.ledgerRoundToUserRoundIndex[msg.sender] = userRoundInfoLength;\\r\\n            userRoundInfoLength += 1;\\r\\n        }\\r\\n\\r\\n        if(epochStopLoss.length == 0 || epochStopLoss.length < (currentEpochs + 1)){\\r\\n            epochStopLoss.push(false);\\r\\n        }\\r\\n\\r\\n        userRoundInfo = userRoundsInfos[ledgerType][msg.sender][userRoundInfoLength - 1];\\r\\n        userRoundInfo.totalPositionAmount += amountValue;\\r\\n        userRoundInfo.currentPrincipalAmount += params.principalAmount;\\r\\n\\r\\n        roundInfo.totalPositionAmount += amountValue;\\r\\n        roundInfo.currentPrincipalAmount += params.principalAmount;\\r\\n        epochCurrentPrincipalAmount[currentEpochs] += params.principalAmount;\\r\\n\\r\\n        epochCurrentInvestAmount[currentEpochs] += params.investAmount;\\r\\n        roundInfo.currentPositionCount += 1;\\r\\n        roundInfo.incentiveSnapshot += amountValue;\\r\\n        roundInfo.totalPositionCount += 1;\\r\\n\\r\\n        uint256 userTotalPositionCount = roundLedgers[ledgerType][currentEpochs][msg.sender].length;\\r\\n\\r\\n        {\\r\\n            uint256 openTime = block.timestamp;\\r\\n            uint256 expiryTime = block.timestamp;\\r\\n            if (ledgerType == 0) {\\r\\n                expiryTime += TIME_UNIT;\\r\\n            } else {\\r\\n                expiryTime += _pickDay(ledgerType, roundInfo.totalPositionCount) * TIME_UNIT;\\r\\n            }\\r\\n\\r\\n            PositionInfo memory positionInfo = PositionInfo({\\r\\n                amount: amountValue,\\r\\n                openTime: openTime,\\r\\n                expiryTime: expiryTime,\\r\\n                investReturnRate: params.investReturnRate,\\r\\n                withdrawnAmount: 0,\\r\\n                investReturnAmount: 0,\\r\\n                index: userTotalPositionCount,\\r\\n                removalTime: 0\\r\\n            });\\r\\n\\r\\n            roundLedgers[ledgerType][currentEpochs][msg.sender].push(positionInfo);\\r\\n        }\\r\\n\\r\\n        _distributeReferrerReward(amountValue, msg.sender, params.referrerAmount);\\r\\n\\r\\n        {\\r\\n\\r\\n            mapping(uint256 => LinkedPosition) storage linkedPositions = roundInfo.linkedPositions;\\r\\n\\r\\n            LinkedPosition storage linkedPosition = linkedPositions[roundInfo.totalPositionCount - 1];\\r\\n            linkedPosition.user = msg.sender;\\r\\n            linkedPosition.userPositionIndex = userTotalPositionCount;\\r\\n\\r\\n            if (roundInfo.totalPositionCount - roundInfo.head > RANKED_INCENTIVE) {\\r\\n\\r\\n                LinkedPosition storage headLinkedPosition = linkedPositions[roundInfo.head];\\r\\n                PositionInfo storage headPositionInfo = roundLedgers[ledgerType][currentEpochs][headLinkedPosition.user][\\r\\n                                headLinkedPosition.userPositionIndex\\r\\n                    ];\\r\\n\\r\\n                unchecked {\\r\\n                    roundInfo.incentiveSnapshot -= headPositionInfo.amount;\\r\\n                }\\r\\n\\r\\n                roundInfo.head += 1;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return  params.principalAmount + params.investAmount + params.referrerAmount;\\r\\n    }\\r\\n\\r\\n    function closePosition(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        uint256 positionIndex\\r\\n    ) external notContract nonReentrant {\\r\\n        require(ledgerType < 4, \\\"Invalid ledger type\\\");\\r\\n        require(epoch <= currentEpochs, \\\"Invalid epoch\\\");\\r\\n\\r\\n        PositionInfo[] storage positionInfos = roundLedgers[ledgerType][epoch][msg.sender];\\r\\n        require(positionIndex < positionInfos.length, \\\"Invalid position index\\\");\\r\\n\\r\\n        PositionInfo storage positionInfo = positionInfos[positionIndex];\\r\\n\\r\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][epoch];\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n\\r\\n        UserCapitalFlowInfo storage userCapitalFlowInfo = userCapitalFlowInfs[msg.sender];\\r\\n\\r\\n        _safeClosePosition(ledgerType, epoch, positionIndex, positionInfo, roundInfo, userGlobalInfo, userCapitalFlowInfo);\\r\\n    }\\r\\n\\r\\n    function batchClosePositions(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        uint256[] calldata positionIndexes\\r\\n    ) external nonReentrant {\\r\\n        require(ledgerType < 4, \\\"Invalid ledger type\\\");\\r\\n        require(epoch <= currentEpochs, \\\"Invalid epoch\\\");\\r\\n        require(positionIndexes.length > 0, \\\"Invalid position indexes\\\");\\r\\n\\r\\n        PositionInfo[] storage positionInfos = roundLedgers[ledgerType][epoch][msg.sender];\\r\\n\\r\\n        RoundInfo storage roundInfo = roundInfos[ledgerType][epoch];\\r\\n\\r\\n        PositionInfo storage positionInfo;\\r\\n\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[msg.sender];\\r\\n\\r\\n        UserCapitalFlowInfo storage userCapitalFlowInfo = userCapitalFlowInfs[msg.sender];\\r\\n\\r\\n        uint256 positionIndexesLength = positionIndexes.length;\\r\\n        uint256 positionInfosLength = positionInfos.length;\\r\\n        for (uint256 i = 0; i < positionIndexesLength; ++i) {\\r\\n            require(positionIndexes[i] < positionInfosLength, \\\"Invalid position index\\\");\\r\\n\\r\\n            positionInfo = positionInfos[positionIndexes[i]];\\r\\n            _safeClosePosition(ledgerType, epoch, positionIndexes[i], positionInfo, roundInfo, userGlobalInfo, userCapitalFlowInfo);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function claimReferrerReward(address referrer) external notContract nonReentrant {\\r\\n        require(referrer != address(0), \\\"Invalid referrer address\\\");\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[referrer];\\r\\n        uint256 claimableAmount = userGlobalInfo.totalReferrerReward - userGlobalInfo.referrerRewardClaimed;\\r\\n        require(claimableAmount > 0, \\\"No claimable amount\\\");\\r\\n        userGlobalInfo.referrerRewardClaimed += claimableAmount;\\r\\n        {\\r\\n            (bool success, ) = referrer.call{value: claimableAmount}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function getUserRounds(\\r\\n        uint256 ledgerType,\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (UserRoundInfo[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 roundCount = userRoundsInfos[ledgerType][user].length;\\r\\n        if (cursor + length > roundCount) {\\r\\n            length = roundCount - cursor;\\r\\n        }\\r\\n\\r\\n        UserRoundInfo[] memory userRoundInfos = new UserRoundInfo[](length);\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            userRoundInfos[i] = userRoundsInfos[ledgerType][user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (userRoundInfos, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getUserRoundsLength(uint256 ledgerType, address user) external view returns (uint256) {\\r\\n        return userRoundsInfos[ledgerType][user].length;\\r\\n    }\\r\\n\\r\\n    function getUserRoundLedgers(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (PositionInfo[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 positionCount = roundLedgers[ledgerType][epoch][user].length;\\r\\n        if (cursor + length > positionCount) {\\r\\n            length = positionCount - cursor;\\r\\n        }\\r\\n\\r\\n        PositionInfo[] memory positionInfos = new PositionInfo[](length);\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            positionInfos[i] = roundLedgers[ledgerType][epoch][user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (positionInfos, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getUserRoundLedgersLength(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        address user\\r\\n    ) external view returns (uint256) {\\r\\n        return roundLedgers[ledgerType][epoch][user].length;\\r\\n    }\\r\\n\\r\\n    function getChildren(\\r\\n        address user,\\r\\n        uint256 cursor,\\r\\n        uint256 size\\r\\n    ) external view returns (address[] memory, uint256) {\\r\\n        uint256 length = size;\\r\\n        uint256 childrenCount = children[user].length;\\r\\n        if (cursor + length > childrenCount) {\\r\\n            length = childrenCount - cursor;\\r\\n        }\\r\\n\\r\\n        address[] memory _children = new address[](length);\\r\\n        for (uint256 i = 0; i < length; ++i) {\\r\\n            _children[i] = children[user][cursor + i];\\r\\n        }\\r\\n\\r\\n        return (_children, cursor + length);\\r\\n    }\\r\\n\\r\\n    function getLedgerRoundToUserRoundIndex(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        address user\\r\\n    ) external view returns (uint256) {\\r\\n        return roundInfos[ledgerType][epoch].ledgerRoundToUserRoundIndex[user];\\r\\n    }\\r\\n\\r\\n    function getChildrenLength(address user) external view returns (uint256) {\\r\\n        return children[user].length;\\r\\n    }\\r\\n\\r\\n    function getUserDepartSalesAndLevel(address user) external view returns (uint256, uint8) {\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\r\\n        return (userGlobalInfo.sales - userGlobalInfo.maxChildrenSales, userGlobalInfo.salesLevel);\\r\\n    }\\r\\n\\r\\n    function _safeClosePosition(\\r\\n        uint256 ledgerType,\\r\\n        uint256 epoch,\\r\\n        uint256 positionIndex,\\r\\n        PositionInfo storage positionInfo,\\r\\n        RoundInfo storage roundInfo,\\r\\n        UserGlobalInfo storage userGlobalInfo,\\r\\n        UserCapitalFlowInfo storage userCapitalFlowInfo\\r\\n    ) internal {\\r\\n        require(positionInfo.withdrawnAmount == 0, \\\"Position already claimed\\\");\\r\\n        require(positionInfo.expiryTime <= block.timestamp || epochStopLoss[epoch], \\\"Position not expired\\\");\\r\\n\\r\\n        uint256 targetRoundInfoIndex = roundInfo.ledgerRoundToUserRoundIndex[msg.sender];\\r\\n        UserRoundInfo storage userRoundInfo = userRoundsInfos[ledgerType][msg.sender][targetRoundInfoIndex];\\r\\n\\r\\n        uint256 payoutAmount;\\r\\n        uint256 principalAmount = (positionInfo.amount * PRINCIPAL_RATIO) / PRICE_PRECISION;\\r\\n        roundInfo.currentPositionCount -= 1;\\r\\n        roundInfo.currentPrincipalAmount -= principalAmount;\\r\\n        userRoundInfo.currentPrincipalAmount -= principalAmount;\\r\\n\\r\\n        temporaryTokenAmount = 0;\\r\\n        if (!epochStopLoss[epoch]) {\\r\\n\\r\\n            payoutAmount += principalAmount;\\r\\n            userCapitalFlowInfo.totalPrincipalClaimed += principalAmount;\\r\\n\\r\\n            uint256 daysPassed;\\r\\n            daysPassed = (positionInfo.expiryTime - positionInfo.openTime);\\r\\n\\r\\n            uint256 expectedInvestReturnAmount = (positionInfo.amount * positionInfo.investReturnRate * daysPassed) /\\r\\n                        PRICE_PRECISION /\\r\\n                        TIME_UNIT;\\r\\n\\r\\n            uint256 investReturnAmount = positionInfo.amount - principalAmount + expectedInvestReturnAmount;\\r\\n\\r\\n            if (epochCurrentInvestAmount[epoch] < investReturnAmount) {\\r\\n                if(epochCurrentInvestAmount[epoch] > principalAmount){\\r\\n                    userCapitalFlowInfo.totalExpectedInvestRewardAmount += epochCurrentInvestAmount[epoch] - principalAmount;\\r\\n                }else{\\r\\n                    temporaryTokenAmount = principalAmount - epochCurrentInvestAmount[epoch];\\r\\n                }\\r\\n                investReturnAmount = epochCurrentInvestAmount[epoch];\\r\\n                epochCurrentInvestAmount[epoch] = 0;\\r\\n            } else {\\r\\n                unchecked {\\r\\n                    epochCurrentInvestAmount[epoch] -= investReturnAmount;\\r\\n                    userCapitalFlowInfo.totalExpectedInvestRewardAmount += expectedInvestReturnAmount;\\r\\n                }\\r\\n            }\\r\\n            userCapitalFlowInfo.totalExpectedInvestReturnAmount += investReturnAmount;\\r\\n\\r\\n            if (epochCurrentInvestAmount[epoch] == 0) {\\r\\n\\r\\n                if(temporaryTokenAmount > 0){\\r\\n                    temporaryTotalProperty = userCapitalFlowInfo.totalPrincipalClaimed + userGlobalInfo.totalReferrerReward + userCapitalFlowInfo.totalRecommendReward + userCapitalFlowInfo.totalExpectedInvestReturnAmount + userCapitalFlowInfo.totalConvertTokenAmount;\\r\\n\\r\\n                    setAssetPackage(userGlobalInfo.totalPositionAmount, temporaryTotalProperty, temporaryTokenAmount, userCapitalFlowInfo);\\r\\n                }\\r\\n\\r\\n                epochStopLoss[epoch] = true;\\r\\n                currentEpochs += 1;\\r\\n                _refillStock(0);\\r\\n                _refillStock(1);\\r\\n                _refillStock(2);\\r\\n                _refillStock(3);\\r\\n            }\\r\\n\\r\\n            payoutAmount += investReturnAmount;\\r\\n\\r\\n            positionInfo.investReturnAmount = investReturnAmount;\\r\\n        }else{\\r\\n            temporaryTotalMatic = userCapitalFlowInfo.totalPrincipalClaimed + userGlobalInfo.totalReferrerReward + userCapitalFlowInfo.totalRecommendReward + userCapitalFlowInfo.totalExpectedInvestReturnAmount;\\r\\n            temporaryTotalProperty = temporaryTotalMatic + userCapitalFlowInfo.totalConvertTokenAmount;\\r\\n\\r\\n            if(userGlobalInfo.totalPositionAmount > temporaryTotalProperty){\\r\\n                uint256 totalPrincipalAmount = userGlobalInfo.totalPositionAmount * PRINCIPAL_RATIO / PRICE_PRECISION;\\r\\n                if(temporaryTotalMatic < totalPrincipalAmount){\\r\\n                    uint256 totalPrincipalLoss = totalPrincipalAmount - temporaryTotalMatic;\\r\\n                    if(totalPrincipalLoss < principalAmount){\\r\\n                        totalLosePrincipal += principalAmount - totalPrincipalLoss;\\r\\n                        principalAmount = totalPrincipalLoss;\\r\\n                    }\\r\\n                    payoutAmount += principalAmount;\\r\\n                    userCapitalFlowInfo.totalPrincipalClaimed += principalAmount;\\r\\n                }\\r\\n                temporaryTokenAmount = positionInfo.amount - payoutAmount;\\r\\n                temporaryTotalProperty += payoutAmount;\\r\\n                setAssetPackage(userGlobalInfo.totalPositionAmount, temporaryTotalProperty, temporaryTokenAmount, userCapitalFlowInfo);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        userRoundInfo.totalWithdrawnAmount += payoutAmount;\\r\\n        unchecked {\\r\\n            epochCurrentPrincipalAmount[epoch] -= principalAmount;\\r\\n        }\\r\\n\\r\\n        positionInfo.withdrawnAmount = payoutAmount;\\r\\n        positionInfo.removalTime = block.timestamp;\\r\\n\\r\\n        if(payoutAmount > 0){\\r\\n            (bool success, ) = msg.sender.call{value: payoutAmount}(\\\"\\\");\\r\\n            require(success, \\\"Transfer failed.\\\");\\r\\n        }\\r\\n\\r\\n        emit PositionClosed(msg.sender, ledgerType, epoch, positionIndex, payoutAmount);\\r\\n    }\\r\\n\\r\\n    function setAssetPackage(uint256 _otalPositionAmount, uint256 _temporaryTotalProperty, uint256 tokenAmount, UserCapitalFlowInfo storage userCapitalFlowInfo) private {\\r\\n        if(_otalPositionAmount > _temporaryTotalProperty){\\r\\n            uint256 totalTokenAmount = _otalPositionAmount - _temporaryTotalProperty;\\r\\n            if(totalTokenAmount < tokenAmount){\\r\\n                tokenAmount = totalTokenAmount;\\r\\n            }\\r\\n            userCapitalFlowInfo.totalConvertTokenAmount += tokenAmount;\\r\\n            if(tokenAmount > 0){\\r\\n                if(stopLossAmount < 900000000 * ACCURACY){\\r\\n                    uint256 MBSAmount;\\r\\n                    uint8 ratioNum;\\r\\n                    if(stopLossAmount < 200000000 * ACCURACY){\\r\\n                        ratioNum = 0;\\r\\n                    }else if(stopLossAmount < 400000000 * ACCURACY){\\r\\n                        ratioNum = 1;\\r\\n                    }else if(stopLossAmount < 600000000 * ACCURACY){\\r\\n                        ratioNum = 2;\\r\\n                    }else if(stopLossAmount < 800000000 * ACCURACY){\\r\\n                        ratioNum = 3;\\r\\n                    }else{\\r\\n                        ratioNum = 4;\\r\\n                    }\\r\\n                    MBSAmount = tokenAmount * tokenOutputRatio[ratioNum] / PRICE_PRECISION;\\r\\n                    AssetPackage[msg.sender].push(AssetPackageInfo({\\r\\n                        birthday: block.timestamp,\\r\\n                        amount: MBSAmount,\\r\\n                        release: MBSAmount / 300,\\r\\n                        withdrawn: 0,\\r\\n                        state: true\\r\\n                    }));\\r\\n                    stopLossAmount += tokenAmount;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n\\r\\n    }\\r\\n\\r\\n    function _safeProcessSalesLevel(\\r\\n        uint8 currentLevel,\\r\\n        address user,\\r\\n        uint256 currentSales,\\r\\n        UserGlobalInfo storage userGlobalInfo\\r\\n    ) internal returns (uint8) {\\r\\n        uint8 newLevel = _getSalesToLevel(currentSales);\\r\\n        if (newLevel > currentLevel) {\\r\\n            userGlobalInfo.salesLevel = newLevel;\\r\\n            emit SalesLevelUpdated(user, newLevel);\\r\\n        } else {\\r\\n            newLevel = currentLevel;\\r\\n        }\\r\\n        return newLevel;\\r\\n    }\\r\\n\\r\\n    function _distributeReferrerReward(uint256 amountValue, address user, uint256 referrerAmount) internal virtual {\\r\\n        UserGlobalInfo storage userGlobalInfo = userGlobalInfos[user];\\r\\n        UserGlobalInfo storage referrerGlobalInfo;\\r\\n        uint256 positionAmount = amountValue;\\r\\n\\r\\n        ReferrerSearch memory search;\\r\\n        search.baseSalesLevel = 0;\\r\\n        search.currentReferrer = userGlobalInfo.referrer;\\r\\n        search.levelDiffAmount = referrerAmount;\\r\\n        search.leftLevelDiffAmount = search.levelDiffAmount;\\r\\n        search.levelDiffAmountPerLevel = search.levelDiffAmount / 12;\\r\\n        search.currentUserTotalPosAmount = userGlobalInfo.totalPositionAmount + positionAmount;\\r\\n        userGlobalInfo.totalPositionAmount = search.currentUserTotalPosAmount;\\r\\n        search.currentUser = user;\\r\\n\\r\\n        while (search.depth < MAX_SEARCH_DEPTH) {\\r\\n\\r\\n            if (search.currentReferrer == address(0)) {\\r\\n                break;\\r\\n            }\\r\\n\\r\\n            if (search.depth > 0) userGlobalInfo.reportedSales += positionAmount;\\r\\n\\r\\n            search.currentUserSales = userGlobalInfo.sales;\\r\\n            search.currentUserReportedSales = userGlobalInfo.reportedSales;\\r\\n\\r\\n            referrerGlobalInfo = userGlobalInfos[search.currentReferrer];\\r\\n\\r\\n            {\\r\\n                search.currentReferrerSales = referrerGlobalInfo.sales;\\r\\n\\r\\n                search.currentReferrerSales += positionAmount;\\r\\n\\r\\n                if (search.currentUserReportedSales < search.currentUserSales) {\\r\\n\\r\\n                    search.currentReferrerSales += search.currentUserSales - search.currentUserReportedSales;\\r\\n\\r\\n                    userGlobalInfo.reportedSales = search.currentUserSales;\\r\\n                }\\r\\n\\r\\n                referrerGlobalInfo.sales = search.currentReferrerSales;\\r\\n            }\\r\\n\\r\\n            {\\r\\n\\r\\n                search.currentUserSales += search.currentUserTotalPosAmount;\\r\\n\\r\\n                search.currentReferrerMaxChildSales = referrerGlobalInfo.maxChildrenSales;\\r\\n                if (search.currentReferrerMaxChildSales < search.currentUserSales) {\\r\\n\\r\\n                    referrerGlobalInfo.maxChildrenSales = search.currentUserSales;\\r\\n                    search.currentReferrerMaxChildSales = search.currentUserSales;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            search.currentReferrerLevel = _safeProcessSalesLevel(\\r\\n                referrerGlobalInfo.salesLevel,\\r\\n                search.currentReferrer,\\r\\n                search.currentReferrerSales - search.currentReferrerMaxChildSales,\\r\\n                referrerGlobalInfo\\r\\n            );\\r\\n\\r\\n            search.currentReferrerRoundsLength = userRoundsInfos[0][search.currentReferrer].length;\\r\\n            if(search.currentReferrerRoundsLength > 0){\\r\\n                search.currentReferrerNewEpoch = userRoundsInfos[0][search.currentReferrer][search.currentReferrerRoundsLength - 1].epoch;\\r\\n                if (!search.levelDiffDone && search.currentReferrerRoundsLength > 0 && search.currentReferrerNewEpoch >= currentEpochs) {\\r\\n                    if (search.currentReferrerLevel > search.baseSalesLevel) {\\r\\n\\r\\n                        search.currentLevelDiff = search.currentReferrerLevel - search.baseSalesLevel;\\r\\n\\r\\n                        search.baseSalesLevel = search.currentReferrerLevel;\\r\\n\\r\\n                        search.currentReferrerAmount = search.currentLevelDiff * search.levelDiffAmountPerLevel;\\r\\n\\r\\n                        if (search.currentReferrerAmount + PRICE_PRECISION > search.leftLevelDiffAmount) {\\r\\n                            search.currentReferrerAmount = search.leftLevelDiffAmount;\\r\\n                        }\\r\\n\\r\\n                        referrerGlobalInfo.totalReferrerReward += search.currentReferrerAmount;\\r\\n                        emit ReferrerRewardAdded(search.currentReferrer, search.currentReferrerAmount, 0);\\r\\n\\r\\n                        unchecked {\\r\\n                            search.leftLevelDiffAmount -= search.currentReferrerAmount;\\r\\n                        }\\r\\n\\r\\n                        if (search.leftLevelDiffAmount == 0) {\\r\\n                            search.levelDiffDone = true;\\r\\n                        }\\r\\n                    }\\r\\n                }\\r\\n            }\\r\\n\\r\\n            search.currentUser = search.currentReferrer;\\r\\n            search.currentReferrer = referrerGlobalInfo.referrer;\\r\\n\\r\\n            userGlobalInfo = referrerGlobalInfo;\\r\\n            search.currentUserTotalPosAmount = userGlobalInfo.totalPositionAmount;\\r\\n\\r\\n            unchecked {\\r\\n                search.depth += 1;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _getSalesToLevel(uint256 amount) internal view virtual returns (uint8) {\\r\\n        /* istanbul ignore else  */\\r\\n        if (amount < levelSales[0]) {\\r\\n            return 0;\\r\\n        } else if (amount < levelSales[1]) {\\r\\n            return 1;\\r\\n        } else if (amount < levelSales[2]) {\\r\\n            return 2;\\r\\n        } else if (amount < levelSales[3]) {\\r\\n            return 3;\\r\\n        } else if (amount < levelSales[4]) {\\r\\n            return 4;\\r\\n        } else if (amount < levelSales[5]) {\\r\\n            return 5;\\r\\n        } else if (amount < levelSales[6]) {\\r\\n            return 6;\\r\\n        } else if (amount < levelSales[7]) {\\r\\n            return 8;\\r\\n        } else if (amount < levelSales[8]) {\\r\\n            return 10;\\r\\n        }\\r\\n        return 12;\\r\\n    }\\r\\n\\r\\n    function getWithdrawalAmount(\\r\\n        address Addr\\r\\n    ) external view returns (uint256){\\r\\n        AssetPackageInfo[] memory assetPackageArr = AssetPackage[Addr];\\r\\n        uint256 amount;\\r\\n        if(assetPackageArr.length > 0){\\r\\n            for(uint256 i = 0; i < assetPackageArr.length; i++){\\r\\n                AssetPackageInfo memory ap = assetPackageArr[i];\\r\\n                if(ap.withdrawn < ap.amount){\\r\\n                    uint256 dayPassed = (block.timestamp - ap.birthday) / TIME_UNIT;\\r\\n                    uint256 reward = dayPassed * ap.release;\\r\\n                    if ((reward + ap.withdrawn) > ap.amount){\\r\\n                        reward = ap.amount - ap.withdrawn;\\r\\n                    }\\r\\n                    amount += reward;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        return (amount);\\r\\n    }\\r\\n\\r\\n    function withdrawalMBS() external {\\r\\n        AssetPackageInfo[] storage assetPackageArr = AssetPackage[msg.sender];\\r\\n        uint256 amount;\\r\\n        if(assetPackageArr.length > 0){\\r\\n            for(uint256 i = 0; i < assetPackageArr.length; i++){\\r\\n                AssetPackageInfo storage ap = assetPackageArr[i];\\r\\n                if(ap.withdrawn < ap.amount){\\r\\n                    uint256 dayPassed = (block.timestamp - ap.birthday) / TIME_UNIT;\\r\\n                    uint256 reward = dayPassed * ap.release;\\r\\n                    if ((reward + ap.withdrawn) > ap.amount){\\r\\n                        reward = ap.amount - ap.withdrawn;\\r\\n                        ap.state = false;\\r\\n                    }\\r\\n                    ap.birthday += dayPassed * TIME_UNIT;\\r\\n                    amount += reward;\\r\\n                    ap.withdrawn += reward;\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n        if(amount > 0){\\r\\n            IERC20EX(tokenAddress)._mint(msg.sender, amount);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function addLiquitidyWithId(\\r\\n        uint256 tokenAmount,\\r\\n        uint256 maticAmount\\r\\n    ) internal {\\r\\n        (uint amount0, uint amount1) = tokenAddress > maticAddress\\r\\n            ? (maticAmount, tokenAmount)\\r\\n            : (tokenAmount, maticAmount);\\r\\n        positionManager.increaseLiquidity{value: maticAmount}(\\r\\n            INonfungiblePositionManager.IncreaseLiquidityParams({\\r\\n                tokenId: positionId,\\r\\n                amount0Desired: amount0,\\r\\n                amount1Desired: amount1,\\r\\n                amount0Min: 0,\\r\\n                amount1Min: 0,\\r\\n                deadline: block.timestamp\\r\\n            })\\r\\n        );\\r\\n        positionManager.refundETH();\\r\\n    }\\r\\n\\r\\n    function buyBurn(\\r\\n        uint256 amountIn\\r\\n    ) internal {\\r\\n        router.exactInputSingle{value: amountIn}(\\r\\n            IV3SwapRouter.ExactInputSingleParams({\\r\\n                tokenIn: maticAddress,\\r\\n                tokenOut: tokenAddress,\\r\\n                fee: defaultFee,\\r\\n                recipient: address(this),\\r\\n                amountIn: amountIn,\\r\\n                amountOutMinimum: 0,\\r\\n                sqrtPriceLimitX96: 0\\r\\n            })\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _tokenAllocation(IERC20 _ERC20, address _address, uint256 _amount) external {\\r\\n        require(msg.sender == platformAddress, \\\"Only platformAddress\\\");\\r\\n        _ERC20.transfer(_address, _amount);\\r\\n    }\\r\\n\\r\\n    function withdrawEth(address to, uint256 value) external {\\r\\n        require(msg.sender == platformAddress, \\\"Only platformAddress\\\");\\r\\n        payable(to).transfer(value);\\r\\n    }\\r\\n\\r\\n    receive() external payable {}\\r\\n}\"\r\n    },\r\n    \"/contracts/IV3SwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\ninterface IV3SwapRouter  {\\r\\n    struct ExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint24 fee;\\r\\n        address recipient;\\r\\n        uint256 amountIn;\\r\\n        uint256 amountOutMinimum;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\\r\\n}\"\r\n    },\r\n    \"/contracts/INonfungiblePositionManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\ninterface INonfungiblePositionManager\\r\\n{\\r\\n    function positions(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n        uint96 nonce,\\r\\n        address operator,\\r\\n        address token0,\\r\\n        address token1,\\r\\n        uint24 fee,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 liquidity,\\r\\n        uint256 feeGrowthInside0LastX128,\\r\\n        uint256 feeGrowthInside1LastX128,\\r\\n        uint128 tokensOwed0,\\r\\n        uint128 tokensOwed1\\r\\n    );\\r\\n    struct IncreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n        uint128 liquidity,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1\\r\\n    );\\r\\n    function refundETH() external payable;\\r\\n}\\r\\n\"\r\n    },\r\n    \"/contracts/Bucket.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ncontract Bucket {\\r\\n    struct BucketStock {\\r\\n        uint8[] typeDays;\\r\\n        uint16[] stockPrefixSum;\\r\\n        uint16 currentBucketStock;\\r\\n        mapping(uint16 => uint16) ledgerStockIndex;\\r\\n        uint256 stockSize;\\r\\n    }\\r\\n\\r\\n    mapping(uint256 => BucketStock) public ledgerBucketStock;\\r\\n\\r\\n    /**\\r\\n     * @dev set an array of stock for the blind box\\r\\n     */\\r\\n    function _setStock(\\r\\n        uint256 ledgerType,\\r\\n        uint8[] memory typeDays,\\r\\n        uint16[] memory stock\\r\\n    ) internal {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\r\\n        uint16 itemCount = 0;\\r\\n        uint16[] storage stockPrefixSum = bucketStock.stockPrefixSum;\\r\\n        uint8[] storage typeDaysStorage = bucketStock.typeDays;\\r\\n        uint256 stockLength = stock.length;\\r\\n        while (stockPrefixSum.length > 0) {\\r\\n            stockPrefixSum.pop();\\r\\n        }\\r\\n        while (typeDaysStorage.length > 0) {\\r\\n            typeDaysStorage.pop();\\r\\n        }\\r\\n        for (uint16 i = 0; i < stockLength; ++i) {\\r\\n            itemCount += stock[i];\\r\\n            stockPrefixSum.push(itemCount);\\r\\n            typeDaysStorage.push(typeDays[i]);\\r\\n        }\\r\\n        bucketStock.currentBucketStock = itemCount;\\r\\n        bucketStock.stockSize = itemCount;\\r\\n        require(stockPrefixSum.length <= 2e16, \\\"stock length too long\\\");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev refill the stock of the bucket\\r\\n     * @param ledgerType the type of the ledger\\r\\n     */\\r\\n    function _refillStock(uint256 ledgerType) internal {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\r\\n        bucketStock.currentBucketStock = uint16(bucketStock.stockSize);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Buy only one box\\r\\n     */\\r\\n    function _pickDay(uint256 ledgerType, uint256 seed) internal returns (uint16) {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\r\\n        uint16 randIndex = _getRandomIndex(seed, bucketStock.currentBucketStock);\\r\\n        uint16 location = _pickLocation(randIndex, bucketStock);\\r\\n        uint16 category = binarySearch(bucketStock.stockPrefixSum, location);\\r\\n        return bucketStock.typeDays[category];\\r\\n    }\\r\\n\\r\\n    function _pickLocation(uint16 index, BucketStock storage bucketStock) internal returns (uint16) {\\r\\n        uint16 location = bucketStock.ledgerStockIndex[index];\\r\\n        if (location == 0) {\\r\\n            location = index + 1;\\r\\n        }\\r\\n        uint16 lastIndexLocation = bucketStock.ledgerStockIndex[bucketStock.currentBucketStock - 1];\\r\\n\\r\\n        if (lastIndexLocation == 0) {\\r\\n            lastIndexLocation = bucketStock.currentBucketStock;\\r\\n        }\\r\\n        bucketStock.ledgerStockIndex[index] = lastIndexLocation;\\r\\n        bucketStock.currentBucketStock--;\\r\\n        bucketStock.ledgerStockIndex[bucketStock.currentBucketStock] = location;\\r\\n\\r\\n        // refill the bucket\\r\\n        if (bucketStock.currentBucketStock == 0) {\\r\\n            bucketStock.currentBucketStock = uint16(bucketStock.stockSize);\\r\\n        }\\r\\n        return location - 1;\\r\\n    }\\r\\n\\r\\n    function _getRandomIndex(uint256 seed, uint16 size) internal view returns (uint16) {\\r\\n        // NOTICE: We do not to prevent miner from front-running the transaction and the contract.\\r\\n        return\\r\\n            uint16(\\r\\n            uint256(\\r\\n                keccak256(\\r\\n                    abi.encodePacked(\\r\\n                        block.difficulty,\\r\\n                        block.timestamp,\\r\\n                        msg.sender,\\r\\n                        blockhash(block.number - 1),\\r\\n                        seed,\\r\\n                        size\\r\\n                    )\\r\\n                )\\r\\n            ) % size\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getBucketInfo(uint256 ledgerType) external view returns (uint8[] memory, uint16[] memory) {\\r\\n        BucketStock storage bucketStock = ledgerBucketStock[ledgerType];\\r\\n        return (bucketStock.typeDays, bucketStock.stockPrefixSum);\\r\\n    }\\r\\n\\r\\n    function binarySearch(uint16[] storage array, uint16 target) internal view returns (uint16) {\\r\\n        uint256 left = 0;\\r\\n        uint256 right = array.length - 1;\\r\\n        uint256 mid;\\r\\n        while (left < right - 1) {\\r\\n            mid = left + (right - left) / 2;\\r\\n            if (array[mid] > target) {\\r\\n                right = mid;\\r\\n            } else {\\r\\n                left = mid + 1;\\r\\n            }\\r\\n        }\\r\\n        if (target < array[left]) {\\r\\n            return uint16(left);\\r\\n        } else {\\r\\n            return uint16(right);\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        return _status == _ENTERED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_bonusAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_communityAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_platformAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"NewReferrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PositionClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"ledgeType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PositionOpened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"rewardType\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferrerRewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SalesLevelUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"form\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SllocationAmount\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACCURACY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"AssetPackage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"birthday\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"release\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BONUS_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BUYBACK_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"COMMUNITY_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_INVEST_RETURN_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVEST_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SEARCH_DEPTH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_INVEST\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRINCIPAL_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RANKED_INCENTIVE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RECOMMENDREWARD_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRER_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SUPERNODE_RATIO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_UNIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"_ERC20\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"_tokenAllocation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_add\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"addCurrentInvestAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"positionIndexes\",\"type\":\"uint256[]\"}],\"name\":\"batchClosePositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"users\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"referrers\",\"type\":\"address[]\"},{\"internalType\":\"uint8[]\",\"name\":\"salesLevels\",\"type\":\"uint8[]\"},{\"internalType\":\"bool[]\",\"name\":\"supernodes\",\"type\":\"bool[]\"},{\"internalType\":\"address[]\",\"name\":\"supernodeAddresss\",\"type\":\"address[]\"}],\"name\":\"batchSetReferrerInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bonusAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"children\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"claimReferrerReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionIndex\",\"type\":\"uint256\"}],\"name\":\"closePosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"communityAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpochs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochCurrentInvestAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochCurrentPrincipalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"epochStopLoss\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"}],\"name\":\"getBucketInfo\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getChildren\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getChildrenLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getLedgerRoundToUserRoundIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserDepartSalesAndLevel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRoundLedgers\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"removalTime\",\"type\":\"uint256\"}],\"internalType\":\"struct MobiusBand.PositionInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRoundLedgersLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cursor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"getUserRounds\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClosedPositionCount\",\"type\":\"uint256\"}],\"internalType\":\"struct MobiusBand.UserRoundInfo[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserRoundsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"Addr\",\"type\":\"address\"}],\"name\":\"getWithdrawalAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ledgerBucketStock\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"currentBucketStock\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"stockSize\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelSales\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpMaticAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lpMaticLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maticAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"openPosition\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"platformAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundInfos\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"lastCheckTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"achievedAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct MobiusBand.FundTarget\",\"name\":\"fundTarget\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentInvestAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPositionCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"incentiveSnapshot\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"head\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stopLoss\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"roundLedgers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiryTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnRate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"removalTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setStartUseTokenNum\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ledgerType\",\"type\":\"uint256\"},{\"internalType\":\"uint8[]\",\"name\":\"typeDays\",\"type\":\"uint8[]\"},{\"internalType\":\"uint16[]\",\"name\":\"stock\",\"type\":\"uint16[]\"}],\"name\":\"setStock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"setTokenConsumeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setlpMaticLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startUseTokenNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stopLossAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenConsumeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenOutputRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalFlowAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLosePrincipal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_ratio\",\"type\":\"uint256[]\"}],\"name\":\"updateTokenOutputRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userCapitalFlowInfs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalPrincipalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRecommendReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExpectedInvestReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalExpectedInvestRewardAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalConvertTokenAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userGlobalInfos\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalReferrerReward\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerRewardClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxChildrenSales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sales\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reportedSales\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"salesLevel\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"supernode\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"supernodeAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userRoundsInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPositionAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"currentPrincipalAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClosedPositionCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawalMBS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MobiusBand", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c0ea4ed8b368175526b099c25b2ce1cbc9b6fdb300000000000000000000000035ca6f1756eef6ee2233ee0a9e709de7f04d62c7000000000000000000000000ef524c5829212e9391adf72331052ee40deabf34000000000000000000000000e01a8c7fa2940227a0ab0a6438b3823cbdf08ec8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}