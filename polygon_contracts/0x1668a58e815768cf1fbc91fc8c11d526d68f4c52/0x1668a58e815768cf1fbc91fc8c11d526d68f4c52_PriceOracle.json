{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/PriceOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.7.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\\\";\\r\\nimport \\\"./PriceOracleDataTypes.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title PriceOracle\\r\\n * @dev Contract for storing and providing price data for the Orion Protocol\\r\\n * @dev Price oracle gets data from authorized source, store it and gives to Exchange.\\r\\n * @dev Initially there were three possible methods to provide price data\\r\\n        1) signed data by oraclePublicKey\\r\\n        2) data provided by authorized address\\r\\n        3) chainlink\\r\\n        Currently, first option is commented out.\\r\\n * @author @EmelyanenkoK\\r\\n */\\r\\ncontract PriceOracle is Ownable, PriceOracleDataTypes {\\r\\n\\r\\n    // Prices as they got to the contract\\r\\n    struct Prices {\\r\\n        address[] assetAddresses;\\r\\n        uint64[] prices;\\r\\n        uint64 timestamp;\\r\\n        bytes signature;\\r\\n    }\\r\\n\\r\\n    /*bytes32 public constant PRICES_TYPEHASH = keccak256(\\r\\n    /* SignedPriceApproach\\r\\n    bytes32 public constant PRICES_TYPEHASH = keccak256(\\r\\n        abi.encodePacked(\\r\\n            \\\"Prices(address[] assetAddresses,uint64[] prices,uint64 timestamp)\\\"\\r\\n        )\\r\\n    );\\r\\n    */\\r\\n\\r\\n    // SignedPriceApproach, publicKey used to check data authenticity\\r\\n    address public oraclePublicKey;\\r\\n    // Asset related to which prices are determined, ORN in our case\\r\\n    address public baseAsset;\\r\\n    // Storage of prices\\r\\n    mapping(address => PriceDataOut) public assetPrices;\\r\\n    // Mapping of asset/eth chainLink price aggregators\\r\\n    mapping(address => address) public chainLinkETHAggregator;\\r\\n    // Mapping of proceProvider authorization: addresses with true may provide price data\\r\\n    mapping(address => bool) public priceProviderAuthorization;\\r\\n\\r\\n    constructor(address publicKey, address _baseAsset) public {\\r\\n        require((publicKey != address(0)) && (_baseAsset != address(0)), \\\"Wrong constructor params\\\");\\r\\n        oraclePublicKey = publicKey;\\r\\n        baseAsset = _baseAsset;\\r\\n    }\\r\\n\\r\\n    /* SignedPriceApproach\\r\\n    function checkPriceFeedSignature(Prices memory priceFeed) public view returns (bool) {\\r\\n        bytes32 digest = keccak256(\\r\\n            abi.encodePacked(\\r\\n                \\\"\\\\x19\\\\x01\\\",\\r\\n                DOMAIN_SEPARATOR,\\r\\n                getPricesHash(priceFeed)\\r\\n            )\\r\\n        );\\r\\n\\r\\n        if (priceFeed.signature.length != 65) {\\r\\n            revert(\\\"ECDSA: invalid signature length\\\");\\r\\n        }\\r\\n\\r\\n        // Divide the signature in r, s and v variables\\r\\n        bytes32 r;\\r\\n        bytes32 s;\\r\\n        uint8 v;\\r\\n\\r\\n        bytes memory signature = priceFeed.signature;\\r\\n\\r\\n        // ecrecover takes the signature parameters, and the only way to get them\\r\\n        // currently is to use assembly.\\r\\n        // solhint-disable-next-line no-inline-assembly\\r\\n        assembly {\\r\\n            r := mload(add(signature, 0x20))\\r\\n            s := mload(add(signature, 0x40))\\r\\n            v := byte(0, mload(add(signature, 0x60)))\\r\\n        }\\r\\n\\r\\n        if (\\r\\n            uint256(s) >\\r\\n            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0\\r\\n        ) {\\r\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\r\\n        }\\r\\n\\r\\n        if (v != 27 && v != 28) {\\r\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\r\\n        }\\r\\n\\r\\n        return ecrecover(digest, v, r, s) == oraclePublicKey;\\r\\n\\r\\n    }\\r\\n\\r\\n    function provideData(Prices memory priceFeed) public {\\r\\n       require(checkPriceFeedSignature(priceFeed), \\\"Wrong signature\\\");\\r\\n       require(priceFeed.timestamp<block.timestamp+60, \\\"Price data timestamp too far in the future\\\");\\r\\n       for(uint8 i=0; i<priceFeed.assetAddresses.length; i++) {\\r\\n         PriceDataOut storage assetData = assetPrices[priceFeed.assetAddresses[i]];\\r\\n         if(assetData.timestamp<priceFeed.timestamp) {\\r\\n           assetData.price = priceFeed.prices[i];\\r\\n           assetData.timestamp = priceFeed.timestamp;\\r\\n         }\\r\\n       }\\r\\n    }\\r\\n    */\\r\\n\\r\\n    /**\\r\\n     * @dev method to set price data to PriceOracle from one of authorized addresses\\r\\n     * @param priceFeed - set of prices\\r\\n     */\\r\\n    function provideDataAddressAuthorization(Prices memory priceFeed) public {\\r\\n        require(priceProviderAuthorization[msg.sender], \\\"Unauthorized dataprovider\\\");\\r\\n        require(priceFeed.timestamp<block.timestamp+60, \\\"Price data timestamp too far in the future\\\");\\r\\n        for(uint256 i=0; i<priceFeed.assetAddresses.length; i++) {\\r\\n            PriceDataOut storage assetData = assetPrices[priceFeed.assetAddresses[i]];\\r\\n            if(assetData.timestamp<priceFeed.timestamp) {\\r\\n                assetData.price = priceFeed.prices[i];\\r\\n                assetData.timestamp = priceFeed.timestamp;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev price data getter (note prices are relative to basicAsset, ORN)\\r\\n     * @param assetAddresses - set of assets\\r\\n     * @return result PriceDataOut[] - set of prices\\r\\n     */\\r\\n    function givePrices(address[] calldata assetAddresses) external view returns (PriceDataOut[] memory result) {\\r\\n        result = new PriceDataOut[](assetAddresses.length);\\r\\n        for(uint256 i=0; i<assetAddresses.length; i++) {\\r\\n            result[i] = assetPrices[assetAddresses[i]];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* SignedPriceApproach\\r\\n    function getPricesHash(Prices memory priceVector)\\r\\n        public\\r\\n        pure\\r\\n        returns (bytes32)\\r\\n    {\\r\\n        return\\r\\n            keccak256(\\r\\n                abi.encode(\\r\\n                    PRICES_TYPEHASH,\\r\\n                    keccak256(abi.encodePacked(priceVector.assetAddresses)),\\r\\n                    keccak256(abi.encodePacked(priceVector.prices)),\\r\\n                    priceVector.timestamp\\r\\n                )\\r\\n            );\\r\\n    }\\r\\n    */\\r\\n\\r\\n    /**\\r\\n     * @dev Method to request price data from ChainLink aggregator\\r\\n     * @dev note, ORN/ETH prices are requested by default since all other\\r\\n            prices are calculated to ORN using ORN/ETH as base price.\\r\\n            ChainLink aggregator prices should be already known at the moment.\\r\\n     * @param assets - set of assets\\r\\n     */\\r\\n    function getChainLinkPriceData(address[] memory assets) public {\\r\\n        // First request ORN/ETH, save it and then request all other assets to ETH\\r\\n        // and calculate prices to ETH. Since ChainLink doesn't update prices\\r\\n        // if they change less than threshold, regardless of provided Chainlink\\r\\n        // timestamp we treat price as fresh (timestamp=now), but only during first\\r\\n        // 24h. In any case, Chainlink should update price once in a day, even\\r\\n        // if it didn't change; that way if provided price is older than 24h -\\r\\n        // Chainlink aggregator doesn't work and in this case we will not set\\r\\n        // outdated price as fresh.\\r\\n        address baseAggregator = chainLinkETHAggregator[baseAsset];\\r\\n        if(baseAggregator == address(0))\\r\\n            return;\\r\\n        (\\r\\n        uint80 roundID,\\r\\n        int _basePrice,\\r\\n        uint startedAt,\\r\\n        uint timestamp,\\r\\n        uint80 answeredInRound\\r\\n        ) = AggregatorV3Interface(baseAggregator).latestRoundData();\\r\\n        uint now = block.timestamp;\\r\\n        if(now - timestamp < 24 hours) {\\r\\n            timestamp = now;\\r\\n        }\\r\\n        require(_basePrice>=0, \\\"Negative base price is not allowed\\\");\\r\\n        uint basePrice = uint(_basePrice);\\r\\n\\r\\n        //ETH/ORN\\r\\n        PriceDataOut storage baseAssetData = assetPrices[address(0)];\\r\\n        if(baseAssetData.timestamp<timestamp) {\\r\\n            uint price = ( (10**AggregatorV3Interface(baseAggregator).decimals()) *1e8)/basePrice;\\r\\n            require(price<2**64-1, \\\"Too big price\\\");\\r\\n            baseAssetData.price = uint64(price);\\r\\n            baseAssetData.timestamp = uint64(timestamp);\\r\\n        }\\r\\n\\r\\n        // Retrieve */ETH price data for all assets\\r\\n        for(uint256 i=0; i<assets.length; i++) {\\r\\n            address currentAsset = assets[i];\\r\\n            address currentAggregator = chainLinkETHAggregator[currentAsset];\\r\\n            if( currentAggregator == address(0))\\r\\n                continue;\\r\\n            (\\r\\n            uint80 aRoundID,\\r\\n            int _aPrice,\\r\\n            uint aStartedAt,\\r\\n            uint aTimestamp,\\r\\n            uint80 aAnsweredInRound\\r\\n            ) = AggregatorV3Interface(currentAggregator).latestRoundData();\\r\\n            require(_aPrice>=0, \\\"Negative price is not allowed\\\");\\r\\n            if(now - timestamp < 24 hours) {\\r\\n                aTimestamp = now;\\r\\n            }\\r\\n            uint aPrice = uint(_aPrice);\\r\\n            uint newTimestamp = timestamp > aTimestamp? aTimestamp : timestamp;\\r\\n\\r\\n            PriceDataOut storage assetData = assetPrices[currentAsset];\\r\\n            if(assetData.timestamp<newTimestamp) {\\r\\n                uint price = (aPrice *1e8)/basePrice;\\r\\n                require(price<2**64-1, \\\"Too big price\\\");\\r\\n                assetData.price = uint64(price);\\r\\n                assetData.timestamp = uint64(newTimestamp);\\r\\n            }\\r\\n\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Method to update list of ChainLink aggregators\\r\\n     * @param assets - set of assets\\r\\n     * @param aggregatorAddresses - set of AggregatorV3Interface addresses\\r\\n     * List of available aggregators: https://docs.chain.link/docs/ethereum-addresses\\r\\n     */\\r\\n    function setChainLinkAggregators(address[] memory assets, address[] memory aggregatorAddresses) public onlyOwner {\\r\\n        for(uint256 i=0; i<assets.length; i++) {\\r\\n            chainLinkETHAggregator[assets[i]] = aggregatorAddresses[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Method to update list of autorized dataproviders\\r\\n     * @param added - set of addresses for which we allow authorization\\r\\n     * @param removed - set of addresses for which we forbid authorization\\r\\n     */\\r\\n    function changePriceProviderAuthorization(address[] memory added, address[] memory removed) public onlyOwner {\\r\\n        for(uint256 i=0; i<added.length; i++) {\\r\\n            priceProviderAuthorization[added[i]] = true;\\r\\n        }\\r\\n        for(uint256 i=0; i<removed.length; i++) {\\r\\n            priceProviderAuthorization[removed[i]] = false;\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.6/interfaces/AggregatorV3Interface.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.0;\\n\\ninterface AggregatorV3Interface {\\n\\n  function decimals() external view returns (uint8);\\n  function description() external view returns (string memory);\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"contracts/PriceOracleDataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.7.4;\\r\\npragma experimental ABIEncoderV2;\\r\\n\\r\\ninterface PriceOracleDataTypes {\\r\\n    struct PriceDataOut {\\r\\n        uint64 price;\\r\\n        uint64 timestamp;\\r\\n    }\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"publicKey\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_baseAsset\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assetPrices\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chainLinkETHAggregator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"added\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"removed\",\"type\":\"address[]\"}],\"name\":\"changePriceProviderAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"name\":\"getChainLinkPriceData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assetAddresses\",\"type\":\"address[]\"}],\"name\":\"givePrices\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"price\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"}],\"internalType\":\"struct PriceOracleDataTypes.PriceDataOut[]\",\"name\":\"result\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oraclePublicKey\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceProviderAuthorization\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address[]\",\"name\":\"assetAddresses\",\"type\":\"address[]\"},{\"internalType\":\"uint64[]\",\"name\":\"prices\",\"type\":\"uint64[]\"},{\"internalType\":\"uint64\",\"name\":\"timestamp\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct PriceOracle.Prices\",\"name\":\"priceFeed\",\"type\":\"tuple\"}],\"name\":\"provideDataAddressAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"aggregatorAddresses\",\"type\":\"address[]\"}],\"name\":\"setChainLinkAggregators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PriceOracle", "CompilerVersion": "v0.7.4+commit.3f05b770", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c19d917a88e07e5040cd2443fb3a026838c3b8520000000000000000000000004142628ab419fa6312b2f1b1679c97cec6deda96", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}