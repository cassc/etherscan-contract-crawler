{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/SafeOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.7.6;\\n\\nimport '@openzeppelin/contracts/utils/Context.sol';\\n\\n/**\\n * This is a contract copied from 'Ownable.sol'\\n * It has the same fundation of Ownable, besides it accept pendingOwner for mor Safe Use\\n */\\nabstract contract SafeOwnable is Context {\\n    address private _owner;\\n    address private _pendingOwner;\\n\\n    event ChangePendingOwner(address indexed previousPendingOwner, address indexed newPendingOwner);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    constructor (address _ownerAddress) {\\n        if (_ownerAddress == address(0)) {\\n            _ownerAddress = _msgSender();\\n        }\\n        _owner = _ownerAddress;\\n        emit OwnershipTransferred(address(0), _ownerAddress);\\n    }\\n\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    modifier onlyPendingOwner() {\\n        require(pendingOwner() == _msgSender(), \\\"Ownable: caller is not the pendingOwner\\\");\\n        _;\\n    }\\n\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n        if (_pendingOwner != address(0)) {\\n            emit ChangePendingOwner(_pendingOwner, address(0));\\n            _pendingOwner = address(0);\\n        }\\n    }\\n\\n    function setPendingOwner(address pendingOwner_) public virtual onlyOwner {\\n        require(pendingOwner_ != address(0), \\\"Ownable: pendingOwner is the zero address\\\");\\n        emit ChangePendingOwner(_pendingOwner, pendingOwner_);\\n        _pendingOwner = pendingOwner_;\\n    }\\n\\n    function acceptOwner() public virtual onlyPendingOwner {\\n        emit OwnershipTransferred(_owner, _pendingOwner);\\n        _owner = _pendingOwner;\\n        emit ChangePendingOwner(_pendingOwner, address(0));\\n        _pendingOwner = address(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/Exchange.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"../interfaces/IProxyImplementation.sol\\\";\\nimport \\\"../interfaces/ITokenTransferProxy.sol\\\";\\nimport \\\"./ExchangeCore.sol\\\";\\n\\ncontract Exchange is ExchangeCore {\\n\\n    constructor(IProxyFactory _proxyFactory, ITokenTransferProxy _tokenTransferProxy, IERC20 _exchangeToken, address _protocolFeeRecipient) {\\n        proxyFactory = _proxyFactory;\\n        tokenTransferProxy = _tokenTransferProxy;\\n        exchangeToken = _exchangeToken;\\n        protocolFeeRecipient = _protocolFeeRecipient;\\n    }\\n\\n    function approveOrder_ (\\n        address[7] memory addrs,\\n        uint[9] memory uints,\\n        FeeMethod feeMethod,\\n        Side side,\\n        SaleKind saleKind,\\n        IProxyImplementation.HowToCall howToCall,\\n        bytes memory targetdata,\\n        bytes memory replacementPattern,\\n        bytes memory staticExtradata,\\n        bool orderbookInclusionDesired) \\n        external\\n    {\\n        Order memory order = Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], uints[2], uints[3], addrs[3], feeMethod, side, saleKind, addrs[4], howToCall, targetdata, replacementPattern, addrs[5], staticExtradata, IERC20(addrs[6]), uints[4], uints[5], uints[6], uints[7], uints[8]);\\n        return approveOrder(order, orderbookInclusionDesired);\\n    }\\n\\n    function cancelOrder_(\\n        address[7] memory addrs,\\n        uint[9] memory uints,\\n        FeeMethod feeMethod,\\n        Side side,\\n        SaleKind saleKind,\\n        IProxyImplementation.HowToCall howToCall,\\n        bytes memory targetdata,\\n        bytes memory replacementPattern,\\n        bytes memory staticExtradata,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s)\\n        external\\n    {\\n\\n        return cancelOrder(\\n          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], uints[2], uints[3], addrs[3], feeMethod, side, saleKind, addrs[4], howToCall, targetdata, replacementPattern, addrs[5], staticExtradata, IERC20(addrs[6]), uints[4], uints[5], uints[6], uints[7], uints[8]),\\n          Sig(v, r, s)\\n        );\\n    }\\n\\n    function atomicMatch_(\\n        address[14] memory addrs,\\n        uint[18] memory uints,\\n        uint8[8] memory feeMethodsSidesKindsHowToCalls,\\n        bytes memory calldataBuy,\\n        bytes memory calldataSell,\\n        bytes memory replacementPatternBuy,\\n        bytes memory replacementPatternSell,\\n        bytes memory staticExtradataBuy,\\n        bytes memory staticExtradataSell,\\n        uint8[2] memory vs,\\n        bytes32[5] memory rssMetadata)\\n        external\\n        payable\\n    {\\n\\n        return atomicMatch(\\n          Order(addrs[0], addrs[1], addrs[2], uints[0], uints[1], uints[2], uints[3], addrs[3], FeeMethod(feeMethodsSidesKindsHowToCalls[0]), Side(feeMethodsSidesKindsHowToCalls[1]), SaleKind(feeMethodsSidesKindsHowToCalls[2]), addrs[4], IProxyImplementation.HowToCall(feeMethodsSidesKindsHowToCalls[3]), calldataBuy, replacementPatternBuy, addrs[5], staticExtradataBuy, IERC20(addrs[6]), uints[4], uints[5], uints[6], uints[7], uints[8]),\\n          Sig(vs[0], rssMetadata[0], rssMetadata[1]),\\n          Order(addrs[7], addrs[8], addrs[9], uints[9], uints[10], uints[11], uints[12], addrs[10], FeeMethod(feeMethodsSidesKindsHowToCalls[4]), Side(feeMethodsSidesKindsHowToCalls[5]), SaleKind(feeMethodsSidesKindsHowToCalls[6]), addrs[11], IProxyImplementation.HowToCall(feeMethodsSidesKindsHowToCalls[7]), calldataSell, replacementPatternSell, addrs[12], staticExtradataSell, IERC20(addrs[13]), uints[13], uints[14], uints[15], uints[16], uints[17]),\\n          Sig(vs[1], rssMetadata[2], rssMetadata[3]),\\n          rssMetadata[4]\\n        );\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/exchange/ExchangeCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../interfaces/IOwnableDelegateProxy.sol\\\";\\nimport \\\"../interfaces/IProxyImplementation.sol\\\";\\nimport \\\"../interfaces/ITokenTransferProxy.sol\\\";\\nimport \\\"../interfaces/IProxyFactory.sol\\\";\\nimport \\\"../libraries/ArrayUtils.sol\\\";\\nimport \\\"../libraries/Strings.sol\\\";\\nimport \\\"../core/SafeOwnable.sol\\\";\\n\\ncontract ExchangeCore is ReentrancyGuard, SafeOwnable {\\n    using SafeMath for uint;\\n    using Strings for uint;\\n    \\n    event OrderApprovedPartOne(\\n        bytes32 indexed hash, address exchange, address indexed maker, address taker, \\n        uint makerRelayerFee, uint takerRelayerFee, uint makerProtocolFee, uint takerProtocolFee, address indexed feeRecipient, \\n        FeeMethod feeMethod, Side side, SaleKind saleKind, address target\\n    );\\n    event OrderApprovedPartTwo(\\n        bytes32 indexed hash, IProxyImplementation.HowToCall howToCall, bytes targetdata, \\n        bytes replacementPattern, address staticTarget, bytes staticExtradata, IERC20 paymentToken, \\n        uint basePrice, uint extra, uint listingTime, uint expirationTime, uint salt, bool orderbookInclusionDesired\\n    );\\n    event OrderCancelled(bytes32 indexed hash);\\n    event OrdersMatched(bytes32 buyHash, bytes32 sellHash, address indexed maker, address indexed taker, uint price, bytes32 indexed metadata);\\n\\n    IERC20 public exchangeToken;\\n\\n    IProxyFactory public proxyFactory;\\n\\n    ITokenTransferProxy public tokenTransferProxy;\\n\\n    mapping(bytes32 => bool) public cancelledOrFinalized;\\n\\n    mapping(bytes32 => bool) public approvedOrders;\\n\\n    uint public minimumMakerProtocolFee = 0;\\n\\n    uint public minimumTakerProtocolFee = 0;\\n\\n    address public protocolFeeRecipient;\\n\\n    enum FeeMethod { ProtocolFee, SplitFee }\\n\\n    uint public constant INVERSE_BASIS_POINT = 10000;\\n\\n    enum Side { Buy, Sell }\\n\\n    enum SaleKind { FixedPrice, DutchAuction }\\n\\n    constructor() SafeOwnable(msg.sender) {\\n    }\\n\\n    struct Sig {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n    }\\n\\n    struct Order {\\n        address exchange;\\n        address maker;\\n        address taker;\\n        uint makerRelayerFee;\\n        uint takerRelayerFee;\\n        uint makerProtocolFee;\\n        uint takerProtocolFee;\\n        address feeRecipient;\\n        FeeMethod feeMethod;\\n        Side side;\\n        SaleKind saleKind;\\n        address target;\\n        IProxyImplementation.HowToCall howToCall;\\n        bytes targetdata;\\n        bytes replacementPattern;\\n        address staticTarget;\\n        bytes staticExtradata;\\n        IERC20 paymentToken;\\n        uint basePrice;\\n        uint extra;\\n        uint listingTime;\\n        uint expirationTime;\\n        uint salt;\\n    }\\n\\n    function changeMinimumMakerProtocolFee(uint newMinimumMakerProtocolFee)\\n        public\\n        onlyOwner\\n    {\\n        minimumMakerProtocolFee = newMinimumMakerProtocolFee;\\n    }\\n\\n    function changeMinimumTakerProtocolFee(uint newMinimumTakerProtocolFee)\\n        public\\n        onlyOwner\\n    {\\n        minimumTakerProtocolFee = newMinimumTakerProtocolFee;\\n    }\\n\\n    function changeProtocolFeeRecipient(address newProtocolFeeRecipient)\\n        public\\n        onlyOwner\\n    {\\n        protocolFeeRecipient = newProtocolFeeRecipient;\\n    }\\n\\n    function changeExchangeToken(IERC20 newExchangeToken)\\n        public\\n        onlyOwner\\n    {\\n        exchangeToken = newExchangeToken;\\n    }\\n\\n    function transferTokens(IERC20 token, address from, address to, uint amount)\\n        internal\\n    {\\n        if (amount > 0) {\\n            tokenTransferProxy.transferFrom(token, from, to, amount);\\n        }\\n    }\\n\\n    function chargeProtocolFee(address from, address to, uint amount)\\n        internal\\n    {\\n        transferTokens(exchangeToken, from, to, amount);\\n    }\\n\\n    function staticCall(address target, bytes memory data, bytes memory extradata)\\n        public\\n        view\\n        returns (bool result)\\n    {\\n        bytes memory combined = new bytes(data.length + extradata.length);\\n        uint index;\\n        assembly {\\n            index := add(combined, 0x20)\\n        }\\n        index = ArrayUtils.unsafeWriteBytes(index, extradata);\\n        ArrayUtils.unsafeWriteBytes(index, data);\\n        assembly {\\n            result := staticcall(gas(), target, add(combined, 0x20), mload(combined), mload(0x40), 0)\\n        }\\n        return result;\\n    }\\n\\n    function hashOrder(Order memory order)\\n        internal\\n        pure\\n        returns (bytes32 hash)\\n    {\\n        /* Unfortunately abi.encodePacked doesn't work here, stack size constraints. */\\n        uint size = 736;\\n        bytes memory array = new bytes(size);\\n        uint index;\\n        assembly {\\n            index := add(array, 0x20)\\n        }\\n        index = ArrayUtils.unsafeWriteAddressWord(index, order.exchange);\\n        index = ArrayUtils.unsafeWriteAddressWord(index, order.maker);\\n        index = ArrayUtils.unsafeWriteAddressWord(index, order.taker);\\n        index = ArrayUtils.unsafeWriteUint(index, order.makerRelayerFee);\\n        index = ArrayUtils.unsafeWriteUint(index, order.takerRelayerFee);\\n        index = ArrayUtils.unsafeWriteUint(index, order.makerProtocolFee);\\n        index = ArrayUtils.unsafeWriteUint(index, order.takerProtocolFee);\\n        index = ArrayUtils.unsafeWriteAddressWord(index, order.feeRecipient);\\n        index = ArrayUtils.unsafeWriteUint8Word(index, uint8(order.feeMethod));\\n        index = ArrayUtils.unsafeWriteUint8Word(index, uint8(order.side));\\n        index = ArrayUtils.unsafeWriteUint8Word(index, uint8(order.saleKind));\\n        index = ArrayUtils.unsafeWriteAddressWord(index, order.target);\\n        index = ArrayUtils.unsafeWriteUint8Word(index, uint8(order.howToCall));\\n        index = ArrayUtils.unsafeWriteBytes32(index, keccak256(order.targetdata));\\n        index = ArrayUtils.unsafeWriteBytes32(index, keccak256(order.replacementPattern));\\n        index = ArrayUtils.unsafeWriteAddressWord(index, order.staticTarget);\\n        index = ArrayUtils.unsafeWriteBytes32(index, keccak256(order.staticExtradata));\\n        index = ArrayUtils.unsafeWriteAddressWord(index, address(order.paymentToken));\\n        index = ArrayUtils.unsafeWriteUint(index, order.basePrice);\\n        index = ArrayUtils.unsafeWriteUint(index, order.extra);\\n        index = ArrayUtils.unsafeWriteUint(index, order.listingTime);\\n        index = ArrayUtils.unsafeWriteUint(index, order.expirationTime);\\n        index = ArrayUtils.unsafeWriteUint(index, order.salt);\\n        assembly {\\n            hash := keccak256(add(array, 0x20), size)\\n        }\\n        return hash;\\n    }\\n\\n    function hashToSign(Order memory order)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return sha256(abi.encodePacked(\\\"ETHEREUM_CUSTOM_EXTERNAL_SIGN_MSG_PREFIX\\\", uint(hashOrder(order)).toHexString(32)));\\n    }\\n\\n    function requireValidOrder(Order memory order, Sig memory sig)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes32 hash = hashToSign(order);\\n        require(validateOrder(hash, order, sig), \\\"requireValidOrder: 003\\\");\\n        return hash;\\n    }\\n\\n    function validateParameters(SaleKind saleKind, uint expirationTime)\\n        pure\\n        internal\\n        returns (bool)\\n    {\\n        /* Auctions must have a set expiration date. */\\n        return (saleKind == SaleKind.FixedPrice || expirationTime > 0);\\n    }\\n\\n    function validateOrderParameters(Order memory order)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        /* Order must be targeted at this protocol version (this Exchange contract). */\\n        if (order.exchange != address(this)) {\\n            return false;\\n        }\\n        /* Order must possess valid sale kind parameter combination. */\\n        if (!validateParameters(order.saleKind, order.expirationTime)) {\\n            return false;\\n        }\\n\\n        /* If using the split fee method, order must have sufficient protocol fees. */\\n        if (order.feeMethod == FeeMethod.SplitFee && (order.makerProtocolFee < minimumMakerProtocolFee || order.takerProtocolFee < minimumTakerProtocolFee)) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function validateOrder(bytes32 hash, Order memory order, Sig memory sig) \\n        internal\\n        view\\n        returns (bool)\\n    {\\n        /* Not done in an if-conditional to prevent unnecessary ecrecover evaluation, which seems to happen even though it should short-circuit. */\\n        /* Order must have valid parameters. */\\n        if (!validateOrderParameters(order)) {\\n            return false;\\n        }\\n\\n        /* Order must have not been canceled or already filled. */\\n        if (cancelledOrFinalized[hash]) {\\n            return false;\\n        }\\n        \\n        /* Order authentication. Order must be either:\\n        /* (a) previously approved */\\n        if (approvedOrders[hash]) {\\n            return true;\\n        }\\n\\n        /* or (b) ECDSA-signed by maker. */\\n        if (ecrecover(hash, sig.v, sig.r, sig.s) == order.maker) {\\n            return true;\\n        }\\n\\n        return false;\\n    }\\n\\n    function approveOrder(Order memory order, bool orderbookInclusionDesired)\\n        internal\\n    {\\n        /* CHECKS */\\n\\n        /* Assert sender is authorized to approve order. */\\n        require(msg.sender == order.maker);\\n\\n        /* Calculate order hash. */\\n        bytes32 hash = hashToSign(order);\\n\\n        /* Assert order has not already been approved. */\\n        require(!approvedOrders[hash]);\\n\\n        /* EFFECTS */\\n    \\n        /* Mark order as approved. */\\n        approvedOrders[hash] = true;\\n  \\n        /* Log approval event. Must be split in two due to Solidity stack size limitations. */\\n        {\\n            emit OrderApprovedPartOne(hash, order.exchange, order.maker, order.taker, order.makerRelayerFee, order.takerRelayerFee, order.makerProtocolFee, order.takerProtocolFee, order.feeRecipient, order.feeMethod, order.side, order.saleKind, order.target);\\n        }\\n        {   \\n            emit OrderApprovedPartTwo(hash, order.howToCall, order.targetdata, order.replacementPattern, order.staticTarget, order.staticExtradata, order.paymentToken, order.basePrice, order.extra, order.listingTime, order.expirationTime, order.salt, orderbookInclusionDesired);\\n        }\\n    }\\n\\n    function cancelOrder(Order memory order, Sig memory sig) \\n        internal\\n    {\\n        /* CHECKS */\\n\\n        /* Calculate order hash. */\\n        bytes32 hash = requireValidOrder(order, sig);\\n\\n        /* Assert sender is authorized to cancel order. */\\n        require(msg.sender == order.maker);\\n  \\n        /* EFFECTS */\\n      \\n        /* Mark order as cancelled, preventing it from being matched. */\\n        cancelledOrFinalized[hash] = true;\\n\\n        /* Log cancel event. */\\n        emit OrderCancelled(hash);\\n    }\\n\\n    function calculateFinalPrice(Side side, SaleKind saleKind, uint basePrice, uint extra, uint listingTime, uint expirationTime)\\n        view\\n        internal\\n        returns (uint finalPrice)\\n    {\\n        if (saleKind == SaleKind.FixedPrice) {\\n            return basePrice;\\n        } else if (saleKind == SaleKind.DutchAuction) {\\n            uint diff = extra.mul(block.timestamp.sub(listingTime)).div(expirationTime.sub(listingTime));\\n            if (side == Side.Sell) {\\n                /* Sell-side - start price: basePrice. End price: basePrice - extra. */\\n                return basePrice.sub(diff);\\n            } else {\\n                /* Buy-side - start price: basePrice. End price: basePrice + extra. */\\n                return basePrice.add(diff);\\n            }\\n        }\\n    }\\n\\n    function calculateCurrentPrice (Order memory order)\\n        internal  \\n        view\\n        returns (uint)\\n    {\\n        return calculateFinalPrice(order.side, order.saleKind, order.basePrice, order.extra, order.listingTime, order.expirationTime);\\n    }\\n\\n    function calculateMatchPrice(Order memory buy, Order memory sell)\\n        view\\n        internal\\n        returns (uint)\\n    {\\n        /* Calculate sell price. */\\n        uint sellPrice = calculateFinalPrice(sell.side, sell.saleKind, sell.basePrice, sell.extra, sell.listingTime, sell.expirationTime);\\n\\n        /* Calculate buy price. */\\n        uint buyPrice = calculateFinalPrice(buy.side, buy.saleKind, buy.basePrice, buy.extra, buy.listingTime, buy.expirationTime);\\n\\n        /* Require price cross. */\\n        require(buyPrice >= sellPrice, \\\"011\\\");\\n        \\n        /* Maker/taker priority. */\\n        return sell.feeRecipient != address(0) ? sellPrice : buyPrice;\\n    }\\n\\n    function executeFundsTransfer(Order memory buy, Order memory sell)\\n        internal\\n        returns (uint)\\n    {\\n        /* Only payable in the special case of unwrapped Ether. */\\n        if (address(sell.paymentToken) != address(0)) {\\n            require(msg.value == 0, \\\"010\\\");\\n        }\\n\\n        /* Calculate match price. */\\n        uint price = calculateMatchPrice(buy, sell);\\n\\n        /* If paying using a token (not Ether), transfer tokens. This is done prior to fee payments to that a seller will have tokens before being charged fees. */\\n        if (price > 0 && address(sell.paymentToken) != address(0)) {\\n            transferTokens(sell.paymentToken, buy.maker, sell.maker, price);\\n        }\\n\\n        /* Amount that will be received by seller (for Ether). */\\n        uint receiveAmount = price;\\n\\n        /* Amount that must be sent by buyer (for Ether). */\\n        uint requiredAmount = price;\\n\\n        /* Determine maker/taker and charge fees accordingly. */\\n        if (sell.feeRecipient != address(0)) {\\n            /* Sell-side order is maker. */\\n      \\n            /* Assert taker fee is less than or equal to maximum fee specified by buyer. */\\n            require(sell.takerRelayerFee <= buy.takerRelayerFee, \\\"012\\\");\\n\\n            if (sell.feeMethod == FeeMethod.SplitFee) {\\n                /* Assert taker fee is less than or equal to maximum fee specified by buyer. */\\n                require(sell.takerProtocolFee <= buy.takerProtocolFee, \\\"013\\\");\\n\\n                /* Maker fees are deducted from the token amount that the maker receives. Taker fees are extra tokens that must be paid by the taker. */\\n\\n                if (sell.makerRelayerFee > 0) {\\n                    uint makerRelayerFee = sell.makerRelayerFee.mul(price).div(INVERSE_BASIS_POINT);\\n                    if (address(sell.paymentToken) == address(0)) {\\n                        receiveAmount = receiveAmount.sub(makerRelayerFee);\\n                        payable(sell.feeRecipient).transfer(makerRelayerFee);\\n                    } else {\\n                        transferTokens(sell.paymentToken, sell.maker, sell.feeRecipient, makerRelayerFee);\\n                    }\\n                }\\n\\n                if (sell.takerRelayerFee > 0) {\\n                    uint takerRelayerFee = sell.takerRelayerFee.mul(price).div(INVERSE_BASIS_POINT);\\n                    if (address(sell.paymentToken) == address(0)) {\\n                        requiredAmount = requiredAmount.add(takerRelayerFee);\\n                        payable(sell.feeRecipient).transfer(takerRelayerFee);\\n                    } else {\\n                        transferTokens(sell.paymentToken, buy.maker, sell.feeRecipient, takerRelayerFee);\\n                    }\\n                }\\n\\n                if (sell.makerProtocolFee > 0) {\\n                    uint makerProtocolFee = sell.makerProtocolFee.mul(price).div(INVERSE_BASIS_POINT);\\n                    if (address(sell.paymentToken) == address(0)) {\\n                        receiveAmount = receiveAmount.sub(makerProtocolFee);\\n                        payable(protocolFeeRecipient).transfer(makerProtocolFee);\\n                    } else {\\n                        transferTokens(sell.paymentToken, sell.maker, protocolFeeRecipient, makerProtocolFee);\\n                    }\\n                }\\n\\n                if (sell.takerProtocolFee > 0) {\\n                    uint takerProtocolFee = sell.takerProtocolFee.mul(price).div(INVERSE_BASIS_POINT);\\n                    if (address(sell.paymentToken) == address(0)) {\\n                        requiredAmount = requiredAmount.add(takerProtocolFee);\\n                        payable(protocolFeeRecipient).transfer(takerProtocolFee);\\n                    } else {\\n                        transferTokens(sell.paymentToken, buy.maker, protocolFeeRecipient, takerProtocolFee);\\n                    }\\n                }\\n\\n            } else {\\n                /* Charge maker fee to seller. */\\n                chargeProtocolFee(sell.maker, sell.feeRecipient, sell.makerRelayerFee);\\n\\n                /* Charge taker fee to buyer. */\\n                chargeProtocolFee(buy.maker, sell.feeRecipient, sell.takerRelayerFee);\\n            }\\n        } else {\\n            /* Buy-side order is maker. */\\n\\n            /* Assert taker fee is less than or equal to maximum fee specified by seller. */\\n            require(buy.takerRelayerFee <= sell.takerRelayerFee, \\\"014\\\");\\n\\n            if (sell.feeMethod == FeeMethod.SplitFee) {\\n                /* The Exchange does not escrow Ether, so direct Ether can only be used to with sell-side maker / buy-side taker orders. */\\n                require(address(sell.paymentToken) != address(0), \\\"015\\\");\\n\\n                /* Assert taker fee is less than or equal to maximum fee specified by seller. */\\n                require(buy.takerProtocolFee <= sell.takerProtocolFee, \\\"016\\\");\\n\\n                if (buy.makerRelayerFee > 0) {\\n                    uint makerRelayerFee = buy.makerRelayerFee.mul(price).div(INVERSE_BASIS_POINT);\\n                    transferTokens(sell.paymentToken, buy.maker, buy.feeRecipient, makerRelayerFee);\\n                }\\n\\n                if (buy.takerRelayerFee > 0) {\\n                    uint takerRelayerFee = buy.takerRelayerFee.mul(price).div(INVERSE_BASIS_POINT);\\n                    transferTokens(sell.paymentToken, sell.maker, buy.feeRecipient, takerRelayerFee);\\n                }\\n\\n                if (buy.makerProtocolFee > 0) {\\n                    uint makerProtocolFee = buy.makerProtocolFee.mul(price).div(INVERSE_BASIS_POINT);\\n                    transferTokens(sell.paymentToken, buy.maker, protocolFeeRecipient, makerProtocolFee);\\n                }\\n\\n                if (buy.takerProtocolFee > 0) {\\n                    uint takerProtocolFee = buy.takerProtocolFee.mul(price).div(INVERSE_BASIS_POINT);\\n                    transferTokens(sell.paymentToken, sell.maker, protocolFeeRecipient, takerProtocolFee);\\n                }\\n\\n            } else {\\n                /* Charge maker fee to buyer. */\\n                chargeProtocolFee(buy.maker, buy.feeRecipient, buy.makerRelayerFee);\\n      \\n                /* Charge taker fee to seller. */\\n                chargeProtocolFee(sell.maker, buy.feeRecipient, buy.takerRelayerFee);\\n            }\\n        }\\n\\n        if (address(sell.paymentToken) == address(0)) {\\n            /* Special-case Ether, order must be matched by buyer. */\\n            require(msg.value >= requiredAmount, \\\"017\\\");\\n            payable(sell.maker).transfer(receiveAmount);\\n            /* Allow overshoot for variable-price auctions, refund difference. */\\n            uint diff = msg.value.sub(requiredAmount);\\n            if (diff > 0) {\\n                payable(buy.maker).transfer(diff);\\n            }\\n        }\\n\\n        /* This contract should never hold Ether, however, we cannot assert this, since it is impossible to prevent anyone from sending Ether e.g. with selfdestruct. */\\n\\n        return price;\\n    }\\n\\n    function canSettleOrder(uint listingTime, uint expirationTime)\\n        view\\n        internal\\n        returns (bool)\\n    {\\n        return (listingTime < block.timestamp) && (expirationTime == 0 || block.timestamp < expirationTime);\\n    }\\n\\n\\n    function ordersCanMatch(Order memory buy, Order memory sell)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        return (\\n            /* Must be opposite-side. */\\n            (buy.side == Side.Buy && sell.side == Side.Sell) &&     \\n            /* Must use same fee method. */\\n            (buy.feeMethod == sell.feeMethod) &&\\n            /* Must use same payment token. */\\n            (buy.paymentToken == sell.paymentToken) &&\\n            /* Must match maker/taker addresses. */\\n            (sell.taker == address(0) || sell.taker == buy.maker) &&\\n            (buy.taker == address(0) || buy.taker == sell.maker) &&\\n            /* One must be maker and the other must be taker (no bool XOR in Solidity). */\\n            ((sell.feeRecipient == address(0) && buy.feeRecipient != address(0)) || (sell.feeRecipient != address(0) && buy.feeRecipient == address(0))) &&\\n            /* Must match target. */\\n            (buy.target == sell.target) &&\\n            /* Must match howToCall. */\\n            (buy.howToCall == sell.howToCall) &&\\n            /* Buy-side order must be settleable. */\\n            canSettleOrder(buy.listingTime, buy.expirationTime) &&\\n            /* Sell-side order must be settleable. */\\n            canSettleOrder(sell.listingTime, sell.expirationTime)\\n        );\\n    }\\n\\n    function atomicMatch(Order memory buy, Sig memory buySig, Order memory sell, Sig memory sellSig, bytes32 metadata)\\n        internal\\n        nonReentrant\\n    {\\n        /* CHECKS */\\n      \\n        /* Ensure buy order validity and calculate hash if necessary. */\\n        bytes32 buyHash;\\n        if (buy.maker == msg.sender) {\\n            require(validateOrderParameters(buy), \\\"AtomicMatch: validateOrderParameters 001\\\");\\n        } else {\\n            buyHash = requireValidOrder(buy, buySig);\\n        }\\n\\n        /* Ensure sell order validity and calculate hash if necessary. */\\n        bytes32 sellHash;\\n        if (sell.maker == msg.sender) {\\n            require(validateOrderParameters(sell), \\\"AtomicMatch: validateOrderParameters 002\\\");\\n        } else {\\n            sellHash = requireValidOrder(sell, sellSig);\\n        }\\n        \\n        /* Must be matchable. */\\n        require(ordersCanMatch(buy, sell), \\\"AtomicMatch: ordersCanMatch 004\\\");\\n\\n        /* Target must exist (prevent malicious selfdestructs just prior to order settlement). */\\n        uint size;\\n        address target = sell.target;\\n        assembly {\\n            size := extcodesize(target)\\n        }\\n        require(size > 0);\\n      \\n        /* Must match calldata after replacement, if specified. */ \\n        if (buy.replacementPattern.length > 0) {\\n          ArrayUtils.guardedArrayReplace(buy.targetdata, sell.targetdata, buy.replacementPattern);\\n        }\\n        if (sell.replacementPattern.length > 0) {\\n          ArrayUtils.guardedArrayReplace(sell.targetdata, buy.targetdata, sell.replacementPattern);\\n        }\\n        require(ArrayUtils.arrayEq(buy.targetdata, sell.targetdata), \\\"AtomicMatch: arrayEq 007\\\");\\n\\n        /* Retrieve delegateProxy contract. */\\n        IProxyImplementation delegateProxy = proxyFactory.proxies(sell.maker);\\n\\n        /* Proxy must exist. */\\n        require(address(delegateProxy) != address(0), \\\"AtomicMatch: 008\\\");\\n\\n        /* Assert implementation. */\\n        require(IOwnableDelegateProxy(address(delegateProxy)).implementation() == address(proxyFactory.proxyImplementation()), \\\"AtomicMatch: 009\\\");\\n\\n        /* Access the passthrough ProxyImplementation. */\\n        IProxyImplementation proxy = IProxyImplementation(address(delegateProxy));\\n\\n        /* EFFECTS */\\n\\n        /* Mark previously signed or approved orders as finalized. */\\n        if (msg.sender != buy.maker) {\\n            cancelledOrFinalized[buyHash] = true;\\n        }\\n        if (msg.sender != sell.maker) {\\n            cancelledOrFinalized[sellHash] = true;\\n        }\\n\\n        /* INTERACTIONS */\\n\\n        /* Execute funds transfer and pay fees. */\\n        uint price = executeFundsTransfer(buy, sell);\\n\\n        /* Execute specified call through proxy. */\\n        require(proxy.proxy(sell.target, sell.howToCall, sell.targetdata), \\\"018\\\");\\n\\n        /* Static calls are intentionally done after the effectful call so they can check resulting state. */\\n\\n        /* Handle buy-side static call if specified. */\\n        if (buy.staticTarget != address(0)) {\\n            require(staticCall(buy.staticTarget, sell.targetdata, buy.staticExtradata), \\\"019\\\");\\n        }\\n\\n        /* Handle sell-side static call if specified. */\\n        if (sell.staticTarget != address(0)) {\\n            require(staticCall(sell.staticTarget, sell.targetdata, sell.staticExtradata), \\\"020\\\");\\n        }\\n\\n        /* Log match event. */\\n        emit OrdersMatched(buyHash, sellHash, sell.feeRecipient != address(0) ? sell.maker : buy.maker, sell.feeRecipient != address(0) ? buy.maker : sell.maker, price, metadata);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IOwnableDelegateProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport './IProxyImplementation.sol';\\n\\ninterface IOwnableDelegateProxy {\\n\\n    function initialize (IProxyImplementation _impl, address _user, address _factory) external;\\n\\n    function implementation() external view returns(address);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProxyFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport './IProxyImplementation.sol';\\n\\ninterface IProxyFactory {\\n\\n    function contracts(address _caller) external returns (bool);\\n\\n    function registerProxy() external returns (address);\\n\\n    function proxies(address user) external returns (IProxyImplementation);\\n\\n    function proxyImplementation() external returns (IProxyImplementation);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IProxyImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\ninterface IProxyImplementation {\\n\\n    enum HowToCall { Call, DelegateCall }\\n\\n    function proxy(address dest, HowToCall howToCall, bytes memory data) external returns (bool result);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ITokenTransferProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ITokenTransferProxy {\\n\\n    function transferFrom(IERC20 _token, address _from, address _to, uint _amount) external returns (bool);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/ArrayUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.7.6;\\n\\nlibrary ArrayUtils {\\n\\n    /*\\n     * Replace bytes in an array with bytes in another array, guarded by a bitmask\\n     * Efficiency of this function is a bit unpredictable because of the EVM's word-specific model (arrays under 32 bytes will be slower)\\n     * \\n     * @dev Mask must be the size of the byte array. A nonzero byte means the byte array can be changed.\\n     * @param array The original array\\n     * @param desired The target array\\n     * @param mask The mask specifying which bits can be changed\\n     * @return The updated byte array (the parameter will be modified inplace)\\n     */\\n    function guardedArrayReplace(bytes memory array, bytes memory desired, bytes memory mask)\\n        internal\\n        pure\\n    {\\n        require(array.length == desired.length);\\n        require(array.length == mask.length);\\n\\n        uint words = array.length / 0x20;\\n        uint index = words * 0x20;\\n        assert(index / 0x20 == words);\\n        uint i;\\n\\n        for (i = 0; i < words; i++) {\\n            /* Conceptually: array[i] = (!mask[i] && array[i]) || (mask[i] && desired[i]), bitwise in word chunks. */\\n            assembly {\\n                let commonIndex := mul(0x20, add(1, i))\\n                let maskValue := mload(add(mask, commonIndex))\\n                mstore(add(array, commonIndex), or(and(not(maskValue), mload(add(array, commonIndex))), and(maskValue, mload(add(desired, commonIndex)))))\\n            }\\n        }\\n\\n        /* Deal with the last section of the byte array. */\\n        if (words > 0) {\\n            /* This overlaps with bytes already set but is still more efficient than iterating through each of the remaining bytes individually. */\\n            i = words;\\n            assembly {\\n                let commonIndex := mul(0x20, add(1, i))\\n                let maskValue := mload(add(mask, commonIndex))\\n                mstore(add(array, commonIndex), or(and(not(maskValue), mload(add(array, commonIndex))), and(maskValue, mload(add(desired, commonIndex)))))\\n            }\\n        } else {\\n            /* If the byte array is shorter than a word, we must unfortunately do the whole thing bytewise.\\n               (bounds checks could still probably be optimized away in assembly, but this is a rare case) */\\n            for (i = index; i < array.length; i++) {\\n                array[i] = ((mask[i] ^ 0xff) & array[i]) | (mask[i] & desired[i]);\\n            }\\n        }\\n    }\\n\\n    /*\\n     * Test if two arrays are equal\\n     * Source: https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\\n     * \\n     * @dev Arrays must be of equal length, otherwise will return false\\n     * @param a First array\\n     * @param b Second array\\n     * @return Whether or not all bytes in the arrays are equal\\n     */\\n    function arrayEq(bytes memory a, bytes memory b)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(a)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(b))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(a, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(b, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    /*\\n     * Unsafe write byte array into a memory location\\n     *\\n     * @param index Memory location\\n     * @param source Byte array to write\\n     * @return End memory index\\n     */\\n    function unsafeWriteBytes(uint index, bytes memory source)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        if (source.length > 0) {\\n            assembly {\\n                let length := mload(source)\\n                let end := add(source, add(0x20, length))\\n                let arrIndex := add(source, 0x20)\\n                let tempIndex := index\\n                for { } eq(lt(arrIndex, end), 1) {\\n                    arrIndex := add(arrIndex, 0x20)\\n                    tempIndex := add(tempIndex, 0x20)\\n                } {\\n                    mstore(tempIndex, mload(arrIndex))\\n                }\\n                index := add(index, length)\\n            }\\n        }\\n        return index;\\n    }\\n\\n    /*\\n     * Unsafe write address into a memory location\\n     *\\n     * @param index Memory location\\n     * @param source Address to write\\n     * @return End memory index\\n     */\\n    function unsafeWriteAddress(uint index, address source)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        uint conv = uint(source) << 0x60;\\n        assembly {\\n            mstore(index, conv)\\n            index := add(index, 0x14)\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Unsafe write address into a memory location using entire word\\n     *\\n     * @param index Memory location\\n     * @param source uint to write\\n     * @return End memory index\\n     */\\n    function unsafeWriteAddressWord(uint index, address source)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        assembly {\\n            mstore(index, source)\\n            index := add(index, 0x20)\\n        }\\n        return index;\\n    }\\n\\n    /*\\n     * Unsafe write uint into a memory location\\n     *\\n     * @param index Memory location\\n     * @param source uint to write\\n     * @return End memory index\\n     */\\n    function unsafeWriteUint(uint index, uint source)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        assembly {\\n            mstore(index, source)\\n            index := add(index, 0x20)\\n        }\\n        return index;\\n    }\\n\\n    /*\\n     * Unsafe write uint8 into a memory location\\n     *\\n     * @param index Memory location\\n     * @param source uint8 to write\\n     * @return End memory index\\n     */\\n    function unsafeWriteUint8(uint index, uint8 source)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        assembly {\\n            mstore8(index, source)\\n            index := add(index, 0x1)\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Unsafe write uint8 into a memory location using entire word\\n     *\\n     * @param index Memory location\\n     * @param source uint to write\\n     * @return End memory index\\n     */\\n    function unsafeWriteUint8Word(uint index, uint8 source)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        assembly {\\n            mstore(index, source)\\n            index := add(index, 0x20)\\n        }\\n        return index;\\n    }\\n\\n    /**\\n     * Unsafe write bytes32 into a memory location using entire word\\n     *\\n     * @param index Memory location\\n     * @param source uint to write\\n     * @return End memory index\\n     */\\n    function unsafeWriteBytes32(uint index, bytes32 source)\\n        internal\\n        pure\\n        returns (uint)\\n    {\\n        assembly {\\n            mstore(index, source)\\n            index := add(index, 0x20)\\n        }\\n        return index;\\n    }\\n}\\n\\ncontract ReentrancyGuarded {\\n\\n    bool reentrancyLock = false;\\n\\n    /* Prevent a contract function from being reentrant-called. */\\n    modifier reentrancyGuard {\\n        if (reentrancyLock) {\\n            revert();\\n        }\\n        reentrancyLock = true;\\n        _;\\n        reentrancyLock = false;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.7.6;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    function toHexStringWithoutPrefix(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length);\\n        for (uint256 i = 2 * length; i > 0; --i) {\\n            buffer[i-1] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IProxyFactory\",\"name\":\"_proxyFactory\",\"type\":\"address\"},{\"internalType\":\"contract ITokenTransferProxy\",\"name\":\"_tokenTransferProxy\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_exchangeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_protocolFeeRecipient\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousPendingOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newPendingOwner\",\"type\":\"address\"}],\"name\":\"ChangePendingOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerRelayerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerRelayerFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"makerProtocolFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"takerProtocolFee\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feeRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"enum ExchangeCore.FeeMethod\",\"name\":\"feeMethod\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum ExchangeCore.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum ExchangeCore.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"OrderApprovedPartOne\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"enum IProxyImplementation.HowToCall\",\"name\":\"howToCall\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"targetdata\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staticTarget\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"contract IERC20\",\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"basePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extra\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"listingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"orderbookInclusionDesired\",\"type\":\"bool\"}],\"name\":\"OrderApprovedPartTwo\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"buyHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sellHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"taker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"metadata\",\"type\":\"bytes32\"}],\"name\":\"OrdersMatched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INVERSE_BASIS_POINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[7]\",\"name\":\"addrs\",\"type\":\"address[7]\"},{\"internalType\":\"uint256[9]\",\"name\":\"uints\",\"type\":\"uint256[9]\"},{\"internalType\":\"enum ExchangeCore.FeeMethod\",\"name\":\"feeMethod\",\"type\":\"uint8\"},{\"internalType\":\"enum ExchangeCore.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"enum ExchangeCore.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"internalType\":\"enum IProxyImplementation.HowToCall\",\"name\":\"howToCall\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"targetdata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"orderbookInclusionDesired\",\"type\":\"bool\"}],\"name\":\"approveOrder_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"approvedOrders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[14]\",\"name\":\"addrs\",\"type\":\"address[14]\"},{\"internalType\":\"uint256[18]\",\"name\":\"uints\",\"type\":\"uint256[18]\"},{\"internalType\":\"uint8[8]\",\"name\":\"feeMethodsSidesKindsHowToCalls\",\"type\":\"uint8[8]\"},{\"internalType\":\"bytes\",\"name\":\"calldataBuy\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"calldataSell\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"replacementPatternBuy\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"replacementPatternSell\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradataBuy\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradataSell\",\"type\":\"bytes\"},{\"internalType\":\"uint8[2]\",\"name\":\"vs\",\"type\":\"uint8[2]\"},{\"internalType\":\"bytes32[5]\",\"name\":\"rssMetadata\",\"type\":\"bytes32[5]\"}],\"name\":\"atomicMatch_\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[7]\",\"name\":\"addrs\",\"type\":\"address[7]\"},{\"internalType\":\"uint256[9]\",\"name\":\"uints\",\"type\":\"uint256[9]\"},{\"internalType\":\"enum ExchangeCore.FeeMethod\",\"name\":\"feeMethod\",\"type\":\"uint8\"},{\"internalType\":\"enum ExchangeCore.Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"enum ExchangeCore.SaleKind\",\"name\":\"saleKind\",\"type\":\"uint8\"},{\"internalType\":\"enum IProxyImplementation.HowToCall\",\"name\":\"howToCall\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"targetdata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"replacementPattern\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"staticExtradata\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"cancelOrder_\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"cancelledOrFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"newExchangeToken\",\"type\":\"address\"}],\"name\":\"changeExchangeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimumMakerProtocolFee\",\"type\":\"uint256\"}],\"name\":\"changeMinimumMakerProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMinimumTakerProtocolFee\",\"type\":\"uint256\"}],\"name\":\"changeMinimumTakerProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newProtocolFeeRecipient\",\"type\":\"address\"}],\"name\":\"changeProtocolFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumMakerProtocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumTakerProtocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyFactory\",\"outputs\":[{\"internalType\":\"contract IProxyFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pendingOwner_\",\"type\":\"address\"}],\"name\":\"setPendingOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extradata\",\"type\":\"bytes\"}],\"name\":\"staticCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenTransferProxy\",\"outputs\":[{\"internalType\":\"contract ITokenTransferProxy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Exchange", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004435c68a3f365ae53ded7dd63a825fb4e0297876000000000000000000000000deb7db8fc4c55202c7f4ce15ec50a034b42cb00b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000007a06a8389be01a7eaf5b72a7ae390764ba35034b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}