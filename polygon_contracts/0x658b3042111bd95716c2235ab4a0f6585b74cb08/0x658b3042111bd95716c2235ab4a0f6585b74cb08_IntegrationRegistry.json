{"SourceCode": "/*\r\n    Copyright 2020 Set Labs Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n    SPDX-License-Identifier: Apache-2.0\r\n*/\r\n\r\npragma solidity 0.8.21;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership} and {acceptOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available all functions\r\n * from parent (Ownable).\r\n */\r\nabstract contract Ownable2Step is Ownable {\r\n    address private _pendingOwner;\r\n\r\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the pending owner.\r\n     */\r\n    function pendingOwner() public view virtual returns (address) {\r\n        return _pendingOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\r\n        _pendingOwner = newOwner;\r\n        emit OwnershipTransferStarted(owner(), newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual override {\r\n        delete _pendingOwner;\r\n        super._transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev The new owner accepts the ownership transfer.\r\n     */\r\n    function acceptOwnership() public virtual {\r\n        address sender = _msgSender();\r\n        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");\r\n        _transferOwnership(sender);\r\n    }\r\n}\r\n\r\ninterface IIntegrationRegistry {\r\n\r\n   /* ============ Custom Errors ============ */\r\n\r\n    /// @notice Emitted when an adapter already exists on the IntegrationRegistry.\r\n    error IntegrationRegistry__IntegrationExists();\r\n    /// @notice Emitted when an adapter does not exist on the IntegrationRegistry.\r\n    error IntegrationRegistry__IntegrationInvalid();\r\n    /// @notice Emitted when a module is not enabled on the Controller.\r\n    error IntegrationRegistry__ModuleInvalid();\r\n    /// @notice Emitted when the modules and adapters length mismatch.\r\n    error IntegrationRegistry__ModulesAdaptersLengthMismatch(uint256 numModules, uint256 numAdapters);\r\n    /// @notice Emitted when the modules length is zero.\r\n    error IntegrationRegistry__ModulesEmpty();\r\n    /// @notice Emitted when the modules and names length mismatch.\r\n    error IntegrationRegistry__ModulesNamesLengthMismatch(uint256 numModules, uint256 numNames);\r\n    /// @notice Emitted when a zero address is provided.\r\n    error IntegrationRegistry__ZeroAddress();\r\n\r\n   /* ============ Functions ============ */\r\n    \r\n    function addIntegration(address _module, string memory _id, address _wrapper) external;\r\n    function getIntegrationAdapter(address _module, string memory _id) external view returns(address);\r\n    function getIntegrationAdapterWithHash(address _module, bytes32 _id) external view returns(address);\r\n    function isValidIntegration(address _module, string memory _id) external view returns(bool);\r\n}\r\n\r\ninterface IController {\r\n    \r\n   /* ============ Custom Errors ============ */\r\n    \r\n    /// @notice Emitted when the number of resources and resourceIds mismatch.\r\n    error Controller__ArrayLengthMismatch(uint256 resourcesLength, uint256 resourcesIdsLength);\r\n    /// @notice Emitted when the caller is not a factory.\r\n    error Controller__CallerNotFactory(address caller);\r\n    /// @notice Emitted when a factory already exists on the Controller.\r\n    error Controller__FactoryExists();\r\n    /// @notice Emitted when a factory does not exist on the Controller.\r\n    error Controller__FactoryInvalid();\r\n    /// @notice Emitted when a fee type already exists on the Controller.\r\n    error Controller__FeeTypeExists();\r\n    /// @notice Emitted when a fee type does not exist on the Controller.\r\n    error Controller__FeeTypeInvalid();\r\n    /// @notice Emitted when the Controller is already initialized.\r\n    error Controller__IsInitialized();\r\n    /// @notice Emitted when a module is already enabled on the Controller.\r\n    error Controller__ModuleExists();\r\n    /// @notice Emitted when a module is not enabled on the Controller.\r\n    error Controller__ModuleInvalid();\r\n    /// @notice Emitted when a resource or resourceId is already enabled on the Controller.\r\n    error Controller__ResourceExists();\r\n    /// @notice Emitted when a resource is not enabled on the Controller.\r\n    error Controller__ResourceInvalid();\r\n    /// @notice Emitted when a SetToken is already enabled on the Controller. \r\n    error Controller__SetExists();\r\n    /// @notice Emitted when a SetToken is not enabled on the Controller.\r\n    error Controller__SetInvalid();\r\n    /// @notice Emitted when the Controller is not initialized.\r\n    error Controller__Uninitialized();\r\n    /// @notice Emitted when a zero address is provided.\r\n    error Controller__ZeroAddress();\r\n\r\n   /* ============ Functions ============ */\r\n\r\n    function addSet(address _setToken) external;\r\n    function feeRecipient() external view returns(address);\r\n    function getModuleFee(address _module, uint256 _feeType) external view returns(uint256);\r\n    function isModule(address _module) external view returns(bool);\r\n    function isSet(address _setToken) external view returns(bool);\r\n    function isSystemContract(address _contractAddress) external view returns (bool);\r\n    function resourceId(uint256 _id) external view returns(address);\r\n}\r\n\r\n/**\r\n * @title IntegrationRegistry\r\n * @author Set Protocol\r\n *\r\n * The IntegrationRegistry holds state relating to the Modules and the integrations they are connected with.\r\n * The state is combined into a single Registry to allow governance updates to be aggregated to one contract.\r\n *\r\n * CHANGELOG\r\n * - 9/13/23: Switch from Ownable to Ownable2Step\r\n * - 9/18/23: Upgrade to Solidity 0.8.21\r\n * - 9/26/23: Added custom errors\r\n */\r\ncontract IntegrationRegistry is IIntegrationRegistry, Ownable2Step {\r\n\r\n    /* ============ Events ============ */\r\n\r\n    event IntegrationAdded(address indexed _module, address indexed _adapter, string _integrationName);\r\n    event IntegrationRemoved(address indexed _module, address indexed _adapter, string _integrationName);\r\n    event IntegrationEdited(\r\n        address indexed _module,\r\n        address _newAdapter,\r\n        string _integrationName\r\n    );\r\n\r\n    /* ============ State Variables ============ */\r\n\r\n    // Address of the Controller contract\r\n    IController public immutable CONTROLLER;\r\n\r\n    // Mapping of module => integration identifier => adapter address\r\n    mapping(address => mapping(bytes32 => address)) private integrations;\r\n\r\n    /* ============ Constructor ============ */\r\n\r\n    /**\r\n     * Initializes the Controller\r\n     *\r\n     * @param _controller          Instance of the Controller\r\n     */\r\n    constructor(IController _controller) {\r\n        CONTROLLER = _controller;\r\n    }\r\n\r\n    /* ============ External Functions ============ */\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Add a new integration to the registry\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable string identifying the integration\r\n     * @param  _adapter      Address of the adapter contract to add\r\n     */\r\n    function addIntegration(\r\n        address _module,\r\n        string memory _name,\r\n        address _adapter\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        if (_adapter == address(0)) revert IntegrationRegistry__ZeroAddress();\r\n        if (!CONTROLLER.isModule(_module)) revert IntegrationRegistry__ModuleInvalid();\r\n        \r\n        bytes32 hashedName = _nameHash(_name);\r\n        if (integrations[_module][hashedName] != address(0)) revert IntegrationRegistry__IntegrationExists();\r\n\r\n        integrations[_module][hashedName] = _adapter;\r\n\r\n        emit IntegrationAdded(_module, _adapter, _name);\r\n    }\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Batch add new adapters. Reverts if exists on any module and name\r\n     *\r\n     * @param  _modules      Array of addresses of the modules associated with integration\r\n     * @param  _names        Array of human readable strings identifying the integration\r\n     * @param  _adapters     Array of addresses of the adapter contracts to add\r\n     */\r\n    function batchAddIntegration(\r\n        address[] memory _modules,\r\n        string[] memory _names,\r\n        address[] memory _adapters\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        // Storing modules count to local variable to save on invocation\r\n        uint256 modulesCount = _modules.length;\r\n\r\n        if (modulesCount == 0) revert IntegrationRegistry__ModulesEmpty();\r\n        uint256 namesLength = _names.length;\r\n        if (modulesCount != namesLength) revert IntegrationRegistry__ModulesNamesLengthMismatch(modulesCount, namesLength);\r\n        uint256 adaptersLength = _adapters.length;\r\n        if (modulesCount != adaptersLength) revert IntegrationRegistry__ModulesAdaptersLengthMismatch(modulesCount, adaptersLength);\r\n\r\n        for (uint256 i; i < modulesCount; ) {\r\n            // Add integrations to the specified module. Will revert if module and name combination exists\r\n            addIntegration(\r\n                _modules[i],\r\n                _names[i],\r\n                _adapters[i]\r\n            );\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Edit an existing integration on the registry\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable string identifying the integration\r\n     * @param  _adapter      Address of the adapter contract to edit\r\n     */\r\n    function editIntegration(\r\n        address _module,\r\n        string memory _name,\r\n        address _adapter\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        bytes32 hashedName = _nameHash(_name);\r\n\r\n        if (_adapter == address(0)) revert IntegrationRegistry__ZeroAddress();\r\n        if (!CONTROLLER.isModule(_module)) revert IntegrationRegistry__ModuleInvalid();\r\n        if (integrations[_module][hashedName] == address(0)) revert IntegrationRegistry__IntegrationInvalid();\r\n\r\n        integrations[_module][hashedName] = _adapter;\r\n\r\n        emit IntegrationEdited(_module, _adapter, _name);\r\n    }\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Batch edit adapters for modules. Reverts if module and\r\n     * adapter name don't map to an adapter address\r\n     *\r\n     * @param  _modules      Array of addresses of the modules associated with integration\r\n     * @param  _names        Array of human readable strings identifying the integration\r\n     * @param  _adapters     Array of addresses of the adapter contracts to add\r\n     */\r\n    function batchEditIntegration(\r\n        address[] memory _modules,\r\n        string[] memory _names,\r\n        address[] memory _adapters\r\n    )\r\n        external\r\n        onlyOwner\r\n    {\r\n        // Storing name count to local variable to save on invocation\r\n        uint256 modulesCount = _modules.length;\r\n\r\n        if (modulesCount == 0) revert IntegrationRegistry__ModulesEmpty();\r\n        uint256 namesLength = _names.length;\r\n        if (modulesCount != namesLength) revert IntegrationRegistry__ModulesNamesLengthMismatch(modulesCount, namesLength);\r\n        uint256 adaptersLength = _adapters.length;\r\n        if (modulesCount != adaptersLength) revert IntegrationRegistry__ModulesAdaptersLengthMismatch(modulesCount, adaptersLength);\r\n\r\n        for (uint256 i; i < modulesCount; ) {\r\n            // Edits integrations to the specified module. Will revert if module and name combination does not exist\r\n            editIntegration(\r\n                _modules[i],\r\n                _names[i],\r\n                _adapters[i]\r\n            );\r\n            unchecked { ++i; }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * GOVERNANCE FUNCTION: Remove an existing integration on the registry\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable string identifying the integration\r\n     */\r\n    function removeIntegration(address _module, string memory _name) external onlyOwner {\r\n        bytes32 hashedName = _nameHash(_name);\r\n        if (integrations[_module][hashedName] == address(0)) revert IntegrationRegistry__IntegrationInvalid();\r\n\r\n        address oldAdapter = integrations[_module][hashedName];\r\n        delete integrations[_module][hashedName];\r\n\r\n        emit IntegrationRemoved(_module, oldAdapter, _name);\r\n    }\r\n\r\n    /* ============ External Getter Functions ============ */\r\n\r\n    /**\r\n     * Get integration adapter address associated with passed human readable name\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable adapter name\r\n     *\r\n     * @return               Address of adapter\r\n     */\r\n    function getIntegrationAdapter(address _module, string memory _name) external view returns (address) {\r\n        return integrations[_module][_nameHash(_name)];\r\n    }\r\n\r\n    /**\r\n     * Get integration adapter address associated with passed hashed name\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _adapterNameHash     Hash of human readable adapter name\r\n     *\r\n     * @return               Address of adapter\r\n     */\r\n    function getIntegrationAdapterWithHash(address _module, bytes32 _adapterNameHash) external view returns (address) {\r\n        return integrations[_module][_adapterNameHash];\r\n    }\r\n\r\n    /**\r\n     * Check if adapter name is valid\r\n     *\r\n     * @param  _module       The address of the module associated with the integration\r\n     * @param  _name         Human readable string identifying the integration\r\n     *\r\n     * @return               Boolean indicating if valid\r\n     */\r\n    function isValidIntegration(address _module, string memory _name) external view returns (bool) {\r\n        return integrations[_module][_nameHash(_name)] != address(0);\r\n    }\r\n\r\n    /* ============ Internal Functions ============ */\r\n\r\n    /**\r\n     * Hashes the string and returns a bytes32 value\r\n     */\r\n    function _nameHash(string memory _name) internal pure returns(bytes32) {\r\n        return keccak256(bytes(_name));\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IController\",\"name\":\"_controller\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IntegrationRegistry__IntegrationExists\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IntegrationRegistry__IntegrationInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IntegrationRegistry__ModuleInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numModules\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numAdapters\",\"type\":\"uint256\"}],\"name\":\"IntegrationRegistry__ModulesAdaptersLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IntegrationRegistry__ModulesEmpty\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"numModules\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numNames\",\"type\":\"uint256\"}],\"name\":\"IntegrationRegistry__ModulesNamesLengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IntegrationRegistry__ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newAdapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationEdited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"_integrationName\",\"type\":\"string\"}],\"name\":\"IntegrationRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CONTROLLER\",\"outputs\":[{\"internalType\":\"contract IController\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"addIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_adapters\",\"type\":\"address[]\"}],\"name\":\"batchAddIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_modules\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"_names\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"_adapters\",\"type\":\"address[]\"}],\"name\":\"batchEditIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_adapter\",\"type\":\"address\"}],\"name\":\"editIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"getIntegrationAdapter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_adapterNameHash\",\"type\":\"bytes32\"}],\"name\":\"getIntegrationAdapterWithHash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"isValidIntegration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_module\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"removeIntegration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IntegrationRegistry", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000074e49adcbd36984b31b1438077d5bcbe94a628f9", "EVMVersion": "paris", "Library": "", "LicenseType": "Apache-2.0", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a04e122a60e1ddc3339654a4a44714ae33d7282f38f780f18f0509ea98c12d8f"}