{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/cygnus-token/interfaces/core/ICygnusTerminal.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  ICygnusTerminal.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\n// Dependencies\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\n\\n/**\\n *  @title ICygnusTerminal\\n *  @notice The interface to mint/redeem pool tokens (CygLP and CygUSD)\\n */\\ninterface ICygnusTerminal is IERC20Permit {\\n\\n    /**\\n     *  @notice Redeems the specified amount of `shares` for the underlying asset and transfers it to `recipient`.\\n     *\\n     *  @dev shares must be greater than 0.\\n     *  @dev If the function is called by someone other than `owner`, then the function will reduce the allowance\\n     *       granted to the caller by `shares`.\\n     *\\n     *  @param shares The number of shares to redeem for the underlying asset.\\n     *  @param recipient The address that will receive the underlying asset.\\n     *  @param owner The address that owns the shares.\\n     *\\n     *  @return assets The amount of underlying assets received by the `recipient`.\\n     */\\n    function redeem(uint256 shares, address recipient, address owner) external returns (uint256 assets);\\n\\n    /**\\n     *  @notice Exchange Rate between the pool token and the asset\\n     */\\n    function exchangeRate() external view returns (uint256);\\n\\n    /**\\n     *  @notice The lending pool ID (shared by borrowable/collateral)\\n     */\\n    function shuttleId() external view returns (uint256);\\n\\n    /**\\n     *  @notice Get the collateral address from the borrowable\\n     */\\n    function collateral() external view returns (address);\\n\\n    /**\\n     *  @notice Get the borrowable address from the collateral\\n     */\\n    function borrowable() external view returns (address);\\n\\n    /**\\n     *  @notice Syncs the totalBalance in terms of its underlying (accrues interest in borrowable)\\n     */\\n    function sync() external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/interfaces/core/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\npragma solidity >=0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    // Mint\\n    function mint(address, uint256) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/interfaces/core/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\npragma solidity >=0.8.17;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/interfaces/core/IHangar18.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  IHangar18.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\n// Oracles\\n\\n/**\\n *  @title The interface for the Cygnus Factory\\n *  @notice The Cygnus factory facilitates creation of collateral and borrow pools\\n */\\ninterface IHangar18 {\\n\\n    /**\\n     *  @notice Array of LP Token pairs deployed\\n     *  @param _shuttleId The ID of the shuttle deployed\\n     *  @return launched Whether this pair exists or not\\n     *  @return shuttleId The ID of this shuttle\\n     *  @return borrowable The address of the borrow contract\\n     *  @return collateral The address of the collateral contract\\n     *  @return orbiterId The ID of the orbiters used to deploy this lending pool\\n     */\\n    function allShuttles(\\n        uint256 _shuttleId\\n    ) external view returns (bool launched, uint88 shuttleId, address borrowable, address collateral, uint96 orbiterId);\\n\\n    /**\\n     *  @return usd The address of the borrowable token (stablecoin)\\n     */\\n    function usd() external view returns (address);\\n\\n    /**\\n     *  @return admin The address of the Cygnus Admin which grants special permissions in collateral/borrow contracts\\n     */\\n    function admin() external view returns (address);\\n\\n    /**\\n     *  @return daoReserves The address that handles Cygnus reserves from all pools\\n     */\\n    function daoReserves() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/interfaces/IBonusRewarder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.17;\\n\\ninterface IBonusRewarder {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. CUSTOM ERRORS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n    /**\\n     *  @dev Reverts if msg.sender is not admin\\n     *  @custom:error OnlyAdmin\\n     */\\n    error BonusRewarder__OnlyAdmin();\\n\\n    /**\\n     *  @dev Reverts if msg.sender is not pillars\\n     *  @custom:error OnlyPillarsOfCreation\\n     */\\n    error BonusRewarder__OnlyPillarsOfCreation();\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            2. CUSTOM EVENTS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @custom:event OnReward Logs when it's harvested\\n     */\\n    event OnReward(address indexed borrowable, address indexed collateral, address indexed borrower, uint256 newShares, uint256 pending);\\n\\n    /**\\n     *  @custom:event SetReward Logs when a new reward per second is set\\n     */\\n    event NewRewardPerSec(uint256 rewardPerSec);\\n\\n    /**\\n     *  @custom:event NewBonusReward Logs when a new bonus reward is set for a shuttle\\n     */\\n    event NewBonusReward(address indexed borrowable, address indexed collateral, uint256 allocPoint);\\n\\n    /**\\n     *  @custom:event UpdateBonusShuttle Logs when a bonus reward is updated\\n     */\\n    event UpdateBonusShuttle(\\n        address indexed borrowable,\\n        address indexed collateral,\\n        uint256 lastRewardTime,\\n        uint256 totalShares,\\n        uint256 accRewardPerShare\\n    );\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @return pillarsOfCreation The address of the Pillars of Creation contract on this chain\\n     */\\n    function pillarsOfCreation() external view returns (address);\\n\\n    /**\\n     *  @return totalAllocPoint The total allocation points accross all pools\\n     */\\n    function totalAllocPoint() external view returns (uint256);\\n\\n    /**\\n     *  @return rewardPerSec The rewards per sec of the bonus token\\n     */\\n    function rewardPerSec() external view returns (uint256);\\n\\n    /**\\n     *  @return rewardToken The address of the bonus reward token\\n     */\\n    function rewardToken() external view returns (address);\\n\\n    /**\\n     *  @return admin The address of the admin\\n     */\\n    function admin() external view returns (address);\\n\\n    /**\\n     *  @notice View function to get the pending tokens amount\\n     *  @param borrowable Address of the borrowable\\n     *  @param collateral Address of the collateral\\n     *  @param user The address of the user\\n     */\\n    function pendingReward(\\n        address borrowable,\\n        address collateral,\\n        address user\\n    ) external view returns (address token, uint256 amount);\\n\\n    /**\\n     *  @return getBlockTimestamp The latest timestamp\\n     */\\n    function getBlockTimestamp() external view returns (uint256);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @notice Harvests bonus rewards\\n     *  @param borrowable Address of the borrowable contract\\n     *  @param collateral Address of the collateral contract\\n     *  @param user The address of the user\\n     *  @param recipient The address of the bonus rewards\\n     *  @param rewardAmount The amount of bonus rewards harvested\\n     *  @param newShares The shares after harvest\\n     */\\n    function onReward(\\n        address borrowable,\\n        address collateral,\\n        address user,\\n        address recipient,\\n        uint256 rewardAmount,\\n        uint256 newShares\\n    ) external;\\n\\n    /**\\n     *  @notice Sets the reward per second of rewardToken\\n     *  @param newReward The new reward per sec\\n     *  @custom:security only-admin\\n     */\\n    function setRewardPerSec(uint256 newReward) external;\\n\\n    /**\\n     *  @notice Sets new shuttle rewards\\n     *  @param borrowable Address of the borrowable\\n     *  @param collateral Address of the collateral\\n     *  @param allocPoint The alloc point for this shuttle\\n     *  @custom:security only-admin\\n     */\\n    function initializeBonusRewards(address borrowable, address collateral, uint256 allocPoint) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/interfaces/IPillarsOfCreation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.17;\\n\\n// Interfaces\\nimport {IHangar18} from \\\"./core/IHangar18.sol\\\";\\nimport {IBonusRewarder} from \\\"./IBonusRewarder.sol\\\";\\n\\n/**\\n *  @notice Interface to interact with CYG rewards\\n */\\ninterface IPillarsOfCreation {\\n    /**\\n     *  @custom:struct Epoch Information on each epoch\\n     *  @custom:member epoch The ID for this epoch\\n     *  @custom:member cygPerBlock The CYG reward rate for this epoch\\n     *  @custom:member totalRewards The total amount of CYG estimated to be rewarded in this epoch\\n     *  @custom:member totalClaimed The total amount of claimed CYG\\n     *  @custom:member start The unix timestamp of when this epoch started\\n     *  @custom:member end The unix timestamp of when it ended or is estimated to end\\n     */\\n    struct EpochInfo {\\n        uint256 epoch;\\n        uint256 cygPerBlock;\\n        uint256 totalRewards;\\n        uint256 totalClaimed;\\n        uint256 start;\\n        uint256 end;\\n    }\\n\\n    /**\\n     *  @custom:struct ShuttleInfo Info of each borrowable\\n     *  @custom:member active Whether the pool is active or not\\n     *  @custom:member shuttleId The ID for this shuttle to identify in hangar18\\n     *  @custom:member totalShares The total number of shares held in the pool\\n     *  @custom:member accRewardPerShare The accumulated reward per share\\n     *  @custom:member lastRewardTime The timestamp of the last reward distribution\\n     *  @custom:member allocPoint The allocation points of the pool\\n     *  @custom:member bonusRewarder The address of the bonus rewarder contract (if set)\\n     *  @custom:member pillarsId Unique ID of the rewards to separate shuttle ID between lenders/borrowers\\n     */\\n    struct ShuttleInfo {\\n        bool active;\\n        uint256 shuttleId;\\n        address borrowable;\\n        address collateral;\\n        uint256 totalShares;\\n        uint256 accRewardPerShare;\\n        uint256 lastRewardTime;\\n        uint256 allocPoint;\\n        IBonusRewarder bonusRewarder;\\n        uint256 pillarsId;\\n    }\\n\\n    /**\\n     *  @custom:struct UserInfo Shares and rewards paid to each user\\n     *  @custom:member shares The number of shares held by the user\\n     *  @custom:member rewardDebt The amount of reward debt the user has accrued\\n     */\\n    struct UserInfo {\\n        uint256 shares;\\n        int256 rewardDebt;\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. CUSTOM ERRORS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @dev Reverts if initializing pillars again\\n     *\\n     *  @custom:error PillarsAlreadyInitialized\\n     */\\n    error PillarsOfCreation__PillarsAlreadyInitialized();\\n\\n    /**\\n     *  @dev Reverts if caller is not the Hangar18 Admin\\n     *\\n     *  @custom:error MsgSenderNotAdmin\\n     */\\n    error PillarsOfCreation__MsgSenderNotAdmin();\\n\\n    /**\\n     *  @dev Reverts if pool is not initialized in the rewarder\\n     *\\n     *  @custom:error ShuttleNotInitialized\\n     */\\n    error PillarsOfCreation__ShuttleNotInitialized();\\n\\n    /**\\n     *  @dev Reverts if we are initializing shuttle rewards twice\\n     *\\n     *  @custom:error ShuttleAlreadyInitialized\\n     */\\n    error PillarsOfCreation__ShuttleAlreadyInitialized();\\n\\n    /**\\n     *  @dev Reverts when the total weight is above 100% when setting lender/borrower splits\\n     *\\n     *  @custom:error InvalidTotalWeight\\n     */\\n    error PillarsOfCreation__InvalidTotalWeight();\\n\\n    /**\\n     *  @dev Reverts when the artificer contract is enabled and the msg sender is not artificer\\n     *  @notice Mainly used to set/update rewards\\n     *\\n     *  @custom:error OnlyArtificer\\n     */\\n    error PillarsOfCreation__OnlyArtificer();\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            2. CUSTOM EVENTS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @dev Logs when a new `cygPerBlock` is set manually by Admin\\n     *\\n     *  @param lastRewardRate The previous `cygPerBlock rate`\\n     *  @param newRewardRate The new `cygPerBlock` rate\\n     *\\n     *  @custom:event NewCygPerBlock\\n     */\\n    event NewCygPerBlock(uint256 lastRewardRate, uint256 newRewardRate);\\n\\n    /**\\n     *  @dev Logs when a new collateral is set\\n     */\\n    event NewShuttleRewards(address borrowable, address collateral, uint256 totalAlloc, uint256 alloc);\\n\\n    /**\\n     *  @dev Logs when a bonus rewarder is set for a shuttle\\n     */\\n    event NewBonusRewarder(address borrowable, address collateral, IBonusRewarder bonusRewarder);\\n\\n    /**\\n     *  @dev Logs when a bonus rewarder is removed from a shuttle\\n     */\\n    event RemoveBonusRewarder(address borrowable, address collateral);\\n\\n    /**\\n     *  @dev Logs when a lending pool is updated\\n     *\\n     *  @param borrowable Address of the CygnusBorrow contract\\n     *  @param collateral Address of the CygnusCollateral contract\\n     *  @param sender The msg.sender\\n     *  @param lastRewardTime The last reward time for this pool\\n     *  @param epoch The current epoch\\n     *\\n     *  @custom:event UpdateShuttle\\n     */\\n    event UpdateShuttle(address indexed borrowable, address indexed collateral, address sender, uint256 lastRewardTime, uint256 epoch);\\n\\n    /**\\n     *  @notice Logs when user collects their pending CYG from a single pool pools\\n     *\\n     *  @param borrowable Address of the CygnusBorrow contract\\n     *  @param receiver The receiver of the CYG rewards\\n     *  @param reward CYG reward collected amount\\n     *\\n     *  @custom:event CollectCYG\\n     */\\n    event Collect(address indexed borrowable, address indexed collateral, address receiver, uint256 reward);\\n\\n    /**\\n     *  @notice Logs when user collects their pending CYG from all pools\\n     *\\n     *  @param totalPools The total number of pools harvested\\n     *  @param reward The total amount of CYG collected\\n     */\\n    event CollectAll(uint256 totalPools, uint256 reward);\\n\\n    /**\\n     *  @notice Logs when user collects their pending CYG from all specific borrow or lending pools\\n     *\\n     *  @param totalPools The total number of pools harvested\\n     *  @param reward The total amount of CYG collected\\n     *  @param borrowRewards Whether the user collected borrow or lending reward pools\\n     */\\n    event CollectAllSingle(uint256 totalPools, uint256 reward, bool borrowRewards);\\n\\n    /**\\n     *  @dev Logs when a new Artificer Contract is set\\n     *\\n     *  @param oldArtificer The address of the old artificer contract\\n     *  @param newArtificer The address of the new artificer cntract\\n     *\\n     *  @custom:event NewArtificer\\n     */\\n    event NewArtificer(address oldArtificer, address newArtificer);\\n\\n    /**\\n     *  @dev Logs when admin initializes pillars - Can only be initialized once!\\n     *\\n     *  @param birth The birth timestamp of the pillars\\n     *  @param death The death timestamp of the pillars (ie. when rewards have died out)\\n     *  @param _cygPerBlockRewards The CYG per block for borrowers/lenders at epoch 0\\n     *  @param _cygPerBlockDAO The CYG per block for the DAO at epoch 0\\n     */\\n    event InitializePillars(uint256 birth, uint256 death, uint256 _cygPerBlockRewards, uint256 _cygPerBlockDAO);\\n\\n    /**\\n     *  @dev Logs when the complex rewarder tracks a lender or a borrower\\n     *\\n     *  @param borrowable The address of the borrowable asset.\\n     *  @param account The address of the lender or borrower\\n     *  @param balance The updated balance of the account\\n     *\\n     *  @custom:event TrackShuttle\\n     */\\n    event TrackRewards(address indexed borrowable, address indexed account, uint256 balance, address collateral);\\n\\n    /**\\n     *  @dev Emitted when the contract self-destructs (can only self-destruct after the death unix timestamp)\\n     *\\n     *  @param sender msg.sender\\n     *  @param _birth The birth of this contract\\n     *  @param _death The planned death of this contract\\n     *  @param timestamp The current timestamp\\n     *\\n     *  @custom:event WeAreTheWormsThatCrawlOnTheBrokenWingsOfAnAngel\\n     */\\n    event Supernova(address sender, uint256 _birth, uint256 _death, uint256 timestamp);\\n\\n    /**\\n     *  @dev Logs when we advance an epoch\\n     *\\n     *  @param previousEpoch The number of the previous epoch\\n     *  @param newEpoch The new epoch\\n     *  @param _oldCygPerBlock The old CYG per block\\n     *  @param _newCygPerBlock The new CYG per block\\n     *\\n     *  @custom:event NewEpoch\\n     */\\n    event NewEpoch(uint256 previousEpoch, uint256 newEpoch, uint256 _oldCygPerBlock, uint256 _newCygPerBlock);\\n\\n    /**\\n     *  @dev Logs when the contract sweeps an ERC20 token\\n     *\\n     *  @param token The address of the ERC20 token that was swept.\\n     *  @param sender The address of the account that triggered the token sweep.\\n     *  @param amount The amount of tokens that were swept from the contract's balance.\\n     *  @param currentEpoch The current epoch at the time of the token sweep.\\n     *\\n     *  @custom:event SweepToken\\n     */\\n    event SweepToken(address indexed token, address indexed sender, uint256 amount, uint256 currentEpoch);\\n\\n    /**\\n     *  @dev Logs when the allocation point of a borrowable asset in a Shuttle pool is updated.\\n     *\\n     *  @param borrowable The address of the borrowable asset whose allocation point was updated.\\n     *  @param collateral The address of the collateral asset whose allocation point was updated.\\n     *  @param oldAllocPoint The old allocation point of the borrowable asset in the Shuttle pool.\\n     *  @param newAllocPoint The new allocation point of the borrowable asset in the Shuttle pool.\\n     *\\n     *  @custom:event NewShuttleAllocPoint\\n     */\\n    event NewShuttleAllocPoint(address borrowable, address collateral, uint256 oldAllocPoint, uint256 newAllocPoint);\\n\\n    /**\\n     *  @dev Logs when all pools get updated\\n     *\\n     *  @param shuttlesLength The total number of shuttles updated\\n     *  @param sender The msg.sender\\n     *  @param epoch The current epoch\\n     *\\n     *  @custom:event AccelerateTheUniverse\\n     */\\n    event AccelerateTheUniverse(uint256 shuttlesLength, address sender, uint256 epoch);\\n\\n    /**\\n     *  @dev Logs when the doom switch is enabled by admin, cannot be turned off\\n     */\\n    event DoomSwitchSet(uint256 time, address sender, bool doomswitch);\\n\\n    /**\\n     *  @dev Logs when CYG is dripped to the DAO reserves\\n     */\\n    event CygnusDAODrip(address receiver, uint256 amount);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @return Human readable name for this rewarder\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     *  @return Version of the rewarder\\n     */\\n    function version() external pure returns (string memory);\\n\\n    /**\\n     *  @return The reduction factor per epoch of `cygPerBlock` (each epoch rewards reduce by this factor)\\n     */\\n    function REDUCTION_FACTOR_PER_EPOCH() external pure returns (uint256);\\n\\n    /**\\n     *  @return Address of hangar18 in this chain\\n     */\\n    function hangar18() external view returns (IHangar18);\\n\\n    /**\\n     *  @return Unix timestamp representing the time of contract deployment\\n     */\\n    function birth() external view returns (uint256);\\n\\n    /**\\n     *  @return Unix timestamp representing the time of contract destruction\\n     */\\n    function death() external view returns (uint256);\\n\\n    /**\\n     *  @return The address of the CYG ERC20 Token\\n     */\\n    function cygToken() external view returns (address);\\n\\n    /**\\n     *  @return Total allocation points across all pools\\n     */\\n    function totalAllocPoint() external view returns (uint256);\\n\\n    /**\\n     *  @notice Mapping to keep track of PoolInfo for each borrowable asset\\n     *  @param borrowable The address of the Cygnus Borrow contract\\n     *  @return active Whether the pool has been initialized or not (can only be set once)\\n     *  @return totalShares The total number of shares held in the pool\\n     *  @return accRewardPerShare The accumulated reward per share of the pool\\n     *  @return lastRewardTime The timestamp of the last reward distribution\\n     *  @return allocPoint The allocation points of the pool\\n     *  @return bonusRewarder The rewarder contract to receive bonus token rewards apart from CYG\\n     *  @return shuttleId The ID of the lending pool (shared by borrowable/collateral)\\n     *  @return pillarsId The index of the shuttle in the array\\n     */\\n    function getShuttleInfo(\\n        address borrowable,\\n        address collateral\\n    ) external view returns (bool, uint256, address, address, uint256, uint256, uint256, uint256, IBonusRewarder, uint256);\\n\\n    /**\\n     *  @notice Mapping to keep track of UserInfo for each user's deposit and borrow activity\\n     *  @param borrowable The address of the borrowable contract.\\n     *  @param user The address of the user to check rewards for.\\n     *  @return shares The number of shares held by the user\\n     *  @return rewardDebt The amount of reward debt the user has accrued\\n     */\\n    function getUserInfo(address borrowable, address collateral, address user) external view returns (uint256, int256);\\n\\n    /**\\n     *  @notice Mapping to keep track of EpochInfo for each epoch\\n     *  @param id The epoch number (limited by TOTAL_EPOCHS)\\n     *  @return epoch The ID for this epoch\\n     *  @return rewardRate The CYG reward rate for this epoch\\n     *  @return totalRewards The total amount of CYG estimated to be rewarded in this epoch\\n     *  @return totalClaimed The total amount of claimed CYG\\n     *  @return start The unix timestamp of when this epoch started\\n     *  @return end The unix timestamp of when it ended or is estimated to end\\n     */\\n    function getEpochInfo(\\n        uint256 id\\n    ) external view returns (uint256 epoch, uint256 rewardRate, uint256 totalRewards, uint256 totalClaimed, uint256 start, uint256 end);\\n\\n    /**\\n     *  @return The total amount of pools we have initialized\\n     */\\n    function shuttlesLength() external view returns (uint256);\\n\\n    /**\\n     *  @return Constant variable representing the number of seconds in a year (not taking into account leap years)\\n     */\\n    function SECONDS_PER_YEAR() external pure returns (uint256);\\n\\n    /**\\n     *  @return Constant variable representing the duration of the contract in seconds\\n     */\\n    function DURATION() external pure returns (uint256);\\n\\n    /**\\n     *  @return The total number of epochs.\\n     */\\n    function TOTAL_EPOCHS() external pure returns (uint256);\\n\\n    /**\\n     *  @return The duration of each epoch.\\n     */\\n    function BLOCKS_PER_EPOCH() external pure returns (uint256);\\n\\n    /**\\n     *  @return The timestamp of the end of the last epoch.\\n     */\\n    function lastEpochTime() external view returns (uint256);\\n\\n    /**\\n     *  @return Total rewards given out by this contract up to this point.\\n     */\\n    function totalCygClaimed() external view returns (uint256);\\n\\n    /**\\n     *  @dev Calculates the emission curve for CYG emissions.\\n     *\\n     *  @param epoch The epoch we are calculating the curve for\\n     *  @return The CYG emissions curve at `epoch`\\n     */\\n    function emissionsCurve(uint256 epoch) external pure returns (uint256);\\n\\n    /**\\n     *  @return The current block timestamp.\\n     */\\n    function getBlockTimestamp() external view returns (uint256);\\n\\n    /**\\n     *  @return This function calculates the current epoch based on the current time and the contract deployment time\\n     *          It checks if the contract has expired and returns the total number of epochs if it has\\n     */\\n    function getCurrentEpoch() external view returns (uint256);\\n\\n    /**\\n     *  @return The current epoch rewards for the DAO as per the emissions curve\\n     */\\n    function currentEpochRewardsDAO() external view returns (uint256);\\n\\n    /**\\n     *  @return The current epoch rewards for borrowers/lenders as per the emissions curve\\n     */\\n    function currentEpochRewards() external view returns (uint256);\\n\\n    /**\\n     *  @return The previous epoch rewards as per the emissions curve\\n     */\\n    function previousEpochRewards() external view returns (uint256);\\n\\n    /**\\n     *  @return The amount of rewards to be released in the next epoch.\\n     */\\n    function nextEpochRewards() external view returns (uint256);\\n\\n    /**\\n     *  @dev Get the time in seconds until this contract self-destructs\\n     */\\n    function untilSupernova() external view returns (uint256);\\n\\n    /**\\n     *  @dev Calculates the amount of CYG tokens that should be emitted per block for a given epoch.\\n     *  @param epoch The epoch for which to calculate the emissions rate.\\n     *  @param totalRewards The total amount of rewards distributed by the end of total epochs\\n     *  @return The amount of CYG tokens to be emitted per block.\\n     */\\n    function calculateCygPerBlock(uint256 epoch, uint256 totalRewards) external view returns (uint256);\\n\\n    /**\\n     *  @dev Calculates the total amount of CYG tokens that should be emitted during a given epoch.\\n     *  @param epoch The epoch for which to calculate the total emissions.\\n     *  @param totalRewards The total rewards given out by the end of the total epochs.\\n     *  @return The total amount of CYG tokens to be emitted during the epoch.\\n     */\\n    function calculateEpochRewards(uint256 epoch, uint256 totalRewards) external view returns (uint256);\\n\\n    /**\\n     *  @return Whether the doom which is enabled or not\\n     */\\n    function doomswitch() external view returns (bool);\\n\\n    /**\\n     *  @return The total amount of CYG tokens to be distributed to borrowers and lenders by `death` timestamp\\n     */\\n    function totalCygRewards() external view returns (uint256);\\n\\n    /**\\n     *  @return The total amount of CYG to be distributed to the DAO by the end of this contract's lifetime\\n     */\\n    function totalCygDAO() external view returns (uint256);\\n\\n    /**\\n     *  @return The amount of CYG this contract gives out to per block\\n     */\\n    function cygPerBlockRewards() external view returns (uint256);\\n\\n    /**\\n     *  @return The current cygPerBlock for the dao\\n     */\\n    function cygPerBlockDAO() external view returns (uint256);\\n\\n    /**\\n     *  @return The timestamp of last DAO drip\\n     */\\n    function lastDripDAO() external view returns (uint256);\\n\\n    /**\\n     *  @return The address of the artificer, capable of manipulation individual pool rewards\\n     */\\n    function artificer() external view returns (address);\\n\\n    /**\\n     *  @return Whether or not the artificer is enabled\\n     */\\n    function artificerEnabled() external view returns (bool);\\n\\n    // Simple view functions\\n\\n    /**\\n     * @return The current epoch progression.\\n     */\\n    function epochProgression() external view returns (uint256);\\n\\n    /**\\n     * @return The distance travelled in blocks this epoch.\\n     */\\n    function blocksThisEpoch() external view returns (uint256);\\n\\n    /**\\n     *  @return The pacing of rewards for the current epoch as a percentage\\n     */\\n    function epochRewardsPacing() external view returns (uint256);\\n\\n    /**\\n     *  @return The time left until the next epoch starts.\\n     */\\n    function untilNextEpoch() external view returns (uint256);\\n\\n    /**\\n     * @return The total contract progression.\\n     */\\n    function totalProgression() external view returns (uint256);\\n\\n    /**\\n     *  @return Days until this epoch ends and the next epoch begins\\n     */\\n    function daysUntilNextEpoch() external view returns (uint256);\\n\\n    /**\\n     *  @return The amount of days until this contract self-destructs\\n     */\\n    function daysUntilSupernova() external view returns (uint256);\\n\\n    /**\\n     *  @return How many days have passed since the star tof this epoch\\n     */\\n    function daysPassedThisEpoch() external view returns (uint256);\\n\\n    /**\\n     *  @notice Uses the library's `timestampToDateTime` function to avoid repeating ourselves\\n     */\\n    function timestampToDateTime(\\n        uint256 timestamp\\n    ) external pure returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second);\\n\\n    /**\\n     *  @notice Uses the library's `diffDays` function to avoid repeating ourselves\\n     */\\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp) external pure returns (uint256 result);\\n\\n    /**\\n     *  @notice Returns the datetime that this contract self destructs\\n     */\\n    function dateSupernova() external view returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second);\\n\\n    /**\\n     *  @notice Returns the datetime this epoch ends and next epoch begins\\n     */\\n    function dateNextEpochStart()\\n        external\\n        view\\n        returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second);\\n\\n    /**\\n     *  @notice  Returns the datetime the current epoch started\\n     */\\n    function dateCurrentEpochStart()\\n        external\\n        view\\n        returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second);\\n\\n    /**\\n     *  @notice Returns the datetime the last epoch started\\n     */\\n    function dateLastEpochStart()\\n        external\\n        view\\n        returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second);\\n\\n    /**\\n     *  @notice Returns the datetime that `epoch` started\\n     *  @param epoch The epoch number to get the date time of\\n     */\\n    function dateEpochStart(\\n        uint256 epoch\\n    ) external view returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second);\\n\\n    /**\\n     *  @notice Returns the datetime that `epoch` ends\\n     *  @param epoch The epoch number to get the date time of\\n     */\\n    function dateEpochEnd(\\n        uint256 epoch\\n    ) external view returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second);\\n\\n    //  User functions  //\\n\\n    /**\\n     *  @dev Returns the amount of CYG tokens that are pending to be claimed by the user.\\n     *\\n     *  @param borrowable The address of the Cygnus borrow contract\\n     *  @param account The address of the user\\n     *  @param borrowRewards Whether to check for pending borrow or lender rewards\\n     *  @return The amount of CYG tokens pending to be claimed by `account`.\\n     */\\n    function pendingCyg(address borrowable, address account, bool borrowRewards) external view returns (uint256);\\n\\n    /**\\n     *  @notice Collects CYG rewards from all borrow or lend pools specifically.\\n     *  @notice Only msg.sender can collect their rewards.\\n     *  @param account The addres sof the user\\n     *  @param borrowRewards Whether to check for pending borrow or lender rewards\\n     *\\n     */\\n    function pendingCygSingle(address account, bool borrowRewards) external view returns (uint256 pending);\\n\\n    /**\\n     *  @dev Returns the amount of CYG tokens that are pending to be claimed by the user for all pools.\\n     *\\n     *  @param account The address of the user.\\n     *  @return The amount of CYG tokens pending to be claimed by `account`.\\n     */\\n    function pendingCygAll(address account) external view returns (uint256);\\n\\n    /**\\n     *  @dev Returns bonus rewards for a user\\n     *\\n     *  @param borrowable The address of the borrowable\\n     *  @param collateral The address of the collateral\\n     *  @param account The address of the user\\n     */\\n    function pendingBonusReward(address borrowable, address collateral, address account) external view returns (address, uint256);\\n\\n    /**\\n     *  @dev Returns the amount of CYG tokens that are pending to be claimed by the DAO\\n     */\\n    function pendingCygDAO() external view returns (uint256);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @notice Main entry point into the Pillars. For borrowers, after taking out a loan the core contracts\\n     *          check for whether the pillars are set or not. If the pillars are set, then the borrowable\\n     *          contract passes the principal (ie the user's borrow amount) and the collateral address to this\\n     *          contract to track their rewards. For lenders this occurs after minting, redeeming or any transfer\\n     *          of CygUSD. After any transfer the borrowable checks the user's balance of CygUSD (borrowable vault\\n     *          token) and passes this to the Pillars along wtih to track lending rewards, using the zero address\\n     *          as collateral.\\n     *\\n     *          Effects:\\n     *            - Updates the shares and reward debt of the borrower or lender in this shuttle\\n     *            - Updates the total shares of the shuttle being tracked\\n     *\\n     *  @param account The address of the lender or borrower\\n     *  @param balance The latest balance of CygUSD (for lenders) and the borrowed principal of borrowers\\n     *  @param collateral The address of the collateral (this is the zero address for lenders)\\n     */\\n    function trackRewards(address account, uint256 balance, address collateral) external;\\n\\n    /**\\n     *  @notice Main function used by borrowers or lenders to collect their CYG rewards for a specific pool.\\n     *  @notice Only msg.sender can collect their rewards.\\n     *  @param borrowable The address of the borrowable contract (CygUSD)\\n     *  @param to The address to which rewards are paid to\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function collect(address borrowable, bool borrowRewards, address to) external returns (uint256 cygAmount);\\n\\n    /**\\n     *  @notice Collects CYG rewards from all borrow or lend pools specifically.\\n     *  @notice Only msg.sender can collect their rewards.\\n     *  @param to The address to which rewards are paid to\\n     *  @param borrowRewards Whether user is collecting borrow rewards or lend rewards\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function collectAllSingle(address to, bool borrowRewards) external returns (uint256 cygAmount);\\n\\n    /**\\n     *  @notice Collects CYG rewards owed to borrowers or lenders for ALL pools in the Pillars.\\n     *  @notice Only msg.sender can collect their rewards.\\n     *  @param to The address to which rewards are paid to\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function collectAll(address to) external returns (uint256 cygAmount);\\n\\n    /**\\n     *  @notice Updates the reward per share for a given shuttle\\n     *\\n     *  @param borrowable The address of the borrowable contract (CygUSD)\\n     *  @param borrowRewards Whether the rewards we are updating are for borrowers or lenders\\n     *\\n     *  @custom:security non-reentrantoa\\n     */\\n    function updateShuttle(address borrowable, bool borrowRewards) external;\\n\\n    /**\\n     *  @notice Updates rewards for all pools\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function accelerateTheUniverse() external;\\n\\n    /**\\n     *  @notice Mints Cyg to the DAO according to the `cygPerBlockDAO`\\n     */\\n    function dripCygDAO() external;\\n\\n    /**\\n     *  @notice Self destructs the contract, stopping all CYG rewards. Reverts if we have passed TOTAL_EPOCHS\\n     *          and `doomswitch` is not set.\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function supernova() external;\\n\\n    /**\\n     *  @notice Manually try and advance the epoch\\n     */\\n    function advanceEpoch() external;\\n\\n    /*  -------------------------------------------------------------------------------------------------------  *\\n     *                                           ARTIFICER FUNCTIONS \ud83d\udee0\ufe0f                                          *\\n     *  -------------------------------------------------------------------------------------------------------  */\\n\\n    /**\\n     *  @notice Initializes CYG rewards for a specific shuttle (ie. sets lender or borrower rewards).\\n     *  @notice Can only be initialized once! If need to modifiy use `adjustRewards`.\\n     *\\n     *  @param borrowable The address of the borrowable contract (CygUSD)\\n     *  @param allocPoint The alloc point for this shuttle\\n     *  @param borrowRewards Whether the rewards being set are for borrowers or lenders\\n     *\\n     *  @custom:security only-artificer-or-admin \ud83d\udee0\ufe0f\\n     */\\n    function setShuttleRewards(address borrowable, uint256 allocPoint, bool borrowRewards) external;\\n\\n    /**\\n     *  @notice Adjusts CYG rewards to an already initialized shuttle (for borrowers or lender rewards)\\n     *\\n     *  @param borrowable The address of the borrowable contract (CygUSD)\\n     *  @param allocPoint The new alloc point for this shuttle\\n     *  @param borrowRewards Whether the rewards being set are for borrowers or lenders\\n     *\\n     *  @custom:security only-artificer-or-admin \ud83d\udee0\ufe0f\\n     */\\n    function adjustRewards(address borrowable, uint256 allocPoint, bool borrowRewards) external;\\n\\n    /**\\n     *  @notice Adds bonus rewards to a shuttle to reward borrowers with a bonus token (aside from CYG)\\n     *\\n     *  @param borrowable The address of the borrowable contract (CygUSD)\\n     *  @param borrowRewards Whether this is for lender or borrower rewards\\n     *  @param bonusRewarder The address of the bonus rewarder to reward users in another token other than CYG\\n     *\\n     *  @custom:security only-artificer-or-admin \ud83d\udee0\ufe0f\\n     */\\n    function setBonusRewarder(address borrowable, bool borrowRewards, IBonusRewarder bonusRewarder) external;\\n\\n    /**\\n     *  @notice Removes bonus rewards from a shuttle\\n     *\\n     *  @param borrowable The address of the borrowable\\n     *  @param borrowRewards Whether this is for lender or borrower rewards\\n     *\\n     *  @custom:security only-artificer-or-admin \ud83d\udee0\ufe0f\\n     */\\n    function removeBonusRewarder(address borrowable, bool borrowRewards) external;\\n\\n    /*  -------------------------------------------------------------------------------------------------------  *\\n     *                                             ADMIN FUNCTIONS \ud83d\udc7d                                            *\\n     *  -------------------------------------------------------------------------------------------------------  */\\n\\n    /**\\n     *  @notice Sets the artificer, capable of adjusting rewards\\n     *\\n     *  @param _artificer The address of the new artificer contract\\n     *\\n     *  @custom:security only-admin \ud83d\udc7d\\n     */\\n    function setArtificer(address _artificer) external;\\n\\n    /**\\n     *  @notice Set the doom switch - Cannot be turned off!\\n     *\\n     *  @custom:security only-admin \ud83d\udc7d\\n     *\\n     */\\n    function setDoomswitch() external;\\n\\n    /**\\n     *  @notice Sweeps any erc20 token that was incorrectly sent to this contract\\n     *\\n     *  @param token The address of the token we are recovering\\n     *\\n     *  @custom:security only-admin \ud83d\udc7d\\n     */\\n    function sweepToken(address token) external;\\n\\n    /**\\n     *  @notice Sweeps native that was incorrectly sent to this contract\\n     *\\n     *  @custom:security only-admin \ud83d\udc7d\\n     */\\n    function sweepNative() external;\\n\\n    /*  -------------------------------------------------------------------------------------------------------  *\\n     *                                  INITIALIZE PILLARS - CAN ONLY BE INIT ONCE                               *\\n     *  -------------------------------------------------------------------------------------------------------  */\\n\\n    /**\\n     *  @notice Initializes the contract\\n     *\\n     *  @custom:security only-admin \ud83d\udc7d\\n     */\\n    function initializePillars() external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/libraries/DateTimeLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for date time operations.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/DateTimeLib.sol)\\n///\\n/// Conventions:\\n/// --------------------------------------------------------------------+\\n/// Unit      | Range                | Notes                            |\\n/// --------------------------------------------------------------------|\\n/// timestamp | 0..0x1e18549868c76ff | Unix timestamp.                  |\\n/// epochDay  | 0..0x16d3e098039     | Days since 1970-01-01.           |\\n/// year      | 1970..0xffffffff     | Gregorian calendar year.         |\\n/// month     | 1..12                | Gregorian calendar month.        |\\n/// day       | 1..31                | Gregorian calendar day of month. |\\n/// weekday   | 1..7                 | The day of the week (1-indexed). |\\n/// --------------------------------------------------------------------+\\n/// All timestamps of days are rounded down to 00:00:00 UTC.\\nlibrary DateTimeLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // Weekdays are 1-indexed for a traditional rustic feel.\\n\\n    // \\\"And on the seventh day God finished his work that he had done,\\n    // and he rested on the seventh day from all his work that he had done.\\\"\\n    // -- Genesis 2:2\\n\\n    uint256 internal constant MON = 1;\\n    uint256 internal constant TUE = 2;\\n    uint256 internal constant WED = 3;\\n    uint256 internal constant THU = 4;\\n    uint256 internal constant FRI = 5;\\n    uint256 internal constant SAT = 6;\\n    uint256 internal constant SUN = 7;\\n\\n    // Months and days of months are 1-indexed for ease of use.\\n\\n    uint256 internal constant JAN = 1;\\n    uint256 internal constant FEB = 2;\\n    uint256 internal constant MAR = 3;\\n    uint256 internal constant APR = 4;\\n    uint256 internal constant MAY = 5;\\n    uint256 internal constant JUN = 6;\\n    uint256 internal constant JUL = 7;\\n    uint256 internal constant AUG = 8;\\n    uint256 internal constant SEP = 9;\\n    uint256 internal constant OCT = 10;\\n    uint256 internal constant NOV = 11;\\n    uint256 internal constant DEC = 12;\\n\\n    // These limits are large enough for most practical purposes.\\n    // Inputs that exceed these limits result in undefined behavior.\\n\\n    uint256 internal constant MAX_SUPPORTED_YEAR = 0xffffffff;\\n    uint256 internal constant MAX_SUPPORTED_EPOCH_DAY = 0x16d3e098039;\\n    uint256 internal constant MAX_SUPPORTED_TIMESTAMP = 0x1e18549868c76ff;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                    DATE TIME OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the number of days since 1970-01-01 from (`year`,`month`,`day`).\\n    /// See: https://howardhinnant.github.io/date_algorithms.html\\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\\n    /// Use {isSupportedDate} to check if the inputs are supported.\\n    function dateToEpochDay(uint256 year, uint256 month, uint256 day) internal pure returns (uint256 epochDay) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            year := sub(year, lt(month, 3))\\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\\n            let yoe := mod(year, 400)\\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\\n        }\\n    }\\n\\n    /// @dev Returns (`year`,`month`,`day`) from the number of days since 1970-01-01.\\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\\n    /// Use {isSupportedDays} to check if the inputs is supported.\\n    function epochDayToDate(uint256 epochDay) internal pure returns (uint256 year, uint256 month, uint256 day) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            epochDay := add(epochDay, 719468)\\n            let doe := mod(epochDay, 146097)\\n            let yoe := div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\\n            let mp := div(add(mul(5, doy), 2), 153)\\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\\n            month := sub(add(mp, 3), mul(gt(mp, 9), 12))\\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\\n        }\\n    }\\n\\n    /// @dev Returns the unix timestamp from (`year`,`month`,`day`).\\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\\n    /// Use {isSupportedDate} to check if the inputs are supported.\\n    function dateToTimestamp(uint256 year, uint256 month, uint256 day) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = dateToEpochDay(year, month, day) * 86400;\\n        }\\n    }\\n\\n    /// @dev Returns (`year`,`month`,`day`) from the given unix timestamp.\\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\\n    function timestampToDate(uint256 timestamp) internal pure returns (uint256 year, uint256 month, uint256 day) {\\n        (year, month, day) = epochDayToDate(timestamp / 86400);\\n    }\\n\\n    /// @dev Returns the unix timestamp from\\n    /// (`year`,`month`,`day`,`hour`,`minute`,`second`).\\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\\n    /// Use {isSupportedDateTime} to check if the inputs are supported.\\n    function dateTimeToTimestamp(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\\n        }\\n    }\\n\\n    /// @dev Returns (`year`,`month`,`day`,`hour`,`minute`,`second`)\\n    /// from the given unix timestamp.\\n    /// Note: Inputs outside the supported ranges result in undefined behavior.\\n    /// Use {isSupportedTimestamp} to check if the inputs are supported.\\n    function timestampToDateTime(\\n        uint256 timestamp\\n    ) internal pure returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) {\\n        unchecked {\\n            (year, month, day) = epochDayToDate(timestamp / 86400);\\n            uint256 secs = timestamp % 86400;\\n            hour = secs / 3600;\\n            secs = secs % 3600;\\n            minute = secs / 60;\\n            second = secs % 60;\\n        }\\n    }\\n\\n    /// @dev Returns if the `year` is leap.\\n    function isLeapYear(uint256 year) internal pure returns (bool leap) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\\n        }\\n    }\\n\\n    /// @dev Returns number of days in given `month` of `year`.\\n    function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\\n        bool flag = isLeapYear(year);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\\n            result := add(byte(month, shl(152, 0x1F1C1F1E1F1E1F1F1E1F1E1F)), and(eq(month, 2), flag))\\n        }\\n    }\\n\\n    /// @dev Returns the weekday from the unix timestamp.\\n    /// Monday: 1, Tuesday: 2, ....., Sunday: 7.\\n    function weekday(uint256 timestamp) internal pure returns (uint256 result) {\\n        unchecked {\\n            result = ((timestamp / 86400 + 3) % 7) + 1;\\n        }\\n    }\\n\\n    /// @dev Returns if (`year`,`month`,`day`) is a supported date.\\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\\n    /// - `1 <= month <= 12`.\\n    /// - `1 <= day <= daysInMonth(year, month)`.\\n    function isSupportedDate(uint256 year, uint256 month, uint256 day) internal pure returns (bool result) {\\n        uint256 md = daysInMonth(year, month);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let w := not(0)\\n            result := and(lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)), and(lt(add(month, w), 12), lt(add(day, w), md)))\\n        }\\n    }\\n\\n    /// @dev Returns if (`year`,`month`,`day`,`hour`,`minute`,`second`) is a supported date time.\\n    /// - `1970 <= year <= MAX_SUPPORTED_YEAR`.\\n    /// - `1 <= month <= 12`.\\n    /// - `1 <= day <= daysInMonth(year, month)`.\\n    /// - `hour < 24`.\\n    /// - `minute < 60`.\\n    /// - `second < 60`.\\n    function isSupportedDateTime(\\n        uint256 year,\\n        uint256 month,\\n        uint256 day,\\n        uint256 hour,\\n        uint256 minute,\\n        uint256 second\\n    ) internal pure returns (bool result) {\\n        if (isSupportedDate(year, month, day)) {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns if `epochDay` is a supported unix epoch day.\\n    function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\\n        unchecked {\\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\\n        }\\n    }\\n\\n    /// @dev Returns if `timestamp` is a supported unix timestamp.\\n    function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\\n        unchecked {\\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\\n        }\\n    }\\n\\n    /// @dev Returns the unix timestamp of the given `n`th weekday `wd`, in `month` of `year`.\\n    /// Example: 3rd Friday of Feb 2022 is `nthWeekdayInMonthOfYearTimestamp(2022, 2, 3, 5)`\\n    /// Note: `n` is 1-indexed for traditional consistency.\\n    /// Invalid weekdays (i.e. `wd == 0 || wd > 7`) result in undefined behavior.\\n    function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd) internal pure returns (uint256 result) {\\n        uint256 d = dateToEpochDay(year, month, 1);\\n        uint256 md = daysInMonth(year, month);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\\n        }\\n    }\\n\\n    /// @dev Returns the unix timestamp of the most recent Monday.\\n    function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\\n        uint256 t = timestamp;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let day := div(t, 86400)\\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\\n        }\\n    }\\n\\n    /// @dev Returns whether the unix timestamp falls on a Saturday or Sunday.\\n    /// To check whether it is a week day, just take the negation of the result.\\n    function isWeekEnd(uint256 timestamp) internal pure returns (bool result) {\\n        result = weekday(timestamp) > FRI;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              DATE TIME ARITHMETIC OPERATIONS               */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Adds `numYears` to the unix timestamp, and returns the result.\\n    /// Note: The result will share the same Gregorian calendar month,\\n    /// but different Gregorian calendar years for non-zero `numYears`.\\n    /// If the Gregorian calendar month of the result has less days\\n    /// than the Gregorian calendar month day of the `timestamp`,\\n    /// the result's month day will be the maximum possible value for the month.\\n    /// (e.g. from 29th Feb to 28th Feb)\\n    function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\\n        result = _offsetted(year + numYears, month, day, timestamp);\\n    }\\n\\n    /// @dev Adds `numMonths` to the unix timestamp, and returns the result.\\n    /// Note: If the Gregorian calendar month of the result has less days\\n    /// than the Gregorian calendar month day of the `timestamp`,\\n    /// the result's month day will be the maximum possible value for the month.\\n    /// (e.g. from 29th Feb to 28th Feb)\\n    function addMonths(uint256 timestamp, uint256 numMonths) internal pure returns (uint256 result) {\\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\\n        month = _sub(month + numMonths, 1);\\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\\n    }\\n\\n    /// @dev Adds `numDays` to the unix timestamp, and returns the result.\\n    function addDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\\n        result = timestamp + numDays * 86400;\\n    }\\n\\n    /// @dev Adds `numHours` to the unix timestamp, and returns the result.\\n    function addHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\\n        result = timestamp + numHours * 3600;\\n    }\\n\\n    /// @dev Adds `numMinutes` to the unix timestamp, and returns the result.\\n    function addMinutes(uint256 timestamp, uint256 numMinutes) internal pure returns (uint256 result) {\\n        result = timestamp + numMinutes * 60;\\n    }\\n\\n    /// @dev Adds `numSeconds` to the unix timestamp, and returns the result.\\n    function addSeconds(uint256 timestamp, uint256 numSeconds) internal pure returns (uint256 result) {\\n        result = timestamp + numSeconds;\\n    }\\n\\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\\n    /// Note: The result will share the same Gregorian calendar month,\\n    /// but different Gregorian calendar years for non-zero `numYears`.\\n    /// If the Gregorian calendar month of the result has less days\\n    /// than the Gregorian calendar month day of the `timestamp`,\\n    /// the result's month day will be the maximum possible value for the month.\\n    /// (e.g. from 29th Feb to 28th Feb)\\n    function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\\n        result = _offsetted(year - numYears, month, day, timestamp);\\n    }\\n\\n    /// @dev Subtracts `numYears` from the unix timestamp, and returns the result.\\n    /// Note: If the Gregorian calendar month of the result has less days\\n    /// than the Gregorian calendar month day of the `timestamp`,\\n    /// the result's month day will be the maximum possible value for the month.\\n    /// (e.g. from 29th Feb to 28th Feb)\\n    function subMonths(uint256 timestamp, uint256 numMonths) internal pure returns (uint256 result) {\\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\\n    }\\n\\n    /// @dev Subtracts `numDays` from the unix timestamp, and returns the result.\\n    function subDays(uint256 timestamp, uint256 numDays) internal pure returns (uint256 result) {\\n        result = timestamp - numDays * 86400;\\n    }\\n\\n    /// @dev Subtracts `numHours` from the unix timestamp, and returns the result.\\n    function subHours(uint256 timestamp, uint256 numHours) internal pure returns (uint256 result) {\\n        result = timestamp - numHours * 3600;\\n    }\\n\\n    /// @dev Subtracts `numMinutes` from the unix timestamp, and returns the result.\\n    function subMinutes(uint256 timestamp, uint256 numMinutes) internal pure returns (uint256 result) {\\n        result = timestamp - numMinutes * 60;\\n    }\\n\\n    /// @dev Subtracts `numSeconds` from the unix timestamp, and returns the result.\\n    function subSeconds(uint256 timestamp, uint256 numSeconds) internal pure returns (uint256 result) {\\n        result = timestamp - numSeconds;\\n    }\\n\\n    /// @dev Returns the difference in Gregorian calendar years\\n    /// between `fromTimestamp` and `toTimestamp`.\\n    /// Note: Even if the true time difference is less than a year,\\n    /// the difference can be non-zero is the timestamps are\\n    /// from different Gregorian calendar years\\n    function diffYears(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 result) {\\n        toTimestamp - fromTimestamp;\\n        (uint256 fromYear, , ) = epochDayToDate(fromTimestamp / 86400);\\n        (uint256 toYear, , ) = epochDayToDate(toTimestamp / 86400);\\n        result = _sub(toYear, fromYear);\\n    }\\n\\n    /// @dev Returns the difference in Gregorian calendar months\\n    /// between `fromTimestamp` and `toTimestamp`.\\n    /// Note: Even if the true time difference is less than a month,\\n    /// the difference can be non-zero is the timestamps are\\n    /// from different Gregorian calendar months.\\n    function diffMonths(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 result) {\\n        toTimestamp - fromTimestamp;\\n        (uint256 fromYear, uint256 fromMonth, ) = epochDayToDate(fromTimestamp / 86400);\\n        (uint256 toYear, uint256 toMonth, ) = epochDayToDate(toTimestamp / 86400);\\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\\n    }\\n\\n    /// @dev Returns the difference in days between `fromTimestamp` and `toTimestamp`.\\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 result) {\\n        result = (toTimestamp - fromTimestamp) / 86400;\\n    }\\n\\n    /// @dev Returns the difference in hours between `fromTimestamp` and `toTimestamp`.\\n    function diffHours(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 result) {\\n        result = (toTimestamp - fromTimestamp) / 3600;\\n    }\\n\\n    /// @dev Returns the difference in minutes between `fromTimestamp` and `toTimestamp`.\\n    function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 result) {\\n        result = (toTimestamp - fromTimestamp) / 60;\\n    }\\n\\n    /// @dev Returns the difference in seconds between `fromTimestamp` and `toTimestamp`.\\n    function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp) internal pure returns (uint256 result) {\\n        result = toTimestamp - fromTimestamp;\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      PRIVATE HELPERS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Unchecked arithmetic for computing the total number of months.\\n    function _totalMonths(uint256 numYears, uint256 numMonths) private pure returns (uint256 total) {\\n        unchecked {\\n            total = numYears * 12 + numMonths;\\n        }\\n    }\\n\\n    /// @dev Unchecked arithmetic for adding two numbers.\\n    function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\\n        unchecked {\\n            c = a + b;\\n        }\\n    }\\n\\n    /// @dev Unchecked arithmetic for subtracting two numbers.\\n    function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\\n        unchecked {\\n            c = a - b;\\n        }\\n    }\\n\\n    /// @dev Returns the offsetted timestamp.\\n    function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp) private pure returns (uint256 result) {\\n        uint256 dm = daysInMonth(year, month);\\n        if (day >= dm) {\\n            day = dm;\\n        }\\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/libraries/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The multiply-divide operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The output is undefined, as the input is zero.\\n    error Log2Undefined();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    // Store the function selector of `ExpOverflow()`.\\n                    mstore(0x00, 0xa37bfec9)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                if iszero(sgt(x, 0)) {\\n                    // Store the function selector of `LnWadUndefined()`.\\n                    mstore(0x00, 0x1615e638)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Compute k = log2(x) - 96.\\n            int256 k;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let v := x\\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\\n\\n                // For the remaining 32 bits, use a De Bruijn lookup.\\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\\n                v := shr(k, v)\\n                v := or(v, shr(1, v))\\n                v := or(v, shr(2, v))\\n                v := or(v, shr(4, v))\\n                v := or(v, shr(8, v))\\n                v := or(v, shr(16, v))\\n\\n                // forgefmt: disable-next-item\\n                k := sub(\\n                    or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))), 0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)),\\n                    96\\n                )\\n            }\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Calculates `floor(a * b / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {\\n\\n            } 1 {\\n\\n            } {\\n                // 512-bit multiply `[prod1 prod0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = prod1 * 2**256 + prod0`.\\n\\n                // Least significant 256 bits of the product.\\n                let prod0 := mul(x, y)\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(prod1) {\\n                    if iszero(d) {\\n                        // Store the function selector of `FullMulDivFailed()`.\\n                        mstore(0x00, 0xae47f702)\\n                        // Revert with (offset, size).\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(prod0, d)\\n                    break\\n                }\\n\\n                // Make sure the result is less than `2**256`.\\n                // Also prevents `d == 0`.\\n                if iszero(gt(d, prod1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                ///////////////////////////////////////////////\\n                // 512 by 256 division.\\n                ///////////////////////////////////////////////\\n\\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\\n                // Compute remainder using mulmod.\\n                let remainder := mulmod(x, y, d)\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n                // Factor powers of two out of `d`.\\n                // Compute largest power of two divisor of `d`.\\n                // Always greater or equal to 1.\\n                let twos := and(d, sub(0, d))\\n                // Divide d by power of two.\\n                d := div(d, twos)\\n                // Divide [prod1 prod0] by the factors of two.\\n                prod0 := div(prod0, twos)\\n                // Shift in bits from `prod1` into `prod0`. For this we need\\n                // to flip `twos` such that it is `2**256 / twos`.\\n                // If `twos` is zero, then it becomes one.\\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(mul(3, d), 2)\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                if iszero(add(result, 1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n                result := add(result, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                // Store the function selector of `DivFailed()`.\\n                mstore(0x00, 0x65244e4e)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`.\\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {\\n\\n            } 1 {\\n\\n            } {\\n                if iszero(lt(10, x)) {\\n                    // forgefmt: disable-next-item\\n                    result := and(shr(mul(22, x), 0x375f0016260009d80004ec0002d00001e0000180000180000200000400001), 0x3fffff)\\n                    break\\n                }\\n                if iszero(lt(57, x)) {\\n                    let end := 31\\n                    result := 8222838654177922817725562880000000\\n                    if iszero(lt(end, x)) {\\n                        end := 10\\n                        result := 3628800\\n                    }\\n                    for {\\n                        let w := not(0)\\n                    } 1 {\\n\\n                    } {\\n                        result := mul(result, x)\\n                        x := add(x, w)\\n                        if eq(x, end) {\\n                            break\\n                        }\\n                    }\\n                    break\\n                }\\n                // Store the function selector of `FactorialOverflow()`.\\n                mstore(0x00, 0xaba0f2a2)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(x) {\\n                // Store the function selector of `Log2Undefined()`.\\n                mstore(0x00, 0x5be3aa5c)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))), 0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        unchecked {\\n            uint256 isNotPo2;\\n            assembly {\\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\\n            }\\n            return log2(x) + isNotPo2;\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := sub(0, shr(255, x))\\n            z := xor(mask, add(mask, x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let a := sub(y, x)\\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue) internal pure returns (uint256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {\\n                z := x\\n            } y {\\n\\n            } {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/libraries/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                pop(create(amount, 0x0b, 0x16))\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                pop(create(amount, 0x0b, 0x16))\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal returns (bool success) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            mstore(0x20, from) // Store the `from` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x60, amount) // Store the `amount` argument.\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, from) // Store the `from` argument.\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            mstore(0x40, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x6a.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x1a, to) // Store the `to` argument.\\n            mstore(0x3a, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`,\\n            // left by 6 bytes (enough for 8tb of memory represented by the free memory pointer).\\n            // We waste 6-3 = 3 bytes to save on 6 runtime gas (PUSH1 0x224 SHL).\\n            mstore(0x00, 0xa9059cbb000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x16, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten,\\n            // which is guaranteed to be zero, if less than 8tb of memory is used.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x3a, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x1a, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x3a.\\n            amount := mload(0x3a)\\n            // Store the function selector of `transfer(address,uint256)`,\\n            // left by 6 bytes (enough for 8tb of memory represented by the free memory pointer).\\n            // We waste 6-3 = 3 bytes to save on 6 runtime gas (PUSH1 0x224 SHL).\\n            mstore(0x00, 0xa9059cbb000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x16, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten,\\n            // which is guaranteed to be zero, if less than 8tb of memory is used.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x1a, to) // Store the `to` argument.\\n            mstore(0x3a, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`,\\n            // left by 6 bytes (enough for 8tb of memory represented by the free memory pointer).\\n            // We waste 6-3 = 3 bytes to save on 6 runtime gas (PUSH1 0x224 SHL).\\n            mstore(0x00, 0x095ea7b3000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x16, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten,\\n            // which is guaranteed to be zero, if less than 8tb of memory is used.\\n            mstore(0x3a, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, account) // Store the `account` argument.\\n            amount := mul(\\n                mload(0x20),\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x20, 0x20)\\n                )\\n            )\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/PillarsOfCreation.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  PillarsOfCreation.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\n/*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  \\n    .              .            .               .      \ud83d\udef0\ufe0f     .           .                .           .\\n           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           ---======*.                                                 .           \u2800\\n          \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588                                               \ud83d\udce1                \ud83c\udf14                      . \\n         \u2588\u2588\u2588     \u2591\u2591\u2591  \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588        \u2800\\n        \u2591\u2588\u2588\u2588         \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591      .     .\u2800           .           .\\n        \u2591\u2588\u2588\u2588          \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588       \u2800\\n        \u2591\u2591\u2588\u2588\u2588     \u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2588\u2588\u2588              .             .\u2800\\n         \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588     .----===.*  \u2800\\n          \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591   \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591\u2591            .                           .\u2800\\n           \ud83d\udef0\ufe0f          \u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588 \u2591\u2588\u2588\u2588                .                 .                 .\u2800\\n        .             \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588                \ud83d\udef0\ufe0f                             .                 .     \\n                       \u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591      -------=========*         \ud83d\udef0\ufe0f             .                     \u2800\\n           .                            .       .          .            .                        .             .\u2800\\n        \\n        Pillars of Creation - https://cygnusdao.finance                                                          .                     .\\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\npragma solidity >=0.8.17;\\n\\n// Dependencies\\nimport {IPillarsOfCreation} from \\\"./interfaces/IPillarsOfCreation.sol\\\";\\nimport {ReentrancyGuard} from \\\"./utils/ReentrancyGuard.sol\\\";\\n\\n// Libraries\\nimport {SafeTransferLib} from \\\"./libraries/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./libraries/FixedPointMathLib.sol\\\";\\nimport {DateTimeLib} from \\\"./libraries/DateTimeLib.sol\\\";\\n\\n// Interfaces\\nimport {IBonusRewarder} from \\\"./interfaces/IBonusRewarder.sol\\\";\\nimport {IHangar18} from \\\"./interfaces/core/IHangar18.sol\\\";\\nimport {IERC20} from \\\"./interfaces/core/IERC20.sol\\\";\\nimport {ICygnusTerminal} from \\\"./interfaces/core/ICygnusTerminal.sol\\\";\\n\\n// TODO FIX TIME\\n\\n/**\\n *  @notice The only contract capable of minting the CYG token. The CYG token is divided between the DAO and lenders\\n *          or borrowers of the Cygnus protocol.\\n *          It is similar to a masterchef contract but the rewards are based on epochs. Each epoch the rewards get\\n *          reduced by the `REDUCTION_FACTOR_PER_EPOCH` which is set at 1%. When deploying, the contract calculates\\n *          the initial rewards per block based on:\\n *            - the total amount of rewards\\n *            - the total number of epochs\\n *            - reduction factor.\\n *\\n *          rewardsAtEpochN = (totalRewards - accumulatedRewards) * reductionFactor / emissionsCurve(epochN)\\n *\\n *                        |\\n *                   800k |_______.\\n *                        |       |\\n *                   700k |       |\\n *                        |       |                Example with 1.75M totalRewards, 2% reduction and 100 epochs\\n *                   600k |       |\\n *                        |       |                                Epochs    |    Rewards\\n *                   500M |       |                             -------------|---------------\\n *                        |       |_______.                       00 - 24    |   800,037.32\\n *          rewards  400k |       |       |                       25 - 49    |   482,794.30\\n *                        |       |       |                       50 - 74    |   291,349.33\\n *                   300k |       |       |_______.               75 - 99    |   175,819.05\\n *                        |       |       |       |                          | 1,750,000.00\\n *                   200k |       |       |       |_______\\n *                        |       |       |       |       |\\n *                   100k |       |       |       |       |\\n *                        |       |       |       |       |\\n *                        |_______|_______|_______|_______|__\\n *                          00-24   25-49   50-74   75-99\\n *                                     epochs\\n *\\n *          On any interaction the `advance` function is called to check if we can advance to a new epoch. The contract\\n *          self-destructs once the final epoch is reached.\\n *\\n *  @title  PillarsOfCreation The only contract that can mint CYG into existence\\n *  @author CygnusDAO\\n */\\ncontract PillarsOfCreation is IPillarsOfCreation, ReentrancyGuard {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. LIBRARIES\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @custom:library SafeTransferLib ERC20 transfer library that gracefully handles missing return values.\\n     */\\n    using SafeTransferLib for address;\\n\\n    /**\\n     *  @custom:library FixedPointMathLib Arithmetic library with operations for fixed-point numbers\\n     */\\n    using FixedPointMathLib for uint256;\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            2. STORAGE\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Private \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Accounting precision for rewards per share\\n     */\\n    uint256 private constant ACC_PRECISION = 1e24;\\n\\n    /**\\n     *  @notice Total pools receiving CYG rewards - This is different to the hangar18 shuttles. In Hangar18\\n     *          1 shuttle contains a borrowable and collateral. In this contract each hangar18 shuttle is divided\\n     *          into 2 shuttles to separate between lender and borrower rewards, and each shuttle has a unique\\n     *          `pillarsId`.\\n     */\\n    ShuttleInfo[] private _allShuttles;\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    mapping(uint256 => EpochInfo) public override getEpochInfo;\\n\\n    /**\\n     *  @notice For lender rewards the collateral is address zero.\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    mapping(address => mapping(address => ShuttleInfo)) public override getShuttleInfo; // borrowable -> collateral = Shuttle\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    mapping(address => mapping(address => mapping(address => UserInfo))) public override getUserInfo; // borrowable -> collateral -> user address = User Info\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    string public override name = \\\"Cygnus: Pillars of Creation\\\";\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    string public constant override version = \\\"1.0.0\\\";\\n\\n    // Pillars settings //\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public constant override SECONDS_PER_YEAR = 31536000; // Doesn't take into account leap years\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public constant override DURATION = SECONDS_PER_YEAR * 6;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public constant override TOTAL_EPOCHS = 156;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public constant override BLOCKS_PER_EPOCH = DURATION / TOTAL_EPOCHS;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public constant override REDUCTION_FACTOR_PER_EPOCH = 0.01e18; // 1% `cygPerblock` reduction per epoch\\n\\n    // Immutables //\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    IHangar18 public immutable override hangar18;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    address public immutable override cygToken;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public immutable override totalCygRewards;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public immutable override totalCygDAO;\\n\\n    // Current settings\\n\\n    /**\\n     *  @notice Can only be set once via the `initializePillars` function\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public override birth;\\n\\n    /**\\n     *  @notice Can only be set once via the `initializePillars` function\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public override death;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public override cygPerBlockRewards; // Rewards for Borrowers & Lenders\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public override cygPerBlockDAO; // Rewards for DAO\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public override totalAllocPoint;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public override lastDripDAO;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    uint256 public override lastEpochTime;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    address public override artificer;\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    bool public override doomswitch;\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTRUCTOR\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @dev Constructor that initializes the contract with the given `_hangar18`, `_rewardToken`, and `_cygPerBlock` values.\\n     *\\n     *  @param _hangar18 The address of the Hangar18 contract.\\n     *  @param _rewardToken The address of the reward token contract.\\n     *  @param _totalCygRewardsBorrows The amount of CYG tokens to be distributed to borrowers and lenders\\n     *  @param _totalCygRewardsDAO The amount of CYG tokens to be distributed to the DAO\\n     */\\n    constructor(IHangar18 _hangar18, address _rewardToken, uint256 _totalCygRewardsBorrows, uint256 _totalCygRewardsDAO) {\\n        // Total CYG to be distributed as rewards to lenders/borrowers\\n        totalCygRewards = _totalCygRewardsBorrows;\\n\\n        // Total CYG to go to the DAO\\n        totalCygDAO = _totalCygRewardsDAO;\\n\\n        // Set CYG token\\n        cygToken = _rewardToken;\\n\\n        // Set factory\\n        hangar18 = _hangar18;\\n    }\\n\\n    /**\\n     *  @dev This function is called for plain Ether transfers\\n     */\\n    receive() external payable {}\\n\\n    /**\\n     *  @dev Fallback function is executed if none of the other functions match the function identifier or no data was provided with the function call.\\n     */\\n    fallback() external payable {}\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. MODIFIERS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @custom:modifier cygnusAdmin Controls important parameters in both Collateral and Borrow contracts \ud83d\udc7d\\n     */\\n    modifier cygnusAdmin() {\\n        _checkAdmin();\\n        _;\\n    }\\n\\n    /**\\n     *  @custom:modifier advance Advances the epoch if necessary and self-destructs contract if all epochs are finished\\n     */\\n    modifier advance() {\\n        // Try and advance epoch\\n        _advanceEpoch();\\n        _;\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            5. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Private \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Internal check for msg.sender admin, checks factory's current admin \ud83d\udc7d\\n     */\\n    function _checkAdmin() private view {\\n        // Current admin from the factory\\n        address admin = hangar18.admin();\\n\\n        /// @custom:error MsgSenderNotAdmin Avoid unless caller is Cygnus Admin\\n        if (msg.sender != admin) revert PillarsOfCreation__MsgSenderNotAdmin();\\n    }\\n\\n    /**\\n     *  @notice Reverts if msg.sender is not artificer\\n     */\\n    function _checkArtificer() private view {\\n        // Check if artificer is enabled\\n        if (artificerEnabled()) {\\n            /// @custom:error OnlyArtificer Avoid if caller is not the artificer\\n            if (msg.sender != artificer) revert PillarsOfCreation__OnlyArtificer();\\n        }\\n        // Artificer not enabled, check caller is admin\\n        else _checkAdmin();\\n    }\\n\\n    /**\\n     *  @notice Returns the latest pending CYG for `account` in this shuttle\\n     *  @param borrowable The address of the CygnusBorrow contract (CygUSD)\\n     *  @param collateral The address of the CygnusCollateral contract (CygLP)\\n     *  @param account The address of the user\\n     */\\n    function _pendingCyg(address borrowable, address collateral, address account) private view returns (uint256 pending) {\\n        // Load pool to memory\\n        ShuttleInfo memory shuttle = getShuttleInfo[borrowable][collateral];\\n\\n        // Load user to memory\\n        UserInfo memory user = getUserInfo[borrowable][collateral][account];\\n\\n        // Load the accumulated reward per share\\n        uint256 accRewardPerShare = shuttle.accRewardPerShare;\\n\\n        // Load total shares from the pool\\n        uint256 totalShares = shuttle.totalShares;\\n\\n        // Current timestamp\\n        uint256 timestamp = getBlockTimestamp();\\n\\n        // If the current block's timestamp is after the last reward time and there are shares in the pool\\n        if (timestamp > shuttle.lastRewardTime && totalShares != 0) {\\n            // Calculate the time elapsed since the last reward\\n            uint256 timeElapsed = timestamp - shuttle.lastRewardTime;\\n\\n            // Calculate the reward for the elapsed time, using the pool's allocation point and total allocation points\\n            uint256 reward = (timeElapsed * cygPerBlockRewards * shuttle.allocPoint) / totalAllocPoint;\\n\\n            // Add the calculated reward per share to the accumulated reward per share\\n            accRewardPerShare = accRewardPerShare + (reward * ACC_PRECISION) / totalShares;\\n        }\\n\\n        // Calculate the pending reward for the user, based on their shares and the accumulated reward per share\\n        pending = uint256(int256((user.shares * accRewardPerShare) / ACC_PRECISION) - (user.rewardDebt));\\n    }\\n\\n    /**\\n     *  @dev The pillars consists of rewards for both borrowers and lenders in each shuttle. To separate between\\n     *       each rewards and alloc points we set different collaterals for each, but the same borrowable.\\n     *       If we are setting borrow rewards then we use the actual collateral of the borrowable, if we are setting\\n     *       lender rewards we set the collateral as the zero address.\\n     */\\n    function _isBorrowRewards(address borrowable, bool borrowRewards) private view returns (address collateral) {\\n        // Check if we are adding lender or borrower rewards\\n        collateral = borrowRewards ? ICygnusTerminal(borrowable).collateral() : address(0);\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function shuttlesLength() public view override returns (uint256) {\\n        return _allShuttles.length;\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function getBlockTimestamp() public view override returns (uint256) {\\n        // Return this block's timestamp\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function getCurrentEpoch() public view override returns (uint256 currentEpoch) {\\n        // Get the current timestamp\\n        uint256 currentTime = getBlockTimestamp();\\n\\n        // Contract has expired\\n        if (currentTime >= death) return TOTAL_EPOCHS;\\n\\n        // Current epoch\\n        currentEpoch = (currentTime - birth) / BLOCKS_PER_EPOCH;\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function calculateEpochRewards(uint256 epoch, uint256 totalRewards) public pure override returns (uint256 rewards) {\\n        // Get cyg per block for the epoch\\n        uint256 _cygPerBlock = calculateCygPerBlock(epoch, totalRewards);\\n\\n        // Return total CYG in the epoch\\n        return _cygPerBlock * BLOCKS_PER_EPOCH;\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function emissionsCurve(uint256 epoch) public pure override returns (uint) {\\n        // Create the emissions curve based on the reduction factor and epoch\\n        uint256 oneMinusReductionFactor = 1e18 - REDUCTION_FACTOR_PER_EPOCH;\\n\\n        // Total Epochs\\n        uint256 totalEpochs = TOTAL_EPOCHS - epoch;\\n\\n        // Start at 1\\n        uint256 result = 1e18;\\n\\n        // Loop through total epochs left\\n        for (uint i = 0; i < totalEpochs; i++) {\\n            result = result.mulWad(oneMinusReductionFactor);\\n        }\\n\\n        return 1e18 - result;\\n    }\\n\\n    /**\\n     *  @notice Same claculation as in line 64. We calculate emissions at epoch 0 and then adjust the rewards by reduction\\n     *          factor for gas savings.\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function calculateCygPerBlock(uint256 epoch, uint256 totalRewards) public pure override returns (uint256 rewardRate) {\\n        // Calculate emissions curve at epoch 0 - This is what gives the slope of the curve at each epoch, given\\n        // total epochs and a reduction factor:\\n        // rewards_at_epoch_0 = (total_cyg_rewards * reduction_factor) / emissions_curve\\n        //                    = (1750000 * 0.02) / 0.867380\\n        //                    = 40351.38\\n        // From here we reduce 2% of the total rewards each epoch:\\n        // rewards_at_epoch_1 = 40351.38 * 0.98 = 39544.35\\n        // rewards_at_epoch_2 = 39544.35 * 0.98 = 38753.47, etc.\\n        uint256 emissionsAt0 = emissionsCurve(0);\\n\\n        // Get rewards for epoch 0\\n        uint256 rewards = totalRewards.fullMulDiv(REDUCTION_FACTOR_PER_EPOCH, emissionsAt0);\\n\\n        // Get total CYG rewards for `epoch`\\n        for (uint i = 0; i < epoch; i++) {\\n            rewards = rewards.mulWad(1e18 - REDUCTION_FACTOR_PER_EPOCH);\\n        }\\n\\n        // Return the CYG per block rate at `epoch` given `totalRewards`\\n        rewardRate = rewards / BLOCKS_PER_EPOCH;\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Get the shuttle by Pillars ID from the `_allShuttles` array. The shuttles differ from Hangar18's\\n     *          allShuttles array as for every shuttle ID there are 2 pillar IDs (one pillars for borrowers and\\n     *          one for lenders). This reads individual shuttle for either borrowers or lenders, and not by the\\n     *          factory's shuttle ID.\\n     */\\n    function allShuttles(uint256 pillarsId) external view returns (ShuttleInfo memory) {\\n        // Read from array\\n        return _allShuttles[pillarsId];\\n    }\\n\\n    /**\\n     *  @notice Get the shuttle by ID (not the same as hangar18 `allShuttles`)\\n     */\\n    function getShuttleById(uint256 shuttleId) external view returns (ShuttleInfo memory lenders, ShuttleInfo memory borrowers) {\\n        // Get shuttle ID from hangar\\n        (, , address borrowable, address collateral, ) = hangar18.allShuttles(shuttleId);\\n\\n        // Lender's pool is always with address zero as collateral\\n        lenders = getShuttleInfo[borrowable][address(0)];\\n\\n        // Borrower's pool is with both\\n        borrowers = getShuttleInfo[borrowable][collateral];\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function pendingCyg(address borrowable, address account, bool borrowRewards) external view override returns (uint256 pending) {\\n        // Get collateral (lender rewards is the zero address, borrow rewards we get the borrowable's collateral)\\n        address collateral = _isBorrowRewards(borrowable, borrowRewards);\\n\\n        // Pending CYG for this unique shuttle\\n        pending = _pendingCyg(borrowable, collateral, account);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function pendingCygSingle(address account, bool borrowRewards) external view returns (uint256 pending) {\\n        // Gas savings\\n        ShuttleInfo[] memory shuttles = _allShuttles;\\n\\n        // Length\\n        uint256 totalPools = shuttles.length;\\n\\n        // Loop through each shuttle\\n        for (uint256 i = 0; i < totalPools; i++) {\\n            // Get collateral\\n            address collateral = shuttles[i].collateral;\\n\\n            // If collecting borrow rewards then we skip if collateral is address zero (lenders)\\n            if (borrowRewards && collateral == address(0)) continue;\\n\\n            // If collecting lender rewards then we skip if collateral is not address zero\\n            if (!borrowRewards && collateral != address(0)) continue;\\n\\n            // Collect rewards\\n            pending += _pendingCyg(shuttles[i].borrowable, collateral, account);\\n        }\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function pendingCygAll(address account) external view returns (uint256 pending) {\\n        // Gas savings\\n        ShuttleInfo[] memory shuttles = _allShuttles;\\n\\n        // Length\\n        uint256 totalShuttles = shuttles.length;\\n\\n        // Loop through each shuttle\\n        for (uint256 i = 0; i < totalShuttles; i++) {\\n            // Get pending cyg for each shuttle\\n            // note that these shuttles are different from hangar18 shuttles as\\n            // collateral can be zero address here to represent lender pools\\n            pending += _pendingCyg(shuttles[i].borrowable, shuttles[i].collateral, account);\\n        }\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function pendingBonusReward(\\n        address borrowable,\\n        address collateral,\\n        address account\\n    ) external view override returns (address token, uint256 amount) {\\n        // Load pool to memory\\n        ShuttleInfo memory shuttle = getShuttleInfo[borrowable][collateral];\\n\\n        // Return bonus rewards if any\\n        return shuttle.bonusRewarder.pendingReward(borrowable, collateral, account);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function pendingCygDAO() external view override returns (uint256 pending) {\\n        // Calculate time since last dao claim\\n        uint256 currentTime = block.timestamp;\\n\\n        // Cyg accrued for the DAO\\n        return (currentTime - lastDripDAO) * cygPerBlockDAO;\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function totalCygClaimed() public view override returns (uint256 claimed) {\\n        // Get current epoch\\n        uint256 currentEpoch = getCurrentEpoch();\\n\\n        // Loop through each epoch\\n        for (uint256 i = 0; i <= currentEpoch; i++) {\\n            // Get total claimed in this epoch and add it to previous\\n            claimed += getEpochInfo[i].totalClaimed;\\n        }\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function artificerEnabled() public view returns (bool) {\\n        return artificer != address(0);\\n    }\\n\\n    // Simple view functions to get quickly\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function epochRewardsPacing() external view override returns (uint256) {\\n        // Get the progress to then divide by far how along we in epoch\\n        uint256 epochProgress = (getBlockTimestamp() - lastEpochTime).divWad(BLOCKS_PER_EPOCH);\\n\\n        // Get current epoch\\n        uint256 currentEpoch = getCurrentEpoch();\\n\\n        // Total rewards this epoch\\n        uint256 rewards = getEpochInfo[currentEpoch].totalRewards;\\n\\n        // Claimed rewards this epoch\\n        uint256 claimed = getEpochInfo[currentEpoch].totalClaimed;\\n\\n        // Get rewards claimed progress relative to epoch progress. ie. epoch progression is 50% and 50%\\n        // of rewards in this epoch have been claimed then we are at 100% or 1e18\\n        return claimed.divWad(rewards.mulWad(epochProgress));\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function currentEpochRewardsDAO() external view override returns (uint256) {\\n        // Get current epoch\\n        uint256 currentEpoch = getCurrentEpoch();\\n\\n        // Calculate current epoch rewards\\n        return calculateEpochRewards(currentEpoch, totalCygDAO);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function currentEpochRewards() external view override returns (uint256) {\\n        // Get current epoch\\n        uint256 currentEpoch = getCurrentEpoch();\\n\\n        // Calculate current epoch rewards\\n        return calculateEpochRewards(currentEpoch, totalCygRewards);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function previousEpochRewards() external view override returns (uint256) {\\n        // Get current epoch\\n        uint256 currentEpoch = getCurrentEpoch();\\n\\n        // Calculate next epoch rewards\\n        return currentEpoch == 0 ? 0 : calculateEpochRewards(currentEpoch - 1, totalCygRewards);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function nextEpochRewards() external view override returns (uint256) {\\n        // Get current epoch\\n        uint256 currentEpoch = getCurrentEpoch();\\n\\n        // Calculate next epoch rewards\\n        return calculateEpochRewards(currentEpoch + 1, totalCygRewards);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function blocksThisEpoch() external view override returns (uint256) {\\n        // Get how far along we are in this epoch in seconds\\n        return getBlockTimestamp() - lastEpochTime;\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function untilNextEpoch() external view override returns (uint256) {\\n        // Return seconds left until next epoch\\n        return BLOCKS_PER_EPOCH - (getBlockTimestamp() - lastEpochTime);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function untilSupernova() external view override returns (uint256) {\\n        // Return seconds until death\\n        return death - getBlockTimestamp();\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function epochProgression() external view override returns (uint256) {\\n        // Return how far along we are in this epoch scaled by 1e18 (0.69e18 = 69%)\\n        return (getBlockTimestamp() - lastEpochTime).divWad(BLOCKS_PER_EPOCH);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function totalProgression() external view override returns (uint256) {\\n        // Return how far along we are in total scaled by 1e18 (0.69e18 = 69%)\\n        return (getBlockTimestamp() - birth).divWad(DURATION);\\n    }\\n\\n    // Datetime functions\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function timestampToDateTime(\\n        uint256 timestamp\\n    ) public pure returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) {\\n        // Avoid repeating ourselves\\n        return DateTimeLib.timestampToDateTime(timestamp);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function diffDays(uint256 fromTimestamp, uint256 toTimestamp) public pure returns (uint256 result) {\\n        // Avoid repeating ourselves\\n        return DateTimeLib.diffDays(fromTimestamp, toTimestamp);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function daysUntilNextEpoch() external view override returns (uint256) {\\n        // Current epoch\\n        uint256 epoch = getCurrentEpoch();\\n\\n        // If we are in the last epoch return 0\\n        if (epoch == TOTAL_EPOCHS - 1) return (0);\\n\\n        // Return the days left for this epoch\\n        return diffDays(block.timestamp, getEpochInfo[epoch].end);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function daysUntilSupernova() external view override returns (uint256) {\\n        // Return how many days until we self-destruct\\n        return diffDays(block.timestamp, death);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function daysPassedThisEpoch() external view override returns (uint256) {\\n        // Current epoch\\n        uint256 epoch = getCurrentEpoch();\\n\\n        // Return how many days in we are in this epoch\\n        return diffDays(getEpochInfo[epoch].start, block.timestamp);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function dateNextEpochStart()\\n        external\\n        view\\n        override\\n        returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second)\\n    {\\n        // Current epoch\\n        uint256 epoch = getCurrentEpoch();\\n\\n        // Get epoch end\\n        uint256 nextEpochTimestamp = getEpochInfo[epoch].end;\\n\\n        // Return the dateTime of the next epoch start\\n        return timestampToDateTime(nextEpochTimestamp);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function dateCurrentEpochStart()\\n        external\\n        view\\n        override\\n        returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second)\\n    {\\n        // Currrent epoch\\n        uint256 epoch = getCurrentEpoch();\\n\\n        // block.timestamp of the start of this epoch\\n        uint256 thisEpochTimestamp = getEpochInfo[epoch].start;\\n\\n        // Return the date time of this epoch start\\n        return timestampToDateTime(thisEpochTimestamp);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function dateLastEpochStart()\\n        external\\n        view\\n        override\\n        returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second)\\n    {\\n        // Current epoch\\n        uint256 epoch = getCurrentEpoch();\\n\\n        // Account for epoch 0\\n        if (epoch == 0) return (0, 0, 0, 0, 0, 0);\\n\\n        // Get when this epoch ends\\n        uint256 thisEpochTimestamp = getEpochInfo[epoch - 1].start;\\n\\n        // Return the datetime the last epoch began\\n        return timestampToDateTime(thisEpochTimestamp);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function dateEpochStart(\\n        uint256 _epoch\\n    ) external view override returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) {\\n        // Epoch start\\n        uint256 epochStart = getEpochInfo[_epoch].start;\\n\\n        // Return datetime of past epoch start time\\n        return timestampToDateTime(epochStart);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function dateEpochEnd(\\n        uint256 _epoch\\n    ) external view override returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) {\\n        // Epoch end\\n        uint256 epochEnd = getEpochInfo[_epoch].end;\\n\\n        // Datetime of the end of the epoch\\n        return timestampToDateTime(epochEnd);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function dateSupernova()\\n        external\\n        view\\n        override\\n        returns (uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second)\\n    {\\n        // Return the datetime this contract self-destructs\\n        return timestampToDateTime(death);\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            6. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Private \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @dev Internal function that destroys the contract and transfers remaining funds to the owner.\\n     */\\n    function _supernova() private {\\n        // Get epoch, uses block.timestamp - keep this function separate to getCurrentEpoch for simplicity\\n        uint256 epoch = getCurrentEpoch();\\n\\n        // Check if current epoch is less than total epochs\\n        if (epoch < TOTAL_EPOCHS) return;\\n\\n        // Assert we are doomed, can only be set my admin and cannot be turned off\\n        assert(doomswitch);\\n\\n        /// @custom:event Supernova\\n        emit Supernova(msg.sender, birth, death, epoch);\\n\\n        // Hail Satan! \u0295\u2022\u1d25\u2022\u0294\\n        //\\n        // By now 8 years have passed and this contract would have minted exactly:\\n        //\\n        //   totalCygRewards + totalCygRewardsDAO\\n        //\\n        // Since the Pillars are the only minter of the CYG token, no more CYG can be minted into existence.\\n        // Hide self destruct as it will be deprecated and not all EVMs support it (ie ZKEVM).\\n        // selfdestruct(payable(admin));\\n    }\\n\\n    /**\\n     *  @notice Try and advance the epoch based on the time that has passed since the last epoch\\n     *  @notice Called after most payable functions (except `trackRewards`) to try and advance epoch\\n     */\\n    function _advanceEpoch() private {\\n        // Get timestamp\\n        uint256 currentTime = getBlockTimestamp();\\n\\n        // Time since last epoch\\n        uint256 timeSinceLastEpoch = currentTime - lastEpochTime;\\n\\n        // Get epoch since last update\\n        uint256 epochsPassed = timeSinceLastEpoch / BLOCKS_PER_EPOCH;\\n\\n        // Update if we are at new epoch\\n        if (epochsPassed > 0) {\\n            // Get this epoch\\n            uint256 currentEpoch = getCurrentEpoch();\\n\\n            // Check that contract is not expired\\n            if (currentEpoch < TOTAL_EPOCHS) {\\n                // Store last epoch update\\n                lastEpochTime = currentTime;\\n\\n                // The cygPerBlock up to this epoch\\n                uint256 oldCygPerBlock = cygPerBlockRewards;\\n\\n                // Store new cygPerBlock\\n                cygPerBlockRewards = calculateCygPerBlock(currentEpoch, totalCygRewards);\\n\\n                // Store this info once on each advance\\n                EpochInfo storage epoch = getEpochInfo[currentEpoch];\\n\\n                // Store start time\\n                epoch.start = currentTime;\\n\\n                // Store estimated end time\\n                epoch.end = currentTime + BLOCKS_PER_EPOCH;\\n\\n                // Store current epoch number\\n                epoch.epoch = currentEpoch;\\n\\n                // Store the `cygPerBlock` of this epoch\\n                epoch.cygPerBlock = cygPerBlockRewards;\\n\\n                // Store the planned rewards for this epoch (same as `currentEpochRewards()`)\\n                epoch.totalRewards = cygPerBlockRewards * BLOCKS_PER_EPOCH;\\n\\n                // Assurance\\n                epoch.totalClaimed = 0;\\n\\n                // Store the new cyg per block for the dao\\n                cygPerBlockDAO = calculateCygPerBlock(currentEpoch, totalCygDAO);\\n\\n                /// @custom:event NewEpoch\\n                emit NewEpoch(currentEpoch - 1, currentEpoch, oldCygPerBlock, cygPerBlockRewards);\\n            }\\n            // If we have passed 1 epoch and the current epoch is >= TOTAL EPOCHS then we self-destruct contract\\n            else _supernova();\\n        }\\n    }\\n\\n    /**\\n     *  @notice Update the specified shuttle's reward variables to the current timestamp.\\n     *  @notice Updates the reward information for a specific borrowable asset. It retrieves the current\\n     *          ShuttleInfo for the asset, calculates the reward to be distributed based on the time elapsed\\n     *          since the last distribution and the pool's allocation point, updates the accumulated reward\\n     *          per share based on the reward distributed, and stores the updated ShuttleInfo for the asset.\\n     *  @param borrowable The address of the borrowable asset to update.\\n     *  @return shuttle The updated ShuttleInfo struct.\\n     */\\n    function _updateShuttle(address borrowable, address collateral) private returns (ShuttleInfo storage shuttle) {\\n        // Get the pool information\\n        shuttle = getShuttleInfo[borrowable][collateral];\\n\\n        // Current timestamp\\n        uint256 timestamp = getBlockTimestamp();\\n\\n        // Check if rewards can be distributed\\n        if (timestamp > shuttle.lastRewardTime) {\\n            // Calculate the reward to be distributed\\n            uint256 totalShares = shuttle.totalShares;\\n\\n            if (totalShares > 0) {\\n                // Get the time elapsed to calculate the reward\\n                uint256 timeElapsed;\\n\\n                // Never underflows\\n                unchecked {\\n                    // Calculate the time elapsed since the last reward distribution\\n                    timeElapsed = timestamp - shuttle.lastRewardTime;\\n                }\\n\\n                // Calculate the reward to be distributed based on the time elapsed and the pool's allocation point\\n                uint256 reward = (timeElapsed * cygPerBlockRewards * shuttle.allocPoint) / totalAllocPoint;\\n\\n                // Update the accumulated reward per share based on the reward distributed\\n                shuttle.accRewardPerShare += ((reward * ACC_PRECISION) / totalShares);\\n            }\\n\\n            // Store last block tiemstamp\\n            shuttle.lastRewardTime = timestamp;\\n        }\\n    }\\n\\n    /**\\n     *  @notice Updates all shuttles in the pillars. The shuttles are not the same as the `hangar18` shuttles,\\n     *          since 1 shuttle ID has 2 pillars ID.\\n     */\\n    function _accelerateTheUniverse() private {\\n        // Gas savings\\n        ShuttleInfo[] memory shuttles = _allShuttles;\\n\\n        // Length\\n        uint256 totalShuttles = shuttles.length;\\n\\n        // Loop through each shuttle and update all pools - Doesn't emit event\\n        for (uint256 i = 0; i < totalShuttles; i++) _updateShuttle(shuttles[i].borrowable, shuttles[i].collateral);\\n\\n        // Drip CYG to DAO reserves\\n        _dripCygDAO();\\n\\n        /// @custom:event AccelerateTheUniverse\\n        emit AccelerateTheUniverse(totalShuttles, msg.sender, getCurrentEpoch());\\n    }\\n\\n    /**\\n     *  @notice Collects the CYG the msg.sender has accrued and sends to `to`\\n     *  @param borrowable The address of the borrowable where borrows are stored\\n     *  @param to The address to send msg.sender's rewards to\\n     */\\n    function _collect(address borrowable, address collateral, address to) private returns (uint256 cygAmount) {\\n        // Update the pool to ensure the user's reward calculation is up-to-date.\\n        ShuttleInfo storage shuttle = _updateShuttle(borrowable, collateral);\\n\\n        // Retrieve the user's info for the specified borrowable address.\\n        UserInfo storage user = getUserInfo[borrowable][collateral][msg.sender];\\n\\n        // Avoid stack too deep\\n        {\\n            // Calculate the user's accumulated reward based on their shares and the pool's accumulated reward per share.\\n            int256 accumulatedReward = int256((user.shares * shuttle.accRewardPerShare) / ACC_PRECISION);\\n\\n            // Calculate the pending reward for the user by subtracting their stored reward debt from their accumulated reward.\\n            cygAmount = uint256(accumulatedReward - user.rewardDebt);\\n\\n            // If no rewards then return and don't collect\\n            if (cygAmount == 0) return 0;\\n\\n            // Update the user's reward debt to reflect the current accumulated reward.\\n            user.rewardDebt = accumulatedReward;\\n\\n            // Check for bonus rewards\\n            if (address(shuttle.bonusRewarder) != address(0)) {\\n                // Bonus rewarder is set, harvest\\n                shuttle.bonusRewarder.onReward(borrowable, collateral, msg.sender, to, cygAmount, user.shares);\\n            }\\n        }\\n\\n        // Get current epoch\\n        uint256 currentEpoch = getCurrentEpoch();\\n\\n        // Update total claimed for this epoch\\n        getEpochInfo[currentEpoch].totalClaimed += cygAmount;\\n\\n        // Check that total claimed this epoch is not above the max we can mint for this epoch\\n        if (getEpochInfo[currentEpoch].totalClaimed > getEpochInfo[currentEpoch].totalRewards) revert(\\\"Exceeds Epoch Limit\\\");\\n\\n        // Mint new CYG\\n        IERC20(cygToken).mint(to, cygAmount);\\n    }\\n\\n    /**\\n     *  @notice Drips CYG to the DAO reserves given the `cygPerBlockDAO` and time elapsed\\n     */\\n    function _dripCygDAO() private {\\n        // Calculate time since last dao claim\\n        uint256 currentTime = block.timestamp;\\n\\n        // Cyg accrued for the DAO\\n        uint256 _pendingCygDAO = (currentTime - lastDripDAO) * cygPerBlockDAO;\\n\\n        // Return if none accrued\\n        if (_pendingCygDAO == 0) return;\\n\\n        // Store current time\\n        lastDripDAO = currentTime;\\n\\n        // Latest DAO reserves contract\\n        address daoReserves = hangar18.daoReserves();\\n\\n        // Mint new CYG\\n        IERC20(cygToken).mint(daoReserves, _pendingCygDAO);\\n\\n        /// @custom:event CygnusDAODrip\\n        emit CygnusDAODrip(daoReserves, _pendingCygDAO);\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Main entry point into the Pillars contract to track borrowers and lenders.\\n     *  @notice Rewards are tracked only from borrowables. For borrowers, rewards are updated after any borrow,\\n     *          repay or liquidation (via the `_updateBorrow` function). For lenders, rewards are updated after\\n     *          any CygUSD mint, burn or transfer (via the `_afterTokenTransfer` function).\\n     *  @inheritdoc IPillarsOfCreation\\n     */\\n    function trackRewards(address account, uint256 balance, address collateral) external override {\\n        // Don't allow the DAO to receive CYG rewards from reserves\\n        if (account == address(0) || account == hangar18.daoReserves()) return;\\n\\n        // Interactions\\n        address borrowable = msg.sender;\\n\\n        // Update and load to storage for gas savings\\n        ShuttleInfo storage shuttle = _updateShuttle(borrowable, collateral);\\n\\n        // Get the user information for the borrower in the borrowable asset's pool\\n        UserInfo storage user = getUserInfo[borrowable][collateral][account];\\n\\n        // User's latest shares\\n        uint256 newShares = balance;\\n\\n        // Calculate the difference in shares for the borrower and update their shares\\n        int256 diffShares = int256(newShares) - int256(user.shares);\\n\\n        // Calculate the difference in reward debt for the borrower and update their reward debt\\n        int256 diffRewardDebt = (diffShares * int256(shuttle.accRewardPerShare)) / int256(ACC_PRECISION);\\n\\n        // Update shares\\n        user.shares = newShares;\\n\\n        // Update reward debt\\n        user.rewardDebt = user.rewardDebt + diffRewardDebt;\\n\\n        // Update the total shares of the pool of `borrowable` and `position`\\n        shuttle.totalShares = uint256(int256(shuttle.totalShares) + diffShares);\\n\\n        // Check if bonus rewarder is set\\n        if (address(shuttle.bonusRewarder) != address(0)) {\\n            // Assign shares for user to receive bonus rewards\\n            shuttle.bonusRewarder.onReward(borrowable, collateral, account, account, 0, newShares);\\n        }\\n\\n        /// @custom:event TrackShuttle\\n        emit TrackRewards(borrowable, account, balance, collateral);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security non-reentrant\\n     */\\n    function collect(\\n        address borrowable,\\n        bool borrowRewards,\\n        address to\\n    ) external override nonReentrant advance returns (uint256 cygAmount) {\\n        // Get collateral (lender rewards is the zero address, borrow rewards we get the borrowable's collateral)\\n        address collateral = _isBorrowRewards(borrowable, borrowRewards);\\n\\n        // Checks to see if there is any pending CYG to be collected and sends to user\\n        cygAmount = _collect(borrowable, collateral, to);\\n\\n        /// @custom:event Collect\\n        emit Collect(borrowable, collateral, to, cygAmount);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security non-reentrant\\n     */\\n    function collectAllSingle(address to, bool borrowRewards) external nonReentrant advance returns (uint256 cygAmount) {\\n        // Gas savings\\n        ShuttleInfo[] memory shuttles = _allShuttles;\\n\\n        // Length\\n        uint256 totalPools = shuttles.length;\\n\\n        // Loop through each shuttle\\n        for (uint256 i = 0; i < totalPools; i++) {\\n            // Get collateral\\n            address collateral = shuttles[i].collateral;\\n\\n            // If collecting borrow rewards then we skip if collateral is address zero (lenders)\\n            if (borrowRewards && collateral == address(0)) continue;\\n\\n            // If collecting lender rewards then we skip if collateral is not address zero\\n            if (!borrowRewards && collateral != address(0)) continue;\\n\\n            // Collect rewards\\n            cygAmount += _collect(shuttles[i].borrowable, collateral, to);\\n        }\\n\\n        /// @custom:event CollectAll\\n        emit CollectAllSingle(totalPools, cygAmount, borrowRewards);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security non-reentrant\\n     */\\n    function collectAll(address to) external override nonReentrant advance returns (uint256 cygAmount) {\\n        // Gas savings\\n        ShuttleInfo[] memory shuttles = _allShuttles;\\n\\n        // Length\\n        uint256 totalPools = shuttles.length;\\n\\n        // Loop through each shuttle\\n        for (uint256 i = 0; i < totalPools; i++) {\\n            // Collect lend rewards\\n            cygAmount += _collect(shuttles[i].borrowable, shuttles[i].collateral, to);\\n        }\\n\\n        /// @custom:event CollectAll\\n        emit CollectAll(totalPools, cygAmount);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security non-reentrant\\n     */\\n    function updateShuttle(address borrowable, bool borrowRewards) external override nonReentrant {\\n        // Get collateral (lender rewards is the zero address, borrow rewards we get the borrowable's collateral)\\n        address collateral = _isBorrowRewards(borrowable, borrowRewards);\\n\\n        // Update the borrower's pool for this borrowable\\n        _updateShuttle(borrowable, collateral);\\n\\n        /// @custom:event UpdateShuttle\\n        emit UpdateShuttle(borrowable, collateral, msg.sender, block.timestamp, getCurrentEpoch());\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security non-reentrant\\n     */\\n    function advanceEpoch() external override nonReentrant advance {}\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security non-reentrant\\n     */\\n    function accelerateTheUniverse() external override nonReentrant advance {\\n        // Manually updates all shuttles in the Pillars\\n        _accelerateTheUniverse();\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security non-reentrant\\n     */\\n    function dripCygDAO() external override nonReentrant advance {\\n        // Drip CYG to dao since `lastDripDAO`\\n        _dripCygDAO();\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security non-reentrant\\n     */\\n    function supernova() external override nonReentrant advance {\\n        // Manually updates all shuttles in the Pillars\\n        _accelerateTheUniverse();\\n\\n        // Tries to self destruct the contract\\n        _supernova();\\n    }\\n\\n    /*  -------------------------------------------------------------------------------------------------------  *\\n     *                                           ARTIFICER FUNCTIONS \ud83d\udee0\ufe0f                                          *\\n     *  -------------------------------------------------------------------------------------------------------  */\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-artificer-or-admin \ud83d\udee0\ufe0f\\n     */\\n    function setShuttleRewards(address borrowable, uint256 allocPoint, bool borrowRewards) external override advance {\\n        // Check if artificer is enabled, else check admin\\n        _checkArtificer();\\n\\n        // Get collateral (lender rewards is the zero address, borrow rewards we get the borrowable's collateral)\\n        address collateral = _isBorrowRewards(borrowable, borrowRewards);\\n\\n        // Load shuttle rewards\\n        ShuttleInfo storage shuttle = getShuttleInfo[borrowable][collateral];\\n\\n        /// @custom:error ShuttleAlreadyInitialized Avoid initializing shuttle rewards twice\\n        if (shuttle.active) revert PillarsOfCreation__ShuttleAlreadyInitialized();\\n\\n        // Update the total allocation points for Pillars\\n        totalAllocPoint = totalAllocPoint + allocPoint;\\n\\n        // Enable shuttle rewards, cannot be initialized again\\n        shuttle.active = true;\\n\\n        // Assign shuttle alloc points\\n        shuttle.allocPoint = allocPoint;\\n\\n        // Assign core contracts\\n        shuttle.borrowable = borrowable;\\n        shuttle.collateral = collateral; // _isBorrowRewards returns address zero for lender rewards\\n\\n        // Lending pool ID - Shared by borrow and lending rewards\\n        shuttle.shuttleId = ICygnusTerminal(borrowable).shuttleId();\\n\\n        // Unique reward pool ID\\n        shuttle.pillarsId = _allShuttles.length;\\n\\n        // Push to shuttles array\\n        _allShuttles.push(shuttle);\\n\\n        /// @custom:event NewShuttleRewards\\n        emit NewShuttleRewards(borrowable, collateral, totalAllocPoint, allocPoint);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-artificer-or-admin \ud83d\udee0\ufe0f\\n     */\\n    function adjustRewards(address borrowable, uint256 allocPoint, bool borrowRewards) external override advance {\\n        // Check if artificer is enabled, else check admin\\n        _checkArtificer();\\n\\n        // Get collateral (lending rewards use address(0) as collateral)\\n        address collateral = borrowRewards ? ICygnusTerminal(borrowable).collateral() : address(0);\\n\\n        // Load rewards\\n        ShuttleInfo storage shuttle = getShuttleInfo[borrowable][collateral];\\n\\n        /// @custom:error ShuttleAlreadyInitialized Avoid initializing twice\\n        if (!shuttle.active) revert PillarsOfCreation__ShuttleNotInitialized();\\n\\n        // Old alloc\\n        uint256 oldAlloc = shuttle.allocPoint;\\n\\n        // Update the total allocation points (lender rewards have already been set, or else we revert)\\n        totalAllocPoint = (totalAllocPoint - oldAlloc) + allocPoint;\\n\\n        // Assign new points\\n        shuttle.allocPoint = allocPoint;\\n\\n        // Update pool in array\\n        _allShuttles[shuttle.pillarsId].allocPoint = allocPoint;\\n\\n        /// @custom:event NewShuttleAllocPoint\\n        emit NewShuttleAllocPoint(borrowable, collateral, oldAlloc, allocPoint);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-artificer-or-admin \ud83d\udee0\ufe0f\\n     */\\n    function setBonusRewarder(address borrowable, bool borrowRewards, IBonusRewarder bonusRewarder) external override advance {\\n        // Check if artificer is enabled, else check admin\\n        _checkArtificer();\\n\\n        // Get collateral (lender rewards is the zero address, borrow rewards we get the borrowable's collateral)\\n        address collateral = _isBorrowRewards(borrowable, borrowRewards);\\n\\n        // Load lender rewards\\n        ShuttleInfo storage shuttle = getShuttleInfo[borrowable][collateral];\\n\\n        /// @custom:error ShuttleAlreadyInitialized Avoid initializing twice\\n        if (!shuttle.active) revert PillarsOfCreation__ShuttleNotInitialized();\\n\\n        // Assign bonus shuttle rewards\\n        shuttle.bonusRewarder = bonusRewarder;\\n\\n        /// @custom:event NewBonusRewarder\\n        emit NewBonusRewarder(borrowable, collateral, bonusRewarder);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-artificer-or-admin \ud83d\udee0\ufe0f\\n     */\\n    function removeBonusRewarder(address borrowable, bool borrowRewards) external override advance {\\n        // Check if artificer is enabled, else check admin\\n        _checkArtificer();\\n\\n        // Get collateral (lender rewards is the zero address, borrow rewards we get the borrowable's collateral)\\n        address collateral = _isBorrowRewards(borrowable, borrowRewards);\\n\\n        // Load lender rewards\\n        ShuttleInfo storage shuttle = getShuttleInfo[borrowable][collateral];\\n\\n        /// @custom:error ShuttleAlreadyInitialized Avoid initializing twice\\n        if (!shuttle.active) revert PillarsOfCreation__ShuttleNotInitialized();\\n\\n        // Assign bonus shuttle rewards\\n        shuttle.bonusRewarder = IBonusRewarder(address(0));\\n\\n        /// @custom:event NewBonusRewarder\\n        emit RemoveBonusRewarder(borrowable, collateral);\\n    }\\n\\n    /*  -------------------------------------------------------------------------------------------------------  *\\n     *                                             ADMIN FUNCTIONS \ud83d\udc7d                                            *\\n     *  -------------------------------------------------------------------------------------------------------  */\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-admin \ud83d\udc7d\\n     */\\n    function setArtificer(address _artificer) external override advance cygnusAdmin {\\n        // Artificer up until now\\n        address oldArtificer = artificer;\\n\\n        // Assign new artificer contract - Capable of adjusting shuttle rewards, bonus rewards, etc.\\n        artificer = _artificer;\\n\\n        /// @custom;event NewArtificer\\n        emit NewArtificer(oldArtificer, _artificer);\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-admin \ud83d\udc7d\\n     */\\n    function setDoomswitch() external override advance cygnusAdmin {\\n        // Set the doom switch, cannot be turned off!\\n        if (doomswitch) return;\\n\\n        // Set the doomswitch - Contract can self destruct now\\n        doomswitch = true;\\n\\n        /// @custom:event DoomSwitchSet\\n        emit DoomSwitchSet(block.timestamp, msg.sender, doomswitch);\\n    }\\n\\n    /**\\n     *  @notice This contract should never have any token balance, including CYG\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-admin \ud83d\udc7d\\n     */\\n    function sweepToken(address token) external override advance cygnusAdmin {\\n        // Balance this contract has of the erc20 token we are recovering\\n        uint256 balance = token.balanceOf(address(this));\\n\\n        // Transfer token to admin\\n        if (balance > 0) token.safeTransfer(msg.sender, balance);\\n\\n        /// @custom:event SweepToken\\n        emit SweepToken(token, msg.sender, balance, getCurrentEpoch());\\n    }\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-admin\\n     */\\n    function sweepNative() external override advance cygnusAdmin {\\n        // Get native balance\\n        uint256 balance = address(this).balance;\\n\\n        // Get ETH out\\n        if (balance > 0) SafeTransferLib.safeTransferETH(msg.sender, balance);\\n\\n        /// @custom:event SweepToken\\n        emit SweepToken(address(0), msg.sender, balance, getCurrentEpoch());\\n    }\\n\\n    /*  -------------------------------------------------------------------------------------------------------  *\\n     *                                  INITIALIZE PILLARS - CAN ONLY BE INIT ONCE                               *\\n     *  -------------------------------------------------------------------------------------------------------  */\\n\\n    /**\\n     *  @inheritdoc IPillarsOfCreation\\n     *  @custom:security only-admin \ud83d\udc7d\\n     */\\n    function initializePillars() external override cygnusAdmin {\\n        /// @custom:error PillarsAlreadyInitialized Avoid initializing pillars twice\\n        if (birth != 0) revert PillarsOfCreation__PillarsAlreadyInitialized();\\n\\n        // Calculate the cygPerBlock at epoch 0 for rewards\\n        cygPerBlockRewards = calculateCygPerBlock(0, totalCygRewards);\\n\\n        // Calculate the cygPerBlock for the DAO\\n        cygPerBlockDAO = calculateCygPerBlock(0, totalCygDAO);\\n\\n        // Gas savings\\n        uint256 _birth = block.timestamp;\\n\\n        // Birth of pillars\\n        birth = _birth;\\n\\n        // Timestamp of when the contract self-destructs\\n        death = _birth + DURATION;\\n\\n        // Start epoch\\n        lastEpochTime = _birth;\\n\\n        // Store the last drip as pillars initialized time\\n        lastDripDAO = _birth;\\n\\n        // Store epoch\\n        getEpochInfo[0] = EpochInfo({\\n            epoch: 0,\\n            start: _birth,\\n            end: _birth + BLOCKS_PER_EPOCH,\\n            cygPerBlock: cygPerBlockRewards,\\n            totalRewards: cygPerBlockRewards * BLOCKS_PER_EPOCH,\\n            totalClaimed: 0\\n        });\\n\\n        /// @custom;event InitializePillars\\n        emit InitializePillars(birth, death, cygPerBlockRewards, cygPerBlockDAO);\\n\\n        /// @custom:event NewEpoch\\n        emit NewEpoch(0, 0, 0, cygPerBlockRewards);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-token/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.17;\\n\\n/// @title ReentrancyGuard\\n/// @author Paul Razvan Berg\\n/// @notice Contract module that helps prevent reentrant calls to a function.\\n///\\n/// Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier available, which can be applied\\n/// to functions to make sure there are no nested (reentrant) calls to them.\\n///\\n/// Note that because there is a single `nonReentrant` guard, functions marked as `nonReentrant` may not\\n/// call one another. This can be worked around by making those functions `private`, and then adding\\n/// `external` `nonReentrant` entry points to them.\\n///\\n/// @dev Forked from OpenZeppelin\\n/// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v3.4.0/contracts/utils/ReentrancyGuard.sol\\nabstract contract ReentrancyGuard {\\n    /// CUSTOM ERRORS ///\\n\\n    /// @notice Emitted when there is a reentrancy call.\\n    error ReentrantCall();\\n\\n    /// PRIVATE STORAGE ///\\n\\n    bool private notEntered;\\n\\n    /// CONSTRUCTOR ///\\n\\n    /// Storing an initial non-zero value makes deployment a bit more expensive but in exchange the\\n    /// refund on every call to nonReentrant will be lower in amount. Since refunds are capped to a\\n    /// percetange of the total transaction's gas, it is best to keep them low in cases like this one,\\n    /// to increase the likelihood of the full refund coming into effect.\\n    constructor() {\\n        notEntered = true;\\n    }\\n\\n    /// MODIFIERS ///\\n\\n    /// @notice Prevents a contract from calling itself, directly or indirectly.\\n    /// @dev Calling a `nonReentrant` function from another `nonReentrant` function\\n    /// is not supported. It is possible to prevent this from happening by making\\n    /// the `nonReentrant` function external, and make it call a `private`\\n    /// function that does the actual work.\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, notEntered will be true.\\n        if (!notEntered) {\\n            revert ReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail.\\n        notEntered = false;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (https://eips.ethereum.org/EIPS/eip-2200).\\n        notEntered = true;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul[j]Tpeulxa[rul]xa[r]cLgvifCTUca[r]LSsTOtfDnca[r]Iulc]jmul[jul]VcTOculjmul\"\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IHangar18\",\"name\":\"_hangar18\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_totalCygRewardsBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalCygRewardsDAO\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PillarsOfCreation__InvalidTotalWeight\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PillarsOfCreation__MsgSenderNotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PillarsOfCreation__OnlyArtificer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PillarsOfCreation__PillarsAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PillarsOfCreation__ShuttleAlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PillarsOfCreation__ShuttleNotInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrantCall\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"shuttlesLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"AccelerateTheUniverse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Collect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPools\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"CollectAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalPools\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"}],\"name\":\"CollectAllSingle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"CygnusDAODrip\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"doomswitch\",\"type\":\"bool\"}],\"name\":\"DoomSwitchSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"birth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"death\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cygPerBlockRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_cygPerBlockDAO\",\"type\":\"uint256\"}],\"name\":\"InitializePillars\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldArtificer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newArtificer\",\"type\":\"address\"}],\"name\":\"NewArtificer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"contract IBonusRewarder\",\"name\":\"bonusRewarder\",\"type\":\"address\"}],\"name\":\"NewBonusRewarder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastRewardRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRewardRate\",\"type\":\"uint256\"}],\"name\":\"NewCygPerBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newEpoch\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_oldCygPerBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_newCygPerBlock\",\"type\":\"uint256\"}],\"name\":\"NewEpoch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldAllocPoint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAllocPoint\",\"type\":\"uint256\"}],\"name\":\"NewShuttleAllocPoint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAlloc\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"alloc\",\"type\":\"uint256\"}],\"name\":\"NewShuttleRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"RemoveBonusRewarder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_birth\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_death\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"Supernova\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentEpoch\",\"type\":\"uint256\"}],\"name\":\"SweepToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"TrackRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"UpdateShuttle\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BLOCKS_PER_EPOCH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REDUCTION_FACTOR_PER_EPOCH\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SECONDS_PER_YEAR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_EPOCHS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accelerateTheUniverse\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"}],\"name\":\"adjustRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"advanceEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pillarsId\",\"type\":\"uint256\"}],\"name\":\"allShuttles\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shuttleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IBonusRewarder\",\"name\":\"bonusRewarder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pillarsId\",\"type\":\"uint256\"}],\"internalType\":\"struct IPillarsOfCreation.ShuttleInfo\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artificer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"artificerEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"birth\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksThisEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"}],\"name\":\"calculateCygPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewardRate\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"}],\"name\":\"calculateEpochRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rewards\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"collect\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cygAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"collectAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cygAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"}],\"name\":\"collectAllSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cygAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpochRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEpochRewardsDAO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cygPerBlockDAO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cygPerBlockRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cygToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dateCurrentEpochStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"dateEpochEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"dateEpochStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dateLastEpochStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dateNextEpochStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dateSupernova\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daysPassedThisEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daysUntilNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daysUntilSupernova\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"death\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fromTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toTimestamp\",\"type\":\"uint256\"}],\"name\":\"diffDays\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doomswitch\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dripCygDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"}],\"name\":\"emissionsCurve\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochProgression\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochRewardsPacing\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"currentEpoch\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getEpochInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"epoch\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cygPerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"end\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shuttleId\",\"type\":\"uint256\"}],\"name\":\"getShuttleById\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shuttleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IBonusRewarder\",\"name\":\"bonusRewarder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pillarsId\",\"type\":\"uint256\"}],\"internalType\":\"struct IPillarsOfCreation.ShuttleInfo\",\"name\":\"lenders\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shuttleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IBonusRewarder\",\"name\":\"bonusRewarder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pillarsId\",\"type\":\"uint256\"}],\"internalType\":\"struct IPillarsOfCreation.ShuttleInfo\",\"name\":\"borrowers\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getShuttleInfo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"shuttleId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accRewardPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IBonusRewarder\",\"name\":\"bonusRewarder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pillarsId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"rewardDebt\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hangar18\",\"outputs\":[{\"internalType\":\"contract IHangar18\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initializePillars\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastDripDAO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastEpochTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextEpochRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingBonusReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"}],\"name\":\"pendingCyg\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"pendingCygAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingCygDAO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"}],\"name\":\"pendingCygSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"pending\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousEpochRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"}],\"name\":\"removeBonusRewarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_artificer\",\"type\":\"address\"}],\"name\":\"setArtificer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"},{\"internalType\":\"contract IBonusRewarder\",\"name\":\"bonusRewarder\",\"type\":\"address\"}],\"name\":\"setBonusRewarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setDoomswitch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"}],\"name\":\"setShuttleRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shuttlesLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supernova\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"timestampToDateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"year\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"month\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hour\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minute\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"second\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCygClaimed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"claimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCygDAO\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCygRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalProgression\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"trackRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"untilNextEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"untilSupernova\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"borrowRewards\",\"type\":\"bool\"}],\"name\":\"updateShuttle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "PillarsOfCreation", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "0000000000000000000000008796747946871b6b8ea495cce8d7814b17959296000000000000000000000000c553a5a789f1bb56a72847b3fda1de3e16e6763f00000000000000000000000000000000000000000001a784379d99db420000000000000000000000000000000000000000000000000029c9027aab57d3140000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}