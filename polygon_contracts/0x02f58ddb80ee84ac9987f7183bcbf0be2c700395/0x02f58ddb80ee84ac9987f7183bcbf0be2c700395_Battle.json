{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Battle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"./interfaces/IBattleToken.sol\\\";\\nimport \\\"./interfaces/IBattleDice.sol\\\";\\n\\nenum PieceType {\\n    PLAYER,\\n    WEAPON\\n}\\n\\nstruct Piece {\\n    uint32 id; // tokenId of player, or ID of weapon\\n    uint32 data; // id of weapon if held by player\\n    uint8 data2; // kills\\n    uint16 game; // game that this piece belongs to\\n    uint16 lastMove; // last move if it a player\\n    PieceType pieceType; // PLAYER, WEAPON\\n    int8 x; // x pos\\n    int8 y; // y pos\\n    int8[7] stats; // array of weapon or player stats\\n}\\n\\nstruct Game {\\n    uint32 startTime; // timestamp of beginning of game\\n    uint16 lastBattle; // turn number of the last battle\\n    uint8 players; // number of players\\n    uint8 remaining; // number of remaining players\\n    mapping(int8 => mapping(int8 => uint32)) board; // board game\\n}\\n\\nuint256 constant FEE_ENTRY = 0 ether;\\nuint256 constant STALEMATE_TURNS = 6;\\nuint256 constant PERCENT_OWNER = 51;\\nuint32 constant TOKEN_MAX = 800;\\n\\n/// @author AnAllergyToAnalogy\\n/// @title Big Head Club Doomies Main Contract\\n/// @notice Main Doomies contract, it has all the externally-facing battle and mint functions (not ERC721 stuff tho)\\ncontract Battle is Ownable {\\n\\n    event NewGame(uint16 indexed game);\\n\\n    event Move(\\n        uint32 indexed tokenId,\\n        int8 x,\\n        int8 y,\\n        uint16 indexed game,\\n        uint16 turn,\\n        uint32 data\\n    );\\n    event BattleLog(\\n        uint32 indexed player1,\\n        uint32 indexed player2,\\n        int256[8] rolls1,\\n        int256[8] rolls2,\\n        uint32 winner,\\n        uint16 indexed game,\\n        uint16 turn\\n    );\\n    event Mint(\\n        uint32 indexed tokenId,\\n        int8[7] stats\\n    );\\n    event NewWeapon(\\n        uint32 indexed pieceId,\\n        int8[7] stats,\\n        uint16 indexed game\\n    );\\n    event WithdrawWinnings(\\n        uint32 tokenId,\\n        uint16 indexed game,\\n        uint256 amount\\n    );\\n\\n    uint256 public turnTime = 1 days;\\n    address token;\\n    address dice;\\n    uint32 ownerWithdrawn;\\n    uint32 public lastTokenId;\\n    uint32 lastWeaponId = TOKEN_MAX;\\n\\n    //This exposes a public method like this:\\n    // function game() public view returns(uint);\\n    //  returns the current game number\\n    uint16 public game;\\n\\n    //This exposes a public method like this:\\n    // function games(uint _game) public view returns(Game);\\n    //  it will return the Game struct for the given game number, not including the board\\n    mapping(uint256 => Game) public games;\\n\\n    //This exposes a public method like this:\\n    // function pieces(uint _pieceId) public view returns(Piece);\\n    //  it will return the Piece struct for the given id, not including the stats array\\n    mapping(uint32 => Piece) public pieces;\\n\\n\\n\\n\\n    constructor(address _token, address _dice) {\\n        token = _token;\\n        dice = _dice;\\n    }\\n\\n    // Enters token into game\\n    //  takes the following params:\\n    //      tokenId: id of token\\n    //      startX:  x coord to start form\\n    //      startY:  y coord to start form\\n\\n    //  player must own the token\\n    //  token can't have been entered into this or a previous game\\n    //  game has to be active,\\n    //  has to be entry time of the game (ie, turn = 0)\\n    //  has to be on the edge of map, only on every second space\\n    //  has to be on an empty tile\\n\\n    //Emits the following events\\n    // from main contract\\n    //   event Move(tokenId, startX, startY, game number, turn number, type(uint32).max - 1);\\n    //    you can infer that a Move event is an 'enter game' event by either lookin at turn number == 0\\n    //                                                          or the data property = type(uint32).max - 1\\n    function enterGame(\\n        uint32 tokenId,\\n        int8 startX,\\n        int8 startY\\n    ) public {\\n        require(IBattleToken(token).ownerOf(tokenId) == msg.sender, \\\"owner\\\");\\n\\n        require(pieces[tokenId].game == 0, \\\"entered\\\");\\n\\n        require(gameIsActive(), \\\"game not active\\\");\\n        require(turnNumber() == 0, \\\"not entry time\\\");\\n\\n        require(\\n            startX == 0 || startY == 0 || startX == 8 || startY == 8,\\n            \\\"edge\\\"\\n        );\\n        require(startX % 2 == 0 && startY % 2 == 0, \\\"position\\\");\\n        require(games[game].board[startX][startY] == 0, \\\"occupied\\\");\\n\\n        games[game].board[startX][startY] = tokenId;\\n        ++games[game].players;\\n        ++games[game].remaining;\\n\\n        pieces[tokenId].game = game;\\n        pieces[tokenId].x = startX;\\n        pieces[tokenId].y = startY;\\n\\n        emit Move(\\n            tokenId,\\n            startX,\\n            startY,\\n            game,\\n            turnNumber(),\\n            type(uint32).max - 1\\n        );\\n\\n        if (games[game].players == 16) {\\n            games[game].startTime = uint32(block.timestamp - turnTime);\\n        }\\n    }\\n\\n    //Mints token,\\n    // Requires msg value of FEE_ENTRY\\n    //  will fail if token max has been reached\\n    //  this rolls the stats of the token\\n\\n    //Emits the following events\\n    // from Token contract:\\n    //      Transfer( 0x0, msg.sender, tokenId)\\n    // from main contract\\n    //      event Mint(tokenId, int8[7] stats );\\n    function mint() public payable onlyOwner{\\n        require(gasleft() > 200000, \\\"gas failsafe\\\");\\n\\n        require(msg.sender == tx.origin, \\\"no contracts\\\");\\n        require(msg.value == FEE_ENTRY, \\\"FEE_ENTRY\\\");\\n        require(lastTokenId < TOKEN_MAX, \\\"supply limit\\\");\\n\\n        IBattleToken(token).mint(msg.sender, ++lastTokenId);\\n\\n        pieces[lastTokenId] = Piece(\\n            lastTokenId,\\n            0,\\n            0,\\n            0,\\n            0,\\n            PieceType.PLAYER,\\n            0,\\n            0,\\n            IBattleDice(dice).rollPlayerStats()\\n        );\\n\\n        emit Mint(lastTokenId, pieces[lastTokenId].stats);\\n    }\\n\\n    //Moves a token\\n    //  takes the following params:\\n    //      tokenId: id of the token\\n    //      dx: how far to move in x direction\\n    //      dy: how far to move in y direction\\n\\n    //  player must own the token\\n    //  game must be active\\n    //  can't be in entry time (ie turnNumber = 0)\\n    //  can't have moved this turn\\n    //  can't do it if token has died\\n    //  can't do it if not in this game\\n    //  can't do it if sender is a contract\\n    //  can't do it trying to move more than 1 square away\\n    //  can't not move at all in tx\\n    //  can't move off map\\n\\n    //Emits the following events\\n    // from main contract\\n\\n    // if the player moves to an empty square, a weapon square, or an occupied square and then succeeds at the battle:\\n    //  emit Move(tokenId, toX, toY, game number, turn number, 0);\\n\\n    // if there is a battle, it will emit the following event BEFORE the Move event\\n    //  emit BattleLog(player id, opponent id, player's rolls,  opponent's rolls, id of victor, turn number, game number);\\n    //   where rolls are arrays of the dice rolls for each player for each stat.\\n    //      in the case where it's a draw, the winner will have a 1 in their final slot. otherwise that's unused.\\n\\n    function move(\\n        uint32 tokenId,\\n        int8 dx,\\n        int8 dy\\n    ) public {\\n        require(gasleft() > 200000, \\\"gas failsafe\\\");\\n        require(IBattleToken(token).ownerOf(tokenId) == msg.sender, \\\"owner\\\");\\n\\n        require(gameIsActive(), \\\"game not active\\\");\\n        require(turnNumber() != 0, \\\"still entry time\\\");\\n        require(pieces[tokenId].lastMove < turnNumber(), \\\"already moved\\\");\\n        require(pieces[tokenId].game == game, \\\"not in game\\\");\\n        require(pieces[tokenId].data != type(uint32).max, \\\"token dead\\\");\\n\\n        require(msg.sender == tx.origin, \\\"no contracts\\\");\\n        require(dx >= -1 && dx <= 1 && dy >= -1 && dy <= 1, \\\"range\\\");\\n        require(!(dx == 0 && dy == 0), \\\"stationary\\\");\\n\\n        Piece memory piece = pieces[tokenId];\\n\\n        int8 toX = piece.x + dx;\\n        int8 toY = piece.y + dy;\\n\\n        require(toX >= 0 && toX <= 8 && toY >= 0 && toY <= 8, \\\"bounds\\\");\\n\\n        delete games[game].board[piece.x][piece.y];\\n\\n        uint32 target = games[game].board[toX][toY];\\n\\n        if (target == 0) {\\n            //space empty, Just move\\n            games[game].board[toX][toY] = tokenId;\\n            pieces[tokenId].x = toX;\\n            pieces[tokenId].y = toY;\\n            pieces[tokenId].lastMove = turnNumber();\\n\\n            emit Move(tokenId, toX, toY, game, turnNumber(), 0);\\n        } else if (pieces[target].pieceType == PieceType.WEAPON) {\\n            //Weapon, pickup\\n            if (piece.data != 0) {\\n                //kill the current weapon\\n                delete pieces[piece.data];\\n            }\\n            pieces[tokenId].data = target;\\n\\n            games[game].board[toX][toY] = tokenId;\\n            pieces[tokenId].x = toX;\\n            pieces[tokenId].y = toY;\\n            pieces[tokenId].lastMove = turnNumber();\\n\\n            emit Move(tokenId, toX, toY, game, turnNumber(), target);\\n        } else {\\n            //Player, battle\\n\\n            games[game].lastBattle = turnNumber();\\n\\n            uint32 victor = _battle(tokenId, target);\\n\\n            if (tokenId == victor) {\\n                //player wins\\n\\n                //flag enemy token as dead\\n                pieces[target].data = type(uint32).max;\\n\\n                games[game].board[toX][toY] = tokenId;\\n                pieces[tokenId].x = toX;\\n                pieces[tokenId].y = toY;\\n                pieces[tokenId].lastMove = turnNumber();\\n\\n                ++pieces[tokenId].data2;\\n\\n                emit Move(tokenId, toX, toY, game, turnNumber(), 0);\\n            } else {\\n                //enemy wins\\n                pieces[tokenId].data = type(uint32).max;\\n\\n                ++pieces[target].data2;\\n            }\\n            --games[game].remaining;\\n        }\\n    }\\n\\n    function withdrawWinnings(uint32 tokenId) public {\\n        require(IBattleToken(token).ownerOf(tokenId) == msg.sender, \\\"owner\\\");\\n\\n        Piece memory piece = pieces[tokenId];\\n\\n        require(piece.game < game || !gameIsActive(), \\\"not yet winner\\\");\\n        require(pieces[tokenId].data < type(uint32).max, \\\"no winnings\\\");\\n\\n        uint256 toWithdraw;\\n\\n        if (games[piece.game].remaining == 1) {\\n            //Single Winner\\n            toWithdraw =\\n            (games[piece.game].players *\\n            FEE_ENTRY *\\n            (100 - PERCENT_OWNER)) /\\n            100;\\n        } else {\\n            uint256 eliminated = games[piece.game].players -\\n            games[piece.game].remaining;\\n            if (eliminated > 0) {\\n                toWithdraw =\\n                (((uint256(piece.data2) *\\n                games[piece.game].players *\\n                FEE_ENTRY) / eliminated) * (100 - PERCENT_OWNER)) /\\n                100;\\n            } else {\\n                toWithdraw =\\n                (games[piece.game].players *\\n                FEE_ENTRY *\\n                (100 - PERCENT_OWNER)) /\\n                100;\\n            }\\n        }\\n\\n        pieces[tokenId].data = type(uint32).max;\\n\\n        emit WithdrawWinnings(tokenId, piece.game, toWithdraw);\\n\\n        payable(msg.sender).transfer(toWithdraw);\\n    }\\n\\n    function ownerWithdraw() public onlyOwner {\\n        require(ownerWithdrawn < lastTokenId, \\\"withdrawn\\\");\\n\\n        uint256 toWithdraw = (uint256(lastTokenId - ownerWithdrawn) *\\n        FEE_ENTRY *\\n        PERCENT_OWNER) / 100;\\n\\n        ownerWithdrawn = lastTokenId;\\n\\n        payable(msg.sender).transfer(toWithdraw);\\n    }\\n\\n    function updateTurnTime(uint256 _turnTime) public onlyOwner {\\n        require(!gameIsActive(), \\\"game active\\\");\\n        turnTime = _turnTime;\\n    }\\n\\n    // call this to start the game\\n    //  can't be called by non contract owner\\n    //  cant be called if game in progress\\n    function startGame() public {\\n        require(gasleft() > 1250000, \\\"gas failsafe\\\");\\n\\n        require(!gameIsActive(), \\\"game active\\\");\\n        game++;\\n\\n        games[game].startTime = uint32(block.timestamp);\\n\\n        for (int8 x = 3; x <= 5; x++) {\\n            for (int8 y = 3; y <= 5; y++) {\\n                if (x == 4 && y == 4) continue;\\n\\n                games[game].board[x][y] = ++lastWeaponId;\\n                games[game].lastBattle = 1;\\n\\n                pieces[lastWeaponId] = Piece(\\n                    lastWeaponId,\\n                    0,\\n                    0,\\n                    game,\\n                    0,\\n                    PieceType.WEAPON,\\n                    x,\\n                    y,\\n                    IBattleDice(dice).rollWeaponStats(lastWeaponId)\\n                );\\n\\n                emit NewWeapon(lastWeaponId, pieces[lastWeaponId].stats, game);\\n            }\\n        }\\n        emit NewGame(game);\\n    }\\n\\n    // returns true if game is currently active\\n    function gameIsActive() public view returns (bool) {\\n        return\\n        game != 0 &&\\n        (turnNumber() == 0 ||\\n        !(turnNumber() > games[game].lastBattle + STALEMATE_TURNS ||\\n        games[game].remaining < 2));\\n    }\\n\\n    // returns a 9x9 array of current board, with ids of pieces\\n    function getTile(int8 x, int8 y) public view returns (uint32) {\\n        return games[game].board[x][y];\\n\\n    }\\n\\n    // return stats array of a given piece\\n    function getStats(uint32 pieceId) public view returns (int8[7] memory) {\\n        return pieces[pieceId].stats;\\n    }\\n\\n    // returns true if a token hasnt been put in a game\\n    function tokenIsUnused(uint32 tokenId) public view returns (bool) {\\n        return pieces[tokenId].game == 0;\\n    }\\n\\n    function _battle(uint32 player1, uint32 player2) internal returns (uint32) {\\n        (\\n            uint32 victor,\\n            int256[8] memory rolls1,\\n            int256[8] memory rolls2\\n        ) = IBattleDice(dice).battle(\\n                player1,\\n                player2,\\n                pieces[player1].stats,\\n                pieces[pieces[player1].data].stats,\\n                pieces[player2].stats,\\n                pieces[pieces[player2].data].stats\\n            );\\n        emit BattleLog(\\n            player1,\\n            player2,\\n            rolls1,\\n            rolls2,\\n            victor,\\n            turnNumber(),\\n            game\\n        );\\n\\n        return victor;\\n    }\\n\\n    // returns the current turn number of the current game\\n    function turnNumber() private view returns (uint16) {\\n        return\\n            uint16(\\n                (block.timestamp - uint256(games[game].startTime)) / turnTime\\n            );\\n    }\\n\\n\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBattleDice.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface IBattleDice {\\n    function rollPlayerStats() external view returns (int8[7] memory stats);\\n\\n    function rollWeaponStats(uint32 salt)\\n        external\\n        view\\n        returns (int8[7] memory stats);\\n\\n    function battle(\\n        uint32 player1,\\n        uint32 player2,\\n        int8[7] memory stats1,\\n        int8[7] memory weapon1,\\n        int8[7] memory stats2,\\n        int8[7] memory weapon2\\n    )\\n        external\\n        view\\n        returns (\\n            uint32 victor,\\n            int256[8] memory rolls1,\\n            int256[8] memory rolls2\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IBattleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\ninterface IBattleToken {\\n    function mint(address to, uint256 tokenId) external;\\n\\n    function burn(uint256 tokenId) external;\\n\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dice\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"player1\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"player2\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int256[8]\",\"name\":\"rolls1\",\"type\":\"int256[8]\"},{\"indexed\":false,\"internalType\":\"int256[8]\",\"name\":\"rolls2\",\"type\":\"int256[8]\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"winner\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"turn\",\"type\":\"uint16\"}],\"name\":\"BattleLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int8[7]\",\"name\":\"stats\",\"type\":\"int8[7]\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"x\",\"type\":\"int8\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"y\",\"type\":\"int8\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"turn\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"data\",\"type\":\"uint32\"}],\"name\":\"Move\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"}],\"name\":\"NewGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"pieceId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int8[7]\",\"name\":\"stats\",\"type\":\"int8[7]\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"}],\"name\":\"NewWeapon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawWinnings\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"int8\",\"name\":\"startX\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"startY\",\"type\":\"int8\"}],\"name\":\"enterGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"game\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"lastBattle\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"players\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"remaining\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"pieceId\",\"type\":\"uint32\"}],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"int8[7]\",\"name\":\"\",\"type\":\"int8[7]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"x\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"y\",\"type\":\"int8\"}],\"name\":\"getTile\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTokenId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"int8\",\"name\":\"dx\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"dy\",\"type\":\"int8\"}],\"name\":\"move\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"pieces\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"data\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"data2\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lastMove\",\"type\":\"uint16\"},{\"internalType\":\"enum PieceType\",\"name\":\"pieceType\",\"type\":\"uint8\"},{\"internalType\":\"int8\",\"name\":\"x\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"y\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"tokenIsUnused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_turnTime\",\"type\":\"uint256\"}],\"name\":\"updateTurnTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"withdrawWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Battle", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d2655a6f125cca3383e11755da3c21fe1d77dae30000000000000000000000006992cc84c28d1b84ecaf132f47d68817147b4143", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}