{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC721.sol\\\";\\nimport \\\"./IERC721Receiver.sol\\\";\\nimport \\\"./extensions/IERC721Metadata.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"../../utils/Strings.sol\\\";\\nimport \\\"../../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: address zero is not a valid owner\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _ownerOf(tokenId);\\n        require(owner != address(0), \\\"ERC721: invalid token ID\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        _requireMinted(tokenId);\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overridden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not token owner or approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        _requireMinted(tokenId);\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: caller is not token owner or approved\\\");\\n        _safeTransfer(from, to, tokenId, data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\\n     */\\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\\n        return _owners[tokenId];\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _ownerOf(tokenId) != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\\n\\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        unchecked {\\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\\n            // Given that tokens are minted one by one, it is impossible in practice that\\n            // this ever happens. Might change if we allow batch minting.\\n            // The ERC fails to describe this case.\\n            _balances[to] += 1;\\n        }\\n\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\\n\\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\\n        owner = ERC721.ownerOf(tokenId);\\n\\n        // Clear approvals\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // Cannot overflow, as that would require more tokens to be burned/transferred\\n            // out than the owner initially received through minting and transferring in.\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId, 1);\\n\\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer from incorrect owner\\\");\\n\\n        // Clear approvals from the previous owner\\n        delete _tokenApprovals[tokenId];\\n\\n        unchecked {\\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\\n            // `from`'s balance is the number of token held, which is at least one before the current\\n            // transfer.\\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\\n            // all 2**256 token ids to be minted, which in practice is impossible.\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId, 1);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Reverts if the `tokenId` has not been minted yet.\\n     */\\n    function _requireMinted(uint256 tokenId) internal view virtual {\\n        require(_exists(tokenId), \\\"ERC721: invalid token ID\\\");\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    /// @solidity memory-safe-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\\n     * - When `from` is zero, the tokens will be minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256, /* firstTokenId */\\n        uint256 batchSize\\n    ) internal virtual {\\n        if (batchSize > 1) {\\n            if (from != address(0)) {\\n                _balances[from] -= batchSize;\\n            }\\n            if (to != address(0)) {\\n                _balances[to] += batchSize;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\\n     * - When `from` is zero, the tokens were minted for `to`.\\n     * - When `to` is zero, ``from``'s tokens were burned.\\n     * - `from` and `to` are never both zero.\\n     * - `batchSize` is non-zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC721.sol\\\";\\nimport \\\"./IERC721Enumerable.sol\\\";\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n */\\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721.balanceOf(owner), \\\"ERC721Enumerable: owner index out of bounds\\\");\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(index < ERC721Enumerable.totalSupply(), \\\"ERC721Enumerable: global index out of bounds\\\");\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev See {ERC721-_beforeTokenTransfer}.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 firstTokenId,\\n        uint256 batchSize\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\\n\\n        if (batchSize > 1) {\\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\\n            revert(\\\"ERC721Enumerable: consecutive transfers not supported\\\");\\n        }\\n\\n        uint256 tokenId = firstTokenId;\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/extras/recovery/BlackHolePrevention.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\ncontract BlackHolePrevention is Ownable {\\n    // blackhole prevention methods\\n    function retrieveETH() external onlyOwner {\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n    \\n    function retrieveERC20(address _tracker, uint256 amount) external onlyOwner {\\n        IERC20(_tracker).transfer(msg.sender, amount);\\n    }\\n\\n    function retrieve721(address _tracker, uint256 id) external onlyOwner {\\n        IERC721(_tracker).transferFrom(address(this), msg.sender, id);\\n    }\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRandomNumberProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\ninterface IRandomNumberProvider {\\n    function requestRandomNumber() external returns (uint256 requestId);\\n    function requestRandomNumberWithCallback() external returns (uint256);\\n    function isRequestComplete(uint256 requestId) external view returns (bool isCompleted);\\n    function randomNumber(uint256 requestId) external view returns (uint256 randomNum);\\n    function setAuth(address user, bool grant) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IRandomNumberRequester.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\ninterface IRandomNumberRequester {\\n    function process(uint256 rand, uint256 requestId) external;\\n}\\n\"\r\n    },\r\n    \"contracts/invest/Invest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"../traits/Implementers/ProjectInvestImplementer.sol\\\";\\nimport \\\"../traits/Implementers/UserInvestmentImplementer.sol\\\";\\nimport \\\"../traits/Implementers/TraitUint8ValueImplementer.sol\\\";\\nimport \\\"../traits/Implementers/ReinvestRequestImplementer.sol\\\";\\nimport \\\"../traits/TraitRegistryV3.sol\\\";\\nimport \\\"../nft/token/ActivatableToken.sol\\\";\\nimport \\\"../nft/sale/ExchangeRegistry.sol\\\";\\n\\ninterface SimpleERC20Interface {\\n    function balanceOf(address account) external view returns (uint256);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n}\\n\\n//Error codes\\nuint8 constant ERR_CODE_SUCCESS = 0;\\nuint8 constant ERR_PROJECT_DOES_NOT_EXIST = 1;\\nuint8 constant ERR_USER_NOT_ACTIVE_TOKEN = 2;\\nuint8 constant ERR_FUNDING_NOT_STARTED = 3;\\nuint8 constant ERR_FUNDING_ENDED = 4;\\nuint8 constant ERR_INVESTMENT_BELOW_MIN = 5;\\nuint8 constant ERR_INVESTMENT_ABOVE_MAX = 6;\\nuint8 constant ERR_FUNDING_ABOVE_MAX = 7;\\nuint8 constant ERR_INSUFFICIENT_FUNDS = 8;\\n\\n//Event types\\nuint8 constant INVEST_TYPE_CRYPTO = 0; //USDC invest by user\\nuint8 constant INVEST_TYPE_FIAT = 1; //Fiat invest added by SC owner\\nuint8 constant INVEST_TYPE_REINVEST_REQUEST = 2; //User made a reinvest request\\nuint8 constant INVEST_TYPE_REINVEST = 3; //Reinvest executed on payout\\nuint8 constant INVEST_TYPE_PAYOUT_CRYPTO = 4; //Payout in crypto to user\\nuint8 constant INVEST_TYPE_PAYOUT_FIAT = 5; //Balance for fiat was decremented from proj and added to user\\nuint8 constant INVEST_TYPE_PAYOUT_RETURN = 6; //Return of investment to user\\nuint8 constant INVEST_TYPE_PAYOUT_FIAT_DONE = 7; //After marking payment as done, this event is fired.\\nuint8 constant INVEST_TYPE_PAYOUT_CRYPTO_FAILED_FUNDING = 8; //if fundding fails and crypto is returned to investor\\nuint8 constant INVEST_TYPE_PAYOUT_FIAT_FAILED_FUNDING = 9; //if fundding fails and fiat is returned to user\\n\\n//currency\\nuint8 constant CURRENCY_EUR = 0;\\nuint8 constant CURRENCY_USD = 1;\\nuint8 constant CURRENCY_RON = 2;\\nuint8 constant CURRENCY_USDC = 128;\\n\\n//event type\\nuint8 constant EVENT_TYPE_NEW_PROJECT = 0;\\nuint8 constant EVENT_TYPE_UPDATE_PROJECT = 1;\\n\\n\\n\\ncontract Invest is Ownable {\\n    event InvestEvent(uint8 evType, uint32 fromProjId, uint32 toProjId, uint16 tokenId, uint256 value, bool isCrypto, uint8 currency);\\n    event ProjectEvent(uint8 eventType, ProjectInvestImplementer.Project project, address destinationWallet, string uid);\\n\\n    TraitRegistryV3 public traitRegistry;\\n    ActivatableToken public token;\\n    ExchangeRegistry public exchangeRegistry;\\n\\n    ProjectInvestImplementer public projectInvestImplementer;\\n    UserInvestmentImplementer public userInvestmentImplementer;\\n    ReinvestRequestImplementer public reinvestRequestImplementer;\\n    TraitUint8ValueImplementer public activatedTraitImplementer;\\n    string public constant version = \\\"1.0.0\\\";\\n\\n    mapping (address => bool) public allowedFiatInvest;\\n\\n    constructor(address _traitRegistryAddress, \\n                address _tokenAddress, \\n                uint16 _projectsTraitId, \\n                uint16 _userInvetmentTraitId, \\n                uint16 _reinvestmentTraitId ,\\n                uint16 _activatedTraitId,\\n                address _exchangeRegistryAddress) {\\n        require(_traitRegistryAddress != address(0), \\\"Invest: traitRegistryAddress is zero\\\");\\n        require(_tokenAddress != address(0), \\\"Invest: tokenAddress is zero\\\");\\n        require(_exchangeRegistryAddress != address(0), \\\"Invest: exchangeRegistryAddress is zero\\\");\\n        traitRegistry = TraitRegistryV3(_traitRegistryAddress);\\n        token = ActivatableToken(_tokenAddress);\\n        exchangeRegistry = ExchangeRegistry(_exchangeRegistryAddress);\\n\\n        projectInvestImplementer = ProjectInvestImplementer(traitRegistry.getImplementer(_projectsTraitId));\\n        userInvestmentImplementer = UserInvestmentImplementer(traitRegistry.getImplementer(_userInvetmentTraitId));\\n        reinvestRequestImplementer = ReinvestRequestImplementer(traitRegistry.getImplementer(_reinvestmentTraitId));\\n        activatedTraitImplementer = TraitUint8ValueImplementer(traitRegistry.getImplementer(_activatedTraitId));\\n    }\\n\\n    function addProject(ProjectInvestImplementer.Project memory proj, address destWallet, string calldata uid) external onlyOwner returns (uint32) {\\n        uint32 id = projectInvestImplementer.addProject(proj, destWallet, uid);\\n        proj.id = id;\\n        emit ProjectEvent(EVENT_TYPE_NEW_PROJECT ,proj, destWallet, uid);\\n        return proj.id;\\n    }\\n\\n    function updateProject(ProjectInvestImplementer.Project memory proj, address destWallet, uint32 projectId ) external onlyOwner {\\n        projectInvestImplementer.updateProject(proj, destWallet, projectId);\\n        emit ProjectEvent(EVENT_TYPE_UPDATE_PROJECT ,proj, destWallet, \\\"\\\");\\n    }\\n\\n    function getProject(uint32 projectId) external view returns (ProjectInvestImplementer.Project memory) {\\n        return projectInvestImplementer.getProject(projectId);\\n    }\\n\\n    function userHasActiveToken(uint16 _tokenId, address user) public view returns (bool){\\n        return token.ownerOf(_tokenId) == user && (activatedTraitImplementer.getValue(_tokenId) == 1 || activatedTraitImplementer.getValue(_tokenId) == 2);\\n    }\\n\\n    function invest(uint32 projectId, uint16 tokenId, uint256 amount) external {\\n        ProjectInvestImplementer.Project memory project = projectInvestImplementer.getProject(projectId); //throws error if project does not exist\\n        require(project.erc20PaymentTokenAddress != address(0), \\\"ERC20 payment token address not set\\\");\\n        SimpleERC20Interface paymentToken = SimpleERC20Interface(project.erc20PaymentTokenAddress);\\n\\n        uint256 grossInv = exchange(CURRENCY_USDC, project.investmentCurrency, amount);\\n        uint256 netInv = grossInv - (grossInv * project.feeRate / 10000) - project.flatFee;\\n        requireWithErrorCode(investmentAllowed(projectId, tokenId, msg.sender, netInv, block.timestamp));\\n        require(paymentToken.balanceOf(msg.sender) >= amount, \\\"Insufficient balance\\\");\\n        require(paymentToken.transferFrom(msg.sender, projectInvestImplementer.getProjectWallet(projectId), amount), \\\"Transfer failed\\\");\\n        userInvestmentImplementer.incrementPayedCrypto(projectId, tokenId, CURRENCY_USDC, amount);\\n        _invest(projectId, tokenId, true, netInv);\\n\\n        emit InvestEvent(INVEST_TYPE_CRYPTO, 0, projectId, tokenId, netInv, true, project.investmentCurrency);\\n    }\\n\\n\\n    function investmentAllowed(uint32 projectId, uint16 tokenId, address user, uint256 netInv, uint256 timestamp)  internal view returns (uint8) { //returns 0 for success, error code for others\\n        ProjectInvestImplementer.Project memory project;\\n        try projectInvestImplementer.getProject(projectId) returns (ProjectInvestImplementer.Project memory _project) {\\n            project = _project;\\n        } catch {\\n            return ERR_PROJECT_DOES_NOT_EXIST;\\n        }\\n        if(!userHasActiveToken(tokenId, user)) return ERR_USER_NOT_ACTIVE_TOKEN;\\n        if(timestamp < project.fundingStart) return ERR_FUNDING_NOT_STARTED;\\n        if(timestamp > project.fundingEnd) return ERR_FUNDING_ENDED;\\n        if(netInv < project.minInvestmentPerUser) return ERR_INVESTMENT_BELOW_MIN;\\n        if(userInvestmentImplementer.getUserTotalInvest(tokenId, projectId) + netInv > project.maxInvestmentPerUser) return ERR_INVESTMENT_ABOVE_MAX;\\n        if(netInv + projectInvestImplementer.getProjectTotalInvestment(projectId) > project.maxFundingTarget) return ERR_FUNDING_ABOVE_MAX;\\n        \\n        return ERR_CODE_SUCCESS;\\n    }\\n\\n\\n    function _invest(uint32 projectId, uint16 tokenId, bool isCrypto, uint256 netInv) internal {\\n        userInvestmentImplementer.incrementValue(tokenId, projectId, isCrypto, netInv);\\n        projectInvestImplementer.incrementProjectInvestment(projectId, isCrypto, netInv);\\n    }\\n\\n    function reInvestRequest(uint32 fromProjectId, uint32 toProjectId, uint16 tokenId, bool isCrypto, uint256 amount) external{\\n        ProjectInvestImplementer.Project memory fromProject = projectInvestImplementer.getProject(fromProjectId); //throws error if project does not exist\\n        ProjectInvestImplementer.Project memory toProject = projectInvestImplementer.getProject(toProjectId); //throws error if project does not exist\\n        uint256 amountDst = exchange(fromProject.investmentCurrency, toProject.investmentCurrency, amount);\\n        canScheduleReinvest(fromProject, toProject, tokenId, isCrypto, amount, amountDst, block.timestamp);\\n        reinvestRequestImplementer.incrementValue(tokenId, fromProjectId, toProjectId, isCrypto, amount, amountDst);\\n\\n        emit InvestEvent(INVEST_TYPE_REINVEST_REQUEST, fromProjectId, toProjectId, tokenId, amount, isCrypto, fromProject.investmentCurrency);\\n    }\\n\\n    function canScheduleReinvest(ProjectInvestImplementer.Project memory fromProject, \\n                         ProjectInvestImplementer.Project memory toProject, \\n                         uint16 tokenId, \\n                         bool isCrypto, \\n                         uint256 amountSrc,\\n                         uint256 amountDst, \\n                         uint256 scheduleTimestamp //timestamp of scheduling reinvestment\\n                        ) internal view {\\n        uint256 fromProjEnd = fromProject.fundingEnd + fromProject.duration;\\n        require(scheduleTimestamp > fromProject.fundingEnd, \\\"Cannot schedule reinvest; Investment period of source project is not over yet\\\");\\n        require(scheduleTimestamp >= fromProjEnd - projectInvestImplementer.reinvestStartTime(), \\\"Cannot schedule reinvest, reinvest period not started yet\\\");\\n        require(scheduleTimestamp <= fromProjEnd - projectInvestImplementer.reinvestCutOffTime(), \\\"Cannot schedule reinvest, reinvest period is over\\\");\\n        requireWithErrorCode(isReinvestmentPossible(fromProject, toProject, tokenId, isCrypto, amountSrc, amountDst, true, fromProjEnd)); \\n    }\\n\\n\\n    function isReinvestmentPossible(ProjectInvestImplementer.Project memory fromProject, \\n                                ProjectInvestImplementer.Project memory toProject, \\n                                uint16 tokenId, \\n                                bool isCrypto, \\n                                uint256 amountSrc, //amount is in the currency of the source project\\n                                uint256 amountDst, //amount is in the currency of the destination project\\n                                bool forSchedule, //if true, then the reinvestment is scheduled, false if executed\\n                                uint256 reinvestTimestamp ) internal view returns (uint8) {\\n        uint256 srcFunds = userInvestmentImplementer.getValue(tokenId, fromProject.id, isCrypto);\\n        if (forSchedule) {\\n            srcFunds = srcFunds * (10000 + fromProject.returnRate) / 10000;\\n        }\\n        uint256 availableSrcFunds = srcFunds - reinvestRequestImplementer.getTotalSumReinvested(tokenId, fromProject.id, isCrypto);\\n        uint8 invAllowedRetCode = investmentAllowed(toProject.id, tokenId, msg.sender, amountDst, reinvestTimestamp);\\n        if(invAllowedRetCode != ERR_CODE_SUCCESS) return invAllowedRetCode;\\n        if(availableSrcFunds < amountSrc) return ERR_INSUFFICIENT_FUNDS;\\n        return ERR_CODE_SUCCESS;\\n    }\\n\\n\\n\\n    function addFiatInvestment(uint32 projectId, uint16 tokenId, address destWallet, uint256 netInv) external allowFiatInvest { //net investment should be passed. Any fee, if it exsists, should be handled by the caller.\\n        requireWithErrorCode(investmentAllowed(projectId, tokenId, destWallet, netInv, block.timestamp));\\n        _invest(projectId, tokenId, false, netInv);\\n\\n        emit InvestEvent(INVEST_TYPE_FIAT, 0, projectId, tokenId, netInv, false, projectInvestImplementer.getProject(projectId).investmentCurrency);\\n    }\\n\\n    //this is a function called by the owner of the SC to pay out the investors all at once.\\n    function payout(uint32 projectId, address safe) external onlyOwner {\\n        ProjectInvestImplementer.Project memory project = projectInvestImplementer.getProject(projectId); //throws error if project does not exist\\n        uint256 projectInvestment = projectInvestImplementer.getProjectTotalInvestment(projectId);\\n        require(projectInvestment > 0, \\\"Project has no investments\\\");\\n        require(block.timestamp > project.fundingEnd, \\\"Project funding period is not over yet\\\");\\n        bool projectFundingTargetReached = projectInvestment >= project.minFundingTarget;\\n        if(projectFundingTargetReached) { //project funding target failed, return investment\\n            require(block.timestamp >= project.fundingEnd + project.duration, \\\"Project duration is not over yet\\\");\\n        } \\n        \\n\\n        SimpleERC20Interface paymentToken = SimpleERC20Interface(project.erc20PaymentTokenAddress);\\n        require(paymentToken.balanceOf(safe) >= projectInvestImplementer.getProjectInvestment(projectId, true) * (10000 + project.returnRate) / 10000 , \\\"Insufficient balance\\\");\\n        uint16[] memory tokenIds = userInvestmentImplementer.getTokenIds(projectId);\\n        for(uint16 i = 0; i < tokenIds.length; i++){\\n            if(projectFundingTargetReached) {\\n                //1 - add return to user\\n                addReturn(project, tokenIds[i], true);\\n                addReturn(project, tokenIds[i], false);\\n            }\\n\\n            //2// reinvestment\\n            uint32[] memory destProjects = reinvestRequestImplementer.getDestProjects(projectId, tokenIds[i]);\\n            for(uint32 j = 0; j < destProjects.length; j++){\\n                ProjectInvestImplementer.Project memory destProject;\\n                try projectInvestImplementer.getProject(destProjects[j]) returns (ProjectInvestImplementer.Project memory retrievedProject) {\\n                    destProject = retrievedProject;\\n                } catch {\\n                    continue;\\n                }\\n                if(projectFundingTargetReached) {\\n                    executeReinvest(tokenIds[i], project, destProject, true);\\n                    executeReinvest(tokenIds[i], project, destProject, false);\\n                } \\n                clearReinvest(tokenIds[i], project, destProject, true);\\n                clearReinvest(tokenIds[i], project, destProject, false);\\n            }\\n\\n            //3// crypto payout remaining after reinvestment\\n            uint256 remaining = userInvestmentImplementer.getValue(tokenIds[i], projectId, true);\\n            if(remaining > 0){\\n                userInvestmentImplementer.decrementValue(tokenIds[i], projectId, true, remaining);\\n                projectInvestImplementer.decrementProjectInvestment(projectId, true, remaining);\\n                if(projectFundingTargetReached){\\n                    paymentToken.transferFrom(safe, token.ownerOf(tokenIds[i]) , exchange(project.investmentCurrency, CURRENCY_USDC, remaining));\\n                    emit InvestEvent(INVEST_TYPE_PAYOUT_CRYPTO, projectId, 0, tokenIds[i], remaining, true, project.investmentCurrency);\\n                } else {\\n                    uint256 payedCrypto =  userInvestmentImplementer.getPayedCrypto(projectId, tokenIds[i], CURRENCY_USDC);\\n                    if(payedCrypto > 0) {\\n                        paymentToken.transferFrom(safe, token.ownerOf(tokenIds[i]) , payedCrypto);\\n                        userInvestmentImplementer.decrementPayedCrypto(projectId, tokenIds[i], CURRENCY_USDC, payedCrypto);\\n                        emit InvestEvent(INVEST_TYPE_PAYOUT_CRYPTO_FAILED_FUNDING, projectId, 0, tokenIds[i], payedCrypto, true, CURRENCY_USDC);\\n                    }\\n                }\\n            }\\n                \\n\\n            //4// fiat payout remaining after reinvestment\\n            remaining = userInvestmentImplementer.getValue(tokenIds[i], projectId, false);\\n            if(remaining > 0){\\n                userInvestmentImplementer.decrementValue(tokenIds[i], projectId, false, remaining); \\n                projectInvestImplementer.decrementProjectInvestment(projectId, false, remaining);\\n                userInvestmentImplementer.incrementFiatPayment(tokenIds[i],project.investmentCurrency, remaining);\\n                if(projectFundingTargetReached) {\\n                    emit InvestEvent(INVEST_TYPE_PAYOUT_FIAT, projectId, 0, tokenIds[i], remaining, false, project.investmentCurrency);\\n                }\\n                else {\\n                    emit InvestEvent(INVEST_TYPE_PAYOUT_FIAT_FAILED_FUNDING, projectId, 0, tokenIds[i], remaining, false, project.investmentCurrency);\\n                }\\n            }\\n\\n        }\\n    }\\n\\n    function addReturn(ProjectInvestImplementer.Project memory project, uint16 tokenId, bool isCrypto) internal {\\n        uint256 value = userInvestmentImplementer.getValue(tokenId, project.id, isCrypto);\\n        if(value > 0 ) {\\n            uint256 returnAmount = value * project.returnRate / 10000;\\n            userInvestmentImplementer.incrementValue(tokenId, project.id, isCrypto, returnAmount);\\n            projectInvestImplementer.incrementProjectInvestment(project.id, isCrypto, returnAmount);\\n            emit InvestEvent(INVEST_TYPE_PAYOUT_RETURN, project.id, 0, tokenId, returnAmount, isCrypto, project.investmentCurrency);\\n        }\\n    }\\n\\n    function executeReinvest(uint16 tokenId, ProjectInvestImplementer.Project memory fromProj, ProjectInvestImplementer.Project memory toProj, bool isCrypto) internal {\\n        uint256 valueSrc = reinvestRequestImplementer.getValue(tokenId, fromProj.id, toProj.id, isCrypto, true);\\n        uint256 valueDst = reinvestRequestImplementer.getValue(tokenId, fromProj.id, toProj.id, isCrypto, false);\\n        if(valueSrc > 0 && valueDst > 0 ) {\\n            if(isReinvestmentPossible(fromProj, toProj, tokenId, isCrypto, valueSrc, valueDst, false, block.timestamp) == ERR_CODE_SUCCESS){\\n                userInvestmentImplementer.decrementValue(tokenId, fromProj.id, true, valueSrc); \\n                projectInvestImplementer.decrementProjectInvestment(fromProj.id, true, valueSrc);\\n                if(isCrypto){\\n                    ProjectInvestImplementer.Project memory proj = projectInvestImplementer.getProject(toProj.id);\\n                    userInvestmentImplementer.incrementPayedCrypto(toProj.id, tokenId, toProj.investmentCurrency, exchange(proj.investmentCurrency, CURRENCY_USDC, valueSrc) );\\n                }\\n                _invest(toProj.id, tokenId, true, valueDst);\\n                emit InvestEvent(INVEST_TYPE_REINVEST, fromProj.id, toProj.id, tokenId, valueSrc, true, fromProj.investmentCurrency);\\n                if(isCrypto){\\n                    emit InvestEvent(INVEST_TYPE_CRYPTO, 0, toProj.id, tokenId, valueDst, true, toProj.investmentCurrency);\\n                } else {\\n                    emit InvestEvent(INVEST_TYPE_FIAT, 0, toProj.id, tokenId, valueDst, false, toProj.investmentCurrency);\\n                }\\n            }           \\n        }\\n    }\\n\\n    function clearReinvest(uint16 tokenId, ProjectInvestImplementer.Project memory fromProj, ProjectInvestImplementer.Project memory toProj, bool isCrypto) internal {\\n        uint256 valueSrc = reinvestRequestImplementer.getValue(tokenId, fromProj.id, toProj.id, isCrypto, true);\\n        uint256 valueDst = reinvestRequestImplementer.getValue(tokenId, fromProj.id, toProj.id, isCrypto, false);\\n        if(valueSrc > 0 && valueDst > 0 ) {\\n            reinvestRequestImplementer.decrementValue(tokenId, fromProj.id, toProj.id, true, valueSrc, valueDst);\\n        }\\n    }\\n\\n    function markFiatPaymentAsDone(uint16 tokenId, uint32 projectId, uint8 currency, uint256 value) external onlyOwner {\\n        require(userInvestmentImplementer.getFiatPayment(tokenId, currency) >= value && value > 0, \\\"markFiatPaymentAsDone: insufficient fiat payment\\\");\\n        userInvestmentImplementer.decrementFiatPayment(tokenId, currency, value);\\n        emit InvestEvent(INVEST_TYPE_PAYOUT_FIAT_DONE, projectId, 0, tokenId, value, false, currency);\\n    }\\n\\n    function getTotalProjectInvestment(uint32 projectId) external view returns (uint256) {\\n        return projectInvestImplementer.getProjectTotalInvestment(projectId);\\n    }\\n\\n    function getFiatTokenIdsToPay(uint8 currency) external view returns (uint16[] memory) {\\n        return userInvestmentImplementer.getFiatPaymentTokenIds(currency);\\n    }\\n\\n    //user fiat balance per currency\\n    function getFiatPayment(uint16 tokenId, uint8 currency) external view returns (uint256) {\\n        return userInvestmentImplementer.getFiatPayment(tokenId, currency);\\n    }\\n\\n    function exchange(uint8 sourceCurrency, uint8 destCurrency, uint256 amount) internal view returns (uint256){\\n        uint256 result = exchangeRegistry.exchange(sourceCurrency, destCurrency, amount);\\n        return round(result, 4);\\n    }\\n\\n    function round(uint256 value, uint256 decimals) internal pure returns (uint256) { //decimals represent the number of decimals that need to be dropped. As fiat will only have 2 meaningful decimals, we drop 4 decimals\\n        uint256 divisor = 10 ** decimals; //10^4 = 10000\\n        uint256 roundValue = value / divisor; // floor the value (round down)\\n        uint256 remainder = value % divisor; // last 4 digits\\n        if (remainder >= divisor / 2) { // if the remainder is greater than or equal to 5000, round up\\n            roundValue += 1;\\n        }\\n        return roundValue * divisor; //add back the decimals as zeros\\n    }\\n\\n\\n    modifier allowFiatInvest(){\\n        require(msg.sender == owner() || allowedFiatInvest[msg.sender], \\\"Invest not allowed\\\");\\n        _;\\n    }\\n\\n    function setAllowedOffChainInvest(address _address, bool _allowed) external onlyOwner {\\n        allowedFiatInvest[_address] = _allowed;\\n    }\\n\\n\\n    function requireWithErrorCode(uint8 error_code) pure internal{\\n        if(error_code == ERR_CODE_SUCCESS) return;\\n        if(error_code == ERR_PROJECT_DOES_NOT_EXIST) revert(\\\"Project does not exist\\\");\\n        if(error_code == ERR_USER_NOT_ACTIVE_TOKEN) revert(\\\"User does not have an active token\\\");\\n        if(error_code == ERR_FUNDING_NOT_STARTED) revert(\\\"Funding not started\\\");\\n        if(error_code == ERR_FUNDING_ENDED) revert(\\\"Funding ended\\\");\\n        if(error_code == ERR_INVESTMENT_BELOW_MIN) revert(\\\"Investment below min\\\");\\n        if(error_code == ERR_INVESTMENT_ABOVE_MAX) revert(\\\"Investment above max\\\");\\n        if(error_code == ERR_FUNDING_ABOVE_MAX) revert(\\\"Funding above max\\\");\\n        if(error_code == ERR_INSUFFICIENT_FUNDS) revert(\\\"Insufficient funds\\\");\\n        revert(\\\"Unknown error\\\");\\n    }\\n}\"\r\n    },\r\n    \"contracts/nft/sale/ExchangeRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.13;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"./IExchangeRate.sol\\\";\\n\\ncontract ExchangeRegistry is Ownable {\\n    uint8 constant public CURRENCY_EUR = 0;\\n    uint8 constant public CURRENCY_USD = 1;\\n    uint8 constant public CURRENCY_RON = 2;\\n    uint8 constant public CURRENCY_USDC = 128;\\n\\n    mapping (uint8 => string) public currency; //id && symbol\\n    uint8 public crossCurrency; \\n    mapping (uint8 => mapping (uint8 => address)) public exchangePairContracts; //fromCurrency => toCurrency => contractAddress\\n\\n    event AddExchangePairContract(uint8 from, uint8 to, address indexed exchangePairContract);\\n\\n    constructor() {\\n        setCrossCurrency(CURRENCY_RON); //RON\\n    }\\n\\n\\n\\n    function setCrossCurrency(uint8 _currency) public onlyOwner{\\n        crossCurrency = _currency;\\n    }\\n\\n    function addExchangePairContract(uint8 fromCurrency, uint8 toCurrency, address exchangePairContract) public onlyOwner {\\n        require(fromCurrency != toCurrency, \\\"ExchangeRegistry: fromCurrency and toCurrency must be different\\\");\\n        exchangePairContracts[fromCurrency][toCurrency] = exchangePairContract;\\n        emit AddExchangePairContract(fromCurrency, toCurrency, exchangePairContract);\\n    }\\n\\n    function exchange(uint8 fromCurrency, uint8 toCurrency, uint256 amount) public view returns(uint256) {\\n        if(fromCurrency == CURRENCY_USDC) {\\n            fromCurrency = CURRENCY_USD;\\n        }\\n        if(toCurrency == CURRENCY_USDC) {\\n            toCurrency = CURRENCY_USD;\\n        }\\n        if(fromCurrency == toCurrency) {\\n            return amount;\\n        }\\n        if (exchangePairContracts[fromCurrency][toCurrency] != address(0) ) { //direct\\n            return IExchangeRate(exchangePairContracts[fromCurrency][toCurrency]).mul(amount);\\n        } \\n        if(exchangePairContracts[toCurrency][fromCurrency] != address(0)){ //inverse\\n            return inverseRate(IExchangeRate(exchangePairContracts[toCurrency][fromCurrency]).getRate(), amount);\\n        } \\n        if (exchangePairContracts[fromCurrency][crossCurrency] != address(0) && exchangePairContracts[toCurrency][crossCurrency] != address(0)) { //cross\\n                uint256 rate1 = IExchangeRate(exchangePairContracts[fromCurrency][crossCurrency]).getRate();\\n                uint256 rate2 = IExchangeRate(exchangePairContracts[toCurrency][crossCurrency]).getRate();\\n                return SafeMath.div(SafeMath.mul(amount, rate1), rate2);\\n        }\\n        \\n        revert(\\\"ExchangeRegistry: exchangePairContract must be set\\\");        \\n    }\\n\\n    function inverseRate(uint256 rate, uint256 amount) internal pure returns(uint256) {\\n        return SafeMath.div(SafeMath.mul(amount, 1e18), rate);\\n    }\\n}\"\r\n    },\r\n    \"contracts/nft/sale/IExchangeRate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity 0.8.13;\\n\\ninterface IExchangeRate {\\n    function getRate() external view returns (uint256);\\n    function getLastUpdate() external view returns (uint256);\\n\\n    function mul(uint256 a) external view returns (uint256);\\n}\"\r\n    },\r\n    \"contracts/nft/token/ActivatableToken.sol\": {\r\n      \"content\": \"\\n// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"./ERC721Token.sol\\\";\\n\\ninterface ITraitRegistry {\\n    function hasTrait(uint16 traitID, uint16 tokenId) external view returns (bool result);\\n}\\n\\ninterface ITraitImplementer {\\n    function getValue(uint16 _tokenId) external view returns (uint8 value);\\n}\\n\\n\\n// \\n\\ncontract ActivatableToken is ERC721Token {\\n\\n    mapping(uint16 => uint8)        internal activatedTokenData;\\n    ITraitRegistry     public       TraitRegistry;\\n    ITraitImplementer  public       TraitImplementer;\\n    address         public          ManagerMultisigAddress;\\n    uint16          public constant TRAIT_ACTIVATED_ID = 1;\\n    uint8           public constant TRAIT_ACTIVATED_USER_CAN_TRANSFER = 0;\\n    uint8           public constant TRAIT_ACTIVATED_ADMIN_CAN_TRANSFER = 2;\\n\\n    struct TokenConfig {\\n        string  _name;\\n        string  _symbol;\\n        string  _baseURL;     \\n        uint256 _maxSupply;\\n        bool    _transferLocked;\\n        address _TraitRegistryAddress;\\n        address _TraitImplementerAddress;\\n        address _ManagerMultisigAddress;\\n    }\\n\\n    constructor(\\n        TokenConfig memory config\\n    ) ERC721Token(\\n        config._name,\\n        config._symbol,\\n        config._baseURL,\\n        config._maxSupply,\\n        config._transferLocked\\n    ) {\\n        TraitRegistry = ITraitRegistry(config._TraitRegistryAddress);\\n        TraitImplementer = ITraitImplementer(config._TraitImplementerAddress);\\n        ManagerMultisigAddress = config._ManagerMultisigAddress;\\n\\n        // @TODO: may want to mint the first 50 - 100 here\\n        // mintIncrementalCards(50, msg.sender);\\n    }\\n\\n    function updateContractAddresses(\\n        address _TraitRegistryAddress,\\n        address _TraitImplementerAddress,\\n        address _ManagerMultisigAddress\\n    ) public {\\n        require(msg.sender == ManagerMultisigAddress, \\\"Token: Unauthorised\\\");\\n\\n        TraitRegistry = ITraitRegistry(_TraitRegistryAddress);\\n        TraitImplementer = ITraitImplementer(_TraitImplementerAddress);\\n        ManagerMultisigAddress = _ManagerMultisigAddress;\\n    }\\n\\n    function canAdminTransferToken(uint256 _tokenId, address _adminAddress) public view returns (bool) {\\n        // Once a token requests activation it can only be moved by admin multisig\\n        if(\\n            TraitImplementer.getValue(uint16(_tokenId)) != TRAIT_ACTIVATED_USER_CAN_TRANSFER\\n            && _adminAddress == ManagerMultisigAddress\\n        ) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual override returns (bool) {\\n        return super._isApprovedOrOwner(spender, tokenId) || canAdminTransferToken(tokenId, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 _tokenId,\\n        uint256 batchSize\\n    ) internal override {\\n\\n        // ignore minting so we don't waste gas for no reason\\n        if(from != address(0)) {\\n\\n            // Once a token requests activation it can only be moved by admin multisig\\n            if(TraitImplementer.getValue(uint16(_tokenId)) != TRAIT_ACTIVATED_USER_CAN_TRANSFER) {\\n                if(msg.sender == ManagerMultisigAddress) {\\n                    super._beforeTokenTransfer(from, to, _tokenId, batchSize);\\n                } else {\\n                    revert(\\\"Token: Activated token can only be moved by request to admin multisig!\\\");\\n                }\\n            }\\n        }\\n\\n        super._beforeTokenTransfer(from, to, _tokenId, batchSize);\\n    }\\n\\n    struct ActivatableTokenInfo {\\n        TokenConfig     config;\\n        uint256         mintedSupply;\\n        uint256         totalSupply;\\n        uint256         version;\\n    }\\n\\n    function tellEverything() external view returns (ActivatableTokenInfo memory) {\\n\\n        return ActivatableTokenInfo(\\n            TokenConfig(\\n                name(),\\n                symbol(),\\n                baseURL,\\n                maxSupply,\\n                transferLocked,\\n                address(TraitRegistry),\\n                address(TraitImplementer),\\n                address(ManagerMultisigAddress)\\n            ),\\n            // computed and hardcoded values\\n            mintedSupply,\\n            totalSupply(),\\n            version\\n        );\\n    }\\n}\"\r\n    },\r\n    \"contracts/nft/token/ERC721Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"./IToken.sol\\\";\\nimport \\\"../../interfaces/IRandomNumberProvider.sol\\\";\\nimport \\\"../../interfaces/IRandomNumberRequester.sol\\\";\\nimport \\\"../../extras/recovery/BlackHolePrevention.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Strings.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\\\";\\n\\n\\ncontract ERC721Token is IToken, ERC721Enumerable, BlackHolePrevention {\\n    using Strings  for uint256;\\n\\n    uint256             immutable   public maxSupply;\\n    uint256                         public mintedSupply;    // minted incrementally\\n\\n    string                          public baseURL;\\n    string                          public contractURI;\\n\\n    bool                            public transferLocked;\\n    mapping (address => bool)       public permitted;\\n    uint32                 constant public version = 2023012601;\\n\\n    event Allowed(address, bool);\\n    event Locked(bool);\\n    event ContractURIset(string contractURI);\\n\\n    constructor(\\n        string memory   _name, \\n        string memory   _symbol,\\n        string memory   _baseURL,\\n        uint256         _maxSupply,\\n        bool            _transferLocked\\n    ) ERC721(_name, _symbol) {\\n        baseURL             = _baseURL;\\n        maxSupply           = _maxSupply;\\n        transferLocked      = _transferLocked;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 _tokenId,\\n        uint256 batchSize\\n    ) internal virtual override {\\n        if(from != address(0)) {\\n            require(!transferLocked, \\\"Token: Transfers are not enabled\\\");\\n        }\\n        \\n        super._beforeTokenTransfer(from, to, _tokenId, batchSize);\\n    }\\n\\n    /**\\n     * @dev Sale: mint cards.\\n     */\\n    function mintIncrementalCards(uint256 numberOfCards, address recipient) public onlyAllowed returns (uint256)  {\\n        require(mintedSupply + numberOfCards <= maxSupply, \\\"Token: This would exceed the number of cards available\\\");\\n        uint256 mintId = mintedSupply + 1;\\n        for (uint j = 0; j < numberOfCards; j++) {\\n            _mint(recipient, mintId++);\\n        }\\n        mintedSupply+=numberOfCards;\\n        return mintId;\\n    }\\n\\n    /**\\n     * @dev Admin: set PreRevealURI\\n     */\\n    function setBaseURL(string calldata _baseURL) external onlyAllowed {\\n        baseURL = _baseURL;\\n    }\\n\\n    /**\\n    * @dev Get metadata server url for tokenId\\n    */\\n    function tokenURI(uint256 _tokenId) public view override(IToken, ERC721) returns (string memory) {\\n        require(_exists(_tokenId), 'Token: Token does not exist');\\n        string memory folder = (_tokenId % 100).toString(); \\n        string memory file = _tokenId.toString();\\n        string memory ext = \\\".json\\\";\\n        string memory slash = \\\"/\\\";\\n        return string(abi.encodePacked(baseURL, folder, slash, file, ext));\\n    }\\n\\n    /**\\n     * @dev Admin: Lock / Unlock transfers\\n     */\\n    function setTransferLock(bool _locked) external onlyAllowed {\\n        transferLocked = _locked;\\n        emit Locked(_locked);\\n    }\\n\\n    /**\\n     * @dev Admin: Allow / Dissalow addresses\\n     */\\n    function setAllowed(address _addr, bool _state) external onlyOwner {\\n        permitted[_addr] = _state;\\n        emit Allowed(_addr, _state);\\n    }\\n\\n    function isAllowed(address _addr) public view returns(bool) {\\n        return permitted[_addr] || _addr == owner();\\n    }\\n\\n    modifier onlyAllowed() {\\n        require(isAllowed(msg.sender), \\\"Token: Unauthorised\\\");\\n        _;\\n    }\\n\\n    // function tellEverything() external view virtual returns (TokenInfo memory) {\\n        \\n    //     revealStruct[] memory _reveals = new revealStruct[](currentRevealCount);\\n    //     for(uint16 i = 1; i <= currentRevealCount; i++) {\\n    //         _reveals[i - 1] = reveals[i];\\n    //     }\\n\\n    //     return TokenInfo(\\n    //         name(),\\n    //         symbol(),\\n    //         version,\\n    //         maxSupply,\\n    //         mintedSupply,\\n    //         tokenPreRevealURI,\\n    //         tokenRevealURI,\\n    //         transferLocked,\\n    //         lastRevealRequested,\\n    //         totalSupply(),\\n    //         _reveals\\n    //     );\\n    // }\\n\\n    function getTokenInfoForSale() external view returns (TokenInfoForSale memory) {\\n        return TokenInfoForSale(\\n            version,\\n            totalSupply(),\\n            maxSupply\\n        );\\n    }\\n\\n}\"\r\n    },\r\n    \"contracts/nft/token/IToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\n\\nstruct revealStruct {\\n    uint256 REQUEST_ID;\\n    uint256 RANDOM_NUM;\\n    uint256 SHIFT;\\n    uint256 RANGE_START;\\n    uint256 RANGE_END;\\n    bool processed;\\n}\\n\\nstruct TokenInfoForSale {\\n    uint256 _version;\\n    uint256 _mintedSupply;\\n    uint256 _maxSupply;\\n}\\n\\nstruct TokenInfo {\\n    string _name;\\n    string _symbol;\\n    uint256 _version;\\n    uint256 _maxSupply;\\n    uint256 _mintedSupply;\\n    string _tokenPreRevealURI;\\n    string _tokenRevealURI;\\n    bool _transferLocked;\\n    bool _lastRevealRequested;\\n    uint256 _totalSupply;\\n    revealStruct[] _reveals;\\n}\\n\\ninterface IToken {\\n\\n    function mintIncrementalCards(uint256, address) external returns (uint256);\\n\\n    function setBaseURL(string calldata) external;\\n    function tokenURI(uint256) external view returns (string memory);\\n\\n    function setTransferLock(bool) external;\\n    function setAllowed(address, bool) external;\\n    function isAllowed(address) external view returns(bool);\\n\\n    function getTokenInfoForSale() external view returns (TokenInfoForSale memory);\\n}\\n\"\r\n    },\r\n    \"contracts/traits/Implementers/ProjectInvestImplementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"../TraitRegistryV3.sol\\\";\\n\\ncontract ProjectInvestImplementer {\\n    uint8 public immutable implementerType = 7;    // logic\\n    uint16 public immutable traitId;\\n    string public version = \\\"1.0.0\\\";\\n    uint32 public reinvestCutOffTime = 60 * 60 * 24 * 7; //time before project end after wich reinvestments are not allowed\\n    uint32 public reinvestStartTime = 60 * 60 * 24 * 30; //time before project end after wich reinvestments are allowed\\n    uint8 internal constant EVENT_TYPE_NEW_PROJECT = 0;\\n    uint8 internal constant EVENT_TYPE_UPDATE_PROJECT = 1;\\n\\n    event projectEvent(uint8 eventType, Project project, address destWallet, string uid);\\n\\n    struct Project {\\n        uint8 investmentCurrency; // 0: EUR, 1: USD, 2: RON\\n        address erc20PaymentTokenAddress;\\n        uint256 minFundingTarget;\\n        uint256 maxFundingTarget;\\n        uint32 returnRate;\\n        uint256 fundingStart;\\n        uint256 fundingEnd;\\n        uint256 duration;\\n        uint32 feeRate;\\n        uint32 flatFee;\\n        uint256 minInvestmentPerUser;\\n        uint256 maxInvestmentPerUser;\\n        uint32 id; //id will be automatically overwritten when project is added to ensure uniqueness\\n    }\\n    \\n    TraitRegistryV3 public TraitRegistry;\\n    mapping(uint32=>Project) public projects;\\n    mapping(uint32=>mapping(bool => uint256)) public projectInvestments;\\n    mapping(uint32=>address) public projectWallets;\\n    uint32 public projectCount;\\n\\n    constructor(address _registry, uint16 _traitId) {\\n        require(_registry != address(0), \\\"ProjectInvestImplementer: Invalid registry address\\\");\\n        traitId = _traitId;\\n        TraitRegistry = TraitRegistryV3(_registry);\\n    }\\n\\n    function addProject(Project calldata _project, address destWallet, string calldata uid) external onlyAllowed validProject(_project) returns (uint32){\\n        require(destWallet != address(0), \\\"ProjectInvestImplementer: Invalid destination wallet\\\");\\n\\n        projectCount++; //project id starts from 1. 0 id is reserved for non-existing projects\\n        projects[projectCount] = _project;\\n        projects[projectCount].id = projectCount; //overwrite id to ensure uniqueness\\n        projectWallets[projectCount] = destWallet;\\n        emit projectEvent(EVENT_TYPE_NEW_PROJECT, projects[projectCount], destWallet, uid);\\n        return projectCount;\\n    }\\n\\n    function updateProject(Project calldata _project, address destWallet, uint32 projId) external onlyAllowed validProject(_project) {\\n        require(destWallet != address(0));\\n        require(_project.id == projId, \\\"Invalid project id\\\");\\n        projects[projId] = _project;\\n        projectWallets[projId] = destWallet;\\n        emit projectEvent(EVENT_TYPE_UPDATE_PROJECT, _project, destWallet, \\\"\\\");\\n    }\\n\\n    function getProject(uint32 _projectId) external view returns (Project memory) {\\n        require(_projectId <= projectCount, \\\"ProjectInvestImplementer: Project does not exist\\\");\\n        return projects[_projectId];\\n    }\\n\\n    function getProjectWallet(uint32 _projectId) external view returns (address) {\\n        require(_projectId <= projectCount, \\\"ProjectInvestImplementer: Project does not exist\\\");\\n        return projectWallets[_projectId];\\n    }\\n\\n    function getProjectTotalInvestment(uint32 _projectId) external view returns (uint256) {\\n        return projectInvestments[_projectId][true] + projectInvestments[_projectId][false];\\n    }\\n\\n    function getProjectInvestment(uint32 _projectId, bool isCrypto) external view returns (uint256) {\\n        return projectInvestments[_projectId][isCrypto];\\n    }\\n\\n    function incrementProjectInvestment(uint32 _projectId, bool isCrypto, uint256 _value) external onlyAllowed {\\n        projectInvestments[_projectId][isCrypto] += _value;\\n    }\\n\\n    function decrementProjectInvestment(uint32 _projectId, bool isCrypto, uint256 _value) external onlyAllowed {\\n        require(projectInvestments[_projectId][isCrypto] >= _value, \\\"ProjectInvestImplementer: Not enough investment\\\");\\n        projectInvestments[_projectId][isCrypto] -= _value;\\n    }\\n\\n    function updateReinvestInterval(uint32 reinvestStart, uint32 reinvestCutoff) external onlyAllowed {\\n        reinvestStartTime = reinvestStart;\\n        reinvestCutOffTime = reinvestCutoff;\\n    }\\n\\n\\n\\n    modifier onlyAllowed() {\\n        require(\\n            TraitRegistry.addressCanModifyTrait(msg.sender, traitId),\\n            \\\"Implementer: Not Authorised\\\" \\n        );\\n        _;\\n    }\\n\\n    modifier validProject(Project calldata _project) {\\n        require(_project.fundingEnd > _project.fundingStart, \\\"ProjectInvestImplementer: Invalid funding end\\\");\\n        require(_project.minFundingTarget > 0, \\\"ProjectInvestImplementer: Invalid min funding target\\\");\\n        require(_project.maxFundingTarget > _project.minFundingTarget, \\\"ProjectInvestImplementer: Invalid max funding target\\\");\\n        require(_project.minInvestmentPerUser > 0, \\\"ProjectInvestImplementer: Invalid min investment per user\\\");\\n        require(_project.maxInvestmentPerUser > _project.minInvestmentPerUser, \\\"ProjectInvestImplementer: Invalid max investment per user\\\");\\n        require(_project.duration > 0, \\\"ProjectInvestImplementer: Invalid duration\\\");\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/traits/Implementers/ReinvestRequestImplementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"../TraitRegistryV3.sol\\\";\\n\\ncontract ReinvestRequestImplementer {\\n    \\n    uint8 public immutable implementerType = 7;    // logic\\n    uint16 public immutable traitId;\\n    string public version = \\\"1.0.0\\\";\\n\\n    TraitRegistryV3 public TraitRegistry;\\n    mapping ( uint32 => mapping ( uint16 => mapping (uint32 => mapping ( bool => uint256) ) ) ) public dataUserReinvetmentsSrcCurrency; //fromProjId=>tokenId=>toProjId=>isCrypto=>value\\n    mapping ( uint32 => mapping ( uint16 => mapping (uint32 => mapping ( bool => uint256) ) ) ) public dataUserReinvetmentsDstCurrency; //fromProjId=>tokenId=>toProjId=>isCrypto=>value\\n    mapping ( uint32 => mapping ( uint16 => uint32[] ) ) public dataDestProjects; //fromProjId=>tokenId=>toProjId[]\\n\\n    constructor(address _registry, uint16 _traitId) {\\n        traitId = _traitId;\\n        TraitRegistry = TraitRegistryV3(_registry);\\n    }\\n    \\n    function incrementValue(uint16 tokenId, uint32 fromProjId, uint32 toProjId, bool isCrypto, uint256 valueSrc, uint256 valueDst) public onlyAllowed {\\n        if (dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][isCrypto] == 0) {\\n            dataDestProjects[fromProjId][tokenId].push(toProjId);\\n        }\\n        dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][isCrypto] += valueSrc;\\n        dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][isCrypto] += valueDst;\\n    }\\n\\n    function decrementValue(uint16 tokenId, uint32 fromProjId, uint32 toProjId, bool isCrypto, uint256 valueSrc, uint256 valueDst) public onlyAllowed {\\n        require(dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][isCrypto] >= valueSrc, \\\"ReinvestImplementer: Not enough reinvestment src\\\");\\n        require(dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][isCrypto] >= valueDst, \\\"ReinvestImplementer: Not enough reinvestment dst\\\");\\n        dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][isCrypto] -= valueSrc;\\n        dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][isCrypto] -= valueDst;\\n        if((dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][false] == 0 && dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][true] == 0) ||\\n            (dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][false] == 0 && dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][true] == 0)) {\\n            require(dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][false] == 0 && dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][true] == 0, \\\"ReinvestImplementer: if source reinvest is 0, destination reinvest must be 0\\\");\\n            require(dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][false] == 0 && dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][true] == 0, \\\"ReinvestImplementer: if destination reinvest is 0, source reinvest must be 0\\\");\\n\\n            uint32[] storage destProjects = dataDestProjects[fromProjId][tokenId];\\n            for (uint i = 0; i < destProjects.length; i++) {\\n                if (destProjects[i] == toProjId) {\\n                    destProjects[i] = destProjects[destProjects.length - 1];\\n                    destProjects.pop();\\n                    break;\\n                }\\n            }\\n        }\\n\\n    }\\n\\n    function getValue(uint16 tokenId, uint32 fromProjId, uint32 toProjId, bool isCrypto, bool isSource) public view returns (uint256) {\\n        if (isSource) {\\n            return dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][isCrypto];\\n        } else {\\n            return dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][isCrypto];\\n        }\\n    }\\n\\n    function getTotalSumReinvested(uint16 tokenId, uint32 fromProjId, bool isCrypto) public view returns (uint256) {\\n        uint256 totalReinvest = 0;\\n        uint32[] storage destProjects = dataDestProjects[fromProjId][tokenId];\\n        for (uint i = 0; i < destProjects.length; i++) {\\n            totalReinvest += dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][destProjects[i]][isCrypto];\\n        }\\n        return totalReinvest;\\n    }\\n\\n    function getUserTotalReinvest(uint16 tokenId, uint32 fromProjId, bool isSource) public view returns (uint256) {\\n        uint256 totalReinvest = 0;\\n        uint32[] storage destProjects = dataDestProjects[fromProjId][tokenId];\\n        for (uint i = 0; i < destProjects.length; i++) {\\n            if(isSource) {\\n                totalReinvest += dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][destProjects[i]][false];\\n                totalReinvest += dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][destProjects[i]][true];\\n            } else {\\n                totalReinvest += dataUserReinvetmentsDstCurrency[fromProjId][tokenId][destProjects[i]][false];\\n                totalReinvest += dataUserReinvetmentsDstCurrency[fromProjId][tokenId][destProjects[i]][true];\\n            }\\n        }\\n        return totalReinvest;\\n    }\\n\\n    function getUserTotalReinvestToProj(uint16 tokenId, uint32 fromProjId, uint32 toProjId, bool isSource) public view returns (uint256) {\\n        if(isSource) {\\n            return dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][false] + dataUserReinvetmentsSrcCurrency[fromProjId][tokenId][toProjId][true];\\n        } else {\\n            return dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][false] + dataUserReinvetmentsDstCurrency[fromProjId][tokenId][toProjId][true];\\n        }\\n    }\\n\\n    function getDestProjects(uint32 fromProjId, uint16 tokenId) public view returns (uint32[] memory) {\\n        return dataDestProjects[fromProjId][tokenId];\\n    }\\n\\n    modifier onlyAllowed() {\\n        require(\\n            TraitRegistry.addressCanModifyTrait(msg.sender, traitId),\\n            \\\"Implementer: Not Authorised\\\" \\n        );\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/traits/Implementers/TraitUint8ValueImplementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"../TraitRegistryV3.sol\\\";\\n\\ncontract TraitUint8ValueImplementer {\\n\\n    uint8           public immutable    implementerType = 3;    // uint8\\n    uint16          public immutable    traitId;\\n    TraitRegistryV3 public              TraitRegistry;\\n\\n    //  tokenID => uint value\\n    mapping(uint16 => uint8) public data;\\n\\n    event updateTraitEvent(uint16 indexed _tokenId, uint8 _newData);\\n\\n    constructor(address _registry, uint16 _traitId) {\\n        traitId = _traitId;\\n        TraitRegistry = TraitRegistryV3(_registry);\\n    }\\n\\n    // update multiple token values at once\\n    function setData(uint16[] memory _tokenIds, uint8[] memory _value) public onlyAllowed {\\n        for (uint16 i = 0; i < _tokenIds.length; i++) {\\n            data[_tokenIds[i]] = _value[i];\\n            emit updateTraitEvent(_tokenIds[i], _value[i]);\\n        }\\n    }\\n\\n    // update one\\n    function setValue(uint16 _tokenId, uint8 _value) public onlyAllowed {\\n        data[_tokenId] = _value;\\n        emit updateTraitEvent(_tokenId, _value);\\n    }\\n\\n    function getValue(uint16 _tokenId) public view returns (uint8) {\\n         return data[_tokenId];\\n    }\\n\\n    function getValues(uint16 _start, uint16 _len) public view returns (uint8[] memory) {\\n        uint8[] memory retval = new uint8[](_len);\\n        for(uint16 i = _start; i < _len; i++) {\\n            retval[i] = data[i];\\n        }\\n        return retval;\\n    }\\n\\n    modifier onlyAllowed() {\\n        require(\\n            TraitRegistry.addressCanModifyTrait(msg.sender, traitId),\\n            \\\"Implementer: Not Authorised\\\" \\n        );\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/traits/Implementers/UserInvestmentImplementer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"../TraitRegistryV3.sol\\\";\\n\\ncontract UserInvestmentImplementer {\\n    uint8 public constant implementerType = 7;    // logic\\n    uint16 public immutable traitId;\\n    string public version = \\\"1.0.0\\\";\\n\\n    TraitRegistryV3 public TraitRegistry;\\n    mapping (uint16 => mapping (uint32 => mapping (bool => uint256))) public dataTokensToProjects; //tokenId=>projectId=>fiat/crypto=>value\\n    mapping (uint32 => uint16[]) public tokenIds;\\n    mapping (uint16 => mapping (uint8 => uint256)) public fiatPayment; //tokenId=> currencyId => value\\n    mapping (uint32 => mapping (uint16 => mapping (uint8 => uint256))) public payedCrypto; //projectId=>tokenId=>currencyId=>value //USDC = 128 - only crypto accepted for now\\n    mapping (uint8 => uint16[]) public tokenIdsByFiatCurrency; //currencyId => tokenIds\\n\\n    constructor(address _registry, uint16 _traitId) {\\n        traitId = _traitId;\\n        TraitRegistry = TraitRegistryV3(_registry);\\n    }\\n\\n\\n    function incrementValue(uint16 _tokenId, uint32 _projectId, bool _isCrypto, uint256 _value) public onlyAllowed {\\n        if(dataTokensToProjects[_tokenId][_projectId][true] == 0 && dataTokensToProjects[_tokenId][_projectId][false] == 0  && _value != 0) {\\n            tokenIds[_projectId].push(_tokenId);\\n        }\\n        dataTokensToProjects[_tokenId][_projectId][_isCrypto] += _value;\\n    }\\n\\n    function decrementValue(uint16 _tokenId, uint32 _projectId, bool _isCrypto, uint256 _value) public onlyAllowed {\\n        require(dataTokensToProjects[_tokenId][_projectId][_isCrypto] >= _value, \\\"UserInvestmentImplementer: Not enough investment\\\");\\n        dataTokensToProjects[_tokenId][_projectId][_isCrypto] -= _value;\\n        if(dataTokensToProjects[_tokenId][_projectId][true] == 0 && dataTokensToProjects[_tokenId][_projectId][false] == 0 ) {\\n            uint16[] storage ids = tokenIds[_projectId];\\n            for(uint16 i = 0; i < ids.length; i++) {\\n                if(ids[i] == _tokenId) {\\n                    ids[i] = ids[ids.length - 1];\\n                    ids.pop();\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    function incrementFiatPayment(uint16 _tokenId, uint8 _currencyId, uint256 _value) public onlyAllowed {\\n        if(_value > 0) {\\n            if(fiatPayment[_tokenId][_currencyId] == 0) {\\n                tokenIdsByFiatCurrency[_currencyId].push(_tokenId);\\n            }   \\n            fiatPayment[_tokenId][_currencyId] += _value;\\n        }\\n    }\\n\\n    function decrementFiatPayment(uint16 _tokenId, uint8 _currencyId, uint256 _value) public onlyAllowed {\\n        require(fiatPayment[_tokenId][_currencyId] >= _value, \\\"UserInvestmentImplementer: Not enough fiat\\\");\\n        fiatPayment[_tokenId][_currencyId] -= _value;\\n        if(fiatPayment[_tokenId][_currencyId] == 0) {\\n            uint16[] storage ids = tokenIdsByFiatCurrency[_currencyId];\\n            for(uint16 i = 0; i < ids.length; i++) {\\n                if(ids[i] == _tokenId) {\\n                    ids[i] = ids[ids.length - 1];\\n                    ids.pop();\\n                    break;\\n                }\\n            }\\n        }\\n    }\\n\\n    function getFiatPaymentTokenIds(uint8 _currencyId) public view returns (uint16[] memory) {\\n        return tokenIdsByFiatCurrency[_currencyId];\\n    }\\n\\n    function getFiatPayment(uint16 _tokenId, uint8 _currencyId) public view returns (uint256) {\\n        return fiatPayment[_tokenId][_currencyId];\\n    }\\n\\n    function getValue(uint16 _tokenId, uint32 _projectId, bool _isCrypto) public view returns (uint256) {\\n        return dataTokensToProjects[_tokenId][_projectId][_isCrypto];\\n    }\\n\\n    function getUserTotalInvest(uint16 _tokenId, uint32 _projectId) public view returns (uint256) {\\n        return dataTokensToProjects[_tokenId][_projectId][true] + dataTokensToProjects[_tokenId][_projectId][false];\\n    }\\n\\n    function getValues(uint16 _tokenId, uint32[] memory _projectIds, bool _isCrypto) public view returns (uint256[] memory) {\\n        uint256[] memory retval = new uint256[](_projectIds.length);\\n        for(uint16 i = 0; i < _projectIds.length; i++) {\\n            retval[i] = dataTokensToProjects[_tokenId][_projectIds[i]][_isCrypto];\\n        }\\n        return retval;\\n    }\\n\\n    function getTokenIds(uint32 _projectId) public view returns (uint16[] memory) {\\n        return tokenIds[_projectId];\\n    }\\n\\n    function incrementPayedCrypto(uint32 _projectId, uint16 _tokenId, uint8 _currencyId, uint256 _value) external onlyAllowed {\\n        payedCrypto[_projectId][_tokenId][_currencyId] += _value;\\n    }\\n\\n    function decrementPayedCrypto(uint32 _projectId, uint16 _tokenId, uint8 _currencyId, uint256 _value) external onlyAllowed {\\n        require(payedCrypto[_projectId][_tokenId][_currencyId] >= _value, \\\"UserInvestmentImplementer: Not enough crypto\\\");\\n        payedCrypto[_projectId][_tokenId][_currencyId] -= _value;\\n    }\\n\\n    function getPayedCrypto(uint32 _projectId, uint16 _tokenId, uint8 _currencyId) public view returns (uint256) {\\n        return payedCrypto[_projectId][_tokenId][_currencyId];\\n    }\\n\\n\\n    modifier onlyAllowed() {\\n        require(\\n            TraitRegistry.addressCanModifyTrait(msg.sender, traitId),\\n            \\\"Implementer: Not Authorised\\\" \\n        );\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"contracts/traits/TraitRegistryV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\n\\ncontract TraitRegistryV3 is Ownable {\\n\\n    struct traitStruct {\\n        uint16  id;\\n        uint8   traitType;       \\n        // internal 0 for normal, 1 for inverted, 2 for inverted range,\\n        // external 3 uint8 values, 4 uint256 values, 5 bytes32, 6 string \\n        // external 7 uint8 custom logic\\n        uint16  start;\\n        uint16  end;\\n        address implementer;     // address of the smart contract that will implement extra functionality\\n        bool    enabled;         // frontend decides if it wants to hide or not\\n        string  name;\\n    }\\n\\n    uint16 public traitCount;\\n    mapping(uint16 => traitStruct) public traits;\\n\\n    // token data\\n    mapping(uint16 => mapping(uint16 => uint8) ) public tokenData;\\n\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n    // onlyOwner can change contractControllers and transfer it's ownership\\n    // any contractController can setData\\n    EnumerableSet.AddressSet contractController;\\n\\n    // trait controller access designates sub contracts that can affect 1 or more traits\\n    mapping(uint16 => address ) public traitControllerById;\\n    mapping(address => uint16 ) public traitControllerByAddress;\\n    uint16 public traitControllerCount = 0;\\n\\n    mapping(address => mapping(uint8 => uint8) ) public traitControllerAccess;\\n\\n\\n    /*\\n    *   Events\\n    */\\n    event contractControllerEvent(address _address, bool mode);\\n    event traitControllerEvent(address _address);\\n    \\n    // traits\\n    event newTraitEvent(string _name, address _address, uint8 _traitType, uint16 _start, uint16 _end );\\n    event updateTraitEvent(uint16 indexed _id, string _name, address _address, uint8 _traitType, uint16 _start, uint16 _end);\\n    event updateTraitDataEvent(uint16 indexed _id);\\n    // tokens\\n    event tokenTraitChangeEvent(uint16 indexed _traitId, uint16 indexed _tokenId, bool mode);\\n\\n    function getTraits() public view returns (traitStruct[] memory)\\n    {\\n        traitStruct[] memory retval = new traitStruct[](traitCount);\\n        for(uint16 i = 0; i < traitCount; i++) {\\n            retval[i] = traits[i];\\n        }\\n        return retval;\\n    }\\n\\n    function addTrait(\\n        traitStruct[] calldata _newTraits\\n    ) public onlyAllowed {\\n\\n        for (uint8 i = 0; i < _newTraits.length; i++) {\\n\\n            uint16 newTraitId = traitCount++;\\n            traitStruct storage newT = traits[newTraitId];\\n            newT.id =           _newTraits[i].id;\\n            newT.name =         _newTraits[i].name;\\n            newT.traitType =    _newTraits[i].traitType;\\n            newT.start =        _newTraits[i].start;\\n            newT.end =          _newTraits[i].end;\\n            newT.implementer =  _newTraits[i].implementer;\\n            newT.enabled =      _newTraits[i].enabled;\\n\\n            emit newTraitEvent(newT.name, newT.implementer, newT.traitType, newT.start, newT.end );\\n            setTraitControllerAccess(address(newT.implementer), newTraitId, true);\\n            setTraitControllerAccess(owner(), newTraitId, true);\\n        }\\n    }\\n\\n    function updateTrait(\\n        uint16 _traitId,\\n        string memory _name,\\n        address _implementer,\\n        uint8   _traitType,\\n        uint16  _start,\\n        uint16  _end,\\n        bool    _enabled\\n    ) public onlyAllowed {\\n        traits[_traitId].name = _name;\\n        traits[_traitId].implementer = _implementer;\\n        traits[_traitId].traitType = _traitType;\\n        traits[_traitId].start = _start;\\n        traits[_traitId].end = _end;\\n        traits[_traitId].enabled = _enabled;\\n        \\n        emit updateTraitEvent(_traitId, _name, _implementer, _traitType, _start, _end);\\n    }\\n\\n    function setTrait(uint16 traitID, uint16 tokenId, bool _value) external onlyTraitController(traitID) {\\n        _setTrait(traitID, tokenId, _value);\\n    }\\n\\n    function setTraitOnMultiple(uint16 traitID, uint16[] memory tokenIds, bool[] memory _value) public onlyTraitController(traitID) {\\n        for (uint16 i = 0; i < tokenIds.length; i++) {\\n            _setTrait(traitID, tokenIds[i], _value[i]);\\n        }\\n    }\\n\\n    function _setTrait(uint16 traitID, uint16 tokenId, bool _value) internal {\\n        bool emitvalue = _value;\\n        (uint16 byteNum, uint8 bitPos) = getByteAndBit(tokenId);\\n        if(traits[traitID].traitType == 1 || traits[traitID].traitType == 2) {\\n            _value = !_value; \\n        }\\n        if(_value) {\\n            tokenData[traitID][byteNum] = uint8(tokenData[traitID][byteNum] | 2**bitPos);\\n        } else {\\n            tokenData[traitID][byteNum] = uint8(tokenData[traitID][byteNum] & ~(2**bitPos));\\n        }\\n        emit tokenTraitChangeEvent(traitID, tokenId, emitvalue);\\n    }\\n\\n    // set trait data\\n    function setData(uint16 traitId, uint16[] calldata _ids, uint8[] calldata _data) public onlyTraitController(traitId) {\\n        for (uint16 i = 0; i < _data.length; i++) {\\n            tokenData[traitId][_ids[i]] = _data[i];\\n        }\\n        emit updateTraitDataEvent(traitId);\\n    }\\n\\n    /*\\n    *   View Methods\\n    */\\n\\n    /*\\n    * _perPage = 1250 in order to load 10000 tokens ( 10000 / 8; starting from 0 )\\n    */\\n    function getData(uint16 traitId, uint8 _page, uint16 _perPage) public view returns (uint8[] memory) {\\n        uint16 i = _perPage * _page;\\n        uint16 max = i + (_perPage);\\n        uint16 j = 0;\\n        uint8[] memory retValues = new uint8[](max);\\n        while(i < max) {\\n            retValues[j] = tokenData[traitId][i];\\n            j++;\\n            i++;\\n        }\\n        return retValues;\\n    }\\n\\n    function getTokenData(uint16 tokenId) public view returns (uint8[] memory) {\\n        uint8[] memory retValues = new uint8[](getByteCountToStoreTraitData());\\n        // calculate positions for our token\\n        for(uint16 i = 0; i < traitCount; i++) {\\n            if(hasTrait(i, tokenId)) {\\n                uint8 byteNum = uint8(i / 8);\\n                retValues[byteNum] = uint8(retValues[byteNum] | 2 ** uint8(i - byteNum * 8));\\n            }\\n        }\\n        return retValues;\\n    }\\n\\n    function getTraitControllerAccessData(address _addr) public view returns (uint8[] memory) {\\n        uint16 _returnCount = getByteCountToStoreTraitData();\\n        uint8[] memory retValues = new uint8[](_returnCount);\\n        for(uint8 i = 0; i < _returnCount; i++) {\\n            retValues[i] = traitControllerAccess[_addr][i];\\n        }\\n        return retValues;\\n    }\\n\\n    function getByteCountToStoreTraitData() internal view returns (uint16) {\\n        uint16 _returnCount = traitCount/8;\\n        if(_returnCount * 8 < traitCount) {\\n            _returnCount++;\\n        }\\n        return _returnCount;\\n    }\\n\\n    function getByteAndBit(uint16 _offset) public pure returns (uint16 _byte, uint8 _bit)\\n    {\\n        // find byte storig our bit\\n        _byte = uint16(_offset / 8);\\n        _bit = uint8(_offset - _byte * 8);\\n    }\\n\\n    function getImplementer(uint16 traitID) public view returns (address implementer)\\n    {\\n        return traits[traitID].implementer;\\n    }\\n\\n    function hasTrait(uint16 traitID, uint16 tokenId) public view returns (bool result)\\n    {\\n        (uint16 byteNum, uint8 bitPos) = getByteAndBit(tokenId);\\n        bool _result = tokenData[traitID][byteNum] & (0x01 * 2**bitPos) != 0;\\n        bool _returnVal = (traits[traitID].traitType == 1) ? !_result: _result;\\n        if(traits[traitID].traitType == 2) {\\n            // range trait\\n            if(traits[traitID].start <= tokenId && tokenId <= traits[traitID].end) {\\n                _returnVal = !_result;\\n            }\\n        }\\n        return _returnVal;\\n    }\\n\\n    /*\\n    *   Admin Stuff\\n    */\\n\\n    function setContractController(address _controller, bool _mode) public onlyOwner {\\n        if(_mode) {\\n            contractController.add(_controller);\\n        } else {\\n            contractController.remove(_controller);\\n        }\\n        emit contractControllerEvent(_controller, _mode);\\n    }\\n\\n    function getContractControllerLength() public view returns (uint256) {\\n        return contractController.length();\\n    }\\n\\n    function getContractControllerAt(uint256 _index) public view returns (address) {\\n        return contractController.at(_index);\\n    }\\n\\n    function getContractControllerContains(address _addr) public view returns (bool) {\\n        return contractController.contains(_addr);\\n    }\\n\\n    /*\\n    *   Trait Controllers\\n    */\\n\\n    function indexTraitController(address _addr) internal {\\n        if(traitControllerByAddress[_addr] == 0) {\\n            uint16 controllerId = ++traitControllerCount;\\n            traitControllerByAddress[_addr] = controllerId;\\n            traitControllerById[controllerId] = _addr;\\n        }\\n    }\\n\\n    function setTraitControllerAccessData(address _addr, uint8[] calldata _data) public onlyAllowed {\\n        indexTraitController(_addr);\\n        for (uint8 i = 0; i < _data.length; i++) {\\n            traitControllerAccess[_addr][i] = _data[i];\\n        }\\n        emit traitControllerEvent(_addr);\\n    }\\n\\n    function setTraitControllerAccess(address _addr, uint16 traitID, bool _value) public onlyAllowed {\\n        indexTraitController(_addr);\\n        if(_addr != address(0)) {\\n            (uint16 byteNum, uint8 bitPos) = getByteAndBit(traitID);\\n            if(_value) {\\n                traitControllerAccess[_addr][uint8(byteNum)] = uint8(traitControllerAccess[_addr][uint8(byteNum)] | 2**bitPos);\\n            } else {\\n                traitControllerAccess[_addr][uint8(byteNum)] = uint8(traitControllerAccess[_addr][uint8(byteNum)] & ~(2**bitPos));\\n            }\\n        }\\n        emit traitControllerEvent(_addr);\\n    }\\n \\n    function addressCanModifyTrait(address _addr, uint16 traitID) public view returns (bool result) {\\n        (uint16 byteNum, uint8 bitPos) = getByteAndBit(traitID);\\n        return traitControllerAccess[_addr][uint8(byteNum)] & (0x01 * 2**bitPos) != 0;\\n    }\\n\\n    function addressCanModifyTraits(address _addr, uint16[] memory traitIDs) public view returns (bool result) {\\n        for(uint16 i = 0; i < traitIDs.length; i++) {\\n            if(!addressCanModifyTrait(_addr, traitIDs[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    modifier onlyAllowed() {\\n        require(\\n            msg.sender == owner() || contractController.contains(msg.sender),\\n            \\\"Not Authorised\\\"\\n        );\\n        _;\\n    }\\n    \\n    modifier onlyTraitController(uint16 traitID) {\\n        require(\\n            addressCanModifyTrait(msg.sender, traitID),\\n            \\\"Not Authorised\\\"\\n        );\\n        _;\\n    }\\n}\\n\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_traitRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_projectsTraitId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_userInvetmentTraitId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_reinvestmentTraitId\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_activatedTraitId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"_exchangeRegistryAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"evType\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"fromProjId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"toProjId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isCrypto\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"currency\",\"type\":\"uint8\"}],\"name\":\"InvestEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"eventType\",\"type\":\"uint8\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"investmentCurrency\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"erc20PaymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"returnRate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fundingStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"feeRate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFee\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"minInvestmentPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxInvestmentPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct ProjectInvestImplementer.Project\",\"name\":\"project\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destinationWallet\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"}],\"name\":\"ProjectEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activatedTraitImplementer\",\"outputs\":[{\"internalType\":\"contract TraitUint8ValueImplementer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"destWallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"netInv\",\"type\":\"uint256\"}],\"name\":\"addFiatInvestment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"investmentCurrency\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"erc20PaymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"returnRate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fundingStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"feeRate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFee\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"minInvestmentPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxInvestmentPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"}],\"internalType\":\"struct ProjectInvestImplementer.Project\",\"name\":\"proj\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"destWallet\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"uid\",\"type\":\"string\"}],\"name\":\"addProject\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowedFiatInvest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchangeRegistry\",\"outputs\":[{\"internalType\":\"contract ExchangeRegistry\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"currency\",\"type\":\"uint8\"}],\"name\":\"getFiatPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"currency\",\"type\":\"uint8\"}],\"name\":\"getFiatTokenIdsToPay\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"}],\"name\":\"getProject\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"investmentCurrency\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"erc20PaymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"returnRate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fundingStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"feeRate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFee\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"minInvestmentPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxInvestmentPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"}],\"internalType\":\"struct ProjectInvestImplementer.Project\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"}],\"name\":\"getTotalProjectInvestment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"currency\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"markFiatPaymentAsDone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"safe\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectInvestImplementer\",\"outputs\":[{\"internalType\":\"contract ProjectInvestImplementer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"fromProjectId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"toProjectId\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"tokenId\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"isCrypto\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"reInvestRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestRequestImplementer\",\"outputs\":[{\"internalType\":\"contract ReinvestRequestImplementer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_allowed\",\"type\":\"bool\"}],\"name\":\"setAllowedOffChainInvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"internalType\":\"contract ActivatableToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"traitRegistry\",\"outputs\":[{\"internalType\":\"contract TraitRegistryV3\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"investmentCurrency\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"erc20PaymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minFundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFundingTarget\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"returnRate\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"fundingStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"feeRate\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"flatFee\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"minInvestmentPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxInvestmentPerUser\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"}],\"internalType\":\"struct ProjectInvestImplementer.Project\",\"name\":\"proj\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"destWallet\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"projectId\",\"type\":\"uint32\"}],\"name\":\"updateProject\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_tokenId\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userHasActiveToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userInvestmentImplementer\",\"outputs\":[{\"internalType\":\"contract UserInvestmentImplementer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Invest", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000ed16d7565f30ad094b8a0f24af76032bce5ca098000000000000000000000000f64993e02a15a5d1d1c65face6aefdc69eb9f74200000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000100000000000000000000000011e2b2fdc89ac659a058dfda417777b6675255f1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}