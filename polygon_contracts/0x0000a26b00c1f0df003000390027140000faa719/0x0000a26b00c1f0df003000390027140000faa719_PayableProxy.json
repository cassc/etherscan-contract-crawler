{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/proxy/PayableProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\nimport { PayableProxyInterface } from \\\"../interfaces/PayableProxyInterface.sol\\\";\\n\\ninterface IUpgradeBeacon {\\n    /**\\n     * @notice An external view function that returns the implementation.\\n     *\\n     * @return The address of the implementation.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\\n/**\\n * @title   PayableProxy\\n * @author  OpenSea Protocol Team\\n * @notice  PayableProxy is a beacon proxy which will immediately return if\\n *          called with callvalue. Otherwise, it will delegatecall the beacon\\n *          implementation.\\n */\\ncontract PayableProxy is PayableProxyInterface {\\n    // Address of the beacon.\\n    address private immutable _beacon;\\n\\n    constructor(address beacon) payable {\\n        // Ensure the origin is an approved deployer.\\n        require(\\n            (tx.origin == address(0x939C8d89EBC11fA45e576215E2353673AD0bA18A) ||\\n                tx.origin ==\\n                address(0xe80a65eB7a3018DedA407e621Ef5fb5B416678CA) ||\\n                tx.origin ==\\n                address(0x86D26897267711ea4b173C8C124a0A73612001da) ||\\n                tx.origin ==\\n                address(0x3B52ad533687Ce908bA0485ac177C5fb42972962)),\\n            \\\"Deployment must originate from an approved deployer.\\\"\\n        );\\n        // Set the initial beacon.\\n        _beacon = beacon;\\n    }\\n\\n    function initialize(address ownerToSet) external {\\n        // Ensure the origin is an approved deployer.\\n        require(\\n            (tx.origin == address(0x939C8d89EBC11fA45e576215E2353673AD0bA18A) ||\\n                tx.origin ==\\n                address(0xe80a65eB7a3018DedA407e621Ef5fb5B416678CA) ||\\n                tx.origin ==\\n                address(0x86D26897267711ea4b173C8C124a0A73612001da) ||\\n                tx.origin ==\\n                address(0x3B52ad533687Ce908bA0485ac177C5fb42972962)),\\n            \\\"Initialize must originate from an approved deployer.\\\"\\n        );\\n        // Get the implementation address from the provided beacon.\\n        address implementation = IUpgradeBeacon(_beacon).implementation();\\n\\n        // Create the initializationCalldata from the provided parameters.\\n        bytes memory initializationCalldata = abi.encodeWithSignature(\\n            \\\"initialize(address)\\\",\\n            ownerToSet\\n        );\\n\\n        // Delegatecall into the implementation, supplying initialization\\n        // calldata.\\n        (bool ok, ) = implementation.delegatecall(initializationCalldata);\\n\\n        // Revert and include revert data if delegatecall to implementation\\n        // reverts.\\n        if (!ok) {\\n            assembly {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by\\n     *      `_implementation()`. Will run if no other function in the contract\\n     *      matches the call data.\\n     */\\n    fallback() external payable override {\\n        _fallback();\\n    }\\n\\n    /**\\n     * @dev Internal fallback function that delegates calls to the address\\n     *      returned by `_implementation()`. Will run if no other function\\n     *      in the contract matches the call data.\\n     */\\n    function _fallback() internal {\\n        // Delegate if call value is zero.\\n        if (msg.value == 0) {\\n            _delegate(_implementation());\\n        }\\n    }\\n\\n    /**\\n     * @dev Delegates the current call to `implementation`.\\n     *\\n     * This function does not return to its internal call site, it will\\n     * return directly to the external caller.\\n     */\\n    function _delegate(address implementation) internal virtual {\\n        assembly {\\n            // Copy msg.data. We take full control of memory in this\\n            // inline assembly block because it will not return to\\n            // Solidity code. We overwrite the Solidity scratch pad\\n            // at memory position 0.\\n            calldatacopy(0, 0, calldatasize())\\n\\n            // Call the implementation.\\n            // out and outsize are 0 because we don't know the size yet.\\n            let result := delegatecall(\\n                gas(),\\n                implementation,\\n                0,\\n                calldatasize(),\\n                0,\\n                0\\n            )\\n\\n            // Copy the returned data.\\n            returndatacopy(0, 0, returndatasize())\\n\\n            switch result\\n            // delegatecall returns 0 on error.\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev This function returns the address to which the fallback function\\n     *      should delegate.\\n     */\\n    function _implementation() internal view returns (address) {\\n        return IUpgradeBeacon(_beacon).implementation();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/PayableProxyInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.7;\\n\\n/**\\n * @title   PayableProxyInterface\\n * @author  OpenSea Protocol Team\\n * @notice  PayableProxyInterface contains all external function interfaces\\n *          for the payable proxy.\\n */\\ninterface PayableProxyInterface {\\n    /**\\n     * @dev Fallback function that delegates calls to the address returned by\\n     *      `_implementation()`. Will run if no other function in the contract\\n     *      matches the call data.\\n     */\\n    fallback() external payable;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 19066\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ownerToSet\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PayableProxy", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "19066", "ConstructorArguments": "0000000000000000000000000000000033ca97c0b4df29103dc8da00a967884f", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x0000001fe5cf18002c00272f4665fb67005d1a02", "SwarmSource": ""}