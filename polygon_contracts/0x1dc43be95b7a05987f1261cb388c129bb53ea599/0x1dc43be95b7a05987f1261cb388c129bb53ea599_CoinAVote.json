{"SourceCode": "// File: utils/Imisc.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface Imisc{\r\n    function changeCapsuleContract(address addr) external;//ELFCore\r\n    function changeSpawnContract(address addr) external;//ELFCore\r\n    function changeCoinA(address addr) external;//SpawnContract\r\n    function changeCoinB(address addr) external;//SpawnContract\r\n    function setELFCore(address addr) external;//SpawnContract\r\n    function changeCoinAddresses(uint256 coinType, address addr) external;//CoinMarket\r\n}\r\n// File: utils/ICapsuleContract.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface ICapsuleContract{\r\n    function writePriceInfo(uint256 price) external;\r\n    function getPriceInfo() external view returns(uint256 price,uint256 time);\r\n    function createCapsule(address caller,bool triple) external returns(uint256[] memory, uint256);\r\n    function setELFCoreAddress(address addr) external;\r\n}\r\n// File: utils/ISpawnCoin.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface ISpawnCoin {\r\n\r\n    event SpawnContractAddressChanged(address indexed _from, address indexed _to, uint256 time);\r\n\r\n    function setSpawnContractAddress(address addr) external;\r\n\r\n    function spawnEgg(address addr,uint256 amount) external;\r\n  \r\n}\r\n// File: security/AccessControl.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant NO_PERMISSION='no permission';\r\n    string constant INVALID_ADDRESS ='invalid address';\r\n    \r\n    /// @dev Administrator with highest authority. Should be a multisig wallet.\r\n    address payable superAdmin;\r\n\r\n    /// @dev Administrator of this contract.\r\n    address payable admin;\r\n\r\n    /// Sets the original admin and superAdmin of the contract to the sender account.\r\n    constructor(){\r\n        superAdmin=payable(msg.sender);\r\n        admin=payable(msg.sender);\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the superAdmin.\r\n    modifier onlySuperAdmin{\r\n        require(msg.sender==superAdmin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the admin.\r\n    modifier onlyAdmin{\r\n        require(msg.sender==admin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change superAdmin.\r\n    /// @param addr The address to transfer the right of superAdmin to.\r\n    function changeSuperAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        superAdmin=addr;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change admin.\r\n    /// @param addr The address to transfer the right of admin to.\r\n    function changeAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        admin=addr;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to withdraw balance.\r\n    function withdrawBalance(uint256 amount) external onlySuperAdmin{\r\n        superAdmin.transfer(amount);\r\n    }\r\n\r\n    fallback() external {}\r\n}\r\n// File: security/Pausable.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\ncontract Pausable is AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant PAUSED='paused';\r\n    string constant NOT_PAUSED='not paused';\r\n\r\n    /// @dev Keeps track whether the contract is paused. When this is true, most actions are blocked.\r\n    bool public paused = false;\r\n\r\n    /// @dev Modifier to allow actions only when the contract is not paused\r\n    modifier whenNotPaused {\r\n        require(!paused,PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract is paused\r\n    modifier whenPaused {\r\n        require(paused,NOT_PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to pause the contract. Used when something goes wrong\r\n    ///  and we need to limit damage.\r\n    function pause() external onlySuperAdmin whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the superAdmin.\r\n    function unpause() external onlySuperAdmin whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n// File: token/IERC20.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n\r\n    /// MUST trigger when tokens are transferred, including zero value transfers.\r\n    /// A token contract which creates new tokens SHOULD trigger a Transfer event with \r\n    ///  the _from address set to 0x0 when tokens are created.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /// MUST trigger on any successful call to approve(address _spender, uint256 _value).\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /// Returns the total token supply.\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// Returns the account balance of another account with address _owner.\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /// Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. \r\n    /// The function SHOULD throw if the message caller\u2019s account balance does not have enough tokens to spend.\r\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.\r\n    /// The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. \r\n    /// This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies. \r\n    /// The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism.\r\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// Allows _spender to withdraw from your account multiple times, up to the _value amount. \r\n    /// If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /// Returns the amount which _spender is still allowed to withdraw from _owner.\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n}\r\n// File: token/ERC20Implementation.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n/// @title Standard ERC20 token\r\n\r\ncontract ERC20Implementation is IERC20, Pausable {\r\n\r\n    mapping (address => uint256) _balances;\r\n\r\n    mapping (address => mapping (address => uint256)) _allowed;\r\n\r\n    uint256 _totalSupply;\r\n\r\n    /// @dev Total number of tokens in existence\r\n    function totalSupply() public override view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @dev Gets the balance of the specified address.\r\n    /// @param _owner The address to query the balance of.\r\n    function balanceOf(address _owner) public override view returns (uint256 balance) {\r\n        return _balances[_owner];\r\n    }\r\n\r\n    /// @dev Transfer token for a specified address\r\n    /// @param _to The address to transfer to.\r\n    /// @param _value The amount to be transferred.\r\n    function transfer(address _to, uint256 _value) public whenNotPaused override returns (bool success) {\r\n        require(_to != address(0),INVALID_ADDRESS);\r\n        _balances[msg.sender]-=_value;\r\n        _balances[_to]+=_value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Transfer tokens from one address to another\r\n    /// @param _from address The address which you want to send tokens from\r\n    /// @param _to address The address which you want to transfer to\r\n    /// @param _value uint256 the amount of tokens to be transferred\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused override returns (bool success) {\r\n        require(_to != address(0),INVALID_ADDRESS);\r\n        _balances[_from]-=_value;\r\n        _balances[_to]+=_value;\r\n        _allowed[_from][msg.sender]-=_value;\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    /// @param _spender The address which will spend the funds.\r\n    /// @param _value The amount of tokens to be spent.\r\n    function approve(address _spender, uint256 _value) public whenNotPaused override returns (bool success) {\r\n        require(_spender != address(0),INVALID_ADDRESS);\r\n        _allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    /// @param _owner The address which owns the funds.\r\n    /// @param _spender The address which will spend the funds.\r\n    function allowance(address _owner, address _spender) public override view returns (uint256 remaining) {\r\n        return _allowed[_owner][_spender];\r\n    }\r\n\r\n    /// @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    /// @param spender The address which will spend the funds.\r\n    /// @param addedValue The amount of tokens to increase the allowance by.\r\n    function increaseAllowance(address spender,uint256 addedValue) public whenNotPaused returns (bool) {\r\n        require(spender != address(0),INVALID_ADDRESS);\r\n        _allowed[msg.sender][spender]+=addedValue;\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    /// @param spender The address which will spend the funds.\r\n    /// @param subtractedValue The amount of tokens to decrease the allowance by.\r\n    function decreaseAllowance(address spender,uint256 subtractedValue) public whenNotPaused returns (bool) {\r\n        require(spender != address(0),INVALID_ADDRESS);\r\n        _allowed[msg.sender][spender]-=subtractedValue;\r\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Internal function that mints an amount of the token and assigns it to an account.\r\n    ///  This encapsulates the modification of balances such that the proper events are emitted.\r\n    /// @param account The account that will receive the created tokens.\r\n    /// @param amount The amount that will be created.\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0),INVALID_ADDRESS);\r\n        _totalSupply+=amount;\r\n        _balances[account]+=amount;\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n}\r\n// File: CoinABase.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ncontract CoinABase is ERC20Implementation, ISpawnCoin {\r\n\r\n    string constant WRONG_TIME = \"wrong time\";\r\n    string constant EXECUTED = \"executed\";\r\n\r\n    string _name = \"Rise of Elves\";\r\n    string _symbol = \"ROE\";\r\n\r\n    uint256 public startAt=99999999999999999999999;\r\n\r\n    //bool\r\n    bool isSetAddress = false;\r\n    //\u89e3\u9396\u968e\u6bb5\r\n    uint256 public unlockCounter = 0;\r\n\r\n    //\u4e0d\u540c\u89e3\u9396\u5730\u5740\r\n    address launchpad;\r\n    address privateSell;\r\n    address playToEarn;\r\n    address stakingReward;\r\n    address teamAccount;\r\n    address ecofund;\r\n    address audit;\r\n\r\n    event Bought(address _address, uint256 _amount);\r\n\r\n    constructor() {\r\n        _totalSupply = 300000000 * 1e6;\r\n    }\r\n\r\n    modifier checkAddress() {\r\n        require(\r\n            launchpad != address(0) &&\r\n                privateSell != address(0) &&\r\n                playToEarn != address(0) &&\r\n                stakingReward != address(0) &&\r\n                teamAccount != address(0) &&\r\n                ecofund != address(0) &&\r\n                audit != address(0)\r\n        );\r\n        _;\r\n    }\r\n\r\n    function name() public view returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public pure returns (uint8) {\r\n        return 6;\r\n    }\r\n\r\n    //\u8a2d\u5b9a\u5e33\u6236\r\n    function setAddress(\r\n        address _launchpad,\r\n        address _privateSell,\r\n        address _playToEarn,\r\n        address _stakingReward,\r\n        address _teamAccount,\r\n        address _ecofund,\r\n        address _audit\r\n    ) external onlySuperAdmin {\r\n        launchpad = _launchpad;\r\n        privateSell = _privateSell;\r\n        playToEarn = _playToEarn;\r\n        stakingReward = _stakingReward;\r\n        teamAccount = _teamAccount;\r\n        ecofund = _ecofund;\r\n        audit = _audit;\r\n\r\n        isSetAddress = true;\r\n    }\r\n\r\n    function getAddress()\r\n        external\r\n        view\r\n        returns (\r\n            address _launchpad,\r\n            address _privateSell,\r\n            address _playToEarn,\r\n            address _stakingReward,\r\n            address _teamAccount,\r\n            address _ecofund,\r\n            address _audit\r\n        )\r\n    {\r\n        return (\r\n            launchpad,\r\n            privateSell,\r\n            playToEarn,\r\n            stakingReward,\r\n            teamAccount,\r\n            ecofund,\r\n            audit\r\n        );\r\n    }\r\n\r\n    function setStartTime(uint256 _uint) external onlySuperAdmin {\r\n        require(block.timestamp<startAt,'expired');\r\n        startAt = _uint;\r\n    }\r\n\r\n    //init\r\n    function initUnlock() public onlyAdmin checkAddress {\r\n        require(block.timestamp>=startAt,'too early');\r\n        require(isSetAddress, \"Set the Address first\");\r\n        require(unlockCounter == 0, \"already unlock init counter\");\r\n        _balances[launchpad] += 30000000 * 1e6;\r\n        _balances[privateSell] += 3000000 * 1e6;\r\n        _balances[playToEarn] += 5000000 * 1e6;\r\n        _balances[stakingReward] += 2000000 * 1e6;\r\n        _balances[teamAccount] += 10000000 * 1e6;\r\n        _balances[ecofund] += 6000000 * 1e6;\r\n        _balances[audit] += 4000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    /// @dev First phase unlock.\r\n    function unlock_3month() public {\r\n        require(block.timestamp >= startAt + 3 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 1, EXECUTED);\r\n        _balances[playToEarn] += 5000000 * 1e6;\r\n        _balances[stakingReward] += 5900000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_6month() public {\r\n        require(block.timestamp >= startAt + 6 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 2, EXECUTED);\r\n        _balances[privateSell] += 3000000 * 1e6;\r\n        _balances[playToEarn] += 10000000 * 1e6;\r\n        _balances[stakingReward] += 5600000 * 1e6;\r\n        _balances[ecofund] += 6000000 * 1e6;\r\n        _balances[audit] += 2000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_12month() public {\r\n        require(block.timestamp >= startAt + 12 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 3, EXECUTED);\r\n        _balances[privateSell] += 3000000 * 1e6;\r\n        _balances[playToEarn] += 8000000 * 1e6;\r\n        _balances[stakingReward] += 10700000 * 1e6;\r\n        _balances[teamAccount] += 8000000 * 1e6;\r\n        _balances[ecofund] += 6000000 * 1e6;\r\n        _balances[audit] += 2000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_18month() public {\r\n        require(block.timestamp >= startAt + 18 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 4, EXECUTED);\r\n        _balances[privateSell] += 3000000 * 1e6;\r\n        _balances[playToEarn] += 8000000 * 1e6;\r\n        _balances[stakingReward] += 10200000 * 1e6;\r\n        _balances[teamAccount] += 8000000 * 1e6;\r\n        _balances[ecofund] += 6000000 * 1e6;\r\n        _balances[audit] += 2000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_24month() public {\r\n        require(block.timestamp >= startAt + 24 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 5, EXECUTED);\r\n        _balances[privateSell] += 3000000 * 1e6;\r\n        _balances[playToEarn] += 5000000 * 1e6;\r\n        _balances[stakingReward] += 10000000 * 1e6;\r\n        _balances[teamAccount] += 5000000 * 1e6;\r\n        _balances[ecofund] += 5000000 * 1e6;\r\n        _balances[audit] += 2000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_30month() public {\r\n        require(block.timestamp >= startAt + 30 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 6, EXECUTED);\r\n        _balances[playToEarn] += 5000000 * 1e6;\r\n        _balances[stakingReward] += 9000000 * 1e6;\r\n        _balances[teamAccount] += 4000000 * 1e6;\r\n        _balances[ecofund] += 4000000 * 1e6;\r\n        _balances[audit] += 1000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_36month() public {\r\n        require(block.timestamp >= startAt + 36 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 7, EXECUTED);\r\n        _balances[playToEarn] += 4000000 * 1e6;\r\n        _balances[stakingReward] += 8800000 * 1e6;\r\n        _balances[teamAccount] += 3000000 * 1e6;\r\n        _balances[ecofund] += 3000000 * 1e6;\r\n        _balances[audit] += 1000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_42month() public {\r\n        require(block.timestamp >= startAt + 42 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 8, EXECUTED);\r\n        _balances[playToEarn] += 4000000 * 1e6;\r\n        _balances[stakingReward] += 7800000 * 1e6;\r\n        _balances[teamAccount] += 3000000 * 1e6;\r\n        _balances[ecofund] += 3000000 * 1e6;\r\n        _balances[audit] += 1000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_48month() public {\r\n        require(block.timestamp >= startAt + 48 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 9, EXECUTED);\r\n        _balances[playToEarn] += 3000000 * 1e6;\r\n        _balances[stakingReward] += 7625000 * 1e6;\r\n        _balances[teamAccount] += 2000000 * 1e6;\r\n        _balances[ecofund] += 3000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_54month() public {\r\n        require(block.timestamp >= startAt + 54 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 10, EXECUTED);\r\n        _balances[playToEarn] += 3000000 * 1e6;\r\n        _balances[stakingReward] += 6750000 * 1e6;\r\n        _balances[teamAccount] += 2000000 * 1e6;\r\n        _balances[ecofund] += 3000000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function unlock_60month() public {\r\n        require(block.timestamp >= startAt + 60 * 30 days, WRONG_TIME);\r\n        require(unlockCounter == 11, EXECUTED);\r\n\r\n        _balances[stakingReward] += 5625000 * 1e6;\r\n        unlockCounter++;\r\n    }\r\n\r\n    function getNow() external view returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    address public SpawnContractAddress;\r\n\r\n    function setSpawnContractAddress(address addr) external override onlySuperAdmin {\r\n        require(addr != address(0), INVALID_ADDRESS);\r\n        emit SpawnContractAddressChanged(SpawnContractAddress, addr, block.timestamp);\r\n        SpawnContractAddress = addr;\r\n    }\r\n\r\n    function spawnEgg(address addr, uint256 amount)\r\n        external\r\n        override\r\n        whenNotPaused\r\n    {\r\n        require(ecofund != address(0), INVALID_ADDRESS);\r\n        require(msg.sender == SpawnContractAddress,NO_PERMISSION);\r\n        _balances[addr] -= amount;\r\n        _balances[ecofund] += amount;\r\n        emit Transfer(addr, ecofund, amount);\r\n    }\r\n}\r\n\r\n// File: CoinA.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\n\r\ncontract CoinADAO is CoinABase {\r\n\r\n    bool public startDAO;\r\n\r\n    /// @dev Total amount of staking.\r\n    uint256 public totalStaking;\r\n\r\n    string constant NO_DAO='DAO functions not available now';\r\n\r\n    /// @dev Mapping from an address to its amount of staking for vote.\r\n    mapping (address => uint256) public staking;\r\n\r\n    /// @dev Mapping from an address to its amount of ballot.\r\n    mapping (address => uint256) public ballot;\r\n\r\n    /// @dev Mapping from an address to the address which is assigned stake.\r\n    mapping (address => address) public assignedStaking;\r\n\r\n    /// @dev Start DAO. In the meantime, superAdmin should change superAdmin to this contract.\r\n    ///  Cautious! This function is irreversible.\r\n    function activateDAO() external onlySuperAdmin {\r\n        startDAO=true;\r\n    }\r\n\r\n    /// @dev Stake for vote.\r\n    /// @param amount Amount of coinA that caller want to stake.\r\n    function stake(uint256 amount) external whenNotPaused{\r\n        require(startDAO,NO_DAO);\r\n        totalStaking+=amount;\r\n        staking[msg.sender]+=amount;\r\n        transfer(address(this),amount);\r\n        if (assignedStaking[msg.sender]!=address(0)){\r\n            ballot[assignedStaking[msg.sender]]+=amount;\r\n        }\r\n        else{\r\n            ballot[msg.sender]+=amount;\r\n        }\r\n    }\r\n\r\n    /// @dev Caller assigns all staking to _to.\r\n    /// @param _to If _to==address(0) or _to==msg.sender, cancel assignment.\r\n    function assignStaking(address _to) external whenNotPaused{\r\n        require(startDAO,NO_DAO);\r\n        address assigned=assignedStaking[msg.sender];\r\n        uint256 amount=staking[msg.sender];\r\n        if(_to==address(0) && assigned!=address(0)){\r\n            ballot[assigned]-=amount;\r\n            ballot[msg.sender]+=amount;\r\n        }\r\n        else if(_to!=address(0) && assigned!=address(0)){\r\n            ballot[assigned]-=amount;\r\n            ballot[_to]+=amount;\r\n        }\r\n        else if(_to!=address(0) && assigned==address(0)){\r\n            ballot[msg.sender]-=amount;\r\n            ballot[_to]+=amount;\r\n        }\r\n        assignedStaking[msg.sender]=_to;\r\n    }\r\n\r\n    /// @dev Withdraw stake for vote.\r\n    /// @param amount Amount of coinA that caller want to withdraw.\r\n    function withdrawStake(uint256 amount) external whenNotPaused{\r\n        require(startDAO,NO_DAO);\r\n        totalStaking-=amount;\r\n        staking[msg.sender]-=amount;\r\n        this.transfer(msg.sender,amount);\r\n        if (assignedStaking[msg.sender]!=address(0)){\r\n            ballot[assignedStaking[msg.sender]]-=amount;\r\n        }\r\n        else{\r\n            ballot[msg.sender]-=amount;\r\n        }\r\n    }\r\n}\r\n\r\ncontract CoinAVote is CoinADAO{\r\n\r\n    /// @dev Mapping from normal proposal id to a mapping which map address to \r\n    ///  whether the address has voted for the proposal.\r\n    mapping (uint256 => mapping (address => bool)) normalConfirmations;\r\n\r\n    /// @dev Mapping from noraml proposal id to address array which contains all addresses\r\n    ///  that has voted for the proposal. \r\n    mapping (uint256 => address[]) normalConfirmedAddresses; \r\n\r\n    /// @dev Mapping from normal proposal id to whether vote result has been calculated.\r\n    mapping (uint256 => bool) calculated;\r\n\r\n    /// @dev Mapping from normal proposal id to an uint array, where each \r\n    ///  element is the corresponding ballot of options. \r\n    mapping (uint256 => uint256[10]) normalProposalResult;\r\n\r\n    /// @dev Mapping from normal proposal id to a mapping which map index of options to all addresses approved it.\r\n    mapping (uint256 => mapping(uint256 => address[])) normalOptionsToApproved;\r\n\r\n    /// @dev Mapping from proposal id to a mapping which map address to its vote(index of options).\r\n    mapping (uint256 => mapping (address => uint256)) voteTo;\r\n\r\n    struct NormalProposal{\r\n        address proposer;\r\n        bool isAnonymous;\r\n        bool isPublic;\r\n        uint256 endAt;\r\n        string[] options;\r\n    }\r\n\r\n    NormalProposal[] NormalProposals;\r\n\r\n    string constant BALLOT_NOT_ENOUGH='ballot not enough';\r\n    string constant VOTED='you have voted for this proposal';\r\n    string constant VOTE_EXPIRED='vote period expired';\r\n    string constant VOTE_NOT_END='vote period not end';\r\n    string constant ANONYMOUS='This proposal is anonymous';\r\n    string constant PRIVATE='private proposal, check result after conclusion';\r\n    string constant NAMEED_AND_PRIVATE=\"vote can't be named and private at the same time\";\r\n    string constant NO_STAKING='no one staked';\r\n\r\n    /// @dev Submit a normal proposal . Only address with more than 10% stake can submit proposals.\r\n    /// @param isAnonymous Is the election anonymous?\r\n    /// @param isPublic Is the elction public?\r\n    /// @param isWeek Is the election last for a week or two weeks?\r\n    /// @param options Options of vote.\r\n    /// @return id Index in NormalProposals.\r\n    function submitNormalProposal(bool isAnonymous, bool isPublic, bool isWeek,string[] memory options) external returns(uint256 id){\r\n        require(totalStaking!=0,NO_STAKING);\r\n        require(ballot[msg.sender]*10>=totalStaking,BALLOT_NOT_ENOUGH);\r\n        require(options.length>=1 && options.length<=10,'length of options must between 1 and 10');\r\n        if (isPublic==false && isAnonymous==false){\r\n            require(false,NAMEED_AND_PRIVATE);\r\n        }\r\n        uint256 interval=1209600;\r\n        if (isWeek){\r\n            interval=604800;\r\n        }\r\n        NormalProposal memory _Proposal=NormalProposal({\r\n            proposer:msg.sender,\r\n            isAnonymous:isAnonymous,\r\n            isPublic:isPublic,\r\n            endAt:interval+block.timestamp,\r\n            options:options\r\n        });\r\n        id=NormalProposals.length;\r\n        NormalProposals.push(_Proposal);\r\n    }\r\n\r\n    /// @dev Confirm a normal proposal. Anyone can confirm a normal proposal. \r\n    ///  Valid ballot will be calculated at the first call of executeProposal after deadline.\r\n    /// @param id Id of normal proposal.\r\n    /// @param optionIndex Index of options.\r\n    function confirmNormalProposal(uint256 id,uint256 optionIndex) external {\r\n        require(NormalProposals[id].endAt>block.timestamp,VOTE_EXPIRED);\r\n        require(!normalConfirmations[id][msg.sender],VOTED);\r\n        require(optionIndex<NormalProposals[id].options.length,'invalid target');\r\n        normalConfirmations[id][msg.sender]=true;\r\n        normalConfirmedAddresses[id].push(msg.sender);\r\n        normalOptionsToApproved[id][optionIndex].push(msg.sender);\r\n        voteTo[id][msg.sender]=optionIndex;\r\n    }\r\n\r\n    /// @dev Calulate result of normal proposal. Consequence will be recorded in normalProposalResult.\r\n    /// @param id Id of normal proposal.\r\n    function calculateNormalProposal(uint256 id) external {\r\n        require(NormalProposals[id].endAt<block.timestamp,VOTE_NOT_END);\r\n        require(!calculated[id],'result has been calculated');\r\n        calculated[id]=true;\r\n        address[] memory addrs=normalConfirmedAddresses[id];\r\n        for (uint256 i=0;i<addrs.length;i++){\r\n            normalProposalResult[id][voteTo[id][addrs[i]]]+=ballot[addrs[i]];\r\n        }\r\n    }\r\n\r\n    /// @dev Return information about normal proposal.\r\n    function gainNormalProposal(uint256 id) external view returns(address,bool,bool,uint256,string[] memory){\r\n        NormalProposal memory temp=NormalProposals[id];\r\n        return (temp.proposer,temp.isAnonymous,temp.isPublic,temp.endAt,temp.options);\r\n    }\r\n\r\n    /// @dev Return addresses which approved optionIndex.\r\n    function gainNormalNamed(uint256 id,uint256 optionIndex) external view returns(address[] memory){\r\n        require(!NormalProposals[id].isAnonymous,ANONYMOUS);\r\n        return normalOptionsToApproved[id][optionIndex];\r\n    }\r\n\r\n    /// @dev Return ballot of each option in options. This may not be the final result.\r\n    /// @return res Final result or current result. Depends on isFinal.\r\n    /// @return isFinal If isFinal is true, res is the final result, else res may change in the future.\r\n    function gainNormalBallot(uint256 id) external view returns(uint256[10] memory res,bool isFinal){\r\n        if (calculated[id]){\r\n            res=normalProposalResult[id];\r\n            isFinal=true;\r\n        }\r\n        else{\r\n            require(NormalProposals[id].isPublic,PRIVATE);\r\n            address[] memory addrs=normalConfirmedAddresses[id];\r\n            for (uint256 i=0;i<addrs.length;i++){\r\n                res[voteTo[id][addrs[i]]]+=ballot[addrs[i]];\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev When an important proposal is executed, emit this event with executed==true.\r\n    ///  When an important proposal is dropped, emit this event with executed==false.\r\n    event importantProposalEvent(uint256 indexed id,\r\n        address indexed proposer,\r\n        address indexed sc,\r\n        uint256 op,\r\n        uint256 endAt,\r\n        bool isAnonymous,\r\n        bool isPublic,\r\n        address param1,\r\n        uint256 param2,\r\n        bool executed);\r\n\r\n    /// @dev Mapping from important proposalId to a mapping which map address to wether the address has voted for the proposal.\r\n    mapping (uint256 => mapping (address => bool)) importantConfirmations;\r\n    /// @dev Mapping from important proposalId to all addresses voted for it.\r\n    mapping (uint256 => address[]) importantConfirmedAddresses;\r\n\r\n    struct ImportantProposal{\r\n        uint256 id;\r\n        address proposer;\r\n        address sc;\r\n        uint256 op;\r\n        bool isAnonymous;\r\n        bool isPublic;\r\n        uint256 endAt;\r\n        address param1;\r\n        uint256 param2;\r\n    }\r\n\r\n    ImportantProposal[] ImportantProposals;\r\n\r\n    uint256 importantProposalCount;\r\n\r\n    /// @dev Submit a proposal . Only address with more than 10% stake can submit proposal.\r\n    /// @param sc Target smart contract.\r\n    /// @param op Operation type executed by sc.\r\n    /// @param isAnonymous Is the election anonymous?\r\n    /// @param isPublic Is the elction public?\r\n    /// @param isWeek Is the election last for a week or two weeks?\r\n    /// @param param1 Parameter of operation op.\r\n    /// @param param2 Parameter of operation op.\r\n    function submitImportantProposal(address sc, uint256 op, bool isAnonymous, bool isPublic, bool isWeek,address param1, uint256 param2) external returns(uint256 id){\r\n        require(totalStaking!=0,NO_STAKING);\r\n        require(ballot[msg.sender]*10>=totalStaking,BALLOT_NOT_ENOUGH);\r\n        require(op<15,'wrong op');\r\n        if (isPublic==false && isAnonymous==false){\r\n            require(false,NAMEED_AND_PRIVATE);\r\n        }\r\n        uint256 interval=1209600;\r\n        if (isWeek){\r\n            interval=604800;\r\n        }\r\n        ImportantProposal memory _Proposal=ImportantProposal({\r\n            id:importantProposalCount,\r\n            proposer:msg.sender,\r\n            sc:sc,\r\n            op:op,\r\n            isAnonymous:isAnonymous,\r\n            isPublic:isPublic,\r\n            endAt:interval+block.timestamp,\r\n            param1: param1,\r\n            param2: param2\r\n        });\r\n        id=importantProposalCount;\r\n        importantProposalCount++;\r\n        ImportantProposals.push(_Proposal);\r\n        confirmImportantProposal(id);\r\n    }\r\n\r\n    /// @dev Confirm a proposal. Anyone can confirm a proposal. \r\n    ///  Valid ballot will be calculated at the first call of executeProposal after deadline.\r\n    ///  Ensure that _Proposal.sc is correct address.\r\n    function confirmImportantProposal(uint256 id) public {\r\n        removeExpiredProposal();\r\n        uint256 i=findIndex(id);\r\n        require(ImportantProposals[i].endAt>block.timestamp,VOTE_EXPIRED);\r\n        require(!importantConfirmations[id][msg.sender],VOTED);\r\n        importantConfirmations[id][msg.sender]=true;\r\n        importantConfirmedAddresses[id].push(msg.sender);\r\n    }\r\n\r\n    function executeProposal(uint256 id) external {\r\n        removeExpiredProposal();\r\n        uint256 i=findIndex(id);\r\n        ImportantProposal memory _Proposal=ImportantProposals[i];\r\n        require(_Proposal.endAt<block.timestamp,VOTE_NOT_END);\r\n        uint256 op=_Proposal.op;\r\n        uint256 l=ImportantProposals.length;\r\n        ImportantProposals[i]=ImportantProposals[l-1];\r\n        ImportantProposals.pop();\r\n        if (op==0) {\r\n            AccessControl sc=AccessControl(_Proposal.sc);\r\n            sc.changeSuperAdmin(payable(_Proposal.param1));\r\n        }\r\n        else if (op==1) {\r\n            AccessControl sc=AccessControl(_Proposal.sc);\r\n            sc.changeAdmin(payable(_Proposal.param1));\r\n        }\r\n        else if (op==2) {\r\n            AccessControl sc=AccessControl(_Proposal.sc);\r\n            sc.withdrawBalance(_Proposal.param2);\r\n        }\r\n        else if (op==3) {\r\n            Pausable sc=Pausable(_Proposal.sc);\r\n            sc.pause();\r\n        }\r\n        else if (op==4) {\r\n            Pausable sc=Pausable(_Proposal.sc);\r\n            sc.unpause();\r\n        }\r\n        else if (op==5) {\r\n            ISpawnCoin sc=ISpawnCoin(_Proposal.sc);\r\n            sc.setSpawnContractAddress(_Proposal.param1);\r\n        }\r\n        else if (op==6) {\r\n            ICapsuleContract sc=ICapsuleContract(_Proposal.sc);\r\n            sc.setELFCoreAddress(_Proposal.param1);\r\n        }\r\n        else if (op==7) {\r\n            Imisc sc=Imisc(_Proposal.sc);\r\n            sc.changeCoinAddresses(_Proposal.param2,_Proposal.param1);\r\n        }\r\n        else if (op==8) {\r\n            ERC20Implementation sc=ERC20Implementation(_Proposal.sc);\r\n            sc.transfer(_Proposal.param1,_Proposal.param2);\r\n        }\r\n        else if (op==9) {\r\n            Imisc sc=Imisc(_Proposal.sc);\r\n            sc.setELFCore(_Proposal.param1);\r\n        }\r\n        else if (op==10) {\r\n            Imisc sc=Imisc(_Proposal.sc);\r\n            sc.changeCapsuleContract(_Proposal.param1);\r\n        }\r\n        else if (op==11) {\r\n            Imisc sc=Imisc(_Proposal.sc);\r\n            sc.changeSpawnContract(_Proposal.param1);\r\n        }\r\n        else if (op==12) {\r\n            Imisc sc=Imisc(_Proposal.sc);\r\n            sc.changeCoinA(_Proposal.param1);\r\n        }\r\n        else if (op==13) {\r\n            Imisc sc=Imisc(_Proposal.sc);\r\n            sc.changeCoinB(_Proposal.param1);\r\n        }\r\n        else if (op==14) {\r\n            payable(_Proposal.param1).transfer(_Proposal.param2);\r\n        }\r\n        emit importantProposalEvent(_Proposal.id,_Proposal.proposer,_Proposal.sc,_Proposal.op,_Proposal.endAt,_Proposal.isAnonymous,_Proposal.isPublic,_Proposal.param1,_Proposal.param2,true);\r\n    }\r\n\r\n    /// @dev Return information about important proposal.\r\n    function gainImportantProposal(uint256 id) external view returns(address,address,uint256,bool,bool,uint256,address,uint256){\r\n        uint256 i=findIndex(id);\r\n        ImportantProposal memory temp=ImportantProposals[i];\r\n        return (temp.proposer,temp.sc,temp.op,temp.isAnonymous,temp.isPublic,temp.endAt,temp.param1,temp.param2);\r\n    }\r\n\r\n    /// @dev Return addresses which approved the proposal.\r\n    function gainImportantNamed(uint256 id) external view returns(address[] memory){\r\n        uint256 i=findIndex(id);\r\n        require(!ImportantProposals[i].isAnonymous,ANONYMOUS);\r\n        return importantConfirmedAddresses[id];\r\n    }\r\n\r\n    /// @dev Return current ballot of the given important proposal.\r\n    function gainImportantBallot(uint256 id) external view returns(uint256 res){\r\n        uint256 i=findIndex(id);\r\n        require(ImportantProposals[i].isPublic,PRIVATE);\r\n        address[] memory addrs=importantConfirmedAddresses[id];\r\n        for (uint256 i2=0;i2<addrs.length;i2++){\r\n            res+=ballot[addrs[i2]];\r\n        }\r\n    }\r\n\r\n    /// @dev Find index of id in ImportantProposals.\r\n    function findIndex(uint256 id) internal view returns(uint256 i){\r\n        uint256 l=ImportantProposals.length;\r\n        while (i<l){\r\n            if (ImportantProposals[i].id==id){\r\n                break;\r\n            }\r\n            i++;\r\n        }\r\n        require(i<l,'proposal not found');\r\n    }\r\n\r\n    /// @dev If deadline come, and proposal not achieve goal, drop it. Else, pass\r\n    function removeExpiredProposal() internal {\r\n        uint256 l=ImportantProposals.length;\r\n        for (uint256 i=0;i<l;){\r\n            if (ImportantProposals[i].endAt<=block.timestamp && !goalAchieved(i)){\r\n                ImportantProposal memory _Proposal=ImportantProposals[i];\r\n                emit importantProposalEvent(_Proposal.id,_Proposal.proposer,_Proposal.sc,_Proposal.op,_Proposal.endAt,_Proposal.isAnonymous,_Proposal.isPublic,_Proposal.param1,_Proposal.param2,false);\r\n                ImportantProposals[i]=ImportantProposals[l-1];\r\n                ImportantProposals.pop();\r\n                l--;\r\n            }\r\n            else{\r\n                i+=1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Examine whether the important proposal can be executeed.\r\n    ///  This function doesn't check wether deadline has come.\r\n    /// @param i Index in array ImportantProposals.\r\n    function goalAchieved(uint256 i) internal view returns(bool){\r\n        ImportantProposal memory _Proposal=ImportantProposals[i];\r\n        uint256 id=_Proposal.id;\r\n        address[] memory addrs=importantConfirmedAddresses[id];\r\n        uint256 l=addrs.length;\r\n        uint256 total;\r\n        for (uint256 i2;i2<l;i2++){\r\n            total+=ballot[addrs[i2]];\r\n        }\r\n        return total*2>=totalStaking;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Bought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"SpawnContractAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"proposer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sc\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"op\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endAt\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAnonymous\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isPublic\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"param1\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"param2\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"executed\",\"type\":\"bool\"}],\"name\":\"importantProposalEvent\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"SpawnContractAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activateDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"assignStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"assignedStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ballot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"calculateNormalProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"confirmImportantProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionIndex\",\"type\":\"uint256\"}],\"name\":\"confirmNormalProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"executeProposal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"gainImportantBallot\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"gainImportantNamed\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"gainImportantProposal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"gainNormalBallot\",\"outputs\":[{\"internalType\":\"uint256[10]\",\"name\":\"res\",\"type\":\"uint256[10]\"},{\"internalType\":\"bool\",\"name\":\"isFinal\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"optionIndex\",\"type\":\"uint256\"}],\"name\":\"gainNormalNamed\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"gainNormalProposal\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_launchpad\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_privateSell\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_playToEarn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingReward\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ecofund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_audit\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initUnlock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_launchpad\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_privateSell\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_playToEarn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stakingReward\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_teamAccount\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ecofund\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_audit\",\"type\":\"address\"}],\"name\":\"setAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setSpawnContractAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_uint\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"spawnEgg\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"staking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startDAO\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sc\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"op\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAnonymous\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPublic\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWeek\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"param1\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"param2\",\"type\":\"uint256\"}],\"name\":\"submitImportantProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isAnonymous\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isPublic\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWeek\",\"type\":\"bool\"},{\"internalType\":\"string[]\",\"name\":\"options\",\"type\":\"string[]\"}],\"name\":\"submitNormalProposal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaking\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_12month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_18month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_24month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_30month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_36month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_3month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_42month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_48month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_54month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_60month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlock_6month\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CoinAVote", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3d063d9f0a81a2aa04e794d1cb0bbcfccc1a46c5296719b7840c526edce2beba"}