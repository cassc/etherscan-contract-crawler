{"SourceCode": "{\"abstract.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.19;\\n\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;}\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;}}\\n\\nabstract contract ReentrancyGuard {\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n    uint256 private _status;\\n    constructor() {\\n        _status = _NOT_ENTERED;}\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        _status = _ENTERED;\\n        _;\\n        _status = _NOT_ENTERED;}}\\n\\nabstract contract Ownable is Context {\\n    address private _owner;\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n    constructor() {\\n        _transferOwnership(_msgSender());}\\n    function owner() public view virtual returns (address) {\\n        return _owner;}\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;}\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));}\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);}\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);}}\\n\"},\"interface.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.19;\\n\\ninterface NewIERC20 {\\n    function transfer(address, uint) external returns (bool);}\\n\\ninterface OldIERC20 {\\n    function transfer(address, uint) external;}\\n\\ninterface IERC20 {\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n    function totalSupply() external view returns (uint256);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address to, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);}\\n\\ninterface IERC20Permit {\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n    function nonces(address owner) external view returns (uint256);\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);}\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        return account.code.length \\u003e 0;}\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance \\u003e= amount, \\\"Address: insufficient balance\\\");\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");}  \\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");}\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);}\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");}\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance \\u003e= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);}\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");}\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);}\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");}\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);}\\n    function verifyCallResultFromTarget(address target, bool success, bytes memory returndata, string memory errorMessage) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                require(isContract(target), \\\"Address: call to non-contract\\\");}\\n            return returndata;} \\n        else {\\n            _revert(returndata, errorMessage);}}\\n    function verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;}\\n        else {\\n            _revert(returndata, errorMessage);}}\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        if (returndata.length \\u003e 0) {\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)}}\\n        else {\\n            revert(errorMessage);}}}\\n\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));}\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));}\\n        \\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0), \\\"SafeERC20: approve from non-zero to non-zero allowance\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));}\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));}\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance \\u003e= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));}}\\n\\n    function safePermit(IERC20Permit token, address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");}\\n    \\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length \\u003e 0) {\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");}}}\\n\"},\"swappy.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.19;\\n\\n//    .-\\u0027\\u0027\\u0027-. .--.      .--.   ____    .-------. .-------.  ____     __  \\n//   / _     \\\\|  |_     |  | .\\u0027  __ `. \\\\  _(`)_ \\\\\\\\  _(`)_ \\\\ \\\\   \\\\   /  / \\n//  (`\\u0027 )/`--\\u0027| _( )_   |  |/   \\u0027  \\\\  \\\\| (_ o._)|| (_ o._)|  \\\\  _. /  \\u0027  \\n// (_ o _).   |(_ o _)  |  ||___|  /  ||  (_,_) /|  (_,_) /   _( )_ .\\u0027   \\n//  (_,_). \\u0027. | (_,_) \\\\ |  |   _.-`   ||   \\u0027-.-\\u0027 |   \\u0027-.-\\u0027___(_ o _)\\u0027    \\n// .---.  \\\\  :|  |/    \\\\|  |.\\u0027   _    ||   |     |   |   |   |(_,_)\\u0027     \\n// \\\\    `-\\u0027  ||  \\u0027  /\\\\  `  ||  _( )_  ||   |     |   |   |   `-\\u0027  /      \\n//  \\\\       / |    /  \\\\    |\\\\ (_ o _) //   )     /   )    \\\\      /       \\n//   `-...-\\u0027  `---\\u0027    `---` \\u0027.(_,_).\\u0027 `---\\u0027     `---\\u0027     `-..-\\u0027        \\n\\n//Giuliano Neroni DEV\\n//https://www.giulianoneroni.com/\\n\\nimport \\\"./abstract.sol\\\";\\nimport \\\"./interface.sol\\\";\\n\\ncontract Swappy is Ownable, ReentrancyGuard {\\n\\n    address public swappyWallet;\\n    address public limitWallet;\\n    using SafeERC20 for IERC20;\\n\\n    //maxApproveValue = 115792089237316195423570985008687907853269984665640564039457584007913129639935;\\n\\n    fallback() external payable {}\\n    receive() external payable {}\\n\\n    //Wallet Setting\\n\\n    function setSwappyWallet(address _swappyWallet) public onlyOwner() {\\n        swappyWallet = _swappyWallet;}\\n\\n    function setLimitWallet(address _limitWallet) public onlyOwner() {\\n        limitWallet = _limitWallet;}\\n\\n    //Operative function\\n\\n    function swappyAnyToken(address _tokenToSwap, uint256 amount, address tokenTo, string memory blockchainTo, string memory differentWallet, string memory refCode) public payable {\\n        IERC20 tokenToSwap = IERC20(_tokenToSwap);\\n        uint256 balance = tokenToSwap.balanceOf(msg.sender);\\n        require(balance \\u003e 0, \\\"You have no token to swap\\\");\\n        require(tokenToSwap.allowance(msg.sender, address(this)) \\u003e= amount, \\\"Approve Necessary\\\");\\n        tokenToSwap.safeTransferFrom(msg.sender, swappyWallet, amount);}\\n\\n    function swappyETH(uint256 amount, address tokenTo, string memory blockchainTo, string memory differentWallet, string memory refCode) public payable {\\n        require(msg.sender.balance \\u003e 0, \\\"You have no token to swap\\\");\\n        (bool sent,) = swappyWallet.call{value: (amount)}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");}\\n        \\n    function limitBuy(address _tokenToSwap, uint256 amount, address tokenTo, string memory blockchainTo, string memory differentWallet, string memory condition, string memory price, uint256 expiration, string memory refCode) public {\\n        IERC20 tokenToSwap = IERC20(_tokenToSwap);\\n        uint256 balance = tokenToSwap.balanceOf(msg.sender);\\n        require(balance \\u003e 0, \\\"You have no token to swap\\\");\\n        require(tokenToSwap.allowance(msg.sender, address(this)) \\u003e= amount, \\\"Approve Necessary\\\");\\n        tokenToSwap.safeTransferFrom(msg.sender, limitWallet, amount);}\\n\\n    function limitSellAnyToken(address _tokenToSwap, uint256 amount, address tokenTo, string memory blockchainTo, string memory differentWallet, string memory price_gain, string memory price_loss, uint256 expiration, string memory refCode) public {\\n        IERC20 tokenToSwap = IERC20(_tokenToSwap);\\n        uint256 balance = tokenToSwap.balanceOf(msg.sender);\\n        require(balance \\u003e 0, \\\"You have no token to swap\\\");\\n        require(tokenToSwap.allowance(msg.sender, address(this)) \\u003e= amount, \\\"Approve Necessary\\\");\\n        tokenToSwap.safeTransferFrom(msg.sender, limitWallet, amount);}    \\n\\n    function limitSellETH(uint256 amount, address tokenTo, string memory blockchainTo, string memory differentWallet, string memory price_gain, string memory price_loss, uint256 expiration, string memory refCode) public payable {\\n        require(msg.sender.balance \\u003e 0, \\\"You have no token to swap\\\");\\n        (bool sent,) = limitWallet.call{value: amount}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");}  \\n\\n    //Security function\\n\\n    function transferAnyNewERC20Token(address _tokenAddr, address _to, uint _amount) public onlyOwner {  \\n        require(NewIERC20(_tokenAddr).transfer(_to, _amount), \\\"Could not transfer out tokens!\\\");}\\n\\n    function transferAnyOldERC20Token(address _tokenAddr, address _to, uint _amount) public onlyOwner {    \\n        OldIERC20(_tokenAddr).transfer(_to, _amount);}\\n\\n    function transferETH(address _to, uint _amount) public onlyOwner {\\n        (bool sent,) = _to.call{value: _amount}(\\\"\\\");\\n        require(sent, \\\"Failed to send Ether\\\");}}\\n\"}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenToSwap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"blockchainTo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"differentWallet\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"condition\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"price\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"limitBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenToSwap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"blockchainTo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"differentWallet\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"price_gain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"price_loss\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"limitSellAnyToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"blockchainTo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"differentWallet\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"price_gain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"price_loss\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"limitSellETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"limitWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_limitWallet\",\"type\":\"address\"}],\"name\":\"setLimitWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_swappyWallet\",\"type\":\"address\"}],\"name\":\"setSwappyWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenToSwap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"blockchainTo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"differentWallet\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"swappyAnyToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"tokenTo\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"blockchainTo\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"differentWallet\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"swappyETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swappyWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyNewERC20Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyOldERC20Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Swappy", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2157d4bc6a4b2c7ce1258e9d8fdb316f0f93b8019c473431e4da88e709cae6fe"}