{"SourceCode": "// File: contracts/token/IERC721.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface IERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n// File: contracts/utils/IELFCore.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\ninterface IELFCore is IERC721{\r\n\r\n    function isHatched(uint256 _tokenId) external view returns (bool res);\r\n    function gainELF(uint _tokenId) external view returns (uint label, uint dad, uint mom, uint gene, uint bornAt, uint[] memory children);\r\n}\r\n// File: contracts/token/IERC20.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n\r\n    /// MUST trigger when tokens are transferred, including zero value transfers.\r\n    /// A token contract which creates new tokens SHOULD trigger a Transfer event with \r\n    ///  the _from address set to 0x0 when tokens are created.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /// MUST trigger on any successful call to approve(address _spender, uint256 _value).\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /// Returns the total token supply.\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// Returns the account balance of another account with address _owner.\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /// Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. \r\n    /// The function SHOULD throw if the message caller\u2019s account balance does not have enough tokens to spend.\r\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.\r\n    /// The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. \r\n    /// This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies. \r\n    /// The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism.\r\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// Allows _spender to withdraw from your account multiple times, up to the _value amount. \r\n    /// If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /// Returns the amount which _spender is still allowed to withdraw from _owner.\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n}\r\n// File: contracts/security/AccessControl.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant NO_PERMISSION='no permission';\r\n    string constant INVALID_ADDRESS ='invalid address';\r\n    \r\n    /// @dev Administrator with highest authority. Should be a multisig wallet.\r\n    address payable superAdmin;\r\n\r\n    /// @dev Administrator of this contract.\r\n    address payable admin;\r\n\r\n    /// Sets the original admin and superAdmin of the contract to the sender account.\r\n    constructor(){\r\n        superAdmin=payable(msg.sender);\r\n        admin=payable(msg.sender);\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the superAdmin.\r\n    modifier onlySuperAdmin{\r\n        require(msg.sender==superAdmin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the admin.\r\n    modifier onlyAdmin{\r\n        require(msg.sender==admin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change superAdmin.\r\n    /// @param addr The address to transfer the right of superAdmin to.\r\n    function changeSuperAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        superAdmin=addr;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change admin.\r\n    /// @param addr The address to transfer the right of admin to.\r\n    function changeAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        admin=addr;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to withdraw balance.\r\n    function withdrawBalance(uint256 amount) external onlySuperAdmin{\r\n        superAdmin.transfer(amount);\r\n    }\r\n\r\n    fallback() external {}\r\n}\r\n// File: contracts/security/Pausable.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\ncontract Pausable is AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant PAUSED='paused';\r\n    string constant NOT_PAUSED='not paused';\r\n\r\n    /// @dev Keeps track whether the contract is paused. When this is true, most actions are blocked.\r\n    bool public paused = false;\r\n\r\n    /// @dev Modifier to allow actions only when the contract is not paused\r\n    modifier whenNotPaused {\r\n        require(!paused,PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract is paused\r\n    modifier whenPaused {\r\n        require(paused,NOT_PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to pause the contract. Used when something goes wrong\r\n    ///  and we need to limit damage.\r\n    function pause() external onlySuperAdmin whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the superAdmin.\r\n    function unpause() external onlySuperAdmin whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n// File: contracts/stakeELF.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\n\r\n\r\ncontract stakeELF is Pausable {\r\n    IELFCore immutable ELFCore;\r\n    IERC20 immutable ROE;\r\n    uint public totalEggs;\r\n\r\n    struct EGG {\r\n        uint id;\r\n        uint t; //stake timestamp\r\n        uint i; //corresponding index of prices when EGG is created/withdrawn\r\n        uint price;\r\n        uint bornAt;\r\n        uint gene;\r\n        uint rewardStartingPoint; // the time when this egg can earn reward\r\n    }\r\n\r\n    uint constant denominator = 8760;// hours per year\r\n    uint constant unit = 3600; //seconds per hour;\r\n    uint constant noRewardTime= 1 days;\r\n    uint constant maxStakingPeriod=365 days;\r\n    uint constant extraRewardUnit=1 days;\r\n\r\n    /// @dev extraRewardTable[i] means the extra reward of ith day.\r\n    mapping(uint => uint) public extraRewardTable;\r\n\r\n    /// @dev Operators who can set APR.\r\n    address[] ops;\r\n    mapping(address => bool) isOp;\r\n\r\n    /// @dev Accumulated damage done to altars. Its value lies between [0,90].\r\n    mapping(address => uint) public altar;\r\n\r\n    /// @dev 9 attributes, price/APR.\r\n    uint[2][9][] prices;\r\n\r\n    /// @dev Mapping index of array prices to timestamp it was created.\r\n    mapping(uint => uint) public tPrices;\r\n\r\n    /// @dev Eggs staked by address.\r\n    mapping(address => EGG[]) public eggs;\r\n\r\n    /// @dev withdrawn[addr][i] means whether eggs[addr][i] has been withdrawn.\r\n    mapping(address => mapping(uint => bool)) public withdrawn;\r\n\r\n    /// @dev expired[addr][i] means whether eggs[addr][i] has expired.\r\n    mapping(address => mapping(uint => bool)) public expired;\r\n\r\n    /// @dev lastWithdrawTime[addr][i] is the timestamp of the last withdrawn of eggs[addr][i].\r\n    ///  When lastWithdrawTime[addr][i]!=0, (lastWithdrawTime[addr][i]-rewardStartingPoint)/unit shuold be an integer.\r\n    mapping(address => mapping(uint => uint)) public lastWithdrawTime;\r\n\r\n    event ExtraRewardTableChanged(address indexed sender, uint t, uint day, uint value);\r\n\r\n    /// @dev Should be fired whenever new term is added to array prices.\r\n    event PriceChanged(address indexed sender, uint t, uint[2][9] p);\r\n\r\n    /// @dev Fire whenever someone stake an egg.\r\n    event Staking(address indexed staker, uint indexed id, uint t);\r\n\r\n    /// @dev Fire whenever someone claim his/her reward.\r\n    event Withdrawing(address indexed staker, uint amount, uint t, uint altarDamage);\r\n\r\n    constructor(address ELF, address _ROE) {\r\n        ELFCore = IELFCore(ELF);\r\n        ROE = IERC20(_ROE);\r\n    }\r\n\r\n    modifier needPricesSet{\r\n        require(tPrices[0]!=0,'price not set');\r\n        _;\r\n    }\r\n\r\n    function getOps() external view returns (address[] memory res) {\r\n        return ops;\r\n    }\r\n\r\n    function transferELF(address to, uint id) external onlySuperAdmin {\r\n        ELFCore.transferFrom(address(this), to, id);\r\n    }\r\n\r\n    function transferROE(address to, uint amount) external onlySuperAdmin {\r\n        ROE.transfer(to, amount);\r\n    }\r\n\r\n    function setOps(address op, bool tf) external onlySuperAdmin {\r\n        if (isOp[op] != tf) {\r\n            isOp[op] = tf;\r\n            if (tf) {\r\n                ops.push(op);\r\n            } else {\r\n                // remove element from ops\r\n                uint i;\r\n                uint l = ops.length;\r\n                while (i < l) {\r\n                    if (ops[i] == op) break;\r\n                    i++;\r\n                }\r\n                ops[i] = ops[l - 1];\r\n                ops.pop();\r\n            }\r\n        }\r\n    }\r\n\r\n    function setExtraRewardTable(uint day, uint value) external {\r\n        require(isOp[msg.sender], NO_PERMISSION);\r\n        extraRewardTable[day]=value;\r\n        emit ExtraRewardTableChanged(msg.sender, block.timestamp, day, value);\r\n    }\r\n\r\n    function setPrices(uint[2][9] calldata p) external {\r\n        require(isOp[msg.sender], NO_PERMISSION);\r\n        uint t = block.timestamp;\r\n        tPrices[prices.length] = t;\r\n        prices.push(p);\r\n        emit PriceChanged(msg.sender, t, p);\r\n    }\r\n\r\n    function getPrices(uint i) external view returns(uint[2][9] memory res) {\r\n        return prices[i];\r\n    }\r\n\r\n    /// @dev The unit of res is %.\r\n    function getYearlyReward() external view returns(uint res) {\r\n        uint index=prices.length-1;\r\n        for (uint i; i<9; i++) {\r\n            res=res+prices[index][i][1];\r\n        }\r\n        res/=9;\r\n        res+=calculateExtraRewardPercentage(365*extraRewardUnit);\r\n    }\r\n\r\n    function userStakeEggs(address addr) external view returns(uint res){\r\n        return eggs[addr].length;\r\n    }\r\n\r\n    function stake(uint[] calldata ids) external needPricesSet{\r\n        uint t = block.timestamp;\r\n        uint pricesIndex=prices.length-1;\r\n        totalEggs=ids.length+totalEggs;\r\n        for (uint i=0;i<ids.length;i++){\r\n            require(msg.sender == ELFCore.ownerOf(ids[i]),NO_PERMISSION);\r\n            require(!ELFCore.isHatched(ids[i]), 'egg hatched');\r\n            (, , , uint gene, uint bornAt, ) = ELFCore.gainELF(ids[i]);\r\n            uint rewardStartingPoint;\r\n            if (bornAt<t+noRewardTime) rewardStartingPoint=t+noRewardTime;\r\n            else rewardStartingPoint=bornAt;\r\n            EGG memory _EGG = EGG({\r\n                id: ids[i],\r\n                t: t,\r\n                i: pricesIndex,\r\n                price: prices[pricesIndex][gene - 1][0],\r\n                bornAt: bornAt,\r\n                gene: gene,\r\n                rewardStartingPoint: rewardStartingPoint\r\n            });\r\n\r\n            eggs[msg.sender].push(_EGG);\r\n            ELFCore.transferFrom(msg.sender, address(this), ids[i]);\r\n            emit Staking(msg.sender, ids[i], t);\r\n        }\r\n        if (altar[msg.sender] <= 10*ids.length) altar[msg.sender] = 0;\r\n        else altar[msg.sender] -= 10*ids.length;\r\n    }\r\n\r\n    function withdraw() external needPricesSet{\r\n        uint amount;\r\n        uint t = block.timestamp;\r\n        EGG[] memory _eggs = eggs[msg.sender];\r\n\r\n        for (uint i=0; i<_eggs.length; i++) { //iterate through all eggs.\r\n            uint rewardStartingPoint=_eggs[i].rewardStartingPoint;\r\n            uint totalTime;\r\n            if (!withdrawn[msg.sender][i]){\r\n                //staking reward + extra reward\r\n                if (t<=rewardStartingPoint) totalTime=0;\r\n                else totalTime = t - rewardStartingPoint;//the total seconds caller can earn reward\r\n                if (totalTime>=unit) {\r\n                    withdrawn[msg.sender][i]=true;\r\n                    if (totalTime>=maxStakingPeriod) {\r\n                        expired[msg.sender][i]=true;\r\n                        totalTime=maxStakingPeriod;\r\n                    }\r\n                    amount+=calculateExtraRewardPercentage(totalTime)*_eggs[i].price/100;\r\n                }\r\n            }\r\n            else if (!expired[msg.sender][i]){\r\n                //only staking reward\r\n                if (t-rewardStartingPoint>=maxStakingPeriod) {\r\n                    expired[msg.sender][i]=true;\r\n                    totalTime=rewardStartingPoint+maxStakingPeriod-lastWithdrawTime[msg.sender][i];\r\n                }\r\n                else totalTime = t - lastWithdrawTime[msg.sender][i];\r\n            }\r\n            (uint eggAmount, uint eggIndex, uint tempLastWithdrawTime)=stakingReward(totalTime, _eggs[i], i, msg.sender);\r\n            amount+=eggAmount;\r\n            eggs[msg.sender][i].i=eggIndex;\r\n            lastWithdrawTime[msg.sender][i]=tempLastWithdrawTime;\r\n        }\r\n\r\n        if (amount > 0) {\r\n            uint altarTemp = altar[msg.sender];\r\n            amount = amount * (100 - altarTemp) / 100;\r\n            altarTemp = altarTemp + block.timestamp % 8 + 3;\r\n            if (altarTemp > 90) altarTemp = 90;\r\n            altar[msg.sender] = altarTemp;\r\n            ROE.transfer(msg.sender, amount);\r\n            emit Withdrawing(msg.sender, amount, t, 100-altarTemp);\r\n        }\r\n    }\r\n\r\n    function getWithdrawValue(address addr) external view needPricesSet returns(uint amount, uint t){\r\n        t = block.timestamp;\r\n        EGG[] memory _eggs = eggs[addr];\r\n\r\n        for (uint i=0; i<_eggs.length; i++) { //iterate through all eggs.\r\n            uint rewardStartingPoint=_eggs[i].rewardStartingPoint;\r\n            uint totalTime;\r\n            if (!withdrawn[addr][i]){\r\n                //staking reward + extra reward\r\n                if (t<=rewardStartingPoint) totalTime=0;\r\n                else totalTime = t - rewardStartingPoint;//the total seconds caller can earn reward\r\n                if (totalTime>=unit) {\r\n                    if (totalTime>=maxStakingPeriod) totalTime=maxStakingPeriod;\r\n                    amount+=calculateExtraRewardPercentage(totalTime)*_eggs[i].price/100;\r\n                }\r\n            }\r\n            else if (!expired[addr][i]){\r\n                //only staking reward\r\n                if (t-rewardStartingPoint>=maxStakingPeriod) totalTime=rewardStartingPoint+maxStakingPeriod-lastWithdrawTime[addr][i];\r\n                else totalTime = t - lastWithdrawTime[addr][i];\r\n            }\r\n            (uint eggAmount,,)=stakingReward(totalTime, _eggs[i], i, addr);\r\n            amount+=eggAmount;\r\n        }\r\n\r\n        amount = amount * (100 - altar[addr]) / 100;\r\n    }\r\n\r\n    /// @dev The unit of returnd value percentage is %.\r\n    function getAverageWithdrawPercentage(address addr) external view needPricesSet returns(uint percentage, uint t){\r\n        t = block.timestamp;\r\n        EGG[] memory _eggs = eggs[addr];\r\n        uint count;\r\n        uint maxExtraRewardPercentage=calculateExtraRewardPercentage(365*extraRewardUnit);\r\n\r\n        for (uint i=0; i<_eggs.length; i++) { //iterate through all eggs.\r\n            uint rewardStartingPoint=_eggs[i].rewardStartingPoint;\r\n            if (!withdrawn[addr][i]){\r\n                //staking reward + extra reward\r\n                if (t>=rewardStartingPoint+unit) {\r\n                    percentage+=maxExtraRewardPercentage+prices[prices.length-1][_eggs[i].gene-1][1];\r\n                    count++;\r\n                }\r\n            }\r\n            else if (!expired[addr][i]){\r\n                //only staking reward\r\n                percentage+=prices[prices.length-1][_eggs[i].gene-1][1];\r\n                count++;\r\n            }\r\n        }\r\n\r\n        if (count==0) percentage=0;\r\n        else percentage=percentage*(100-altar[addr])/100/count;\r\n    }\r\n\r\n    function getWithdrawDiff(address addr) external view needPricesSet returns(uint diff, uint t){\r\n        t = block.timestamp;\r\n        EGG[] memory _eggs = eggs[addr];\r\n        uint amount;\r\n        uint maxExtraRewardPercentage=calculateExtraRewardPercentage(365*extraRewardUnit);\r\n\r\n        for (uint i=0; i<_eggs.length; i++) { //iterate through all eggs.\r\n            uint rewardStartingPoint=_eggs[i].rewardStartingPoint;\r\n            uint totalTime;\r\n            if (!withdrawn[addr][i]){\r\n                //staking reward + extra reward\r\n                if (t<=rewardStartingPoint) totalTime=0;\r\n                else totalTime = t - rewardStartingPoint;//the total seconds caller can earn reward\r\n                if (totalTime>=unit) {\r\n                    if (totalTime>=maxStakingPeriod) totalTime=maxStakingPeriod;\r\n                    uint extraReward=calculateExtraRewardPercentage(totalTime)*_eggs[i].price/100;\r\n                    amount+=extraReward;\r\n                    diff+=maxExtraRewardPercentage*_eggs[i].price/100-extraReward;\r\n                }\r\n            }\r\n            else if (!expired[addr][i]){\r\n                //only staking reward\r\n                if (t-rewardStartingPoint>=maxStakingPeriod) totalTime=rewardStartingPoint+maxStakingPeriod-lastWithdrawTime[addr][i];\r\n                else totalTime = t - lastWithdrawTime[addr][i];\r\n            }\r\n            (uint eggAmount,,)=stakingReward(totalTime, _eggs[i], i, addr);\r\n            amount+=eggAmount;\r\n        }\r\n\r\n        diff=diff+amount*altar[addr]/100;\r\n    }\r\n\r\n    /// @dev Unit of returnd value res is %.\r\n    function calculateExtraRewardPercentage(uint totalTime) internal view returns(uint res) {\r\n        uint l=totalTime/extraRewardUnit;\r\n        for (uint i=1; i<l+1; i++){\r\n            res+=extraRewardTable[i];\r\n        }\r\n    }\r\n\r\n    function stakingReward(uint totalTime, EGG memory egg, uint i, address addr) internal view returns(uint amount, uint indexOfPrices, uint tempLastWithdrawTime) {\r\n        uint accumulatedTime; // accumulated seconds whose reward have been calculated\r\n        indexOfPrices = egg.i;\r\n        uint rewardStartingPoint=egg.rewardStartingPoint;\r\n        tempLastWithdrawTime=lastWithdrawTime[addr][i];\r\n        while (totalTime-accumulatedTime>=unit){ //iterate through terms of prices\r\n            uint unitDiff;\r\n            if (tPrices[indexOfPrices+1]==0){ //next term of prices does not exist\r\n                unitDiff=(totalTime-accumulatedTime)/unit;\r\n                accumulatedTime=totalTime;\r\n                amount=amount+egg.price*prices[indexOfPrices][egg.gene-1][1]/100*unitDiff/denominator;\r\n            }\r\n            else{ //next term of prices exists\r\n                uint secondDiff;\r\n                if (tempLastWithdrawTime==0) secondDiff=tPrices[indexOfPrices+1]-rewardStartingPoint;\r\n                else secondDiff=tPrices[indexOfPrices+1]-tempLastWithdrawTime;\r\n                uint remainder=secondDiff%unit;\r\n                secondDiff=secondDiff-remainder;\r\n\r\n                if (accumulatedTime+secondDiff>totalTime) {\r\n                    unitDiff=(totalTime-accumulatedTime)/unit;\r\n                    accumulatedTime=totalTime;\r\n                    amount=amount+egg.price*prices[indexOfPrices][egg.gene-1][1]/100*unitDiff/denominator;\r\n                }\r\n                else {\r\n                    unitDiff=secondDiff/unit;\r\n                    if (remainder!=0 && accumulatedTime+secondDiff+unit<=totalTime) unitDiff++;\r\n                    accumulatedTime+=unitDiff*unit;\r\n                    amount=amount+egg.price*prices[indexOfPrices][egg.gene-1][1]/100*unitDiff/denominator;\r\n                    indexOfPrices++;\r\n                }\r\n            }\r\n            if (tempLastWithdrawTime==0) tempLastWithdrawTime=rewardStartingPoint+unitDiff*unit;\r\n            else tempLastWithdrawTime+=unitDiff*unit;\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ELF\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ROE\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ExtraRewardTableChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[2][9]\",\"name\":\"p\",\"type\":\"uint256[2][9]\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"Staking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"altarDamage\",\"type\":\"uint256\"}],\"name\":\"Withdrawing\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"altar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bornAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gene\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardStartingPoint\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"expired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extraRewardTable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAverageWithdrawPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOps\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"res\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256[2][9]\",\"name\":\"res\",\"type\":\"uint256[2][9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWithdrawDiff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWithdrawValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getYearlyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastWithdrawTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setExtraRewardTable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"op\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"tf\",\"type\":\"bool\"}],\"name\":\"setOps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2][9]\",\"name\":\"p\",\"type\":\"uint256[2][9]\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferELF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferROE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userStakeEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdrawn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "stakeELF", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fcd60b2d8acbc3869cbe1ddcda60d0a92da2d4cb0000000000000000000000001dc43be95b7a05987f1261cb388c129bb53ea599", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bdb3e194bd38a723a7537c3f0a51a9d689e5d721443fe5b2a7b88d4a702ad593"}