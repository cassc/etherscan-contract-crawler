{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@gridexprotocol/core/contracts/interfaces/callback/IGridPlaceMakerOrderCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Callback for IGrid#placeMakerOrder\\n/// @notice Any contract that calls IGrid#placeMakerOrder must implement this interface\\ninterface IGridPlaceMakerOrderCallback {\\n    /// @notice Called to `msg.sender` after executing a place maker order via IGrid#placeMakerOrder\\n    /// @dev In this implementation, you are required to pay the grid tokens owed for the maker order.\\n    /// The caller of the method must be a grid deployed by the canonical GridFactory.\\n    /// At most one of amount0 and amount1 is a positive number\\n    /// @param amount0 The grid will receive the amount of token0 upon placement of the maker order.\\n    /// In the receiving case, the callback must send this amount of token0 to the grid\\n    /// @param amount1 The grid will receive the amount of token1 upon placement of the maker order.\\n    /// In the receiving case, the callback must send this amount of token1 to the grid\\n    /// @param data Any data passed through by the caller via the IGrid#placeMakerOrder call\\n    function gridexPlaceMakerOrderCallback(uint256 amount0, uint256 amount1, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IGrid.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IGridStructs.sol\\\";\\nimport \\\"./IGridParameters.sol\\\";\\n\\n/// @title The interface for Gridex grid\\ninterface IGrid {\\n    ///==================================== Grid States  ====================================\\n\\n    /// @notice The first token in the grid, after sorting by address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second token in the grid, after sorting by address\\n    function token1() external view returns (address);\\n\\n    /// @notice The step size in initialized boundaries for a grid created with a given fee\\n    function resolution() external view returns (int24);\\n\\n    /// @notice The fee paid to the grid denominated in hundredths of a bip, i.e. 1e-6\\n    function takerFee() external view returns (int24);\\n\\n    /// @notice The 0th slot of the grid holds a lot of values that can be gas-efficiently accessed\\n    /// externally as a single method\\n    /// @return priceX96 The current price of the grid, as a Q64.96\\n    /// @return boundary The current boundary of the grid\\n    /// @return blockTimestamp The time the oracle was last updated\\n    /// @return unlocked Whether the grid is unlocked or not\\n    function slot0() external view returns (uint160 priceX96, int24 boundary, uint32 blockTimestamp, bool unlocked);\\n\\n    /// @notice Returns the boundary information of token0\\n    /// @param boundary The boundary of the grid\\n    /// @return bundle0Id The unique identifier of bundle0\\n    /// @return bundle1Id The unique identifier of bundle1\\n    /// @return makerAmountRemaining The remaining amount of token0 that can be swapped out,\\n    /// which is the sum of bundle0 and bundle1\\n    function boundaries0(\\n        int24 boundary\\n    ) external view returns (uint64 bundle0Id, uint64 bundle1Id, uint128 makerAmountRemaining);\\n\\n    /// @notice Returns the boundary information of token1\\n    /// @param boundary The boundary of the grid\\n    /// @return bundle0Id The unique identifier of bundle0\\n    /// @return bundle1Id The unique identifier of bundle1\\n    /// @return makerAmountRemaining The remaining amount of token1 that can be swapped out,\\n    /// which is the sum of bundle0 and bundle1\\n    function boundaries1(\\n        int24 boundary\\n    ) external view returns (uint64 bundle0Id, uint64 bundle1Id, uint128 makerAmountRemaining);\\n\\n    /// @notice Returns 256 packed boundary initialized boolean values for token0\\n    function boundaryBitmaps0(int16 wordPos) external view returns (uint256 word);\\n\\n    /// @notice Returns 256 packed boundary initialized boolean values for token1\\n    function boundaryBitmaps1(int16 wordPos) external view returns (uint256 word);\\n\\n    /// @notice Returns the amount owed for token0 and token1\\n    /// @param owner The address of owner\\n    /// @return token0 The amount of token0 owed\\n    /// @return token1 The amount of token1 owed\\n    function tokensOweds(address owner) external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice Returns the information of a given bundle\\n    /// @param bundleId The unique identifier of the bundle\\n    /// @return boundaryLower The lower boundary of the bundle\\n    /// @return zero When zero is true, it represents token0, otherwise it represents token1\\n    /// @return makerAmountTotal The total amount of token0 or token1 that the maker added\\n    /// @return makerAmountRemaining The remaining amount of token0 or token1 that can be swapped out from the makers\\n    /// @return takerAmountRemaining The remaining amount of token0 or token1 that have been swapped in from the takers\\n    /// @return takerFeeAmountRemaining The remaining amount of fees that takers have paid in\\n    function bundles(\\n        uint64 bundleId\\n    )\\n        external\\n        view\\n        returns (\\n            int24 boundaryLower,\\n            bool zero,\\n            uint128 makerAmountTotal,\\n            uint128 makerAmountRemaining,\\n            uint128 takerAmountRemaining,\\n            uint128 takerFeeAmountRemaining\\n        );\\n\\n    /// @notice Returns the information of a given order\\n    /// @param orderId The unique identifier of the order\\n    /// @return bundleId The unique identifier of the bundle -- represents which bundle this order belongs to\\n    /// @return owner The address of the owner of the order\\n    /// @return amount The amount of token0 or token1 to add\\n    function orders(uint256 orderId) external view returns (uint64 bundleId, address owner, uint128 amount);\\n\\n    ///==================================== Grid Actions ====================================\\n\\n    /// @notice Initializes the grid with the given parameters\\n    /// @dev The caller of this method receives a callback in the form of\\n    /// IGridPlaceMakerOrderCallback#gridexPlaceMakerOrderCallback.\\n    /// When initializing the grid, token0 and token1's liquidity must be added simultaneously.\\n    /// @param parameters The parameters used to initialize the grid\\n    /// @param data Any data to be passed through to the callback\\n    /// @return orderIds0 The unique identifiers of the orders for token0\\n    /// @return orderIds1 The unique identifiers of the orders for token1\\n    function initialize(\\n        IGridParameters.InitializeParameters memory parameters,\\n        bytes calldata data\\n    ) external returns (uint256[] memory orderIds0, uint256[] memory orderIds1);\\n\\n    /// @notice Swaps token0 for token1, or vice versa\\n    /// @dev The caller of this method receives a callback in the form of IGridSwapCallback#gridexSwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The swap direction, true for token0 to token1 and false otherwise\\n    /// @param amountSpecified The amount of the swap, configured as an exactInput (positive)\\n    /// or an exactOutput (negative)\\n    /// @param priceLimitX96 Swap price limit: if zeroForOne, the price will not be less than this value after swap,\\n    /// if oneForZero, it will not be greater than this value after swap, as a Q64.96\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The balance change of the grid's token0. When negative, it will reduce the balance\\n    /// by the exact amount. When positive, it will increase by at least this amount\\n    /// @return amount1 The balance change of the grid's token1. When negative, it will reduce the balance\\n    /// by the exact amount. When positive, it will increase by at least this amount.\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 priceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    /// @notice Places a maker order on the grid\\n    /// @dev The caller of this method receives a callback in the form of\\n    /// IGridPlaceMakerOrderCallback#gridexPlaceMakerOrderCallback\\n    /// @param parameters The parameters used to place the maker order\\n    /// @param data Any data to be passed through to the callback\\n    /// @return orderId The unique identifier of the order\\n    function placeMakerOrder(\\n        IGridParameters.PlaceOrderParameters memory parameters,\\n        bytes calldata data\\n    ) external returns (uint256 orderId);\\n\\n    /// @notice Places maker orders on the grid\\n    /// @dev The caller of this method receives a callback in the form of\\n    /// IGridPlaceMakerOrderCallback#gridexPlaceMakerOrderCallback\\n    /// @param parameters The parameters used to place the maker orders\\n    /// @param data Any data to be passed through to the callback\\n    /// @return orderIds The unique identifiers of the orders\\n    function placeMakerOrderInBatch(\\n        IGridParameters.PlaceOrderInBatchParameters memory parameters,\\n        bytes calldata data\\n    ) external returns (uint256[] memory orderIds);\\n\\n    /// @notice Settles a maker order\\n    /// @param orderId The unique identifier of the order\\n    /// @return amount0 The amount of token0 that the maker received\\n    /// @return amount1 The amount of token1 that the maker received\\n    function settleMakerOrder(uint256 orderId) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Settle maker order and collect\\n    /// @param recipient The address to receive the output of the settlement\\n    /// @param orderId The unique identifier of the order\\n    /// @param unwrapWETH9 Whether to unwrap WETH9 to ETH\\n    /// @return amount0 The amount of token0 that the maker received\\n    /// @return amount1 The amount of token1 that the maker received\\n    function settleMakerOrderAndCollect(\\n        address recipient,\\n        uint256 orderId,\\n        bool unwrapWETH9\\n    ) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Settles maker orders and collects in a batch\\n    /// @param recipient The address to receive the output of the settlement\\n    /// @param orderIds The unique identifiers of the orders\\n    /// @param unwrapWETH9 Whether to unwrap WETH9 to ETH\\n    /// @return amount0Total The total amount of token0 that the maker received\\n    /// @return amount1Total The total amount of token1 that the maker received\\n    function settleMakerOrderAndCollectInBatch(\\n        address recipient,\\n        uint256[] memory orderIds,\\n        bool unwrapWETH9\\n    ) external returns (uint128 amount0Total, uint128 amount1Total);\\n\\n    /// @notice For flash swaps. The caller borrows assets and returns them in the callback of the function,\\n    /// in addition to a fee\\n    /// @dev The caller of this function receives a callback in the form of IGridFlashCallback#gridexFlashCallback\\n    /// @param recipient The address which will receive the token0 and token1\\n    /// @param amount0 The amount of token0 to receive\\n    /// @param amount1 The amount of token1 to receive\\n    /// @param data Any data to be passed through to the callback\\n    function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;\\n\\n    /// @notice Collects tokens owed\\n    /// @param recipient The address to receive the collected fees\\n    /// @param amount0Requested The maximum amount of token0 to send.\\n    /// Set to 0 if fees should only be collected in token1.\\n    /// @param amount1Requested The maximum amount of token1 to send.\\n    /// Set to 0 if fees should only be collected in token0.\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(\\n        address recipient,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IGridFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title The interface for Gridex grid factory\\ninterface IGridFactory {\\n    /// @notice Emitted when a new resolution is enabled for grid creation via the grid factory\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @param takerFee The taker fee, denominated in hundredths of a bip (i.e. 1e-6)\\n    event ResolutionEnabled(int24 indexed resolution, int24 indexed takerFee);\\n\\n    /// @notice Emitted upon grid creation\\n    /// @param token0 The first token in the grid, after sorting by address\\n    /// @param token1 The first token in the grid, after sorting by address\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @param grid The address of the deployed grid\\n    event GridCreated(address indexed token0, address indexed token1, int24 indexed resolution, address grid);\\n\\n    /// @notice Returns the taker fee for the given resolution if enabled. Else, returns 0.\\n    /// @dev A resolution can never be removed, so this value should be hard coded or cached in the calling context\\n    /// @param resolution The enabled resolution\\n    /// @return takerFee The taker fee, denominated in hundredths of a bip (i.e. 1e-6)\\n    function resolutions(int24 resolution) external view returns (int24 takerFee);\\n\\n    /// @notice The implementation address of the price oracle\\n    function priceOracle() external view returns (address);\\n\\n    /// @notice Returns the grid address for a given token pair and a resolution. Returns 0 if the pair does not exist.\\n    /// @dev tokenA and tokenB may be passed in, in the order of either token0/token1 or token1/token0\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return grid The grid address\\n    function grids(address tokenA, address tokenB, int24 resolution) external view returns (address grid);\\n\\n    /// @notice Concat grid creation code bytes\\n    /// @dev Split the creationCode of the Grid contract into two parts, so that the Gas Limit of particular networks can be met when deploying.\\n    /// @param gridSuffixCreationCode This parameter is the second half of the creationCode of the Grid contract.\\n    function concatGridSuffixCreationCode(bytes memory gridSuffixCreationCode) external;\\n\\n    /// @notice Creates a grid for a given pair of tokens and resolution\\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0.\\n    /// @param tokenA One token of the grid token pair\\n    /// @param tokenB The other token of the grid token pair\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return grid The address of the deployed grid\\n    function createGrid(address tokenA, address tokenB, int24 resolution) external returns (address grid);\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IGridParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IGridParameters {\\n    /// @dev Parameters for initializing the grid\\n    struct InitializeParameters {\\n        /// @dev The initial price of the grid, as a Q64.96.\\n        /// Price is represented as an amountToken1/amountToken0 Q64.96 value.\\n        uint160 priceX96;\\n        /// @dev The address to receive orders\\n        address recipient;\\n        /// @dev Represents the order parameters for token0\\n        BoundaryLowerWithAmountParameters[] orders0;\\n        /// @dev Represents the order parameters for token1\\n        BoundaryLowerWithAmountParameters[] orders1;\\n    }\\n\\n    /// @dev Parameters for placing an order\\n    struct PlaceOrderParameters {\\n        /// @dev The address to receive the order\\n        address recipient;\\n        /// @dev When zero is true, it represents token0, otherwise it represents token1\\n        bool zero;\\n        /// @dev The lower boundary of the order\\n        int24 boundaryLower;\\n        /// @dev The amount of token0 or token1 to add\\n        uint128 amount;\\n    }\\n\\n    struct PlaceOrderInBatchParameters {\\n        /// @dev The address to receive the order\\n        address recipient;\\n        /// @dev When zero is true, it represents token0, otherwise it represents token1\\n        bool zero;\\n        BoundaryLowerWithAmountParameters[] orders;\\n    }\\n\\n    struct BoundaryLowerWithAmountParameters {\\n        /// @dev The lower boundary of the order\\n        int24 boundaryLower;\\n        /// @dev The amount of token0 or token1 to add\\n        uint128 amount;\\n    }\\n\\n    /// @dev Status during swap\\n    struct SwapState {\\n        /// @dev When true, token0 is swapped for token1, otherwise token1 is swapped for token0\\n        bool zeroForOne;\\n        /// @dev The remaining amount of the swap, which implicitly configures\\n        /// the swap as exact input (positive), or exact output (negative)\\n        int256 amountSpecifiedRemaining;\\n        /// @dev The calculated amount to be inputted\\n        uint256 amountInputCalculated;\\n        /// @dev The calculated amount of fee to be inputted\\n        uint256 feeAmountInputCalculated;\\n        /// @dev The calculated amount to be outputted\\n        uint256 amountOutputCalculated;\\n        /// @dev The price of the grid, as a Q64.96\\n        uint160 priceX96;\\n        uint160 priceLimitX96;\\n        /// @dev The boundary of the grid\\n        int24 boundary;\\n        /// @dev The lower boundary of the grid\\n        int24 boundaryLower;\\n        uint160 initializedBoundaryLowerPriceX96;\\n        uint160 initializedBoundaryUpperPriceX96;\\n        /// @dev Whether the swap has been completed\\n        bool stopSwap;\\n    }\\n\\n    struct SwapForBoundaryState {\\n        /// @dev The price indicated by the lower boundary, as a Q64.96\\n        uint160 boundaryLowerPriceX96;\\n        /// @dev The price indicated by the upper boundary, as a Q64.96\\n        uint160 boundaryUpperPriceX96;\\n        /// @dev The price indicated by the lower or upper boundary, as a Q64.96.\\n        /// When using token0 to exchange token1, it is equal to boundaryLowerPriceX96,\\n        /// otherwise it is equal to boundaryUpperPriceX96\\n        uint160 boundaryPriceX96;\\n        /// @dev The price of the grid, as a Q64.96\\n        uint160 priceX96;\\n    }\\n\\n    struct UpdateBundleForTakerParameters {\\n        /// @dev The amount to be swapped in to bundle0\\n        uint256 amountInUsed;\\n        /// @dev The remaining amount to be swapped in to bundle1\\n        uint256 amountInRemaining;\\n        /// @dev The amount to be swapped out to bundle0\\n        uint128 amountOutUsed;\\n        /// @dev The remaining amount to be swapped out to bundle1\\n        uint128 amountOutRemaining;\\n        /// @dev The amount to be paid to bundle0\\n        uint128 takerFeeForMakerAmountUsed;\\n        /// @dev The amount to be paid to bundle1\\n        uint128 takerFeeForMakerAmountRemaining;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IGridStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IGridStructs {\\n    struct Bundle {\\n        int24 boundaryLower;\\n        bool zero;\\n        uint128 makerAmountTotal;\\n        uint128 makerAmountRemaining;\\n        uint128 takerAmountRemaining;\\n        uint128 takerFeeAmountRemaining;\\n    }\\n\\n    struct Boundary {\\n        uint64 bundle0Id;\\n        uint64 bundle1Id;\\n        uint128 makerAmountRemaining;\\n    }\\n\\n    struct Order {\\n        uint64 bundleId;\\n        address owner;\\n        uint128 amount;\\n    }\\n\\n    struct TokensOwed {\\n        uint128 token0;\\n        uint128 token1;\\n    }\\n\\n    struct Slot0 {\\n        uint160 priceX96;\\n        int24 boundary;\\n        uint32 blockTimestamp;\\n        bool unlocked;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IWETHMinimum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IWETHMinimum {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function balanceOf(address dst) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/libraries/BoundaryMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary BoundaryMath {\\n    int24 public constant MIN_BOUNDARY = -527400;\\n    int24 public constant MAX_BOUNDARY = 443635;\\n\\n    /// @dev The minimum value that can be returned from #getPriceX96AtBoundary. Equivalent to getPriceX96AtBoundary(MIN_BOUNDARY)\\n    uint160 internal constant MIN_RATIO = 989314;\\n    /// @dev The maximum value that can be returned from #getPriceX96AtBoundary. Equivalent to getPriceX96AtBoundary(MAX_BOUNDARY)\\n    uint160 internal constant MAX_RATIO = 1461300573427867316570072651998408279850435624081;\\n\\n    /// @dev Checks if a boundary is divisible by a resolution\\n    /// @param boundary The boundary to check\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return isValid Whether or not the boundary is valid\\n    function isValidBoundary(int24 boundary, int24 resolution) internal pure returns (bool isValid) {\\n        return boundary % resolution == 0;\\n    }\\n\\n    /// @dev Checks if a boundary is within the valid range\\n    /// @param boundary The boundary to check\\n    /// @return inRange Whether or not the boundary is in range\\n    function isInRange(int24 boundary) internal pure returns (bool inRange) {\\n        return boundary >= MIN_BOUNDARY && boundary <= MAX_BOUNDARY;\\n    }\\n\\n    /// @dev Checks if a price is within the valid range\\n    /// @param priceX96 The price to check, as a Q64.96\\n    /// @return inRange Whether or not the price is in range\\n    function isPriceX96InRange(uint160 priceX96) internal pure returns (bool inRange) {\\n        return priceX96 >= MIN_RATIO && priceX96 <= MAX_RATIO;\\n    }\\n\\n    /// @notice Calculates the price at a given boundary\\n    /// @dev priceX96 = pow(1.0001, boundary) * 2**96\\n    /// @param boundary The boundary to calculate the price at\\n    /// @return priceX96 The price at the boundary, as a Q64.96\\n    function getPriceX96AtBoundary(int24 boundary) internal pure returns (uint160 priceX96) {\\n        unchecked {\\n            uint256 absBoundary = boundary < 0 ? uint256(-int256(boundary)) : uint24(boundary);\\n\\n            uint256 ratio = absBoundary & 0x1 != 0\\n                ? 0xfff97272373d413259a46990580e213a\\n                : 0x100000000000000000000000000000000;\\n            if (absBoundary & 0x2 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absBoundary & 0x4 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absBoundary & 0x8 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absBoundary & 0x10 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absBoundary & 0x20 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absBoundary & 0x40 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absBoundary & 0x80 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absBoundary & 0x100 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absBoundary & 0x200 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absBoundary & 0x400 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absBoundary & 0x800 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absBoundary & 0x1000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absBoundary & 0x2000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absBoundary & 0x4000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absBoundary & 0x8000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absBoundary & 0x10000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absBoundary & 0x20000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absBoundary & 0x40000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n            if (absBoundary & 0x80000 != 0) ratio = (ratio * 0x149b34ee7ac263) >> 128;\\n\\n            if (boundary > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 and rounds up to go from a Q128.128 to a Q128.96.\\n            // due to out boundary input limitations, we then proceed to downcast as the\\n            // result will always fit within 160 bits.\\n            // we round up in the division so that getBoundaryAtPriceX96 of the output price is always consistent\\n            priceX96 = uint160((ratio + 0xffffffff) >> 32);\\n        }\\n    }\\n\\n    /// @notice Calculates the boundary at a given price\\n    /// @param priceX96 The price to calculate the boundary at, as a Q64.96\\n    /// @return boundary The boundary at the price\\n    function getBoundaryAtPriceX96(uint160 priceX96) internal pure returns (int24 boundary) {\\n        unchecked {\\n            uint256 ratio = uint256(priceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log10001 = log_2 * 127869479499801913173570;\\n            // 128.128 number\\n\\n            int24 boundaryLow = int24((log10001 - 1701496478404566090792001455681771637) >> 128);\\n            int24 boundaryHi = int24((log10001 + 289637967442836604689790891002483458648) >> 128);\\n\\n            boundary = boundaryLow == boundaryHi ? boundaryLow : getPriceX96AtBoundary(boundaryHi) <= priceX96\\n                ? boundaryHi\\n                : boundaryLow;\\n        }\\n    }\\n\\n    /// @dev Returns the lower boundary for the given boundary and resolution.\\n    /// The lower boundary may not be valid (if out of the boundary range)\\n    /// @param boundary The boundary to get the lower boundary for\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return boundaryLower The lower boundary for the given boundary and resolution\\n    function getBoundaryLowerAtBoundary(int24 boundary, int24 resolution) internal pure returns (int24 boundaryLower) {\\n        unchecked {\\n            return boundary - (((boundary % resolution) + resolution) % resolution);\\n        }\\n    }\\n\\n    /// @dev Rewrite the lower boundary that is not in the range to a valid value\\n    /// @param boundaryLower The lower boundary to rewrite\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return validBoundaryLower The valid lower boundary\\n    function rewriteToValidBoundaryLower(\\n        int24 boundaryLower,\\n        int24 resolution\\n    ) internal pure returns (int24 validBoundaryLower) {\\n        unchecked {\\n            if (boundaryLower < MIN_BOUNDARY) return boundaryLower + resolution;\\n            else if (boundaryLower + resolution > MAX_BOUNDARY) return boundaryLower - resolution;\\n            else return boundaryLower;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/libraries/CallbackValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./GridAddress.sol\\\";\\n\\nlibrary CallbackValidator {\\n    /// @dev Validates the `msg.sender` is the canonical grid address for the given parameters\\n    /// @param gridFactory The address of the grid factory\\n    /// @param gridKey The grid key to compute the canonical address for the grid\\n    function validate(address gridFactory, GridAddress.GridKey memory gridKey) internal view {\\n        // CV_IC: invalid caller\\n        require(GridAddress.computeAddress(gridFactory, gridKey) == msg.sender, \\\"CV_IC\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/libraries/GridAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary GridAddress {\\n    bytes32 internal constant GRID_BYTES_CODE_HASH = 0x884a6891a166f885bf6f0a3b330a25e41d1761a5aa091110a229d9a0e34b2c36;\\n\\n    struct GridKey {\\n        address token0;\\n        address token1;\\n        int24 resolution;\\n    }\\n\\n    /// @notice Constructs the grid key for the given parameters\\n    /// @dev tokenA and tokenB may be passed in, in the order of either token0/token1 or token1/token0\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return key The grid key to compute the canonical address for the grid\\n    function gridKey(address tokenA, address tokenB, int24 resolution) internal pure returns (GridKey memory key) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n\\n        return GridKey(tokenA, tokenB, resolution);\\n    }\\n\\n    /// @dev Computes the CREATE2 address for a grid with the given parameters\\n    /// @param gridFactory The address of the grid factory\\n    /// @param key The grid key to compute the canonical address for the grid\\n    /// @return grid The computed address\\n    function computeAddress(address gridFactory, GridKey memory key) internal pure returns (address grid) {\\n        require(key.token0 < key.token1);\\n        return\\n            Create2.computeAddress(\\n                keccak256(abi.encode(key.token0, key.token1, key.resolution)),\\n                GRID_BYTES_CODE_HASH,\\n                gridFactory\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AbstractPayments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/interfaces/IWETHMinimum.sol\\\";\\nimport \\\"./interfaces/IPayments.sol\\\";\\n\\nabstract contract AbstractPayments is IPayments, Context {\\n    /// @dev The address of IGridFactory\\n    address public immutable gridFactory;\\n    /// @dev The address of IWETHMinimum\\n    address public immutable weth9;\\n\\n    constructor(address _gridFactory, address _weth9) {\\n        // AP_NC: not contract\\n        require(Address.isContract(_gridFactory), \\\"AP_NC\\\");\\n        require(Address.isContract(_weth9), \\\"AP_NC\\\");\\n\\n        gridFactory = _gridFactory;\\n        weth9 = _weth9;\\n    }\\n\\n    modifier checkDeadline(uint256 deadline) {\\n        // AP_TTO: transaction too old\\n        require(block.timestamp <= deadline, \\\"AP_TTO\\\");\\n        _;\\n    }\\n\\n    receive() external payable {\\n        // AP_WETH9: not WETH9\\n        require(_msgSender() == weth9, \\\"AP_WETH9\\\");\\n    }\\n\\n    /// @inheritdoc IPayments\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {\\n        uint256 balanceWETH9 = IWETHMinimum(weth9).balanceOf(address(this));\\n        // AP_IWETH9: insufficient WETH9\\n        require(balanceWETH9 >= amountMinimum, \\\"AP_IWETH9\\\");\\n\\n        if (balanceWETH9 > 0) {\\n            IWETHMinimum(weth9).withdraw(balanceWETH9);\\n            Address.sendValue(payable(recipient), balanceWETH9);\\n        }\\n    }\\n\\n    /// @inheritdoc IPayments\\n    function sweepToken(address token, uint256 amountMinimum, address recipient) public payable override {\\n        uint256 balanceToken = IERC20(token).balanceOf(address(this));\\n        // AP_ITKN: insufficient token\\n        require(balanceToken >= amountMinimum, \\\"AP_ITKN\\\");\\n\\n        if (balanceToken > 0) SafeERC20.safeTransfer(IERC20(token), recipient, balanceToken);\\n    }\\n\\n    /// @inheritdoc IPayments\\n    function refundNativeToken() external payable {\\n        if (address(this).balance > 0) Address.sendValue(payable(_msgSender()), address(this).balance);\\n    }\\n\\n    /// @dev Pays the token to the recipient\\n    /// @param token The token to pay\\n    /// @param payer The address of the payment token\\n    /// @param recipient The address that will receive the payment\\n    /// @param amount The amount to pay\\n    function pay(address token, address payer, address recipient, uint256 amount) internal {\\n        if (token == weth9 && address(this).balance >= amount) {\\n            // pay with WETH9\\n            Address.sendValue(payable(weth9), amount);\\n            IWETHMinimum(weth9).transfer(recipient, amount);\\n        } else if (payer == address(this)) SafeERC20.safeTransfer(IERC20(token), recipient, amount);\\n        else SafeERC20.safeTransferFrom(IERC20(token), payer, recipient, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AbstractSelfPermit2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\n\\n/// @dev Backward compatible EIP-2612 contract definitions.\\n//  For more information, please refer to https://eips.ethereum.org/EIPS/eip-2612#backwards-compatibility\\ninterface IPermit2612Compatible {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\n/// @dev Base contract for supporting the EIP-2612 specification.\\n/// For more information, please refer to https://eips.ethereum.org/EIPS/eip-2612\\nabstract contract AbstractSelfPermit2612 {\\n    function selfPermit(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable {\\n        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    }\\n\\n    function selfPermitIfNecessary(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable {\\n        if (IERC20(token).allowance(msg.sender, address(this)) < value)\\n            IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    }\\n\\n    function selfPermitCompatible(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable {\\n        IPermit2612Compatible(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\\n    }\\n\\n    function selfPermitCompatibleIfNecessary(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable {\\n        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)\\n            IPermit2612Compatible(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IMakerOrderManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@gridexprotocol/core/contracts/interfaces/callback/IGridPlaceMakerOrderCallback.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/interfaces/IGridParameters.sol\\\";\\n\\n/// @title The interface for the maker order manager\\ninterface IMakerOrderManager is IGridPlaceMakerOrderCallback {\\n    struct InitializeParameters {\\n        address tokenA;\\n        address tokenB;\\n        int24 resolution;\\n        uint160 priceX96;\\n        address recipient;\\n        IGridParameters.BoundaryLowerWithAmountParameters[] orders0;\\n        IGridParameters.BoundaryLowerWithAmountParameters[] orders1;\\n    }\\n\\n    struct PlaceOrderParameters {\\n        uint256 deadline;\\n        address recipient;\\n        address tokenA;\\n        address tokenB;\\n        int24 resolution;\\n        bool zero;\\n        int24 boundaryLower;\\n        uint128 amount;\\n    }\\n\\n    struct PlaceOrderInBatchParameters {\\n        uint256 deadline;\\n        address recipient;\\n        address tokenA;\\n        address tokenB;\\n        int24 resolution;\\n        bool zero;\\n        IGridParameters.BoundaryLowerWithAmountParameters[] orders;\\n    }\\n\\n    /// @notice Initializes the grid with the given parameters\\n    function initialize(InitializeParameters calldata initializeParameters) external payable;\\n\\n    /// @notice Creates the grid and initializes the grid with the given parameters\\n    function createGridAndInitialize(InitializeParameters calldata initializeParameters) external payable;\\n\\n    /// @notice Places a maker order on the grid\\n    /// @return orderId The unique identifier of the order\\n    function placeMakerOrder(PlaceOrderParameters calldata parameters) external payable returns (uint256 orderId);\\n\\n    /// @notice Places maker orders on the grid\\n    /// @return orderIds The unique identifiers of the orders\\n    function placeMakerOrderInBatch(\\n        PlaceOrderInBatchParameters calldata parameters\\n    ) external payable returns (uint256[] memory orderIds);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPayments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IPayments {\\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\\n    /// @param recipient The address receiving ETH\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\\n\\n    /// @notice Refunds any native token(e.g. ETH) balance held by this contract to the `msg.sender`\\n    /// @dev This method is suitable for the following 2 scenarios:\\n    /// 1. When using exactInput, the inputted Ether is not fully consumed due to insufficient liquidity so,\\n    ///    remaining Ether can be withdrawn through this method\\n    /// 2. When using exactOutput, the inputted Ether is not fully consumed because the slippage settings\\n    /// are too high, henceforth, the remaining Ether can be withdrawn through this method\\n    function refundNativeToken() external payable;\\n\\n    /// @notice Transfers the full amount of a token held by this contract to a recipient\\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\\n    /// @param token The contract address of the tokens which will be transferred to the `recipient`\\n    /// @param amountMinimum The minimum amount of tokens required for a transfer\\n    /// @param recipient The destination address of the tokens\\n    function sweepToken(address token, uint256 amountMinimum, address recipient) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IRelativeOrderManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title The interface for the relative order manager\\ninterface IRelativeOrderManager {\\n    struct RelativeOrderParameters {\\n        uint256 deadline;\\n        address recipient;\\n        address tokenA;\\n        address tokenB;\\n        int24 resolution;\\n        bool zero;\\n        uint128 amount;\\n        /// @dev The price delta is the price difference between the order price and the grid price, as a Q64.96.\\n        /// Positive values mean the order price is higher than the grid price, and negative values mean the order price is\\n        /// lower than the grid price.\\n        int160 priceDeltaX96;\\n        /// @dev The minimum price of the order, as a Q64.96.\\n        uint160 priceMinimumX96;\\n        /// @dev The maximum price of the order, as a Q64.96.\\n        uint160 priceMaximumX96;\\n    }\\n\\n    /// @notice Places a relative order\\n    /// @param parameters The parameters for the relative order\\n    /// @return orderId The unique identifier of the order\\n    function placeRelativeOrder(RelativeOrderParameters calldata parameters) external payable returns (uint256 orderId);\\n}\\n\"\r\n    },\r\n    \"contracts/MakerOrderManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity =0.8.9;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/interfaces/IGrid.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/interfaces/IGridParameters.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/interfaces/IGridFactory.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/libraries/GridAddress.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/libraries/CallbackValidator.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/libraries/BoundaryMath.sol\\\";\\nimport \\\"./interfaces/IMakerOrderManager.sol\\\";\\nimport \\\"./interfaces/IRelativeOrderManager.sol\\\";\\nimport \\\"./Multicall.sol\\\";\\nimport \\\"./AbstractPayments.sol\\\";\\nimport \\\"./AbstractSelfPermit2612.sol\\\";\\n\\n/// @title The implementation for the maker order manager\\ncontract MakerOrderManager is\\n    IMakerOrderManager,\\n    IRelativeOrderManager,\\n    AbstractPayments,\\n    AbstractSelfPermit2612,\\n    Multicall\\n{\\n    constructor(address _gridFactory, address _weth9) AbstractPayments(_gridFactory, _weth9) {}\\n\\n    struct PlaceMakerOrderCalldata {\\n        GridAddress.GridKey gridKey;\\n        address payer;\\n    }\\n\\n    /// @inheritdoc IGridPlaceMakerOrderCallback\\n    function gridexPlaceMakerOrderCallback(uint256 amount0, uint256 amount1, bytes calldata data) external override {\\n        PlaceMakerOrderCalldata memory decodeData = abi.decode(data, (PlaceMakerOrderCalldata));\\n        CallbackValidator.validate(gridFactory, decodeData.gridKey);\\n\\n        if (amount0 > 0) pay(decodeData.gridKey.token0, decodeData.payer, _msgSender(), amount0);\\n\\n        if (amount1 > 0) pay(decodeData.gridKey.token1, decodeData.payer, _msgSender(), amount1);\\n    }\\n\\n    /// @inheritdoc IMakerOrderManager\\n    function initialize(InitializeParameters calldata parameters) external payable {\\n        GridAddress.GridKey memory gridKey = GridAddress.gridKey(\\n            parameters.tokenA,\\n            parameters.tokenB,\\n            parameters.resolution\\n        );\\n        address grid = GridAddress.computeAddress(gridFactory, gridKey);\\n\\n        address recipient = parameters.recipient == address(0) ? _msgSender() : parameters.recipient;\\n\\n        IGrid(grid).initialize(\\n            IGridParameters.InitializeParameters({\\n                priceX96: parameters.priceX96,\\n                recipient: recipient,\\n                orders0: parameters.orders0,\\n                orders1: parameters.orders1\\n            }),\\n            abi.encode(PlaceMakerOrderCalldata({gridKey: gridKey, payer: _msgSender()}))\\n        );\\n    }\\n\\n    /// @inheritdoc IMakerOrderManager\\n    function createGridAndInitialize(InitializeParameters calldata parameters) external payable {\\n        address grid = IGridFactory(gridFactory).createGrid(\\n            parameters.tokenA,\\n            parameters.tokenB,\\n            parameters.resolution\\n        );\\n\\n        address recipient = parameters.recipient == address(0) ? _msgSender() : parameters.recipient;\\n\\n        IGrid(grid).initialize(\\n            IGridParameters.InitializeParameters({\\n                priceX96: parameters.priceX96,\\n                recipient: recipient,\\n                orders0: parameters.orders0,\\n                orders1: parameters.orders1\\n            }),\\n            abi.encode(\\n                PlaceMakerOrderCalldata({\\n                    gridKey: GridAddress.gridKey(parameters.tokenA, parameters.tokenB, parameters.resolution),\\n                    payer: _msgSender()\\n                })\\n            )\\n        );\\n    }\\n\\n    /// @inheritdoc IMakerOrderManager\\n    function placeMakerOrder(\\n        PlaceOrderParameters calldata parameters\\n    ) external payable checkDeadline(parameters.deadline) returns (uint256 orderId) {\\n        GridAddress.GridKey memory gridKey = GridAddress.gridKey(\\n            parameters.tokenA,\\n            parameters.tokenB,\\n            parameters.resolution\\n        );\\n        address grid = GridAddress.computeAddress(gridFactory, gridKey);\\n\\n        address recipient = parameters.recipient == address(0) ? _msgSender() : parameters.recipient;\\n\\n        orderId = _placeMakerOrder(\\n            grid,\\n            gridKey,\\n            recipient,\\n            parameters.zero,\\n            parameters.boundaryLower,\\n            parameters.amount\\n        );\\n    }\\n\\n    function _placeMakerOrder(\\n        address grid,\\n        GridAddress.GridKey memory gridKey,\\n        address recipient,\\n        bool zero,\\n        int24 boundaryLower,\\n        uint128 amount\\n    ) private returns (uint256 orderId) {\\n        orderId = IGrid(grid).placeMakerOrder(\\n            IGridParameters.PlaceOrderParameters({\\n                recipient: recipient,\\n                zero: zero,\\n                boundaryLower: boundaryLower,\\n                amount: amount\\n            }),\\n            abi.encode(PlaceMakerOrderCalldata({gridKey: gridKey, payer: _msgSender()}))\\n        );\\n    }\\n\\n    /// @inheritdoc IMakerOrderManager\\n    function placeMakerOrderInBatch(\\n        PlaceOrderInBatchParameters calldata parameters\\n    ) external payable checkDeadline(parameters.deadline) returns (uint256[] memory orderIds) {\\n        GridAddress.GridKey memory gridKey = GridAddress.gridKey(\\n            parameters.tokenA,\\n            parameters.tokenB,\\n            parameters.resolution\\n        );\\n        address grid = GridAddress.computeAddress(gridFactory, gridKey);\\n\\n        address recipient = parameters.recipient == address(0) ? _msgSender() : parameters.recipient;\\n\\n        orderIds = IGrid(grid).placeMakerOrderInBatch(\\n            IGridParameters.PlaceOrderInBatchParameters({\\n                recipient: recipient,\\n                zero: parameters.zero,\\n                orders: parameters.orders\\n            }),\\n            abi.encode(PlaceMakerOrderCalldata({gridKey: gridKey, payer: _msgSender()}))\\n        );\\n    }\\n\\n    /// @inheritdoc IRelativeOrderManager\\n    function placeRelativeOrder(\\n        RelativeOrderParameters calldata parameters\\n    ) external payable checkDeadline(parameters.deadline) returns (uint256 orderId) {\\n        // MOM_AIZ: amount is zero\\n        require(parameters.amount > 0, \\\"MOM_AIZ\\\");\\n\\n        GridAddress.GridKey memory gridKey = GridAddress.gridKey(\\n            parameters.tokenA,\\n            parameters.tokenB,\\n            parameters.resolution\\n        );\\n        address grid = GridAddress.computeAddress(gridFactory, gridKey);\\n\\n        (uint160 priceX96, , , ) = IGrid(grid).slot0();\\n        uint160 targetPriceX96 = parameters.priceDeltaX96 > 0\\n            ? priceX96 + uint160(parameters.priceDeltaX96)\\n            : priceX96 - uint160(-parameters.priceDeltaX96);\\n\\n        // MOM_POR: price out of range\\n        require(BoundaryMath.isPriceX96InRange(targetPriceX96), \\\"MOM_POR\\\");\\n        require(\\n            targetPriceX96 >= parameters.priceMinimumX96 && targetPriceX96 <= parameters.priceMaximumX96,\\n            \\\"MOM_POR\\\"\\n        );\\n\\n        int24 boundaryLower = BoundaryMath.rewriteToValidBoundaryLower(\\n            BoundaryMath.getBoundaryLowerAtBoundary(\\n                BoundaryMath.getBoundaryAtPriceX96(targetPriceX96),\\n                parameters.resolution\\n            ),\\n            parameters.resolution\\n        );\\n\\n        // when the input is token1 and the price has reached the right boundary price,\\n        // we need to subtract a resolution from boundary lower\\n        if (!parameters.zero) {\\n            uint160 priceMaxX96 = BoundaryMath.getPriceX96AtBoundary(boundaryLower);\\n            boundaryLower = priceMaxX96 == targetPriceX96\\n                ? BoundaryMath.rewriteToValidBoundaryLower(\\n                    boundaryLower -= parameters.resolution,\\n                    parameters.resolution\\n                ) // avoid underflow\\n                : boundaryLower;\\n        }\\n\\n        address recipient = parameters.recipient == address(0) ? _msgSender() : parameters.recipient;\\n\\n        orderId = _placeMakerOrder(grid, gridKey, recipient, parameters.zero, boundaryLower, parameters.amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nabstract contract Multicall {\\n    function multicall(bytes[] calldata data) external payable virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        unchecked {\\n            for (uint256 i = 0; i < data.length; i++) {\\n                results[i] = _functionDelegateCall(data[i]);\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    function _functionDelegateCall(bytes memory data) private returns (bytes memory) {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(this).delegatecall(data);\\n        // M_LDCF: low-level delegate call failed\\n        return Address.verifyCallResult(success, returndata, \\\"M_LDCF\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100000000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gridFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth9\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"resolution\",\"type\":\"int24\"},{\"internalType\":\"uint160\",\"name\":\"priceX96\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"boundaryLower\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct IGridParameters.BoundaryLowerWithAmountParameters[]\",\"name\":\"orders0\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"boundaryLower\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct IGridParameters.BoundaryLowerWithAmountParameters[]\",\"name\":\"orders1\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMakerOrderManager.InitializeParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"createGridAndInitialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gridFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"gridexPlaceMakerOrderCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"resolution\",\"type\":\"int24\"},{\"internalType\":\"uint160\",\"name\":\"priceX96\",\"type\":\"uint160\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"boundaryLower\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct IGridParameters.BoundaryLowerWithAmountParameters[]\",\"name\":\"orders0\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"boundaryLower\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct IGridParameters.BoundaryLowerWithAmountParameters[]\",\"name\":\"orders1\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMakerOrderManager.InitializeParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"resolution\",\"type\":\"int24\"},{\"internalType\":\"bool\",\"name\":\"zero\",\"type\":\"bool\"},{\"internalType\":\"int24\",\"name\":\"boundaryLower\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct IMakerOrderManager.PlaceOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"placeMakerOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"resolution\",\"type\":\"int24\"},{\"internalType\":\"bool\",\"name\":\"zero\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"boundaryLower\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"internalType\":\"struct IGridParameters.BoundaryLowerWithAmountParameters[]\",\"name\":\"orders\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IMakerOrderManager.PlaceOrderInBatchParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"placeMakerOrderInBatch\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"orderIds\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"resolution\",\"type\":\"int24\"},{\"internalType\":\"bool\",\"name\":\"zero\",\"type\":\"bool\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"int160\",\"name\":\"priceDeltaX96\",\"type\":\"int160\"},{\"internalType\":\"uint160\",\"name\":\"priceMinimumX96\",\"type\":\"uint160\"},{\"internalType\":\"uint160\",\"name\":\"priceMaximumX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IRelativeOrderManager.RelativeOrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"placeRelativeOrder\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundNativeToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitCompatible\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitCompatibleIfNecessary\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitIfNecessary\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrapWETH9\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth9\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "MakerOrderManager", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "100000000", "ConstructorArguments": "00000000000000000000000032d1f0dce675902f89d72251db4ab1d728efa19c0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}