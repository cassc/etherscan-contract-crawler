{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"deploy/@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role, _msgSender());\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    function _grantRole(bytes32 role, address account) private {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    function _revokeRole(bytes32 role, address account) private {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/access/AccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControlEnumerable.sol\\\";\\nimport \\\"./AccessControl.sol\\\";\\nimport \\\"../utils/structs/EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\\n */\\nabstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    mapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControlEnumerable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {\\n        return _roleMembers[role].at(index);\\n    }\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {\\n        return _roleMembers[role].length();\\n    }\\n\\n    /**\\n     * @dev Overload {grantRole} to track enumerable memberships\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        super.grantRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n\\n    /**\\n     * @dev Overload {revokeRole} to track enumerable memberships\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        super.revokeRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev Overload {renounceRole} to track enumerable memberships\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {\\n        super.renounceRole(role, account);\\n        _roleMembers[role].remove(account);\\n    }\\n\\n    /**\\n     * @dev Overload {_setupRole} to track enumerable memberships\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual override {\\n        super._setupRole(role, account);\\n        _roleMembers[role].add(account);\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/access/IAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\n\\n/**\\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\\n */\\ninterface IAccessControlEnumerable is IAccessControl {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(bytes32 role, uint256 index) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(bytes32 role) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastvalue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastvalue;\\n                // Update the index for the moved value\\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v6/MultiLpLiquidityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPool\\n} from './interfaces/IMultiLpLiquidityPool.sol';\\nimport {\\n  ISynthereumLendingSwitch\\n} from '../common/interfaces/ILendingSwitch.sol';\\nimport {\\n  ISynthereumLendingTransfer\\n} from '../common/interfaces/ILendingTransfer.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPoolEvents\\n} from './interfaces/IMultiLpLiquidityPoolEvents.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport {PreciseUnitMath} from '../../base/utils/PreciseUnitMath.sol';\\nimport {\\n  SynthereumMultiLpLiquidityPoolMainLib\\n} from './MultiLpLiquidityPoolMainLib.sol';\\nimport {\\n  SynthereumMultiLpLiquidityPoolMigrationLib\\n} from './MultiLpLiquidityPoolMigrationLib.sol';\\nimport {\\n  SynthereumPoolMigrationFrom\\n} from '../common/migration/PoolMigrationFrom.sol';\\nimport {\\n  SynthereumPoolMigrationTo\\n} from '../common/migration/PoolMigrationTo.sol';\\nimport {ERC2771Context} from '../../common/ERC2771Context.sol';\\nimport {\\n  AccessControlEnumerable,\\n  Context\\n} from '../../../@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\nimport {\\n  ReentrancyGuard\\n} from '../../../@openzeppelin/contracts/security/ReentrancyGuard.sol';\\n\\n/**\\n * @title Multi LP Synthereum pool\\n */\\ncontract SynthereumMultiLpLiquidityPool is\\n  ISynthereumMultiLpLiquidityPoolEvents,\\n  ISynthereumLendingTransfer,\\n  ISynthereumLendingSwitch,\\n  ISynthereumMultiLpLiquidityPool,\\n  ReentrancyGuard,\\n  AccessControlEnumerable,\\n  ERC2771Context,\\n  SynthereumPoolMigrationTo,\\n  SynthereumPoolMigrationFrom\\n{\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SynthereumMultiLpLiquidityPoolMainLib for Storage;\\n  using SynthereumMultiLpLiquidityPoolMigrationLib for Storage;\\n\\n  //----------------------------------------\\n  // Constants\\n  //----------------------------------------\\n\\n  string public constant override typology = 'POOL';\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  //----------------------------------------\\n  // Storage\\n  //----------------------------------------\\n\\n  Storage internal storageParams;\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  modifier isNotExpired(uint256 expirationTime) {\\n    require(block.timestamp <= expirationTime, 'Transaction expired');\\n    _;\\n  }\\n\\n  modifier isNotInitialized() {\\n    require(!storageParams.isInitialized, 'Pool already initialized');\\n    _;\\n    storageParams.isInitialized = true;\\n  }\\n\\n  /**\\n   * @notice Initialize pool\\n   * @param _params Params used for initialization (see InitializationParams struct)\\n   */\\n  function initialize(InitializationParams calldata _params)\\n    external\\n    override\\n    isNotInitialized\\n    nonReentrant\\n  {\\n    finder = _params.finder;\\n    storageParams.initialize(_params);\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, _params.roles.admin);\\n    _setupRole(MAINTAINER_ROLE, _params.roles.maintainer);\\n  }\\n\\n  /**\\n   * @notice Register a liquidity provider to the LP's whitelist\\n   * @notice This can be called only by the maintainer\\n   * @param _lp Address of the LP\\n   */\\n  function registerLP(address _lp)\\n    external\\n    override\\n    nonReentrant\\n    onlyMaintainer\\n  {\\n    storageParams.registerLP(_lp);\\n  }\\n\\n  /**\\n   * @notice Add the Lp to the active list of the LPs and initialize collateral and overcollateralization\\n   * @notice Only a registered and inactive LP can call this function to add himself\\n   * @param _collateralAmount Collateral amount to deposit by the LP\\n   * @param _overCollateralization Overcollateralization to set by the LP\\n   * @return collateralDeposited Net collateral deposited in the LP position\\n   */\\n  function activateLP(uint256 _collateralAmount, uint128 _overCollateralization)\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256 collateralDeposited)\\n  {\\n    return\\n      storageParams.activateLP(\\n        _collateralAmount,\\n        _overCollateralization,\\n        finder,\\n        _msgSender()\\n      );\\n  }\\n\\n  /**\\n   * @notice Add collateral to an active LP position\\n   * @notice Only an active LP can call this function to add collateral to his position\\n   * @param _collateralAmount Collateral amount to deposit by the LP\\n   * @return collateralDeposited Net collateral deposited in the LP position\\n   * @return newLpCollateralAmount Amount of collateral of the LP after the increase\\n   */\\n  function addLiquidity(uint256 _collateralAmount)\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256 collateralDeposited, uint256 newLpCollateralAmount)\\n  {\\n    return storageParams.addLiquidity(_collateralAmount, finder, _msgSender());\\n  }\\n\\n  /**\\n   * @notice Withdraw collateral from an active LP position\\n   * @notice Only an active LP can call this function to withdraw collateral from his position\\n   * @param _collateralAmount Collateral amount to withdraw by the LP\\n   * @return collateralRemoved Net collateral decreased form the position\\n   * @return collateralReceived Collateral received from the withdrawal\\n   * @return newLpCollateralAmount Amount of collateral of the LP after the decrease\\n   */\\n  function removeLiquidity(uint256 _collateralAmount)\\n    external\\n    override\\n    nonReentrant\\n    returns (\\n      uint256 collateralRemoved,\\n      uint256 collateralReceived,\\n      uint256 newLpCollateralAmount\\n    )\\n  {\\n    return\\n      storageParams.removeLiquidity(_collateralAmount, finder, _msgSender());\\n  }\\n\\n  /**\\n   * @notice Set the overCollateralization by an active LP\\n   * @notice This can be called only by an active LP\\n   * @param _overCollateralization New overCollateralizations\\n   */\\n  function setOvercollateralization(uint128 _overCollateralization)\\n    external\\n    override\\n    nonReentrant\\n  {\\n    storageParams.setOvercollateralization(\\n      _overCollateralization,\\n      finder,\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Mint synthetic tokens using fixed amount of collateral\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve collateral transfer for the mint request to succeed\\n   * @param _mintParams Input parameters for minting (see MintParams struct)\\n   * @return Amount of synthetic tokens minted by a user\\n   * @return Amount of collateral paid by the user as fee\\n   */\\n  function mint(MintParams calldata _mintParams)\\n    external\\n    override\\n    nonReentrant\\n    isNotExpired(_mintParams.expiration)\\n    returns (uint256, uint256)\\n  {\\n    return storageParams.mint(_mintParams, finder, _msgSender());\\n  }\\n\\n  /**\\n   * @notice Redeem amount of collateral using fixed number of synthetic token\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param _redeemParams Input parameters for redeeming (see RedeemParams struct)\\n   * @return Amount of collateral redeemed by user\\n   * @return Amount of collateral paid by user as fee\\n   */\\n  function redeem(RedeemParams calldata _redeemParams)\\n    external\\n    override\\n    nonReentrant\\n    isNotExpired(_redeemParams.expiration)\\n    returns (uint256, uint256)\\n  {\\n    return storageParams.redeem(_redeemParams, finder, _msgSender());\\n  }\\n\\n  /**\\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\\n   * @notice Revert if position is not undercollateralized\\n   * @param _lp LP that the the user wants to liquidate\\n   * @param _numSynthTokens Number of synthetic tokens that user wants to liquidate\\n   * @return Amount of collateral received (Amount of collateral + bonus)\\n   */\\n  function liquidate(address _lp, uint256 _numSynthTokens)\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256)\\n  {\\n    return storageParams.liquidate(_lp, _numSynthTokens, finder, _msgSender());\\n  }\\n\\n  /**\\n   * @notice Update interests and positions ov every LP\\n   * @notice Everyone can call this function\\n   */\\n  function updatePositions() external override nonReentrant {\\n    storageParams.updatePositions(finder);\\n  }\\n\\n  /**\\n   * @notice Transfer a bearing amount to the lending manager\\n   * @notice Only the lending manager can call the function\\n   * @param _bearingAmount Amount of bearing token to transfer\\n   * @return bearingAmountOut Real bearing amount transferred to the lending manager\\n   */\\n  function transferToLendingManager(uint256 _bearingAmount)\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256 bearingAmountOut)\\n  {\\n    return storageParams.transferToLendingManager(_bearingAmount, finder);\\n  }\\n\\n  /**\\n   * @notice Transfer all bearing tokens to another address\\n   * @notice Only the lending manager can call the function\\n   * @param _recipient Address receving bearing amount\\n   * @return migrationAmount Total balance of the pool in bearing tokens before migration\\n   */\\n  function migrateTotalFunds(address _recipient)\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256 migrationAmount)\\n  {\\n    return\\n      SynthereumMultiLpLiquidityPoolMigrationLib.migrateTotalFunds(\\n        _recipient,\\n        finder\\n      );\\n  }\\n\\n  /**\\n   * @notice Set new liquidation reward percentage\\n   * @notice This can be called only by the maintainer\\n   * @param _newLiquidationReward New liquidation reward percentage\\n   */\\n  function setLiquidationReward(uint64 _newLiquidationReward)\\n    external\\n    override\\n    nonReentrant\\n    onlyMaintainer\\n  {\\n    storageParams.setLiquidationReward(_newLiquidationReward);\\n  }\\n\\n  /**\\n   * @notice Set new fee percentage\\n   * @notice This can be called only by the maintainer\\n   * @param _newFee New fee percentage\\n   */\\n  function setFee(uint64 _newFee)\\n    external\\n    override\\n    nonReentrant\\n    onlyMaintainer\\n  {\\n    storageParams.setFee(_newFee);\\n  }\\n\\n  /**\\n   * @notice Set new lending protocol for this pool\\n   * @notice This can be called only by the synthereum manager\\n   * @param _lendingId Name of the new lending module\\n   * @param _bearingToken Token of the lending mosule to be used for intersts accrual\\n            (used only if the lending manager doesn't automatically find the one associated to the collateral fo this pool)\\n   */\\n  function switchLendingModule(\\n    string calldata _lendingId,\\n    address _bearingToken\\n  ) external override nonReentrant {\\n    storageParams.switchLendingModule(_lendingId, _bearingToken, finder);\\n  }\\n\\n  /**\\n   * @notice Get all the registered LPs of this pool\\n   * @return The list of addresses of all the registered LPs in the pool.\\n   */\\n  function getRegisteredLPs()\\n    external\\n    view\\n    override\\n    returns (address[] memory)\\n  {\\n    return storageParams.getRegisteredLPs();\\n  }\\n\\n  /**\\n   * @notice Get all the active LPs of this pool\\n   * @return The list of addresses of all the active LPs in the pool.\\n   */\\n  function getActiveLPs() external view override returns (address[] memory) {\\n    return storageParams.getActiveLPs();\\n  }\\n\\n  /**\\n   * @notice Check if the input LP is registered\\n   * @param _lp Address of the LP\\n   * @return Return true if the LP is regitered, otherwise false\\n   */\\n  function isRegisteredLP(address _lp) external view override returns (bool) {\\n    return storageParams.registeredLPs.contains(_lp);\\n  }\\n\\n  /**\\n   * @notice Check if the input LP is active\\n   * @param _lp Address of the LP\\n   * @return Return true if the LP is active, otherwise false\\n   */\\n  function isActiveLP(address _lp) external view override returns (bool) {\\n    return storageParams.activeLPs.contains(_lp);\\n  }\\n\\n  /**\\n   * @notice Get Synthereum finder of the pool\\n   * @return Finder contract\\n   */\\n  function synthereumFinder()\\n    external\\n    view\\n    override\\n    returns (ISynthereumFinder)\\n  {\\n    return finder;\\n  }\\n\\n  /**\\n   * @notice Get Synthereum version\\n   * @return The version of this pool\\n   */\\n  function version() external view override returns (uint8) {\\n    return storageParams.poolVersion;\\n  }\\n\\n  /**\\n   * @notice Get the collateral token of this pool\\n   * @return The ERC20 collateral token\\n   */\\n  function collateralToken() external view override returns (IERC20) {\\n    return storageParams.collateralAsset;\\n  }\\n\\n  /**\\n   * @notice Get the decimals of the collateral\\n   * @return Number of decimals of the collateral\\n   */\\n  function collateralTokenDecimals() external view override returns (uint8) {\\n    return storageParams.collateralDecimals;\\n  }\\n\\n  /**\\n   * @notice Get the synthetic token associated to this pool\\n   * @return The ERC20 synthetic token\\n   */\\n  function syntheticToken() external view override returns (IERC20) {\\n    return storageParams.syntheticAsset;\\n  }\\n\\n  /**\\n   * @notice Get the synthetic token symbol associated to this pool\\n   * @return The ERC20 synthetic token symbol\\n   */\\n  function syntheticTokenSymbol()\\n    external\\n    view\\n    override\\n    returns (string memory)\\n  {\\n    return IStandardERC20(address(storageParams.syntheticAsset)).symbol();\\n  }\\n\\n  /**\\n   * @notice Returns the percentage of overcollateralization to which a liquidation can triggered\\n   * @return Thresold percentage on a liquidation can be triggered\\n   */\\n  function collateralRequirement() external view override returns (uint256) {\\n    return\\n      PreciseUnitMath.PRECISE_UNIT + storageParams.overCollateralRequirement;\\n  }\\n\\n  /**\\n   * @notice Returns the percentage of reward for correct liquidation by a liquidator\\n   * @return Percentage of reward\\n   */\\n  function liquidationReward() external view override returns (uint256) {\\n    return storageParams.liquidationBonus;\\n  }\\n\\n  /**\\n   * @notice Returns price identifier of the pool\\n   * @return Price identifier\\n   */\\n  function priceFeedIdentifier() external view override returns (bytes32) {\\n    return storageParams.priceIdentifier;\\n  }\\n\\n  /**\\n   * @notice Returns fee percentage of the pool\\n   * @return Fee percentage\\n   */\\n  function feePercentage() external view override returns (uint256) {\\n    return storageParams.fee;\\n  }\\n\\n  /**\\n   * @notice Returns total number of synthetic tokens generated by this pool\\n   * @return Number of synthetic tokens\\n   */\\n  function totalSyntheticTokens() external view override returns (uint256) {\\n    return storageParams.totalSyntheticAsset;\\n  }\\n\\n  /**\\n   * @notice Returns the total amounts of collateral\\n   * @return usersCollateral Total collateral amount currently holded by users\\n   * @return lpsCollateral Total collateral amount currently holded by LPs\\n   * @return totalCollateral Total collateral amount currently holded by users + LPs\\n   */\\n  function totalCollateralAmount()\\n    external\\n    view\\n    override\\n    returns (\\n      uint256 usersCollateral,\\n      uint256 lpsCollateral,\\n      uint256 totalCollateral\\n    )\\n  {\\n    return storageParams.totalCollateralAmount(finder);\\n  }\\n\\n  /**\\n   * @notice Returns the max capacity in synth assets of all the LPs\\n   * @return maxCapacity Total max capacity of the pool\\n   */\\n  function maxTokensCapacity()\\n    external\\n    view\\n    override\\n    returns (uint256 maxCapacity)\\n  {\\n    return storageParams.maxTokensCapacity(finder);\\n  }\\n\\n  /**\\n   * @notice Returns the LP parametrs info\\n   * @notice Mint, redeem and intreest shares are round down (division dust not included)\\n   * @param _lp Address of the LP\\n   * @return info Info of the input LP (see LPInfo struct)\\n   */\\n  function positionLPInfo(address _lp)\\n    external\\n    view\\n    override\\n    returns (LPInfo memory info)\\n  {\\n    return storageParams.positionLPInfo(_lp, finder);\\n  }\\n\\n  /**\\n   * @notice Returns the lending protocol info\\n   * @return lendingId Name of the lending module\\n   * @return bearingToken Address of the bearing token held by the pool for interest accrual\\n   */\\n  function lendingProtocolInfo()\\n    external\\n    view\\n    returns (string memory lendingId, address bearingToken)\\n  {\\n    return storageParams.lendingProtocolInfo(finder);\\n  }\\n\\n  /**\\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\\n   * @notice This function is only trading-informative, it doesn't check edge case conditions like lending manager dust and reverting due to dust splitting\\n   * @param _collateralAmount Input collateral amount to be exchanged\\n   * @return synthTokensReceived Synthetic tokens will be minted\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getMintTradeInfo(uint256 _collateralAmount)\\n    external\\n    view\\n    override\\n    returns (uint256 synthTokensReceived, uint256 feePaid)\\n  {\\n    (synthTokensReceived, feePaid) = storageParams.getMintTradeInfo(\\n      _collateralAmount,\\n      finder\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check edge case conditions like lending manager dust and undercap of one or more LPs\\n   * @param  _syntTokensAmount Amount of synthetic tokens to be exchanged\\n   * @return collateralAmountReceived Collateral amount will be received by the user\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getRedeemTradeInfo(uint256 _syntTokensAmount)\\n    external\\n    view\\n    override\\n    returns (uint256 collateralAmountReceived, uint256 feePaid)\\n  {\\n    (collateralAmountReceived, feePaid) = storageParams.getRedeemTradeInfo(\\n      _syntTokensAmount,\\n      finder\\n    );\\n  }\\n\\n  /**\\n   * @notice Check if an address is the trusted forwarder\\n   * @param  forwarder Address to check\\n   * @return True is the input address is the trusted forwarder, otherwise false\\n   */\\n  function isTrustedForwarder(address forwarder)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    try\\n      finder.getImplementationAddress(SynthereumInterfaces.TrustedForwarder)\\n    returns (address trustedForwarder) {\\n      if (forwarder == trustedForwarder) {\\n        return true;\\n      } else {\\n        return false;\\n      }\\n    } catch {\\n      return false;\\n    }\\n  }\\n\\n  /**\\n   * @notice Return sender of the transaction\\n   */\\n  function _msgSender()\\n    internal\\n    view\\n    override(ERC2771Context, Context)\\n    returns (address sender)\\n  {\\n    return ERC2771Context._msgSender();\\n  }\\n\\n  /**\\n   * @notice Return data of the transaction\\n   */\\n  function _msgData()\\n    internal\\n    view\\n    override(ERC2771Context, Context)\\n    returns (bytes calldata)\\n  {\\n    return ERC2771Context._msgData();\\n  }\\n\\n  /**\\n   * @notice Clean and reset the storage to the initial state during migration\\n   */\\n  function _cleanStorage() internal override {\\n    address[] memory registeredLPsList = storageParams.getRegisteredLPs();\\n\\n    address[] memory activeLPsList = storageParams.getActiveLPs();\\n\\n    storageParams.cleanStorage(registeredLPsList, activeLPsList);\\n  }\\n\\n  /**\\n   * @notice Set the storage to the new pool during migration\\n   * @param _oldVersion Version of the migrated pool\\n   * @param _storageBytes Pool storage encoded in bytes\\n   * @param _newVersion Version of the new deployed pool\\n   * @param _extraInputParams Additive input pool params encoded for the new pool, that are not part of the migrationPool\\n   */\\n  function _setStorage(\\n    uint8 _oldVersion,\\n    bytes calldata _storageBytes,\\n    uint8 _newVersion,\\n    bytes calldata _extraInputParams\\n  ) internal override isNotInitialized {\\n    (address[] memory admins, address[] memory maintainers) =\\n      storageParams.setStorage(\\n        _oldVersion,\\n        _storageBytes,\\n        _newVersion,\\n        _extraInputParams\\n      );\\n\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    for (uint256 j = 0; j < admins.length; j++) {\\n      _setupRole(DEFAULT_ADMIN_ROLE, admins[j]);\\n    }\\n    for (uint256 j = 0; j < maintainers.length; j++) {\\n      _setupRole(MAINTAINER_ROLE, maintainers[j]);\\n    }\\n  }\\n\\n  /**\\n   * @notice Update positions during migration\\n   */\\n  function _modifyStorageFrom() internal override {\\n    storageParams.updatePositions(finder);\\n  }\\n\\n  /**\\n   * @notice Update the storage of the new pool after the migration\\n   * @param _sourceCollateralAmount Collateral amount from the source pool\\n   * @param _actualCollateralAmount Collateral amount of the new pool\\n   * @param _price Actual price of the pair\\n   */\\n  function _modifyStorageTo(\\n    uint256 _sourceCollateralAmount,\\n    uint256 _actualCollateralAmount,\\n    uint256 _price\\n  ) internal override {\\n    storageParams.updateMigrationStorage(\\n      _sourceCollateralAmount,\\n      _actualCollateralAmount,\\n      _price\\n    );\\n  }\\n\\n  /**\\n   * @notice Encode storage in bytes during migration\\n   * @return poolVersion Version of the pool\\n   * @return price Actual price of the pair\\n   * @return storageBytes Pool storage encoded in bytes\\n   */\\n  function _encodeStorage()\\n    internal\\n    view\\n    override\\n    returns (\\n      uint8 poolVersion,\\n      uint256 price,\\n      bytes memory storageBytes\\n    )\\n  {\\n    uint256 numberOfRoles = getRoleMemberCount(DEFAULT_ADMIN_ROLE);\\n    address[] memory admins = new address[](numberOfRoles);\\n    for (uint256 j = 0; j < numberOfRoles; j++) {\\n      address newMember = getRoleMember(DEFAULT_ADMIN_ROLE, j);\\n      admins[j] = newMember;\\n    }\\n    numberOfRoles = getRoleMemberCount(MAINTAINER_ROLE);\\n    address[] memory maintainers = new address[](numberOfRoles);\\n    for (uint256 j = 0; j < numberOfRoles; j++) {\\n      address newMember = getRoleMember(MAINTAINER_ROLE, j);\\n      maintainers[j] = newMember;\\n    }\\n\\n    address[] memory registeredLPsList = storageParams.getRegisteredLPs();\\n\\n    address[] memory activeLPsList = storageParams.getActiveLPs();\\n\\n    (poolVersion, price, storageBytes) = storageParams.encodeStorage(\\n      SynthereumMultiLpLiquidityPoolMigrationLib.TempListArgs(\\n        admins,\\n        maintainers,\\n        registeredLPsList,\\n        activeLPsList\\n      ),\\n      finder\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/base/interfaces/IStandardERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\ninterface IStandardERC20 is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n   */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token, usually a shorter version of the\\n   * name.\\n   */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the number of decimals used to get its user representation.\\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n   * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n   *\\n   * Tokens usually opt for a value of 18, imitating the relationship between\\n   * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n   * called.\\n   *\\n   * NOTE: This information is only used for _display_ purposes: it in\\n   * no way affects any of the arithmetic of the contract, including\\n   * {IERC20-balanceOf} and {IERC20-transfer}.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v6/interfaces/IMultiLpLiquidityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ITypology} from '../../../common/interfaces/ITypology.sol';\\nimport {IStandardERC20} from '../../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {\\n  ISynthereumDeployment\\n} from '../../../common/interfaces/IDeployment.sol';\\nimport {ISynthereumFinder} from '../../../core/interfaces/IFinder.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../../@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport {\\n  FixedPoint\\n} from '../../../../@uma/core/contracts/common/implementation/FixedPoint.sol';\\n\\n/**\\n * @title Multi LP pool interface\\n */\\ninterface ISynthereumMultiLpLiquidityPool is ITypology, ISynthereumDeployment {\\n  struct Storage {\\n    EnumerableSet.AddressSet registeredLPs;\\n    EnumerableSet.AddressSet activeLPs;\\n    mapping(address => LPPosition) lpPositions;\\n    string lendingModuleId;\\n    bytes32 priceIdentifier;\\n    uint256 totalSyntheticAsset;\\n    IStandardERC20 collateralAsset;\\n    uint64 fee;\\n    uint8 collateralDecimals;\\n    bool isInitialized;\\n    uint8 poolVersion;\\n    uint128 overCollateralRequirement;\\n    uint64 liquidationBonus;\\n    IMintableBurnableERC20 syntheticAsset;\\n  }\\n\\n  // Describe role structure\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  struct InitializationParams {\\n    // Synthereum finder\\n    ISynthereumFinder finder;\\n    // Synthereum pool version\\n    uint8 version;\\n    // ERC20 collateral token\\n    IStandardERC20 collateralToken;\\n    // ERC20 synthetic token\\n    IMintableBurnableERC20 syntheticToken;\\n    // The addresses of admin and maintainer\\n    Roles roles;\\n    // The fee percentage\\n    uint64 fee;\\n    // Identifier of price to be used in the price feed\\n    bytes32 priceIdentifier;\\n    // Percentage of overcollateralization to which a liquidation can triggered\\n    uint128 overCollateralRequirement;\\n    // Percentage of reward for correct liquidation by a liquidator\\n    uint64 liquidationReward;\\n    // Name of the lending protocol used\\n    string lendingModuleId;\\n  }\\n\\n  struct LPPosition {\\n    // Actual collateral owned\\n    uint256 actualCollateralAmount;\\n    // Number of tokens collateralized\\n    uint256 tokensCollateralized;\\n    // Overcollateralization percentage\\n    uint128 overCollateralization;\\n  }\\n\\n  struct MintParams {\\n    // Minimum amount of synthetic tokens that a user wants to mint using collateral (anti-slippage)\\n    uint256 minNumTokens;\\n    // Amount of collateral that a user wants to spend for minting\\n    uint256 collateralAmount;\\n    // Expiration time of the transaction\\n    uint256 expiration;\\n    // Address to which send synthetic tokens minted\\n    address recipient;\\n  }\\n\\n  struct RedeemParams {\\n    // Amount of synthetic tokens that user wants to use for redeeming\\n    uint256 numTokens;\\n    // Minimium amount of collateral that user wants to redeem (anti-slippage)\\n    uint256 minCollateral;\\n    // Expiration time of the transaction\\n    uint256 expiration;\\n    // Address to which send collateral tokens redeemed\\n    address recipient;\\n  }\\n\\n  struct LPInfo {\\n    // Actual collateral owned\\n    uint256 actualCollateralAmount;\\n    // Number of tokens collateralized\\n    uint256 tokensCollateralized;\\n    // Overcollateralization percentage\\n    uint256 overCollateralization;\\n    // Actual Lp capacity of the Lp in synth asset  (actualCollateralAmount/overCollateralization) * price - numTokens\\n    uint256 capacity;\\n    // Utilization ratio: (numTokens * price_inv * overCollateralization) / actualCollateralAmount\\n    uint256 utilization;\\n    // Collateral coverage: (actualCollateralAmount + numTokens * price_inv) / (numTokens * price_inv)\\n    uint256 coverage;\\n    // Mint shares percentage\\n    uint256 mintShares;\\n    // Redeem shares percentage\\n    uint256 redeemShares;\\n    // Interest shares percentage\\n    uint256 interestShares;\\n    // True if it's overcollateralized, otherwise false\\n    bool isOvercollateralized;\\n  }\\n\\n  /**\\n   * @notice Initialize pool\\n   * @param _params Params used for initialization (see InitializationParams struct)\\n   */\\n  function initialize(InitializationParams calldata _params) external;\\n\\n  /**\\n   * @notice Register a liquidity provider to the LP's whitelist\\n   * @notice This can be called only by the maintainer\\n   * @param _lp Address of the LP\\n   */\\n  function registerLP(address _lp) external;\\n\\n  /**\\n   * @notice Add the Lp to the active list of the LPs and initialize collateral and overcollateralization\\n   * @notice Only a registered and inactive LP can call this function to add himself\\n   * @param _collateralAmount Collateral amount to deposit by the LP\\n   * @param _overCollateralization Overcollateralization to set by the LP\\n   * @return collateralDeposited Net collateral deposited in the LP position\\n   */\\n  function activateLP(uint256 _collateralAmount, uint128 _overCollateralization)\\n    external\\n    returns (uint256 collateralDeposited);\\n\\n  /**\\n   * @notice Add collateral to an active LP position\\n   * @notice Only an active LP can call this function to add collateral to his position\\n   * @param _collateralAmount Collateral amount to deposit by the LP\\n   * @return collateralDeposited Net collateral deposited in the LP position\\n   * @return newLpCollateralAmount Amount of collateral of the LP after the increase\\n   */\\n  function addLiquidity(uint256 _collateralAmount)\\n    external\\n    returns (uint256 collateralDeposited, uint256 newLpCollateralAmount);\\n\\n  /**\\n   * @notice Withdraw collateral from an active LP position\\n   * @notice Only an active LP can call this function to withdraw collateral from his position\\n   * @param _collateralAmount Collateral amount to withdraw by the LP\\n   * @return collateralRemoved Net collateral decreased form the position\\n   * @return collateralReceived Collateral received from the withdrawal\\n   * @return newLpCollateralAmount Amount of collateral of the LP after the decrease\\n   */\\n  function removeLiquidity(uint256 _collateralAmount)\\n    external\\n    returns (\\n      uint256 collateralRemoved,\\n      uint256 collateralReceived,\\n      uint256 newLpCollateralAmount\\n    );\\n\\n  /**\\n   * @notice Set the overCollateralization by an active LP\\n   * @notice This can be called only by an active LP\\n   * @param _overCollateralization New overCollateralizations\\n   */\\n  function setOvercollateralization(uint128 _overCollateralization) external;\\n\\n  /**\\n   * @notice Mint synthetic tokens using fixed amount of collateral\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve collateral transfer for the mint request to succeed\\n   * @param mintParams Input parameters for minting (see MintParams struct)\\n   * @return syntheticTokensMinted Amount of synthetic tokens minted by a user\\n   * @return feePaid Amount of collateral paid by the user as fee\\n   */\\n  function mint(MintParams calldata mintParams)\\n    external\\n    returns (uint256 syntheticTokensMinted, uint256 feePaid);\\n\\n  /**\\n   * @notice Redeem amount of collateral using fixed number of synthetic token\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param redeemParams Input parameters for redeeming (see RedeemParams struct)\\n   * @return collateralRedeemed Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function redeem(RedeemParams calldata redeemParams)\\n    external\\n    returns (uint256 collateralRedeemed, uint256 feePaid);\\n\\n  /**\\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\\n   * @notice Revert if position is not undercollateralized\\n   * @param lp LP that the the user wants to liquidate\\n   * @param numSynthTokens Number of synthetic tokens that user wants to liquidate\\n   * @return Amount of collateral received (Amount of collateral + bonus)\\n   */\\n  function liquidate(address lp, uint256 numSynthTokens)\\n    external\\n    returns (uint256);\\n\\n  /**\\n   * @notice Update interests and positions ov every LP\\n   * @notice Everyone can call this function\\n   */\\n  function updatePositions() external;\\n\\n  /**\\n   * @notice Set new liquidation reward percentage\\n   * @notice This can be called only by the maintainer\\n   * @param _newLiquidationReward New liquidation reward percentage\\n   */\\n  function setLiquidationReward(uint64 _newLiquidationReward) external;\\n\\n  /**\\n   * @notice Set new fee percentage\\n   * @notice This can be called only by the maintainer\\n   * @param _fee New fee percentage\\n   */\\n  function setFee(uint64 _fee) external;\\n\\n  /**\\n   * @notice Get all the registered LPs of this pool\\n   * @return lps The list of addresses of all the registered LPs in the pool.\\n   */\\n  function getRegisteredLPs() external view returns (address[] memory lps);\\n\\n  /**\\n   * @notice Get all the active LPs of this pool\\n   * @return lps The list of addresses of all the active LPs in the pool.\\n   */\\n  function getActiveLPs() external view returns (address[] memory lps);\\n\\n  /**\\n   * @notice Check if the input LP is registered\\n   * @param _lp Address of the LP\\n   * @return isRegistered Return true if the LP is regitered, otherwise false\\n   */\\n  function isRegisteredLP(address _lp)\\n    external\\n    view\\n    returns (bool isRegistered);\\n\\n  /**\\n   * @notice Check if the input LP is active\\n   * @param _lp Address of the LP\\n   * @return isActive Return true if the LP is active, otherwise false\\n   */\\n  function isActiveLP(address _lp) external view returns (bool isActive);\\n\\n  /**\\n   * @notice Get the decimals of the collateral\\n   * @return Number of decimals of the collateral\\n   */\\n  function collateralTokenDecimals() external view returns (uint8);\\n\\n  /**\\n   * @notice Returns the percentage of overcollateralization to which a liquidation can triggered\\n   * @return requirement Thresold percentage on a liquidation can be triggered\\n   */\\n  function collateralRequirement() external view returns (uint256 requirement);\\n\\n  /**\\n   * @notice Returns the percentage of reward for correct liquidation by a liquidator\\n   * @return reward Percentage of reward\\n   */\\n  function liquidationReward() external view returns (uint256 reward);\\n\\n  /**\\n   * @notice Returns price identifier of the pool\\n   * @return identifier Price identifier\\n   */\\n  function priceFeedIdentifier() external view returns (bytes32 identifier);\\n\\n  /**\\n   * @notice Returns fee percentage of the pool\\n   * @return fee Fee percentage\\n   */\\n  function feePercentage() external view returns (uint256 fee);\\n\\n  /**\\n   * @notice Returns total number of synthetic tokens generated by this pool\\n   * @return totalTokens Number of total synthetic tokens in the pool\\n   */\\n  function totalSyntheticTokens() external view returns (uint256 totalTokens);\\n\\n  /**\\n   * @notice Returns the total amounts of collateral\\n   * @return usersCollateral Total collateral amount currently holded by users\\n   * @return lpsCollateral Total collateral amount currently holded by LPs\\n   * @return totalCollateral Total collateral amount currently holded by users + LPs\\n   */\\n  function totalCollateralAmount()\\n    external\\n    view\\n    returns (\\n      uint256 usersCollateral,\\n      uint256 lpsCollateral,\\n      uint256 totalCollateral\\n    );\\n\\n  /**\\n   * @notice Returns the max capacity in synth assets of all the LPs\\n   * @return maxCapacity Total max capacity of the pool\\n   */\\n  function maxTokensCapacity() external view returns (uint256 maxCapacity);\\n\\n  /**\\n   * @notice Returns the LP parametrs info\\n   * @notice Mint, redeem and intreest shares are round down (division dust not included)\\n   * @param _lp Address of the LP\\n   * @return info Info of the input LP (see LPInfo struct)\\n   */\\n  function positionLPInfo(address _lp)\\n    external\\n    view\\n    returns (LPInfo memory info);\\n\\n  /**\\n   * @notice Returns the lending protocol info\\n   * @return lendingId Name of the lending module\\n   * @return bearingToken Address of the bearing token held by the pool for interest accrual\\n   */\\n  function lendingProtocolInfo()\\n    external\\n    view\\n    returns (string memory lendingId, address bearingToken);\\n\\n  /**\\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\\n   * @notice This function is only trading-informative, it doesn't check edge case conditions like lending manager dust and reverting due to dust splitting\\n   * @param _collateralAmount Input collateral amount to be exchanged\\n   * @return synthTokensReceived Synthetic tokens will be minted\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getMintTradeInfo(uint256 _collateralAmount)\\n    external\\n    view\\n    returns (uint256 synthTokensReceived, uint256 feePaid);\\n\\n  /**\\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check edge case conditions like lending manager dust\\n   * @param  _syntTokensAmount Amount of synthetic tokens to be exchanged\\n   * @return collateralAmountReceived Collateral amount will be received by the user\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getRedeemTradeInfo(uint256 _syntTokensAmount)\\n    external\\n    view\\n    returns (uint256 collateralAmountReceived, uint256 feePaid);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/common/interfaces/ILendingSwitch.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Pool interface for making lending manager interacting with the pool\\n */\\ninterface ISynthereumLendingSwitch {\\n  /**\\n  * @notice Set new lending protocol for this pool\\n  * @notice This can be called only by the maintainer\\n  * @param _lendingId Name of the new lending module\\n  * @param _bearingToken Token of the lending mosule to be used for intersts accrual\\n            (used only if the lending manager doesn't automatically find the one associated to the collateral fo this pool)\\n  */\\n  function switchLendingModule(\\n    string calldata _lendingId,\\n    address _bearingToken\\n  ) external;\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/common/interfaces/ILendingTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Pool interface for making lending manager interacting with the pool\\n */\\ninterface ISynthereumLendingTransfer {\\n  /**\\n   * @notice Transfer a bearing amount to the lending manager\\n   * @notice Only the lending manager can call the function\\n   * @param _bearingAmount Amount of bearing token to transfer\\n   * @return bearingAmountOut Real bearing amount transferred to the lending manager\\n   */\\n  function transferToLendingManager(uint256 _bearingAmount)\\n    external\\n    returns (uint256 bearingAmountOut);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v6/interfaces/IMultiLpLiquidityPoolEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\ninterface ISynthereumMultiLpLiquidityPoolEvents {\\n  struct MintValues {\\n    // collateral sent to the the pool by the user\\n    uint256 totalCollateral;\\n    // numTokens * price\\n    uint256 exchangeAmount;\\n    // Fee to be paid according to the fee percentage\\n    uint256 feeAmount;\\n    // Number of synthetic tokens will be received ((totalCollateral - feeAmount - lending fee/bonus) / price)\\n    uint256 numTokens;\\n  }\\n\\n  struct RedeemValues {\\n    // Amount of synthetic asset sent by the user\\n    uint256 numTokens;\\n    // numTokens * price\\n    uint256 exchangeAmount;\\n    // Fee to be paid according to the fee percentage\\n    uint256 feeAmount;\\n    // Net collateral amount will be received (totCollateral - feeAmount -lending fee/bonus )\\n    uint256 collateralAmount;\\n  }\\n\\n  /**\\n   * @notice Emitted when a LP is registered in the pool by the maintainer\\n   * @param lp Address of the LP to be registered\\n   */\\n  event RegisteredLp(address indexed lp);\\n\\n  /**\\n   * @notice Emitted when a LP is activated in the pool by himself\\n   * @param lp Address of the LP to be activated\\n   */\\n  event ActivatedLP(address indexed lp);\\n\\n  /**\\n   * @notice Emitted when a LP set his overCollateralization\\n   * @param lp Address of the LP to set overCollateralization\\n   * @param overCollateralization OverCollateralization percentage set\\n   */\\n  event SetOvercollateralization(\\n    address indexed lp,\\n    uint256 overCollateralization\\n  );\\n\\n  /**\\n   * @notice Emitted when a LP deposits collateral\\n   * @param lp Address of the LP depositing\\n   * @param collateralSent Collateral sent to the the pool by the LP\\n   * @param collateralDeposited Net collateral amount added to the LP position\\n   */\\n  event DepositedLiquidity(\\n    address indexed lp,\\n    uint256 collateralSent,\\n    uint256 collateralDeposited\\n  );\\n\\n  /**\\n   * @notice Emitted when a LP withdraws collateral\\n   * @param lp Address of the LP withdrawing\\n   * @param collateralWithdrawn Collateral amount removed from the LP position\\n   * @param collateralReceived Collateral received from the pool by the LP\\n   */\\n  event WithdrawnLiquidity(\\n    address indexed lp,\\n    uint256 collateralWithdrawn,\\n    uint256 collateralReceived\\n  );\\n\\n  /**\\n   * @notice Emitted when a user mint the synthetic asset\\n   * @param user Address of the user minting\\n   * @param mintvalues Include netCollateralAmount, feeAmount and numTokens\\n   * @param recipient Address receiving minted tokens\\n   */\\n  event Minted(address indexed user, MintValues mintvalues, address recipient);\\n\\n  /**\\n   * @notice Emitted when a user redeem the synthetic asset\\n   * @param user Address of the user redeeming\\n   * @param redeemvalues Include exchangeAmount, feeAmount and collateralAmount\\n   * @param recipient Address receiving collateral unlocked\\n   */\\n  event Redeemed(\\n    address indexed user,\\n    RedeemValues redeemvalues,\\n    address recipient\\n  );\\n\\n  /**\\n   * @notice Emitted when a user liquidate an LP\\n   * @param user Address of the user liquidating\\n   * @param lp Address of the LP to liquidate\\n   * @param synthTokensInLiquidation Amount of synthetic asset in liquidation\\n   * @param collateralAmount Value of synthetic tokens in liquidation expressed in collateral (synthTokensInLiquidation * price)\\n   * @param bonusAmount Collateral amount as reward for the liquidator\\n   * @param collateralReceived Amount of collateral received by liquidator (collateralAmount + liquidation bonus - lending fee/bonus)\\n   */\\n  event Liquidated(\\n    address indexed user,\\n    address indexed lp,\\n    uint256 synthTokensInLiquidation,\\n    uint256 collateralAmount,\\n    uint256 bonusAmount,\\n    uint256 collateralReceived\\n  );\\n\\n  /**\\n   * @notice Emitted when new fee percentage is set in the pool by the maintainer\\n   * @param newFee New fee percentage\\n   */\\n  event SetFeePercentage(uint256 newFee);\\n\\n  /**\\n   * @notice Emitted when liquidation reward percentage is set in the pool by the maintainer\\n   * @param newLiquidationReward New liquidation reward percentage\\n   */\\n  event SetLiquidationReward(uint256 newLiquidationReward);\\n\\n  /**\\n   * @notice Emitted when lending module is initialized or set\\n   * @param lendingModuleId Name of the lending module\\n   */\\n  event NewLendingModule(string lendingModuleId);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/interfaces/IFinder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Provides addresses of the contracts implementing certain interfaces.\\n */\\ninterface ISynthereumFinder {\\n  /**\\n   * @notice Updates the address of the contract that implements `interfaceName`.\\n   * @param interfaceName bytes32 encoding of the interface name that is either changed or registered.\\n   * @param implementationAddress address of the deployed contract that implements the interface.\\n   */\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external;\\n\\n  /**\\n   * @notice Gets the address of the contract that implements the given `interfaceName`.\\n   * @param interfaceName queried interface.\\n   * @return implementationAddress Address of the deployed contract that implements the interface.\\n   */\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    returns (address);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\n/**\\n * @title Stores common interface names used throughout Synthereum.\\n */\\nlibrary SynthereumInterfaces {\\n  bytes32 public constant Deployer = 'Deployer';\\n  bytes32 public constant FactoryVersioning = 'FactoryVersioning';\\n  bytes32 public constant TokenFactory = 'TokenFactory';\\n  bytes32 public constant PoolRegistry = 'PoolRegistry';\\n  bytes32 public constant SelfMintingRegistry = 'SelfMintingRegistry';\\n  bytes32 public constant FixedRateRegistry = 'FixedRateRegistry';\\n  bytes32 public constant PriceFeed = 'PriceFeed';\\n  bytes32 public constant Manager = 'Manager';\\n  bytes32 public constant CreditLineController = 'CreditLineController';\\n  bytes32 public constant CollateralWhitelist = 'CollateralWhitelist';\\n  bytes32 public constant IdentifierWhitelist = 'IdentifierWhitelist';\\n  bytes32 public constant TrustedForwarder = 'TrustedForwarder';\\n  bytes32 public constant MoneyMarketManager = 'MoneyMarketManager';\\n  bytes32 public constant JarvisBrrrrr = 'JarvisBrrrrr';\\n  bytes32 public constant LendingManager = 'LendingManager';\\n  bytes32 public constant LendingStorageManager = 'LendingStorageManager';\\n  bytes32 public constant CommissionReceiver = 'CommissionReceiver';\\n  bytes32 public constant BuybackProgramReceiver = 'BuybackProgramReceiver';\\n  bytes32 public constant JarvisToken = 'JarvisToken';\\n}\\n\\nlibrary FactoryInterfaces {\\n  bytes32 public constant PoolFactory = 'PoolFactory';\\n  bytes32 public constant SelfMintingFactory = 'SelfMintingFactory';\\n  bytes32 public constant FixedRateFactory = 'FixedRateFactory';\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/base/utils/PreciseUnitMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\n/**\\n * @title PreciseUnitMath\\n * @author Synthereum Protocol\\n *\\n * Arithmetic for fixed-point numbers with 18 decimals of precision.\\n *\\n */\\nlibrary PreciseUnitMath {\\n  // The number One in precise units.\\n  uint256 internal constant PRECISE_UNIT = 10**18;\\n\\n  // Max unsigned integer value\\n  uint256 internal constant MAX_UINT_256 = type(uint256).max;\\n\\n  /**\\n   * @dev Getter function since constants can't be read directly from libraries.\\n   */\\n  function preciseUnit() internal pure returns (uint256) {\\n    return PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @dev Getter function since constants can't be read directly from libraries.\\n   */\\n  function maxUint256() internal pure returns (uint256) {\\n    return MAX_UINT_256;\\n  }\\n\\n  /**\\n   * @dev Multiplies value a by value b (result is rounded down). It's assumed that the value b is the significand\\n   * of a number with 18 decimals precision.\\n   */\\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return (a * b) / PRECISE_UNIT;\\n  }\\n\\n  /**\\n   * @dev Multiplies value a by value b (result is rounded up). It's assumed that the value b is the significand\\n   * of a number with 18 decimals precision.\\n   */\\n  function mulCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n    if (a == 0 || b == 0) {\\n      return 0;\\n    }\\n    return (((a * b) - 1) / PRECISE_UNIT) + 1;\\n  }\\n\\n  /**\\n   * @dev Divides value a by value b (result is rounded down).\\n   */\\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return (a * PRECISE_UNIT) / b;\\n  }\\n\\n  /**\\n   * @dev Divides value a by value b (result is rounded up or away from 0).\\n   */\\n  function divCeil(uint256 a, uint256 b) internal pure returns (uint256) {\\n    require(b != 0, 'Cant divide by 0');\\n\\n    return a > 0 ? (((a * PRECISE_UNIT) - 1) / b) + 1 : 0;\\n  }\\n\\n  /**\\n   * @dev Performs the power on a specified value, reverts on overflow.\\n   */\\n  function safePower(uint256 a, uint256 pow) internal pure returns (uint256) {\\n    require(a > 0, 'Value must be positive');\\n\\n    uint256 result = 1;\\n    for (uint256 i = 0; i < pow; i++) {\\n      uint256 previousResult = result;\\n\\n      result = previousResult * a;\\n    }\\n\\n    return result;\\n  }\\n\\n  /**\\n   * @dev The minimum of `a` and `b`.\\n   */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev The maximum of `a` and `b`.\\n   */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v6/MultiLpLiquidityPoolMainLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumPriceFeed\\n} from '../../oracle/common/interfaces/IPriceFeed.sol';\\nimport {\\n  ILendingManager\\n} from '../../lending-module/interfaces/ILendingManager.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPool\\n} from './interfaces/IMultiLpLiquidityPool.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPoolEvents\\n} from './interfaces/IMultiLpLiquidityPoolEvents.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {PreciseUnitMath} from '../../base/utils/PreciseUnitMath.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport {ExplicitERC20} from '../../base/utils/ExplicitERC20.sol';\\nimport {SynthereumMultiLpLiquidityPoolLib} from './MultiLpLiquidityPoolLib.sol';\\n\\n/**\\n * @title Multi LP Synthereum pool lib with main functions\\n */\\n\\nlibrary SynthereumMultiLpLiquidityPoolMainLib {\\n  using PreciseUnitMath for uint256;\\n  using ExplicitERC20 for IERC20;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  struct PositionLPInfoArgs {\\n    uint256 price;\\n    uint256 poolInterest;\\n    uint256 collateralDeposited;\\n    uint256 totalSynthTokens;\\n    uint256 overCollateralLimit;\\n    uint256[] capacityShares;\\n    uint256 totalCapacity;\\n    uint256 tokensValue;\\n    uint256 maxCapacity;\\n    uint8 decimals;\\n    uint256 utilization;\\n    uint256 totalUtilization;\\n  }\\n\\n  // See IMultiLpLiquidityPoolEvents for events description\\n  event RegisteredLp(address indexed lp);\\n\\n  event ActivatedLP(address indexed lp);\\n\\n  event SetOvercollateralization(\\n    address indexed lp,\\n    uint256 overCollateralization\\n  );\\n\\n  event DepositedLiquidity(\\n    address indexed lp,\\n    uint256 collateralSent,\\n    uint256 collateralDeposited\\n  );\\n\\n  event WithdrawnLiquidity(\\n    address indexed lp,\\n    uint256 collateralWithdrawn,\\n    uint256 collateralReceived\\n  );\\n\\n  event Minted(\\n    address indexed user,\\n    ISynthereumMultiLpLiquidityPoolEvents.MintValues mintvalues,\\n    address recipient\\n  );\\n\\n  event Redeemed(\\n    address indexed user,\\n    ISynthereumMultiLpLiquidityPoolEvents.RedeemValues redeemvalues,\\n    address recipient\\n  );\\n\\n  event Liquidated(\\n    address indexed user,\\n    address indexed lp,\\n    uint256 synthTokensInLiquidation,\\n    uint256 collateralAmount,\\n    uint256 bonusAmount,\\n    uint256 collateralReceived\\n  );\\n\\n  /**\\n   * @notice Initialize pool\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _params Params used for initialization (see InitializationParams struct)\\n   */\\n  function initialize(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    ISynthereumMultiLpLiquidityPool.InitializationParams calldata _params\\n  ) external {\\n    require(\\n      _params.overCollateralRequirement > 0,\\n      'Overcollateral requirement must be bigger than 0%'\\n    );\\n\\n    uint8 collTokenDecimals = _params.collateralToken.decimals();\\n    require(collTokenDecimals <= 18, 'Collateral has more than 18 decimals');\\n\\n    require(\\n      _params.syntheticToken.decimals() == 18,\\n      'Synthetic token has more or less than 18 decimals'\\n    );\\n\\n    ISynthereumPriceFeed priceFeed =\\n      ISynthereumPriceFeed(\\n        _params.finder.getImplementationAddress(SynthereumInterfaces.PriceFeed)\\n      );\\n    require(\\n      priceFeed.isPriceSupported(_params.priceIdentifier),\\n      'Price identifier not supported'\\n    );\\n\\n    _storageParams.poolVersion = _params.version;\\n    _storageParams.collateralAsset = _params.collateralToken;\\n    _storageParams.collateralDecimals = collTokenDecimals;\\n    _storageParams.syntheticAsset = _params.syntheticToken;\\n    _storageParams.priceIdentifier = _params.priceIdentifier;\\n    _storageParams.overCollateralRequirement = _params\\n      .overCollateralRequirement;\\n\\n    SynthereumMultiLpLiquidityPoolLib._setLiquidationReward(\\n      _storageParams,\\n      _params.liquidationReward\\n    );\\n    SynthereumMultiLpLiquidityPoolLib._setFee(_storageParams, _params.fee);\\n    SynthereumMultiLpLiquidityPoolLib._setLendingModule(\\n      _storageParams,\\n      _params.lendingModuleId\\n    );\\n  }\\n\\n  /**\\n   * @notice Register a liquidity provider to the LP's whitelist\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _lp Address of the LP\\n   */\\n  function registerLP(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    address _lp\\n  ) external {\\n    require(_storageParams.registeredLPs.add(_lp), 'LP already registered');\\n    emit RegisteredLp(_lp);\\n  }\\n\\n  /**\\n   * @notice Add the Lp to the active list of the LPs and initialize collateral and overcollateralization\\n   * @notice Only a registered and inactive LP can call this function to add himself\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _collateralAmount Collateral amount to deposit by the LP\\n   * @param _overCollateralization Overcollateralization to set by the LP\\n   * @param _finder Synthereum finder\\n   * @param _msgSender Transaction sender\\n   * @return collateralDeposited Net collateral deposited in the LP position\\n   */\\n  function activateLP(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _collateralAmount,\\n    uint128 _overCollateralization,\\n    ISynthereumFinder _finder,\\n    address _msgSender\\n  ) external returns (uint256 collateralDeposited) {\\n    require(\\n      SynthereumMultiLpLiquidityPoolLib._isRegisteredLP(\\n        _storageParams,\\n        _msgSender\\n      ),\\n      'Sender must be a registered LP'\\n    );\\n    require(_collateralAmount > 0, 'No collateral deposited');\\n    require(\\n      _overCollateralization > _storageParams.overCollateralRequirement,\\n      'Overcollateralization must be bigger than overcollateral requirement'\\n    );\\n\\n    ILendingManager.ReturnValues memory lendingValues =\\n      SynthereumMultiLpLiquidityPoolLib._lendingDeposit(\\n        SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder),\\n        _msgSender,\\n        _storageParams.collateralAsset,\\n        _collateralAmount\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        lendingValues.poolInterest,\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        lendingValues.prevTotalCollateral,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib._updateActualLPCollateral(\\n      _storageParams,\\n      positionsCache\\n    );\\n\\n    collateralDeposited = lendingValues.tokensOut;\\n    _storageParams.lpPositions[_msgSender] = ISynthereumMultiLpLiquidityPool\\n      .LPPosition(collateralDeposited, 0, _overCollateralization);\\n\\n    require(_storageParams.activeLPs.add(_msgSender), 'LP already active');\\n\\n    emit ActivatedLP(_msgSender);\\n    emit DepositedLiquidity(_msgSender, _collateralAmount, collateralDeposited);\\n    emit SetOvercollateralization(_msgSender, _overCollateralization);\\n  }\\n\\n  /**\\n   * @notice Add collateral to an active LP position\\n   * @notice Only an active LP can call this function to add collateral to his position\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _collateralAmount Collateral amount to deposit by the LP\\n   * @param _finder Synthereum finder\\n   * @param _msgSender Transaction sender\\n   * @return collateralDeposited Net collateral deposited in the LP position\\n   * @return newLpCollateralAmount Amount of collateral of the LP after the increase\\n   */\\n  function addLiquidity(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _collateralAmount,\\n    ISynthereumFinder _finder,\\n    address _msgSender\\n  )\\n    external\\n    returns (uint256 collateralDeposited, uint256 newLpCollateralAmount)\\n  {\\n    require(\\n      SynthereumMultiLpLiquidityPoolLib._isActiveLP(_storageParams, _msgSender),\\n      'Sender must be an active LP'\\n    );\\n    require(_collateralAmount > 0, 'No collateral added');\\n\\n    ILendingManager.ReturnValues memory lendingValues =\\n      SynthereumMultiLpLiquidityPoolLib._lendingDeposit(\\n        SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder),\\n        _msgSender,\\n        _storageParams.collateralAsset,\\n        _collateralAmount\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib.TempStorageArgs memory tempStorage =\\n      SynthereumMultiLpLiquidityPoolLib.TempStorageArgs(\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        lendingValues.poolInterest,\\n        tempStorage.price,\\n        tempStorage.totalSyntheticAsset,\\n        lendingValues.prevTotalCollateral,\\n        tempStorage.decimals\\n      );\\n\\n    collateralDeposited = lendingValues.tokensOut;\\n    newLpCollateralAmount = SynthereumMultiLpLiquidityPoolLib\\n      ._updateAndIncreaseActualLPCollateral(\\n      _storageParams,\\n      positionsCache,\\n      _msgSender,\\n      collateralDeposited\\n    );\\n\\n    emit DepositedLiquidity(_msgSender, _collateralAmount, collateralDeposited);\\n  }\\n\\n  /**\\n   * @notice Withdraw collateral from an active LP position\\n   * @notice Only an active LP can call this function to withdraw collateral from his position\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _collateralAmount Collateral amount to withdraw by the LP\\n   * @param _finder Synthereum finder\\n   * @param _msgSender Transaction sender\\n   * @return collateralRemoved Net collateral decreased form the position\\n   * @return collateralReceived Collateral received from the withdrawal\\n   * @return newLpCollateralAmount Amount of collateral of the LP after the decrease\\n   */\\n  function removeLiquidity(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _collateralAmount,\\n    ISynthereumFinder _finder,\\n    address _msgSender\\n  )\\n    external\\n    returns (\\n      uint256 collateralRemoved,\\n      uint256 collateralReceived,\\n      uint256 newLpCollateralAmount\\n    )\\n  {\\n    require(\\n      SynthereumMultiLpLiquidityPoolLib._isActiveLP(_storageParams, _msgSender),\\n      'Sender must be an active LP'\\n    );\\n    require(_collateralAmount > 0, 'No collateral withdrawn');\\n\\n    (ILendingManager.ReturnValues memory lendingValues, ) =\\n      SynthereumMultiLpLiquidityPoolLib._lendingWithdraw(\\n        SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder),\\n        _msgSender,\\n        _collateralAmount\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib.TempStorageArgs memory tempStorage =\\n      SynthereumMultiLpLiquidityPoolLib.TempStorageArgs(\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        lendingValues.poolInterest,\\n        tempStorage.price,\\n        tempStorage.totalSyntheticAsset,\\n        lendingValues.prevTotalCollateral,\\n        tempStorage.decimals\\n      );\\n\\n    collateralRemoved = lendingValues.tokensOut;\\n    collateralReceived = lendingValues.tokensTransferred;\\n    newLpCollateralAmount = SynthereumMultiLpLiquidityPoolLib\\n      ._updateAndDecreaseActualLPCollateral(\\n      _storageParams,\\n      positionsCache,\\n      _msgSender,\\n      collateralRemoved,\\n      tempStorage.price,\\n      tempStorage.decimals\\n    );\\n\\n    emit WithdrawnLiquidity(_msgSender, collateralRemoved, collateralReceived);\\n  }\\n\\n  /**\\n   * @notice Set the overCollateralization by an active LP\\n   * @notice This can be called only by an active LP\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _overCollateralization New overCollateralization\\n   * @param _finder Synthereum finder\\n   * @param _msgSender Transaction sender\\n   */\\n  function setOvercollateralization(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint128 _overCollateralization,\\n    ISynthereumFinder _finder,\\n    address _msgSender\\n  ) external {\\n    require(\\n      SynthereumMultiLpLiquidityPoolLib._isActiveLP(_storageParams, _msgSender),\\n      'Sender must be an active LP'\\n    );\\n\\n    require(\\n      _overCollateralization > _storageParams.overCollateralRequirement,\\n      'Overcollateralization must be bigger than overcollateral requirement'\\n    );\\n\\n    ILendingManager.ReturnValues memory lendingValues =\\n      SynthereumMultiLpLiquidityPoolLib\\n        ._getLendingManager(_finder)\\n        .updateAccumulatedInterest();\\n\\n    SynthereumMultiLpLiquidityPoolLib.TempStorageArgs memory tempStorage =\\n      SynthereumMultiLpLiquidityPoolLib.TempStorageArgs(\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        lendingValues.poolInterest,\\n        tempStorage.price,\\n        tempStorage.totalSyntheticAsset,\\n        lendingValues.prevTotalCollateral,\\n        tempStorage.decimals\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib._updateAndModifyActualLPOverCollateral(\\n      _storageParams,\\n      positionsCache,\\n      _msgSender,\\n      _overCollateralization,\\n      tempStorage.price,\\n      tempStorage.decimals\\n    );\\n\\n    emit SetOvercollateralization(_msgSender, _overCollateralization);\\n  }\\n\\n  /**\\n   * @notice Mint synthetic tokens using fixed amount of collateral\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve collateral transfer for the mint request to succeed\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _mintParams Input parameters for minting (see MintParams struct)\\n   * @param _finder Synthereum finder\\n   * @param _msgSender Transaction sender\\n   * @return Amount of synthetic tokens minted by a user\\n   * @return Amount of collateral paid by the user as fee\\n   */\\n  function mint(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    ISynthereumMultiLpLiquidityPool.MintParams calldata _mintParams,\\n    ISynthereumFinder _finder,\\n    address _msgSender\\n  ) external returns (uint256, uint256) {\\n    require(_mintParams.collateralAmount > 0, 'No collateral sent');\\n\\n    ILendingManager.ReturnValues memory lendingValues =\\n      SynthereumMultiLpLiquidityPoolLib._lendingDeposit(\\n        SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder),\\n        _msgSender,\\n        _storageParams.collateralAsset,\\n        _mintParams.collateralAmount\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib.TempStorageArgs memory tempStorage =\\n      SynthereumMultiLpLiquidityPoolLib.TempStorageArgs(\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        lendingValues.poolInterest,\\n        tempStorage.price,\\n        tempStorage.totalSyntheticAsset,\\n        lendingValues.prevTotalCollateral,\\n        tempStorage.decimals\\n      );\\n\\n    ISynthereumMultiLpLiquidityPoolEvents.MintValues memory mintValues =\\n      SynthereumMultiLpLiquidityPoolLib._calculateMint(\\n        _storageParams,\\n        lendingValues.tokensOut,\\n        tempStorage.price,\\n        tempStorage.decimals\\n      );\\n\\n    require(\\n      mintValues.numTokens >= _mintParams.minNumTokens,\\n      'Number of tokens less than minimum limit'\\n    );\\n\\n    SynthereumMultiLpLiquidityPoolLib._calculateMintTokensAndFee(\\n      mintValues,\\n      tempStorage.price,\\n      tempStorage.decimals,\\n      positionsCache\\n    );\\n\\n    SynthereumMultiLpLiquidityPoolLib._updateActualLPPositions(\\n      _storageParams,\\n      positionsCache\\n    );\\n\\n    _storageParams.totalSyntheticAsset =\\n      tempStorage.totalSyntheticAsset +\\n      mintValues.numTokens;\\n\\n    _storageParams.syntheticAsset.mint(\\n      _mintParams.recipient,\\n      mintValues.numTokens\\n    );\\n\\n    mintValues.totalCollateral = _mintParams.collateralAmount;\\n\\n    emit Minted(_msgSender, mintValues, _mintParams.recipient);\\n\\n    return (mintValues.numTokens, mintValues.feeAmount);\\n  }\\n\\n  /**\\n   * @notice Redeem amount of collateral using fixed number of synthetic token\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _redeemParams Input parameters for redeeming (see RedeemParams struct)\\n   * @param _finder Synthereum finder\\n   * @param _msgSender Transaction sender\\n   * @return Amount of collateral redeemed by user\\n   * @return Amount of collateral paid by user as fee\\n   */\\n  function redeem(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    ISynthereumMultiLpLiquidityPool.RedeemParams calldata _redeemParams,\\n    ISynthereumFinder _finder,\\n    address _msgSender\\n  ) external returns (uint256, uint256) {\\n    require(_redeemParams.numTokens > 0, 'No tokens sent');\\n\\n    SynthereumMultiLpLiquidityPoolLib.TempStorageArgs memory tempStorage =\\n      SynthereumMultiLpLiquidityPoolLib.TempStorageArgs(\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    ISynthereumMultiLpLiquidityPoolEvents.RedeemValues memory redeemValues =\\n      SynthereumMultiLpLiquidityPoolLib._calculateRedeem(\\n        _storageParams,\\n        _redeemParams.numTokens,\\n        tempStorage.price,\\n        tempStorage.decimals\\n      );\\n\\n    (\\n      ILendingManager.ReturnValues memory lendingValues,\\n      SynthereumMultiLpLiquidityPoolLib.WithdrawDust memory withdrawDust\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._lendingWithdraw(\\n        SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder),\\n        _redeemParams.recipient,\\n        redeemValues.collateralAmount\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        lendingValues.poolInterest,\\n        tempStorage.price,\\n        tempStorage.totalSyntheticAsset,\\n        lendingValues.prevTotalCollateral,\\n        tempStorage.decimals\\n      );\\n\\n    require(\\n      lendingValues.tokensTransferred >= _redeemParams.minCollateral,\\n      'Collateral amount less than minimum limit'\\n    );\\n\\n    SynthereumMultiLpLiquidityPoolLib._calculateRedeemTokensAndFee(\\n      tempStorage.totalSyntheticAsset,\\n      _redeemParams.numTokens,\\n      redeemValues.feeAmount,\\n      withdrawDust,\\n      positionsCache\\n    );\\n\\n    SynthereumMultiLpLiquidityPoolLib._updateActualLPPositions(\\n      _storageParams,\\n      positionsCache\\n    );\\n\\n    _storageParams.totalSyntheticAsset =\\n      tempStorage.totalSyntheticAsset -\\n      _redeemParams.numTokens;\\n\\n    SynthereumMultiLpLiquidityPoolLib._burnSyntheticTokens(\\n      _storageParams.syntheticAsset,\\n      _redeemParams.numTokens,\\n      _msgSender\\n    );\\n\\n    redeemValues.collateralAmount = lendingValues.tokensTransferred;\\n\\n    emit Redeemed(_msgSender, redeemValues, _redeemParams.recipient);\\n\\n    return (redeemValues.collateralAmount, redeemValues.feeAmount);\\n  }\\n\\n  /**\\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\\n   * @notice Revert if position is not undercollateralized\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _lp LP that the the user wants to liquidate\\n   * @param _numSynthTokens Number of synthetic tokens that user wants to liquidate\\n   * @param _finder Synthereum finder\\n   * @param _liquidator Liquidator of the LP position\\n   * @return Amount of collateral received (Amount of collateral + bonus)\\n   */\\n  function liquidate(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    address _lp,\\n    uint256 _numSynthTokens,\\n    ISynthereumFinder _finder,\\n    address _liquidator\\n  ) external returns (uint256) {\\n\\n      SynthereumMultiLpLiquidityPoolLib.LiquidationUpdateArgs\\n        memory liquidationUpdateArgs\\n    ;\\n    liquidationUpdateArgs.liquidator = _liquidator;\\n\\n    require(\\n      SynthereumMultiLpLiquidityPoolLib._isActiveLP(_storageParams, _lp),\\n      'LP is not active'\\n    );\\n\\n    liquidationUpdateArgs.tempStorageArgs = SynthereumMultiLpLiquidityPoolLib\\n      .TempStorageArgs(\\n      SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n        _finder,\\n        _storageParams.priceIdentifier\\n      ),\\n      _storageParams.totalSyntheticAsset,\\n      _storageParams.collateralDecimals\\n    );\\n\\n    liquidationUpdateArgs.lendingManager = SynthereumMultiLpLiquidityPoolLib\\n      ._getLendingManager(_finder);\\n    liquidationUpdateArgs.overCollateralRequirement = _storageParams\\n      .overCollateralRequirement;\\n\\n    (uint256 poolInterest, uint256 collateralDeposited) =\\n      SynthereumMultiLpLiquidityPoolLib._getLendingInterest(\\n        liquidationUpdateArgs.lendingManager\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        poolInterest,\\n        liquidationUpdateArgs.tempStorageArgs.price,\\n        liquidationUpdateArgs.tempStorageArgs.totalSyntheticAsset,\\n        collateralDeposited,\\n        liquidationUpdateArgs.tempStorageArgs.decimals\\n      );\\n\\n    (\\n      uint256 tokensInLiquidation,\\n      uint256 collateralAmount,\\n      uint256 bonusAmount,\\n      uint256 collateralReceived\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._updateAndLiquidate(\\n        _storageParams,\\n        positionsCache,\\n        _lp,\\n        _numSynthTokens,\\n        liquidationUpdateArgs\\n      );\\n\\n    _storageParams.totalSyntheticAsset =\\n      liquidationUpdateArgs.tempStorageArgs.totalSyntheticAsset -\\n      tokensInLiquidation;\\n\\n    SynthereumMultiLpLiquidityPoolLib._burnSyntheticTokens(\\n      _storageParams.syntheticAsset,\\n      tokensInLiquidation,\\n      _liquidator\\n    );\\n\\n    emit Liquidated(\\n      _liquidator,\\n      _lp,\\n      tokensInLiquidation,\\n      collateralAmount,\\n      bonusAmount,\\n      collateralReceived\\n    );\\n\\n    return collateralReceived;\\n  }\\n\\n  /**\\n   * @notice Update interests and positions ov every LP\\n   * @notice Everyone can call this function\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _finder Synthereum finder\\n   */\\n  function updatePositions(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    ISynthereumFinder _finder\\n  ) external {\\n    ILendingManager.ReturnValues memory lendingValues =\\n      SynthereumMultiLpLiquidityPoolLib\\n        ._getLendingManager(_finder)\\n        .updateAccumulatedInterest();\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        lendingValues.poolInterest,\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        lendingValues.prevTotalCollateral,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib._updateActualLPPositions(\\n      _storageParams,\\n      positionsCache\\n    );\\n  }\\n\\n  /**\\n   * @notice Transfer a bearing amount to the lending manager\\n   * @notice Only the lending manager can call the function\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _bearingAmount Amount of bearing token to transfer\\n   * @param _finder Synthereum finder\\n   * @return bearingAmountOut Real bearing amount transferred to the lending manager\\n   */\\n  function transferToLendingManager(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _bearingAmount,\\n    ISynthereumFinder _finder\\n  ) external returns (uint256 bearingAmountOut) {\\n    ILendingManager lendingManager =\\n      SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder);\\n    require(\\n      msg.sender == address(lendingManager),\\n      'Sender must be the lending manager'\\n    );\\n\\n    (uint256 poolInterest, uint256 totalActualCollateral) =\\n      SynthereumMultiLpLiquidityPoolLib._getLendingInterest(lendingManager);\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        poolInterest,\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        totalActualCollateral,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib._updateActualLPPositions(\\n      _storageParams,\\n      positionsCache\\n    );\\n\\n    (uint256 poolBearingValue, address bearingToken) =\\n      lendingManager.collateralToInterestToken(\\n        address(this),\\n        totalActualCollateral + poolInterest\\n      );\\n\\n    (uint256 amountOut, uint256 remainingBearingValue) =\\n      IERC20(bearingToken).explicitSafeTransfer(msg.sender, _bearingAmount);\\n\\n    require(remainingBearingValue >= poolBearingValue, 'Unfunded pool');\\n\\n    bearingAmountOut = amountOut;\\n  }\\n\\n  /**\\n   * @notice Set new liquidation reward percentage\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _newLiquidationReward New liquidation reward percentage\\n   */\\n  function setLiquidationReward(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint64 _newLiquidationReward\\n  ) external {\\n    SynthereumMultiLpLiquidityPoolLib._setLiquidationReward(\\n      _storageParams,\\n      _newLiquidationReward\\n    );\\n  }\\n\\n  /**\\n   * @notice Set new fee percentage\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _newFee New fee percentage\\n   */\\n  function setFee(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint64 _newFee\\n  ) external {\\n    SynthereumMultiLpLiquidityPoolLib._setFee(_storageParams, _newFee);\\n  }\\n\\n  /**\\n   * @notice Get all the registered LPs of this pool\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @return The list of addresses of all the registered LPs in the pool.\\n   */\\n  function getRegisteredLPs(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams\\n  ) external view returns (address[] memory) {\\n    uint256 numberOfLPs = _storageParams.registeredLPs.length();\\n    address[] memory lpList = new address[](numberOfLPs);\\n    for (uint256 j = 0; j < numberOfLPs; j++) {\\n      lpList[j] = _storageParams.registeredLPs.at(j);\\n    }\\n    return lpList;\\n  }\\n\\n  /**\\n   * @notice Get all the active LPs of this pool\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @return The list of addresses of all the active LPs in the pool.\\n   */\\n  function getActiveLPs(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams\\n  ) external view returns (address[] memory) {\\n    uint256 numberOfLPs = _storageParams.activeLPs.length();\\n    address[] memory lpList = new address[](numberOfLPs);\\n    for (uint256 j = 0; j < numberOfLPs; j++) {\\n      lpList[j] = _storageParams.activeLPs.at(j);\\n    }\\n    return lpList;\\n  }\\n\\n  /**\\n   * @notice Returns the total amounts of collateral\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _finder Synthereum finder\\n   * @return usersCollateral Total collateral amount currently holded by users\\n   * @return lpsCollateral Total collateral amount currently holded by LPs\\n   * @return totalCollateral Total collateral amount currently holded by users + LPs\\n   */\\n  function totalCollateralAmount(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    ISynthereumFinder _finder\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 usersCollateral,\\n      uint256 lpsCollateral,\\n      uint256 totalCollateral\\n    )\\n  {\\n    usersCollateral = SynthereumMultiLpLiquidityPoolLib\\n      ._calculateCollateralAmount(\\n      _storageParams.totalSyntheticAsset,\\n      SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n        _finder,\\n        _storageParams.priceIdentifier\\n      ),\\n      _storageParams.collateralDecimals\\n    );\\n\\n    (uint256 poolInterest, uint256 totalActualCollateral) =\\n      SynthereumMultiLpLiquidityPoolLib._getLendingInterest(\\n        SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder)\\n      );\\n\\n    totalCollateral = totalActualCollateral + poolInterest;\\n\\n    lpsCollateral = totalCollateral - usersCollateral;\\n  }\\n\\n  /**\\n   * @notice Returns the max capacity in synth assets of all the LPs\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _finder Synthereum finder\\n   * @return maxCapacity Total max capacity of the pool\\n   */\\n  function maxTokensCapacity(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    ISynthereumFinder _finder\\n  ) external view returns (uint256 maxCapacity) {\\n    uint256 price =\\n      SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n        _finder,\\n        _storageParams.priceIdentifier\\n      );\\n\\n    uint8 decimals = _storageParams.collateralDecimals;\\n\\n    maxCapacity = SynthereumMultiLpLiquidityPoolLib._calculateMaxCapacity(\\n      _storageParams,\\n      price,\\n      decimals,\\n      _finder\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the lending protocol info\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _finder Synthereum finder\\n   * @return lendingId Name of the lending module\\n   * @return bearingToken Address of the bearing token held by the pool for interest accrual\\n   */\\n  function lendingProtocolInfo(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    ISynthereumFinder _finder\\n  ) external view returns (string memory lendingId, address bearingToken) {\\n    lendingId = _storageParams.lendingModuleId;\\n    bearingToken = SynthereumMultiLpLiquidityPoolLib\\n      ._getLendingStorageManager(_finder)\\n      .getInterestBearingToken(address(this));\\n  }\\n\\n  /**\\n   * @notice Returns the LP parametrs info\\n   * @notice Mint, redeem and intreest shares are round down (division dust not included)\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _lp Address of the LP\\n   * @param _finder Synthereum finder\\n   * @return info Info of the input LP (see LPInfo struct)\\n   */\\n  function positionLPInfo(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    address _lp,\\n    ISynthereumFinder _finder\\n  ) external view returns (ISynthereumMultiLpLiquidityPool.LPInfo memory info) {\\n    require(\\n      SynthereumMultiLpLiquidityPoolLib._isActiveLP(_storageParams, _lp),\\n      'LP not active'\\n    );\\n\\n    PositionLPInfoArgs memory positionLPInfoArgs;\\n    positionLPInfoArgs.price = SynthereumMultiLpLiquidityPoolLib\\n      ._getPriceFeedRate(_finder, _storageParams.priceIdentifier);\\n\\n    (\\n      positionLPInfoArgs.poolInterest,\\n      positionLPInfoArgs.collateralDeposited\\n    ) = SynthereumMultiLpLiquidityPoolLib._getLendingInterest(\\n      SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder)\\n    );\\n\\n    positionLPInfoArgs.totalSynthTokens = _storageParams.totalSyntheticAsset;\\n\\n    positionLPInfoArgs.decimals = _storageParams.collateralDecimals;\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        positionLPInfoArgs.poolInterest,\\n        positionLPInfoArgs.price,\\n        positionLPInfoArgs.totalSynthTokens,\\n        positionLPInfoArgs.collateralDeposited,\\n        positionLPInfoArgs.decimals\\n      );\\n\\n    positionLPInfoArgs.overCollateralLimit = _storageParams\\n      .overCollateralRequirement;\\n\\n    positionLPInfoArgs.capacityShares = new uint256[](positionsCache.length);\\n    positionLPInfoArgs.totalCapacity = SynthereumMultiLpLiquidityPoolLib\\n      ._calculateMintShares(\\n      positionLPInfoArgs.price,\\n      positionLPInfoArgs.decimals,\\n      positionsCache,\\n      positionLPInfoArgs.capacityShares\\n    );\\n\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    for (uint256 j = 0; j < positionsCache.length; j++) {\\n      lpPosition = positionsCache[j].lpPosition;\\n      positionLPInfoArgs.tokensValue = SynthereumMultiLpLiquidityPoolLib\\n        ._calculateCollateralAmount(\\n        lpPosition.tokensCollateralized,\\n        positionLPInfoArgs.price,\\n        positionLPInfoArgs.decimals\\n      );\\n      if (positionsCache[j].lp == _lp) {\\n        info.actualCollateralAmount = lpPosition.actualCollateralAmount;\\n        info.tokensCollateralized = lpPosition.tokensCollateralized;\\n        info.overCollateralization = lpPosition.overCollateralization;\\n        info.capacity = positionLPInfoArgs.capacityShares[j];\\n        info.utilization = lpPosition.actualCollateralAmount != 0\\n          ? PreciseUnitMath.min(\\n            (\\n              positionLPInfoArgs.tokensValue.mul(\\n                lpPosition.overCollateralization\\n              )\\n            )\\n              .div(lpPosition.actualCollateralAmount),\\n            PreciseUnitMath.PRECISE_UNIT\\n          )\\n          : lpPosition.tokensCollateralized > 0\\n          ? PreciseUnitMath.PRECISE_UNIT\\n          : 0;\\n        positionLPInfoArgs.totalUtilization += info.utilization;\\n        (\\n          info.isOvercollateralized,\\n          positionLPInfoArgs.maxCapacity\\n        ) = SynthereumMultiLpLiquidityPoolLib._isOvercollateralizedLP(\\n          lpPosition.actualCollateralAmount,\\n          positionLPInfoArgs.overCollateralLimit,\\n          lpPosition.tokensCollateralized,\\n          positionLPInfoArgs.price,\\n          positionLPInfoArgs.decimals\\n        );\\n        info.coverage = lpPosition.tokensCollateralized != 0\\n          ? PreciseUnitMath.PRECISE_UNIT +\\n            (\\n              positionLPInfoArgs.overCollateralLimit.mul(\\n                positionLPInfoArgs.maxCapacity.div(\\n                  lpPosition.tokensCollateralized\\n                )\\n              )\\n            )\\n          : lpPosition.actualCollateralAmount == 0\\n          ? 0\\n          : PreciseUnitMath.maxUint256();\\n        info.mintShares = positionLPInfoArgs.totalCapacity != 0\\n          ? positionLPInfoArgs.capacityShares[j].div(\\n            positionLPInfoArgs.totalCapacity\\n          )\\n          : 0;\\n        info.redeemShares = positionLPInfoArgs.totalSynthTokens != 0\\n          ? lpPosition.tokensCollateralized.div(\\n            positionLPInfoArgs.totalSynthTokens\\n          )\\n          : 0;\\n      } else {\\n        positionLPInfoArgs.utilization = lpPosition.actualCollateralAmount != 0\\n          ? PreciseUnitMath.min(\\n            (\\n              positionLPInfoArgs.tokensValue.mul(\\n                lpPosition.overCollateralization\\n              )\\n            )\\n              .div(lpPosition.actualCollateralAmount),\\n            PreciseUnitMath.PRECISE_UNIT\\n          )\\n          : lpPosition.tokensCollateralized > 0\\n          ? PreciseUnitMath.PRECISE_UNIT\\n          : 0;\\n        positionLPInfoArgs.totalUtilization += positionLPInfoArgs.utilization;\\n      }\\n    }\\n    info.interestShares = (positionLPInfoArgs.totalCapacity > 0 &&\\n      positionLPInfoArgs.totalUtilization > 0)\\n      ? ((info.mintShares +\\n        (info.utilization.div(positionLPInfoArgs.totalUtilization))) / 2)\\n      : positionLPInfoArgs.totalUtilization == 0\\n      ? info.mintShares\\n      : info.utilization.div(positionLPInfoArgs.totalUtilization);\\n    return info;\\n  }\\n\\n  /**\\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\\n   * @notice This function is only trading-informative, it doesn't check edge case conditions like lending manager dust, reverting due to dust splitting and undercaps\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _collateralAmount Input collateral amount to be exchanged\\n   * @param _finder Synthereum finder\\n   * @return synthTokensReceived Synthetic tokens will be minted\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getMintTradeInfo(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _collateralAmount,\\n    ISynthereumFinder _finder\\n  ) external view returns (uint256 synthTokensReceived, uint256 feePaid) {\\n    require(_collateralAmount > 0, 'No input collateral');\\n\\n    uint256 price =\\n      SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n        _finder,\\n        _storageParams.priceIdentifier\\n      );\\n    uint8 decimals = _storageParams.collateralDecimals;\\n\\n    ISynthereumMultiLpLiquidityPoolEvents.MintValues memory mintValues =\\n      SynthereumMultiLpLiquidityPoolLib._calculateMint(\\n        _storageParams,\\n        _collateralAmount,\\n        price,\\n        decimals\\n      );\\n\\n    uint256 maxCapacity =\\n      SynthereumMultiLpLiquidityPoolLib._calculateMaxCapacity(\\n        _storageParams,\\n        price,\\n        decimals,\\n        _finder\\n      );\\n\\n    require(maxCapacity >= mintValues.numTokens, 'No enough liquidity');\\n\\n    return (mintValues.numTokens, mintValues.feeAmount);\\n  }\\n\\n  /**\\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check edge case conditions like lending manager dust and undercaps\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param  _syntTokensAmount Amount of synthetic tokens to be exchanged\\n   * @param _finder Synthereum finder\\n   * @return collateralAmountReceived Collateral amount will be received by the user\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getRedeemTradeInfo(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _syntTokensAmount,\\n    ISynthereumFinder _finder\\n  ) external view returns (uint256 collateralAmountReceived, uint256 feePaid) {\\n    require(_syntTokensAmount > 0, 'No tokens sent');\\n\\n    ISynthereumMultiLpLiquidityPoolEvents.RedeemValues memory redeemValues =\\n      SynthereumMultiLpLiquidityPoolLib._calculateRedeem(\\n        _storageParams,\\n        _syntTokensAmount,\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.collateralDecimals\\n      );\\n\\n    require(\\n      _syntTokensAmount <= _storageParams.totalSyntheticAsset,\\n      'No enough synth tokens'\\n    );\\n\\n    return (redeemValues.collateralAmount, redeemValues.feeAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v6/MultiLpLiquidityPoolMigrationLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  ILendingManager\\n} from '../../lending-module/interfaces/ILendingManager.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPool\\n} from './interfaces/IMultiLpLiquidityPool.sol';\\nimport {\\n  ISynthereumPoolMigrationStorage\\n} from '../common/migration/interfaces/IPoolMigrationStorage.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport {SynthereumMultiLpLiquidityPoolLib} from './MultiLpLiquidityPoolLib.sol';\\nimport {\\n  SafeERC20\\n} from '../../../@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\n/**\\n * @title Multi LP Synthereum pool lib for migration of the storage\\n */\\n\\nlibrary SynthereumMultiLpLiquidityPoolMigrationLib {\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n  using SafeERC20 for IERC20;\\n\\n  struct TempListArgs {\\n    address[] admins;\\n    address[] maintainers;\\n    address[] registeredLps;\\n    address[] activeLps;\\n  }\\n\\n  /**\\n   * @notice Set new lending protocol for this pool\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _lendingId Name of the new lending module\\n   * @param _bearingToken Token of the lending mosule to be used for intersts accrual\\n            (used only if the lending manager doesn't automatically find the one associated to the collateral fo this pool)\\n   * @param _finder Synthereum finder\\n   */\\n  function switchLendingModule(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    string calldata _lendingId,\\n    address _bearingToken,\\n    ISynthereumFinder _finder\\n  ) external {\\n    require(\\n      msg.sender ==\\n        _finder.getImplementationAddress(SynthereumInterfaces.Manager),\\n      'Sender must be the Synthereum manager'\\n    );\\n\\n    ILendingManager.MigrateReturnValues memory migrationValues =\\n      SynthereumMultiLpLiquidityPoolLib._lendingMigration(\\n        SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder),\\n        SynthereumMultiLpLiquidityPoolLib._getLendingStorageManager(_finder),\\n        _lendingId,\\n        _bearingToken\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib.TempStorageArgs memory tempStorage =\\n      SynthereumMultiLpLiquidityPoolLib.TempStorageArgs(\\n        SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n          _finder,\\n          _storageParams.priceIdentifier\\n        ),\\n        _storageParams.totalSyntheticAsset,\\n        _storageParams.collateralDecimals\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      uint256 prevTotalLpsCollateral,\\n      uint256 mostFundedIndex\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        migrationValues.poolInterest,\\n        tempStorage.price,\\n        tempStorage.totalSyntheticAsset,\\n        migrationValues.prevTotalCollateral,\\n        tempStorage.decimals\\n      );\\n\\n    SynthereumMultiLpLiquidityPoolLib._calculateSwitchingOrMigratingCollateral(\\n      prevTotalLpsCollateral,\\n      migrationValues,\\n      _storageParams.overCollateralRequirement,\\n      tempStorage.price,\\n      tempStorage.decimals,\\n      mostFundedIndex,\\n      positionsCache\\n    );\\n\\n    SynthereumMultiLpLiquidityPoolLib._updateActualLPPositions(\\n      _storageParams,\\n      positionsCache\\n    );\\n\\n    SynthereumMultiLpLiquidityPoolLib._setLendingModule(\\n      _storageParams,\\n      _lendingId\\n    );\\n  }\\n\\n  /**\\n   * @notice Reset storage to the initial status\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _registeredLPsList List of every registered LP\\n   * @param _activeLPsList List of every active LP\\n   */\\n  function cleanStorage(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    address[] calldata _registeredLPsList,\\n    address[] calldata _activeLPsList\\n  ) external {\\n    address lp;\\n    for (uint256 j = 0; j < _activeLPsList.length; j++) {\\n      lp = _activeLPsList[j];\\n      _storageParams.activeLPs.remove(lp);\\n      delete _storageParams.lpPositions[lp];\\n    }\\n    for (uint256 j = 0; j < _registeredLPsList.length; j++) {\\n      _storageParams.registeredLPs.remove(_registeredLPsList[j]);\\n    }\\n    delete _storageParams.totalSyntheticAsset;\\n  }\\n\\n  /**\\n   * @notice Set the storage to the new pool during migration\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _oldVersion Version of the migrated pool\\n   * @param _storageBytes Pool storage encoded in bytes\\n   * @param _newVersion Version of the new deployed pool\\n   * @param _extraInputParams Additive input pool params encoded for the new pool, that are not part of the migrationPool\\n   * @return admins List of pool admins\\n   * @return maintainers List of pool maintainers\\n   */\\n  function setStorage(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint8 _oldVersion,\\n    bytes calldata _storageBytes,\\n    uint8 _newVersion,\\n    bytes calldata _extraInputParams\\n  ) external returns (address[] memory admins, address[] memory maintainers) {\\n    _storageParams.poolVersion = _newVersion;\\n\\n    ISynthereumPoolMigrationStorage.MigrationV6 memory migrationStorage =\\n      abi.decode(_storageBytes, (ISynthereumPoolMigrationStorage.MigrationV6));\\n\\n    _storageParams.lendingModuleId = migrationStorage.lendingModuleId;\\n    _storageParams.priceIdentifier = migrationStorage.priceIdentifier;\\n    _storageParams.totalSyntheticAsset = migrationStorage.totalSyntheticAsset;\\n    _storageParams.collateralAsset = migrationStorage.collateralAsset;\\n    _storageParams.fee = migrationStorage.fee;\\n    _storageParams.collateralDecimals = migrationStorage.collateralDecimals;\\n    _storageParams.overCollateralRequirement = migrationStorage\\n      .overCollateralRequirement;\\n    _storageParams.liquidationBonus = migrationStorage.liquidationBonus;\\n    _storageParams.syntheticAsset = migrationStorage.syntheticAsset;\\n\\n    address lp;\\n    for (uint256 j = 0; j < migrationStorage.activeLPsList.length; j++) {\\n      lp = migrationStorage.activeLPsList[j];\\n      _storageParams.activeLPs.add(lp);\\n      _storageParams.lpPositions[lp] = migrationStorage.positions[j];\\n    }\\n\\n    for (uint256 j = 0; j < migrationStorage.registeredLPsList.length; j++) {\\n      _storageParams.registeredLPs.add(migrationStorage.registeredLPsList[j]);\\n    }\\n\\n    admins = migrationStorage.admins;\\n    maintainers = migrationStorage.maintainers;\\n  }\\n\\n  /**\\n   * @notice Update storage after the migration, splitting fee/bonus of the migration between the LPs\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _sourceCollateralAmount Collateral amount from the source pool\\n   * @param _actualCollateralAmount Collateral amount of the new pool\\n   * @param _price Actual price of the pair\\n   */\\n  function updateMigrationStorage(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _sourceCollateralAmount,\\n    uint256 _actualCollateralAmount,\\n    uint256 _price\\n  ) external {\\n    uint256 lpNumbers = _storageParams.activeLPs.length();\\n    if (lpNumbers > 0) {\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache =\\n        new SynthereumMultiLpLiquidityPoolLib.PositionCache[](lpNumbers);\\n      (uint256 totalLpsCollateral, uint256 mostFundedIndex) =\\n        SynthereumMultiLpLiquidityPoolLib._loadPositions(\\n          _storageParams,\\n          positionsCache\\n        );\\n      SynthereumMultiLpLiquidityPoolLib\\n        ._calculateSwitchingOrMigratingCollateral(\\n        totalLpsCollateral,\\n        ILendingManager.MigrateReturnValues(\\n          _sourceCollateralAmount,\\n          0,\\n          _actualCollateralAmount\\n        ),\\n        _storageParams.overCollateralRequirement,\\n        _price,\\n        _storageParams.collateralDecimals,\\n        mostFundedIndex,\\n        positionsCache\\n      );\\n      SynthereumMultiLpLiquidityPoolLib._updateActualLPPositions(\\n        _storageParams,\\n        positionsCache\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Encode storage of the pool in bytes for migration\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _lists Lists of admins, maintainers, registered and active LPs\\n   * @param _finder Synthereum finder\\n   * @return poolVersion Version of the pool\\n   * @return price Actual price of the pair\\n   * @return storageBytes Encoded pool storage in bytes\\n   */\\n  function encodeStorage(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    TempListArgs calldata _lists,\\n    ISynthereumFinder _finder\\n  )\\n    external\\n    view\\n    returns (\\n      uint8 poolVersion,\\n      uint256 price,\\n      bytes memory storageBytes\\n    )\\n  {\\n    poolVersion = _storageParams.poolVersion;\\n    bytes32 priceIdentifier = _storageParams.priceIdentifier;\\n    price = SynthereumMultiLpLiquidityPoolLib._getPriceFeedRate(\\n      _finder,\\n      priceIdentifier\\n    );\\n    uint256 numberOfLps = _lists.activeLps.length;\\n    ISynthereumMultiLpLiquidityPool.LPPosition[] memory positions =\\n      new ISynthereumMultiLpLiquidityPool.LPPosition[](numberOfLps);\\n    for (uint256 j = 0; j < numberOfLps; j++) {\\n      positions[j] = _storageParams.lpPositions[_lists.activeLps[j]];\\n    }\\n    storageBytes = abi.encode(\\n      ISynthereumPoolMigrationStorage.MigrationV6(\\n        _storageParams.lendingModuleId,\\n        priceIdentifier,\\n        _storageParams.totalSyntheticAsset,\\n        _storageParams.collateralAsset,\\n        _storageParams.fee,\\n        _storageParams.collateralDecimals,\\n        _storageParams.overCollateralRequirement,\\n        _storageParams.liquidationBonus,\\n        _storageParams.syntheticAsset,\\n        _lists.registeredLps,\\n        _lists.activeLps,\\n        positions,\\n        _lists.admins,\\n        _lists.maintainers\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @notice Transfer all bearing tokens to another address\\n   * @notice Only the lending manager can call the function\\n   * @param _recipient Address receving bearing amount\\n   * @param _finder Synthereum finder\\n   * @return migrationAmount Total balance of the pool in bearing tokens before migration\\n   */\\n  function migrateTotalFunds(address _recipient, ISynthereumFinder _finder)\\n    external\\n    returns (uint256 migrationAmount)\\n  {\\n    ILendingManager lendingManager =\\n      SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder);\\n    require(\\n      msg.sender == address(lendingManager),\\n      'Sender must be the lending manager'\\n    );\\n\\n    IERC20 bearingToken =\\n      IERC20(\\n        SynthereumMultiLpLiquidityPoolLib\\n          ._getLendingStorageManager(_finder)\\n          .getInterestBearingToken(address(this))\\n      );\\n    migrationAmount = bearingToken.balanceOf(address(this));\\n    bearingToken.safeTransfer(_recipient, migrationAmount);\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/common/migration/PoolMigrationFrom.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {ISynthereumFinder} from '../../../core/interfaces/IFinder.sol';\\nimport {SynthereumPoolMigration} from './PoolMigration.sol';\\n\\n/**\\n * @title Abstract contract inherit by pools for moving storage from one pool to another\\n */\\nabstract contract SynthereumPoolMigrationFrom is SynthereumPoolMigration {\\n  /**\\n   * @notice Migrate storage from this pool resetting and cleaning data\\n   * @notice This can be called only by a pool factory\\n   * @return poolVersion Version of the pool\\n   * @return price Actual price of the pair\\n   * @return storageBytes Pool storage encoded in bytes\\n   */\\n  function migrateStorage()\\n    external\\n    virtual\\n    onlyPoolFactory\\n    returns (\\n      uint8 poolVersion,\\n      uint256 price,\\n      bytes memory storageBytes\\n    )\\n  {\\n    _modifyStorageFrom();\\n    (poolVersion, price, storageBytes) = _encodeStorage();\\n    _cleanStorage();\\n  }\\n\\n  /**\\n   * @notice Transfer all bearing tokens to another address\\n   * @notice Only the lending manager can call the function\\n   * @param _recipient Address receving bearing amount\\n   * @return migrationAmount Total balance of the pool in bearing tokens before migration\\n   */\\n  function migrateTotalFunds(address _recipient)\\n    external\\n    virtual\\n    returns (uint256 migrationAmount);\\n\\n  /**\\n   * @notice Function to implement for modifying storage before the encoding\\n   */\\n  function _modifyStorageFrom() internal virtual;\\n\\n  /**\\n   * @notice Function to implement for cleaning and resetting the storage to the initial state\\n   */\\n  function _cleanStorage() internal virtual;\\n\\n  /**\\n   * @notice Function to implement for encoding storage in bytes\\n   * @return poolVersion Version of the pool\\n   * @return price Actual price of the pair\\n   * @return storageBytes Pool storage encoded in bytes\\n   */\\n  function _encodeStorage()\\n    internal\\n    view\\n    virtual\\n    returns (\\n      uint8 poolVersion,\\n      uint256 price,\\n      bytes memory storageBytes\\n    );\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/common/migration/PoolMigrationTo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {ISynthereumFinder} from '../../../core/interfaces/IFinder.sol';\\nimport {SynthereumPoolMigration} from './PoolMigration.sol';\\n\\n/**\\n * @title Abstract contract inherit by pools for moving storage from one pool to another\\n */\\nabstract contract SynthereumPoolMigrationTo is SynthereumPoolMigration {\\n  /**\\n   * @notice Migrate storage to this new pool and initialize it\\n   * @param _finder Synthereum finder of the pool\\n   * @param _oldVersion Version of the migrated pool\\n   * @param _storageBytes Pool storage encoded in bytes\\n   * @param _newVersion Version of the new deployed pool\\n   * @param _extraInputParams Additive input pool params encoded for the new pool, that are not part of the migrationPool\\n   * @param _sourceCollateralAmount Collateral amount from the source pool\\n   * @param _actualCollateralAmount Collateral amount of the new pool\\n   * @param _price Actual price of the pair\\n   */\\n  function setMigratedStorage(\\n    ISynthereumFinder _finder,\\n    uint8 _oldVersion,\\n    bytes calldata _storageBytes,\\n    uint8 _newVersion,\\n    bytes calldata _extraInputParams,\\n    uint256 _sourceCollateralAmount,\\n    uint256 _actualCollateralAmount,\\n    uint256 _price\\n  ) external virtual {\\n    finder = _finder;\\n    _setMigratedStorage(\\n      _oldVersion,\\n      _storageBytes,\\n      _newVersion,\\n      _extraInputParams,\\n      _sourceCollateralAmount,\\n      _actualCollateralAmount,\\n      _price\\n    );\\n  }\\n\\n  /**\\n   * @notice Migrate storage to this new pool and initialize it\\n   * @notice This can be called only by a pool factory\\n   * @param _oldVersion Version of the migrated pool\\n   * @param _storageBytes Pool storage encoded in bytes\\n   * @param _newVersion Version of the new deployed pool\\n   * @param _extraInputParams Additive input pool params encoded for the new pool, that are not part of the migrationPool\\n   * @param _sourceCollateralAmount Collateral amount from the source pool\\n   * @param _actualCollateralAmount Collateral amount of the new pool\\n   * @param _price Actual price of the pair\\n   */\\n  function _setMigratedStorage(\\n    uint8 _oldVersion,\\n    bytes calldata _storageBytes,\\n    uint8 _newVersion,\\n    bytes calldata _extraInputParams,\\n    uint256 _sourceCollateralAmount,\\n    uint256 _actualCollateralAmount,\\n    uint256 _price\\n  ) internal onlyPoolFactory {\\n    _setStorage(_oldVersion, _storageBytes, _newVersion, _extraInputParams);\\n    _modifyStorageTo(_sourceCollateralAmount, _actualCollateralAmount, _price);\\n  }\\n\\n  /**\\n   * @notice Function to implement for setting the storage to the new pool\\n   * @param _oldVersion Version of the migrated pool\\n   * @param _storageBytes Pool storage encoded in bytes\\n   * @param _newVersion Version of the new deployed pool\\n   * @param _extraInputParams Additive input pool params encoded for the new pool, that are not part of the migrationPool\\n   */\\n  function _setStorage(\\n    uint8 _oldVersion,\\n    bytes calldata _storageBytes,\\n    uint8 _newVersion,\\n    bytes calldata _extraInputParams\\n  ) internal virtual;\\n\\n  /**\\n   * @notice Function to implement for modifying the storage of the new pool after the migration\\n   * @param _sourceCollateralAmount Collateral amount from the source pool\\n   * @param _actualCollateralAmount Collateral amount of the new pool\\n   * @param _price Actual price of the pair\\n   */\\n  function _modifyStorageTo(\\n    uint256 _sourceCollateralAmount,\\n    uint256 _actualCollateralAmount,\\n    uint256 _price\\n  ) internal virtual;\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/common/ERC2771Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.9;\\n\\nimport {Context} from '../../@openzeppelin/contracts/utils/Context.sol';\\n\\n/**\\n * @dev Context variant with ERC2771 support.\\n */\\nabstract contract ERC2771Context is Context {\\n  function isTrustedForwarder(address forwarder)\\n    public\\n    view\\n    virtual\\n    returns (bool);\\n\\n  function _msgSender()\\n    internal\\n    view\\n    virtual\\n    override\\n    returns (address sender)\\n  {\\n    if (isTrustedForwarder(msg.sender)) {\\n      // The assembly code is more direct than the Solidity version using `abi.decode`.\\n      assembly {\\n        sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n      }\\n    } else {\\n      return super._msgSender();\\n    }\\n  }\\n\\n  function _msgData() internal view virtual override returns (bytes calldata) {\\n    if (isTrustedForwarder(msg.sender)) {\\n      return msg.data[0:msg.data.length - 20];\\n    } else {\\n      return super._msgData();\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/common/interfaces/ITypology.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\ninterface ITypology {\\n  /**\\n   * @notice Return typology of the contract\\n   */\\n  function typology() external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/tokens/interfaces/IMintableBurnableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/**\\n * @title ERC20 interface that includes burn mint and roles methods.\\n */\\ninterface IMintableBurnableERC20 is IERC20 {\\n  /**\\n   * @notice Burns a specific amount of the caller's tokens.\\n   * @dev This method should be permissioned to only allow designated parties to burn tokens.\\n   */\\n  function burn(uint256 value) external;\\n\\n  /**\\n   * @notice Mints tokens and adds them to the balance of the `to` address.\\n   * @dev This method should be permissioned to only allow designated parties to mint tokens.\\n   */\\n  function mint(address to, uint256 value) external returns (bool);\\n\\n  /**\\n   * @notice Returns the number of decimals used to get its user representation.\\n   */\\n  function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/common/interfaces/IDeployment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\n\\n/**\\n * @title Interface that a pool MUST have in order to be included in the deployer\\n */\\ninterface ISynthereumDeployment {\\n  /**\\n   * @notice Get Synthereum finder of the pool/self-minting derivative\\n   * @return finder Returns finder contract\\n   */\\n  function synthereumFinder() external view returns (ISynthereumFinder finder);\\n\\n  /**\\n   * @notice Get Synthereum version\\n   * @return contractVersion Returns the version of this pool/self-minting derivative\\n   */\\n  function version() external view returns (uint8 contractVersion);\\n\\n  /**\\n   * @notice Get the collateral token of this pool/self-minting derivative\\n   * @return collateralCurrency The ERC20 collateral token\\n   */\\n  function collateralToken() external view returns (IERC20 collateralCurrency);\\n\\n  /**\\n   * @notice Get the synthetic token associated to this pool/self-minting derivative\\n   * @return syntheticCurrency The ERC20 synthetic token\\n   */\\n  function syntheticToken() external view returns (IERC20 syntheticCurrency);\\n\\n  /**\\n   * @notice Get the synthetic token symbol associated to this pool/self-minting derivative\\n   * @return symbol The ERC20 synthetic token symbol\\n   */\\n  function syntheticTokenSymbol() external view returns (string memory symbol);\\n}\\n\"\r\n    },\r\n    \"deploy/@uma/core/contracts/common/implementation/FixedPoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../../../../@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"../../../../../@openzeppelin/contracts/utils/math/SignedSafeMath.sol\\\";\\n\\n/**\\n * @title Library for fixed point arithmetic on uints\\n */\\nlibrary FixedPoint {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n    // For unsigned values:\\n    //   This can represent a value up to (2^256 - 1)/10^18 = ~10^59. 10^59 will be stored internally as uint256 10^77.\\n    uint256 private constant FP_SCALING_FACTOR = 10**18;\\n\\n    // --------------------------------------- UNSIGNED -----------------------------------------------------------------------------\\n    struct Unsigned {\\n        uint256 rawValue;\\n    }\\n\\n    /**\\n     * @notice Constructs an `Unsigned` from an unscaled uint, e.g., `b=5` gets stored internally as `5*(10**18)`.\\n     * @param a uint to convert into a FixedPoint.\\n     * @return the converted FixedPoint.\\n     */\\n    function fromUnscaledUint(uint256 a) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.mul(FP_SCALING_FACTOR));\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue == fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue == b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue > fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue >= fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue < fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Unsigned memory a, Unsigned memory b) internal pure returns (bool) {\\n        return a.rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Unsigned memory a, uint256 b) internal pure returns (bool) {\\n        return a.rawValue <= fromUnscaledUint(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(uint256 a, Unsigned memory b) internal pure returns (bool) {\\n        return fromUnscaledUint(a).rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice The minimum of `a` and `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the minimum of `a` and `b`.\\n     */\\n    function min(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return a.rawValue < b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice The maximum of `a` and `b`.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the maximum of `a` and `b`.\\n     */\\n    function max(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return a.rawValue > b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice Adds two `Unsigned`s, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.add(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Adds an `Unsigned` to an unscaled uint, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return add(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts two `Unsigned`s, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.sub(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Subtracts an unscaled uint256 from an `Unsigned`, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return sub(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts an `Unsigned` from an unscaled uint256, reverting on overflow.\\n     * @param a a uint256.\\n     * @param b a FixedPoint.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return sub(fromUnscaledUint(a), b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Unsigned`s, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n        // stored internally as a uint256 ~10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n        // would round to 3, but this computation produces the result 2.\\n        // No need to use SafeMath because FP_SCALING_FACTOR != 0.\\n        return Unsigned(a.rawValue.mul(b.rawValue) / FP_SCALING_FACTOR);\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.\\n     * @param b a uint256.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Unsigned`s and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        uint256 mulRaw = a.rawValue.mul(b.rawValue);\\n        uint256 mulFloor = mulRaw / FP_SCALING_FACTOR;\\n        uint256 mod = mulRaw.mod(FP_SCALING_FACTOR);\\n        if (mod != 0) {\\n            return Unsigned(mulFloor.add(1));\\n        } else {\\n            return Unsigned(mulFloor);\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Unsigned` and an unscaled uint256 and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.\\n     * @param b a FixedPoint.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\\n        return Unsigned(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an `Unsigned`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n        // 10^41 is stored internally as a uint256 10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n        return Unsigned(a.rawValue.mul(FP_SCALING_FACTOR).div(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an unscaled uint256, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        return Unsigned(a.rawValue.div(b));\\n    }\\n\\n    /**\\n     * @notice Divides one unscaled uint256 by an `Unsigned`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a uint256 numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(uint256 a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        return div(fromUnscaledUint(a), b);\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an `Unsigned` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divCeil(Unsigned memory a, Unsigned memory b) internal pure returns (Unsigned memory) {\\n        uint256 aScaled = a.rawValue.mul(FP_SCALING_FACTOR);\\n        uint256 divFloor = aScaled.div(b.rawValue);\\n        uint256 mod = aScaled.mod(b.rawValue);\\n        if (mod != 0) {\\n            return Unsigned(divFloor.add(1));\\n        } else {\\n            return Unsigned(divFloor);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides one `Unsigned` by an unscaled uint256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divCeil(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory) {\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Unsigned(a.rawValue.div(b))\\\"\\n        // similarly to mulCeil with a uint256 as the second parameter. Therefore we need to convert b into an Unsigned.\\n        // This creates the possibility of overflow if b is very large.\\n        return divCeil(a, fromUnscaledUint(b));\\n    }\\n\\n    /**\\n     * @notice Raises an `Unsigned` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n     * @dev This will \\\"floor\\\" the result.\\n     * @param a a FixedPoint numerator.\\n     * @param b a uint256 denominator.\\n     * @return output is `a` to the power of `b`.\\n     */\\n    function pow(Unsigned memory a, uint256 b) internal pure returns (Unsigned memory output) {\\n        output = fromUnscaledUint(1);\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\n            output = mul(output, a);\\n        }\\n    }\\n\\n    // ------------------------------------------------- SIGNED -------------------------------------------------------------\\n    // Supports 18 decimals. E.g., 1e18 represents \\\"1\\\", 5e17 represents \\\"0.5\\\".\\n    // For signed values:\\n    //   This can represent a value up (or down) to +-(2^255 - 1)/10^18 = ~10^58. 10^58 will be stored internally as int256 10^76.\\n    int256 private constant SFP_SCALING_FACTOR = 10**18;\\n\\n    struct Signed {\\n        int256 rawValue;\\n    }\\n\\n    function fromSigned(Signed memory a) internal pure returns (Unsigned memory) {\\n        require(a.rawValue >= 0, \\\"Negative value provided\\\");\\n        return Unsigned(uint256(a.rawValue));\\n    }\\n\\n    function fromUnsigned(Unsigned memory a) internal pure returns (Signed memory) {\\n        require(a.rawValue <= uint256(type(int256).max), \\\"Unsigned too large\\\");\\n        return Signed(int256(a.rawValue));\\n    }\\n\\n    /**\\n     * @notice Constructs a `Signed` from an unscaled int, e.g., `b=5` gets stored internally as `5*(10**18)`.\\n     * @param a int to convert into a FixedPoint.Signed.\\n     * @return the converted FixedPoint.Signed.\\n     */\\n    function fromUnscaledInt(int256 a) internal pure returns (Signed memory) {\\n        return Signed(a.mul(SFP_SCALING_FACTOR));\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a int256.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue == fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if equal, or False.\\n     */\\n    function isEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue == b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue > fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a > b`, or False.\\n     */\\n    function isGreaterThan(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue > b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue >= fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is greater than or equal to `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a >= b`, or False.\\n     */\\n    function isGreaterThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue >= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue < fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a < b`, or False.\\n     */\\n    function isLessThan(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue < b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Signed memory a, Signed memory b) internal pure returns (bool) {\\n        return a.rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(Signed memory a, int256 b) internal pure returns (bool) {\\n        return a.rawValue <= fromUnscaledInt(b).rawValue;\\n    }\\n\\n    /**\\n     * @notice Whether `a` is less than or equal to `b`.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return True if `a <= b`, or False.\\n     */\\n    function isLessThanOrEqual(int256 a, Signed memory b) internal pure returns (bool) {\\n        return fromUnscaledInt(a).rawValue <= b.rawValue;\\n    }\\n\\n    /**\\n     * @notice The minimum of `a` and `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the minimum of `a` and `b`.\\n     */\\n    function min(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return a.rawValue < b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice The maximum of `a` and `b`.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the maximum of `a` and `b`.\\n     */\\n    function max(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return a.rawValue > b.rawValue ? a : b;\\n    }\\n\\n    /**\\n     * @notice Adds two `Signed`s, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.add(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Adds an `Signed` to an unscaled int, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the sum of `a` and `b`.\\n     */\\n    function add(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return add(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts two `Signed`s, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.sub(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Subtracts an unscaled int256 from an `Signed`, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return sub(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts an `Signed` from an unscaled int256, reverting on overflow.\\n     * @param a an int256.\\n     * @param b a FixedPoint.Signed.\\n     * @return the difference of `a` and `b`.\\n     */\\n    function sub(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n        return sub(fromUnscaledInt(a), b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Signed`s, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max output for the represented number is ~10^41, otherwise an intermediate value overflows. 10^41 is\\n        // stored internally as an int256 ~10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 1.4 * 2e-18 = 2.8e-18, which\\n        // would round to 3, but this computation produces the result 2.\\n        // No need to use SafeMath because SFP_SCALING_FACTOR != 0.\\n        return Signed(a.rawValue.mul(b.rawValue) / SFP_SCALING_FACTOR);\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Signed` and an unscaled int256, reverting on overflow.\\n     * @dev This will \\\"floor\\\" the product.\\n     * @param a a FixedPoint.Signed.\\n     * @param b an int256.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mul(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two `Signed`s and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        int256 mulRaw = a.rawValue.mul(b.rawValue);\\n        int256 mulTowardsZero = mulRaw / SFP_SCALING_FACTOR;\\n        // Manual mod because SignedSafeMath doesn't support it.\\n        int256 mod = mulRaw % SFP_SCALING_FACTOR;\\n        if (mod != 0) {\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n            return Signed(mulTowardsZero.add(valueToAdd));\\n        } else {\\n            return Signed(mulTowardsZero);\\n        }\\n    }\\n\\n    /**\\n     * @notice Multiplies an `Signed` and an unscaled int256 and \\\"ceil's\\\" the product, reverting on overflow.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a FixedPoint.Signed.\\n     * @return the product of `a` and `b`.\\n     */\\n    function mulAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        // Since b is an int, there is no risk of truncation and we can just mul it normally\\n        return Signed(a.rawValue.mul(b));\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an `Signed`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        // There are two caveats with this computation:\\n        // 1. Max value for the number dividend `a` represents is ~10^41, otherwise an intermediate value overflows.\\n        // 10^41 is stored internally as an int256 10^59.\\n        // 2. Results that can't be represented exactly are truncated not rounded. E.g., 2 / 3 = 0.6 repeating, which\\n        // would round to 0.666666666666666667, but this computation produces the result 0.666666666666666666.\\n        return Signed(a.rawValue.mul(SFP_SCALING_FACTOR).div(b.rawValue));\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an unscaled int256, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a a FixedPoint numerator.\\n     * @param b an int256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        return Signed(a.rawValue.div(b));\\n    }\\n\\n    /**\\n     * @notice Divides one unscaled int256 by an `Signed`, reverting on overflow or division by 0.\\n     * @dev This will \\\"floor\\\" the quotient.\\n     * @param a an int256 numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function div(int256 a, Signed memory b) internal pure returns (Signed memory) {\\n        return div(fromUnscaledInt(a), b);\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an `Signed` and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b a FixedPoint denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divAwayFromZero(Signed memory a, Signed memory b) internal pure returns (Signed memory) {\\n        int256 aScaled = a.rawValue.mul(SFP_SCALING_FACTOR);\\n        int256 divTowardsZero = aScaled.div(b.rawValue);\\n        // Manual mod because SignedSafeMath doesn't support it.\\n        int256 mod = aScaled % b.rawValue;\\n        if (mod != 0) {\\n            bool isResultPositive = isLessThan(a, 0) == isLessThan(b, 0);\\n            int256 valueToAdd = isResultPositive ? int256(1) : int256(-1);\\n            return Signed(divTowardsZero.add(valueToAdd));\\n        } else {\\n            return Signed(divTowardsZero);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides one `Signed` by an unscaled int256 and \\\"ceil's\\\" the quotient, reverting on overflow or division by 0.\\n     * @param a a FixedPoint numerator.\\n     * @param b an int256 denominator.\\n     * @return the quotient of `a` divided by `b`.\\n     */\\n    function divAwayFromZero(Signed memory a, int256 b) internal pure returns (Signed memory) {\\n        // Because it is possible that a quotient gets truncated, we can't just call \\\"Signed(a.rawValue.div(b))\\\"\\n        // similarly to mulCeil with an int256 as the second parameter. Therefore we need to convert b into an Signed.\\n        // This creates the possibility of overflow if b is very large.\\n        return divAwayFromZero(a, fromUnscaledInt(b));\\n    }\\n\\n    /**\\n     * @notice Raises an `Signed` to the power of an unscaled uint256, reverting on overflow. E.g., `b=2` squares `a`.\\n     * @dev This will \\\"floor\\\" the result.\\n     * @param a a FixedPoint.Signed.\\n     * @param b a uint256 (negative exponents are not allowed).\\n     * @return output is `a` to the power of `b`.\\n     */\\n    function pow(Signed memory a, uint256 b) internal pure returns (Signed memory output) {\\n        output = fromUnscaledInt(1);\\n        for (uint256 i = 0; i < b; i = i.add(1)) {\\n            output = mul(output, a);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/math/SignedSafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SignedSafeMath` is no longer needed starting with Solidity 0.8. The compiler\\n * now has built in overflow checking.\\n */\\nlibrary SignedSafeMath {\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        return a + b;\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/oracle/common/interfaces/IPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\ninterface ISynthereumPriceFeed {\\n  /**\\n   * @notice Get last chainlink oracle price for a given price identifier\\n   * @param _priceIdentifier Price feed identifier\\n   * @return price Oracle price\\n   */\\n  function getLatestPrice(bytes32 _priceIdentifier)\\n    external\\n    view\\n    returns (uint256 price);\\n\\n  /**\\n   * @notice Return if price identifier is supported\\n   * @param _priceIdentifier Price feed identifier\\n   * @return isSupported True if price is supported otherwise false\\n   */\\n  function isPriceSupported(bytes32 _priceIdentifier)\\n    external\\n    view\\n    returns (bool isSupported);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/lending-module/interfaces/ILendingManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ILendingStorageManager} from './ILendingStorageManager.sol';\\n\\ninterface ILendingManager {\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  struct ReturnValues {\\n    uint256 poolInterest; //accumulated pool interest since last state-changing operation;\\n    uint256 daoInterest; //acccumulated dao interest since last state-changing operation;\\n    uint256 tokensOut; //amount of collateral used for a money market operation\\n    uint256 tokensTransferred; //amount of tokens finally transfered/received from money market (after eventual fees)\\n    uint256 prevTotalCollateral; //total collateral in the pool (users + LPs) before new operation\\n  }\\n\\n  struct InterestSplit {\\n    uint256 poolInterest; // share of the total interest generated to the LPs;\\n    uint256 jrtInterest; // share of the total interest generated for jrt buyback;\\n    uint256 commissionInterest; // share of the total interest generated as dao commission;\\n  }\\n\\n  struct MigrateReturnValues {\\n    uint256 prevTotalCollateral; // prevDepositedCollateral collateral deposited (without last interests) before the migration\\n    uint256 poolInterest; // poolInterests collateral interests accumalated before the migration\\n    uint256 actualTotalCollateral; // actualCollateralDeposited collateral deposited after the migration\\n  }\\n\\n  event BatchBuyback(\\n    uint256 indexed collateralIn,\\n    uint256 JRTOut,\\n    address receiver\\n  );\\n\\n  event BatchCommissionClaim(uint256 indexed collateralOut, address receiver);\\n\\n  /**\\n   * @notice deposits collateral into the pool's associated money market\\n   * @dev calculates and return the generated interest since last state-changing operation\\n   * @param _collateralAmount amount of collateral to deposit\\n   * @return returnValues check struct\\n   */\\n  function deposit(uint256 _collateralAmount)\\n    external\\n    returns (ReturnValues memory returnValues);\\n\\n  /**\\n   * @notice withdraw collateral from the pool's associated money market\\n   * @dev calculates and return the generated interest since last state-changing operation\\n   * @param _interestTokenAmount amount of interest tokens to redeem\\n   * @param _recipient the address receiving the collateral from money market\\n   * @return returnValues check struct\\n   */\\n  function withdraw(uint256 _interestTokenAmount, address _recipient)\\n    external\\n    returns (ReturnValues memory returnValues);\\n\\n  /**\\n   * @notice calculate, split and update the generated interest of the caller pool since last state-changing operation\\n   * @return returnValues check struct\\n   */\\n  function updateAccumulatedInterest()\\n    external\\n    returns (ReturnValues memory returnValues);\\n\\n  /**\\n   * @notice batches calls to redeem poolData.commissionInterest from multiple pools\\n   * @dev calculates and update the generated interest since last state-changing operation\\n   * @param _pools array of pools to redeem commissions from\\n   * @param _collateralAmounts array of amount of commission to redeem for each pool (matching pools order)\\n   */\\n  function batchClaimCommission(\\n    address[] calldata _pools,\\n    uint256[] calldata _collateralAmounts\\n  ) external;\\n\\n  /**\\n   * @notice batches calls to redeem poolData.jrtInterest from multiple pools\\n   * @notice and executes a swap to buy Jarvis Reward Token\\n   * @dev calculates and update the generated interest since last state-changing operation\\n   * @param _pools array of pools to redeem collateral from\\n   * @param _collateralAmounts array of amount of commission to redeem for each pool (matching pools order)\\n   * @param _collateralAddress address of the pools collateral token (all pools must have the same collateral)\\n   * @param _swapParams encoded bytes necessary for the swap module\\n   */\\n  function batchBuyback(\\n    address[] calldata _pools,\\n    uint256[] calldata _collateralAmounts,\\n    address _collateralAddress,\\n    bytes calldata _swapParams\\n  ) external;\\n\\n  /**\\n   * @notice sets the address of the implementation of a lending module and its extraBytes\\n   * @param _id associated to the lending module to be set\\n   * @param _lendingInfo see lendingInfo struct\\n   */\\n  function setLendingModule(\\n    string calldata _id,\\n    ILendingStorageManager.LendingInfo calldata _lendingInfo\\n  ) external;\\n\\n  /**\\n   * @notice Add a swap module to the whitelist\\n   * @param _swapModule Swap module to add\\n   */\\n  function addSwapProtocol(address _swapModule) external;\\n\\n  /**\\n   * @notice Remove a swap module from the whitelist\\n   * @param _swapModule Swap module to remove\\n   */\\n  function removeSwapProtocol(address _swapModule) external;\\n\\n  /**\\n   * @notice sets an address as the swap module associated to a specific collateral\\n   * @dev the swapModule must implement the IJRTSwapModule interface\\n   * @param _collateral collateral address associated to the swap module\\n   * @param _swapModule IJRTSwapModule implementer contract\\n   */\\n  function setSwapModule(address _collateral, address _swapModule) external;\\n\\n  /**\\n   * @notice set shares on interest generated by a pool collateral on the lending storage manager\\n   * @param _pool pool address to set shares on\\n   * @param _daoInterestShare share of total interest generated assigned to the dao\\n   * @param _jrtBuybackShare share of the total dao interest used to buyback jrt from an AMM\\n   */\\n  function setShares(\\n    address _pool,\\n    uint64 _daoInterestShare,\\n    uint64 _jrtBuybackShare\\n  ) external;\\n\\n  /**\\n   * @notice migrates liquidity from one lending module (and money market), to a new one\\n   * @dev calculates and return the generated interest since last state-changing operation.\\n   * @dev The new lending module info must be have been previously set in the storage manager\\n   * @param _newLendingID id associated to the new lending module info\\n   * @param _newInterestBearingToken address of the interest token of the new money market\\n   * @param _interestTokenAmount total amount of interest token to migrate from old to new money market\\n   * @return migrateReturnValues check struct\\n   */\\n  function migrateLendingModule(\\n    string memory _newLendingID,\\n    address _newInterestBearingToken,\\n    uint256 _interestTokenAmount\\n  ) external returns (MigrateReturnValues memory);\\n\\n  /**\\n   * @notice migrates pool storage from a deployed pool to a new pool\\n   * @param _migrationPool Pool from which the storage is migrated\\n   * @param _newPool address of the new pool\\n   * @return sourceCollateralAmount Collateral amount of the pool to migrate\\n   * @return actualCollateralAmount Collateral amount of the new deployed pool\\n   */\\n  function migratePool(address _migrationPool, address _newPool)\\n    external\\n    returns (uint256 sourceCollateralAmount, uint256 actualCollateralAmount);\\n\\n  /**\\n   * @notice returns the conversion between interest token and collateral of a specific money market\\n   * @param _pool reference pool to check conversion\\n   * @param _interestTokenAmount amount of interest token to calculate conversion on\\n   * @return collateralAmount amount of collateral after conversion\\n   * @return interestTokenAddr address of the associated interest token\\n   */\\n  function interestTokenToCollateral(\\n    address _pool,\\n    uint256 _interestTokenAmount\\n  ) external view returns (uint256 collateralAmount, address interestTokenAddr);\\n\\n  /**\\n   * @notice returns accumulated interest of a pool since state-changing last operation\\n   * @dev does not update state\\n   * @param _pool reference pool to check accumulated interest\\n   * @return poolInterest amount of interest generated for the pool after splitting the dao share\\n   * @return commissionInterest amount of interest generated for the dao commissions\\n   * @return buybackInterest amount of interest generated for the buyback\\n   * @return collateralDeposited total amount of collateral currently deposited by the pool\\n   */\\n  function getAccumulatedInterest(address _pool)\\n    external\\n    view\\n    returns (\\n      uint256 poolInterest,\\n      uint256 commissionInterest,\\n      uint256 buybackInterest,\\n      uint256 collateralDeposited\\n    );\\n\\n  /**\\n   * @notice returns the conversion between collateral and interest token of a specific money market\\n   * @param _pool reference pool to check conversion\\n   * @param _collateralAmount amount of collateral to calculate conversion on\\n   * @return interestTokenAmount amount of interest token after conversion\\n   * @return interestTokenAddr address of the associated interest token\\n   */\\n  function collateralToInterestToken(address _pool, uint256 _collateralAmount)\\n    external\\n    view\\n    returns (uint256 interestTokenAmount, address interestTokenAddr);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/base/utils/ExplicitERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {\\n  SafeERC20\\n} from '../../../@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\n/**\\n * @title ExplicitERC20\\n * @author Set Protocol\\n *\\n * Utility functions for ERC20 transfers that require the explicit amount to be transferred.\\n */\\nlibrary ExplicitERC20 {\\n  using SafeERC20 for IERC20;\\n\\n  /**\\n   * When given allowance, transfers a token from the \\\"_from\\\" to the \\\"_to\\\" of quantity \\\"_quantity\\\".\\n   * Returning the real amount removed from sender's balance\\n   *\\n   * @param _token ERC20 token\\n   * @param _from  The account to transfer tokens from\\n   * @param _to The account to transfer tokens to\\n   * @param _quantity The quantity to transfer\\n   * @return amountTransferred Real amount removed from user balance\\n   * @return newBalance Final balance of the sender after transfer\\n   */\\n  function explicitSafeTransferFrom(\\n    IERC20 _token,\\n    address _from,\\n    address _to,\\n    uint256 _quantity\\n  ) internal returns (uint256 amountTransferred, uint256 newBalance) {\\n    uint256 existingBalance = _token.balanceOf(_from);\\n\\n    _token.safeTransferFrom(_from, _to, _quantity);\\n\\n    newBalance = _token.balanceOf(_from);\\n\\n    amountTransferred = existingBalance - newBalance;\\n  }\\n\\n  /**\\n   * Transfers a token from the sender to the \\\"_to\\\" of quantity \\\"_quantity\\\".\\n   * Returning the real amount removed from sender's balance\\n   *\\n   * @param _token ERC20 token\\n   * @param _to The account to transfer tokens to\\n   * @param _quantity The quantity to transfer\\n   * @return amountTransferred Real amount removed from user balance\\n   * @return newBalance Final balance of the sender after transfer\\n   */\\n  function explicitSafeTransfer(\\n    IERC20 _token,\\n    address _to,\\n    uint256 _quantity\\n  ) internal returns (uint256 amountTransferred, uint256 newBalance) {\\n    uint256 existingBalance = _token.balanceOf(address(this));\\n\\n    _token.safeTransfer(_to, _quantity);\\n\\n    newBalance = _token.balanceOf(address(this));\\n\\n    amountTransferred = existingBalance - newBalance;\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v6/MultiLpLiquidityPoolLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumPriceFeed\\n} from '../../oracle/common/interfaces/IPriceFeed.sol';\\nimport {\\n  ILendingManager\\n} from '../../lending-module/interfaces/ILendingManager.sol';\\nimport {\\n  ILendingStorageManager\\n} from '../../lending-module/interfaces/ILendingStorageManager.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPool\\n} from './interfaces/IMultiLpLiquidityPool.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPoolEvents\\n} from './interfaces/IMultiLpLiquidityPoolEvents.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {PreciseUnitMath} from '../../base/utils/PreciseUnitMath.sol';\\nimport {\\n  EnumerableSet\\n} from '../../../@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\\nimport {\\n  SafeERC20\\n} from '../../../@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\nimport {ExplicitERC20} from '../../base/utils/ExplicitERC20.sol';\\n\\n/**\\n * @title Multi LP Synthereum pool lib containing internal logic\\n */\\n\\nlibrary SynthereumMultiLpLiquidityPoolLib {\\n  using PreciseUnitMath for uint256;\\n  using SafeERC20 for IStandardERC20;\\n  using SafeERC20 for IMintableBurnableERC20;\\n  using ExplicitERC20 for IERC20;\\n  using EnumerableSet for EnumerableSet.AddressSet;\\n\\n  struct PositionCache {\\n    // Address of the LP\\n    address lp;\\n    // Position of the LP\\n    ISynthereumMultiLpLiquidityPool.LPPosition lpPosition;\\n  }\\n\\n  struct TempStorageArgs {\\n    uint256 price;\\n    uint256 totalSyntheticAsset;\\n    uint8 decimals;\\n  }\\n\\n  struct TempInterstArgs {\\n    uint256 totalCapacity;\\n    uint256 totalUtilization;\\n    uint256 capacityShare;\\n    uint256 utilizationShare;\\n    uint256 interest;\\n    uint256 remainingInterest;\\n    bool isTotCapacityNotZero;\\n    bool isTotUtilizationNotZero;\\n  }\\n\\n  struct TempInterstSharesArgs {\\n    address lp;\\n    uint256 capacityShare;\\n    uint256 utilizationShare;\\n    BestShare bestShare;\\n  }\\n\\n  struct TempSplitOperationArgs {\\n    ISynthereumMultiLpLiquidityPool.LPPosition lpPosition;\\n    uint256 remainingTokens;\\n    uint256 remainingFees;\\n    uint256 tokens;\\n    uint256 fees;\\n    BestShare bestShare;\\n  }\\n\\n  struct BestShare {\\n    uint256 share;\\n    uint256 index;\\n  }\\n\\n  struct LiquidationUpdateArgs {\\n    address liquidator;\\n    ILendingManager lendingManager;\\n    address liquidatedLp;\\n    uint256 tokensInLiquidation;\\n    uint256 overCollateralRequirement;\\n    TempStorageArgs tempStorageArgs;\\n    PositionCache lpCache;\\n    address lp;\\n    uint256 actualCollateralAmount;\\n    uint256 actualSynthTokens;\\n    bool isOvercollateralized;\\n  }\\n\\n  struct TempMigrationArgs {\\n    uint256 prevTotalAmount;\\n    bool isLpGain;\\n    uint256 globalLpsProfitOrLoss;\\n    uint256 actualLpsCollateral;\\n    uint256 share;\\n    uint256 shareAmount;\\n    uint256 remainingAmount;\\n    uint256 lpNumbers;\\n    bool isOvercollateralized;\\n  }\\n\\n  struct WithdrawDust {\\n    bool isPositive;\\n    uint256 amount;\\n  }\\n\\n  // See IMultiLpLiquidityPoolEvents for events description\\n  event SetFeePercentage(uint256 newFee);\\n\\n  event SetLiquidationReward(uint256 newLiquidationReward);\\n\\n  event NewLendingModule(string lendingModuleId);\\n\\n  /**\\n   * @notice Update collateral amount of every LP\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   */\\n  function _updateActualLPCollateral(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    PositionCache[] memory _positionsCache\\n  ) internal {\\n    PositionCache memory lpCache;\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      lpCache = _positionsCache[j];\\n      _storageParams.lpPositions[lpCache.lp].actualCollateralAmount = lpCache\\n        .lpPosition\\n        .actualCollateralAmount;\\n    }\\n  }\\n\\n  /**\\n   * @notice Update collateral amount of every LP and add the new deposit for one LP\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @param _depositingLp Address of the LP depositing collateral\\n   * @param _increaseCollateral Amount of collateral to increase to the LP\\n   * @return newLpCollateralAmount Amount of collateral of the LP after the increase\\n   */\\n  function _updateAndIncreaseActualLPCollateral(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    PositionCache[] memory _positionsCache,\\n    address _depositingLp,\\n    uint256 _increaseCollateral\\n  ) internal returns (uint256 newLpCollateralAmount) {\\n    PositionCache memory lpCache;\\n    address lp;\\n    uint256 actualCollateralAmount;\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      lpCache = _positionsCache[j];\\n      lp = lpCache.lp;\\n      actualCollateralAmount = lpCache.lpPosition.actualCollateralAmount;\\n      if (lp == _depositingLp) {\\n        newLpCollateralAmount = actualCollateralAmount + _increaseCollateral;\\n        _storageParams.lpPositions[lp]\\n          .actualCollateralAmount = newLpCollateralAmount;\\n      } else {\\n        _storageParams.lpPositions[lp]\\n          .actualCollateralAmount = actualCollateralAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Update collateral amount of every LP and removw withdrawal for one LP\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @param _withdrawingLp Address of the LP withdrawing collateral\\n   * @param _decreaseCollateral Amount of collateral to decrease from the LP\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return newLpCollateralAmount Amount of collateral of the LP after the decrease\\n   */\\n  function _updateAndDecreaseActualLPCollateral(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    PositionCache[] memory _positionsCache,\\n    address _withdrawingLp,\\n    uint256 _decreaseCollateral,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  ) internal returns (uint256 newLpCollateralAmount) {\\n    PositionCache memory lpCache;\\n    address lp;\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    uint256 actualCollateralAmount;\\n    bool isOvercollateralized;\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      lpCache = _positionsCache[j];\\n      lp = lpCache.lp;\\n      lpPosition = lpCache.lpPosition;\\n      actualCollateralAmount = lpPosition.actualCollateralAmount;\\n      if (lp == _withdrawingLp) {\\n        newLpCollateralAmount = actualCollateralAmount - _decreaseCollateral;\\n        (isOvercollateralized, ) = _isOvercollateralizedLP(\\n          newLpCollateralAmount,\\n          lpPosition.overCollateralization,\\n          lpPosition.tokensCollateralized,\\n          _price,\\n          _collateralDecimals\\n        );\\n        require(\\n          isOvercollateralized,\\n          'LP below its overcollateralization level'\\n        );\\n        _storageParams.lpPositions[lp]\\n          .actualCollateralAmount = newLpCollateralAmount;\\n      } else {\\n        _storageParams.lpPositions[lp]\\n          .actualCollateralAmount = actualCollateralAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Update collateral amount of every LP and change overcollateralization for one LP\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @param _lp Address of the LP changing overcollateralization\\n   * @param _newOverCollateralization New overcollateralization to be set for the LP\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   */\\n  function _updateAndModifyActualLPOverCollateral(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    PositionCache[] memory _positionsCache,\\n    address _lp,\\n    uint128 _newOverCollateralization,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  ) internal {\\n    PositionCache memory lpCache;\\n    address lp;\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    uint256 actualCollateralAmount;\\n    bool isOvercollateralized;\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      lpCache = _positionsCache[j];\\n      lp = lpCache.lp;\\n      lpPosition = lpCache.lpPosition;\\n      actualCollateralAmount = lpPosition.actualCollateralAmount;\\n      if (lp == _lp) {\\n        (isOvercollateralized, ) = _isOvercollateralizedLP(\\n          actualCollateralAmount,\\n          _newOverCollateralization,\\n          lpPosition.tokensCollateralized,\\n          _price,\\n          _collateralDecimals\\n        );\\n        require(\\n          isOvercollateralized,\\n          'LP below its overcollateralization level'\\n        );\\n        _storageParams.lpPositions[lp]\\n          .actualCollateralAmount = actualCollateralAmount;\\n        _storageParams.lpPositions[lp]\\n          .overCollateralization = _newOverCollateralization;\\n      } else {\\n        _storageParams.lpPositions[lp]\\n          .actualCollateralAmount = actualCollateralAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Update collateral amount and synthetic assets of every LP\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   */\\n  function _updateActualLPPositions(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    PositionCache[] memory _positionsCache\\n  ) internal {\\n    PositionCache memory lpCache;\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      lpCache = _positionsCache[j];\\n      lpPosition = lpCache.lpPosition;\\n      _storageParams.lpPositions[lpCache.lp].actualCollateralAmount = lpPosition\\n        .actualCollateralAmount;\\n      _storageParams.lpPositions[lpCache.lp].tokensCollateralized = lpPosition\\n        .tokensCollateralized;\\n    }\\n  }\\n\\n  /**\\n   * @notice Update collateral amount of every LP and add the new deposit for one LP\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @param _liquidatedLp Address of the LP to liquidate\\n   * @param _tokensInLiquidation Amount of synthetic token to liquidate\\n   * @param _liquidationUpdateArgs Arguments for update liquidation (see LiquidationUpdateArgs struct)\\n   * @return tokensToLiquidate Amount of tokens will be liquidated\\n   * @return collateralAmount Amount of collateral value equivalent to tokens in liquidation\\n   * @return liquidationBonusAmount Amount of bonus collateral for the liquidation\\n   * @return collateralReceived Amount of collateral received by the liquidator\\n   */\\n  function _updateAndLiquidate(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    PositionCache[] memory _positionsCache,\\n    address _liquidatedLp,\\n    uint256 _tokensInLiquidation,\\n    LiquidationUpdateArgs memory _liquidationUpdateArgs\\n  )\\n    internal\\n    returns (\\n      uint256 tokensToLiquidate,\\n      uint256 collateralAmount,\\n      uint256 liquidationBonusAmount,\\n      uint256 collateralReceived\\n    )\\n  {\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      _liquidationUpdateArgs.lpCache = _positionsCache[j];\\n      _liquidationUpdateArgs.lp = _liquidationUpdateArgs.lpCache.lp;\\n      // lpPosition = lpCache.lpPosition;\\n      _liquidationUpdateArgs.actualCollateralAmount = _liquidationUpdateArgs\\n        .lpCache\\n        .lpPosition\\n        .actualCollateralAmount;\\n      _liquidationUpdateArgs.actualSynthTokens = _liquidationUpdateArgs\\n        .lpCache\\n        .lpPosition\\n        .tokensCollateralized;\\n\\n      if (_liquidationUpdateArgs.lp == _liquidatedLp) {\\n        tokensToLiquidate = PreciseUnitMath.min(\\n          _tokensInLiquidation,\\n          _liquidationUpdateArgs.actualSynthTokens\\n        );\\n        require(tokensToLiquidate > 0, 'No synthetic tokens to liquidate');\\n\\n        collateralAmount = _calculateCollateralAmount(\\n          tokensToLiquidate,\\n          _liquidationUpdateArgs.tempStorageArgs.price,\\n          _liquidationUpdateArgs.tempStorageArgs.decimals\\n        );\\n\\n        (\\n          _liquidationUpdateArgs.isOvercollateralized,\\n\\n        ) = _isOvercollateralizedLP(\\n          _liquidationUpdateArgs.actualCollateralAmount,\\n          _liquidationUpdateArgs.overCollateralRequirement,\\n          _liquidationUpdateArgs.actualSynthTokens,\\n          _liquidationUpdateArgs.tempStorageArgs.price,\\n          _liquidationUpdateArgs.tempStorageArgs.decimals\\n        );\\n        require(\\n          !_liquidationUpdateArgs.isOvercollateralized,\\n          'LP is overcollateralized'\\n        );\\n\\n        liquidationBonusAmount = _liquidationUpdateArgs\\n          .actualCollateralAmount\\n          .mul(_storageParams.liquidationBonus)\\n          .mul(tokensToLiquidate.div(_liquidationUpdateArgs.actualSynthTokens));\\n\\n        (\\n          ILendingManager.ReturnValues memory lendingValues,\\n          WithdrawDust memory withdrawDust\\n        ) =\\n          _lendingWithdraw(\\n            _liquidationUpdateArgs.lendingManager,\\n            _liquidationUpdateArgs.liquidator,\\n            collateralAmount + liquidationBonusAmount\\n          );\\n\\n        liquidationBonusAmount = withdrawDust.isPositive\\n          ? liquidationBonusAmount - withdrawDust.amount\\n          : liquidationBonusAmount + withdrawDust.amount;\\n\\n        collateralReceived = lendingValues.tokensTransferred;\\n\\n        _storageParams.lpPositions[_liquidatedLp].actualCollateralAmount =\\n          _liquidationUpdateArgs.actualCollateralAmount -\\n          liquidationBonusAmount;\\n        _storageParams.lpPositions[_liquidatedLp].tokensCollateralized =\\n          _liquidationUpdateArgs.actualSynthTokens -\\n          tokensToLiquidate;\\n      } else {\\n        _storageParams.lpPositions[_liquidationUpdateArgs.lp]\\n          .actualCollateralAmount = _liquidationUpdateArgs\\n          .actualCollateralAmount;\\n      }\\n    }\\n  }\\n\\n  /**\\n   * @notice Set new liquidation reward percentage\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _newLiquidationReward New liquidation reward percentage\\n   */\\n  function _setLiquidationReward(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint64 _newLiquidationReward\\n  ) internal {\\n    require(\\n      _newLiquidationReward > 0 &&\\n        _newLiquidationReward <= PreciseUnitMath.PRECISE_UNIT,\\n      'Liquidation reward must be between 0 and 100%'\\n    );\\n    _storageParams.liquidationBonus = _newLiquidationReward;\\n    emit SetLiquidationReward(_newLiquidationReward);\\n  }\\n\\n  /**\\n   * @notice Set new fee percentage\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _newFee New fee percentage\\n   */\\n  function _setFee(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint64 _newFee\\n  ) internal {\\n    require(\\n      _newFee < PreciseUnitMath.PRECISE_UNIT,\\n      'Fee Percentage must be less than 100%'\\n    );\\n    _storageParams.fee = _newFee;\\n    emit SetFeePercentage(_newFee);\\n  }\\n\\n  /**\\n   * @notice Set new lending module name\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _lendingModuleId Lending module name\\n   */\\n  function _setLendingModule(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    string calldata _lendingModuleId\\n  ) internal {\\n    _storageParams.lendingModuleId = _lendingModuleId;\\n    emit NewLendingModule(_lendingModuleId);\\n  }\\n\\n  /**\\n   * @notice Deposit collateral to the lending manager\\n   * @param _lendingManager Addres of lendingManager\\n   * @param _sender User/LP depositing\\n   * @param _collateralAsset Collateral token of the pool\\n   * @param _collateralAmount Amount of collateral to deposit\\n   * @return Return values parameters from lending manager\\n   */\\n  function _lendingDeposit(\\n    ILendingManager _lendingManager,\\n    address _sender,\\n    IStandardERC20 _collateralAsset,\\n    uint256 _collateralAmount\\n  ) internal returns (ILendingManager.ReturnValues memory) {\\n    _collateralAsset.safeTransferFrom(\\n      _sender,\\n      address(_lendingManager),\\n      _collateralAmount\\n    );\\n\\n    return _lendingManager.deposit(_collateralAmount);\\n  }\\n\\n  /**\\n   * @notice Withdraw collateral from the lending manager\\n   * @param _lendingManager Addres of lendingManager\\n   * @param _recipient Recipient to which collateral is sent\\n   * @param _collateralAmount Collateral to withdraw\\n   * @return Return values parameters from lending manager\\n   * @return Dust to add/decrease if transfer of bearing token from pool to lending manager is not exact\\n   */\\n  function _lendingWithdraw(\\n    ILendingManager _lendingManager,\\n    address _recipient,\\n    uint256 _collateralAmount\\n  )\\n    internal\\n    returns (ILendingManager.ReturnValues memory, WithdrawDust memory)\\n  {\\n    (uint256 bearingAmount, address bearingToken) =\\n      _lendingManager.collateralToInterestToken(\\n        address(this),\\n        _collateralAmount\\n      );\\n\\n    (uint256 amountTransferred, ) =\\n      IERC20(bearingToken).explicitSafeTransfer(\\n        address(_lendingManager),\\n        bearingAmount\\n      );\\n\\n    ILendingManager.ReturnValues memory returnValues =\\n      _lendingManager.withdraw(amountTransferred, _recipient);\\n\\n    bool isPositiveDust = _collateralAmount >= returnValues.tokensOut;\\n\\n    return (\\n      returnValues,\\n      WithdrawDust(\\n        isPositiveDust,\\n        isPositiveDust\\n          ? _collateralAmount - returnValues.tokensOut\\n          : returnValues.tokensOut - _collateralAmount\\n      )\\n    );\\n  }\\n\\n  /**\\n   * @notice Migrate lending module protocol\\n   * @param _lendingManager Addres of lendingManager\\n   * @param _lendingStorageManager Addres of lendingStoarageManager\\n   * @param  _lendingId Name of the new lending protocol to migrate to\\n   * @param  _bearingToken Bearing token of the new lending protocol to switch (only if requetsed by the protocol)\\n   * @return Return migration values parameters from lending manager\\n   */\\n  function _lendingMigration(\\n    ILendingManager _lendingManager,\\n    ILendingStorageManager _lendingStorageManager,\\n    string calldata _lendingId,\\n    address _bearingToken\\n  ) internal returns (ILendingManager.MigrateReturnValues memory) {\\n    IERC20 actualBearingToken =\\n      IERC20(_lendingStorageManager.getInterestBearingToken(address(this)));\\n    uint256 actualBearingAmount = actualBearingToken.balanceOf(address(this));\\n    (uint256 amountTransferred, ) =\\n      actualBearingToken.explicitSafeTransfer(\\n        address(_lendingManager),\\n        actualBearingAmount\\n      );\\n    return\\n      _lendingManager.migrateLendingModule(\\n        _lendingId,\\n        _bearingToken,\\n        amountTransferred\\n      );\\n  }\\n\\n  /**\\n   * @notice Pulls and burns synthetic tokens from the sender\\n   * @param _syntheticAsset Synthetic asset of the pool\\n   * @param _numTokens The number of tokens to be burned\\n   * @param _sender Sender of synthetic tokens\\n   */\\n  function _burnSyntheticTokens(\\n    IMintableBurnableERC20 _syntheticAsset,\\n    uint256 _numTokens,\\n    address _sender\\n  ) internal {\\n    // Transfer synthetic token from the user to the pool\\n    _syntheticAsset.safeTransferFrom(_sender, address(this), _numTokens);\\n\\n    // Burn synthetic asset\\n    _syntheticAsset.burn(_numTokens);\\n  }\\n\\n  /**\\n   * @notice Save LP positions in the cache\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @return totalLPsCollateral Sum of all the LP's collaterals\\n   * @return mostFundedIndex Index in the positionsCache of the LP collateralizing more money\\n   */\\n  function _loadPositions(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    PositionCache[] memory _positionsCache\\n  )\\n    internal\\n    view\\n    returns (uint256 totalLPsCollateral, uint256 mostFundedIndex)\\n  {\\n    address lp;\\n    uint256 maxTokensHeld;\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      lp = _storageParams.activeLPs.at(j);\\n      ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition =\\n        _storageParams.lpPositions[lp];\\n      _positionsCache[j] = PositionCache(lp, lpPosition);\\n      totalLPsCollateral += lpPosition.actualCollateralAmount;\\n      bool isLessFunded = lpPosition.tokensCollateralized <= maxTokensHeld;\\n      mostFundedIndex = isLessFunded ? mostFundedIndex : j;\\n      maxTokensHeld = isLessFunded\\n        ? maxTokensHeld\\n        : lpPosition.tokensCollateralized;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculate new positons from previous interaction\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _totalInterests Amount of interests to split between active LPs\\n   * @param _price Actual price of the pair\\n   * @param _totalSynthTokens Amount of synthetic asset collateralized by the pool\\n   * @param _prevTotalCollateral Total amount in the pool before the operation\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return positionsCache Temporary memory cache containing LPs positions\\n   * @return prevTotalLPsCollateral Sum of all the LP's collaterals before interests and P&L are charged\\n   * @return mostFundedIndex Index of the LP with biggest amount of synt tokens held in his position\\n   */\\n  function _calculateNewPositions(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _totalInterests,\\n    uint256 _price,\\n    uint256 _totalSynthTokens,\\n    uint256 _prevTotalCollateral,\\n    uint8 _collateralDecimals\\n  )\\n    internal\\n    view\\n    returns (\\n      PositionCache[] memory positionsCache,\\n      uint256 prevTotalLPsCollateral,\\n      uint256 mostFundedIndex\\n    )\\n  {\\n    uint256 lpNumbers = _storageParams.activeLPs.length();\\n\\n    if (lpNumbers > 0) {\\n      positionsCache = new PositionCache[](lpNumbers);\\n\\n      (prevTotalLPsCollateral, mostFundedIndex) = _calculateInterest(\\n        _storageParams,\\n        _totalInterests,\\n        _price,\\n        _collateralDecimals,\\n        positionsCache\\n      );\\n\\n      _calculateProfitAndLoss(\\n        _price,\\n        _totalSynthTokens,\\n        _prevTotalCollateral - prevTotalLPsCollateral,\\n        _collateralDecimals,\\n        positionsCache,\\n        mostFundedIndex\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculate interests of each Lp\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _totalInterests Amount of interests to split between active LPs\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @return prevTotalLPsCollateral Sum of all the LP's collaterals before interests are charged\\n   * @return mostFundedIndex Index in the positionsCache of the LP collateralizing more money\\n   */\\n  function _calculateInterest(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _totalInterests,\\n    uint256 _price,\\n    uint8 _collateralDecimals,\\n    PositionCache[] memory _positionsCache\\n  )\\n    internal\\n    view\\n    returns (uint256 prevTotalLPsCollateral, uint256 mostFundedIndex)\\n  {\\n    uint256 lpNumbers = _positionsCache.length;\\n    TempInterstArgs memory tempInterstArguments;\\n    uint256[] memory capacityShares = new uint256[](_positionsCache.length);\\n    uint256[] memory utilizationShares = new uint256[](_positionsCache.length);\\n\\n    (\\n      tempInterstArguments.totalCapacity,\\n      tempInterstArguments.totalUtilization,\\n      prevTotalLPsCollateral,\\n      mostFundedIndex\\n    ) = _calculateInterestShares(\\n      _storageParams,\\n      _price,\\n      _collateralDecimals,\\n      _positionsCache,\\n      capacityShares,\\n      utilizationShares\\n    );\\n\\n    tempInterstArguments.isTotCapacityNotZero =\\n      tempInterstArguments.totalCapacity > 0;\\n    tempInterstArguments.isTotUtilizationNotZero =\\n      tempInterstArguments.totalUtilization > 0;\\n    require(\\n      tempInterstArguments.isTotCapacityNotZero ||\\n        tempInterstArguments.isTotUtilizationNotZero,\\n      'No capacity and utilization'\\n    );\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    tempInterstArguments.remainingInterest = _totalInterests;\\n    if (\\n      tempInterstArguments.isTotCapacityNotZero &&\\n      tempInterstArguments.isTotUtilizationNotZero\\n    ) {\\n      for (uint256 j = 0; j < lpNumbers; j++) {\\n        tempInterstArguments.capacityShare = capacityShares[j].div(\\n          tempInterstArguments.totalCapacity\\n        );\\n        tempInterstArguments.utilizationShare = utilizationShares[j].div(\\n          tempInterstArguments.totalUtilization\\n        );\\n        tempInterstArguments.interest = _totalInterests.mul(\\n          (tempInterstArguments.capacityShare +\\n            tempInterstArguments.utilizationShare) / 2\\n        );\\n        lpPosition = _positionsCache[j].lpPosition;\\n        lpPosition.actualCollateralAmount += tempInterstArguments.interest;\\n        tempInterstArguments.remainingInterest -= tempInterstArguments.interest;\\n      }\\n    } else if (!tempInterstArguments.isTotUtilizationNotZero) {\\n      for (uint256 j = 0; j < lpNumbers; j++) {\\n        tempInterstArguments.capacityShare = capacityShares[j].div(\\n          tempInterstArguments.totalCapacity\\n        );\\n        tempInterstArguments.interest = _totalInterests.mul(\\n          tempInterstArguments.capacityShare\\n        );\\n        lpPosition = _positionsCache[j].lpPosition;\\n        lpPosition.actualCollateralAmount += tempInterstArguments.interest;\\n        tempInterstArguments.remainingInterest -= tempInterstArguments.interest;\\n      }\\n    } else {\\n      for (uint256 j = 0; j < lpNumbers; j++) {\\n        tempInterstArguments.utilizationShare = utilizationShares[j].div(\\n          tempInterstArguments.totalUtilization\\n        );\\n        tempInterstArguments.interest = _totalInterests.mul(\\n          tempInterstArguments.utilizationShare\\n        );\\n        lpPosition = _positionsCache[j].lpPosition;\\n        lpPosition.actualCollateralAmount += tempInterstArguments.interest;\\n        tempInterstArguments.remainingInterest -= tempInterstArguments.interest;\\n      }\\n    }\\n\\n    lpPosition = _positionsCache[mostFundedIndex].lpPosition;\\n    lpPosition.actualCollateralAmount += tempInterstArguments.remainingInterest;\\n  }\\n\\n  /**\\n   * @notice Calculate interest shares of each LP\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @param _capacityShares Array to be populated with the capacity shares of every LP\\n   * @param _utilizationShares Array to be populated with the utilization shares of every LP\\n   * @return totalCapacity Sum of all the LP's capacities\\n   * @return totalUtilization Sum of all the LP's utilizations\\n   * @return totalLPsCollateral Sum of all the LP's collaterals\\n   * @return mostFundedIndex Index in the positionsCache of the LP collateralizing more money\\n   */\\n  function _calculateInterestShares(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _price,\\n    uint8 _collateralDecimals,\\n    PositionCache[] memory _positionsCache,\\n    uint256[] memory _capacityShares,\\n    uint256[] memory _utilizationShares\\n  )\\n    internal\\n    view\\n    returns (\\n      uint256 totalCapacity,\\n      uint256 totalUtilization,\\n      uint256 totalLPsCollateral,\\n      uint256 mostFundedIndex\\n    )\\n  {\\n    TempInterstSharesArgs memory tempInterstSharesArgs;\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      tempInterstSharesArgs.lp = _storageParams.activeLPs.at(j);\\n      ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition =\\n        _storageParams.lpPositions[tempInterstSharesArgs.lp];\\n      tempInterstSharesArgs.capacityShare = _calculateCapacity(\\n        lpPosition,\\n        _price,\\n        _collateralDecimals\\n      );\\n      tempInterstSharesArgs.utilizationShare = _calculateUtilization(\\n        lpPosition,\\n        _price,\\n        _collateralDecimals\\n      );\\n      _capacityShares[j] = tempInterstSharesArgs.capacityShare;\\n      totalCapacity += tempInterstSharesArgs.capacityShare;\\n      _utilizationShares[j] = tempInterstSharesArgs.utilizationShare;\\n      totalUtilization += tempInterstSharesArgs.utilizationShare;\\n      _positionsCache[j] = PositionCache(tempInterstSharesArgs.lp, lpPosition);\\n      totalLPsCollateral += lpPosition.actualCollateralAmount;\\n      tempInterstSharesArgs.bestShare = lpPosition.tokensCollateralized <=\\n        tempInterstSharesArgs.bestShare.share\\n        ? tempInterstSharesArgs.bestShare\\n        : BestShare(lpPosition.tokensCollateralized, j);\\n    }\\n    mostFundedIndex = tempInterstSharesArgs.bestShare.index;\\n  }\\n\\n  /**\\n   * @notice Check if the input LP is registered\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _lp Address of the LP\\n   * @return Return true if the LP is regitered, otherwise false\\n   */\\n  function _isRegisteredLP(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    address _lp\\n  ) internal view returns (bool) {\\n    return _storageParams.registeredLPs.contains(_lp);\\n  }\\n\\n  /**\\n   * @notice Check if the input LP is active\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _lp Address of the LP\\n   * @return Return true if the LP is active, otherwise false\\n   */\\n  function _isActiveLP(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    address _lp\\n  ) internal view returns (bool) {\\n    return _storageParams.activeLPs.contains(_lp);\\n  }\\n\\n  /**\\n   * @notice Return the address of the LendingManager\\n   * @param _finder Synthereum finder\\n   * @return Address of the LendingManager\\n   */\\n  function _getLendingManager(ISynthereumFinder _finder)\\n    internal\\n    view\\n    returns (ILendingManager)\\n  {\\n    return\\n      ILendingManager(\\n        _finder.getImplementationAddress(SynthereumInterfaces.LendingManager)\\n      );\\n  }\\n\\n  /**\\n   * @notice Return the address of the LendingStorageManager\\n   * @param _finder Synthereum finder\\n   * @return Address of the LendingStorageManager\\n   */\\n  function _getLendingStorageManager(ISynthereumFinder _finder)\\n    internal\\n    view\\n    returns (ILendingStorageManager)\\n  {\\n    return\\n      ILendingStorageManager(\\n        _finder.getImplementationAddress(\\n          SynthereumInterfaces.LendingStorageManager\\n        )\\n      );\\n  }\\n\\n  /**\\n   * @notice Calculate and returns interest generated by the pool from the last update\\n   * @param _lendingManager Address of lendingManager\\n   * @return poolInterests Return interest generated by the pool\\n   * @return collateralDeposited Collateral deposited in the pool (LPs + users) (excluding last intrest amount calculation)\\n   */\\n  function _getLendingInterest(ILendingManager _lendingManager)\\n    internal\\n    view\\n    returns (uint256 poolInterests, uint256 collateralDeposited)\\n  {\\n    (poolInterests, , , collateralDeposited) = _lendingManager\\n      .getAccumulatedInterest(address(this));\\n  }\\n\\n  /**\\n   * @notice Return the on-chain oracle price for a pair\\n   * @param _finder Synthereum finder\\n   * @param _priceIdentifier Price identifier\\n   * @return Latest rate of the pair\\n   */\\n  function _getPriceFeedRate(\\n    ISynthereumFinder _finder,\\n    bytes32 _priceIdentifier\\n  ) internal view returns (uint256) {\\n    ISynthereumPriceFeed priceFeed =\\n      ISynthereumPriceFeed(\\n        _finder.getImplementationAddress(SynthereumInterfaces.PriceFeed)\\n      );\\n\\n    return priceFeed.getLatestPrice(_priceIdentifier);\\n  }\\n\\n  /**\\n   * @notice Given a collateral value to be exchanged, returns the fee amount, net collateral and synthetic tokens\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _totCollateralAmount Collateral amount to be exchanged\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return Return netCollateralAmount, feeAmount and numTokens\\n   */\\n  function _calculateMint(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _totCollateralAmount,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  )\\n    internal\\n    view\\n    returns (ISynthereumMultiLpLiquidityPoolEvents.MintValues memory)\\n  {\\n    uint256 feeAmount = _totCollateralAmount.mul(_storageParams.fee);\\n\\n    uint256 netCollateralAmount = _totCollateralAmount - feeAmount;\\n\\n    uint256 numTokens =\\n      _calculateNumberOfTokens(\\n        netCollateralAmount,\\n        _price,\\n        _collateralDecimals\\n      );\\n\\n    return\\n      ISynthereumMultiLpLiquidityPoolEvents.MintValues(\\n        _totCollateralAmount,\\n        netCollateralAmount,\\n        feeAmount,\\n        numTokens\\n      );\\n  }\\n\\n  /**\\n   * @notice Given a an amount of synthetic tokens to be exchanged, returns the fee amount, net collateral and gross collateral\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _numTokens Synthetic tokens amount to be exchanged\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return Return netCollateralAmount, feeAmount and totCollateralAmount\\n   */\\n  function _calculateRedeem(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _numTokens,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  )\\n    internal\\n    view\\n    returns (ISynthereumMultiLpLiquidityPoolEvents.RedeemValues memory)\\n  {\\n    uint256 totCollateralAmount =\\n      _calculateCollateralAmount(_numTokens, _price, _collateralDecimals);\\n\\n    uint256 feeAmount = totCollateralAmount.mul(_storageParams.fee);\\n\\n    uint256 netCollateralAmount = totCollateralAmount - feeAmount;\\n\\n    return\\n      ISynthereumMultiLpLiquidityPoolEvents.RedeemValues(\\n        _numTokens,\\n        totCollateralAmount,\\n        feeAmount,\\n        netCollateralAmount\\n      );\\n  }\\n\\n  /**\\n   * @notice Calculate and return the max capacity in synth tokens of the pool\\n   * @param _storageParams Struct containing all storage variables of a pool (See Storage struct)\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @param _finder Synthereum finder\\n   * @return maxCapacity Max capacity of the pool\\n   */\\n  function _calculateMaxCapacity(\\n    ISynthereumMultiLpLiquidityPool.Storage storage _storageParams,\\n    uint256 _price,\\n    uint8 _collateralDecimals,\\n    ISynthereumFinder _finder\\n  ) internal view returns (uint256 maxCapacity) {\\n    (uint256 poolInterest, uint256 collateralDeposited) =\\n      SynthereumMultiLpLiquidityPoolLib._getLendingInterest(\\n        SynthereumMultiLpLiquidityPoolLib._getLendingManager(_finder)\\n      );\\n\\n    (\\n      SynthereumMultiLpLiquidityPoolLib.PositionCache[] memory positionsCache,\\n      ,\\n\\n    ) =\\n      SynthereumMultiLpLiquidityPoolLib._calculateNewPositions(\\n        _storageParams,\\n        poolInterest,\\n        _price,\\n        _storageParams.totalSyntheticAsset,\\n        collateralDeposited,\\n        _collateralDecimals\\n      );\\n\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    uint256 lpCapacity;\\n    for (uint256 j = 0; j < positionsCache.length; j++) {\\n      lpPosition = positionsCache[j].lpPosition;\\n      lpCapacity = SynthereumMultiLpLiquidityPoolLib._calculateCapacity(\\n        lpPosition,\\n        _price,\\n        _collateralDecimals\\n      );\\n      maxCapacity += lpCapacity;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculate profit or loss of each Lp\\n   * @param _price Actual price of the pair\\n   * @param _totalSynthTokens Amount of synthetic asset collateralized by the pool\\n   * @param _totalUserAmount Actual amount deposited by the users\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @param _mostFundedIndex Index in the positionsCache of the LP collateralizing more money\\n   */\\n  function _calculateProfitAndLoss(\\n    uint256 _price,\\n    uint256 _totalSynthTokens,\\n    uint256 _totalUserAmount,\\n    uint8 _collateralDecimals,\\n    PositionCache[] memory _positionsCache,\\n    uint256 _mostFundedIndex\\n  ) internal pure {\\n    if (_totalSynthTokens == 0) {\\n      return;\\n    }\\n\\n    uint256 lpNumbers = _positionsCache.length;\\n\\n    uint256 totalAssetValue =\\n      _calculateCollateralAmount(\\n        _totalSynthTokens,\\n        _price,\\n        _collateralDecimals\\n      );\\n\\n    bool isLpGain = totalAssetValue < _totalUserAmount;\\n\\n    uint256 totalProfitOrLoss =\\n      isLpGain\\n        ? _totalUserAmount - totalAssetValue\\n        : totalAssetValue - _totalUserAmount;\\n\\n    uint256 remainingProfitOrLoss = totalProfitOrLoss;\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    uint256 assetRatio;\\n    uint256 lpProfitOrLoss;\\n    for (uint256 j = 0; j < lpNumbers; j++) {\\n      lpPosition = _positionsCache[j].lpPosition;\\n      assetRatio = lpPosition.tokensCollateralized.div(_totalSynthTokens);\\n      lpProfitOrLoss = totalProfitOrLoss.mul(assetRatio);\\n      lpPosition.actualCollateralAmount = isLpGain\\n        ? lpPosition.actualCollateralAmount + lpProfitOrLoss\\n        : lpPosition.actualCollateralAmount - lpProfitOrLoss;\\n      remainingProfitOrLoss -= lpProfitOrLoss;\\n    }\\n\\n    lpPosition = _positionsCache[_mostFundedIndex].lpPosition;\\n    lpPosition.actualCollateralAmount = isLpGain\\n      ? lpPosition.actualCollateralAmount + remainingProfitOrLoss\\n      : lpPosition.actualCollateralAmount - remainingProfitOrLoss;\\n  }\\n\\n  /**\\n   * @notice Calculate fee and synthetic asset of each Lp in a mint transaction\\n   * @param _mintValues ExchangeAmount, feeAmount and numTokens\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   */\\n  function _calculateMintTokensAndFee(\\n    ISynthereumMultiLpLiquidityPoolEvents.MintValues memory _mintValues,\\n    uint256 _price,\\n    uint8 _collateralDecimals,\\n    PositionCache[] memory _positionsCache\\n  ) internal pure {\\n    uint256 lpNumbers = _positionsCache.length;\\n\\n    uint256[] memory capacityShares = new uint256[](lpNumbers);\\n    uint256 totalCapacity =\\n      _calculateMintShares(\\n        _price,\\n        _collateralDecimals,\\n        _positionsCache,\\n        capacityShares\\n      );\\n\\n    require(\\n      totalCapacity >= _mintValues.numTokens,\\n      'No enough liquidity for covering mint operation'\\n    );\\n\\n    TempSplitOperationArgs memory mintSplit;\\n    mintSplit.remainingTokens = _mintValues.numTokens;\\n    mintSplit.remainingFees = _mintValues.feeAmount;\\n\\n    for (uint256 j = 0; j < lpNumbers; j++) {\\n      mintSplit.tokens = capacityShares[j].mul(\\n        _mintValues.numTokens.div(totalCapacity)\\n      );\\n      mintSplit.fees = _mintValues.feeAmount.mul(\\n        capacityShares[j].div(totalCapacity)\\n      );\\n      mintSplit.lpPosition = _positionsCache[j].lpPosition;\\n      mintSplit.bestShare = capacityShares[j] > mintSplit.bestShare.share\\n        ? BestShare(capacityShares[j], j)\\n        : mintSplit.bestShare;\\n      mintSplit.lpPosition.tokensCollateralized += mintSplit.tokens;\\n      mintSplit.lpPosition.actualCollateralAmount += mintSplit.fees;\\n      mintSplit.remainingTokens -= mintSplit.tokens;\\n      mintSplit.remainingFees = mintSplit.remainingFees - mintSplit.fees;\\n    }\\n\\n    mintSplit.lpPosition = _positionsCache[mintSplit.bestShare.index]\\n      .lpPosition;\\n    mintSplit.lpPosition.tokensCollateralized += mintSplit.remainingTokens;\\n    mintSplit.lpPosition.actualCollateralAmount += mintSplit.remainingFees;\\n    (bool isOvercollateralized, ) =\\n      _isOvercollateralizedLP(\\n        mintSplit.lpPosition.actualCollateralAmount,\\n        mintSplit.lpPosition.overCollateralization,\\n        mintSplit.lpPosition.tokensCollateralized,\\n        _price,\\n        _collateralDecimals\\n      );\\n    require(\\n      isOvercollateralized,\\n      'No enough liquidity for covering split in mint operation'\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculate fee and synthetic asset of each Lp in a redeem transaction\\n   * @param _totalNumTokens Total amount of synethtic asset in the pool\\n   * @param _redeemNumTokens Total amount of synethtic asset to redeem\\n   * @param _feeAmount Total amount of fee to charge to the LPs\\n   * @param _withdrawDust Dust to add/decrease if transfer of bearing token from pool to lending manager is not exact\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   */\\n  function _calculateRedeemTokensAndFee(\\n    uint256 _totalNumTokens,\\n    uint256 _redeemNumTokens,\\n    uint256 _feeAmount,\\n    WithdrawDust memory _withdrawDust,\\n    PositionCache[] memory _positionsCache\\n  ) internal pure {\\n    uint256 lpNumbers = _positionsCache.length;\\n    TempSplitOperationArgs memory redeemSplit;\\n    redeemSplit.remainingTokens = _redeemNumTokens;\\n    redeemSplit.remainingFees = _feeAmount;\\n\\n    for (uint256 j = 0; j < lpNumbers; j++) {\\n      redeemSplit.lpPosition = _positionsCache[j].lpPosition;\\n      redeemSplit.tokens = redeemSplit.lpPosition.tokensCollateralized.mul(\\n        _redeemNumTokens.div(_totalNumTokens)\\n      );\\n      redeemSplit.fees = _feeAmount.mul(\\n        redeemSplit.lpPosition.tokensCollateralized.div(_totalNumTokens)\\n      );\\n      redeemSplit.bestShare = redeemSplit.lpPosition.tokensCollateralized >\\n        redeemSplit.bestShare.share\\n        ? BestShare(redeemSplit.lpPosition.tokensCollateralized, j)\\n        : redeemSplit.bestShare;\\n      redeemSplit.lpPosition.tokensCollateralized -= redeemSplit.tokens;\\n      redeemSplit.lpPosition.actualCollateralAmount += redeemSplit.fees;\\n      redeemSplit.remainingTokens -= redeemSplit.tokens;\\n      redeemSplit.remainingFees -= redeemSplit.fees;\\n    }\\n    redeemSplit.lpPosition = _positionsCache[redeemSplit.bestShare.index]\\n      .lpPosition;\\n    redeemSplit.lpPosition.tokensCollateralized -= redeemSplit.remainingTokens;\\n    redeemSplit.lpPosition.actualCollateralAmount = _withdrawDust.isPositive\\n      ? redeemSplit.lpPosition.actualCollateralAmount +\\n        redeemSplit.remainingFees +\\n        _withdrawDust.amount\\n      : redeemSplit.lpPosition.actualCollateralAmount +\\n        redeemSplit.remainingFees -\\n        _withdrawDust.amount;\\n  }\\n\\n  /**\\n   * @notice Calculate the new collateral amount of the LPs after the switching of lending module\\n   * @param _prevLpsCollateral Total amount of collateral holded by the LPs before this operation\\n   * @param _migrationValues Values returned by the lending manager after the migration\\n   * @param _overCollateralRequirement Percentage of overcollateralization to which a liquidation can triggered\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @param _mostFundedIndex Index of the LP with biggest amount of synt tokens held in his position\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   */\\n  function _calculateSwitchingOrMigratingCollateral(\\n    uint256 _prevLpsCollateral,\\n    ILendingManager.MigrateReturnValues memory _migrationValues,\\n    uint128 _overCollateralRequirement,\\n    uint256 _price,\\n    uint8 _collateralDecimals,\\n    uint256 _mostFundedIndex,\\n    PositionCache[] memory _positionsCache\\n  ) internal pure {\\n    TempMigrationArgs memory _tempMigrationArgs;\\n    _tempMigrationArgs.prevTotalAmount =\\n      _migrationValues.prevTotalCollateral +\\n      _migrationValues.poolInterest;\\n    _tempMigrationArgs.isLpGain =\\n      _migrationValues.actualTotalCollateral >\\n      _tempMigrationArgs.prevTotalAmount;\\n    _tempMigrationArgs.globalLpsProfitOrLoss = _tempMigrationArgs.isLpGain\\n      ? _migrationValues.actualTotalCollateral -\\n        _tempMigrationArgs.prevTotalAmount\\n      : _tempMigrationArgs.prevTotalAmount -\\n        _migrationValues.actualTotalCollateral;\\n    if (_tempMigrationArgs.globalLpsProfitOrLoss == 0) return;\\n\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    _tempMigrationArgs.actualLpsCollateral =\\n      _prevLpsCollateral +\\n      _migrationValues.poolInterest;\\n    _tempMigrationArgs.remainingAmount = _tempMigrationArgs\\n      .globalLpsProfitOrLoss;\\n    _tempMigrationArgs.lpNumbers = _positionsCache.length;\\n    for (uint256 j = 0; j < _tempMigrationArgs.lpNumbers; j++) {\\n      lpPosition = _positionsCache[j].lpPosition;\\n      _tempMigrationArgs.share = lpPosition.actualCollateralAmount.div(\\n        _tempMigrationArgs.actualLpsCollateral\\n      );\\n      _tempMigrationArgs.shareAmount = _tempMigrationArgs\\n        .globalLpsProfitOrLoss\\n        .mul(_tempMigrationArgs.share);\\n      lpPosition.actualCollateralAmount = _tempMigrationArgs.isLpGain\\n        ? lpPosition.actualCollateralAmount + _tempMigrationArgs.shareAmount\\n        : lpPosition.actualCollateralAmount - _tempMigrationArgs.shareAmount;\\n      _tempMigrationArgs.remainingAmount -= _tempMigrationArgs.shareAmount;\\n      if (j != _mostFundedIndex) {\\n        (_tempMigrationArgs.isOvercollateralized, ) = _isOvercollateralizedLP(\\n          lpPosition.actualCollateralAmount,\\n          _overCollateralRequirement,\\n          lpPosition.tokensCollateralized,\\n          _price,\\n          _collateralDecimals\\n        );\\n        require(\\n          _tempMigrationArgs.isOvercollateralized,\\n          'LP below collateral requirement level'\\n        );\\n      }\\n    }\\n\\n    lpPosition = _positionsCache[_mostFundedIndex].lpPosition;\\n    lpPosition.actualCollateralAmount = _tempMigrationArgs.isLpGain\\n      ? lpPosition.actualCollateralAmount + _tempMigrationArgs.remainingAmount\\n      : lpPosition.actualCollateralAmount - _tempMigrationArgs.remainingAmount;\\n    (_tempMigrationArgs.isOvercollateralized, ) = _isOvercollateralizedLP(\\n      lpPosition.actualCollateralAmount,\\n      _overCollateralRequirement,\\n      lpPosition.tokensCollateralized,\\n      _price,\\n      _collateralDecimals\\n    );\\n    require(\\n      _tempMigrationArgs.isOvercollateralized,\\n      'LP below collateral requirement level'\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculate capacity in tokens of each LP\\n   * @dev Utilization = (actualCollateralAmount / overCollateralization) * price - tokensCollateralized\\n   * @dev Return 0 if underCollateralized\\n   * @param _lpPosition Actual LP position\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return Capacity of the LP\\n   */\\n  function _calculateCapacity(\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory _lpPosition,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  ) internal pure returns (uint256) {\\n    uint256 maxCapacity =\\n      _calculateNumberOfTokens(\\n        _lpPosition.actualCollateralAmount.div(\\n          _lpPosition.overCollateralization\\n        ),\\n        _price,\\n        _collateralDecimals\\n      );\\n    return\\n      maxCapacity > _lpPosition.tokensCollateralized\\n        ? maxCapacity - _lpPosition.tokensCollateralized\\n        : 0;\\n  }\\n\\n  /**\\n   * @notice Calculate utilization of an LP\\n   * @dev Utilization = (tokensCollateralized * price * overCollateralization) / actualCollateralAmount\\n   * @dev Capped to 1 in case of underCollateralization\\n   * @param _lpPosition Actual LP position\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return Utilization of the LP\\n   */\\n  function _calculateUtilization(\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory _lpPosition,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  ) internal pure returns (uint256) {\\n    return\\n      _lpPosition.actualCollateralAmount != 0\\n        ? PreciseUnitMath.min(\\n          _calculateCollateralAmount(\\n            _lpPosition\\n              .tokensCollateralized,\\n            _price,\\n            _collateralDecimals\\n          )\\n            .mul(_lpPosition.overCollateralization)\\n            .div(_lpPosition.actualCollateralAmount),\\n          PreciseUnitMath.PRECISE_UNIT\\n        )\\n        : _lpPosition.tokensCollateralized > 0\\n        ? PreciseUnitMath.PRECISE_UNIT\\n        : 0;\\n  }\\n\\n  /**\\n   * @notice Calculate mint shares based on capacity\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @param _positionsCache Temporary memory cache containing LPs positions\\n   * @param _capacityShares Array to be populated with the capacity shares of every LPP\\n   * @return totalCapacity Sum of all the LP's capacities\\n   */\\n  function _calculateMintShares(\\n    uint256 _price,\\n    uint8 _collateralDecimals,\\n    PositionCache[] memory _positionsCache,\\n    uint256[] memory _capacityShares\\n  ) internal pure returns (uint256 totalCapacity) {\\n    ISynthereumMultiLpLiquidityPool.LPPosition memory lpPosition;\\n    uint256 capacityShare;\\n    for (uint256 j = 0; j < _positionsCache.length; j++) {\\n      lpPosition = _positionsCache[j].lpPosition;\\n      capacityShare = _calculateCapacity(\\n        lpPosition,\\n        _price,\\n        _collateralDecimals\\n      );\\n      _capacityShares[j] = capacityShare;\\n      totalCapacity += capacityShare;\\n    }\\n  }\\n\\n  /**\\n   * @notice Calculate synthetic token amount starting from an amount of collateral\\n   * @param _collateralAmount Amount of collateral from which you want to calculate synthetic token amount\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return Amount of tokens after on-chain oracle conversion\\n   */\\n  function _calculateNumberOfTokens(\\n    uint256 _collateralAmount,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  ) internal pure returns (uint256) {\\n    return (_collateralAmount * (10**(18 - _collateralDecimals))).div(_price);\\n  }\\n\\n  /**\\n   * @notice Calculate collateral amount starting from an amount of synthtic token\\n   * @param _numTokens Amount of synthetic tokens used for the conversion\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return Amount of collateral after on-chain oracle conversion\\n   */\\n  function _calculateCollateralAmount(\\n    uint256 _numTokens,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  ) internal pure returns (uint256) {\\n    return _numTokens.mul(_price) / (10**(18 - _collateralDecimals));\\n  }\\n\\n  /**\\n   * @notice Return if an LP is overcollateralized and the max capacity of the LP\\n   * @param _actualCollateralAmount Actual collateral amount holded by the LP\\n   * @param _overCollateralization Overcollateralization requested\\n   * @param _tokens Tokens collateralized\\n   * @param _price Actual price of the pair\\n   * @param _collateralDecimals Decimals of the collateral token\\n   * @return isOvercollateralized True if LP is overcollateralized otherwise false\\n   * @return maxCapacity Max capcity in synth tokens of the LP\\n   */\\n  function _isOvercollateralizedLP(\\n    uint256 _actualCollateralAmount,\\n    uint256 _overCollateralization,\\n    uint256 _tokens,\\n    uint256 _price,\\n    uint8 _collateralDecimals\\n  ) internal pure returns (bool isOvercollateralized, uint256 maxCapacity) {\\n    maxCapacity = _calculateNumberOfTokens(\\n      _actualCollateralAmount.div(_overCollateralization),\\n      _price,\\n      _collateralDecimals\\n    );\\n    isOvercollateralized = maxCapacity >= _tokens;\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/lending-module/interfaces/ILendingStorageManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\ninterface ILendingStorageManager {\\n  struct PoolStorage {\\n    bytes32 lendingModuleId; // hash of the lending module id associated with the LendingInfo the pool currently is using\\n    uint256 collateralDeposited; // amount of collateral currently deposited in the MoneyMarket\\n    uint256 unclaimedDaoJRT; // amount of interest to be claimed to buyback JRT\\n    uint256 unclaimedDaoCommission; // amount of interest to be claimed as commission (in collateral)\\n    address collateral; // collateral address of the pool\\n    uint64 jrtBuybackShare; // share of dao interest used to buyback JRT\\n    address interestBearingToken; // interest token address of the pool\\n    uint64 daoInterestShare; // share of total interest generated by the pool directed to the DAO\\n  }\\n\\n  struct PoolLendingStorage {\\n    address collateralToken; // address of the collateral token of a pool\\n    address interestToken; // address of interest token of a pool\\n  }\\n\\n  struct LendingInfo {\\n    address lendingModule; // address of the ILendingModule interface implementer\\n    bytes args; // encoded args the ILendingModule implementer might need\\n  }\\n\\n  /**\\n   * @notice sets a ILendingModule implementer info\\n   * @param _id string identifying a specific ILendingModule implementer\\n   * @param _lendingInfo see lendingInfo struct\\n   */\\n  function setLendingModule(\\n    string calldata _id,\\n    LendingInfo calldata _lendingInfo\\n  ) external;\\n\\n  /**\\n   * @notice Add a swap module to the whitelist\\n   * @param _swapModule Swap module to add\\n   */\\n  function addSwapProtocol(address _swapModule) external;\\n\\n  /**\\n   * @notice Remove a swap module from the whitelist\\n   * @param _swapModule Swap module to remove\\n   */\\n  function removeSwapProtocol(address _swapModule) external;\\n\\n  /**\\n   * @notice sets an address as the swap module associated to a specific collateral\\n   * @dev the swapModule must implement the IJRTSwapModule interface\\n   * @param _collateral collateral address associated to the swap module\\n   * @param _swapModule IJRTSwapModule implementer contract\\n   */\\n  function setSwapModule(address _collateral, address _swapModule) external;\\n\\n  /**\\n   * @notice set shares on interest generated by a pool collateral on the lending storage manager\\n   * @param _pool pool address to set shares on\\n   * @param _daoInterestShare share of total interest generated assigned to the dao\\n   * @param _jrtBuybackShare share of the total dao interest used to buyback jrt from an AMM\\n   */\\n  function setShares(\\n    address _pool,\\n    uint64 _daoInterestShare,\\n    uint64 _jrtBuybackShare\\n  ) external;\\n\\n  /**\\n   * @notice store data for lending manager associated to a pool\\n   * @param _lendingID string identifying the associated ILendingModule implementer\\n   * @param _pool pool address to set info\\n   * @param _collateral collateral address of the pool\\n   * @param _interestBearingToken address of the interest token in use\\n   * @param _daoInterestShare share of total interest generated assigned to the dao\\n   * @param _jrtBuybackShare share of the total dao interest used to buyback jrt from an AMM\\n   */\\n  function setPoolStorage(\\n    string calldata _lendingID,\\n    address _pool,\\n    address _collateral,\\n    address _interestBearingToken,\\n    uint64 _daoInterestShare,\\n    uint64 _jrtBuybackShare\\n  ) external;\\n\\n  /**\\n   * @notice assign oldPool storage information and state to newPool address and deletes oldPool storage slot\\n   * @dev is used when a pool is redeployed and the liquidity transferred over\\n   * @param _oldPool address of old pool to migrate storage from\\n   * @param _newPool address of the new pool receiving state of oldPool\\n   * @param _newCollateralDeposited Amount of collateral deposited in the new pool after the migration\\n   */\\n  function migratePoolStorage(\\n    address _oldPool,\\n    address _newPool,\\n    uint256 _newCollateralDeposited\\n  ) external;\\n\\n  /**\\n   * @notice sets new lending info on a pool\\n   * @dev used when migrating liquidity from one lending module (and money market), to a new one\\n   * @dev The new lending module info must be have been previously set in the storage manager\\n   * @param _newLendingID id associated to the new lending module info\\n   * @param _pool address of the pool whose associated lending module is being migrated\\n   * @param _newInterestToken address of the interest token of the new Lending Module (can be set blank)\\n   * @return poolData with the updated state\\n   * @return lendingInfo of the new lending module\\n   */\\n  function migrateLendingModule(\\n    string calldata _newLendingID,\\n    address _pool,\\n    address _newInterestToken\\n  ) external returns (PoolStorage memory, LendingInfo memory);\\n\\n  /**\\n   * @notice updates storage of a pool\\n   * @dev should be callable only by LendingManager after state-changing operations\\n   * @param _pool address of the pool to update values\\n   * @param _collateralDeposited updated amount of collateral deposited\\n   * @param _daoJRT updated amount of unclaimed interest for JRT buyback\\n   * @param _daoInterest updated amount of unclaimed interest as dao commission\\n   */\\n  function updateValues(\\n    address _pool,\\n    uint256 _collateralDeposited,\\n    uint256 _daoJRT,\\n    uint256 _daoInterest\\n  ) external;\\n\\n  /**\\n   * @notice Returns info about a supported lending module\\n   * @param _id Name of the module\\n   * @return lendingInfo Address and bytes associated to the lending mdodule\\n   */\\n  function getLendingModule(string calldata _id)\\n    external\\n    view\\n    returns (LendingInfo memory lendingInfo);\\n\\n  /**\\n   * @notice reads PoolStorage of a pool\\n   * @param _pool address of the pool to read storage\\n   * @return poolData pool struct info\\n   */\\n  function getPoolStorage(address _pool)\\n    external\\n    view\\n    returns (PoolStorage memory poolData);\\n\\n  /**\\n   * @notice reads PoolStorage and LendingInfo of a pool\\n   * @param _pool address of the pool to read storage\\n   * @return poolData pool struct info\\n   * @return lendingInfo information of the lending module associated with the pool\\n   */\\n  function getPoolData(address _pool)\\n    external\\n    view\\n    returns (PoolStorage memory poolData, LendingInfo memory lendingInfo);\\n\\n  /**\\n   * @notice reads lendingStorage and LendingInfo of a pool\\n   * @param _pool address of the pool to read storage\\n   * @return lendingStorage information of the addresses of collateral and intrestToken\\n   * @return lendingInfo information of the lending module associated with the pool\\n   */\\n  function getLendingData(address _pool)\\n    external\\n    view\\n    returns (\\n      PoolLendingStorage memory lendingStorage,\\n      LendingInfo memory lendingInfo\\n    );\\n\\n  /**\\n   * @notice Return the list containing every swap module supported\\n   * @return List of swap modules\\n   */\\n  function getSwapModules() external view returns (address[] memory);\\n\\n  /**\\n   * @notice reads the JRT Buyback module associated to a collateral\\n   * @param _collateral address of the collateral to retrieve module\\n   * @return swapModule address of interface implementer of the IJRTSwapModule\\n   */\\n  function getCollateralSwapModule(address _collateral)\\n    external\\n    view\\n    returns (address swapModule);\\n\\n  /**\\n   * @notice reads the interest beaaring token address associated to a pool\\n   * @param _pool address of the pool to retrieve interest token\\n   * @return interestTokenAddr address of the interest token\\n   */\\n  function getInterestBearingToken(address _pool)\\n    external\\n    view\\n    returns (address interestTokenAddr);\\n\\n  /**\\n   * @notice reads the shares used for splitting interests between pool, dao and buyback\\n   * @param _pool address of the pool to retrieve interest token\\n   * @return jrtBuybackShare Percentage of interests claimable by th DAO\\n   * @return daoInterestShare Percentage of interests used for the buyback\\n   */\\n  function getShares(address _pool)\\n    external\\n    view\\n    returns (uint256 jrtBuybackShare, uint256 daoInterestShare);\\n\\n  /**\\n   * @notice reads the last collateral amount deposited in the pool\\n   * @param _pool address of the pool to retrieve collateral amount\\n   * @return collateralAmount Amount of collateral deposited in the pool\\n   */\\n  function getCollateralDeposited(address _pool)\\n    external\\n    view\\n    returns (uint256 collateralAmount);\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/common/migration/interfaces/IPoolMigrationStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IStandardERC20} from '../../../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPool\\n} from '../../../v6/interfaces/IMultiLpLiquidityPool.sol';\\n\\n/**\\n * @title Interface containing the struct for storage encoding/decoding for each pool version\\n */\\ninterface ISynthereumPoolMigrationStorage {\\n  struct MigrationV6 {\\n    string lendingModuleId;\\n    bytes32 priceIdentifier;\\n    uint256 totalSyntheticAsset;\\n    IStandardERC20 collateralAsset;\\n    uint64 fee;\\n    uint8 collateralDecimals;\\n    uint128 overCollateralRequirement;\\n    uint64 liquidationBonus;\\n    IMintableBurnableERC20 syntheticAsset;\\n    address[] registeredLPsList;\\n    address[] activeLPsList;\\n    ISynthereumMultiLpLiquidityPool.LPPosition[] positions;\\n    address[] admins;\\n    address[] maintainers;\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/common/migration/PoolMigration.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {ISynthereumFinder} from '../../../core/interfaces/IFinder.sol';\\nimport {SynthereumFactoryAccess} from '../../../common/libs/FactoryAccess.sol';\\n\\n/**\\n * @title Abstract contract inherited by pools for moving storage from one pool to another\\n */\\ncontract SynthereumPoolMigration {\\n  ISynthereumFinder internal finder;\\n\\n  modifier onlyPoolFactory() {\\n    SynthereumFactoryAccess._onlyPoolFactory(finder);\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/common/libs/FactoryAccess.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumFactoryVersioning\\n} from '../../core/interfaces/IFactoryVersioning.sol';\\nimport {\\n  SynthereumInterfaces,\\n  FactoryInterfaces\\n} from '../../core/Constants.sol';\\n\\n/** @title Library to use for controlling the access of a functions from the factories\\n */\\nlibrary SynthereumFactoryAccess {\\n  /**\\n   *@notice Revert if caller is not a Pool factory\\n   * @param _finder Synthereum finder\\n   */\\n  function _onlyPoolFactory(ISynthereumFinder _finder) internal view {\\n    ISynthereumFactoryVersioning factoryVersioning =\\n      ISynthereumFactoryVersioning(\\n        _finder.getImplementationAddress(SynthereumInterfaces.FactoryVersioning)\\n      );\\n    uint8 numberOfPoolFactories =\\n      factoryVersioning.numberOfFactoryVersions(FactoryInterfaces.PoolFactory);\\n    require(\\n      _checkSenderIsFactory(\\n        factoryVersioning,\\n        numberOfPoolFactories,\\n        FactoryInterfaces.PoolFactory\\n      ),\\n      'Not allowed'\\n    );\\n  }\\n\\n  /**\\n   * @notice Revert if caller is not a Pool factory or a Fixed rate factory\\n   * @param _finder Synthereum finder\\n   */\\n  function _onlyPoolFactoryOrFixedRateFactory(ISynthereumFinder _finder)\\n    internal\\n    view\\n  {\\n    ISynthereumFactoryVersioning factoryVersioning =\\n      ISynthereumFactoryVersioning(\\n        _finder.getImplementationAddress(SynthereumInterfaces.FactoryVersioning)\\n      );\\n    uint8 numberOfPoolFactories =\\n      factoryVersioning.numberOfFactoryVersions(FactoryInterfaces.PoolFactory);\\n    uint8 numberOfFixedRateFactories =\\n      factoryVersioning.numberOfFactoryVersions(\\n        FactoryInterfaces.FixedRateFactory\\n      );\\n    bool isPoolFactory =\\n      _checkSenderIsFactory(\\n        factoryVersioning,\\n        numberOfPoolFactories,\\n        FactoryInterfaces.PoolFactory\\n      );\\n    if (isPoolFactory) {\\n      return;\\n    }\\n    bool isFixedRateFactory =\\n      _checkSenderIsFactory(\\n        factoryVersioning,\\n        numberOfFixedRateFactories,\\n        FactoryInterfaces.FixedRateFactory\\n      );\\n    if (isFixedRateFactory) {\\n      return;\\n    }\\n    revert('Sender must be a Pool or FixedRate factory');\\n  }\\n\\n  /**\\n   * @notice Check if sender is a factory\\n   * @param _factoryVersioning SynthereumFactoryVersioning contract\\n   * @param _numberOfFactories Total number of versions of a factory type\\n   * @param _factoryKind Type of the factory\\n   * @return isFactory True if sender is a factory, otherwise false\\n   */\\n  function _checkSenderIsFactory(\\n    ISynthereumFactoryVersioning _factoryVersioning,\\n    uint8 _numberOfFactories,\\n    bytes32 _factoryKind\\n  ) private view returns (bool isFactory) {\\n    uint8 counterFactory;\\n    for (uint8 i = 0; counterFactory < _numberOfFactories; i++) {\\n      try _factoryVersioning.getFactoryVersion(_factoryKind, i) returns (\\n        address factory\\n      ) {\\n        if (msg.sender == factory) {\\n          isFactory = true;\\n          break;\\n        } else {\\n          counterFactory++;\\n          if (counterFactory == _numberOfFactories) {\\n            isFactory = false;\\n          }\\n        }\\n      } catch {}\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/interfaces/IFactoryVersioning.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Provides addresses of different versions of pools factory and derivative factory\\n */\\ninterface ISynthereumFactoryVersioning {\\n  /** @notice Sets a Factory\\n   * @param factoryType Type of factory\\n   * @param version Version of the factory to be set\\n   * @param factory The pool factory address to be set\\n   */\\n  function setFactory(\\n    bytes32 factoryType,\\n    uint8 version,\\n    address factory\\n  ) external;\\n\\n  /** @notice Removes a factory\\n   * @param factoryType The type of factory to be removed\\n   * @param version Version of the factory to be removed\\n   */\\n  function removeFactory(bytes32 factoryType, uint8 version) external;\\n\\n  /** @notice Gets a factory contract address\\n   * @param factoryType The type of factory to be checked\\n   * @param version Version of the factory to be checked\\n   * @return factory Address of the factory contract\\n   */\\n  function getFactoryVersion(bytes32 factoryType, uint8 version)\\n    external\\n    view\\n    returns (address factory);\\n\\n  /** @notice Gets the number of factory versions for a specific type\\n   * @param factoryType The type of factory to be checked\\n   * @return numberOfVersions Total number of versions for a specific factory\\n   */\\n  function numberOfFactoryVersions(bytes32 factoryType)\\n    external\\n    view\\n    returns (uint8 numberOfVersions);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v6/MultiLpLiquidityPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {\\n  IDeploymentSignature\\n} from '../../core/interfaces/IDeploymentSignature.sol';\\nimport {\\n  IMigrationSignature\\n} from '../../core/interfaces/IMigrationSignature.sol';\\nimport {\\n  SynthereumMultiLpLiquidityPoolCreator\\n} from './MultiLpLiquidityPoolCreator.sol';\\nimport {FactoryConditions} from '../../common/FactoryConditions.sol';\\nimport {\\n  SynthereumPoolMigrationFrom\\n} from '../common/migration/PoolMigrationFrom.sol';\\nimport {\\n  ReentrancyGuard\\n} from '../../../@openzeppelin/contracts/security/ReentrancyGuard.sol';\\nimport {SynthereumMultiLpLiquidityPool} from './MultiLpLiquidityPool.sol';\\n\\ncontract SynthereumMultiLpLiquidityPoolFactory is\\n  IMigrationSignature,\\n  IDeploymentSignature,\\n  ReentrancyGuard,\\n  FactoryConditions,\\n  SynthereumMultiLpLiquidityPoolCreator\\n{\\n  //----------------------------------------\\n  // Storage\\n  //----------------------------------------\\n\\n  bytes4 public immutable override deploymentSignature;\\n\\n  bytes4 public immutable override migrationSignature;\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Set synthereum finder\\n   * @param _synthereumFinder Synthereum finder contract\\n   * @param _poolImplementation Address of the deployed pool implementation used for EIP1167\\n   */\\n  constructor(address _synthereumFinder, address _poolImplementation)\\n    SynthereumMultiLpLiquidityPoolCreator(\\n      _synthereumFinder,\\n      _poolImplementation\\n    )\\n  {\\n    deploymentSignature = this.createPool.selector;\\n    migrationSignature = this.migratePool.selector;\\n  }\\n\\n  //----------------------------------------\\n  // Public functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Deploy a pool\\n   * @notice Only the deployer can call this function\\n   * @param params input parameters of the pool\\n   * @return pool Deployed pool\\n   */\\n  function createPool(Params calldata params)\\n    public\\n    override\\n    onlyDeployer(synthereumFinder)\\n    nonReentrant\\n    returns (SynthereumMultiLpLiquidityPool pool)\\n  {\\n    checkDeploymentConditions(\\n      synthereumFinder,\\n      params.collateralToken,\\n      params.priceIdentifier\\n    );\\n    pool = super.createPool(params);\\n  }\\n\\n  /**\\n   * @notice Migrate storage from a pool to a new depolyed one\\n   * @notice Only the deployer can call this function\\n   * @param _migrationPool Pool from which migrate storage\\n   * @param _version Version of the new pool\\n   * @param _extraInputParams Additive input pool params encoded for the new pool, that are not part of the migrationPool\\n   * @return migrationPoolUsed Pool from which migrate storage\\n   * @return pool address of the new deployed pool contract to which storage is migrated\\n   */\\n  function migratePool(\\n    SynthereumPoolMigrationFrom _migrationPool,\\n    uint8 _version,\\n    bytes calldata _extraInputParams\\n  )\\n    public\\n    override\\n    nonReentrant\\n    onlyDeployer(synthereumFinder)\\n    returns (\\n      SynthereumPoolMigrationFrom migrationPoolUsed,\\n      SynthereumMultiLpLiquidityPool pool\\n    )\\n  {\\n    (migrationPoolUsed, pool) = super.migratePool(\\n      _migrationPool,\\n      _version,\\n      _extraInputParams\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/interfaces/IDeploymentSignature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Provides signature of function for deployment\\n */\\ninterface IDeploymentSignature {\\n  /**\\n   * @notice Returns the bytes4 signature of the function used for the deployment of a contract in a factory\\n   * @return signature returns signature of the deployment function\\n   */\\n  function deploymentSignature() external view returns (bytes4 signature);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/interfaces/IMigrationSignature.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title Provides signature of function for migration\\n */\\ninterface IMigrationSignature {\\n  /**\\n   * @notice Returns the bytes4 signature of the function used for the migration of a contract in a factory\\n   * @return signature returns signature of the migration function\\n   */\\n  function migrationSignature() external view returns (bytes4 signature);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v6/MultiLpLiquidityPoolCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableTokenFactory\\n} from '../../tokens/factories/interfaces/IMintableBurnableTokenFactory.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumMultiLpLiquidityPool\\n} from './interfaces/IMultiLpLiquidityPool.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {\\n  ILendingManager\\n} from '../../lending-module/interfaces/ILendingManager.sol';\\nimport {\\n  ILendingStorageManager\\n} from '../../lending-module/interfaces/ILendingStorageManager.sol';\\nimport {\\n  SynthereumPoolMigrationFrom\\n} from '../common/migration/PoolMigrationFrom.sol';\\nimport {\\n  BaseControlledMintableBurnableERC20\\n} from '../../tokens/BaseControlledMintableBurnableERC20.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {Clones} from '../../../@openzeppelin/contracts/proxy/Clones.sol';\\nimport {SynthereumMultiLpLiquidityPool} from './MultiLpLiquidityPool.sol';\\n\\ncontract SynthereumMultiLpLiquidityPoolCreator {\\n  using Clones for address;\\n\\n  struct Params {\\n    uint8 version;\\n    IStandardERC20 collateralToken;\\n    string syntheticName;\\n    string syntheticSymbol;\\n    address syntheticToken;\\n    ISynthereumMultiLpLiquidityPool.Roles roles;\\n    uint64 fee;\\n    bytes32 priceIdentifier;\\n    uint128 overCollateralRequirement;\\n    uint64 liquidationReward;\\n    LendingManagerParams lendingManagerParams;\\n  }\\n\\n  struct LendingManagerParams {\\n    string lendingId;\\n    address interestBearingToken;\\n    uint64 daoInterestShare;\\n    uint64 jrtBuybackShare;\\n  }\\n\\n  // Address of Synthereum Finder\\n  ISynthereumFinder public immutable synthereumFinder;\\n\\n  address public immutable poolImplementation;\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Constructs the Pool contract.\\n   * @param _synthereumFinder Synthereum Finder address used to discover other contracts\\n   * @param _poolImplementation Address of the deployed pool implementation used for EIP1167\\n   */\\n  constructor(address _synthereumFinder, address _poolImplementation) {\\n    synthereumFinder = ISynthereumFinder(_synthereumFinder);\\n    poolImplementation = _poolImplementation;\\n  }\\n\\n  //----------------------------------------\\n  // Public functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Creates an instance of the pool\\n   * @param _params is a `ConstructorParams` object from LiquidityPool.\\n   * @return pool address of the deployed pool contract.\\n   */\\n  function createPool(Params calldata _params)\\n    public\\n    virtual\\n    returns (SynthereumMultiLpLiquidityPool pool)\\n  {\\n    pool = SynthereumMultiLpLiquidityPool(poolImplementation.clone());\\n    require(bytes(_params.syntheticName).length != 0, 'Missing synthetic name');\\n    require(\\n      bytes(_params.syntheticSymbol).length != 0,\\n      'Missing synthetic symbol'\\n    );\\n    BaseControlledMintableBurnableERC20 tokenCurrency;\\n    if (_params.syntheticToken == address(0)) {\\n      IMintableBurnableTokenFactory tokenFactory =\\n        IMintableBurnableTokenFactory(\\n          ISynthereumFinder(synthereumFinder).getImplementationAddress(\\n            SynthereumInterfaces.TokenFactory\\n          )\\n        );\\n      tokenCurrency = tokenFactory.createToken(\\n        _params.syntheticName,\\n        _params.syntheticSymbol,\\n        18\\n      );\\n      // Give permissions to new pool contract and then hand over ownership.\\n      tokenCurrency.addMinter(address(pool));\\n      tokenCurrency.addBurner(address(pool));\\n      tokenCurrency.addAdmin(\\n        synthereumFinder.getImplementationAddress(SynthereumInterfaces.Manager)\\n      );\\n      tokenCurrency.renounceAdmin();\\n    } else {\\n      tokenCurrency = BaseControlledMintableBurnableERC20(\\n        _params.syntheticToken\\n      );\\n      require(\\n        keccak256(abi.encodePacked(tokenCurrency.name())) ==\\n          keccak256(abi.encodePacked(_params.syntheticName)),\\n        'Wrong synthetic token name'\\n      );\\n      require(\\n        keccak256(abi.encodePacked(tokenCurrency.symbol())) ==\\n          keccak256(abi.encodePacked(_params.syntheticSymbol)),\\n        'Wrong synthetic token symbol'\\n      );\\n    }\\n    pool.initialize(_convertParams(_params, tokenCurrency));\\n    _setPoolParams(\\n      address(pool),\\n      address(_params.collateralToken),\\n      _params.lendingManagerParams\\n    );\\n  }\\n\\n  /**\\n   * @notice Migrate storage from a pool to a new depolyed one\\n   * @param _migrationPool Pool from which migrate storage\\n   * @param _version Version of the new pool\\n   * @param _extraInputParams Additive input pool params encoded for the new pool, that are not part of the migrationPool\\n   * @return migrationPoolUsed Pool from which migrate storage\\n   * @return pool address of the new deployed pool contract to which storage is migrated\\n   */\\n  function migratePool(\\n    SynthereumPoolMigrationFrom _migrationPool,\\n    uint8 _version,\\n    bytes calldata _extraInputParams\\n  )\\n    public\\n    virtual\\n    returns (\\n      SynthereumPoolMigrationFrom migrationPoolUsed,\\n      SynthereumMultiLpLiquidityPool pool\\n    )\\n  {\\n    migrationPoolUsed = _migrationPool;\\n    pool = SynthereumMultiLpLiquidityPool(poolImplementation.clone());\\n\\n    (uint8 oldPoolVersion, uint256 price, bytes memory storageBytes) =\\n      _migrationPool.migrateStorage();\\n\\n    (uint256 sourceCollateralAmount, uint256 actualCollateralAmount) =\\n      _getLendingManager().migratePool(address(_migrationPool), address(pool));\\n\\n    pool.setMigratedStorage(\\n      synthereumFinder,\\n      oldPoolVersion,\\n      storageBytes,\\n      _version,\\n      _extraInputParams,\\n      sourceCollateralAmount,\\n      actualCollateralAmount,\\n      price\\n    );\\n  }\\n\\n  // Converts createPool params to constructor params.\\n  function _convertParams(\\n    Params memory _params,\\n    BaseControlledMintableBurnableERC20 _tokenCurrency\\n  )\\n    internal\\n    view\\n    returns (\\n      SynthereumMultiLpLiquidityPool.InitializationParams\\n        memory initializationParams\\n    )\\n  {\\n    require(_params.roles.admin != address(0), 'Admin cannot be 0x00');\\n    initializationParams.finder = synthereumFinder;\\n    initializationParams.version = _params.version;\\n    initializationParams.collateralToken = _params.collateralToken;\\n    initializationParams.syntheticToken = IMintableBurnableERC20(\\n      address(_tokenCurrency)\\n    );\\n    initializationParams.roles = _params.roles;\\n    initializationParams.fee = _params.fee;\\n    initializationParams.priceIdentifier = _params.priceIdentifier;\\n    initializationParams.overCollateralRequirement = _params\\n      .overCollateralRequirement;\\n    initializationParams.liquidationReward = _params.liquidationReward;\\n    initializationParams.lendingModuleId = _params\\n      .lendingManagerParams\\n      .lendingId;\\n  }\\n\\n  function _getLendingManager() internal view returns (ILendingManager) {\\n    return\\n      ILendingManager(\\n        synthereumFinder.getImplementationAddress(\\n          SynthereumInterfaces.LendingManager\\n        )\\n      );\\n  }\\n\\n  function _getLendingStorageManager()\\n    internal\\n    view\\n    returns (ILendingStorageManager)\\n  {\\n    return\\n      ILendingStorageManager(\\n        synthereumFinder.getImplementationAddress(\\n          SynthereumInterfaces.LendingStorageManager\\n        )\\n      );\\n  }\\n\\n  // Set lending module params of the pool in the LendingStorageManager\\n  function _setPoolParams(\\n    address _pool,\\n    address _collateral,\\n    LendingManagerParams calldata _lendingManagerParams\\n  ) internal {\\n    _getLendingStorageManager().setPoolStorage(\\n      _lendingManagerParams.lendingId,\\n      _pool,\\n      _collateral,\\n      _lendingManagerParams.interestBearingToken,\\n      _lendingManagerParams.daoInterestShare,\\n      _lendingManagerParams.jrtBuybackShare\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/common/FactoryConditions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IStandardERC20} from '../base/interfaces/IStandardERC20.sol';\\nimport {ISynthereumFinder} from '../core/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumCollateralWhitelist\\n} from '../core/interfaces/ICollateralWhitelist.sol';\\nimport {\\n  ISynthereumIdentifierWhitelist\\n} from '../core/interfaces/IIdentifierWhitelist.sol';\\nimport {SynthereumInterfaces} from '../core/Constants.sol';\\n\\n/** @title Contract to use iniside factories for checking deployment data\\n */\\ncontract FactoryConditions {\\n  /**\\n   * @notice Check if the sender is the deployer\\n   */\\n  modifier onlyDeployer(ISynthereumFinder _synthereumFinder) {\\n    address deployer =\\n      _synthereumFinder.getImplementationAddress(SynthereumInterfaces.Deployer);\\n    require(msg.sender == deployer, 'Sender must be Synthereum deployer');\\n    _;\\n  }\\n\\n  /**\\n   * @notice Check if the sender is the deployer and if identifier and collateral are supported\\n   * @param _synthereumFinder Synthereum finder\\n   * @param _collateralToken Collateral token to check if it's in the whithelist\\n   * @param _priceFeedIdentifier Identifier to check if it's in the whithelist\\n   */\\n  function checkDeploymentConditions(\\n    ISynthereumFinder _synthereumFinder,\\n    IStandardERC20 _collateralToken,\\n    bytes32 _priceFeedIdentifier\\n  ) internal view {\\n    address deployer =\\n      _synthereumFinder.getImplementationAddress(SynthereumInterfaces.Deployer);\\n    require(msg.sender == deployer, 'Sender must be Synthereum deployer');\\n    ISynthereumCollateralWhitelist collateralWhitelist =\\n      ISynthereumCollateralWhitelist(\\n        _synthereumFinder.getImplementationAddress(\\n          SynthereumInterfaces.CollateralWhitelist\\n        )\\n      );\\n    require(\\n      collateralWhitelist.isOnWhitelist(address(_collateralToken)),\\n      'Collateral not supported'\\n    );\\n    ISynthereumIdentifierWhitelist identifierWhitelist =\\n      ISynthereumIdentifierWhitelist(\\n        _synthereumFinder.getImplementationAddress(\\n          SynthereumInterfaces.IdentifierWhitelist\\n        )\\n      );\\n    require(\\n      identifierWhitelist.isOnWhitelist(_priceFeedIdentifier),\\n      'Identifier not supported'\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/tokens/factories/interfaces/IMintableBurnableTokenFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\nimport {\\n  BaseControlledMintableBurnableERC20\\n} from '../../BaseControlledMintableBurnableERC20.sol';\\n\\n/**\\n * @title Interface for interacting with the MintableBurnableTokenFactory contract\\n */\\ninterface IMintableBurnableTokenFactory {\\n  /** @notice Calls the deployment of a new ERC20 token\\n   * @param tokenName The name of the token to be deployed\\n   * @param tokenSymbol The symbol of the token that will be deployed\\n   * @param tokenDecimals Number of decimals for the token to be deployed\\n   */\\n  function createToken(\\n    string memory tokenName,\\n    string memory tokenSymbol,\\n    uint8 tokenDecimals\\n  ) external returns (BaseControlledMintableBurnableERC20 newToken);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/tokens/BaseControlledMintableBurnableERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from '../../@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport {IMintableBurnableERC20} from './interfaces/IMintableBurnableERC20.sol';\\n\\n/**\\n * @title ERC20 interface that includes burn mint and roles methods.\\n */\\nabstract contract BaseControlledMintableBurnableERC20 is\\n  IMintableBurnableERC20,\\n  ERC20\\n{\\n  uint8 private _decimals;\\n\\n  /**\\n   * @notice Constructs the ERC20 token contract\\n   * @param _tokenName Name of the token\\n   * @param _tokenSymbol Token symbol\\n   * @param _tokenDecimals Number of decimals for token\\n   */\\n  constructor(\\n    string memory _tokenName,\\n    string memory _tokenSymbol,\\n    uint8 _tokenDecimals\\n  ) ERC20(_tokenName, _tokenSymbol) {\\n    _setupDecimals(_tokenDecimals);\\n  }\\n\\n  /**\\n   * @notice Add Minter role to an account\\n   * @param account Address to which Minter role will be added\\n   */\\n  function addMinter(address account) external virtual;\\n\\n  /**\\n   * @notice Add Burner role to an account\\n   * @param account Address to which Burner role will be added\\n   */\\n  function addBurner(address account) external virtual;\\n\\n  /**\\n   * @notice Add Admin role to an account\\n   * @param account Address to which Admin role will be added\\n   */\\n  function addAdmin(address account) external virtual;\\n\\n  /**\\n   * @notice Add Admin, Minter and Burner roles to an account\\n   * @param account Address to which Admin, Minter and Burner roles will be added\\n   */\\n  function addAdminAndMinterAndBurner(address account) external virtual;\\n\\n  /**\\n   * @notice Add Admin, Minter and Burner roles to an account\\n   * @param account Address to which Admin, Minter and Burner roles will be added\\n   */\\n  /**\\n   * @notice Self renounce the address calling the function from minter role\\n   */\\n  function renounceMinter() external virtual;\\n\\n  /**\\n   * @notice Self renounce the address calling the function from burner role\\n   */\\n  function renounceBurner() external virtual;\\n\\n  /**\\n   * @notice Self renounce the address calling the function from admin role\\n   */\\n  function renounceAdmin() external virtual;\\n\\n  /**\\n   * @notice Self renounce the address calling the function from admin, minter and burner role\\n   */\\n  function renounceAdminAndMinterAndBurner() external virtual;\\n\\n  /**\\n   * @notice Returns the number of decimals used to get its user representation.\\n   */\\n  function decimals()\\n    public\\n    view\\n    virtual\\n    override(ERC20, IMintableBurnableERC20)\\n    returns (uint8)\\n  {\\n    return _decimals;\\n  }\\n\\n  /**\\n   * @dev Sets {decimals} to a value other than the default one of 18.\\n   *\\n   * WARNING: This function should only be called from the constructor. Most\\n   * applications that interact with token contracts will not expect\\n   * {decimals} to ever change, and may work incorrectly if it does.\\n   */\\n  function _setupDecimals(uint8 decimals_) internal {\\n    _decimals = decimals_;\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/proxy/Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create(0, ptr, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\\n            instance := create2(0, ptr, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\\n            mstore(add(ptr, 0x4c), salt)\\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\\n            predicted := keccak256(add(ptr, 0x37), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/interfaces/ICollateralWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title An interface to track a whitelist of addresses.\\n */\\ninterface ISynthereumCollateralWhitelist {\\n  /**\\n   * @notice Adds an address to the whitelist.\\n   * @param newCollateral the new address to add.\\n   */\\n  function addToWhitelist(address newCollateral) external;\\n\\n  /**\\n   * @notice Removes an address from the whitelist.\\n   * @param collateralToRemove The existing address to remove.\\n   */\\n  function removeFromWhitelist(address collateralToRemove) external;\\n\\n  /**\\n   * @notice Checks whether an address is on the whitelist.\\n   * @param collateralToCheck The address to check.\\n   * @return True if `collateralToCheck` is on the whitelist, or False.\\n   */\\n  function isOnWhitelist(address collateralToCheck)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @notice Gets all addresses that are currently included in the whitelist.\\n   * @return The list of addresses on the whitelist.\\n   */\\n  function getWhitelist() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/interfaces/IIdentifierWhitelist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/**\\n * @title An interface to track a whitelist of identifiers.\\n */\\ninterface ISynthereumIdentifierWhitelist {\\n  /**\\n   * @notice Adds an identifier to the whitelist.\\n   * @param newIdentifier the new identifier to add.\\n   */\\n  function addToWhitelist(bytes32 newIdentifier) external;\\n\\n  /**\\n   * @notice Removes an identifier from the whitelist.\\n   * @param identifierToRemove The existing identifier to remove.\\n   */\\n  function removeFromWhitelist(bytes32 identifierToRemove) external;\\n\\n  /**\\n   * @notice Checks whether an address is on the whitelist.\\n   * @param identifierToCheck The address to check.\\n   * @return True if `identifierToCheck` is on the whitelist, or False.\\n   */\\n  function isOnWhitelist(bytes32 identifierToCheck)\\n    external\\n    view\\n    returns (bool);\\n\\n  /**\\n   * @notice Gets all identifiers that are currently included in the whitelist.\\n   * @return The list of identifiers on the whitelist.\\n   */\\n  function getWhitelist() external view returns (bytes32[] memory);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v5/LiquidityPoolFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  IDeploymentSignature\\n} from '../../core/interfaces/IDeploymentSignature.sol';\\nimport {\\n  ISynthereumCollateralWhitelist\\n} from '../../core/interfaces/ICollateralWhitelist.sol';\\nimport {\\n  ISynthereumIdentifierWhitelist\\n} from '../../core/interfaces/IIdentifierWhitelist.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {SynthereumLiquidityPoolCreator} from './LiquidityPoolCreator.sol';\\nimport {SynthereumLiquidityPool} from './LiquidityPool.sol';\\nimport {FactoryConditions} from '../../common/FactoryConditions.sol';\\nimport {\\n  ReentrancyGuard\\n} from '../../../@openzeppelin/contracts/security/ReentrancyGuard.sol';\\n\\ncontract SynthereumLiquidityPoolFactory is\\n  IDeploymentSignature,\\n  ReentrancyGuard,\\n  FactoryConditions,\\n  SynthereumLiquidityPoolCreator\\n{\\n  //----------------------------------------\\n  // Storage\\n  //----------------------------------------\\n\\n  bytes4 public immutable override deploymentSignature;\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Set synthereum finder\\n   * @param synthereumFinder Synthereum finder contract\\n   */\\n  constructor(address synthereumFinder)\\n    SynthereumLiquidityPoolCreator(synthereumFinder)\\n  {\\n    deploymentSignature = this.createPool.selector;\\n  }\\n\\n  //----------------------------------------\\n  // Public functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Check if the sender is the deployer and deploy a pool\\n   * @param params input parameters of the pool\\n   * @return pool Deployed pool\\n   */\\n  function createPool(Params calldata params)\\n    public\\n    override\\n    nonReentrant\\n    onlyDeployer(synthereumFinder)\\n    returns (SynthereumLiquidityPool pool)\\n  {\\n    checkDeploymentConditions(\\n      synthereumFinder,\\n      params.collateralToken,\\n      params.priceIdentifier\\n    );\\n    pool = super.createPool(params);\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v5/LiquidityPoolCreator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableTokenFactory\\n} from '../../tokens/factories/interfaces/IMintableBurnableTokenFactory.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumLiquidityPoolStorage\\n} from './interfaces/ILiquidityPoolStorage.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {\\n  BaseControlledMintableBurnableERC20\\n} from '../../tokens/BaseControlledMintableBurnableERC20.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {SynthereumLiquidityPool} from './LiquidityPool.sol';\\n\\ncontract SynthereumLiquidityPoolCreator {\\n  struct Params {\\n    IStandardERC20 collateralToken;\\n    string syntheticName;\\n    string syntheticSymbol;\\n    address syntheticToken;\\n    ISynthereumLiquidityPoolStorage.Roles roles;\\n    uint256 overCollateralization;\\n    ISynthereumLiquidityPoolStorage.FeeData feeData;\\n    bytes32 priceIdentifier;\\n    uint256 collateralRequirement;\\n    uint256 liquidationReward;\\n    uint8 version;\\n  }\\n\\n  // Address of Synthereum Finder\\n  ISynthereumFinder public immutable synthereumFinder;\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Constructs the Pool contract.\\n   * @param _synthereumFinder Synthereum Finder address used to discover other contracts\\n   */\\n  constructor(address _synthereumFinder) {\\n    synthereumFinder = ISynthereumFinder(_synthereumFinder);\\n  }\\n\\n  //----------------------------------------\\n  // Public functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Creates an instance of the pool\\n   * @param params is a `ConstructorParams` object from LiquidityPool.\\n   * @return pool address of the deployed pool contract.\\n   */\\n  function createPool(Params calldata params)\\n    public\\n    virtual\\n    returns (SynthereumLiquidityPool pool)\\n  {\\n    require(bytes(params.syntheticName).length != 0, 'Missing synthetic name');\\n    require(\\n      bytes(params.syntheticSymbol).length != 0,\\n      'Missing synthetic symbol'\\n    );\\n\\n    if (params.syntheticToken == address(0)) {\\n      IMintableBurnableTokenFactory tokenFactory =\\n        IMintableBurnableTokenFactory(\\n          ISynthereumFinder(synthereumFinder).getImplementationAddress(\\n            SynthereumInterfaces.TokenFactory\\n          )\\n        );\\n      BaseControlledMintableBurnableERC20 tokenCurrency =\\n        tokenFactory.createToken(\\n          params.syntheticName,\\n          params.syntheticSymbol,\\n          18\\n        );\\n      pool = new SynthereumLiquidityPool(_convertParams(params, tokenCurrency));\\n      // Give permissions to new pool contract and then hand over ownership.\\n      tokenCurrency.addMinter(address(pool));\\n      tokenCurrency.addBurner(address(pool));\\n      tokenCurrency.addAdmin(\\n        synthereumFinder.getImplementationAddress(SynthereumInterfaces.Manager)\\n      );\\n      tokenCurrency.renounceAdmin();\\n    } else {\\n      BaseControlledMintableBurnableERC20 tokenCurrency =\\n        BaseControlledMintableBurnableERC20(params.syntheticToken);\\n      require(\\n        keccak256(abi.encodePacked(tokenCurrency.name())) ==\\n          keccak256(abi.encodePacked(params.syntheticName)),\\n        'Wrong synthetic token name'\\n      );\\n      require(\\n        keccak256(abi.encodePacked(tokenCurrency.symbol())) ==\\n          keccak256(abi.encodePacked(params.syntheticSymbol)),\\n        'Wrong synthetic token symbol'\\n      );\\n      pool = new SynthereumLiquidityPool(_convertParams(params, tokenCurrency));\\n    }\\n    return pool;\\n  }\\n\\n  // Converts createPool params to constructor params.\\n  function _convertParams(\\n    Params memory params,\\n    BaseControlledMintableBurnableERC20 tokenCurrency\\n  )\\n    internal\\n    view\\n    returns (SynthereumLiquidityPool.ConstructorParams memory constructorParams)\\n  {\\n    require(params.roles.admin != address(0), 'Admin cannot be 0x00');\\n    constructorParams.finder = synthereumFinder;\\n    constructorParams.version = params.version;\\n    constructorParams.collateralToken = params.collateralToken;\\n    constructorParams.syntheticToken = IMintableBurnableERC20(\\n      address(tokenCurrency)\\n    );\\n    constructorParams.roles = params.roles;\\n    constructorParams.overCollateralization = params.overCollateralization;\\n    constructorParams.feeData = params.feeData;\\n    constructorParams.priceIdentifier = params.priceIdentifier;\\n    constructorParams.collateralRequirement = params.collateralRequirement;\\n    constructorParams.liquidationReward = params.liquidationReward;\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v5/LiquidityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {IERC20} from '../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {ISynthereumLiquidityPool} from './interfaces/ILiquidityPool.sol';\\nimport {\\n  ISynthereumLiquidityPoolStorage\\n} from './interfaces/ILiquidityPoolStorage.sol';\\nimport {\\n  ISynthereumLiquidityPoolGeneral\\n} from './interfaces/ILiquidityPoolGeneral.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {\\n  FixedPoint\\n} from '../../../@uma/core/contracts/common/implementation/FixedPoint.sol';\\nimport {SynthereumLiquidityPoolLib} from './LiquidityPoolLib.sol';\\nimport {\\n  ReentrancyGuard\\n} from '../../../@openzeppelin/contracts/security/ReentrancyGuard.sol';\\nimport {ERC2771Context} from '../../common/ERC2771Context.sol';\\nimport {\\n  AccessControlEnumerable,\\n  Context\\n} from '../../../@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\n\\n/**\\n * @title Synthetic token Issuer Contract\\n * @notice Collects collateral and issues synthetic assets\\n */\\ncontract SynthereumLiquidityPool is\\n  ISynthereumLiquidityPoolStorage,\\n  ISynthereumLiquidityPool,\\n  ReentrancyGuard,\\n  ERC2771Context,\\n  AccessControlEnumerable\\n{\\n  using SynthereumLiquidityPoolLib for Storage;\\n  using SynthereumLiquidityPoolLib for Liquidation;\\n\\n  struct ConstructorParams {\\n    // Synthereum finder\\n    ISynthereumFinder finder;\\n    // Synthereum pool version\\n    uint8 version;\\n    // ERC20 collateral token\\n    IStandardERC20 collateralToken;\\n    // ERC20 synthetic token\\n    IMintableBurnableERC20 syntheticToken;\\n    // The addresses of admin, maintainer, liquidity provider\\n    Roles roles;\\n    // Overcollateralization percentage\\n    uint256 overCollateralization;\\n    // The feeData structure\\n    FeeData feeData;\\n    // Identifier of price to be used in the price feed\\n    bytes32 priceIdentifier;\\n    // Percentage of overcollateralization to which a liquidation can triggered\\n    uint256 collateralRequirement;\\n    // Percentage of reward for correct liquidation by a liquidator\\n    uint256 liquidationReward;\\n  }\\n\\n  //----------------------------------------\\n  // Constants\\n  //----------------------------------------\\n\\n  string public constant override typology = 'POOL';\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  bytes32 public constant LIQUIDITY_PROVIDER_ROLE =\\n    keccak256('Liquidity Provider');\\n\\n  //----------------------------------------\\n  // Storage\\n  //----------------------------------------\\n\\n  Storage private poolStorage;\\n\\n  LPPosition private lpPosition;\\n\\n  Liquidation private liquidationData;\\n\\n  FeeStatus private feeStatus;\\n\\n  Shutdown private emergencyShutdownData;\\n\\n  //----------------------------------------\\n  // Events\\n  //----------------------------------------\\n\\n  event Mint(\\n    address indexed account,\\n    uint256 collateralSent,\\n    uint256 numTokensReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event Redeem(\\n    address indexed account,\\n    uint256 numTokensSent,\\n    uint256 collateralReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event Exchange(\\n    address indexed account,\\n    address indexed destPool,\\n    uint256 numTokensSent,\\n    uint256 destNumTokensReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event WithdrawLiquidity(\\n    address indexed lp,\\n    uint256 liquidityWithdrawn,\\n    uint256 remainingLiquidity\\n  );\\n\\n  event IncreaseCollateral(\\n    address indexed lp,\\n    uint256 collateralAdded,\\n    uint256 newTotalCollateral\\n  );\\n\\n  event DecreaseCollateral(\\n    address indexed lp,\\n    uint256 collateralRemoved,\\n    uint256 newTotalCollateral\\n  );\\n\\n  event ClaimFee(\\n    address indexed claimer,\\n    uint256 feeAmount,\\n    uint256 totalRemainingFees\\n  );\\n\\n  event Liquidate(\\n    address indexed liquidator,\\n    uint256 tokensLiquidated,\\n    uint256 price,\\n    uint256 collateralExpected,\\n    uint256 collateralReceived,\\n    uint256 rewardReceived\\n  );\\n\\n  event EmergencyShutdown(\\n    uint256 timestamp,\\n    uint256 price,\\n    uint256 finalCollateral\\n  );\\n\\n  event Settle(\\n    address indexed account,\\n    uint256 numTokensSettled,\\n    uint256 collateralExpected,\\n    uint256 collateralSettled\\n  );\\n\\n  event SetFeePercentage(uint256 feePercentage);\\n\\n  event SetFeeRecipients(address[] feeRecipients, uint32[] feeProportions);\\n\\n  event SetOverCollateralization(uint256 overCollateralization);\\n\\n  event SetLiquidationReward(uint256 liquidationReward);\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, _msgSender()),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  modifier onlyLiquidityProvider() {\\n    require(\\n      hasRole(LIQUIDITY_PROVIDER_ROLE, _msgSender()),\\n      'Sender must be the liquidity provider'\\n    );\\n    _;\\n  }\\n\\n  modifier notEmergencyShutdown() {\\n    require(emergencyShutdownData.timestamp == 0, 'Pool emergency shutdown');\\n    _;\\n  }\\n\\n  modifier isEmergencyShutdown() {\\n    require(\\n      emergencyShutdownData.timestamp != 0,\\n      'Pool not emergency shutdown'\\n    );\\n    _;\\n  }\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Constructor of liquidity pool\\n\\n   */\\n  constructor(ConstructorParams memory params) nonReentrant {\\n    poolStorage.initialize(\\n      liquidationData,\\n      params.finder,\\n      params.version,\\n      params.collateralToken,\\n      params.syntheticToken,\\n      FixedPoint.Unsigned(params.overCollateralization),\\n      params.priceIdentifier,\\n      FixedPoint.Unsigned(params.collateralRequirement),\\n      FixedPoint.Unsigned(params.liquidationReward)\\n    );\\n    poolStorage.setFeePercentage(params.feeData.feePercentage);\\n    poolStorage.setFeeRecipients(\\n      params.feeData.feeRecipients,\\n      params.feeData.feeProportions\\n    );\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(LIQUIDITY_PROVIDER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, params.roles.admin);\\n    _setupRole(MAINTAINER_ROLE, params.roles.maintainer);\\n    _setupRole(LIQUIDITY_PROVIDER_ROLE, params.roles.liquidityProvider);\\n  }\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Mint synthetic tokens using fixed amount of collateral\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve collateral transfer for the mint request to succeed\\n   * @param mintParams Input parameters for minting (see MintParams struct)\\n   * @return syntheticTokensMinted Amount of synthetic tokens minted by a user\\n   * @return feePaid Amount of collateral paid by the user as fee\\n   */\\n  function mint(MintParams calldata mintParams)\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 syntheticTokensMinted, uint256 feePaid)\\n  {\\n    (syntheticTokensMinted, feePaid) = poolStorage.mint(\\n      lpPosition,\\n      feeStatus,\\n      mintParams,\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Redeem amount of collateral using fixed number of synthetic token\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param redeemParams Input parameters for redeeming (see RedeemParams struct)\\n   * @return collateralRedeemed Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function redeem(RedeemParams calldata redeemParams)\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 collateralRedeemed, uint256 feePaid)\\n  {\\n    (collateralRedeemed, feePaid) = poolStorage.redeem(\\n      lpPosition,\\n      feeStatus,\\n      redeemParams,\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Exchange a fixed amount of synthetic token of this pool, with an amount of synthetic tokens of an another pool\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param exchangeParams Input parameters for exchanging (see ExchangeParams struct)\\n   * @return destNumTokensMinted Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function exchange(ExchangeParams calldata exchangeParams)\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 destNumTokensMinted, uint256 feePaid)\\n  {\\n    (destNumTokensMinted, feePaid) = poolStorage.exchange(\\n      lpPosition,\\n      feeStatus,\\n      exchangeParams,\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Called by a source Pool's `exchange` function to mint destination tokens\\n   * @notice This functon can be called only by a pool registered in the PoolRegister contract\\n   * @param collateralAmount The amount of collateral to use from the source Pool\\n   * @param numTokens The number of new tokens to mint\\n   * @param recipient Recipient to which send synthetic token minted\\n   */\\n  function exchangeMint(\\n    uint256 collateralAmount,\\n    uint256 numTokens,\\n    address recipient\\n  ) external override notEmergencyShutdown nonReentrant {\\n    poolStorage.exchangeMint(\\n      lpPosition,\\n      feeStatus,\\n      FixedPoint.Unsigned(collateralAmount),\\n      FixedPoint.Unsigned(numTokens),\\n      recipient\\n    );\\n  }\\n\\n  /**\\n   * @notice Withdraw unused deposited collateral by the LP\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralAmount Collateral to be withdrawn\\n   * @return remainingLiquidity Remaining unused collateral in the pool\\n   */\\n  function withdrawLiquidity(uint256 collateralAmount)\\n    external\\n    override\\n    onlyLiquidityProvider\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 remainingLiquidity)\\n  {\\n    remainingLiquidity = poolStorage.withdrawLiquidity(\\n      lpPosition,\\n      feeStatus,\\n      FixedPoint.Unsigned(collateralAmount),\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Increase collaterallization of Lp position\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralToTransfer Collateral to be transferred before increase collateral in the position\\n   * @param collateralToIncrease Collateral to be added to the position\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function increaseCollateral(\\n    uint256 collateralToTransfer,\\n    uint256 collateralToIncrease\\n  )\\n    external\\n    override\\n    onlyLiquidityProvider\\n    nonReentrant\\n    returns (uint256 newTotalCollateral)\\n  {\\n    newTotalCollateral = poolStorage.increaseCollateral(\\n      lpPosition,\\n      feeStatus,\\n      FixedPoint.Unsigned(collateralToTransfer),\\n      FixedPoint.Unsigned(collateralToIncrease),\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Decrease collaterallization of Lp position\\n   * @notice Check that final poosition is not undercollateralized\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralToDecrease Collateral to decreased from the position\\n   * @param collateralToWithdraw Collateral to be transferred to the LP\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function decreaseCollateral(\\n    uint256 collateralToDecrease,\\n    uint256 collateralToWithdraw\\n  )\\n    external\\n    override\\n    onlyLiquidityProvider\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 newTotalCollateral)\\n  {\\n    newTotalCollateral = poolStorage.decreaseCollateral(\\n      lpPosition,\\n      liquidationData,\\n      feeStatus,\\n      FixedPoint.Unsigned(collateralToDecrease),\\n      FixedPoint.Unsigned(collateralToWithdraw),\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Withdraw fees gained by the sender\\n   * @return feeClaimed Amount of fee claimed\\n   */\\n  function claimFee()\\n    external\\n    override\\n    nonReentrant\\n    returns (uint256 feeClaimed)\\n  {\\n    feeClaimed = poolStorage.claimFee(feeStatus, _msgSender());\\n  }\\n\\n  /**\\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\\n   * @notice Revert if position is not undercollateralized\\n   * @param numSynthTokens Number of synthetic tokens that user wants to liquidate\\n   * @return synthTokensLiquidated Amount of synthetic tokens liquidated\\n   * @return collateralReceived Amount of received collateral equal to the value of tokens liquidated\\n   * @return rewardAmount Amount of received collateral as reward for the liquidation\\n   */\\n  function liquidate(uint256 numSynthTokens)\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (\\n      uint256 synthTokensLiquidated,\\n      uint256 collateralReceived,\\n      uint256 rewardAmount\\n    )\\n  {\\n    (synthTokensLiquidated, collateralReceived, rewardAmount) = poolStorage\\n      .liquidate(\\n      lpPosition,\\n      liquidationData,\\n      feeStatus,\\n      FixedPoint.Unsigned(numSynthTokens),\\n      _msgSender()\\n    );\\n  }\\n\\n  /**\\n   * @notice Shutdown the pool in case of emergency\\n   * @notice Only Synthereum manager contract can call this function\\n   * @return timestamp Timestamp of emergency shutdown transaction\\n   * @return price Price of the pair at the moment of shutdown execution\\n   */\\n  function emergencyShutdown()\\n    external\\n    override\\n    notEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 timestamp, uint256 price)\\n  {\\n    (timestamp, price) = poolStorage.emergencyShutdown(\\n      lpPosition,\\n      feeStatus,\\n      emergencyShutdownData\\n    );\\n  }\\n\\n  /**\\n   * @notice Redeem tokens after emergency shutdown\\n   * @return synthTokensSettled Amount of synthetic tokens liquidated\\n   * @return collateralSettled Amount of collateral withdrawn after emergency shutdown\\n   */\\n  function settleEmergencyShutdown()\\n    external\\n    override\\n    isEmergencyShutdown\\n    nonReentrant\\n    returns (uint256 synthTokensSettled, uint256 collateralSettled)\\n  {\\n    address msgSender = _msgSender();\\n    bool isLiquidityProvider = hasRole(LIQUIDITY_PROVIDER_ROLE, msgSender);\\n    (synthTokensSettled, collateralSettled) = poolStorage\\n      .settleEmergencyShutdown(\\n      lpPosition,\\n      feeStatus,\\n      emergencyShutdownData,\\n      isLiquidityProvider,\\n      msgSender\\n    );\\n  }\\n\\n  /**\\n   * @notice Update the fee percentage, recipients and recipient proportions\\n   * @notice Only the maintainer can call this function\\n   * @param _feeData Fee info (percentage + recipients + weigths)\\n   */\\n  function setFee(ISynthereumLiquidityPoolStorage.FeeData calldata _feeData)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setFeePercentage(_feeData.feePercentage);\\n    poolStorage.setFeeRecipients(\\n      _feeData.feeRecipients,\\n      _feeData.feeProportions\\n    );\\n  }\\n\\n  /**\\n   * @notice Update the fee percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _feePercentage The new fee percentage\\n   */\\n  function setFeePercentage(uint256 _feePercentage)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setFeePercentage(FixedPoint.Unsigned(_feePercentage));\\n  }\\n\\n  /**\\n   * @notice Update the addresses of recipients for generated fees and proportions of fees each address will receive\\n   * @notice Only the maintainer can call this function\\n   * @param feeRecipients An array of the addresses of recipients that will receive generated fees\\n   * @param feeProportions An array of the proportions of fees generated each recipient will receive\\n   */\\n  function setFeeRecipients(\\n    address[] calldata feeRecipients,\\n    uint32[] calldata feeProportions\\n  ) external override onlyMaintainer nonReentrant {\\n    poolStorage.setFeeRecipients(feeRecipients, feeProportions);\\n  }\\n\\n  /**\\n   * @notice Update the overcollateralization percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _overCollateralization Overcollateralization percentage\\n   */\\n  function setOverCollateralization(uint256 _overCollateralization)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    poolStorage.setOverCollateralization(\\n      liquidationData,\\n      FixedPoint.Unsigned(_overCollateralization)\\n    );\\n  }\\n\\n  /**\\n   * @notice Update the liquidation reward percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _liquidationReward Percentage of reward for correct liquidation by a liquidator\\n   */\\n  function setLiquidationReward(uint256 _liquidationReward)\\n    external\\n    override\\n    onlyMaintainer\\n    nonReentrant\\n  {\\n    liquidationData.setLiquidationReward(\\n      FixedPoint.Unsigned(_liquidationReward)\\n    );\\n  }\\n\\n  //----------------------------------------\\n  // External view functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Get Synthereum finder of the pool\\n   * @return finder Returns finder contract\\n   */\\n  function synthereumFinder()\\n    external\\n    view\\n    override\\n    returns (ISynthereumFinder finder)\\n  {\\n    finder = poolStorage.finder;\\n  }\\n\\n  /**\\n   * @notice Get Synthereum version\\n   * @return poolVersion Returns the version of the Synthereum pool\\n   */\\n  function version() external view override returns (uint8 poolVersion) {\\n    poolVersion = poolStorage.version;\\n  }\\n\\n  /**\\n   * @notice Get the collateral token\\n   * @return collateralCurrency The ERC20 collateral token\\n   */\\n  function collateralToken()\\n    external\\n    view\\n    override\\n    returns (IERC20 collateralCurrency)\\n  {\\n    collateralCurrency = poolStorage.collateralToken;\\n  }\\n\\n  /**\\n   * @notice Get the synthetic token associated to this pool\\n   * @return syntheticCurrency The ERC20 synthetic token\\n   */\\n  function syntheticToken()\\n    external\\n    view\\n    override\\n    returns (IERC20 syntheticCurrency)\\n  {\\n    syntheticCurrency = poolStorage.syntheticToken;\\n  }\\n\\n  /**\\n   * @notice Get the synthetic token symbol associated to this pool\\n   * @return symbol The ERC20 synthetic token symbol\\n   */\\n  function syntheticTokenSymbol()\\n    external\\n    view\\n    override\\n    returns (string memory symbol)\\n  {\\n    symbol = IStandardERC20(address(poolStorage.syntheticToken)).symbol();\\n  }\\n\\n  /**\\n   * @notice Returns price identifier of the pool\\n   * @return identifier Price identifier\\n   */\\n  function getPriceFeedIdentifier()\\n    external\\n    view\\n    override\\n    returns (bytes32 identifier)\\n  {\\n    identifier = poolStorage.priceIdentifier;\\n  }\\n\\n  /**\\n   * @notice Return overcollateralization percentage from the storage\\n   * @return Overcollateralization percentage\\n   */\\n  function overCollateralization() external view override returns (uint256) {\\n    return poolStorage.overCollateralization.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns fee percentage set by the maintainer\\n   * @return Fee percentage\\n   */\\n  function feePercentage() external view override returns (uint256) {\\n    return poolStorage.fee.feeData.feePercentage.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns fee recipients info\\n   * @return Addresses, weigths and total of weigths\\n   */\\n  function feeRecipientsInfo()\\n    external\\n    view\\n    override\\n    returns (\\n      address[] memory,\\n      uint32[] memory,\\n      uint256\\n    )\\n  {\\n    FeeData storage _feeData = poolStorage.fee.feeData;\\n    return (\\n      _feeData.feeRecipients,\\n      _feeData.feeProportions,\\n      poolStorage.fee.totalFeeProportions\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns total number of synthetic tokens generated by this pool\\n   * @return Number of synthetic tokens\\n   */\\n  function totalSyntheticTokens() external view override returns (uint256) {\\n    return lpPosition.tokensCollateralized.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the total amount of collateral used for collateralizing tokens (users + LP)\\n   * @return Total collateral amount\\n   */\\n  function totalCollateralAmount() external view override returns (uint256) {\\n    return lpPosition.totalCollateralAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the total amount of liquidity deposited in the pool, but nut used as collateral\\n   * @return Total available liquidity\\n   */\\n  function totalAvailableLiquidity() external view override returns (uint256) {\\n    return poolStorage.totalAvailableLiquidity(lpPosition, feeStatus);\\n  }\\n\\n  /**\\n   * @notice Returns the total amount of fees to be withdrawn\\n   * @return Total fee amount\\n   */\\n  function totalFeeAmount() external view override returns (uint256) {\\n    return feeStatus.totalFeeAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the user's fee to be withdrawn\\n   * @param user User's address\\n   * @return User's fee\\n   */\\n  function userFee(address user) external view override returns (uint256) {\\n    return feeStatus.feeGained[user].rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the percentage of overcollateralization to which a liquidation can triggered\\n   * @return Percentage of overcollateralization\\n   */\\n  function collateralRequirement() external view override returns (uint256) {\\n    return liquidationData.collateralRequirement.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the percentage of reward for correct liquidation by a liquidator\\n   * @return Percentage of reward\\n   */\\n  function liquidationReward() external view override returns (uint256) {\\n    return liquidationData.liquidationReward.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the price of the pair at the moment of the shutdown\\n   * @return Price of the pair\\n   */\\n  function emergencyShutdownPrice() external view override returns (uint256) {\\n    return emergencyShutdownData.price.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the timestamp (unix time) at the moment of the shutdown\\n   * @return Timestamp\\n   */\\n  function emergencyShutdownTimestamp()\\n    external\\n    view\\n    override\\n    returns (uint256)\\n  {\\n    return emergencyShutdownData.timestamp;\\n  }\\n\\n  /**\\n   * @notice Returns if position is overcollateralized and thepercentage of coverage of the collateral according to the last price\\n   * @return True if position is overcollaterlized, otherwise false + percentage of coverage (totalCollateralAmount / (price * tokensCollateralized))\\n   */\\n  function collateralCoverage() external view override returns (bool, uint256) {\\n    return poolStorage.collateralCoverage(lpPosition, liquidationData);\\n  }\\n\\n  /**\\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param inputCollateral Input collateral amount to be exchanged\\n   * @return synthTokensReceived Synthetic tokens will be minted\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getMintTradeInfo(uint256 inputCollateral)\\n    external\\n    view\\n    override\\n    returns (uint256 synthTokensReceived, uint256 feePaid)\\n  {\\n    (synthTokensReceived, feePaid) = poolStorage.getMintTradeInfo(\\n      lpPosition,\\n      feeStatus,\\n      FixedPoint.Unsigned(inputCollateral)\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @return collateralAmountReceived Collateral amount will be received by the user\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getRedeemTradeInfo(uint256 syntheticTokens)\\n    external\\n    view\\n    override\\n    returns (uint256 collateralAmountReceived, uint256 feePaid)\\n  {\\n    (collateralAmountReceived, feePaid) = poolStorage.getRedeemTradeInfo(\\n      lpPosition,\\n      FixedPoint.Unsigned(syntheticTokens)\\n    );\\n  }\\n\\n  /**\\n   * @notice Returns the destination synthetic tokens amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @param  destinationPool Pool in which mint the destination synthetic token\\n   * @return destSyntheticTokensReceived Synthetic tokens will be received from destination pool\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getExchangeTradeInfo(\\n    uint256 syntheticTokens,\\n    ISynthereumLiquidityPoolGeneral destinationPool\\n  )\\n    external\\n    view\\n    override\\n    returns (uint256 destSyntheticTokensReceived, uint256 feePaid)\\n  {\\n    (destSyntheticTokensReceived, feePaid) = poolStorage.getExchangeTradeInfo(\\n      lpPosition,\\n      FixedPoint.Unsigned(syntheticTokens),\\n      destinationPool\\n    );\\n  }\\n\\n  /**\\n   * @notice Check if an address is the trusted forwarder\\n   * @param  forwarder Address to check\\n   * @return True is the input address is the trusted forwarder, otherwise false\\n   */\\n  function isTrustedForwarder(address forwarder)\\n    public\\n    view\\n    override\\n    returns (bool)\\n  {\\n    try\\n      poolStorage.finder.getImplementationAddress(\\n        SynthereumInterfaces.TrustedForwarder\\n      )\\n    returns (address trustedForwarder) {\\n      if (forwarder == trustedForwarder) {\\n        return true;\\n      } else {\\n        return false;\\n      }\\n    } catch {\\n      return false;\\n    }\\n  }\\n\\n  function _msgSender()\\n    internal\\n    view\\n    override(ERC2771Context, Context)\\n    returns (address sender)\\n  {\\n    return ERC2771Context._msgSender();\\n  }\\n\\n  function _msgData()\\n    internal\\n    view\\n    override(ERC2771Context, Context)\\n    returns (bytes calldata)\\n  {\\n    return ERC2771Context._msgData();\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v5/interfaces/ILiquidityPoolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {IStandardERC20} from '../../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {ISynthereumFinder} from '../../../core/interfaces/IFinder.sol';\\nimport {\\n  FixedPoint\\n} from '../../../../@uma/core/contracts/common/implementation/FixedPoint.sol';\\n\\ninterface ISynthereumLiquidityPoolStorage {\\n  // Describe role structure\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n    address liquidityProvider;\\n  }\\n\\n  // Describe fee data structure\\n  struct FeeData {\\n    // Fees charged when a user mints, redeem and exchanges tokens\\n    FixedPoint.Unsigned feePercentage;\\n    // Recipient receiving fees\\n    address[] feeRecipients;\\n    // Proportion for each recipient\\n    uint32[] feeProportions;\\n  }\\n\\n  // Describe fee structure\\n  struct Fee {\\n    // Fee data structure\\n    FeeData feeData;\\n    // Used with individual proportions to scale values\\n    uint256 totalFeeProportions;\\n  }\\n\\n  struct Storage {\\n    // Synthereum finder\\n    ISynthereumFinder finder;\\n    // Synthereum version\\n    uint8 version;\\n    // Collateral token\\n    IStandardERC20 collateralToken;\\n    // Synthetic token\\n    IMintableBurnableERC20 syntheticToken;\\n    // Overcollateralization percentage\\n    FixedPoint.Unsigned overCollateralization;\\n    // Fees\\n    Fee fee;\\n    // Price identifier\\n    bytes32 priceIdentifier;\\n  }\\n\\n  struct LPPosition {\\n    // Collateral used for collateralize tokens\\n    FixedPoint.Unsigned totalCollateralAmount;\\n    // Number of tokens collateralized\\n    FixedPoint.Unsigned tokensCollateralized;\\n  }\\n\\n  struct Liquidation {\\n    // Percentage of overcollateralization to which a liquidation can triggered\\n    FixedPoint.Unsigned collateralRequirement;\\n    // Percentage of reward for correct liquidation by a liquidator\\n    FixedPoint.Unsigned liquidationReward;\\n  }\\n\\n  struct FeeStatus {\\n    // Track the fee gained to be withdrawn by an address\\n    mapping(address => FixedPoint.Unsigned) feeGained;\\n    // Total amount of fees to be withdrawn\\n    FixedPoint.Unsigned totalFeeAmount;\\n  }\\n\\n  struct Shutdown {\\n    // Timestamp of execution of shutdown\\n    uint256 timestamp;\\n    // Price of the pair at the moment of the shutdown\\n    FixedPoint.Unsigned price;\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v5/interfaces/ILiquidityPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {\\n  IEmergencyShutdown\\n} from '../../../common/interfaces/IEmergencyShutdown.sol';\\nimport {ISynthereumLiquidityPoolGeneral} from './ILiquidityPoolGeneral.sol';\\nimport {ISynthereumLiquidityPoolStorage} from './ILiquidityPoolStorage.sol';\\nimport {ITypology} from '../../../common/interfaces/ITypology.sol';\\n\\n/**\\n * @title Token Issuer Contract Interface\\n */\\ninterface ISynthereumLiquidityPool is\\n  ITypology,\\n  IEmergencyShutdown,\\n  ISynthereumLiquidityPoolGeneral\\n{\\n  struct MintParams {\\n    // Minimum amount of synthetic tokens that a user wants to mint using collateral (anti-slippage)\\n    uint256 minNumTokens;\\n    // Amount of collateral that a user wants to spend for minting\\n    uint256 collateralAmount;\\n    // Expiration time of the transaction\\n    uint256 expiration;\\n    // Address to which send synthetic tokens minted\\n    address recipient;\\n  }\\n\\n  struct RedeemParams {\\n    // Amount of synthetic tokens that user wants to use for redeeming\\n    uint256 numTokens;\\n    // Minimium amount of collateral that user wants to redeem (anti-slippage)\\n    uint256 minCollateral;\\n    // Expiration time of the transaction\\n    uint256 expiration;\\n    // Address to which send collateral tokens redeemed\\n    address recipient;\\n  }\\n\\n  struct ExchangeParams {\\n    // Destination pool\\n    ISynthereumLiquidityPoolGeneral destPool;\\n    // Amount of source synthetic tokens that user wants to use for exchanging\\n    uint256 numTokens;\\n    // Minimum Amount of destination synthetic tokens that user wants to receive (anti-slippage)\\n    uint256 minDestNumTokens;\\n    // Expiration time of the transaction\\n    uint256 expiration;\\n    // Address to which send synthetic tokens exchanged\\n    address recipient;\\n  }\\n\\n  /**\\n   * @notice Mint synthetic tokens using fixed amount of collateral\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve collateral transfer for the mint request to succeed\\n   * @param mintParams Input parameters for minting (see MintParams struct)\\n   * @return syntheticTokensMinted Amount of synthetic tokens minted by a user\\n   * @return feePaid Amount of collateral paid by the user as fee\\n   */\\n  function mint(MintParams calldata mintParams)\\n    external\\n    returns (uint256 syntheticTokensMinted, uint256 feePaid);\\n\\n  /**\\n   * @notice Redeem amount of collateral using fixed number of synthetic token\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param redeemParams Input parameters for redeeming (see RedeemParams struct)\\n   * @return collateralRedeemed Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function redeem(RedeemParams calldata redeemParams)\\n    external\\n    returns (uint256 collateralRedeemed, uint256 feePaid);\\n\\n  /**\\n   * @notice Exchange a fixed amount of synthetic token of this pool, with an amount of synthetic tokens of an another pool\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param exchangeParams Input parameters for exchanging (see ExchangeParams struct)\\n   * @return destNumTokensMinted Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function exchange(ExchangeParams calldata exchangeParams)\\n    external\\n    returns (uint256 destNumTokensMinted, uint256 feePaid);\\n\\n  /**\\n   * @notice Withdraw unused deposited collateral by the LP\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralAmount Collateral to be withdrawn\\n   * @return remainingLiquidity Remaining unused collateral in the pool\\n   */\\n  function withdrawLiquidity(uint256 collateralAmount)\\n    external\\n    returns (uint256 remainingLiquidity);\\n\\n  /**\\n   * @notice Increase collaterallization of Lp position\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralToTransfer Collateral to be transferred before increase collateral in the position\\n   * @param collateralToIncrease Collateral to be added to the position\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function increaseCollateral(\\n    uint256 collateralToTransfer,\\n    uint256 collateralToIncrease\\n  ) external returns (uint256 newTotalCollateral);\\n\\n  /**\\n   * @notice Decrease collaterallization of Lp position\\n   * @notice Check that final poosition is not undercollateralized\\n   * @notice Only a sender with LP role can call this function\\n   * @param collateralToDecrease Collateral to decreased from the position\\n   * @param collateralToWithdraw Collateral to be transferred to the LP\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function decreaseCollateral(\\n    uint256 collateralToDecrease,\\n    uint256 collateralToWithdraw\\n  ) external returns (uint256 newTotalCollateral);\\n\\n  /**\\n   * @notice Withdraw fees gained by the sender\\n   * @return feeClaimed Amount of fee claimed\\n   */\\n  function claimFee() external returns (uint256 feeClaimed);\\n\\n  /**\\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\\n   * @notice Revert if position is not undercollateralized\\n   * @param numSynthTokens Number of synthetic tokens that user wants to liquidate\\n   * @return synthTokensLiquidated Amount of synthetic tokens liquidated\\n   * @return collateralReceived Amount of received collateral equal to the value of tokens liquidated\\n   * @return rewardAmount Amount of received collateral as reward for the liquidation\\n   */\\n  function liquidate(uint256 numSynthTokens)\\n    external\\n    returns (\\n      uint256 synthTokensLiquidated,\\n      uint256 collateralReceived,\\n      uint256 rewardAmount\\n    );\\n\\n  /**\\n   * @notice Redeem tokens after emergency shutdown\\n   * @return synthTokensSettled Amount of synthetic tokens liquidated\\n   * @return collateralSettled Amount of collateral withdrawn after emergency shutdown\\n   */\\n  function settleEmergencyShutdown()\\n    external\\n    returns (uint256 synthTokensSettled, uint256 collateralSettled);\\n\\n  /**\\n   * @notice Update the fee percentage, recipients and recipient proportions\\n   * @notice Only the maintainer can call this function\\n   * @param _feeData Fee info (percentage + recipients + weigths)\\n   */\\n  function setFee(ISynthereumLiquidityPoolStorage.FeeData calldata _feeData)\\n    external;\\n\\n  /**\\n   * @notice Update the fee percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _feePercentage The new fee percentage\\n   */\\n  function setFeePercentage(uint256 _feePercentage) external;\\n\\n  /**\\n   * @notice Update the addresses of recipients for generated fees and proportions of fees each address will receive\\n   * @notice Only the maintainer can call this function\\n   * @param feeRecipients An array of the addresses of recipients that will receive generated fees\\n   * @param feeProportions An array of the proportions of fees generated each recipient will receive\\n   */\\n  function setFeeRecipients(\\n    address[] calldata feeRecipients,\\n    uint32[] calldata feeProportions\\n  ) external;\\n\\n  /**\\n   * @notice Update the overcollateralization percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _overCollateralization Overcollateralization percentage\\n   */\\n  function setOverCollateralization(uint256 _overCollateralization) external;\\n\\n  /**\\n   * @notice Update the liquidation reward percentage\\n   * @notice Only the maintainer can call this function\\n   * @param _liquidationReward Percentage of reward for correct liquidation by a liquidator\\n   */\\n  function setLiquidationReward(uint256 _liquidationReward) external;\\n\\n  /**\\n   * @notice Returns fee percentage set by the maintainer\\n   * @return Fee percentage\\n   */\\n  function feePercentage() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns fee recipients info\\n   * @return Addresses, weigths and total of weigths\\n   */\\n  function feeRecipientsInfo()\\n    external\\n    view\\n    returns (\\n      address[] memory,\\n      uint32[] memory,\\n      uint256\\n    );\\n\\n  /**\\n   * @notice Returns total number of synthetic tokens generated by this pool\\n   * @return Number of synthetic tokens\\n   */\\n  function totalSyntheticTokens() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the total amount of collateral used for collateralizing tokens (users + LP)\\n   * @return Total collateral amount\\n   */\\n  function totalCollateralAmount() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the total amount of fees to be withdrawn\\n   * @return Total fee amount\\n   */\\n  function totalFeeAmount() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the user's fee to be withdrawn\\n   * @param user User's address\\n   * @return User's fee\\n   */\\n  function userFee(address user) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the percentage of overcollateralization to which a liquidation can triggered\\n   * @return Percentage of overcollateralization\\n   */\\n  function collateralRequirement() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the percentage of reward for correct liquidation by a liquidator\\n   * @return Percentage of reward\\n   */\\n  function liquidationReward() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the price of the pair at the moment of the shutdown\\n   * @return Price of the pair\\n   */\\n  function emergencyShutdownPrice() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the timestamp (unix time) at the moment of the shutdown\\n   * @return Timestamp\\n   */\\n  function emergencyShutdownTimestamp() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns if position is overcollateralized and thepercentage of coverage of the collateral according to the last price\\n   * @return True if position is overcollaterlized, otherwise false + percentage of coverage (totalCollateralAmount / (price * tokensCollateralized))\\n   */\\n  function collateralCoverage() external returns (bool, uint256);\\n\\n  /**\\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param inputCollateral Input collateral amount to be exchanged\\n   * @return synthTokensReceived Synthetic tokens will be minted\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getMintTradeInfo(uint256 inputCollateral)\\n    external\\n    view\\n    returns (uint256 synthTokensReceived, uint256 feePaid);\\n\\n  /**\\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @return collateralAmountReceived Collateral amount will be received by the user\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getRedeemTradeInfo(uint256 syntheticTokens)\\n    external\\n    view\\n    returns (uint256 collateralAmountReceived, uint256 feePaid);\\n\\n  /**\\n   * @notice Returns the destination synthetic tokens amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @param  destinationPool Pool in which mint the destination synthetic token\\n   * @return destSyntheticTokensReceived Synthetic tokens will be received from destination pool\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getExchangeTradeInfo(\\n    uint256 syntheticTokens,\\n    ISynthereumLiquidityPoolGeneral destinationPool\\n  )\\n    external\\n    view\\n    returns (uint256 destSyntheticTokensReceived, uint256 feePaid);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v5/interfaces/ILiquidityPoolGeneral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {\\n  ISynthereumLiquidityPoolInteraction\\n} from './ILiquidityPoolInteraction.sol';\\nimport {\\n  ISynthereumDeployment\\n} from '../../../common/interfaces/IDeployment.sol';\\n\\ninterface ISynthereumLiquidityPoolGeneral is\\n  ISynthereumDeployment,\\n  ISynthereumLiquidityPoolInteraction\\n{}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v5/LiquidityPoolLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {\\n  ISynthereumLiquidityPoolStorage\\n} from './interfaces/ILiquidityPoolStorage.sol';\\nimport {ISynthereumLiquidityPool} from './interfaces/ILiquidityPool.sol';\\nimport {\\n  FixedPoint\\n} from '../../../@uma/core/contracts/common/implementation/FixedPoint.sol';\\nimport {IStandardERC20} from '../../base/interfaces/IStandardERC20.sol';\\nimport {\\n  IMintableBurnableERC20\\n} from '../../tokens/interfaces/IMintableBurnableERC20.sol';\\nimport {ISynthereumFinder} from '../../core/interfaces/IFinder.sol';\\nimport {\\n  ISynthereumRegistry\\n} from '../../core/registries/interfaces/IRegistry.sol';\\nimport {\\n  ISynthereumPriceFeed\\n} from '../../oracle/common/interfaces/IPriceFeed.sol';\\nimport {\\n  ISynthereumLiquidityPoolGeneral\\n} from './interfaces/ILiquidityPoolGeneral.sol';\\nimport {SynthereumInterfaces} from '../../core/Constants.sol';\\nimport {\\n  SafeERC20\\n} from '../../../@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\\n\\n/**\\n * @notice Pool implementation is stored here to reduce deployment costs\\n */\\n\\nlibrary SynthereumLiquidityPoolLib {\\n  using FixedPoint for FixedPoint.Unsigned;\\n  using FixedPoint for uint256;\\n  using SafeERC20 for IStandardERC20;\\n  using SafeERC20 for IMintableBurnableERC20;\\n  using SynthereumLiquidityPoolLib for ISynthereumLiquidityPoolStorage.Storage;\\n  using SynthereumLiquidityPoolLib for ISynthereumLiquidityPoolStorage.LPPosition;\\n  using SynthereumLiquidityPoolLib for ISynthereumLiquidityPoolStorage.FeeStatus;\\n\\n  struct ExecuteMintParams {\\n    // Amount of synth tokens to mint\\n    FixedPoint.Unsigned numTokens;\\n    // Amount of collateral (excluding fees) needed for mint\\n    FixedPoint.Unsigned collateralAmount;\\n    // Amount of fees of collateral user must pay\\n    FixedPoint.Unsigned feeAmount;\\n    // Amount of collateral equal to collateral minted + fees\\n    FixedPoint.Unsigned totCollateralAmount;\\n    // Recipient address that will receive synthetic tokens\\n    address recipient;\\n    // Sender of the mint transaction\\n    address sender;\\n  }\\n\\n  struct ExecuteRedeemParams {\\n    //Amount of synth tokens needed for redeem\\n    FixedPoint.Unsigned numTokens;\\n    // Amount of collateral that user will receive\\n    FixedPoint.Unsigned collateralAmount;\\n    // Amount of fees of collateral user must pay\\n    FixedPoint.Unsigned feeAmount;\\n    // Amount of collateral equal to collateral redeemed + fees\\n    FixedPoint.Unsigned totCollateralAmount;\\n    // Recipient address that will receive synthetic tokens\\n    address recipient;\\n    // Sender of the redeem transaction\\n    address sender;\\n  }\\n\\n  struct ExecuteExchangeParams {\\n    // Destination pool in which mint new tokens\\n    ISynthereumLiquidityPoolGeneral destPool;\\n    // Amount of tokens to send\\n    FixedPoint.Unsigned numTokens;\\n    // Amount of collateral (excluding fees) equivalent to synthetic token (exluding fees) to send\\n    FixedPoint.Unsigned collateralAmount;\\n    // Amount of fees of collateral user must pay\\n    FixedPoint.Unsigned feeAmount;\\n    // Amount of collateral equal to collateral redemeed + fees\\n    FixedPoint.Unsigned totCollateralAmount;\\n    // Amount of synthetic token to receive\\n    FixedPoint.Unsigned destNumTokens;\\n    // Recipient address that will receive synthetic tokens\\n    address recipient;\\n    // Sender of the exchange transaction\\n    address sender;\\n  }\\n\\n  struct ExecuteSettlement {\\n    // Price of emergency shutdown\\n    FixedPoint.Unsigned emergencyPrice;\\n    // Amount of synthtic tokens to be liquidated\\n    FixedPoint.Unsigned userNumTokens;\\n    // Total amount of collateral (excluding unused and fees) deposited\\n    FixedPoint.Unsigned totalCollateralAmount;\\n    // Total amount of synthetic tokens\\n    FixedPoint.Unsigned tokensCollaterlized;\\n    // Total actual amount of fees to be withdrawn\\n    FixedPoint.Unsigned totalFeeAmount;\\n    // Overcollateral to be withdrawn by Lp (0 if standard user)\\n    FixedPoint.Unsigned overCollateral;\\n    // Amount of collateral which value is equal to the synthetic tokens value according to the emergency price\\n    FixedPoint.Unsigned totalRedeemableCollateral;\\n    // Exepected amount of collateral\\n    FixedPoint.Unsigned redeemableCollateral;\\n    // Collateral deposited but not used to collateralize\\n    FixedPoint.Unsigned unusedCollateral;\\n    // Amount of collateral settled to the sender\\n    FixedPoint.Unsigned transferableCollateral;\\n  }\\n\\n  struct ExecuteLiquidation {\\n    // Total amount of collateral in the Lp position\\n    FixedPoint.Unsigned totalCollateralAmount;\\n    // Total number of tokens collateralized in the Lp position\\n    FixedPoint.Unsigned tokensCollateralized;\\n    // Total number of tokens in liquidation\\n    FixedPoint.Unsigned tokensInLiquidation;\\n    // Amount of collateral used to collateralize user's tokens\\n    FixedPoint.Unsigned userCollateralization;\\n    // Available liquidity in the pool\\n    FixedPoint.Unsigned unusedCollateral;\\n    // Expected collateral received by the user according to the actual price\\n    FixedPoint.Unsigned expectedCollateral;\\n    // Collateral amount receieved by the user\\n    FixedPoint.Unsigned settledCollateral;\\n    // Reward amount received by the user\\n    FixedPoint.Unsigned rewardAmount;\\n    // Price rate at the moment of the liquidation\\n    FixedPoint.Unsigned priceRate;\\n  }\\n\\n  //----------------------------------------\\n  // Events\\n  //----------------------------------------\\n\\n  event Mint(\\n    address indexed account,\\n    uint256 collateralSent,\\n    uint256 numTokensReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event Redeem(\\n    address indexed account,\\n    uint256 numTokensSent,\\n    uint256 collateralReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event Exchange(\\n    address indexed account,\\n    address indexed destPool,\\n    uint256 numTokensSent,\\n    uint256 destNumTokensReceived,\\n    uint256 feePaid,\\n    address recipient\\n  );\\n\\n  event WithdrawLiquidity(\\n    address indexed lp,\\n    uint256 liquidityWithdrawn,\\n    uint256 remainingLiquidity\\n  );\\n\\n  event IncreaseCollateral(\\n    address indexed lp,\\n    uint256 collateralAdded,\\n    uint256 newTotalCollateral\\n  );\\n\\n  event DecreaseCollateral(\\n    address indexed lp,\\n    uint256 collateralRemoved,\\n    uint256 newTotalCollateral\\n  );\\n\\n  event ClaimFee(\\n    address indexed claimer,\\n    uint256 feeAmount,\\n    uint256 totalRemainingFees\\n  );\\n\\n  event Liquidate(\\n    address indexed liquidator,\\n    uint256 tokensLiquidated,\\n    uint256 price,\\n    uint256 collateralExpected,\\n    uint256 collateralReceived,\\n    uint256 rewardReceived\\n  );\\n\\n  event EmergencyShutdown(\\n    uint256 timestamp,\\n    uint256 price,\\n    uint256 finalCollateral\\n  );\\n\\n  event Settle(\\n    address indexed account,\\n    uint256 numTokensSettled,\\n    uint256 collateralExpected,\\n    uint256 collateralSettled\\n  );\\n\\n  event SetFeePercentage(uint256 feePercentage);\\n\\n  event SetFeeRecipients(address[] feeRecipients, uint32[] feeProportions);\\n\\n  event SetOverCollateralization(uint256 overCollateralization);\\n\\n  event SetLiquidationReward(uint256 liquidationReward);\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Initializes a liquidity pool\\n   * @param self Data type the library is attached to\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param _finder The Synthereum finder\\n   * @param _version Synthereum version\\n   * @param _collateralToken ERC20 collateral token\\n   * @param _syntheticToken ERC20 synthetic token\\n   * @param _overCollateralization Over-collateralization ratio\\n   * @param _priceIdentifier Identifier of price to be used in the price feed\\n   * @param _collateralRequirement Percentage of overcollateralization to which a liquidation can triggered\\n   * @param _liquidationReward Percentage of reward for correct liquidation by a liquidator\\n   */\\n  function initialize(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    ISynthereumFinder _finder,\\n    uint8 _version,\\n    IStandardERC20 _collateralToken,\\n    IMintableBurnableERC20 _syntheticToken,\\n    FixedPoint.Unsigned calldata _overCollateralization,\\n    bytes32 _priceIdentifier,\\n    FixedPoint.Unsigned calldata _collateralRequirement,\\n    FixedPoint.Unsigned calldata _liquidationReward\\n  ) external {\\n    require(\\n      _collateralRequirement.isGreaterThan(1),\\n      'Collateral requirement must be bigger than 100%'\\n    );\\n\\n    require(\\n      _overCollateralization.isGreaterThan(_collateralRequirement.sub(1)),\\n      'Overcollateralization must be bigger than the Lp part of the collateral requirement'\\n    );\\n\\n    require(\\n      _liquidationReward.rawValue > 0 &&\\n        _liquidationReward.isLessThanOrEqual(1),\\n      'Liquidation reward must be between 0 and 100%'\\n    );\\n\\n    require(\\n      _collateralToken.decimals() <= 18,\\n      'Collateral has more than 18 decimals'\\n    );\\n\\n    require(\\n      _syntheticToken.decimals() == 18,\\n      'Synthetic token has more or less than 18 decimals'\\n    );\\n\\n    ISynthereumPriceFeed priceFeed =\\n      ISynthereumPriceFeed(\\n        _finder.getImplementationAddress(SynthereumInterfaces.PriceFeed)\\n      );\\n\\n    require(\\n      priceFeed.isPriceSupported(_priceIdentifier),\\n      'Price identifier not supported'\\n    );\\n\\n    self.finder = _finder;\\n    self.version = _version;\\n    self.collateralToken = _collateralToken;\\n    self.syntheticToken = _syntheticToken;\\n    self.overCollateralization = _overCollateralization;\\n    self.priceIdentifier = _priceIdentifier;\\n    liquidationData.collateralRequirement = _collateralRequirement;\\n    liquidationData.liquidationReward = _liquidationReward;\\n  }\\n\\n  /**\\n   * @notice Mint synthetic tokens using fixed amount of collateral\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve collateral transfer for the mint request to succeed\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param mintParams Input parameters for minting (see MintParams struct)\\n   * @param sender Sender of the mint transaction\\n   * @return syntheticTokensMinted Amount of synthetic tokens minted by a user\\n   * @return feePaid Amount of collateral paid by the user as fee\\n   */\\n  function mint(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPool.MintParams calldata mintParams,\\n    address sender\\n  ) external returns (uint256 syntheticTokensMinted, uint256 feePaid) {\\n    FixedPoint.Unsigned memory totCollateralAmount =\\n      FixedPoint.Unsigned(mintParams.collateralAmount);\\n\\n    (\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory numTokens\\n    ) = self.mintCalculation(totCollateralAmount);\\n\\n    require(\\n      numTokens.rawValue >= mintParams.minNumTokens,\\n      'Number of tokens less than minimum limit'\\n    );\\n\\n    checkExpiration(mintParams.expiration);\\n\\n    self.executeMint(\\n      lpPosition,\\n      feeStatus,\\n      ExecuteMintParams(\\n        numTokens,\\n        collateralAmount,\\n        feeAmount,\\n        totCollateralAmount,\\n        mintParams.recipient,\\n        sender\\n      )\\n    );\\n\\n    syntheticTokensMinted = numTokens.rawValue;\\n    feePaid = feeAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Redeem amount of collateral using fixed number of synthetic token\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param redeemParams Input parameters for redeeming (see RedeemParams struct)\\n   * @param sender Sender of the redeem transaction\\n   * @return collateralRedeemed Amount of collateral redeem by user\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function redeem(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPool.RedeemParams calldata redeemParams,\\n    address sender\\n  ) external returns (uint256 collateralRedeemed, uint256 feePaid) {\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(redeemParams.numTokens);\\n\\n    (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory collateralAmount\\n    ) = self.redeemCalculation(numTokens);\\n\\n    require(\\n      collateralAmount.rawValue >= redeemParams.minCollateral,\\n      'Collateral amount less than minimum limit'\\n    );\\n\\n    checkExpiration(redeemParams.expiration);\\n\\n    self.executeRedeem(\\n      lpPosition,\\n      feeStatus,\\n      ExecuteRedeemParams(\\n        numTokens,\\n        collateralAmount,\\n        feeAmount,\\n        totCollateralAmount,\\n        redeemParams.recipient,\\n        sender\\n      )\\n    );\\n\\n    feePaid = feeAmount.rawValue;\\n    collateralRedeemed = collateralAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Exchange a fixed amount of synthetic token of this pool, with an amount of synthetic tokens of an another pool\\n   * @notice This calculate the price using on chain price feed\\n   * @notice User must approve synthetic token transfer for the redeem request to succeed\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param exchangeParams Input parameters for exchanging (see ExchangeParams struct)\\n   * @param sender Sender of the exchange transaction\\n   * @return destNumTokensMinted Amount of synthetic token minted in the destination pool\\n   * @return feePaid Amount of collateral paid by user as fee\\n   */\\n  function exchange(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPool.ExchangeParams calldata exchangeParams,\\n    address sender\\n  ) external returns (uint256 destNumTokensMinted, uint256 feePaid) {\\n    FixedPoint.Unsigned memory numTokens =\\n      FixedPoint.Unsigned(exchangeParams.numTokens);\\n\\n    (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory destNumTokens\\n    ) = self.exchangeCalculation(numTokens, exchangeParams.destPool);\\n\\n    require(\\n      destNumTokens.rawValue >= exchangeParams.minDestNumTokens,\\n      'Number of destination tokens less than minimum limit'\\n    );\\n\\n    checkExpiration(exchangeParams.expiration);\\n\\n    self.executeExchange(\\n      lpPosition,\\n      feeStatus,\\n      ExecuteExchangeParams(\\n        exchangeParams.destPool,\\n        numTokens,\\n        collateralAmount,\\n        feeAmount,\\n        totCollateralAmount,\\n        destNumTokens,\\n        exchangeParams.recipient,\\n        sender\\n      )\\n    );\\n\\n    destNumTokensMinted = destNumTokens.rawValue;\\n    feePaid = feeAmount.rawValue;\\n  }\\n\\n  /**\\n   * @notice Called by a source Pool's `exchange` function to mint destination tokens\\n   * @notice This functon can be called only by a pool registered in the deployer\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralAmount The amount of collateral to use from the source Pool\\n   * @param numTokens The number of new tokens to mint\\n   * @param recipient Recipient to which send synthetic token minted\\n   */\\n  function exchangeMint(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata collateralAmount,\\n    FixedPoint.Unsigned calldata numTokens,\\n    address recipient\\n  ) external {\\n    self.checkPool(ISynthereumLiquidityPoolGeneral(msg.sender));\\n\\n    // Sending amount must be different from 0\\n    require(\\n      collateralAmount.rawValue > 0,\\n      'Sending collateral amount is equal to 0'\\n    );\\n\\n    // Collateral available\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        collateralAmount\\n      );\\n\\n    // Update LP's collateralization status\\n    FixedPoint.Unsigned memory overCollateral =\\n      lpPosition.updateLpPositionInMint(\\n        self.overCollateralization,\\n        collateralAmount,\\n        numTokens\\n      );\\n\\n    //Check there is enough liquidity in the pool for overcollateralization\\n    require(\\n      unusedCollateral.isGreaterThanOrEqual(overCollateral),\\n      'No enough liquidity for cover mint operation'\\n    );\\n\\n    // Mint synthetic asset and transfer to the recipient\\n    self.syntheticToken.mint(recipient, numTokens.rawValue);\\n  }\\n\\n  /**\\n   * @notice Withdraw unused deposited collateral by the LP\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralAmount Collateral to be withdrawn\\n   * @param sender Sender of the withdrawLiquidity transaction\\n   * @return remainingLiquidity Remaining unused collateral in the pool\\n   */\\n  function withdrawLiquidity(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata collateralAmount,\\n    address sender\\n  ) external returns (uint256 remainingLiquidity) {\\n    remainingLiquidity = self._withdrawLiquidity(\\n      lpPosition,\\n      feeStatus,\\n      collateralAmount,\\n      sender\\n    );\\n  }\\n\\n  /**\\n   * @notice Increase collaterallization of Lp position\\n   * @notice Only a sender with LP role can call this function\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralToTransfer Collateral to be transferred before increase collateral in the position\\n   * @param collateralToIncrease Collateral to be added to the position\\n   * @param sender Sender of the increaseCollateral transaction\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function increaseCollateral(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata collateralToTransfer,\\n    FixedPoint.Unsigned calldata collateralToIncrease,\\n    address sender\\n  ) external returns (uint256 newTotalCollateral) {\\n    // Check the collateral to be increased is not 0\\n    require(collateralToIncrease.rawValue > 0, 'No collateral to be increased');\\n\\n    // Deposit collateral in the pool\\n    if (collateralToTransfer.rawValue > 0) {\\n      self.pullCollateral(sender, collateralToTransfer);\\n    }\\n\\n    // Collateral available\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    // Check that there is enoush availabe collateral deposited in the pool\\n    require(\\n      unusedCollateral.isGreaterThanOrEqual(collateralToIncrease),\\n      'No enough liquidity for increasing collateral'\\n    );\\n\\n    // Update new total collateral amount\\n    FixedPoint.Unsigned memory _newTotalCollateral =\\n      lpPosition.totalCollateralAmount.add(collateralToIncrease);\\n\\n    lpPosition.totalCollateralAmount = _newTotalCollateral;\\n\\n    newTotalCollateral = _newTotalCollateral.rawValue;\\n\\n    emit IncreaseCollateral(\\n      sender,\\n      collateralToIncrease.rawValue,\\n      newTotalCollateral\\n    );\\n  }\\n\\n  /**\\n   * @notice Decrease collaterallization of Lp position\\n   * @notice Check that final position is not undercollateralized\\n   * @notice Only a sender with LP role can call this function\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralToDecrease Collateral to decreased from the position\\n   * @param collateralToWithdraw Collateral to be transferred to the LP\\n   * @param sender Sender of the decreaseCollateral transaction\\n   * @return newTotalCollateral New total collateral amount\\n   */\\n  function decreaseCollateral(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata collateralToDecrease,\\n    FixedPoint.Unsigned calldata collateralToWithdraw,\\n    address sender\\n  ) external returns (uint256 newTotalCollateral) {\\n    // Check that collateral to be decreased is not 0\\n    require(collateralToDecrease.rawValue > 0, 'No collateral to be decreased');\\n\\n    // Resulting total collateral amount\\n    FixedPoint.Unsigned memory _newTotalCollateral =\\n      lpPosition.totalCollateralAmount.sub(collateralToDecrease);\\n\\n    // Check that position doesn't become undercollateralized\\n    (bool _isOverCollateralized, , ) =\\n      lpPosition.isOverCollateralized(\\n        liquidationData,\\n        getPriceFeedRate(self.finder, self.priceIdentifier),\\n        getCollateralDecimals(self.collateralToken),\\n        _newTotalCollateral\\n      );\\n\\n    require(_isOverCollateralized, 'Position undercollateralized');\\n\\n    // Update new total collateral amount\\n    lpPosition.totalCollateralAmount = _newTotalCollateral;\\n\\n    newTotalCollateral = _newTotalCollateral.rawValue;\\n\\n    emit DecreaseCollateral(\\n      sender,\\n      collateralToDecrease.rawValue,\\n      newTotalCollateral\\n    );\\n\\n    if (collateralToWithdraw.rawValue > 0) {\\n      self._withdrawLiquidity(\\n        lpPosition,\\n        feeStatus,\\n        collateralToWithdraw,\\n        sender\\n      );\\n    }\\n  }\\n\\n  /**\\n   * @notice Withdraw fees gained by the sender\\n   * @param self Data type the library is attached to\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param sender Sender of the claimFee transaction\\n   * @return feeClaimed Amount of fee claimed\\n   */\\n  function claimFee(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    address sender\\n  ) external returns (uint256 feeClaimed) {\\n    // Fee to claim\\n    FixedPoint.Unsigned memory _feeClaimed = feeStatus.feeGained[sender];\\n    feeClaimed = _feeClaimed.rawValue;\\n\\n    // Check that fee is available\\n    require(feeClaimed > 0, 'No fee to claim');\\n\\n    // Update fee status\\n    delete feeStatus.feeGained[sender];\\n\\n    FixedPoint.Unsigned memory _totalRemainingFees =\\n      feeStatus.totalFeeAmount.sub(_feeClaimed);\\n\\n    feeStatus.totalFeeAmount = _totalRemainingFees;\\n\\n    // Transfer amount to the sender\\n    self.collateralToken.safeTransfer(sender, feeClaimed);\\n\\n    emit ClaimFee(sender, feeClaimed, _totalRemainingFees.rawValue);\\n  }\\n\\n  /**\\n   * @notice Liquidate Lp position for an amount of synthetic tokens undercollateralized\\n   * @notice Revert if position is not undercollateralized\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param numSynthTokens Number of synthetic tokens that user wants to liquidate\\n   * @param sender Sender of the liquidation transaction\\n   * @return synthTokensLiquidated Amount of synthetic tokens liquidated\\n   * @return collateralReceived Amount of received collateral equal to the value of tokens liquidated\\n   * @return rewardAmount Amount of received collateral as reward for the liquidation\\n   */\\n  function liquidate(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata numSynthTokens,\\n    address sender\\n  )\\n    external\\n    returns (\\n      uint256 synthTokensLiquidated,\\n      uint256 collateralReceived,\\n      uint256 rewardAmount\\n    )\\n  {\\n    // Memory struct for saving local varibales\\n    ExecuteLiquidation memory executeLiquidation;\\n\\n    executeLiquidation.totalCollateralAmount = lpPosition.totalCollateralAmount;\\n\\n    executeLiquidation.priceRate = getPriceFeedRate(\\n      self.finder,\\n      self.priceIdentifier\\n    );\\n\\n    uint8 collateralDecimals = getCollateralDecimals(self.collateralToken);\\n\\n    // Collateral value of the synthetic token passed\\n    {\\n      (bool _isOverCollaterlized, , ) =\\n        lpPosition.isOverCollateralized(\\n          liquidationData,\\n          executeLiquidation.priceRate,\\n          collateralDecimals,\\n          executeLiquidation.totalCollateralAmount\\n        );\\n\\n      // Revert if position is not undercollataralized\\n      require(!_isOverCollaterlized, 'Position is overcollateralized');\\n    }\\n\\n    IStandardERC20 _collateralToken = self.collateralToken;\\n\\n    executeLiquidation.tokensCollateralized = lpPosition.tokensCollateralized;\\n\\n    executeLiquidation.tokensInLiquidation = FixedPoint.min(\\n      numSynthTokens,\\n      executeLiquidation.tokensCollateralized\\n    );\\n\\n    executeLiquidation.expectedCollateral = calculateCollateralAmount(\\n      executeLiquidation.priceRate,\\n      collateralDecimals,\\n      executeLiquidation.tokensInLiquidation\\n    );\\n\\n    executeLiquidation.userCollateralization = executeLiquidation\\n      .tokensInLiquidation\\n      .div(executeLiquidation.tokensCollateralized)\\n      .mul(executeLiquidation.totalCollateralAmount);\\n\\n    if (\\n      executeLiquidation.userCollateralization.isGreaterThanOrEqual(\\n        executeLiquidation.expectedCollateral\\n      )\\n    ) {\\n      executeLiquidation.settledCollateral = executeLiquidation\\n        .expectedCollateral;\\n      executeLiquidation.rewardAmount = executeLiquidation\\n        .userCollateralization\\n        .sub(executeLiquidation.expectedCollateral)\\n        .mul(liquidationData.liquidationReward);\\n\\n      // Update Lp position\\n      lpPosition.totalCollateralAmount = executeLiquidation\\n        .totalCollateralAmount\\n        .sub(executeLiquidation.settledCollateral)\\n        .sub(executeLiquidation.rewardAmount);\\n    } else {\\n      executeLiquidation.unusedCollateral = self.calculateUnusedCollateral(\\n        executeLiquidation.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n      executeLiquidation.settledCollateral = FixedPoint.min(\\n        executeLiquidation.expectedCollateral,\\n        executeLiquidation.userCollateralization.add(\\n          executeLiquidation.unusedCollateral\\n        )\\n      );\\n\\n      // Update Lp position untill max 105% coverage using available liquidity\\n      lpPosition.totalCollateralAmount = FixedPoint.min(\\n        executeLiquidation\\n          .totalCollateralAmount\\n          .add(executeLiquidation.unusedCollateral)\\n          .sub(executeLiquidation.settledCollateral),\\n        calculateCollateralAmount(\\n          executeLiquidation\\n            .priceRate,\\n          collateralDecimals,\\n          executeLiquidation.tokensCollateralized.sub(\\n            executeLiquidation.tokensInLiquidation\\n          )\\n        )\\n          .mul(liquidationData.collateralRequirement)\\n      );\\n    }\\n\\n    lpPosition.tokensCollateralized = executeLiquidation\\n      .tokensCollateralized\\n      .sub(executeLiquidation.tokensInLiquidation);\\n\\n    collateralReceived = executeLiquidation.settledCollateral.rawValue;\\n\\n    rewardAmount = executeLiquidation.rewardAmount.rawValue;\\n\\n    synthTokensLiquidated = executeLiquidation.tokensInLiquidation.rawValue;\\n\\n    // Burn synthetic tokens to be liquidated\\n    self.burnSyntheticTokens(synthTokensLiquidated, sender);\\n\\n    // Transfer liquidated collateral and reward to the user\\n    _collateralToken.safeTransfer(sender, collateralReceived + rewardAmount);\\n\\n    emit Liquidate(\\n      sender,\\n      synthTokensLiquidated,\\n      executeLiquidation.priceRate.rawValue,\\n      executeLiquidation.expectedCollateral.rawValue,\\n      collateralReceived,\\n      rewardAmount\\n    );\\n  }\\n\\n  /**\\n   * @notice Shutdown the pool in case of emergency\\n   * @notice Only Synthereum manager contract can call this function\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param emergencyShutdownData Emergency shutdown info (see Shutdown struct)\\n   * @return timestamp Timestamp of emergency shutdown transaction\\n   * @return price Price of the pair at the moment of shutdown execution\\n   */\\n  function emergencyShutdown(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPoolStorage.Shutdown storage emergencyShutdownData\\n  ) external returns (uint256 timestamp, uint256 price) {\\n    ISynthereumFinder _finder = self.finder;\\n\\n    require(\\n      msg.sender ==\\n        _finder.getImplementationAddress(SynthereumInterfaces.Manager),\\n      'Caller must be the Synthereum manager'\\n    );\\n\\n    timestamp = block.timestamp;\\n\\n    emergencyShutdownData.timestamp = timestamp;\\n\\n    FixedPoint.Unsigned memory _price =\\n      getPriceFeedRate(_finder, self.priceIdentifier);\\n\\n    emergencyShutdownData.price = _price;\\n\\n    price = _price.rawValue;\\n\\n    // Move available liquidity in the position\\n    FixedPoint.Unsigned memory totalCollateral =\\n      lpPosition.totalCollateralAmount;\\n\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        totalCollateral,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    FixedPoint.Unsigned memory finalCollateral =\\n      totalCollateral.add(unusedCollateral);\\n\\n    lpPosition.totalCollateralAmount = finalCollateral;\\n\\n    emit EmergencyShutdown(timestamp, price, finalCollateral.rawValue);\\n  }\\n\\n  /**\\n   * @notice Redeem tokens after emergency shutdown\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param emergencyShutdownData Emergency shutdown info (see Shutdown struct)\\n   * @param isLiquidityProvider True if the sender is an LP, otherwise false\\n   * @param sender Sender of the settleEmergencyShutdown transaction\\n   * @return synthTokensSettled Amount of synthetic tokens liquidated\\n   * @return collateralSettled Amount of collateral withdrawn after emergency shutdown\\n   */\\n  function settleEmergencyShutdown(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPoolStorage.Shutdown storage emergencyShutdownData,\\n    bool isLiquidityProvider,\\n    address sender\\n  ) external returns (uint256 synthTokensSettled, uint256 collateralSettled) {\\n    // Memory struct for saving local varibales\\n    ExecuteSettlement memory executeSettlement;\\n\\n    IMintableBurnableERC20 syntheticToken = self.syntheticToken;\\n\\n    executeSettlement.emergencyPrice = emergencyShutdownData.price;\\n\\n    executeSettlement.userNumTokens = FixedPoint.Unsigned(\\n      syntheticToken.balanceOf(sender)\\n    );\\n\\n    require(\\n      executeSettlement.userNumTokens.rawValue > 0 || isLiquidityProvider,\\n      'Sender has nothing to settle'\\n    );\\n\\n    if (executeSettlement.userNumTokens.rawValue > 0) {\\n      // Move synthetic tokens from the user to the pool\\n      // - This is because derivative expects the tokens to come from the sponsor address\\n      syntheticToken.safeTransferFrom(\\n        sender,\\n        address(this),\\n        executeSettlement.userNumTokens.rawValue\\n      );\\n    }\\n\\n    executeSettlement.totalCollateralAmount = lpPosition.totalCollateralAmount;\\n    executeSettlement.tokensCollaterlized = lpPosition.tokensCollateralized;\\n    executeSettlement.totalFeeAmount = feeStatus.totalFeeAmount;\\n    executeSettlement.overCollateral;\\n\\n    IStandardERC20 _collateralToken = self.collateralToken;\\n\\n    uint8 collateralDecimals = getCollateralDecimals(_collateralToken);\\n\\n    // Add overcollateral and deposited synthetic tokens if the sender is the LP\\n    if (isLiquidityProvider) {\\n      FixedPoint.Unsigned memory totalRedeemableCollateral =\\n        calculateCollateralAmount(\\n          executeSettlement.emergencyPrice,\\n          collateralDecimals,\\n          executeSettlement.tokensCollaterlized\\n        );\\n\\n      executeSettlement.overCollateral = executeSettlement\\n        .totalCollateralAmount\\n        .isGreaterThan(totalRedeemableCollateral)\\n        ? executeSettlement.totalCollateralAmount.sub(totalRedeemableCollateral)\\n        : FixedPoint.Unsigned(0);\\n\\n      executeSettlement.userNumTokens = FixedPoint.Unsigned(\\n        syntheticToken.balanceOf(address(this))\\n      );\\n    }\\n\\n    // Calculate expected and settled collateral\\n    executeSettlement.redeemableCollateral = calculateCollateralAmount(\\n      executeSettlement\\n        .emergencyPrice,\\n      collateralDecimals,\\n      executeSettlement\\n        .userNumTokens\\n    )\\n      .add(executeSettlement.overCollateral);\\n\\n    executeSettlement.unusedCollateral = self.calculateUnusedCollateral(\\n      executeSettlement.totalCollateralAmount,\\n      executeSettlement.totalFeeAmount,\\n      FixedPoint.Unsigned(0)\\n    );\\n\\n    executeSettlement.transferableCollateral = FixedPoint.min(\\n      executeSettlement.redeemableCollateral,\\n      executeSettlement.totalCollateralAmount\\n    );\\n\\n    // Update Lp position\\n    lpPosition.totalCollateralAmount = executeSettlement\\n      .totalCollateralAmount\\n      .isGreaterThan(executeSettlement.redeemableCollateral)\\n      ? executeSettlement.totalCollateralAmount.sub(\\n        executeSettlement.redeemableCollateral\\n      )\\n      : FixedPoint.Unsigned(0);\\n\\n    lpPosition.tokensCollateralized = executeSettlement.tokensCollaterlized.sub(\\n      executeSettlement.userNumTokens\\n    );\\n\\n    synthTokensSettled = executeSettlement.userNumTokens.rawValue;\\n\\n    collateralSettled = executeSettlement.transferableCollateral.rawValue;\\n\\n    // Burn synthetic tokens\\n    syntheticToken.burn(synthTokensSettled);\\n\\n    // Transfer settled collateral to the user\\n    _collateralToken.safeTransfer(sender, collateralSettled);\\n\\n    emit Settle(\\n      sender,\\n      synthTokensSettled,\\n      executeSettlement.redeemableCollateral.rawValue,\\n      collateralSettled\\n    );\\n  }\\n\\n  /**\\n   * @notice Update the fee percentage\\n   * @param self Data type the library is attached to\\n   * @param _feePercentage The new fee percentage\\n   */\\n  function setFeePercentage(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned calldata _feePercentage\\n  ) external {\\n    require(\\n      _feePercentage.rawValue < 10**(18),\\n      'Fee Percentage must be less than 100%'\\n    );\\n\\n    self.fee.feeData.feePercentage = _feePercentage;\\n\\n    emit SetFeePercentage(_feePercentage.rawValue);\\n  }\\n\\n  /**\\n   * @notice Update the addresses of recipients for generated fees and proportions of fees each address will receive\\n   * @param self Data type the library is attached to\\n   * @param _feeRecipients An array of the addresses of recipients that will receive generated fees\\n   * @param _feeProportions An array of the proportions of fees generated each recipient will receive\\n   */\\n  function setFeeRecipients(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    address[] calldata _feeRecipients,\\n    uint32[] calldata _feeProportions\\n  ) external {\\n    require(\\n      _feeRecipients.length == _feeProportions.length,\\n      'Fee recipients and fee proportions do not match'\\n    );\\n\\n    uint256 totalActualFeeProportions;\\n\\n    // Store the sum of all proportions\\n    for (uint256 i = 0; i < _feeProportions.length; i++) {\\n      totalActualFeeProportions += _feeProportions[i];\\n    }\\n\\n    ISynthereumLiquidityPoolStorage.FeeData storage _feeData = self.fee.feeData;\\n\\n    _feeData.feeRecipients = _feeRecipients;\\n    _feeData.feeProportions = _feeProportions;\\n    self.fee.totalFeeProportions = totalActualFeeProportions;\\n\\n    emit SetFeeRecipients(_feeRecipients, _feeProportions);\\n  }\\n\\n  /**\\n   * @notice Update the overcollateralization percentage\\n   * @param self Data type the library is attached to\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param _overCollateralization Overcollateralization percentage\\n   */\\n  function setOverCollateralization(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    FixedPoint.Unsigned calldata _overCollateralization\\n  ) external {\\n    require(\\n      _overCollateralization.isGreaterThan(\\n        liquidationData.collateralRequirement.sub(1)\\n      ),\\n      'Overcollateralization must be bigger than the Lp part of the collateral requirement'\\n    );\\n\\n    self.overCollateralization = _overCollateralization;\\n\\n    emit SetOverCollateralization(_overCollateralization.rawValue);\\n  }\\n\\n  /**\\n   * @notice Update the liquidation reward percentage\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param _liquidationReward Percentage of reward for correct liquidation by a liquidator\\n   */\\n  function setLiquidationReward(\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    FixedPoint.Unsigned calldata _liquidationReward\\n  ) external {\\n    require(\\n      _liquidationReward.rawValue > 0 &&\\n        _liquidationReward.isLessThanOrEqual(1),\\n      'Liquidation reward must be between 0 and 100%'\\n    );\\n\\n    liquidationData.liquidationReward = _liquidationReward;\\n\\n    emit SetLiquidationReward(_liquidationReward.rawValue);\\n  }\\n\\n  //----------------------------------------\\n  // External view functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Returns the total amount of liquidity deposited in the pool, but nut used as collateral\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @return Total available liquidity\\n   */\\n  function totalAvailableLiquidity(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus\\n  ) external view returns (uint256) {\\n    return\\n      self\\n        .calculateUnusedCollateral(\\n        lpPosition\\n          .totalCollateralAmount,\\n        feeStatus\\n          .totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      )\\n        .rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns if position is overcollateralized and thepercentage of coverage of the collateral according to the last price\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @return True if position is overcollaterlized, otherwise false + percentage of coverage (totalCollateralAmount / (price * tokensCollateralized))\\n   */\\n  function collateralCoverage(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData\\n  ) external view returns (bool, uint256) {\\n    FixedPoint.Unsigned memory priceRate =\\n      getPriceFeedRate(self.finder, self.priceIdentifier);\\n\\n    uint8 collateralDecimals = getCollateralDecimals(self.collateralToken);\\n\\n    (\\n      bool _isOverCollateralized,\\n      ,\\n      FixedPoint.Unsigned memory overCollateralValue\\n    ) =\\n      lpPosition.isOverCollateralized(\\n        liquidationData,\\n        priceRate,\\n        collateralDecimals,\\n        lpPosition.totalCollateralAmount\\n      );\\n\\n    FixedPoint.Unsigned memory coverageRatio =\\n      lpPosition.totalCollateralAmount.div(overCollateralValue);\\n\\n    FixedPoint.Unsigned memory _collateralCoverage =\\n      liquidationData.collateralRequirement.mul(coverageRatio);\\n\\n    return (_isOverCollateralized, _collateralCoverage.rawValue);\\n  }\\n\\n  /**\\n   * @notice Returns the synthetic tokens will be received and fees will be paid in exchange for an input collateral amount\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param inputCollateral Input collateral amount to be exchanged\\n   * @return synthTokensReceived Synthetic tokens will be minted\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getMintTradeInfo(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned calldata inputCollateral\\n  ) external view returns (uint256 synthTokensReceived, uint256 feePaid) {\\n    (\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory _feePaid,\\n      FixedPoint.Unsigned memory _synthTokensReceived\\n    ) = self.mintCalculation(inputCollateral);\\n\\n    require(\\n      collateralAmount.rawValue > 0,\\n      'Sending collateral amount is equal to 0'\\n    );\\n\\n    FixedPoint.Unsigned memory overCollateral =\\n      collateralAmount.mul(self.overCollateralization);\\n\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    require(\\n      unusedCollateral.isGreaterThanOrEqual(overCollateral),\\n      'No enough liquidity for covering mint operation'\\n    );\\n\\n    synthTokensReceived = _synthTokensReceived.rawValue;\\n    feePaid = _feePaid.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the collateral amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @return collateralAmountReceived Collateral amount will be received by the user\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getRedeemTradeInfo(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    FixedPoint.Unsigned calldata syntheticTokens\\n  ) external view returns (uint256 collateralAmountReceived, uint256 feePaid) {\\n    FixedPoint.Unsigned memory totalActualTokens =\\n      lpPosition.tokensCollateralized;\\n\\n    require(\\n      syntheticTokens.rawValue > 0,\\n      'Sending tokens amount is equal to 0'\\n    );\\n\\n    require(\\n      syntheticTokens.isLessThanOrEqual(totalActualTokens),\\n      'Sending tokens amount bigger than amount in the position'\\n    );\\n\\n    (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory _feePaid,\\n      FixedPoint.Unsigned memory _collateralAmountReceived\\n    ) = self.redeemCalculation(syntheticTokens);\\n\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      syntheticTokens.div(totalActualTokens).mul(\\n        lpPosition.totalCollateralAmount\\n      );\\n\\n    require(\\n      collateralRedeemed.isGreaterThanOrEqual(totCollateralAmount),\\n      'Position undercapitalized'\\n    );\\n\\n    collateralAmountReceived = _collateralAmountReceived.rawValue;\\n    feePaid = _feePaid.rawValue;\\n  }\\n\\n  /**\\n   * @notice Returns the destination synthetic tokens amount will be received and fees will be paid in exchange for an input amount of synthetic tokens\\n   * @notice This function is only trading-informative, it doesn't check liquidity and collateralization conditions\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param  syntheticTokens Amount of synthetic tokens to be exchanged\\n   * @param  destinationPool Pool in which mint the destination synthetic token\\n   * @return destSyntheticTokensReceived Synthetic tokens will be received from destination pool\\n   * @return feePaid Collateral fee will be paid\\n   */\\n  function getExchangeTradeInfo(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    FixedPoint.Unsigned calldata syntheticTokens,\\n    ISynthereumLiquidityPoolGeneral destinationPool\\n  )\\n    external\\n    view\\n    returns (uint256 destSyntheticTokensReceived, uint256 feePaid)\\n  {\\n    self.checkPool(destinationPool);\\n\\n    require(\\n      address(this) != address(destinationPool),\\n      'Same source and destination pool'\\n    );\\n\\n    FixedPoint.Unsigned memory totalActualTokens =\\n      lpPosition.tokensCollateralized;\\n\\n    require(\\n      syntheticTokens.rawValue > 0,\\n      'Sending tokens amount is equal to 0'\\n    );\\n\\n    require(\\n      syntheticTokens.isLessThanOrEqual(totalActualTokens),\\n      'Sending tokens amount bigger than amount in the position'\\n    );\\n\\n    (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory _feePaid,\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory _destSyntheticTokensReceived\\n    ) = self.exchangeCalculation(syntheticTokens, destinationPool);\\n\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      syntheticTokens.div(totalActualTokens).mul(\\n        lpPosition.totalCollateralAmount\\n      );\\n\\n    require(\\n      collateralRedeemed.isGreaterThanOrEqual(totCollateralAmount),\\n      'Position undercapitalized'\\n    );\\n\\n    require(\\n      collateralAmount.rawValue > 0,\\n      'Sending collateral amount is equal to 0'\\n    );\\n\\n    FixedPoint.Unsigned memory destOverCollateral =\\n      collateralAmount.mul(\\n        FixedPoint.Unsigned(destinationPool.overCollateralization())\\n      );\\n\\n    FixedPoint.Unsigned memory destUnusedCollateral =\\n      FixedPoint.Unsigned(destinationPool.totalAvailableLiquidity());\\n\\n    require(\\n      destUnusedCollateral.isGreaterThanOrEqual(destOverCollateral),\\n      'No enough liquidity for covering mint operation'\\n    );\\n\\n    destSyntheticTokensReceived = _destSyntheticTokensReceived.rawValue;\\n    feePaid = _feePaid.rawValue;\\n  }\\n\\n  //----------------------------------------\\n  //  Internal functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Execute mint of synthetic tokens\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param executeMintParams Params for execution of mint (see ExecuteMintParams struct)\\n   */\\n  function executeMint(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ExecuteMintParams memory executeMintParams\\n  ) internal {\\n    // Sending amount must be different from 0\\n    require(\\n      executeMintParams.collateralAmount.rawValue > 0,\\n      'Sending collateral amount is equal to 0'\\n    );\\n\\n    // Collateral available\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    // Update LP's collateralization status\\n    FixedPoint.Unsigned memory overCollateral =\\n      lpPosition.updateLpPositionInMint(\\n        self.overCollateralization,\\n        executeMintParams.collateralAmount,\\n        executeMintParams.numTokens\\n      );\\n\\n    //Check there is enough liquidity in the pool for overcollateralization\\n    require(\\n      unusedCollateral.isGreaterThanOrEqual(overCollateral),\\n      'No enough liquidity for covering mint operation'\\n    );\\n\\n    // Update fees status\\n    feeStatus.updateFees(self.fee, executeMintParams.feeAmount);\\n\\n    // Pull user's collateral\\n    self.pullCollateral(\\n      executeMintParams.sender,\\n      executeMintParams.totCollateralAmount\\n    );\\n\\n    // Mint synthetic asset and transfer to the recipient\\n    self.syntheticToken.mint(\\n      executeMintParams.recipient,\\n      executeMintParams.numTokens.rawValue\\n    );\\n\\n    emit Mint(\\n      executeMintParams.sender,\\n      executeMintParams.totCollateralAmount.rawValue,\\n      executeMintParams.numTokens.rawValue,\\n      executeMintParams.feeAmount.rawValue,\\n      executeMintParams.recipient\\n    );\\n  }\\n\\n  /**\\n   * @notice Execute redeem of collateral\\n   * @param self Data type the library is attached tfo\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param executeRedeemParams Params for execution of redeem (see ExecuteRedeemParams struct)\\n   */\\n  function executeRedeem(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ExecuteRedeemParams memory executeRedeemParams\\n  ) internal {\\n    // Sending amount must be different from 0\\n    require(\\n      executeRedeemParams.numTokens.rawValue > 0,\\n      'Sending tokens amount is equal to 0'\\n    );\\n\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      lpPosition.updateLpPositionInRedeem(executeRedeemParams.numTokens);\\n\\n    // Check that collateral redemeed is enough for cover the value of synthetic tokens\\n    require(\\n      collateralRedeemed.isGreaterThanOrEqual(\\n        executeRedeemParams.totCollateralAmount\\n      ),\\n      'Position undercapitalized'\\n    );\\n\\n    // Update fees status\\n    feeStatus.updateFees(self.fee, executeRedeemParams.feeAmount);\\n\\n    // Burn synthetic tokens\\n    self.burnSyntheticTokens(\\n      executeRedeemParams.numTokens.rawValue,\\n      executeRedeemParams.sender\\n    );\\n\\n    //Send net amount of collateral to the user that submitted the redeem request\\n    self.collateralToken.safeTransfer(\\n      executeRedeemParams.recipient,\\n      executeRedeemParams.collateralAmount.rawValue\\n    );\\n\\n    emit Redeem(\\n      executeRedeemParams.sender,\\n      executeRedeemParams.numTokens.rawValue,\\n      executeRedeemParams.collateralAmount.rawValue,\\n      executeRedeemParams.feeAmount.rawValue,\\n      executeRedeemParams.recipient\\n    );\\n  }\\n\\n  /**\\n   * @notice Execute exchange between synthetic tokens\\n   * @param self Data type the library is attached tfo\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param executeExchangeParams Params for execution of exchange (see ExecuteExchangeParams struct)\\n   */\\n  function executeExchange(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ExecuteExchangeParams memory executeExchangeParams\\n  ) internal {\\n    // Sending amount must be different from 0\\n    require(\\n      executeExchangeParams.numTokens.rawValue > 0,\\n      'Sending tokens amount is equal to 0'\\n    );\\n\\n    FixedPoint.Unsigned memory collateralRedeemed =\\n      lpPosition.updateLpPositionInRedeem(executeExchangeParams.numTokens);\\n\\n    // Check that collateral redemeed is enough for cover the value of synthetic tokens\\n    require(\\n      collateralRedeemed.isGreaterThanOrEqual(\\n        executeExchangeParams.totCollateralAmount\\n      ),\\n      'Position undercapitalized'\\n    );\\n\\n    // Update fees status\\n    feeStatus.updateFees(self.fee, executeExchangeParams.feeAmount);\\n\\n    // Burn synthetic tokens\\n    self.burnSyntheticTokens(\\n      executeExchangeParams.numTokens.rawValue,\\n      executeExchangeParams.sender\\n    );\\n\\n    ISynthereumLiquidityPoolGeneral destinationPool =\\n      executeExchangeParams.destPool;\\n\\n    // Check that destination pool is different from this pool\\n    require(\\n      address(this) != address(destinationPool),\\n      'Same source and destination pool'\\n    );\\n\\n    self.checkPool(destinationPool);\\n\\n    // Transfer collateral amount (without overcollateralization) to the destination pool\\n    self.collateralToken.safeTransfer(\\n      address(destinationPool),\\n      executeExchangeParams.collateralAmount.rawValue\\n    );\\n\\n    // Mint the destination tokens with the withdrawn collateral\\n    destinationPool.exchangeMint(\\n      executeExchangeParams.collateralAmount.rawValue,\\n      executeExchangeParams.destNumTokens.rawValue,\\n      executeExchangeParams.recipient\\n    );\\n\\n    emit Exchange(\\n      executeExchangeParams.sender,\\n      address(destinationPool),\\n      executeExchangeParams.numTokens.rawValue,\\n      executeExchangeParams.destNumTokens.rawValue,\\n      executeExchangeParams.feeAmount.rawValue,\\n      executeExchangeParams.recipient\\n    );\\n  }\\n\\n  /**\\n   * @notice Withdraw unused deposited collateral by the LP\\n   * @param self Data type the library is attached to\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param feeStatus Actual status of fee gained (see FeeStatus struct)\\n   * @param collateralAmount Collateral to be withdrawn\\n   * @param sender Sender that withdraws liquidity\\n   * @return remainingLiquidity Remaining unused collateral in the pool\\n   */\\n  function _withdrawLiquidity(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    address sender\\n  ) internal returns (uint256 remainingLiquidity) {\\n    // Collateral available\\n    FixedPoint.Unsigned memory unusedCollateral =\\n      self.calculateUnusedCollateral(\\n        lpPosition.totalCollateralAmount,\\n        feeStatus.totalFeeAmount,\\n        FixedPoint.Unsigned(0)\\n      );\\n\\n    // Check that available collateral is bigger than collateral to be withdrawn and returns the difference\\n    remainingLiquidity = (unusedCollateral.sub(collateralAmount)).rawValue;\\n\\n    // Transfer amount to the Lp\\n    uint256 _collateralAmount = collateralAmount.rawValue;\\n\\n    self.collateralToken.safeTransfer(sender, _collateralAmount);\\n\\n    emit WithdrawLiquidity(sender, _collateralAmount, remainingLiquidity);\\n  }\\n\\n  /**\\n   * @notice Update LP's collateralization status after a mint\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param overCollateralization Overcollateralization rate\\n   * @param collateralAmount Collateral amount to be added (only user collateral)\\n   * @param numTokens Tokens to be added\\n   * @return overCollateral Amount of collateral to be provided by LP for overcollateralization\\n   */\\n  function updateLpPositionInMint(\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    FixedPoint.Unsigned storage overCollateralization,\\n    FixedPoint.Unsigned memory collateralAmount,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal returns (FixedPoint.Unsigned memory overCollateral) {\\n    overCollateral = collateralAmount.mul(overCollateralization);\\n\\n    lpPosition.totalCollateralAmount = lpPosition\\n      .totalCollateralAmount\\n      .add(collateralAmount)\\n      .add(overCollateral);\\n\\n    lpPosition.tokensCollateralized = lpPosition.tokensCollateralized.add(\\n      numTokens\\n    );\\n  }\\n\\n  /**\\n   * @notice Update LP's collateralization status after a redeem\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param numTokens Tokens to be removed\\n   * @return collateralRedeemed Collateral redeemed\\n   */\\n  function updateLpPositionInRedeem(\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal returns (FixedPoint.Unsigned memory collateralRedeemed) {\\n    FixedPoint.Unsigned memory totalActualTokens =\\n      lpPosition.tokensCollateralized;\\n\\n    FixedPoint.Unsigned memory totalActualCollateral =\\n      lpPosition.totalCollateralAmount;\\n\\n    FixedPoint.Unsigned memory fractionRedeemed =\\n      numTokens.div(totalActualTokens);\\n\\n    collateralRedeemed = fractionRedeemed.mul(totalActualCollateral);\\n\\n    lpPosition.tokensCollateralized = totalActualTokens.sub(numTokens);\\n\\n    lpPosition.totalCollateralAmount = totalActualCollateral.sub(\\n      collateralRedeemed\\n    );\\n  }\\n\\n  /**\\n   * @notice Update fee gained by the fee recipients\\n   * @param feeStatus Actual status of fee gained to be withdrawn\\n   * @param feeInfo Actual status of fee recipients and their proportions\\n   * @param feeAmount Collateral fee charged\\n   */\\n  function updateFees(\\n    ISynthereumLiquidityPoolStorage.FeeStatus storage feeStatus,\\n    ISynthereumLiquidityPoolStorage.Fee storage feeInfo,\\n    FixedPoint.Unsigned memory feeAmount\\n  ) internal {\\n    FixedPoint.Unsigned memory feeCharged;\\n\\n    address[] storage feeRecipients = feeInfo.feeData.feeRecipients;\\n\\n    uint32[] storage feeProportions = feeInfo.feeData.feeProportions;\\n\\n    uint256 totalFeeProportions = feeInfo.totalFeeProportions;\\n\\n    uint256 numberOfRecipients = feeRecipients.length;\\n\\n    mapping(address => FixedPoint.Unsigned) storage feeGained =\\n      feeStatus.feeGained;\\n\\n    for (uint256 i = 0; i < numberOfRecipients - 1; i++) {\\n      address feeRecipient = feeRecipients[i];\\n      FixedPoint.Unsigned memory feeReceived =\\n        FixedPoint.Unsigned(\\n          (feeAmount.rawValue * feeProportions[i]) / totalFeeProportions\\n        );\\n      feeGained[feeRecipient] = feeGained[feeRecipient].add(feeReceived);\\n      feeCharged = feeCharged.add(feeReceived);\\n    }\\n\\n    address lastRecipient = feeRecipients[numberOfRecipients - 1];\\n\\n    feeGained[lastRecipient] = feeGained[lastRecipient].add(feeAmount).sub(\\n      feeCharged\\n    );\\n\\n    feeStatus.totalFeeAmount = feeStatus.totalFeeAmount.add(feeAmount);\\n  }\\n\\n  /**\\n   * @notice Pulls collateral tokens from the sender to store in the Pool\\n   * @param self Data type the library is attached to\\n   * @param numTokens The number of tokens to pull\\n   */\\n  function pullCollateral(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    address from,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal {\\n    self.collateralToken.safeTransferFrom(\\n      from,\\n      address(this),\\n      numTokens.rawValue\\n    );\\n  }\\n\\n  /**\\n   * @notice Pulls synthetic tokens from the sender and burn them\\n   * @param self Data type the library is attached to\\n   * @param numTokens The number of tokens to be burned\\n   * @param sender Sender of synthetic tokens\\n   */\\n  function burnSyntheticTokens(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    uint256 numTokens,\\n    address sender\\n  ) internal {\\n    IMintableBurnableERC20 synthToken = self.syntheticToken;\\n\\n    // Transfer synthetic token from the user to the pool\\n    synthToken.safeTransferFrom(sender, address(this), numTokens);\\n\\n    // Burn synthetic asset\\n    synthToken.burn(numTokens);\\n  }\\n\\n  //----------------------------------------\\n  //  Internal views functions\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Given a collateral value to be exchanged, returns the fee amount, net collateral and synthetic tokens\\n   * @param self Data type the library is attached tfo\\n   * @param totCollateralAmount Collateral amount to be exchanged\\n   * @return collateralAmount Net collateral amount (totCollateralAmount - feePercentage)\\n   * @return feeAmount Fee to be paid according to the fee percentage\\n   * @return numTokens Number of synthetic tokens will be received according to the actual price in exchange for collateralAmount\\n   */\\n  function mintCalculation(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory totCollateralAmount\\n  )\\n    internal\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory numTokens\\n    )\\n  {\\n    feeAmount = totCollateralAmount.mul(self.fee.feeData.feePercentage);\\n\\n    collateralAmount = totCollateralAmount.sub(feeAmount);\\n\\n    numTokens = calculateNumberOfTokens(\\n      getPriceFeedRate(self.finder, self.priceIdentifier),\\n      getCollateralDecimals(self.collateralToken),\\n      collateralAmount\\n    );\\n  }\\n\\n  /**\\n   * @notice Given a an amount of synthetic tokens to be exchanged, returns the fee amount, net collateral and gross collateral\\n   * @param self Data type the library is attached tfo\\n   * @param numTokens Synthetic tokens amount to be exchanged\\n   * @return totCollateralAmount Gross collateral amount (collateralAmount + feeAmount)\\n   * @return feeAmount Fee to be paid according to the fee percentage\\n   * @return collateralAmount Net collateral amount will be received according to the actual price in exchange for numTokens\\n   */\\n  function redeemCalculation(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory numTokens\\n  )\\n    internal\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory collateralAmount\\n    )\\n  {\\n    totCollateralAmount = calculateCollateralAmount(\\n      getPriceFeedRate(self.finder, self.priceIdentifier),\\n      getCollateralDecimals(self.collateralToken),\\n      numTokens\\n    );\\n\\n    feeAmount = totCollateralAmount.mul(self.fee.feeData.feePercentage);\\n\\n    collateralAmount = totCollateralAmount.sub(feeAmount);\\n  }\\n\\n  /**\\n   * @notice Given a an amount of synthetic tokens to be exchanged, returns the fee amount, net collateral and gross collateral and number of destination tokens\\n   * @param self Data type the library is attached tfo\\n   * @param numTokens Synthetic tokens amount to be exchanged\\n   * @param destinationPool Pool from which destination tokens will be received\\n   * @return totCollateralAmount Gross collateral amount according to the price\\n   * @return feeAmount Fee to be paid according to the fee percentage\\n   * @return collateralAmount Net collateral amount (totCollateralAmount - feeAmount)\\n   * @return destNumTokens Number of destination synthetic tokens will be received according to the actual price in exchange for synthetic tokens\\n   */\\n  function exchangeCalculation(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory numTokens,\\n    ISynthereumLiquidityPoolGeneral destinationPool\\n  )\\n    internal\\n    view\\n    returns (\\n      FixedPoint.Unsigned memory totCollateralAmount,\\n      FixedPoint.Unsigned memory feeAmount,\\n      FixedPoint.Unsigned memory collateralAmount,\\n      FixedPoint.Unsigned memory destNumTokens\\n    )\\n  {\\n    ISynthereumFinder _finder = self.finder;\\n\\n    IStandardERC20 _collateralToken = self.collateralToken;\\n\\n    uint8 collateralDecimals = getCollateralDecimals(_collateralToken);\\n\\n    totCollateralAmount = calculateCollateralAmount(\\n      getPriceFeedRate(_finder, self.priceIdentifier),\\n      collateralDecimals,\\n      numTokens\\n    );\\n\\n    feeAmount = totCollateralAmount.mul(self.fee.feeData.feePercentage);\\n\\n    collateralAmount = totCollateralAmount.sub(feeAmount);\\n\\n    destNumTokens = calculateNumberOfTokens(\\n      getPriceFeedRate(_finder, destinationPool.getPriceFeedIdentifier()),\\n      collateralDecimals,\\n      collateralAmount\\n    );\\n  }\\n\\n  /**\\n   * @notice Check expiration of mint, redeem and exchange transaction\\n   * @param expiration Expiration time of the transaction\\n   */\\n  function checkExpiration(uint256 expiration) internal view {\\n    require(block.timestamp <= expiration, 'Transaction expired');\\n  }\\n\\n  /**\\n   * @notice Check if sender or receiver pool is a correct registered pool\\n   * @param self Data type the library is attached to\\n   * @param poolToCheck Pool that should be compared with this pool\\n   */\\n  function checkPool(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    ISynthereumLiquidityPoolGeneral poolToCheck\\n  ) internal view {\\n    IStandardERC20 collateralToken = self.collateralToken;\\n    require(\\n      collateralToken == poolToCheck.collateralToken(),\\n      'Collateral tokens do not match'\\n    );\\n\\n    ISynthereumFinder finder = self.finder;\\n\\n    require(finder == poolToCheck.synthereumFinder(), 'Finders do not match');\\n\\n    ISynthereumRegistry poolRegister =\\n      ISynthereumRegistry(\\n        finder.getImplementationAddress(SynthereumInterfaces.PoolRegistry)\\n      );\\n\\n    require(\\n      poolRegister.isDeployed(\\n        poolToCheck.syntheticTokenSymbol(),\\n        collateralToken,\\n        poolToCheck.version(),\\n        address(poolToCheck)\\n      ),\\n      'Destination pool not registered'\\n    );\\n  }\\n\\n  /**\\n   * @notice Check if an amount of collateral is enough to collateralize the position\\n   * @param lpPosition Position of the LP (see LPPosition struct)\\n   * @param priceRate Price rate of the pair\\n   * @param collateralDecimals Number of decimals of the collateral\\n   * @param liquidationData Liquidation info (see LiquidationData struct)\\n   * @param collateralToCompare collateral used for checking the overcollaterlization\\n   * @return _isOverCollateralized True if position is overcollaterlized, otherwise false\\n   * @return collateralValue Collateral amount equal to the value of tokens\\n   * @return overCollateralValue Collateral amount equal to the value of tokens * collateralRequirement\\n   */\\n  function isOverCollateralized(\\n    ISynthereumLiquidityPoolStorage.LPPosition storage lpPosition,\\n    ISynthereumLiquidityPoolStorage.Liquidation storage liquidationData,\\n    FixedPoint.Unsigned memory priceRate,\\n    uint8 collateralDecimals,\\n    FixedPoint.Unsigned memory collateralToCompare\\n  )\\n    internal\\n    view\\n    returns (\\n      bool _isOverCollateralized,\\n      FixedPoint.Unsigned memory collateralValue,\\n      FixedPoint.Unsigned memory overCollateralValue\\n    )\\n  {\\n    collateralValue = calculateCollateralAmount(\\n      priceRate,\\n      collateralDecimals,\\n      lpPosition.tokensCollateralized\\n    );\\n\\n    overCollateralValue = collateralValue.mul(\\n      liquidationData.collateralRequirement\\n    );\\n\\n    _isOverCollateralized = collateralToCompare.isGreaterThanOrEqual(\\n      overCollateralValue\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculate the unused collateral of this pool\\n   * @param self Data type the library is attached to\\n   * @param totalCollateral Total collateral used\\n   * @param totalFees Total fees gained to be whitdrawn\\n   * @param collateralReceived Collateral sent to the pool by a user or contract to be used for collateralization\\n   * @param unusedCollateral Unused collateral of the pool\\n   */\\n  function calculateUnusedCollateral(\\n    ISynthereumLiquidityPoolStorage.Storage storage self,\\n    FixedPoint.Unsigned memory totalCollateral,\\n    FixedPoint.Unsigned memory totalFees,\\n    FixedPoint.Unsigned memory collateralReceived\\n  ) internal view returns (FixedPoint.Unsigned memory unusedCollateral) {\\n    // Collateral available\\n    FixedPoint.Unsigned memory actualBalance =\\n      FixedPoint.Unsigned(self.collateralToken.balanceOf(address(this)));\\n    unusedCollateral = actualBalance.sub(\\n      totalCollateral.add(totalFees).add(collateralReceived)\\n    );\\n  }\\n\\n  /**\\n   * @notice Retrun the on-chain oracle price for a pair\\n   * @param finder Synthereum finder\\n   * @param priceIdentifier Identifier of price pair\\n   * @return priceRate Latest rate of the pair\\n   */\\n  function getPriceFeedRate(ISynthereumFinder finder, bytes32 priceIdentifier)\\n    internal\\n    view\\n    returns (FixedPoint.Unsigned memory priceRate)\\n  {\\n    ISynthereumPriceFeed priceFeed =\\n      ISynthereumPriceFeed(\\n        finder.getImplementationAddress(SynthereumInterfaces.PriceFeed)\\n      );\\n\\n    priceRate = FixedPoint.Unsigned(priceFeed.getLatestPrice(priceIdentifier));\\n  }\\n\\n  /**\\n   * @notice Retrun the number of decimals of collateral token\\n   * @param collateralToken Collateral token contract\\n   * @return decimals number of decimals\\n   */\\n  function getCollateralDecimals(IStandardERC20 collateralToken)\\n    internal\\n    view\\n    returns (uint8 decimals)\\n  {\\n    decimals = collateralToken.decimals();\\n  }\\n\\n  /**\\n   * @notice Calculate synthetic token amount starting from an amount of collateral\\n   * @param priceRate Price rate of the pair\\n   * @param collateralDecimals Number of decimals of the collateral\\n   * @param numTokens Amount of collateral from which you want to calculate synthetic token amount\\n   * @return numTokens Amount of tokens after on-chain oracle conversion\\n   */\\n  function calculateNumberOfTokens(\\n    FixedPoint.Unsigned memory priceRate,\\n    uint8 collateralDecimals,\\n    FixedPoint.Unsigned memory collateralAmount\\n  ) internal pure returns (FixedPoint.Unsigned memory numTokens) {\\n    numTokens = collateralAmount.mul(10**(18 - collateralDecimals)).div(\\n      priceRate\\n    );\\n  }\\n\\n  /**\\n   * @notice Calculate collateral amount starting from an amount of synthtic token\\n   * @param priceRate Price rate of the pair\\n   * @param collateralDecimals Number of decimals of the collateral\\n   * @param numTokens Amount of synthetic tokens from which you want to calculate collateral amount\\n   * @return collateralAmount Amount of collateral after on-chain oracle conversion\\n   */\\n  function calculateCollateralAmount(\\n    FixedPoint.Unsigned memory priceRate,\\n    uint8 collateralDecimals,\\n    FixedPoint.Unsigned memory numTokens\\n  ) internal pure returns (FixedPoint.Unsigned memory collateralAmount) {\\n    collateralAmount = numTokens.mul(priceRate).div(\\n      10**(18 - collateralDecimals)\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/common/interfaces/IEmergencyShutdown.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\ninterface IEmergencyShutdown {\\n  /**\\n   * @notice Shutdown the pool or self-minting-derivative in case of emergency\\n   * @notice Only Synthereum manager contract can call this function\\n   * @return timestamp Timestamp of emergency shutdown transaction\\n   * @return price Price of the pair at the moment of shutdown execution\\n   */\\n  function emergencyShutdown()\\n    external\\n    returns (uint256 timestamp, uint256 price);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/synthereum-pool/v5/interfaces/ILiquidityPoolInteraction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\ninterface ISynthereumLiquidityPoolInteraction {\\n  /**\\n   * @notice Called by a source Pool's `exchange` function to mint destination tokens\\n   * @notice This functon can be called only by a pool registered in the PoolRegister contract\\n   * @param collateralAmount The amount of collateral to use from the source Pool\\n   * @param numTokens The number of new tokens to mint\\n   * @param recipient Recipient to which send synthetic token minted\\n   */\\n  function exchangeMint(\\n    uint256 collateralAmount,\\n    uint256 numTokens,\\n    address recipient\\n  ) external;\\n\\n  /**\\n   * @notice Returns price identifier of the pool\\n   * @return identifier Price identifier\\n   */\\n  function getPriceFeedIdentifier() external view returns (bytes32 identifier);\\n\\n  /**\\n   * @notice Return overcollateralization percentage from the storage\\n   * @return Overcollateralization percentage\\n   */\\n  function overCollateralization() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the total amount of liquidity deposited in the pool, but nut used as collateral\\n   * @return Total available liquidity\\n   */\\n  function totalAvailableLiquidity() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/registries/interfaces/IRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {IERC20} from '../../../../@openzeppelin/contracts/token/ERC20/IERC20.sol';\\n\\n/**\\n * @title Provides interface with functions of SynthereumRegistry\\n */\\n\\ninterface ISynthereumRegistry {\\n  /**\\n   * @notice Allow the deployer to register an element\\n   * @param syntheticTokenSymbol Symbol of the syntheticToken\\n   * @param collateralToken Collateral ERC20 token of the element deployed\\n   * @param version Version of the element deployed\\n   * @param element Address of the element deployed\\n   */\\n  function register(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 version,\\n    address element\\n  ) external;\\n\\n  /**\\n   * @notice Returns if a particular element exists or not\\n   * @param syntheticTokenSymbol Synthetic token symbol of the element\\n   * @param collateralToken ERC20 contract of collateral currency\\n   * @param version Version of the element\\n   * @param element Contract of the element to check\\n   * @return isElementDeployed Returns true if a particular element exists, otherwise false\\n   */\\n  function isDeployed(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 version,\\n    address element\\n  ) external view returns (bool isElementDeployed);\\n\\n  /**\\n   * @notice Returns all the elements with partcular symbol, collateral and version\\n   * @param syntheticTokenSymbol Synthetic token symbol of the element\\n   * @param collateralToken ERC20 contract of collateral currency\\n   * @param version Version of the element\\n   * @return List of all elements\\n   */\\n  function getElements(\\n    string calldata syntheticTokenSymbol,\\n    IERC20 collateralToken,\\n    uint8 version\\n  ) external view returns (address[] memory);\\n\\n  /**\\n   * @notice Returns all the synthetic token symbol used\\n   * @return List of all synthetic token symbol\\n   */\\n  function getSyntheticTokens() external view returns (string[] memory);\\n\\n  /**\\n   * @notice Returns all the versions used\\n   * @return List of all versions\\n   */\\n  function getVersions() external view returns (uint8[] memory);\\n\\n  /**\\n   * @notice Returns all the collaterals used\\n   * @return List of all collaterals\\n   */\\n  function getCollaterals() external view returns (address[] memory);\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/FactoryVersioning.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {\\n  ISynthereumFactoryVersioning\\n} from './interfaces/IFactoryVersioning.sol';\\nimport {\\n  EnumerableMap\\n} from '../../@openzeppelin/contracts/utils/structs/EnumerableMap.sol';\\nimport {\\n  AccessControlEnumerable\\n} from '../../@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\n\\n/**\\n * @title Provides addresses of different versions of pools factory and derivative factory\\n */\\ncontract SynthereumFactoryVersioning is\\n  ISynthereumFactoryVersioning,\\n  AccessControlEnumerable\\n{\\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\\n\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  //Describe role structure\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  //----------------------------------------\\n  // Storage\\n  //----------------------------------------\\n\\n  mapping(bytes32 => EnumerableMap.UintToAddressMap) private factories;\\n\\n  //----------------------------------------\\n  // Events\\n  //----------------------------------------\\n\\n  event AddFactory(\\n    bytes32 indexed factoryType,\\n    uint8 indexed version,\\n    address indexed factory\\n  );\\n\\n  event SetFactory(\\n    bytes32 indexed factoryType,\\n    uint8 indexed version,\\n    address indexed factory\\n  );\\n\\n  event RemoveFactory(\\n    bytes32 indexed factoryType,\\n    uint8 indexed version,\\n    address indexed factory\\n  );\\n\\n  //----------------------------------------\\n  // Constructor\\n  //----------------------------------------\\n  constructor(Roles memory roles) {\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, roles.admin);\\n    _setupRole(MAINTAINER_ROLE, roles.maintainer);\\n  }\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  //----------------------------------------\\n  // External functions\\n  //----------------------------------------\\n\\n  /** @notice Sets a Factory\\n   * @param factoryType Type of factory\\n   * @param version Version of the factory to be set\\n   * @param factory The pool factory address to be set\\n   */\\n  function setFactory(\\n    bytes32 factoryType,\\n    uint8 version,\\n    address factory\\n  ) external override onlyMaintainer {\\n    require(factory != address(0), 'Factory cannot be address 0');\\n    bool isNewVersion = factories[factoryType].set(version, factory);\\n    if (isNewVersion) {\\n      emit AddFactory(factoryType, version, factory);\\n    } else {\\n      emit SetFactory(factoryType, version, factory);\\n    }\\n  }\\n\\n  /** @notice Removes a factory\\n   * @param factoryType The type of factory to be removed\\n   * @param version Version of the factory to be removed\\n   */\\n  function removeFactory(bytes32 factoryType, uint8 version)\\n    external\\n    override\\n    onlyMaintainer\\n  {\\n    EnumerableMap.UintToAddressMap storage selectedFactories =\\n      factories[factoryType];\\n    address factoryToRemove = selectedFactories.get(version);\\n    selectedFactories.remove(version);\\n    emit RemoveFactory(factoryType, version, factoryToRemove);\\n  }\\n\\n  //----------------------------------------\\n  // External view functions\\n  //----------------------------------------\\n\\n  /** @notice Gets a factory contract address\\n   * @param factoryType The type of factory to be checked\\n   * @param version Version of the factory to be checked\\n   * @return factory Address of the factory contract\\n   */\\n  function getFactoryVersion(bytes32 factoryType, uint8 version)\\n    external\\n    view\\n    override\\n    returns (address factory)\\n  {\\n    factory = factories[factoryType].get(version);\\n  }\\n\\n  /** @notice Gets the number of factory versions for a specific type\\n   * @param factoryType The type of factory to be checked\\n   * @return numberOfVersions Total number of versions for a specific factory\\n   */\\n  function numberOfFactoryVersions(bytes32 factoryType)\\n    external\\n    view\\n    override\\n    returns (uint8 numberOfVersions)\\n  {\\n    numberOfVersions = uint8(factories[factoryType].length());\\n  }\\n}\\n\"\r\n    },\r\n    \"deploy/@openzeppelin/contracts/utils/structs/EnumerableMap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSet.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * As of v3.0.0, only maps of type `uint256 -> address` (`UintToAddressMap`) are\\n * supported.\\n */\\nlibrary EnumerableMap {\\n    using EnumerableSet for EnumerableSet.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Map {\\n        // Storage of keys\\n        EnumerableSet.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function _set(\\n        Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) private returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function _length(Map storage map) private view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (_contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || _contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function _get(\\n        Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) private view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || _contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return _set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return _remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return _contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return _length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = _tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(_get(map._inner, bytes32(key), errorMessage))));\\n    }\\n}\\n\"\r\n    },\r\n    \"deploy/contracts/core/Finder.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.9;\\n\\nimport {ISynthereumFinder} from './interfaces/IFinder.sol';\\nimport {\\n  AccessControlEnumerable\\n} from '../../@openzeppelin/contracts/access/AccessControlEnumerable.sol';\\n\\n/**\\n * @title Provides addresses of contracts implementing certain interfaces.\\n */\\ncontract SynthereumFinder is ISynthereumFinder, AccessControlEnumerable {\\n  bytes32 public constant MAINTAINER_ROLE = keccak256('Maintainer');\\n\\n  //Describe role structure\\n  struct Roles {\\n    address admin;\\n    address maintainer;\\n  }\\n\\n  //----------------------------------------\\n  // Storage\\n  //----------------------------------------\\n\\n  mapping(bytes32 => address) public interfacesImplemented;\\n\\n  //----------------------------------------\\n  // Events\\n  //----------------------------------------\\n\\n  event InterfaceImplementationChanged(\\n    bytes32 indexed interfaceName,\\n    address indexed newImplementationAddress\\n  );\\n\\n  //----------------------------------------\\n  // Modifiers\\n  //----------------------------------------\\n\\n  modifier onlyMaintainer() {\\n    require(\\n      hasRole(MAINTAINER_ROLE, msg.sender),\\n      'Sender must be the maintainer'\\n    );\\n    _;\\n  }\\n\\n  //----------------------------------------\\n  // Constructors\\n  //----------------------------------------\\n\\n  constructor(Roles memory roles) {\\n    _setRoleAdmin(DEFAULT_ADMIN_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setRoleAdmin(MAINTAINER_ROLE, DEFAULT_ADMIN_ROLE);\\n    _setupRole(DEFAULT_ADMIN_ROLE, roles.admin);\\n    _setupRole(MAINTAINER_ROLE, roles.maintainer);\\n  }\\n\\n  //----------------------------------------\\n  // External view\\n  //----------------------------------------\\n\\n  /**\\n   * @notice Updates the address of the contract that implements `interfaceName`.\\n   * @param interfaceName bytes32 of the interface name that is either changed or registered.\\n   * @param implementationAddress address of the implementation contract.\\n   */\\n  function changeImplementationAddress(\\n    bytes32 interfaceName,\\n    address implementationAddress\\n  ) external override onlyMaintainer {\\n    interfacesImplemented[interfaceName] = implementationAddress;\\n\\n    emit InterfaceImplementationChanged(interfaceName, implementationAddress);\\n  }\\n\\n  /**\\n   * @notice Gets the address of the contract that implements the given `interfaceName`.\\n   * @param interfaceName queried interface.\\n   * @return implementationAddress Address of the defined interface.\\n   */\\n  function getImplementationAddress(bytes32 interfaceName)\\n    external\\n    view\\n    override\\n    returns (address)\\n  {\\n    address implementationAddress = interfacesImplemented[interfaceName];\\n    require(implementationAddress != address(0x0), 'Implementation not found');\\n    return implementationAddress;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"deploy/contracts/synthereum-pool/v6/MultiLpLiquidityPoolMainLib.sol\": {\r\n        \"SynthereumMultiLpLiquidityPoolMainLib\": \"0xe03ccc32f376fa5de84851cf752b3f1ed3c8e41f\"\r\n      },\r\n      \"deploy/contracts/synthereum-pool/v6/MultiLpLiquidityPoolMigrationLib.sol\": {\r\n        \"SynthereumMultiLpLiquidityPoolMigrationLib\": \"0x3835e92d9f7d66b992fc83a6a85b75c6d1b268d7\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"ActivatedLP\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralSent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralDeposited\",\"type\":\"uint256\"}],\"name\":\"DepositedLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"synthTokensInLiquidation\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralReceived\",\"type\":\"uint256\"}],\"name\":\"Liquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"totalCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ISynthereumMultiLpLiquidityPoolEvents.MintValues\",\"name\":\"mintvalues\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Minted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lendingModuleId\",\"type\":\"string\"}],\"name\":\"NewLendingModule\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct ISynthereumMultiLpLiquidityPoolEvents.RedeemValues\",\"name\":\"redeemvalues\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Redeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"}],\"name\":\"RegisteredLp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"SetFeePercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidationReward\",\"type\":\"uint256\"}],\"name\":\"SetLiquidationReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"overCollateralization\",\"type\":\"uint256\"}],\"name\":\"SetOvercollateralization\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lp\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralWithdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralReceived\",\"type\":\"uint256\"}],\"name\":\"WithdrawnLiquidity\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAINTAINER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_overCollateralization\",\"type\":\"uint128\"}],\"name\":\"activateLP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralDeposited\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"addLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newLpCollateralAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralRequirement\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collateralTokenDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActiveLPs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"getMintTradeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"synthTokensReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_syntTokensAmount\",\"type\":\"uint256\"}],\"name\":\"getRedeemTradeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralAmountReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feePaid\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRegisteredLPs\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"finder\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"},{\"internalType\":\"contract IStandardERC20\",\"name\":\"collateralToken\",\"type\":\"address\"},{\"internalType\":\"contract IMintableBurnableERC20\",\"name\":\"syntheticToken\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"maintainer\",\"type\":\"address\"}],\"internalType\":\"struct ISynthereumMultiLpLiquidityPool.Roles\",\"name\":\"roles\",\"type\":\"tuple\"},{\"internalType\":\"uint64\",\"name\":\"fee\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"priceIdentifier\",\"type\":\"bytes32\"},{\"internalType\":\"uint128\",\"name\":\"overCollateralRequirement\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"liquidationReward\",\"type\":\"uint64\"},{\"internalType\":\"string\",\"name\":\"lendingModuleId\",\"type\":\"string\"}],\"internalType\":\"struct ISynthereumMultiLpLiquidityPool.InitializationParams\",\"name\":\"_params\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"isActiveLP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"isRegisteredLP\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lendingProtocolInfo\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"lendingId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"bearingToken\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_numSynthTokens\",\"type\":\"uint256\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"liquidationReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokensCapacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"maxCapacity\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"migrateStorage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"poolVersion\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"storageBytes\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"migrateTotalFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"migrationAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minNumTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ISynthereumMultiLpLiquidityPool.MintParams\",\"name\":\"_mintParams\",\"type\":\"tuple\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"positionLPInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"actualCollateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokensCollateralized\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"overCollateralization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"capacity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"utilization\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mintShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"redeemShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"interestShares\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isOvercollateralized\",\"type\":\"bool\"}],\"internalType\":\"struct ISynthereumMultiLpLiquidityPool.LPInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceFeedIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"numTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiration\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ISynthereumMultiLpLiquidityPool.RedeemParams\",\"name\":\"_redeemParams\",\"type\":\"tuple\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lp\",\"type\":\"address\"}],\"name\":\"registerLP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_collateralAmount\",\"type\":\"uint256\"}],\"name\":\"removeLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"collateralRemoved\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"collateralReceived\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newLpCollateralAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_newFee\",\"type\":\"uint64\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_newLiquidationReward\",\"type\":\"uint64\"}],\"name\":\"setLiquidationReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"_finder\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"_oldVersion\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_storageBytes\",\"type\":\"bytes\"},{\"internalType\":\"uint8\",\"name\":\"_newVersion\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_extraInputParams\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_sourceCollateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_actualCollateralAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setMigratedStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"_overCollateralization\",\"type\":\"uint128\"}],\"name\":\"setOvercollateralization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_lendingId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_bearingToken\",\"type\":\"address\"}],\"name\":\"switchLendingModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"synthereumFinder\",\"outputs\":[{\"internalType\":\"contract ISynthereumFinder\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syntheticToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"syntheticTokenSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCollateralAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usersCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpsCollateral\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCollateral\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSyntheticTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bearingAmount\",\"type\":\"uint256\"}],\"name\":\"transferToLendingManager\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bearingAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"typology\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updatePositions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SynthereumMultiLpLiquidityPool", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}