{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/facets/control/ControlFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport \\\"../../utils/Ownable.sol\\\";\\r\\nimport \\\"../../utils/Accessibility.sol\\\";\\r\\nimport \\\"../../storages/MAStorage.sol\\\";\\r\\nimport \\\"../../storages/MuonStorage.sol\\\";\\r\\nimport \\\"../../storages/GlobalAppStorage.sol\\\";\\r\\nimport \\\"../../storages/SymbolStorage.sol\\\";\\r\\nimport \\\"./IControlEvents.sol\\\";\\r\\nimport \\\"../../libraries/LibDiamond.sol\\\";\\r\\n\\r\\ncontract ControlFacet is Accessibility, Ownable, IControlEvents {\\r\\n    \\r\\n    function transferOwnership(address owner) external onlyOwner{\\r\\n        require(owner != address(0),\\\"ControlFacet: Zero address\\\");\\r\\n        LibDiamond.setContractOwner(owner); \\r\\n    }\\r\\n\\r\\n    function setAdmin(address user) external onlyOwner {\\r\\n        require(user != address(0),\\\"ControlFacet: Zero address\\\");\\r\\n        GlobalAppStorage.layout().hasRole[user][LibAccessibility.DEFAULT_ADMIN_ROLE] = true;\\r\\n        emit RoleGranted(LibAccessibility.DEFAULT_ADMIN_ROLE, user);\\r\\n    }\\r\\n\\r\\n    function grantRole(\\r\\n        address user,\\r\\n        bytes32 role\\r\\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        require(user != address(0),\\\"ControlFacet: Zero address\\\");\\r\\n        GlobalAppStorage.layout().hasRole[user][role] = true;\\r\\n        emit RoleGranted(role, user);\\r\\n    }\\r\\n\\r\\n    function revokeRole(\\r\\n        address user,\\r\\n        bytes32 role\\r\\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        GlobalAppStorage.layout().hasRole[user][role] = false;\\r\\n        emit RoleRevoked(role, user);\\r\\n    }\\r\\n\\r\\n    function registerPartyB(\\r\\n        address partyB\\r\\n    ) external onlyRole(LibAccessibility.PARTY_B_MANAGER_ROLE) {\\r\\n        require(partyB != address(0), \\\"ControlFacet: Zero address\\\");\\r\\n        require(\\r\\n            !MAStorage.layout().partyBStatus[partyB],\\r\\n            \\\"ControlFacet: Address is already registered\\\"\\r\\n        );\\r\\n        MAStorage.layout().partyBStatus[partyB] = true;\\r\\n        MAStorage.layout().partyBList.push(partyB);\\r\\n        emit RegisterPartyB(partyB);\\r\\n    }\\r\\n\\r\\n    function deregisterPartyB(\\r\\n        address partyB,\\r\\n        uint256 index\\r\\n    ) external onlyRole(LibAccessibility.PARTY_B_MANAGER_ROLE) {\\r\\n        require(partyB != address(0), \\\"ControlFacet: Zero address\\\");\\r\\n        require(MAStorage.layout().partyBStatus[partyB], \\\"ControlFacet: Address is not registered\\\");\\r\\n        require(MAStorage.layout().partyBList[index] == partyB, \\\"ControlFacet: Invalid index\\\");\\r\\n        uint256 lastIndex = MAStorage.layout().partyBList.length - 1;\\r\\n        require(index <= lastIndex, \\\"ControlFacet: Invalid index\\\");\\r\\n        MAStorage.layout().partyBStatus[partyB] = false;\\r\\n        MAStorage.layout().partyBList[index] = MAStorage.layout().partyBList[lastIndex];\\r\\n        MAStorage.layout().partyBList.pop();\\r\\n        emit DeregisterPartyB(partyB, index);\\r\\n    }\\r\\n\\r\\n    function setMuonConfig(\\r\\n        uint256 upnlValidTime,\\r\\n        uint256 priceValidTime,\\r\\n        uint256 priceQuantityValidTime\\r\\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\\r\\n        emit SetMuonConfig(upnlValidTime, priceValidTime, priceQuantityValidTime);\\r\\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\\r\\n        muonLayout.upnlValidTime = upnlValidTime;\\r\\n        muonLayout.priceValidTime = priceValidTime;\\r\\n        muonLayout.priceQuantityValidTime = priceQuantityValidTime;\\r\\n    }\\r\\n\\r\\n    function setMuonIds(\\r\\n        uint256 muonAppId,\\r\\n        address validGateway,\\r\\n        PublicKey memory publicKey\\r\\n    ) external onlyRole(LibAccessibility.MUON_SETTER_ROLE) {\\r\\n        MuonStorage.Layout storage muonLayout = MuonStorage.layout();\\r\\n        muonLayout.muonAppId = muonAppId;\\r\\n        muonLayout.validGateway = validGateway;\\r\\n        muonLayout.muonPublicKey = publicKey;\\r\\n        emit SetMuonIds(muonAppId, validGateway, publicKey.x, publicKey.parity);\\r\\n    }\\r\\n\\r\\n    function setCollateral(\\r\\n        address collateral\\r\\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        require(collateral != address(0),\\\"ControlFacet: Zero address\\\");\\r\\n        require(\\r\\n            IERC20Metadata(collateral).decimals() <= 18,\\r\\n            \\\"ControlFacet: Token with more than 18 decimals not allowed\\\"\\r\\n        );\\r\\n        if (GlobalAppStorage.layout().collateral != address(0)) {\\r\\n            require(\\r\\n                IERC20Metadata(GlobalAppStorage.layout().collateral).balanceOf(address(this)) == 0,\\r\\n                \\\"ControlFacet: There is still collateral in the contract\\\"\\r\\n            );\\r\\n        }\\r\\n        GlobalAppStorage.layout().collateral = collateral;\\r\\n        emit SetCollateral(collateral);\\r\\n    }\\r\\n\\r\\n    // Symbol State\\r\\n\\r\\n    function addSymbol(\\r\\n        string memory name,\\r\\n        uint256 minAcceptableQuoteValue,\\r\\n        uint256 minAcceptablePortionLF,\\r\\n        uint256 tradingFee,\\r\\n        uint256 maxLeverage,\\r\\n        uint256 fundingRateEpochDuration,\\r\\n        uint256 fundingRateWindowTime\\r\\n    ) public onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\\r\\n        require(\\r\\n            fundingRateWindowTime < fundingRateEpochDuration / 2,\\r\\n            \\\"ControlFacet: High window time\\\"\\r\\n        );\\r\\n        require(tradingFee <= 1e18, \\\"ControlFacet: High trading fee\\\");\\r\\n        uint256 lastId = ++SymbolStorage.layout().lastId;\\r\\n        Symbol memory symbol = Symbol(\\r\\n            lastId,\\r\\n            name,\\r\\n            true,\\r\\n            minAcceptableQuoteValue,\\r\\n            minAcceptablePortionLF,\\r\\n            tradingFee,\\r\\n            maxLeverage,\\r\\n            fundingRateEpochDuration,\\r\\n            fundingRateWindowTime\\r\\n        );\\r\\n        SymbolStorage.layout().symbols[lastId] = symbol;\\r\\n        emit AddSymbol(\\r\\n            lastId,\\r\\n            name,\\r\\n            minAcceptableQuoteValue,\\r\\n            minAcceptablePortionLF,\\r\\n            tradingFee, \\r\\n            maxLeverage,\\r\\n            fundingRateEpochDuration,\\r\\n            fundingRateWindowTime\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function addSymbols(\\r\\n        Symbol[] memory symbols\\r\\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\\r\\n        for (uint8 i; i < symbols.length; i++) {\\r\\n            addSymbol(\\r\\n                symbols[i].name,\\r\\n                symbols[i].minAcceptableQuoteValue,\\r\\n                symbols[i].minAcceptablePortionLF,\\r\\n                symbols[i].tradingFee,\\r\\n                symbols[i].maxLeverage,\\r\\n                symbols[i].fundingRateEpochDuration,\\r\\n                symbols[i].fundingRateWindowTime\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setSymbolFundingState(\\r\\n        uint256 symbolId,\\r\\n        uint256 fundingRateEpochDuration,\\r\\n        uint256 fundingRateWindowTime\\r\\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\\r\\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\\r\\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \\\"ControlFacet: Invalid id\\\");\\r\\n        require(\\r\\n            fundingRateWindowTime < fundingRateEpochDuration / 2,\\r\\n            \\\"ControlFacet: High window time\\\"\\r\\n        );\\r\\n        symbolLayout.symbols[symbolId].fundingRateEpochDuration = fundingRateEpochDuration;\\r\\n        symbolLayout.symbols[symbolId].fundingRateWindowTime = fundingRateWindowTime;\\r\\n        emit SetSymbolFundingState(symbolId, fundingRateEpochDuration, fundingRateWindowTime);\\r\\n    }\\r\\n\\r\\n    function setSymbolValidationState(\\r\\n        uint256 symbolId,\\r\\n        bool isValid\\r\\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\\r\\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\\r\\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \\\"ControlFacet: Invalid id\\\");\\r\\n        emit SetSymbolValidationState(symbolId, symbolLayout.symbols[symbolId].isValid, isValid);\\r\\n        symbolLayout.symbols[symbolId].isValid = isValid;\\r\\n    }\\r\\n\\r\\n    function setSymbolMaxLeverage(\\r\\n        uint256 symbolId,\\r\\n        uint256 maxLeverage\\r\\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\\r\\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\\r\\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \\\"ControlFacet: Invalid id\\\");\\r\\n        emit SetSymbolMaxLeverage(symbolId, symbolLayout.symbols[symbolId].maxLeverage, maxLeverage);\\r\\n        symbolLayout.symbols[symbolId].maxLeverage = maxLeverage;\\r\\n    }\\r\\n\\r\\n    function setSymbolAcceptableValues(\\r\\n        uint256 symbolId,\\r\\n        uint256 minAcceptableQuoteValue,\\r\\n        uint256 minAcceptablePortionLF\\r\\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\\r\\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\\r\\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \\\"ControlFacet: Invalid id\\\");\\r\\n        emit SetSymbolAcceptableValues(\\r\\n            symbolId,\\r\\n            symbolLayout.symbols[symbolId].minAcceptableQuoteValue,\\r\\n            symbolLayout.symbols[symbolId].minAcceptablePortionLF,\\r\\n            minAcceptableQuoteValue,\\r\\n            minAcceptablePortionLF\\r\\n        );\\r\\n        symbolLayout.symbols[symbolId].minAcceptableQuoteValue = minAcceptableQuoteValue;\\r\\n        symbolLayout.symbols[symbolId].minAcceptablePortionLF = minAcceptablePortionLF;\\r\\n    }\\r\\n\\r\\n    function setSymbolTradingFee(\\r\\n        uint256 symbolId,\\r\\n        uint256 tradingFee\\r\\n    ) external onlyRole(LibAccessibility.SYMBOL_MANAGER_ROLE) {\\r\\n        SymbolStorage.Layout storage symbolLayout = SymbolStorage.layout();\\r\\n        require(symbolId >= 1 && symbolId <= symbolLayout.lastId, \\\"ControlFacet: Invalid id\\\");\\r\\n        emit SetSymbolTradingFee(symbolId, symbolLayout.symbols[symbolId].tradingFee, tradingFee);\\r\\n        symbolLayout.symbols[symbolId].tradingFee = tradingFee;\\r\\n    }\\r\\n\\r\\n    /////////////////////////////////////\\r\\n\\r\\n    // CoolDowns\\r\\n\\r\\n    function setDeallocateCooldown(\\r\\n        uint256 deallocateCooldown\\r\\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\\r\\n        emit SetDeallocateCooldown(MAStorage.layout().deallocateCooldown, deallocateCooldown);\\r\\n        MAStorage.layout().deallocateCooldown = deallocateCooldown;\\r\\n    }\\r\\n\\r\\n    function setForceCancelCooldown(\\r\\n        uint256 forceCancelCooldown\\r\\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\\r\\n        emit SetForceCancelCooldown(MAStorage.layout().forceCancelCooldown, forceCancelCooldown);\\r\\n        MAStorage.layout().forceCancelCooldown = forceCancelCooldown;\\r\\n    }\\r\\n\\r\\n    function setForceCloseCooldown(\\r\\n        uint256 forceCloseCooldown\\r\\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\\r\\n        emit SetForceCloseCooldown(MAStorage.layout().forceCloseCooldown, forceCloseCooldown);\\r\\n        MAStorage.layout().forceCloseCooldown = forceCloseCooldown;\\r\\n    }\\r\\n\\r\\n    function setForceCancelCloseCooldown(\\r\\n        uint256 forceCancelCloseCooldown\\r\\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\\r\\n        emit SetForceCancelCloseCooldown(\\r\\n            MAStorage.layout().forceCancelCloseCooldown,\\r\\n            forceCancelCloseCooldown\\r\\n        );\\r\\n        MAStorage.layout().forceCancelCloseCooldown = forceCancelCloseCooldown;\\r\\n    }\\r\\n\\r\\n    function setLiquidatorShare(\\r\\n        uint256 liquidatorShare\\r\\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\\r\\n        emit SetLiquidatorShare(MAStorage.layout().liquidatorShare, liquidatorShare);\\r\\n        MAStorage.layout().liquidatorShare = liquidatorShare;\\r\\n    }\\r\\n\\r\\n    function setForceCloseGapRatio(\\r\\n        uint256 forceCloseGapRatio\\r\\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\\r\\n        emit SetForceCloseGapRatio(MAStorage.layout().forceCloseGapRatio, forceCloseGapRatio);\\r\\n        MAStorage.layout().forceCloseGapRatio = forceCloseGapRatio;\\r\\n    }\\r\\n\\r\\n    function setPendingQuotesValidLength(\\r\\n        uint256 pendingQuotesValidLength\\r\\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\\r\\n        emit SetPendingQuotesValidLength(\\r\\n            MAStorage.layout().pendingQuotesValidLength,\\r\\n            pendingQuotesValidLength\\r\\n        );\\r\\n        MAStorage.layout().pendingQuotesValidLength = pendingQuotesValidLength;\\r\\n    }\\r\\n\\r\\n    // Pause State\\r\\n\\r\\n    function setFeeCollector(\\r\\n        address feeCollector\\r\\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        require(feeCollector != address(0),\\\"ControlFacet: Zero address\\\");\\r\\n        emit SetFeeCollector(GlobalAppStorage.layout().feeCollector, feeCollector);\\r\\n        GlobalAppStorage.layout().feeCollector = feeCollector;\\r\\n    }\\r\\n\\r\\n    function pauseGlobal() external onlyRole(LibAccessibility.PAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().globalPaused = true;\\r\\n        emit PauseGlobal();\\r\\n    }\\r\\n\\r\\n    function pauseLiquidation() external onlyRole(LibAccessibility.PAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().liquidationPaused = true;\\r\\n        emit PauseLiquidation();\\r\\n    }\\r\\n\\r\\n    function pauseAccounting() external onlyRole(LibAccessibility.PAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().accountingPaused = true;\\r\\n        emit PauseAccounting();\\r\\n    }\\r\\n\\r\\n    function pausePartyAActions() external onlyRole(LibAccessibility.PAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().partyAActionsPaused = true;\\r\\n        emit PausePartyAActions();\\r\\n    }\\r\\n\\r\\n    function pausePartyBActions() external onlyRole(LibAccessibility.PAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().partyBActionsPaused = true;\\r\\n        emit PausePartyBActions();\\r\\n    }\\r\\n\\r\\n    function activeEmergencyMode() external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        GlobalAppStorage.layout().emergencyMode = true;\\r\\n        emit ActiveEmergencyMode();\\r\\n    }\\r\\n\\r\\n    function unpauseGlobal() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().globalPaused = false;\\r\\n        emit UnpauseGlobal();\\r\\n    }\\r\\n\\r\\n    function unpauseLiquidation() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().liquidationPaused = false;\\r\\n        emit UnpauseLiquidation();\\r\\n    }\\r\\n\\r\\n    function unpauseAccounting() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().accountingPaused = false;\\r\\n        emit UnpauseAccounting();\\r\\n    }\\r\\n\\r\\n    function unpausePartyAActions() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().partyAActionsPaused = false;\\r\\n        emit UnpausePartyAActions();\\r\\n    }\\r\\n\\r\\n    function unpausePartyBActions() external onlyRole(LibAccessibility.UNPAUSER_ROLE) {\\r\\n        GlobalAppStorage.layout().partyBActionsPaused = false;\\r\\n        emit UnpausePartyBActions();\\r\\n    }\\r\\n\\r\\n    function setLiquidationTimeout(\\r\\n        uint256 liquidationTimeout\\r\\n    ) external onlyRole(LibAccessibility.SETTER_ROLE) {\\r\\n        emit SetLiquidationTimeout(MAStorage.layout().liquidationTimeout, liquidationTimeout);\\r\\n        MAStorage.layout().liquidationTimeout = liquidationTimeout;\\r\\n    }\\r\\n\\r\\n    function suspendedAddress(\\r\\n        address user\\r\\n    ) external onlyRole(LibAccessibility.SUSPENDER_ROLE) {\\r\\n        require(user != address(0),\\\"ControlFacet: Zero address\\\");\\r\\n        emit SetSuspendedAddress(user, true);\\r\\n        AccountStorage.layout().suspendedAddresses[user] = true;\\r\\n    }\\r\\n\\r\\n    function unsuspendedAddress(\\r\\n        address user\\r\\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        require(user != address(0),\\\"ControlFacet: Zero address\\\");\\r\\n        emit SetSuspendedAddress(user, false);\\r\\n        AccountStorage.layout().suspendedAddresses[user] = false;\\r\\n    }\\r\\n\\r\\n    function deactiveEmergencyMode() external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        GlobalAppStorage.layout().emergencyMode = false;\\r\\n        emit DeactiveEmergencyMode();\\r\\n    }\\r\\n\\r\\n    function setBalanceLimitPerUser(\\r\\n        uint256 balanceLimitPerUser\\r\\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        emit SetBalanceLimitPerUser(balanceLimitPerUser);\\r\\n        GlobalAppStorage.layout().balanceLimitPerUser = balanceLimitPerUser;\\r\\n    }\\r\\n\\r\\n    function setPartyBEmergencyStatus(\\r\\n        address[] memory partyBs,\\r\\n        bool status\\r\\n    ) external onlyRole(LibAccessibility.DEFAULT_ADMIN_ROLE) {\\r\\n        for (uint8 i; i < partyBs.length; i++) {\\r\\n            require(partyBs[i] != address(0),\\\"ControlFacet: Zero address\\\");\\r\\n            GlobalAppStorage.layout().partyBEmergencyStatus[partyBs[i]] = status;\\r\\n            emit SetPartyBEmergencyStatus(partyBs[i], status);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/facets/control/IControlEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\ninterface IControlEvents {\\r\\n    event RoleGranted(bytes32 role, address user);\\r\\n    event RoleRevoked(bytes32 role, address user);\\r\\n    event SetMuonConfig(\\r\\n        uint256 upnlValidTime,\\r\\n        uint256 priceValidTime,\\r\\n        uint256 priceQuantityValidTime\\r\\n    );\\r\\n    event SetMuonIds(uint256 muonAppId, address gateway, uint256 x, uint8 parity);\\r\\n    event SetCollateral(address collateral);\\r\\n    event AddSymbol(\\r\\n        uint256 id,\\r\\n        string name,\\r\\n        uint256 minAcceptableQuoteValue,\\r\\n        uint256 minAcceptablePortionLF,\\r\\n        uint256 tradingFee,\\r\\n        uint256 maxLeverage,\\r\\n        uint256 fundingRateEpochDuration,\\r\\n        uint256 fundingRateWindowTime\\r\\n    );\\r\\n    event SetFeeCollector(address oldFeeCollector, address newFeeCollector);\\r\\n    event SetSymbolValidationState(uint256 id, bool oldState, bool isValid);\\r\\n    event SetSymbolFundingState(uint256 id, uint256 fundingRateEpochDuration, uint256 fundingRateWindowTime);\\r\\n    event SetSymbolAcceptableValues(\\r\\n        uint256 symbolId,\\r\\n        uint256 oldMinAcceptableQuoteValue,\\r\\n        uint256 oldMinAcceptablePortionLF,\\r\\n        uint256 minAcceptableQuoteValue,\\r\\n        uint256 minAcceptablePortionLF\\r\\n    );\\r\\n    event SetSymbolTradingFee(uint256 symbolId, uint256 oldTradingFee, uint256 tradingFee);\\r\\n    event SetSymbolMaxSlippage(uint256 symbolId, uint256 oldMaxSlippage, uint256 maxSlippage);\\r\\n    event SetSymbolMaxLeverage(uint256 symbolId, uint256 oldMaxLeverage, uint256 maxLeverage);\\r\\n    event SetDeallocateCooldown(uint256 oldDeallocateCooldown, uint256 newDeallocateCooldown);\\r\\n    event SetForceCancelCooldown(uint256 oldForceCancelCooldown, uint256 newForceCancelCooldown);\\r\\n    event SetForceCloseCooldown(uint256 oldForceCloseCooldown, uint256 newForceCloseCooldown);\\r\\n    event SetForceCancelCloseCooldown(\\r\\n        uint256 oldForceCancelCloseCooldown,\\r\\n        uint256 newForceCancelCloseCooldown\\r\\n    );\\r\\n    event SetLiquidatorShare(uint256 oldLiquidatorShare, uint256 newLiquidatorShare);\\r\\n    event SetForceCloseGapRatio(uint256 oldForceCloseGapRatio, uint256 newForceCloseGapRatio);\\r\\n    event SetPendingQuotesValidLength(\\r\\n        uint256 oldPendingQuotesValidLength,\\r\\n        uint256 newPendingQuotesValidLength\\r\\n    );\\r\\n    event PauseGlobal();\\r\\n    event PauseLiquidation();\\r\\n    event PauseAccounting();\\r\\n    event PausePartyAActions();\\r\\n    event PausePartyBActions();\\r\\n    event ActiveEmergencyMode();\\r\\n    event UnpauseGlobal();\\r\\n    event UnpauseLiquidation();\\r\\n    event UnpauseAccounting();\\r\\n    event UnpausePartyAActions();\\r\\n    event UnpausePartyBActions();\\r\\n    event DeactiveEmergencyMode();\\r\\n    event SetLiquidationTimeout(uint256 oldLiquidationTimeout, uint256 newLiquidationTimeout);\\r\\n    event SetSuspendedAddress(address user, bool isSuspended);\\r\\n    event SetPartyBEmergencyStatus(address partyB, bool status);\\r\\n    event SetBalanceLimitPerUser(uint256 balanceLimitPerUser);\\r\\n    event RegisterPartyB(address partyB);\\r\\n    event DeregisterPartyB(address partyB, uint256 index);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    // Add=0, Replace=1, Remove=2\\r\\n    enum FacetCutAction {\\r\\n        Add,\\r\\n        Replace,\\r\\n        Remove\\r\\n    }\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\n// A loupe is a small magnifying glass used to look at diamonds.\\r\\n// These functions look at diamonds\\r\\ninterface IDiamondLoupe {\\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return facetFunctionSelectors_\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    /// @notice Gets the facet that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibAccessibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"../storages/GlobalAppStorage.sol\\\";\\r\\n\\r\\nlibrary LibAccessibility {\\r\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = keccak256(\\\"DEFAULT_ADMIN_ROLE\\\");\\r\\n    bytes32 public constant MUON_SETTER_ROLE = keccak256(\\\"MUON_SETTER_ROLE\\\");\\r\\n    bytes32 public constant SYMBOL_MANAGER_ROLE = keccak256(\\\"SYMBOL_MANAGER_ROLE\\\");\\r\\n    bytes32 public constant SETTER_ROLE = keccak256(\\\"SETTER_ROLE\\\");\\r\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\r\\n    bytes32 public constant UNPAUSER_ROLE = keccak256(\\\"UNPAUSER_ROLE\\\");\\r\\n    bytes32 public constant PARTY_B_MANAGER_ROLE = keccak256(\\\"PARTY_B_MANAGER_ROLE\\\");\\r\\n    bytes32 public constant LIQUIDATOR_ROLE = keccak256(\\\"LIQUIDATOR_ROLE\\\");\\r\\n    bytes32 public constant SUSPENDER_ROLE = keccak256(\\\"SUSPENDER_ROLE\\\");\\r\\n    bytes32 public constant DISPUTE_ROLE = keccak256(\\\"DISPUTE_ROLE\\\");\\r\\n\\r\\n    function hasRole(address user, bytes32 role) internal view returns (bool) {\\r\\n        GlobalAppStorage.Layout storage layout = GlobalAppStorage.layout();\\r\\n        return layout.hasRole[user][role];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\nimport { IDiamondLoupe } from \\\"../interfaces/IDiamondLoupe.sol\\\";\\r\\nimport { IERC165 } from \\\"../interfaces/IERC165.sol\\\";\\r\\n\\r\\nlibrary LibDiamond {\\r\\n    bytes32 public constant DIAMOND_STORAGE_POSITION =\\r\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n\\r\\n    struct FacetAddressAndSelectorPosition {\\r\\n        address facetAddress;\\r\\n        uint16 selectorPosition;\\r\\n    }\\r\\n\\r\\n    struct DiamondStorage {\\r\\n        // function selector => facet address and selector position in selectors array\\r\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\r\\n        bytes4[] selectors;\\r\\n        mapping(bytes4 => bool) supportedInterfaces;\\r\\n        // owner of the contract\\r\\n        address contractOwner;\\r\\n    }\\r\\n\\r\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    function setContractOwner(address _newOwner) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        address previousOwner = ds.contractOwner;\\r\\n        ds.contractOwner = _newOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\r\\n    }\\r\\n\\r\\n    function contractOwner() internal view returns (address contractOwner_) {\\r\\n        contractOwner_ = diamondStorage().contractOwner;\\r\\n    }\\r\\n\\r\\n    function enforceIsOwnerOrContract() internal view {\\r\\n        require(\\r\\n            msg.sender == diamondStorage().contractOwner || msg.sender == address(this),\\r\\n            \\\"LibDiamond: Must be contract or owner\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function enforceIsContractOwner() internal view {\\r\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\r\\n    }\\r\\n\\r\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n\\r\\n    // Internal function version of diamondCut\\r\\n    function diamondCut(\\r\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\r\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\r\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\r\\n                addFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\r\\n                replaceFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\r\\n                removeFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else {\\r\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\r\\n            }\\r\\n        }\\r\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\r\\n        initializeDiamondCut(_init, _calldata);\\r\\n    }\\r\\n\\r\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        uint16 selectorCount = uint16(ds.selectors.length);\\r\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            require(\\r\\n                oldFacetAddress == address(0),\\r\\n                \\\"LibDiamondCut: Can't add function that already exists\\\"\\r\\n            );\\r\\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(\\r\\n                _facetAddress,\\r\\n                selectorCount\\r\\n            );\\r\\n            ds.selectors.push(selector);\\r\\n            selectorCount++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Replace facet can't be address(0)\\\");\\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            // can't replace immutable functions -- functions defined directly in the diamond\\r\\n            require(\\r\\n                oldFacetAddress != address(this),\\r\\n                \\\"LibDiamondCut: Can't replace immutable function\\\"\\r\\n            );\\r\\n            require(\\r\\n                oldFacetAddress != _facetAddress,\\r\\n                \\\"LibDiamondCut: Can't replace function with same function\\\"\\r\\n            );\\r\\n            require(\\r\\n                oldFacetAddress != address(0),\\r\\n                \\\"LibDiamondCut: Can't replace function that doesn't exist\\\"\\r\\n            );\\r\\n            // replace old facet address\\r\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        require(\\r\\n            _facetAddress == address(0),\\r\\n            \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\r\\n        );\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds\\r\\n                .facetAddressAndSelectorPosition[selector];\\r\\n            require(\\r\\n                oldFacetAddressAndSelectorPosition.facetAddress != address(0),\\r\\n                \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\r\\n            );\\r\\n            // can't remove immutable functions -- functions defined directly in the diamond\\r\\n            require(\\r\\n                oldFacetAddressAndSelectorPosition.facetAddress != address(this),\\r\\n                \\\"LibDiamondCut: Can't remove immutable function.\\\"\\r\\n            );\\r\\n            // replace selector with last selector\\r\\n            selectorCount--;\\r\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\r\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\r\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\r\\n                ds\\r\\n                    .facetAddressAndSelectorPosition[lastSelector]\\r\\n                    .selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\\r\\n            }\\r\\n            // delete last selector\\r\\n            ds.selectors.pop();\\r\\n            delete ds.facetAddressAndSelectorPosition[selector];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\r\\n        if (_init == address(0)) {\\r\\n            require(\\r\\n                _calldata.length == 0,\\r\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\r\\n            );\\r\\n        } else {\\r\\n            require(\\r\\n                _calldata.length > 0,\\r\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\r\\n            );\\r\\n            if (_init != address(this)) {\\r\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\r\\n            }\\r\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n            if (!success) {\\r\\n                if (error.length > 0) {\\r\\n                    // bubble up the error\\r\\n                    revert(string(error));\\r\\n                } else {\\r\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\r\\n        uint256 contractSize;\\r\\n        assembly {\\r\\n            contractSize := extcodesize(_contract)\\r\\n        }\\r\\n        require(contractSize > 0, _errorMessage);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibLockedValues.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\nimport \\\"../storages/QuoteStorage.sol\\\";\\r\\n\\r\\nstruct LockedValues {\\r\\n    uint256 cva;\\r\\n    uint256 lf;\\r\\n    uint256 partyAmm;\\r\\n    uint256 partyBmm;\\r\\n}\\r\\n\\r\\nlibrary LockedValuesOps {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    function add(LockedValues storage self, LockedValues memory a)\\r\\n        internal\\r\\n        returns (LockedValues storage)\\r\\n    {\\r\\n        self.cva = self.cva.add(a.cva);\\r\\n        self.partyAmm = self.partyAmm.add(a.partyAmm);\\r\\n        self.partyBmm = self.partyBmm.add(a.partyBmm);\\r\\n        self.lf = self.lf.add(a.lf);\\r\\n        return self;\\r\\n    }\\r\\n\\r\\n    function addQuote(LockedValues storage self, Quote storage quote)\\r\\n        internal\\r\\n        returns (LockedValues storage)\\r\\n    {\\r\\n        return add(self, quote.lockedValues);\\r\\n    }\\r\\n\\r\\n    function sub(LockedValues storage self, LockedValues memory a)\\r\\n        internal\\r\\n        returns (LockedValues storage)\\r\\n    {\\r\\n        self.cva = self.cva.sub(a.cva);\\r\\n        self.partyAmm = self.partyAmm.sub(a.partyAmm);\\r\\n        self.partyBmm = self.partyBmm.sub(a.partyBmm);\\r\\n        self.lf = self.lf.sub(a.lf);\\r\\n        return self;\\r\\n    }\\r\\n\\r\\n    function subQuote(LockedValues storage self, Quote storage quote)\\r\\n        internal\\r\\n        returns (LockedValues storage)\\r\\n    {\\r\\n        return sub(self, quote.lockedValues);\\r\\n    }\\r\\n\\r\\n    function makeZero(LockedValues storage self) internal returns (LockedValues storage) {\\r\\n        self.cva = 0;\\r\\n        self.partyAmm = 0;\\r\\n        self.partyBmm = 0;\\r\\n        self.lf = 0;\\r\\n        return self;\\r\\n    }\\r\\n\\r\\n    function totalForPartyA(LockedValues memory self) internal pure returns (uint256) {\\r\\n        return self.cva + self.partyAmm + self.lf;\\r\\n    }\\r\\n\\r\\n    function totalForPartyB(LockedValues memory self) internal pure returns (uint256) {\\r\\n        return self.cva + self.partyBmm + self.lf;\\r\\n    }\\r\\n\\r\\n    function mul(LockedValues storage self, uint256 a) internal returns (LockedValues storage) {\\r\\n        self.cva = self.cva.mul(a);\\r\\n        self.partyAmm = self.partyAmm.mul(a);\\r\\n        self.partyBmm = self.partyBmm.mul(a);\\r\\n        self.lf = self.lf.mul(a);\\r\\n        return self;\\r\\n    }\\r\\n\\r\\n    function mulMem(LockedValues memory self, uint256 a)\\r\\n        internal\\r\\n        pure\\r\\n        returns (LockedValues memory)\\r\\n    {\\r\\n        LockedValues memory lockedValues = LockedValues(\\r\\n            self.cva.mul(a),\\r\\n            self.lf.mul(a),\\r\\n            self.partyAmm.mul(a),\\r\\n            self.partyBmm.mul(a)\\r\\n        );\\r\\n        return lockedValues;\\r\\n    }\\r\\n\\r\\n    function div(LockedValues storage self, uint256 a) internal returns (LockedValues storage) {\\r\\n        self.cva = self.cva.div(a);\\r\\n        self.partyAmm = self.partyAmm.div(a);\\r\\n        self.partyBmm = self.partyBmm.div(a);\\r\\n        self.lf = self.lf.div(a);\\r\\n        return self;\\r\\n    }\\r\\n\\r\\n    function divMem(LockedValues memory self, uint256 a)\\r\\n        internal\\r\\n        pure\\r\\n        returns (LockedValues memory)\\r\\n    {\\r\\n        LockedValues memory lockedValues = LockedValues(\\r\\n            self.cva.div(a),\\r\\n            self.lf.div(a),\\r\\n            self.partyAmm.div(a),\\r\\n            self.partyBmm.div(a)\\r\\n        );\\r\\n        return lockedValues;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/storages/AccountStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"../libraries/LibLockedValues.sol\\\";\\r\\n\\r\\nenum LiquidationType {\\r\\n    NONE,\\r\\n    NORMAL,\\r\\n    LATE,\\r\\n    OVERDUE\\r\\n}\\r\\n\\r\\nstruct SettlementState {\\r\\n    int256 actualAmount; \\r\\n    int256 expectedAmount; \\r\\n    uint256 cva;\\r\\n    bool pending;\\r\\n}\\r\\n\\r\\nstruct LiquidationDetail {\\r\\n    bytes liquidationId;\\r\\n    LiquidationType liquidationType;\\r\\n    int256 upnl;\\r\\n    int256 totalUnrealizedLoss;\\r\\n    uint256 deficit;\\r\\n    uint256 liquidationFee;\\r\\n    uint256 timestamp;\\r\\n    uint256 involvedPartyBCounts;\\r\\n    int256 partyAAccumulatedUpnl;\\r\\n    bool disputed;\\r\\n}\\r\\n\\r\\nstruct Price {\\r\\n    uint256 price;\\r\\n    uint256 timestamp;\\r\\n}\\r\\n\\r\\nlibrary AccountStorage {\\r\\n    bytes32 internal constant ACCOUNT_STORAGE_SLOT = keccak256(\\\"diamond.standard.storage.account\\\");\\r\\n\\r\\n    struct Layout {\\r\\n        // Users deposited amounts\\r\\n        mapping(address => uint256) balances;\\r\\n        mapping(address => uint256) allocatedBalances;\\r\\n        // position value will become pending locked before openPosition and will be locked after that\\r\\n        mapping(address => LockedValues) pendingLockedBalances;\\r\\n        mapping(address => LockedValues) lockedBalances;\\r\\n        mapping(address => mapping(address => uint256)) partyBAllocatedBalances;\\r\\n        mapping(address => mapping(address => LockedValues)) partyBPendingLockedBalances;\\r\\n        mapping(address => mapping(address => LockedValues)) partyBLockedBalances;\\r\\n        mapping(address => uint256) withdrawCooldown;\\r\\n        mapping(address => uint256) partyANonces;\\r\\n        mapping(address => mapping(address => uint256)) partyBNonces;\\r\\n        mapping(address => bool) suspendedAddresses;\\r\\n        mapping(address => LiquidationDetail) liquidationDetails;\\r\\n        mapping(address => mapping(uint256 => Price)) symbolsPrices;\\r\\n        mapping(address => address[]) liquidators;\\r\\n        mapping(address => uint256) partyAReimbursement;\\r\\n        // partyA => partyB => SettlementState\\r\\n        mapping(address => mapping(address => SettlementState)) settlementStates;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = ACCOUNT_STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/storages/GlobalAppStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"../libraries/LibLockedValues.sol\\\";\\r\\n\\r\\nlibrary GlobalAppStorage {\\r\\n    bytes32 internal constant GLOBAL_APP_STORAGE_SLOT =\\r\\n        keccak256(\\\"diamond.standard.storage.global\\\");\\r\\n\\r\\n    struct Layout {\\r\\n        address collateral;\\r\\n        address feeCollector;\\r\\n        bool globalPaused;\\r\\n        bool liquidationPaused;\\r\\n        bool accountingPaused;\\r\\n        bool partyBActionsPaused;\\r\\n        bool partyAActionsPaused;\\r\\n        bool emergencyMode;\\r\\n        uint256 balanceLimitPerUser;\\r\\n        mapping(address => bool) partyBEmergencyStatus;\\r\\n        mapping(address => mapping(bytes32 => bool)) hasRole;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = GLOBAL_APP_STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/storages/MAStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"../libraries/LibLockedValues.sol\\\";\\r\\n\\r\\nlibrary MAStorage {\\r\\n    bytes32 internal constant MA_STORAGE_SLOT =\\r\\n        keccak256(\\\"diamond.standard.storage.masteragreement\\\");\\r\\n\\r\\n    struct Layout {\\r\\n        uint256 deallocateCooldown;\\r\\n        uint256 forceCancelCooldown;\\r\\n        uint256 forceCancelCloseCooldown;\\r\\n        uint256 forceCloseCooldown;\\r\\n        uint256 liquidationTimeout;\\r\\n        uint256 liquidatorShare; // in 18 decimals\\r\\n        uint256 pendingQuotesValidLength;\\r\\n        uint256 forceCloseGapRatio;\\r\\n        mapping(address => bool) partyBStatus;\\r\\n        mapping(address => bool) liquidationStatus;\\r\\n        mapping(address => mapping(address => bool)) partyBLiquidationStatus;\\r\\n        mapping(address => mapping(address => uint256)) partyBLiquidationTimestamp;\\r\\n        mapping(address => mapping(address => uint256)) partyBPositionLiquidatorsShare;\\r\\n        address[] partyBList;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = MA_STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/storages/MuonStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"../libraries/LibLockedValues.sol\\\";\\r\\n\\r\\nstruct SchnorrSign {\\r\\n    uint256 signature;\\r\\n    address owner;\\r\\n    address nonce;\\r\\n}\\r\\n\\r\\nstruct PublicKey {\\r\\n    uint256 x;\\r\\n    uint8 parity;\\r\\n}\\r\\n\\r\\nstruct SingleUpnlSig {\\r\\n    bytes reqId;\\r\\n    uint256 timestamp;\\r\\n    int256 upnl;\\r\\n    bytes gatewaySignature;\\r\\n    SchnorrSign sigs;\\r\\n}\\r\\n\\r\\nstruct SingleUpnlAndPriceSig {\\r\\n    bytes reqId;\\r\\n    uint256 timestamp;\\r\\n    int256 upnl;\\r\\n    uint256 price;\\r\\n    bytes gatewaySignature;\\r\\n    SchnorrSign sigs;\\r\\n}\\r\\n\\r\\nstruct PairUpnlSig {\\r\\n    bytes reqId;\\r\\n    uint256 timestamp;\\r\\n    int256 upnlPartyA;\\r\\n    int256 upnlPartyB;\\r\\n    bytes gatewaySignature;\\r\\n    SchnorrSign sigs;\\r\\n}\\r\\n\\r\\nstruct PairUpnlAndPriceSig {\\r\\n    bytes reqId;\\r\\n    uint256 timestamp;\\r\\n    int256 upnlPartyA;\\r\\n    int256 upnlPartyB;\\r\\n    uint256 price;\\r\\n    bytes gatewaySignature;\\r\\n    SchnorrSign sigs;\\r\\n}\\r\\n\\r\\nstruct LiquidationSig {\\r\\n    bytes reqId;\\r\\n    uint256 timestamp;\\r\\n    bytes liquidationId;\\r\\n    int256 upnl;\\r\\n    int256 totalUnrealizedLoss; \\r\\n    uint256[] symbolIds;\\r\\n    uint256[] prices;\\r\\n    bytes gatewaySignature;\\r\\n    SchnorrSign sigs;\\r\\n}\\r\\n\\r\\nstruct QuotePriceSig {\\r\\n    bytes reqId;\\r\\n    uint256 timestamp;\\r\\n    uint256[] quoteIds;\\r\\n    uint256[] prices;\\r\\n    bytes gatewaySignature;\\r\\n    SchnorrSign sigs;\\r\\n}\\r\\n\\r\\nlibrary MuonStorage {\\r\\n    bytes32 internal constant MUON_STORAGE_SLOT = keccak256(\\\"diamond.standard.storage.muon\\\");\\r\\n\\r\\n    struct Layout {\\r\\n        uint256 upnlValidTime;\\r\\n        uint256 priceValidTime;\\r\\n        uint256 priceQuantityValidTime;\\r\\n        uint256 muonAppId;\\r\\n        PublicKey muonPublicKey;\\r\\n        address validGateway;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = MUON_STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/storages/QuoteStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"../libraries/LibLockedValues.sol\\\";\\r\\n\\r\\nenum PositionType {\\r\\n    LONG,\\r\\n    SHORT\\r\\n}\\r\\n\\r\\nenum OrderType {\\r\\n    LIMIT,\\r\\n    MARKET\\r\\n}\\r\\n\\r\\nenum QuoteStatus {\\r\\n    PENDING, //0\\r\\n    LOCKED, //1\\r\\n    CANCEL_PENDING, //2\\r\\n    CANCELED, //3\\r\\n    OPENED, //4\\r\\n    CLOSE_PENDING, //5\\r\\n    CANCEL_CLOSE_PENDING, //6\\r\\n    CLOSED, //7\\r\\n    LIQUIDATED, //8\\r\\n    EXPIRED //9\\r\\n}\\r\\n\\r\\nstruct Quote {\\r\\n    uint256 id;\\r\\n    address[] partyBsWhiteList;\\r\\n    uint256 symbolId;\\r\\n    PositionType positionType;\\r\\n    OrderType orderType;\\r\\n    // Price of quote which PartyB opened in 18 decimals\\r\\n    uint256 openedPrice;\\r\\n    uint256 initialOpenedPrice;\\r\\n    // Price of quote which PartyA requested in 18 decimals\\r\\n    uint256 requestedOpenPrice;\\r\\n    uint256 marketPrice;\\r\\n    // Quantity of quote which PartyA requested in 18 decimals\\r\\n    uint256 quantity;\\r\\n    // Quantity of quote which PartyB has closed until now in 18 decimals\\r\\n    uint256 closedAmount;\\r\\n    LockedValues initialLockedValues;\\r\\n    LockedValues lockedValues;\\r\\n    uint256 maxFundingRate;\\r\\n    address partyA;\\r\\n    address partyB;\\r\\n    QuoteStatus quoteStatus;\\r\\n    uint256 avgClosedPrice;\\r\\n    uint256 requestedClosePrice;\\r\\n    uint256 quantityToClose;\\r\\n    // handle partially open position\\r\\n    uint256 parentId;\\r\\n    uint256 createTimestamp;\\r\\n    uint256 statusModifyTimestamp;\\r\\n    uint256 lastFundingPaymentTimestamp;\\r\\n    uint256 deadline;\\r\\n    uint256 tradingFee;\\r\\n}\\r\\n\\r\\nlibrary QuoteStorage {\\r\\n    bytes32 internal constant QUOTE_STORAGE_SLOT = keccak256(\\\"diamond.standard.storage.quote\\\");\\r\\n\\r\\n    struct Layout {\\r\\n        mapping(address => uint256[]) quoteIdsOf;\\r\\n        mapping(uint256 => Quote) quotes;\\r\\n        mapping(address => uint256) partyAPositionsCount;\\r\\n        mapping(address => mapping(address => uint256)) partyBPositionsCount;\\r\\n        mapping(address => uint256[]) partyAPendingQuotes;\\r\\n        mapping(address => mapping(address => uint256[])) partyBPendingQuotes;\\r\\n        mapping(address => uint256[]) partyAOpenPositions;\\r\\n        mapping(uint256 => uint256) partyAPositionsIndex;\\r\\n        mapping(address => mapping(address => uint256[])) partyBOpenPositions;\\r\\n        mapping(uint256 => uint256) partyBPositionsIndex;\\r\\n        uint256 lastId;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = QUOTE_STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/storages/SymbolStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nstruct Symbol {\\r\\n    uint256 symbolId;\\r\\n    string name;\\r\\n    bool isValid;\\r\\n    uint256 minAcceptableQuoteValue;\\r\\n    uint256 minAcceptablePortionLF;\\r\\n    uint256 tradingFee;\\r\\n    uint256 maxLeverage;\\r\\n    uint256 fundingRateEpochDuration;\\r\\n    uint256 fundingRateWindowTime;\\r\\n}\\r\\n\\r\\nlibrary SymbolStorage {\\r\\n    bytes32 internal constant SYMBOL_STORAGE_SLOT = keccak256(\\\"diamond.standard.storage.symbol\\\");\\r\\n\\r\\n    struct Layout {\\r\\n        mapping(uint256 => Symbol) symbols;\\r\\n        uint256 lastId;\\r\\n    }\\r\\n\\r\\n    function layout() internal pure returns (Layout storage l) {\\r\\n        bytes32 slot = SYMBOL_STORAGE_SLOT;\\r\\n        assembly {\\r\\n            l.slot := slot\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/Accessibility.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"../storages/MAStorage.sol\\\";\\r\\nimport \\\"../storages/AccountStorage.sol\\\";\\r\\nimport \\\"../storages/QuoteStorage.sol\\\";\\r\\nimport \\\"../libraries/LibAccessibility.sol\\\";\\r\\n\\r\\nabstract contract Accessibility {\\r\\n    modifier onlyPartyB() {\\r\\n        require(MAStorage.layout().partyBStatus[msg.sender], \\\"Accessibility: Should be partyB\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notPartyB() {\\r\\n        require(!MAStorage.layout().partyBStatus[msg.sender], \\\"Accessibility: Shouldn't be partyB\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyRole(bytes32 role) {\\r\\n        require(LibAccessibility.hasRole(msg.sender, role), \\\"Accessibility: Must has role\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notLiquidatedPartyA(address partyA) {\\r\\n        require(\\r\\n            !MAStorage.layout().liquidationStatus[partyA],\\r\\n            \\\"Accessibility: PartyA isn't solvent\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notLiquidatedPartyB(address partyB, address partyA) {\\r\\n        require(\\r\\n            !MAStorage.layout().partyBLiquidationStatus[partyB][partyA],\\r\\n            \\\"Accessibility: PartyB isn't solvent\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notLiquidated(uint256 quoteId) {\\r\\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\\r\\n        require(\\r\\n            !MAStorage.layout().liquidationStatus[quote.partyA],\\r\\n            \\\"Accessibility: PartyA isn't solvent\\\"\\r\\n        );\\r\\n        require(\\r\\n            !MAStorage.layout().partyBLiquidationStatus[quote.partyB][quote.partyA],\\r\\n            \\\"Accessibility: PartyB isn't solvent\\\"\\r\\n        );\\r\\n        require(\\r\\n            quote.quoteStatus != QuoteStatus.LIQUIDATED && quote.quoteStatus != QuoteStatus.CLOSED,\\r\\n            \\\"Accessibility: Invalid state\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyPartyAOfQuote(uint256 quoteId) {\\r\\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\\r\\n        require(quote.partyA == msg.sender, \\\"Accessibility: Should be partyA of quote\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyPartyBOfQuote(uint256 quoteId) {\\r\\n        Quote storage quote = QuoteStorage.layout().quotes[quoteId];\\r\\n        require(quote.partyB == msg.sender, \\\"Accessibility: Should be partyB of quote\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier notSuspended(address user) {\\r\\n        require(\\r\\n            !AccountStorage.layout().suspendedAddresses[user],\\r\\n            \\\"Accessibility: Sender is Suspended\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: SYMM-Core-Business-Source-License-1.1\\r\\n// This contract is licensed under the SYMM Core Business Source License 1.1\\r\\n// Copyright (c) 2023 Symmetry Labs AG\\r\\n// For more information, see https://docs.symm.io/legal-disclaimer/license\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\nimport \\\"../libraries/LibDiamond.sol\\\";\\r\\n\\r\\nabstract contract Ownable {\\r\\n    modifier onlyOwner() {\\r\\n        LibDiamond.enforceIsContractOwner();\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyOwnerOrContract() {\\r\\n        LibDiamond.enforceIsOwnerOrContract();\\r\\n        _;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[],\"name\":\"ActiveEmergencyMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAcceptableQuoteValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAcceptablePortionLF\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundingRateEpochDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundingRateWindowTime\",\"type\":\"uint256\"}],\"name\":\"AddSymbol\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DeactiveEmergencyMode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"partyB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"DeregisterPartyB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseAccounting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseGlobal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseLiquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PausePartyAActions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PausePartyBActions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"partyB\",\"type\":\"address\"}],\"name\":\"RegisterPartyB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balanceLimitPerUser\",\"type\":\"uint256\"}],\"name\":\"SetBalanceLimitPerUser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"SetCollateral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDeallocateCooldown\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDeallocateCooldown\",\"type\":\"uint256\"}],\"name\":\"SetDeallocateCooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"SetFeeCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldForceCancelCloseCooldown\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newForceCancelCloseCooldown\",\"type\":\"uint256\"}],\"name\":\"SetForceCancelCloseCooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldForceCancelCooldown\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newForceCancelCooldown\",\"type\":\"uint256\"}],\"name\":\"SetForceCancelCooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldForceCloseCooldown\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newForceCloseCooldown\",\"type\":\"uint256\"}],\"name\":\"SetForceCloseCooldown\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldForceCloseGapRatio\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newForceCloseGapRatio\",\"type\":\"uint256\"}],\"name\":\"SetForceCloseGapRatio\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLiquidationTimeout\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidationTimeout\",\"type\":\"uint256\"}],\"name\":\"SetLiquidationTimeout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldLiquidatorShare\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLiquidatorShare\",\"type\":\"uint256\"}],\"name\":\"SetLiquidatorShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"upnlValidTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceValidTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"priceQuantityValidTime\",\"type\":\"uint256\"}],\"name\":\"SetMuonConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"muonAppId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gateway\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"parity\",\"type\":\"uint8\"}],\"name\":\"SetMuonIds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"partyB\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetPartyBEmergencyStatus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldPendingQuotesValidLength\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newPendingQuotesValidLength\",\"type\":\"uint256\"}],\"name\":\"SetPendingQuotesValidLength\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isSuspended\",\"type\":\"bool\"}],\"name\":\"SetSuspendedAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinAcceptableQuoteValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMinAcceptablePortionLF\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAcceptableQuoteValue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAcceptablePortionLF\",\"type\":\"uint256\"}],\"name\":\"SetSymbolAcceptableValues\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundingRateEpochDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fundingRateWindowTime\",\"type\":\"uint256\"}],\"name\":\"SetSymbolFundingState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxLeverage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"name\":\"SetSymbolMaxLeverage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMaxSlippage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSlippage\",\"type\":\"uint256\"}],\"name\":\"SetSymbolMaxSlippage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldTradingFee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"}],\"name\":\"SetSymbolTradingFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"oldState\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"name\":\"SetSymbolValidationState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnpauseAccounting\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnpauseGlobal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnpauseLiquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnpausePartyAActions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"UnpausePartyBActions\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"activeEmergencyMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"minAcceptableQuoteValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAcceptablePortionLF\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingRateEpochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingRateWindowTime\",\"type\":\"uint256\"}],\"name\":\"addSymbol\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"minAcceptableQuoteValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAcceptablePortionLF\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingRateEpochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingRateWindowTime\",\"type\":\"uint256\"}],\"internalType\":\"struct Symbol[]\",\"name\":\"symbols\",\"type\":\"tuple[]\"}],\"name\":\"addSymbols\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deactiveEmergencyMode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"partyB\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"deregisterPartyB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseAccounting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseGlobal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausePartyAActions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pausePartyBActions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"partyB\",\"type\":\"address\"}],\"name\":\"registerPartyB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"balanceLimitPerUser\",\"type\":\"uint256\"}],\"name\":\"setBalanceLimitPerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"}],\"name\":\"setCollateral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deallocateCooldown\",\"type\":\"uint256\"}],\"name\":\"setDeallocateCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forceCancelCloseCooldown\",\"type\":\"uint256\"}],\"name\":\"setForceCancelCloseCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forceCancelCooldown\",\"type\":\"uint256\"}],\"name\":\"setForceCancelCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forceCloseCooldown\",\"type\":\"uint256\"}],\"name\":\"setForceCloseCooldown\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"forceCloseGapRatio\",\"type\":\"uint256\"}],\"name\":\"setForceCloseGapRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidationTimeout\",\"type\":\"uint256\"}],\"name\":\"setLiquidationTimeout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidatorShare\",\"type\":\"uint256\"}],\"name\":\"setLiquidatorShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"upnlValidTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceValidTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceQuantityValidTime\",\"type\":\"uint256\"}],\"name\":\"setMuonConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"muonAppId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"validGateway\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"parity\",\"type\":\"uint8\"}],\"internalType\":\"struct PublicKey\",\"name\":\"publicKey\",\"type\":\"tuple\"}],\"name\":\"setMuonIds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"partyBs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPartyBEmergencyStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"pendingQuotesValidLength\",\"type\":\"uint256\"}],\"name\":\"setPendingQuotesValidLength\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAcceptableQuoteValue\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAcceptablePortionLF\",\"type\":\"uint256\"}],\"name\":\"setSymbolAcceptableValues\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingRateEpochDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundingRateWindowTime\",\"type\":\"uint256\"}],\"name\":\"setSymbolFundingState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxLeverage\",\"type\":\"uint256\"}],\"name\":\"setSymbolMaxLeverage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradingFee\",\"type\":\"uint256\"}],\"name\":\"setSymbolTradingFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"symbolId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isValid\",\"type\":\"bool\"}],\"name\":\"setSymbolValidationState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"suspendedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseAccounting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseGlobal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpauseLiquidation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpausePartyAActions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpausePartyBActions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"unsuspendedAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ControlFacet", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}