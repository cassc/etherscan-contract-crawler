{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/lsp/LSP6KeyManagerProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * FANZONE.io NFT implementation of the LUKSO LSP-8-IdentifiableDigitalAsset standard\\n * for more see https://fanzone.io/nfts\\n */\\n\\n// interfaces\\nimport \\\"./ILSP6KeyManagerProxy.sol\\\";\\n\\n// modules\\nimport \\\"@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6KeyManagerInitAbstract.sol\\\";\\n\\ncontract LSP6KeyManagerProxy is\\n    ILSP6KeyManagerProxy,\\n    LSP6KeyManagerInitAbstract\\n{\\n    // solhint-disable-next-line no-empty-blocks\\n    constructor() initializer {\\n        // when the base logic contract is deployed, the initialized flag should get set so its not\\n        // possible to call `initialize(...)`\\n    }\\n\\n    function initialize(address universalProfile) public override initializer {\\n        LSP6KeyManagerInitAbstract._initialize(universalProfile);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lsp/ILSP6KeyManagerProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\n\\npragma solidity ^0.8.0;\\n\\ninterface ILSP6KeyManagerProxy {\\n    function initialize(address universalProfile) external;\\n}\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6KeyManagerInitAbstract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.6;\\n\\n// modules\\nimport \\\"./LSP6KeyManagerCore.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @title Proxy implementation of a contract acting as a controller of an ERC725 Account, using permissions stored in the ERC725Y storage\\n * @author Fabian Vogelsteller, Jean Cavallera\\n * @dev all the permissions can be set on the ERC725 Account using `setData(...)` with the keys constants below\\n */\\nabstract contract LSP6KeyManagerInitAbstract is\\n    Initializable,\\n    LSP6KeyManagerCore\\n{\\n    function _initialize(address _account) internal virtual onlyInitializing {\\n        account = ERC725(_account);\\n    }\\n}\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6KeyManagerCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.6;\\n\\n// modules\\nimport \\\"@erc725/smart-contracts/contracts/ERC725Y.sol\\\";\\nimport \\\"@erc725/smart-contracts/contracts/ERC725.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\n\\n// interfaces\\nimport \\\"./ILSP6KeyManager.sol\\\";\\n\\n// libraries\\nimport \\\"@erc725/smart-contracts/contracts/utils/ErrorHandlerLib.sol\\\";\\nimport \\\"./LSP6Utils.sol\\\";\\n\\nimport \\\"../Utils/ERC725Utils.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\\\";\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\n\\n// constants\\nimport \\\"./LSP6Constants.sol\\\";\\nimport \\\"../LSP0ERC725Account/LSP0Constants.sol\\\";\\nimport \\\"@erc725/smart-contracts/contracts/constants.sol\\\";\\n\\n/**\\n * @dev revert when address `from` does not have any permissions set\\n * on the account linked to this Key Manager\\n * @param from the address that does not have permissions\\n */\\nerror NoPermissionsSet(address from);\\n\\n/**\\n * @dev address `from` is not authorised to `permission`\\n * @param permission permission required\\n * @param from address not-authorised\\n */\\nerror NotAuthorised(address from, string permission);\\n\\n/**\\n * @dev address `from` is not authorised to interact with `disallowedAddress` via account\\n * @param from address making the request\\n * @param disallowedAddress address that `from` is not authorised to call\\n */\\nerror NotAllowedAddress(address from, address disallowedAddress);\\n\\n/**\\n * @dev address `from` is not authorised to run `disallowedFunction` via account\\n * @param from address making the request\\n * @param disallowedFunction bytes4 function selector that `from` is not authorised to run\\n */\\nerror NotAllowedFunction(address from, bytes4 disallowedFunction);\\n\\n/**\\n * @dev address `from` is not authorised to set the key `disallowedKey` on the account\\n * @param from address making the request\\n * @param disallowedKey a bytes32 key that `from` is not authorised to set on the ERC725Y storage\\n */\\nerror NotAllowedERC725YKey(address from, bytes32 disallowedKey);\\n\\n/**\\n * @title Core implementation of a contract acting as a controller of an ERC725 Account, using permissions stored in the ERC725Y storage\\n * @author Fabian Vogelsteller, Jean Cavallera\\n * @dev all the permissions can be set on the ERC725 Account using `setData(...)` with the keys constants below\\n */\\nabstract contract LSP6KeyManagerCore is ILSP6KeyManager, ERC165 {\\n    using ERC725Utils for ERC725Y;\\n    using LSP2Utils for ERC725Y;\\n    using LSP6Utils for ERC725;\\n    using Address for address;\\n    using ECDSA for bytes32;\\n    using ERC165Checker for address;\\n\\n    ERC725 public account;\\n    mapping(address => mapping(uint256 => uint256)) internal _nonceStore;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == _INTERFACEID_LSP6 ||\\n            interfaceId == _INTERFACEID_ERC1271 ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @inheritdoc ILSP6KeyManager\\n     */\\n    function getNonce(address _from, uint256 _channel)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        uint128 nonceId = uint128(_nonceStore[_from][_channel]);\\n        return (uint256(_channel) << 128) | nonceId;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC1271\\n     */\\n    function isValidSignature(bytes32 _hash, bytes memory _signature)\\n        public\\n        view\\n        override\\n        returns (bytes4 magicValue)\\n    {\\n        address recoveredAddress = ECDSA.recover(_hash, _signature);\\n        return\\n            (_PERMISSION_SIGN & account.getPermissionsFor(recoveredAddress)) ==\\n                _PERMISSION_SIGN\\n                ? _INTERFACEID_ERC1271\\n                : _ERC1271_FAILVALUE;\\n    }\\n\\n    /**\\n     * @inheritdoc ILSP6KeyManager\\n     */\\n    function execute(bytes calldata _data)\\n        external\\n        payable\\n        override\\n        returns (bytes memory)\\n    {\\n        _verifyPermissions(msg.sender, _data);\\n\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory result_) = address(account).call{\\n            value: msg.value,\\n            gas: gasleft()\\n        }(_data);\\n\\n        if (!success) {\\n            ErrorHandlerLib.revertWithParsedError(result_);\\n        }\\n\\n        emit Executed(msg.value, _data);\\n        return result_.length > 0 ? abi.decode(result_, (bytes)) : result_;\\n    }\\n\\n    /**\\n     * @inheritdoc ILSP6KeyManager\\n     */\\n    function executeRelayCall(\\n        address _signedFor,\\n        uint256 _nonce,\\n        bytes calldata _data,\\n        bytes memory _signature\\n    ) external payable override returns (bytes memory) {\\n        require(\\n            _signedFor == address(this),\\n            \\\"executeRelayCall: Message not signed for this keyManager\\\"\\n        );\\n\\n        bytes memory blob = abi.encodePacked(\\n            address(this), // needs to be signed for this keyManager\\n            _nonce,\\n            _data\\n        );\\n\\n        address signer = keccak256(blob).toEthSignedMessageHash().recover(\\n            _signature\\n        );\\n\\n        require(\\n            _isValidNonce(signer, _nonce),\\n            \\\"executeRelayCall: Invalid nonce\\\"\\n        );\\n\\n        // increase nonce after successful verification\\n        _nonceStore[signer][_nonce >> 128]++;\\n\\n        _verifyPermissions(signer, _data);\\n\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory result_) = address(account).call{\\n            value: 0,\\n            gas: gasleft()\\n        }(_data);\\n\\n        if (!success) {\\n            ErrorHandlerLib.revertWithParsedError(result_);\\n        }\\n\\n        emit Executed(msg.value, _data);\\n        return result_.length > 0 ? abi.decode(result_, (bytes)) : result_;\\n    }\\n\\n    /**\\n     * @notice verify the nonce `_idx` for `_from` (obtained via `getNonce(...)`)\\n     * @dev \\\"idx\\\" is a 256bits (unsigned) integer, where:\\n     *          - the 128 leftmost bits = channelId\\n     *      and - the 128 rightmost bits = nonce within the channel\\n     * @param _from caller address\\n     * @param _idx (channel id + nonce within the channel)\\n     */\\n    function _isValidNonce(address _from, uint256 _idx)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        // idx % (1 << 128) = nonce\\n        // (idx >> 128) = channel\\n        // equivalent to: return (nonce == _nonceStore[_from][channel]\\n        return (_idx % (1 << 128)) == (_nonceStore[_from][_idx >> 128]);\\n    }\\n\\n    /**\\n     * @dev verify the permissions of the _from address that want to interact with the `account`\\n     * @param _from the address making the request\\n     * @param _data the payload that will be run on `account`\\n     */\\n    function _verifyPermissions(address _from, bytes calldata _data)\\n        internal\\n        view\\n    {\\n        bytes4 erc725Function = bytes4(_data[:4]);\\n\\n        if (erc725Function == account.setData.selector) {\\n            _verifyCanSetData(_from, _data);\\n        } else if (erc725Function == account.execute.selector) {\\n            _verifyCanExecute(_from, _data);\\n\\n            address to = address(bytes20(_data[48:68]));\\n            _verifyAllowedAddress(_from, to);\\n\\n            if (to.code.length > 0) {\\n                _verifyAllowedStandard(_from, to);\\n\\n                if (_data.length >= 168) {\\n                    // extract bytes4 function selector from payload\\n                    _verifyAllowedFunction(_from, bytes4(_data[164:168]));\\n                }\\n            }\\n        } else if (erc725Function == account.transferOwnership.selector) {\\n            bytes32 permissions = account.getPermissionsFor(_from);\\n            if (permissions == bytes32(0)) revert NoPermissionsSet(_from);\\n\\n            if (!_hasPermission(_PERMISSION_CHANGEOWNER, permissions))\\n                revert NotAuthorised(_from, \\\"TRANSFEROWNERSHIP\\\");\\n        } else {\\n            revert(\\\"_verifyPermissions: unknown ERC725 selector\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev verify if `_from` has the required permissions to set some keys\\n     * on the linked ERC725Account\\n     * @param _from the address who want to set the keys\\n     * @param _data the ABI encoded payload `account.setData(keys, values)`\\n     * containing a list of keys-value pairs\\n     */\\n    function _verifyCanSetData(address _from, bytes calldata _data)\\n        internal\\n        view\\n    {\\n        bytes32 permissions = account.getPermissionsFor(_from);\\n        if (permissions == bytes32(0)) revert NoPermissionsSet(_from);\\n\\n        (bytes32[] memory inputKeys, ) = abi.decode(\\n            _data[4:],\\n            (bytes32[], bytes[])\\n        );\\n\\n        bool isSettingERC725YKeys = false;\\n\\n        // loop through the keys we are trying to set\\n        for (uint256 ii = 0; ii < inputKeys.length; ii++) {\\n            bytes32 key = inputKeys[ii];\\n\\n            // prettier-ignore\\n            // if the key is a permission key\\n            if (bytes8(key) == _SET_PERMISSIONS_PREFIX) {\\n                _verifyCanSetPermissions(key, _from, permissions);\\n\\n                // \\\"nullify permission keys, \\n                // so that they do not get check against allowed ERC725Y keys\\n                inputKeys[ii] = bytes32(0);\\n\\n            // if the key is any other bytes32 key\\n            } else {\\n                isSettingERC725YKeys = true;\\n            }\\n        }\\n\\n        if (isSettingERC725YKeys) {\\n            if (!_hasPermission(_PERMISSION_SETDATA, permissions))\\n                revert NotAuthorised(_from, \\\"SETDATA\\\");\\n\\n            _verifyAllowedERC725YKeys(_from, inputKeys);\\n        }\\n    }\\n\\n    function _verifyCanSetPermissions(\\n        bytes32 _key,\\n        address _from,\\n        bytes32 _callerPermissions\\n    ) internal view {\\n        // prettier-ignore\\n        // check if some permissions are already stored under this key\\n        if (bytes32(ERC725Y(account).getDataSingle(_key)) == bytes32(0)) {\\n            // if nothing is stored under this key,\\n            // we are trying to ADD permissions for a NEW address\\n            if (!_hasPermission(_PERMISSION_ADDPERMISSIONS, _callerPermissions))\\n                revert NotAuthorised(_from, \\\"ADDPERMISSIONS\\\");\\n        } else {\\n            // if there are already a value stored under this key,\\n            // we are trying to CHANGE the permissions of an address\\n            // (that has already some EXISTING permissions set)\\n            if (!_hasPermission(_PERMISSION_CHANGEPERMISSIONS, _callerPermissions)) \\n                revert NotAuthorised(_from, \\\"CHANGEPERMISSIONS\\\");\\n        }\\n    }\\n\\n    function _verifyAllowedERC725YKeys(\\n        address _from,\\n        bytes32[] memory _inputKeys\\n    ) internal view {\\n        bytes memory allowedERC725YKeysEncoded = ERC725Y(account).getDataSingle(\\n            LSP2Utils.generateBytes20MappingWithGroupingKey(\\n                _LSP6_ADDRESS_ALLOWEDERC725YKEYS_MAP_KEY_PREFIX,\\n                bytes20(_from)\\n            )\\n        );\\n\\n        // whitelist any ERC725Y key if nothing in the list\\n        if (allowedERC725YKeysEncoded.length == 0) return;\\n\\n        bytes32[] memory allowedERC725YKeys = abi.decode(\\n            allowedERC725YKeysEncoded,\\n            (bytes32[])\\n        );\\n\\n        bytes memory allowedKeySlice;\\n        bytes memory inputKeySlice;\\n        uint256 sliceLength;\\n\\n        bool isAllowedKey;\\n\\n        // save the not allowed key for cusom revert error\\n        bytes32 notAllowedKey;\\n\\n        // loop through each allowed ERC725Y key retrieved from storage\\n        for (uint256 ii = 0; ii < allowedERC725YKeys.length; ii++) {\\n            // save the length of the slice\\n            // so to know which part to compare for each key we are trying to set\\n            (allowedKeySlice, sliceLength) = _extractKeySlice(\\n                allowedERC725YKeys[ii]\\n            );\\n\\n            // loop through each keys given as input\\n            for (uint256 jj = 0; jj < _inputKeys.length; jj++) {\\n                // skip permissions keys that have been \\\"nulled\\\" previously\\n                if (_inputKeys[jj] == bytes32(0)) continue;\\n\\n                // extract the slice to compare with the allowed key\\n                inputKeySlice = BytesLib.slice(\\n                    bytes.concat(_inputKeys[jj]),\\n                    0,\\n                    sliceLength\\n                );\\n\\n                isAllowedKey =\\n                    keccak256(allowedKeySlice) == keccak256(inputKeySlice);\\n\\n                // if the keys match, the key is allowed so stop iteration\\n                if (isAllowedKey) break;\\n\\n                // if the keys do not match, save this key as a not allowed key\\n                notAllowedKey = _inputKeys[jj];\\n            }\\n\\n            // if after checking all the keys given as input we did not find any not allowed key\\n            // stop checking the other allowed ERC725Y keys\\n            if (isAllowedKey == true) break;\\n        }\\n\\n        // we always revert with the last not-allowed key that we found in the keys given as inputs\\n        if (isAllowedKey == false)\\n            revert NotAllowedERC725YKey(_from, notAllowedKey);\\n    }\\n\\n    /**\\n     * @dev verify if `_from` has the required permissions to make an external call\\n     * via the linked ERC725Account\\n     * @param _from the address who want to run the execute function on the ERC725Account\\n     * @param _data the ABI encoded payload `account.execute(...)`\\n     */\\n    function _verifyCanExecute(address _from, bytes calldata _data)\\n        internal\\n        view\\n    {\\n        bytes32 permissions = account.getPermissionsFor(_from);\\n        if (permissions == bytes32(0)) revert NoPermissionsSet(_from);\\n\\n        uint256 operationType = uint256(bytes32(_data[4:36]));\\n        uint256 value = uint256(bytes32(_data[68:100]));\\n\\n        require(\\n            operationType != 4,\\n            \\\"_verifyCanExecute: operation 4 `DELEGATECALL` not supported\\\"\\n        );\\n\\n        (\\n            bytes32 permissionRequired,\\n            string memory operationName\\n        ) = _extractPermissionFromOperation(operationType);\\n\\n        if (!_hasPermission(permissionRequired, permissions))\\n            revert NotAuthorised(_from, operationName);\\n\\n        if (\\n            (value > 0) &&\\n            !_hasPermission(_PERMISSION_TRANSFERVALUE, permissions)\\n        ) {\\n            revert NotAuthorised(_from, \\\"TRANSFERVALUE\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev verify if `_from` is authorised to interact with address `_to` via the linked ERC725Account\\n     * @param _from the caller address\\n     * @param _to the address to interact with\\n     */\\n    function _verifyAllowedAddress(address _from, address _to) internal view {\\n        bytes memory allowedAddresses = account.getAllowedAddressesFor(_from);\\n\\n        // whitelist any address if nothing in the list\\n        if (allowedAddresses.length == 0) return;\\n\\n        address[] memory allowedAddressesList = abi.decode(\\n            allowedAddresses,\\n            (address[])\\n        );\\n\\n        for (uint256 ii = 0; ii < allowedAddressesList.length; ii++) {\\n            if (_to == allowedAddressesList[ii]) return;\\n        }\\n        revert NotAllowedAddress(_from, _to);\\n    }\\n\\n    /**\\n     * @dev if `_from` is restricted to interact with contracts that implement a specific interface,\\n     * verify that `_to` implements one of these interface.\\n     * @param _from the caller address\\n     * @param _to the address of the contract to interact with\\n     */\\n    function _verifyAllowedStandard(address _from, address _to) internal view {\\n        bytes memory allowedStandards = ERC725Y(account).getDataSingle(\\n            LSP2Utils.generateBytes20MappingWithGroupingKey(\\n                _LSP6_ADDRESS_ALLOWEDSTANDARDS_MAP_KEY_PREFIX,\\n                bytes20(_from)\\n            )\\n        );\\n\\n        // whitelist any standard interface (ERC165) if nothing in the list\\n        if (allowedStandards.length == 0) return;\\n\\n        bytes4[] memory allowedStandardsList = abi.decode(\\n            allowedStandards,\\n            (bytes4[])\\n        );\\n\\n        for (uint256 ii = 0; ii < allowedStandardsList.length; ii++) {\\n            if (_to.supportsInterface(allowedStandardsList[ii])) return;\\n        }\\n        revert(\\\"Not Allowed Standards\\\");\\n    }\\n\\n    /**\\n     * @dev verify if `_from` is authorised to use the linked ERC725Account\\n     * to run a specific function `_functionSelector` at a target contract\\n     * @param _from the caller address\\n     * @param _functionSelector the bytes4 function selector of the function to run\\n     * at the target contract\\n     */\\n    function _verifyAllowedFunction(address _from, bytes4 _functionSelector)\\n        internal\\n        view\\n    {\\n        bytes memory allowedFunctions = account.getAllowedFunctionsFor(_from);\\n\\n        // whitelist any function if nothing in the list\\n        if (allowedFunctions.length == 0) return;\\n\\n        bytes4[] memory allowedFunctionsList = abi.decode(\\n            allowedFunctions,\\n            (bytes4[])\\n        );\\n\\n        for (uint256 ii = 0; ii < allowedFunctionsList.length; ii++) {\\n            if (_functionSelector == allowedFunctionsList[ii]) return;\\n        }\\n        revert NotAllowedFunction(_from, _functionSelector);\\n    }\\n\\n    /**\\n     * @dev compare the permissions `_addressPermission` of an address with `_requiredPermission`\\n     * @param _requiredPermission the permission required\\n     * @param _addressPermission the permission of address that we want to check\\n     * @return true if address has enough permissions, false otherwise\\n     */\\n    function _hasPermission(\\n        bytes32 _requiredPermission,\\n        bytes32 _addressPermission\\n    ) internal pure returns (bool) {\\n        return\\n            (_requiredPermission & _addressPermission) == _requiredPermission\\n                ? true\\n                : false;\\n    }\\n\\n    function _extractKeySlice(bytes32 _key)\\n        internal\\n        pure\\n        returns (bytes memory keySlice_, uint256 sliceLength_)\\n    {\\n        // check each individual bytes of the allowed key, starting from the end (right to left)\\n        for (uint256 index = 31; index >= 0; index--) {\\n            // find where the first non-empty bytes starts (skip empty bytes 0x00)\\n            if (_key[index] != 0x00) {\\n                // stop as soon as we find a non-empty byte\\n                sliceLength_ = index + 1;\\n                keySlice_ = BytesLib.slice(bytes.concat(_key), 0, sliceLength_);\\n                break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev extract the required permission + a descriptive string, based on the `_operationType`\\n     * being run via ERC725Account.execute(...)\\n     * @param _operationType 0 = CALL, 1 = CREATE, 2 = CREATE2, etc... See ERC725X docs for more infos.\\n     * @return bytes32 the permission associated with the `_operationType`\\n     * @return string the opcode associated with `_operationType`\\n     */\\n    function _extractPermissionFromOperation(uint256 _operationType)\\n        internal\\n        pure\\n        returns (bytes32, string memory)\\n    {\\n        require(\\n            _operationType < 5,\\n            \\\"_extractPermissionFromOperation: invalid operation type\\\"\\n        );\\n\\n        if (_operationType == 0) return (_PERMISSION_CALL, \\\"CALL\\\");\\n        if (_operationType == 1) return (_PERMISSION_DEPLOY, \\\"CREATE\\\");\\n        if (_operationType == 2) return (_PERMISSION_DEPLOY, \\\"CREATE2\\\");\\n        if (_operationType == 3) return (_PERMISSION_STATICCALL, \\\"STATICCALL\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/ERC725Y.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// modules\\nimport \\\"./ERC725YCore.sol\\\";\\n\\n/**\\n * @title ERC725 Y General key/value store\\n * @author Fabian Vogelsteller <fabian@lukso.network>\\n * @dev Contract module which provides the ability to set arbitrary key value sets that can be changed over time\\n * It is intended to standardise certain keys value pairs to allow automated retrievals and interactions\\n * from interfaces and other smart contracts\\n */\\ncontract ERC725Y is ERC725YCore {\\n    /**\\n     * @notice Sets the owner of the contract and register ERC725Y interfaceId\\n     * @param _newOwner the owner of the contract\\n     */\\n    constructor(address _newOwner) {\\n        // This is necessary to prevent a contract that implements both ERC725X and ERC725Y to call both constructors\\n        if (_newOwner != owner()) {\\n            OwnableUnset.initOwner(_newOwner);\\n        }\\n\\n        _registerInterface(_INTERFACEID_ERC725Y);\\n    }\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/ERC725.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n// modules\\nimport \\\"./ERC725X.sol\\\";\\nimport \\\"./ERC725Y.sol\\\";\\n\\n/**\\n * @title ERC725 bundle\\n * @author Fabian Vogelsteller <fabian@lukso.network>\\n * @dev Bundles ERC725X and ERC725Y together into one smart contract\\n */\\ncontract ERC725 is ERC725X, ERC725Y {\\n    /**\\n     * @notice Sets the owner of the contract\\n     * @param _newOwner the owner of the contract\\n     */\\n    // solhint-disable no-empty-blocks\\n    constructor(address _newOwner) ERC725X(_newOwner) ERC725Y(_newOwner) {}\\n\\n    // NOTE this implementation has not by default: receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/ILSP6KeyManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// interfaces\\nimport \\\"@openzeppelin/contracts/interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Contract acting as a controller of an ERC725 Account, using permissions stored in the ERC725Y storage\\n */\\ninterface ILSP6KeyManager is\\n    IERC1271\\n    /* is ERC165 */\\n{\\n    event Executed(uint256 indexed _value, bytes _data);\\n\\n    /**\\n     * @notice get latest nonce for `_from` for channel ID: `_channel`\\n     * @dev use channel ID = 0 for sequential nonces, any other number for out-of-order execution (= execution in parallel)\\n     * @param _address caller address\\n     * @param _channel channel id\\n     */\\n    function getNonce(address _address, uint256 _channel)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice execute the following payload on the ERC725Account: `_data`\\n     * @dev the ERC725Account will return some data on successful call, or revert on failure\\n     * @param _data the payload to execute. Obtained in web3 via encodeABI()\\n     * @return result_ the data being returned by the ERC725 Account\\n     */\\n    function execute(bytes calldata _data)\\n        external\\n        payable\\n        returns (bytes memory);\\n\\n    /**\\n     * @dev allows anybody to execute given they have a signed message from an executor\\n     * @param _signedFor this KeyManager\\n     * @param _nonce the address' nonce (in a specific `_channel`), obtained via `getNonce(...)`. Used to prevent replay attack\\n     * @param _data obtained via encodeABI() in web3\\n     * @param _signature bytes32 ethereum signature\\n     * @return result_ the data being returned by the ERC725 Account\\n     */\\n    function executeRelayCall(\\n        address _signedFor,\\n        uint256 _nonce,\\n        bytes calldata _data,\\n        bytes memory _signature\\n    ) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/utils/ErrorHandlerLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Error Handler\\n * @dev When calling other contracts via low-level calls like `contract.call{ ... }(data)`, errors\\n * need to be handled manually. This library will correctly handle the built-in Error(string) and\\n * Panic(uint256) as well as custom errors introduced in Solidity 0.8.4.\\n */\\nlibrary ErrorHandlerLib {\\n    /**\\n     * @dev Will revert with the provided error payload.\\n     */\\n    function revertWithParsedError(bytes memory error)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        if (error.length > 0) {\\n            // the call reverted with a error string or a custom error\\n            assembly {\\n                let error_size := mload(error)\\n                revert(add(32, error), error_size)\\n            }\\n        } else {\\n            // there was no error payload, revert with empty payload\\n            revert();\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// constants\\nimport \\\"../LSP6KeyManager/LSP6Constants.sol\\\";\\n\\n// libraries\\nimport \\\"../LSP2ERC725YJSONSchema/LSP2Utils.sol\\\";\\nimport \\\"..//Utils/ERC725Utils.sol\\\";\\nimport \\\"./ILSP6KeyManager.sol\\\";\\n\\nlibrary LSP6Utils {\\n    using LSP2Utils for bytes12;\\n    using ERC725Utils for IERC725Y;\\n\\n    function getPermissionsFor(IERC725Y _account, address _address)\\n        internal\\n        view\\n        returns (bytes32)\\n    {\\n        bytes memory permissions = _account.getDataSingle(\\n            LSP2Utils.generateBytes20MappingWithGroupingKey(\\n                _LSP6_ADDRESS_PERMISSIONS_MAP_KEY_PREFIX,\\n                bytes20(_address)\\n            )\\n        );\\n\\n        return bytes32(permissions);\\n    }\\n\\n    function getAllowedAddressesFor(IERC725Y _account, address _address)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            _account.getDataSingle(\\n                LSP2Utils.generateBytes20MappingWithGroupingKey(\\n                    _LSP6_ADDRESS_ALLOWEDADDRESSES_MAP_KEY_PREFIX,\\n                    bytes20(_address)\\n                )\\n            );\\n    }\\n\\n    function getAllowedFunctionsFor(IERC725Y _account, address _address)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        return\\n            _account.getDataSingle(\\n                LSP2Utils.generateBytes20MappingWithGroupingKey(\\n                    _LSP6_ADDRESS_ALLOWEDFUNCTIONS_MAP_KEY_PREFIX,\\n                    bytes20(_address)\\n                )\\n            );\\n    }\\n\\n    function setDataViaKeyManager(\\n        address keyManagerAddress,\\n        bytes32[] memory keys,\\n        bytes[] memory values\\n    ) internal returns (bytes memory result) {\\n        bytes memory payload = abi.encodeWithSelector(\\n            hex\\\"14a6e293\\\",\\n            keys,\\n            values\\n        );\\n        result = ILSP6KeyManager(keyManagerAddress).execute(payload);\\n    }\\n}\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/Utils/ERC725Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// interfaces\\nimport \\\"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\\\";\\n\\nlibrary ERC725Utils {\\n    /**\\n     * @dev Gets one value from account storage\\n     */\\n    function getDataSingle(IERC725Y _account, bytes32 _key)\\n        internal\\n        view\\n        returns (bytes memory)\\n    {\\n        bytes32[] memory keys = new bytes32[](1);\\n        keys[0] = _key;\\n        bytes memory fetchResult = _account.getData(keys)[0];\\n        return fetchResult;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165Checker {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\\n        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);\\n        if (result.length < 32) return false;\\n        return success && abi.decode(result, (bool));\\n    }\\n}\\n\"\r\n    },\r\n    \"solidity-bytes-utils/contracts/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.8.0 <0.9.0;\\n\\n\\nlibrary BytesLib {\\n    function concat(\\n        bytes memory _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            // Get a location of some free memory and store it in tempBytes as\\n            // Solidity does for memory variables.\\n            tempBytes := mload(0x40)\\n\\n            // Store the length of the first bytes array at the beginning of\\n            // the memory for tempBytes.\\n            let length := mload(_preBytes)\\n            mstore(tempBytes, length)\\n\\n            // Maintain a memory counter for the current write location in the\\n            // temp bytes array by adding the 32 bytes for the array length to\\n            // the starting location.\\n            let mc := add(tempBytes, 0x20)\\n            // Stop copying when the memory counter reaches the length of the\\n            // first bytes array.\\n            let end := add(mc, length)\\n\\n            for {\\n                // Initialize a copy counter to the start of the _preBytes data,\\n                // 32 bytes into its memory.\\n                let cc := add(_preBytes, 0x20)\\n            } lt(mc, end) {\\n                // Increase both counters by 32 bytes each iteration.\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                // Write the _preBytes data into the tempBytes memory 32 bytes\\n                // at a time.\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Add the length of _postBytes to the current length of tempBytes\\n            // and store it as the new length in the first 32 bytes of the\\n            // tempBytes memory.\\n            length := mload(_postBytes)\\n            mstore(tempBytes, add(length, mload(tempBytes)))\\n\\n            // Move the memory counter back from a multiple of 0x20 to the\\n            // actual end of the _preBytes data.\\n            mc := end\\n            // Stop copying when the memory counter reaches the new combined\\n            // length of the arrays.\\n            end := add(mc, length)\\n\\n            for {\\n                let cc := add(_postBytes, 0x20)\\n            } lt(mc, end) {\\n                mc := add(mc, 0x20)\\n                cc := add(cc, 0x20)\\n            } {\\n                mstore(mc, mload(cc))\\n            }\\n\\n            // Update the free-memory pointer by padding our last write location\\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\\n            // next 32 byte block, then round down to the nearest multiple of\\n            // 32. If the sum of the length of the two arrays is zero then add\\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\\n            mstore(0x40, and(\\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\\n              not(31) // Round down to the nearest 32 bytes.\\n            ))\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\\n        assembly {\\n            // Read the first 32 bytes of _preBytes storage, which is the length\\n            // of the array. (We don't need to use the offset into the slot\\n            // because arrays use the entire slot.)\\n            let fslot := sload(_preBytes.slot)\\n            // Arrays of 31 bytes or less have an even value in their slot,\\n            // while longer arrays have an odd value. The actual length is\\n            // the slot divided by two for odd values, and the lowest order\\n            // byte divided by two for even values.\\n            // If the slot is even, bitwise and the slot with 255 and divide by\\n            // two to get the length. If the slot is odd, bitwise and the slot\\n            // with -1 and divide by two.\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n            let newlength := add(slength, mlength)\\n            // slength can contain both the length and contents of the array\\n            // if length < 32 bytes so let's prepare for that\\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n            switch add(lt(slength, 32), lt(newlength, 32))\\n            case 2 {\\n                // Since the new array still fits in the slot, we just need to\\n                // update the contents of the slot.\\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\\n                sstore(\\n                    _preBytes.slot,\\n                    // all the modifications to the slot are inside this\\n                    // next block\\n                    add(\\n                        // we can just add to the slot contents because the\\n                        // bytes we want to change are the LSBs\\n                        fslot,\\n                        add(\\n                            mul(\\n                                div(\\n                                    // load the bytes from memory\\n                                    mload(add(_postBytes, 0x20)),\\n                                    // zero all bytes to the right\\n                                    exp(0x100, sub(32, mlength))\\n                                ),\\n                                // and now shift left the number of bytes to\\n                                // leave space for the length in the slot\\n                                exp(0x100, sub(32, newlength))\\n                            ),\\n                            // increase length by the double of the memory\\n                            // bytes length\\n                            mul(mlength, 2)\\n                        )\\n                    )\\n                )\\n            }\\n            case 1 {\\n                // The stored value fits in the slot, but the combined value\\n                // will exceed it.\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // The contents of the _postBytes array start 32 bytes into\\n                // the structure. Our first read should obtain the `submod`\\n                // bytes that can fit into the unused space in the last word\\n                // of the stored array. To get this, we read 32 bytes starting\\n                // from `submod`, so the data we read overlaps with the array\\n                // contents by `submod` bytes. Masking the lowest-order\\n                // `submod` bytes allows us to add that value directly to the\\n                // stored value.\\n\\n                let submod := sub(32, slength)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(\\n                    sc,\\n                    add(\\n                        and(\\n                            fslot,\\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\\n                        ),\\n                        and(mload(mc), mask)\\n                    )\\n                )\\n\\n                for {\\n                    mc := add(mc, 0x20)\\n                    sc := add(sc, 1)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n            default {\\n                // get the keccak hash to get the contents of the array\\n                mstore(0x0, _preBytes.slot)\\n                // Start copying to the last used word of the stored array.\\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\\n\\n                // save new length\\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\\n\\n                // Copy over the first `submod` bytes of the new data as in\\n                // case 1 above.\\n                let slengthmod := mod(slength, 32)\\n                let mlengthmod := mod(mlength, 32)\\n                let submod := sub(32, slengthmod)\\n                let mc := add(_postBytes, submod)\\n                let end := add(_postBytes, mlength)\\n                let mask := sub(exp(0x100, submod), 1)\\n\\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\\n\\n                for {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } lt(mc, end) {\\n                    sc := add(sc, 1)\\n                    mc := add(mc, 0x20)\\n                } {\\n                    sstore(sc, mload(mc))\\n                }\\n\\n                mask := exp(0x100, sub(mc, end))\\n\\n                sstore(sc, mul(div(mload(mc), mask), mask))\\n            }\\n        }\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\\n        require(_bytes.length >= _start + 2, \\\"toUint16_outOfBounds\\\");\\n        uint16 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x2), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\\n        require(_bytes.length >= _start + 4, \\\"toUint32_outOfBounds\\\");\\n        uint32 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x4), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\\n        require(_bytes.length >= _start + 8, \\\"toUint64_outOfBounds\\\");\\n        uint64 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x8), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\\n        require(_bytes.length >= _start + 12, \\\"toUint96_outOfBounds\\\");\\n        uint96 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0xc), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\\n        require(_bytes.length >= _start + 16, \\\"toUint128_outOfBounds\\\");\\n        uint128 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x10), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\\n        require(_bytes.length >= _start + 32, \\\"toUint256_outOfBounds\\\");\\n        uint256 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\\n        require(_bytes.length >= _start + 32, \\\"toBytes32_outOfBounds\\\");\\n        bytes32 tempBytes32;\\n\\n        assembly {\\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\\n        }\\n\\n        return tempBytes32;\\n    }\\n\\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\\n        bool success = true;\\n\\n        assembly {\\n            let length := mload(_preBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(length, mload(_postBytes))\\n            case 1 {\\n                // cb is a circuit breaker in the for loop since there's\\n                //  no said feature for inline assembly loops\\n                // cb = 1 - don't breaker\\n                // cb = 0 - break\\n                let cb := 1\\n\\n                let mc := add(_preBytes, 0x20)\\n                let end := add(mc, length)\\n\\n                for {\\n                    let cc := add(_postBytes, 0x20)\\n                // the next line is the loop condition:\\n                // while(uint256(mc < end) + cb == 2)\\n                } eq(add(lt(mc, end), cb), 2) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    // if any of these checks fails then arrays are not equal\\n                    if iszero(eq(mload(mc), mload(cc))) {\\n                        // unsuccess:\\n                        success := 0\\n                        cb := 0\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n\\n    function equalStorage(\\n        bytes storage _preBytes,\\n        bytes memory _postBytes\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        bool success = true;\\n\\n        assembly {\\n            // we know _preBytes_offset is 0\\n            let fslot := sload(_preBytes.slot)\\n            // Decode the length of the stored array like in concatStorage().\\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\\n            let mlength := mload(_postBytes)\\n\\n            // if lengths don't match the arrays are not equal\\n            switch eq(slength, mlength)\\n            case 1 {\\n                // slength can contain both the length and contents of the array\\n                // if length < 32 bytes so let's prepare for that\\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\\n                if iszero(iszero(slength)) {\\n                    switch lt(slength, 32)\\n                    case 1 {\\n                        // blank the last byte which is the length\\n                        fslot := mul(div(fslot, 0x100), 0x100)\\n\\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\\n                            // unsuccess:\\n                            success := 0\\n                        }\\n                    }\\n                    default {\\n                        // cb is a circuit breaker in the for loop since there's\\n                        //  no said feature for inline assembly loops\\n                        // cb = 1 - don't breaker\\n                        // cb = 0 - break\\n                        let cb := 1\\n\\n                        // get the keccak hash to get the contents of the array\\n                        mstore(0x0, _preBytes.slot)\\n                        let sc := keccak256(0x0, 0x20)\\n\\n                        let mc := add(_postBytes, 0x20)\\n                        let end := add(mc, mlength)\\n\\n                        // the next line is the loop condition:\\n                        // while(uint256(mc < end) + cb == 2)\\n                        for {} eq(add(lt(mc, end), cb), 2) {\\n                            sc := add(sc, 1)\\n                            mc := add(mc, 0x20)\\n                        } {\\n                            if iszero(eq(sload(sc), mload(mc))) {\\n                                // unsuccess:\\n                                success := 0\\n                                cb := 0\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            default {\\n                // unsuccess:\\n                success := 0\\n            }\\n        }\\n\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/LSP6KeyManager/LSP6Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n// --- ERC165 interface ids\\nbytes4 constant _INTERFACEID_LSP6 = 0x6f4df48b;\\n\\n// --- ERC725Y Keys\\n\\n// PERMISSIONS KEYS\\nbytes8 constant _SET_PERMISSIONS_PREFIX = 0x4b80742d00000000; // AddressPermissions:<...>\\n\\n// keccak256('AddressPermissions[]')\\nbytes32 constant _LSP6_ADDRESS_PERMISSIONS_ARRAY_KEY = 0x55482936e01da86729a45d2b87a6b1d3bc582bea0ec00e38bdb340e3af6f9f06;\\n\\n// bytes4(keccak256('AddressPermissions')) + bytes4(0) + bytes2(keccak256('Permissions')) + bytes2(0)\\nbytes12 constant _LSP6_ADDRESS_PERMISSIONS_MAP_KEY_PREFIX = 0x4b80742d0000000082ac0000; // AddressPermissions:Permissions:<address> --> bytes32\\n\\n// bytes4(keccak256('AddressPermissions')) + bytes4(0) + bytes2(keccak256('AllowedAddresses')) + bytes2(0)\\nbytes12 constant _LSP6_ADDRESS_ALLOWEDADDRESSES_MAP_KEY_PREFIX = 0x4b80742d00000000c6dd0000; // AddressPermissions:AllowedAddresses:<address> --> address[]\\n\\n// bytes4(keccak256('AddressPermissions')) + bytes4(0) + bytes2(keccak256('AllowedFunctions')) + bytes2(0)\\nbytes12 constant _LSP6_ADDRESS_ALLOWEDFUNCTIONS_MAP_KEY_PREFIX = 0x4b80742d000000008efe0000; // AddressPermissions:AllowedFunctions:<address> --> bytes4[]\\n\\n// bytes4(keccak256('AddressPermissions')) + bytes4(0) + bytes2(keccak256('AllowedStandards')) + bytes2(0)\\nbytes12 constant _LSP6_ADDRESS_ALLOWEDSTANDARDS_MAP_KEY_PREFIX = 0x4b80742d000000003efa0000; // AddressPermissions:AllowedStandards:<address> --> bytes4[]\\n\\n// bytes4(keccak256('AddressPermissions')) + bytes4(0) + bytes2(keccak256('AllowedERC725YKeys')) + bytes2(0)\\nbytes12 constant _LSP6_ADDRESS_ALLOWEDERC725YKEYS_MAP_KEY_PREFIX = 0x4b80742d0000000090b80000; // AddressPermissions:AllowedERC725YKeys:<address> --> bytes32[]\\n\\n// PERMISSIONS VALUES\\nbytes32 constant _PERMISSION_CHANGEOWNER = 0x0000000000000000000000000000000000000000000000000000000000000001;\\nbytes32 constant _PERMISSION_CHANGEPERMISSIONS = 0x0000000000000000000000000000000000000000000000000000000000000002;\\nbytes32 constant _PERMISSION_ADDPERMISSIONS = 0x0000000000000000000000000000000000000000000000000000000000000004;\\nbytes32 constant _PERMISSION_SETDATA = 0x0000000000000000000000000000000000000000000000000000000000000008;\\nbytes32 constant _PERMISSION_CALL = 0x0000000000000000000000000000000000000000000000000000000000000010;\\nbytes32 constant _PERMISSION_STATICCALL = 0x0000000000000000000000000000000000000000000000000000000000000020;\\nbytes32 constant _PERMISSION_DELEGATECALL = 0x0000000000000000000000000000000000000000000000000000000000000040;\\nbytes32 constant _PERMISSION_DEPLOY = 0x0000000000000000000000000000000000000000000000000000000000000080;\\nbytes32 constant _PERMISSION_TRANSFERVALUE = 0x0000000000000000000000000000000000000000000000000000000000000100;\\nbytes32 constant _PERMISSION_SIGN = 0x0000000000000000000000000000000000000000000000000000000000000200;\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/LSP0ERC725Account/LSP0Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// --- ERC165 interface ids\\nbytes4 constant _INTERFACEID_LSP0 = 0x63cb749b;\\nbytes4 constant _INTERFACEID_ERC1271 = 0x1626ba7e;\\n\\n// ERC1271 - Standard Signature Validation\\nbytes4 constant _ERC1271_MAGICVALUE = 0x1626ba7e;\\nbytes4 constant _ERC1271_FAILVALUE = 0xffffffff;\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// interfaces\\nimport \\\"./interfaces/IERC725X.sol\\\";\\nimport \\\"./interfaces/IERC725Y.sol\\\";\\n\\n// >> INTERFACES\\n\\n// ERC725 - Smart Contract based Account\\nbytes4 constant _INTERFACEID_ERC725X = 0x44c028fe;\\nbytes4 constant _INTERFACEID_ERC725Y = 0x5a988c0f;\\n\\n// >> OPERATIONS\\nuint256 constant OPERATION_CALL = 0;\\nuint256 constant OPERATION_CREATE = 1;\\nuint256 constant OPERATION_CREATE2 = 2;\\nuint256 constant OPERATION_STATICCALL = 3;\\nuint256 constant OPERATION_DELEGATECALL = 4;\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/ERC725YCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// constants\\nimport \\\"./constants.sol\\\";\\n\\n// interfaces\\nimport \\\"./interfaces/IERC725Y.sol\\\";\\n\\n// modules\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\nimport \\\"./utils/OwnableUnset.sol\\\";\\n\\n// libraries\\nimport \\\"./utils/GasLib.sol\\\";\\n\\n/**\\n * @title Core implementation of ERC725 Y General key/value store\\n * @author Fabian Vogelsteller <fabian@lukso.network>\\n * @dev Contract module which provides the ability to set arbitrary key value sets that can be changed over time\\n * It is intended to standardise certain keys value pairs to allow automated retrievals and interactions\\n * from interfaces and other smart contracts\\n */\\nabstract contract ERC725YCore is OwnableUnset, ERC165Storage, IERC725Y {\\n    /**\\n     * @dev Map the keys to their values\\n     */\\n    mapping(bytes32 => bytes) internal store;\\n\\n    /* Public functions */\\n\\n    /**\\n     * @inheritdoc IERC725Y\\n     */\\n    function getData(bytes32[] memory keys)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bytes[] memory values)\\n    {\\n        values = new bytes[](keys.length);\\n\\n        for (uint256 i = 0; i < keys.length; i = GasLib.unchecked_inc(i)) {\\n            values[i] = _getData(keys[i]);\\n        }\\n\\n        return values;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC725Y\\n     */\\n    function setData(bytes32[] memory _keys, bytes[] memory _values)\\n        public\\n        virtual\\n        override\\n        onlyOwner\\n    {\\n        require(_keys.length == _values.length, \\\"Keys length not equal to values length\\\");\\n        for (uint256 i = 0; i < _keys.length; i = GasLib.unchecked_inc(i)) {\\n            _setData(_keys[i], _values[i]);\\n        }\\n    }\\n\\n    /* Internal functions */\\n\\n    /**\\n     * @notice Gets singular data at a given `key`\\n     * @param key The key which value to retrieve\\n     * @return value The data stored at the key\\n     */\\n    function _getData(bytes32 key) internal view virtual returns (bytes memory value) {\\n        return store[key];\\n    }\\n\\n    /**\\n     * @notice Sets singular data at a given `key`\\n     * @param key The key which value to retrieve\\n     * @param value The value to set\\n     */\\n    function _setData(bytes32 key, bytes memory value) internal virtual {\\n        store[key] = value;\\n        emit DataChanged(key, value);\\n    }\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/interfaces/IERC725Y.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title The interface for ERC725Y General key/value store\\n * @dev ERC725Y provides the ability to set arbitrary key value sets that can be changed over time\\n * It is intended to standardise certain keys value pairs to allow automated retrievals and interactions\\n * from interfaces and other smart contracts\\n */\\ninterface IERC725Y {\\n    /**\\n     * @notice Emitted when data at a key is changed\\n     * @param key The key which value is set\\n     * @param value The value to set\\n     */\\n    event DataChanged(bytes32 indexed key, bytes value);\\n\\n    /**\\n     * @notice Gets array of data at multiple given keys\\n     * @param keys The array of keys which values to retrieve\\n     * @return values The array of data stored at multiple keys\\n     */\\n    function getData(bytes32[] memory keys) external view returns (bytes[] memory values);\\n\\n    /**\\n     * @param keys The array of keys which values to set\\n     * @param values The array of values to set\\n     * @dev Sets array of data at multiple given `key`\\n     * SHOULD only be callable by the owner of the contract set via ERC173\\n     *\\n     * Emits a {DataChanged} event.\\n     */\\n    function setData(bytes32[] memory keys, bytes[] memory values) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ERC165.sol\\\";\\n\\n/**\\n * @dev Storage based implementation of the {IERC165} interface.\\n *\\n * Contracts may inherit from this and call {_registerInterface} to declare\\n * their support of an interface.\\n */\\nabstract contract ERC165Storage is ERC165 {\\n    /**\\n     * @dev Mapping of interface ids to whether or not it's supported.\\n     */\\n    mapping(bytes4 => bool) private _supportedInterfaces;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\\n    }\\n\\n    /**\\n     * @dev Registers the contract as an implementer of the interface defined by\\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\\n     * registering its interface id is not required.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * Requirements:\\n     *\\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\\n     */\\n    function _registerInterface(bytes4 interfaceId) internal virtual {\\n        require(interfaceId != 0xffffffff, \\\"ERC165: invalid interface id\\\");\\n        _supportedInterfaces[interfaceId] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/utils/OwnableUnset.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// modules\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\n\\n/**\\n * @dev Modified version of ERC173 with no constructor, instead should call `initOwner` function\\n * Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUnset is Context {\\n    address private _owner;\\n\\n    bool private _initiatedOwner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev initiate the owner for the contract\\n     * It can be called once\\n     */\\n    function initOwner(address newOwner) internal {\\n        require(!_initiatedOwner, \\\"Ownable: owner can only be initiated once\\\");\\n        _initiatedOwner = true;\\n        _setOwner(newOwner);\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/utils/GasLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library to add all efficient functions that could get repeated.\\n */\\nlibrary GasLib {\\n    /**\\n     * @dev Will return unchecked incremented uint256\\n     */\\n    function unchecked_inc(uint256 i) internal pure returns (uint256) {\\n        unchecked {\\n            return i + 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/interfaces/IERC725X.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: CC0-1.0\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title The interface for ERC725X General executor\\n * @dev ERC725X provides the ability to call arbitrary functions at any other smart contract and itself,\\n * including using `delegatecall`, `staticcall`, as well creating contracts using `create` and `create2`\\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\\n */\\ninterface IERC725X {\\n    /**\\n     * @notice Emitted when a contract is created\\n     * @param operation The operation used to create a contract\\n     * @param contractAddress The created contract address\\n     * @param value The value sent to the created contract address\\n     */\\n    event ContractCreated(\\n        uint256 indexed operation,\\n        address indexed contractAddress,\\n        uint256 indexed value\\n    );\\n\\n    /**\\n     * @notice Emitted when a contract executed.\\n     * @param operation The operation used to execute a contract\\n     * @param to The address where the call is executed\\n     * @param value The value sent to the created contract address\\n     * @param data The data sent with the call\\n     */\\n    event Executed(\\n        uint256 indexed operation,\\n        address indexed to,\\n        uint256 indexed value,\\n        bytes data\\n    );\\n\\n    /**\\n     * @param operationType The operation to execute: CALL = 0 CREATE = 1 CREATE2 = 2 STATICCALL = 3 DELEGATECALL = 4\\n     * @param to The smart contract or address to interact with, `to` will be unused if a contract is created (operation 1 and 2)\\n     * @param value The value to transfer\\n     * @param data The call data, or the contract data to deploy\\n     * @dev Executes any other smart contract.\\n     * SHOULD only be callable by the owner of the contract set via ERC173\\n     *\\n     * Emits a {Executed} event, when a call is executed under `operationType` 0, 3 and 4\\n     * Emits a {ContractCreated} event, when a contract is created under `operationType` 1 and 2\\n     */\\n    function execute(\\n        uint256 operationType,\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external payable returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/ERC725X.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// modules\\nimport \\\"./ERC725XCore.sol\\\";\\n\\n/**\\n * @title ERC725 X executor\\n * @author Fabian Vogelsteller <fabian@lukso.network>\\n * @dev Implementation of a contract module which provides the ability to call arbitrary functions at any other smart contract and itself,\\n * including using `delegatecall`, `staticcall` as well creating contracts using `create` and `create2`\\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\\n */\\ncontract ERC725X is ERC725XCore {\\n    /**\\n     * @notice Sets the owner of the contract and register ERC725X interfaceId\\n     * @param _newOwner the owner of the contract\\n     */\\n    constructor(address _newOwner) {\\n        // This is necessary to prevent a contract that implements both ERC725X and ERC725Y to call both constructors\\n        if (_newOwner != owner()) {\\n            OwnableUnset.initOwner(_newOwner);\\n        }\\n        _registerInterface(_INTERFACEID_ERC725X);\\n    }\\n}\\n\"\r\n    },\r\n    \"@erc725/smart-contracts/contracts/ERC725XCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n// constants\\nimport \\\"./constants.sol\\\";\\n\\n// interfaces\\nimport \\\"./interfaces/IERC725X.sol\\\";\\n\\n// libraries\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\nimport \\\"solidity-bytes-utils/contracts/BytesLib.sol\\\";\\nimport \\\"./utils/ErrorHandlerLib.sol\\\";\\n\\n// modules\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\\\";\\nimport \\\"./utils/OwnableUnset.sol\\\";\\n\\n/**\\n * @title Core implementation of ERC725 X executor\\n * @author Fabian Vogelsteller <fabian@lukso.network>\\n * @dev Implementation of a contract module which provides the ability to call arbitrary functions at any other smart contract and itself,\\n * including using `delegatecall`, `staticcall` as well creating contracts using `create` and `create2`\\n * This is the basis for a smart contract based account system, but could also be used as a proxy account system\\n */\\nabstract contract ERC725XCore is OwnableUnset, ERC165Storage, IERC725X {\\n    /* Public functions */\\n\\n    /**\\n     * @inheritdoc IERC725X\\n     */\\n    function execute(\\n        uint256 _operation,\\n        address _to,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) public payable virtual override onlyOwner returns (bytes memory result) {\\n        uint256 txGas = gasleft();\\n\\n        // prettier-ignore\\n\\n        // CALL\\n        if (_operation == OPERATION_CALL) {\\n            result = executeCall(_to, _value, _data, txGas);\\n\\n            emit Executed(_operation, _to, _value, _data);\\n\\n        // STATICCALL\\n        } else if (_operation == OPERATION_STATICCALL) {\\n            result = executeStaticCall(_to, _data, txGas);\\n\\n            emit Executed(_operation, _to, _value, _data);\\n\\n        // DELEGATECALL\\n        } else if (_operation == OPERATION_DELEGATECALL) {\\n            address currentOwner = owner();\\n            result = executeDelegateCall(_to, _data, txGas);\\n            \\n            emit Executed(_operation, _to, _value, _data);\\n\\n            require(owner() == currentOwner, \\\"Delegate call is not allowed to modify the owner!\\\");\\n\\n        // CREATE\\n        } else if (_operation == OPERATION_CREATE) {\\n            address contractAddress = performCreate(_value, _data);\\n            result = abi.encodePacked(contractAddress);\\n\\n            emit ContractCreated(_operation, contractAddress, _value);\\n\\n        // CREATE2\\n        } else if (_operation == OPERATION_CREATE2) {\\n            bytes32 salt = BytesLib.toBytes32(_data, _data.length - 32);\\n            bytes memory data = BytesLib.slice(_data, 0, _data.length - 32);\\n\\n            address contractAddress = Create2.deploy(_value, salt, data);\\n            result = abi.encodePacked(contractAddress);\\n\\n            emit ContractCreated(_operation, contractAddress, _value);\\n    \\n        } else {\\n            revert(\\\"Wrong operation type\\\");\\n        }\\n    }\\n\\n    /* Internal functions */\\n\\n    /**\\n     * @dev perform staticcall using operation 3\\n     * Taken from GnosisSafe: https://github.com/gnosis/safe-contracts/blob/main/contracts/base/Executor.sol\\n     *\\n     * @param to The address on which staticcall is executed\\n     * @param value The value to be sent with the call\\n     * @param data The data to be sent with the call\\n     * @param txGas The amount of gas for performing staticcall\\n     * @return The data from the call\\n     */\\n    function executeCall(\\n        address to,\\n        uint256 value,\\n        bytes memory data,\\n        uint256 txGas\\n    ) internal returns (bytes memory) {\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory result) = to.call{gas: txGas, value: value}(data);\\n\\n        if (!success) {\\n            ErrorHandlerLib.revertWithParsedError(result);\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     * @dev perform staticcall using operation 3\\n     * @param to The address on which staticcall is executed\\n     * @param data The data to be sent with the call\\n     * @param txGas The amount of gas for performing staticcall\\n     * @return The data from the call\\n     */\\n    function executeStaticCall(\\n        address to,\\n        bytes memory data,\\n        uint256 txGas\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory result) = to.staticcall{gas: txGas}(data);\\n\\n        if (!success) {\\n            ErrorHandlerLib.revertWithParsedError(result);\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     * @dev perform delegatecall using operation 4\\n     * Taken from GnosisSafe: https://github.com/gnosis/safe-contracts/blob/main/contracts/base/Executor.sol\\n     *\\n     * @param to The address on which delegatecall is executed\\n     * @param data The data to be sent with the call\\n     * @param txGas The amount of gas for performing delegatecall\\n     * @return The data from the call\\n     */\\n    function executeDelegateCall(\\n        address to,\\n        bytes memory data,\\n        uint256 txGas\\n    ) internal returns (bytes memory) {\\n        // solhint-disable avoid-low-level-calls\\n        (bool success, bytes memory result) = to.delegatecall{gas: txGas}(data);\\n\\n        if (!success) {\\n            ErrorHandlerLib.revertWithParsedError(result);\\n        }\\n\\n        return result;\\n    }\\n\\n    /**\\n     * @dev perform contract creation using operation 1\\n     * Taken from GnosisSafe: https://github.com/gnosis/safe-contracts/blob/main/contracts/libraries/CreateCall.sol\\n     *\\n     * @param value The value to be sent to the contract created\\n     * @param deploymentData The contract bytecode to deploy\\n     * @return newContract The address of the contract created\\n     */\\n    function performCreate(uint256 value, bytes memory deploymentData)\\n        internal\\n        returns (address newContract)\\n    {\\n        assembly {\\n            newContract := create(value, add(deploymentData, 0x20), mload(deploymentData))\\n        }\\n\\n        require(newContract != address(0), \\\"Could not deploy contract\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address) {\\n        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));\\n        return address(uint160(uint256(_data)));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC1271.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/LSP2ERC725YJSONSchema/LSP2Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Utils/UtilsLib.sol\\\";\\n\\n/**\\n * @title ERC725 Utility library to encode key types\\n * @author Jean Cavallera (CJ-42)\\n * @dev based on LSP2 - ERC725Y JSON Schema\\n *      https://github.com/lukso-network/LIPs/blob/master/LSPs/LSP-2-ERC725YJSONSchema.md\\n */\\nlibrary LSP2Utils {\\n    /* solhint-disable no-inline-assembly */\\n\\n    function generateBytes32Key(bytes memory _rawKey)\\n        internal\\n        pure\\n        returns (bytes32 key)\\n    {\\n        // solhint-disable-next-line\\n        assembly {\\n            key := mload(add(_rawKey, 32))\\n        }\\n    }\\n\\n    function generateSingletonKey(string memory _keyName)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return keccak256(bytes(_keyName));\\n    }\\n\\n    function generateArrayKey(string memory _keyName)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory keyName = bytes(_keyName);\\n\\n        // prettier-ignore\\n        require(\\n            keyName[keyName.length - 2] == 0x5b && // \\\"[\\\" in utf8 encoded\\n                keyName[keyName.length - 1] == 0x5d, // \\\"]\\\" in utf8\\n            \\\"Missing empty square brackets \\\\\\\"[]\\\\\\\" at the end of the key name\\\"\\n        );\\n\\n        return keccak256(keyName);\\n    }\\n\\n    function generateArrayKeyAtIndex(bytes32 _arrayKey, uint256 _index)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes memory elementInArray = UtilsLib.concatTwoBytes16(\\n            bytes16(_arrayKey),\\n            bytes16(uint128(_index))\\n        );\\n        return generateBytes32Key(elementInArray);\\n    }\\n\\n    function generateMappingKey(\\n        string memory _firstWord,\\n        string memory _lastWord\\n    ) internal pure returns (bytes32) {\\n        bytes32 firstWordHash = keccak256(bytes(_firstWord));\\n        bytes32 lastWordHash = keccak256(bytes(_lastWord));\\n\\n        bytes memory temporaryBytes = abi.encodePacked(\\n            bytes16(firstWordHash),\\n            bytes12(0),\\n            bytes4(lastWordHash)\\n        );\\n\\n        return generateBytes32Key(temporaryBytes);\\n    }\\n\\n    function generateBytes20MappingKey(\\n        string memory _firstWord,\\n        address _address\\n    ) internal pure returns (bytes32) {\\n        bytes32 firstWordHash = keccak256(bytes(_firstWord));\\n\\n        bytes memory temporaryBytes = abi.encodePacked(\\n            bytes8(firstWordHash),\\n            bytes4(0),\\n            _address\\n        );\\n\\n        return generateBytes32Key(temporaryBytes);\\n    }\\n\\n    function generateBytes20MappingWithGroupingKey(\\n        string memory _firstWord,\\n        string memory _secondWord,\\n        address _address\\n    ) internal pure returns (bytes32) {\\n        bytes32 firstWordHash = keccak256(bytes(_firstWord));\\n        bytes32 secondWordHash = keccak256(bytes(_secondWord));\\n\\n        bytes memory temporaryBytes = abi.encodePacked(\\n            bytes4(firstWordHash),\\n            bytes4(0),\\n            bytes2(secondWordHash),\\n            bytes2(0),\\n            _address\\n        );\\n\\n        return generateBytes32Key(temporaryBytes);\\n    }\\n\\n    function generateBytes20MappingWithGroupingKey(\\n        bytes12 _keyPrefix,\\n        bytes20 _bytes20\\n    ) internal pure returns (bytes32) {\\n        bytes memory generatedKey = bytes.concat(_keyPrefix, _bytes20);\\n        return generateBytes32Key(generatedKey);\\n    }\\n\\n    function generateJSONURLValue(\\n        string memory _hashFunction,\\n        string memory _json,\\n        string memory _url\\n    ) internal pure returns (bytes memory key_) {\\n        bytes32 hashFunctionDigest = keccak256(bytes(_hashFunction));\\n        bytes32 jsonDigest = keccak256(bytes(_json));\\n\\n        key_ = abi.encodePacked(bytes4(hashFunctionDigest), jsonDigest, _url);\\n    }\\n\\n    function generateASSETURLValue(\\n        string memory _hashFunction,\\n        string memory _assetBytes,\\n        string memory _url\\n    ) internal pure returns (bytes memory key_) {\\n        bytes32 hashFunctionDigest = keccak256(bytes(_hashFunction));\\n        bytes32 jsonDigest = keccak256(bytes(_assetBytes));\\n\\n        key_ = abi.encodePacked(bytes4(hashFunctionDigest), jsonDigest, _url);\\n    }\\n}\\n\"\r\n    },\r\n    \"@lukso/lsp-smart-contracts/contracts/Utils/UtilsLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Casting utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, type cast efficiently. // To Test\\n */\\nlibrary UtilsLib {\\n    // solhint-disable no-inline-assembly\\n\\n    /**\\n     * @dev concatenate two bytes16\\n     */\\n    function concatTwoBytes16(bytes16 b1, bytes16 b2)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        result = new bytes(32);\\n        assembly {\\n            mstore(add(result, 32), b1)\\n            mstore(add(result, 48), b2)\\n        }\\n    }\\n\\n    /**\\n     * @dev cast uint256 to bytes\\n     */\\n    function uint256ToBytes(uint256 num)\\n        internal\\n        pure\\n        returns (bytes memory bytes_)\\n    {\\n        bytes_ = new bytes(32);\\n        assembly {\\n            mstore(add(bytes_, 32), num)\\n        }\\n    }\\n\\n    /**\\n     * @dev cast address to bytes\\n     */\\n    function addressToBytes(address addr)\\n        internal\\n        pure\\n        returns (bytes memory bytes_)\\n    {\\n        assembly {\\n            let m := mload(0x40)\\n            addr := and(addr, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\\n            mstore(\\n                add(m, 20),\\n                xor(0x140000000000000000000000000000000000000000, addr)\\n            )\\n            mstore(0x40, add(m, 52))\\n            bytes_ := m\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"NoPermissionsSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"disallowedAddress\",\"type\":\"address\"}],\"name\":\"NotAllowedAddress\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"disallowedKey\",\"type\":\"bytes32\"}],\"name\":\"NotAllowedERC725YKey\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"disallowedFunction\",\"type\":\"bytes4\"}],\"name\":\"NotAllowedFunction\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"permission\",\"type\":\"string\"}],\"name\":\"NotAuthorised\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"account\",\"outputs\":[{\"internalType\":\"contract ERC725\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_signedFor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"executeRelayCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_channel\",\"type\":\"uint256\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"universalProfile\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LSP6KeyManagerProxy", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}