{"SourceCode": "{\"GeniosClubDAI.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\nimport \\\"./TransferHelper.sol\\\";\\r\\nimport \\\"./IGeniosClub.sol\\\";\\r\\n\\r\\ncontract GeniosClubDai is IGeniosClub {\\r\\n  address public Id0;\\r\\n  address public TOKEN;\\r\\n  IERC20 TokenB;\\r\\n  bool internal Locked;\\r\\n\\r\\n\\r\\n  struct User {\\r\\n    uint256 Id;\\r\\n    address Ref;\\r\\n    uint256 Amount;\\r\\n    uint256 TotalTeam;\\r\\n    uint256 DirectRefs;\\r\\n    uint256 G3X2Earnings;\\r\\n    uint256 G3X7Earnings;\\r\\n    uint256[] DirectRefsIds;\\r\\n    mapping(uint8 =\\u003e Rank) Ranks;\\r\\n    mapping(uint8 =\\u003e G3X2) G3X2Matrix;\\r\\n    mapping(uint8 =\\u003e G3X7) G3X7Matrix;\\r\\n    mapping(uint8 =\\u003e bool) ActiveG3X2Levels;\\r\\n    mapping(uint8 =\\u003e bool) ActiveG3X7Levels;\\r\\n    mapping(uint8 =\\u003e uint256) G3X7MatrixRecycleAmount;\\r\\n    mapping(uint8 =\\u003e mapping(uint8 =\\u003e uint256)) RankTeams;\\r\\n  }\\r\\n\\r\\n  struct Rank {\\r\\n    bool IsActive;\\r\\n    uint256 TotalTeam;\\r\\n    uint256 DirectRefs;\\r\\n  }\\r\\n\\r\\n  struct RankTeam {\\r\\n    uint256 G3x7FirstTeam;\\r\\n    uint256 G3x7SecondTeam;\\r\\n    uint256 G3x7ThirdTeam;\\r\\n    uint256 G3x7FourthTeam;\\r\\n    uint256 G3x7FifthTeam;\\r\\n    uint256 G3x7SixthTeam;\\r\\n    uint256 G3x7SeventhTeam;\\r\\n  }\\r\\n\\r\\n  struct G3X2 {\\r\\n    address CurrentRef;\\r\\n    address[] FirstLevelRefs;\\r\\n    address[] SecondLevelRefs;\\r\\n    bool Blocked;\\r\\n    uint256 ReinvestCount;\\r\\n    uint256 ReinvestTime;\\r\\n    uint256 Earnings;\\r\\n  }\\r\\n\\r\\n  struct IG3X7 {\\r\\n    address CurrentRef;\\r\\n    address[] FirstLevelRefs;\\r\\n    address[] SecondLevelRefs;\\r\\n    address[] ThirdLevelRefs;\\r\\n    address[] FourthLevelRefs;\\r\\n    address[] FifthLevelRefs;\\r\\n    bool Blocked;\\r\\n    uint256 ReinvestCount;\\r\\n    uint256 ReinvestTime;\\r\\n    uint256 Earnings;\\r\\n  }\\r\\n\\r\\n  struct G3X7 {\\r\\n    bool Blocked;\\r\\n    uint256 Earnings;\\r\\n    address CurrentRef;\\r\\n    uint256 ReinvestTime;\\r\\n    uint256 ReinvestCount;\\r\\n    mapping(uint8 =\\u003e address[]) LevelRefs;\\r\\n  }\\r\\n\\r\\n  struct Teams {\\r\\n    // G3x2\\r\\n    uint256 G3x2FirstTeam;\\r\\n    uint256 G3x2SecondTeam;\\r\\n    // G3x7\\r\\n    uint256 G3x7FirstTeam;\\r\\n    uint256 G3x7SecondTeam;\\r\\n    uint256 G3x7ThirdTeam;\\r\\n    uint256 G3x7FourthTeam;\\r\\n    uint256 G3x7FifthTeam;\\r\\n  }\\r\\n\\r\\n  struct Plat {\\r\\n    uint256 G3X2TotalEarnings;\\r\\n    uint256 G3X7TotalEarnings;\\r\\n  }\\r\\n\\r\\n  Plat public Platform;\\r\\n  uint256 public LastUserId = 1;\\r\\n  mapping(address =\\u003e User) public Users;\\r\\n  mapping(address =\\u003e Teams) public UsersTeams;\\r\\n  mapping(address =\\u003e bool) public IsUserExists;\\r\\n  mapping(uint256 =\\u003e address) public IdToAddress;\\r\\n\\r\\n  uint8 public constant LAST_LEVEL = 8;\\r\\n  uint256[9] public LevelPrice = [\\r\\n    0,\\r\\n    2.5e18,\\r\\n    10e18,\\r\\n    40e18,\\r\\n    160e18,\\r\\n    640e18,\\r\\n    2560e18,\\r\\n    10240e18,\\r\\n    40960e18\\r\\n  ];\\r\\n  uint256[9] public RankReqTotalTeam = [\\r\\n    0,\\r\\n    10,\\r\\n    40,\\r\\n    160,\\r\\n    640,\\r\\n    2560,\\r\\n    10240,\\r\\n    40960,\\r\\n    163840\\r\\n  ];\\r\\n  uint256[9] public RankTeamPerLineLimit = [\\r\\n    0,\\r\\n    10,\\r\\n    10,\\r\\n    40,\\r\\n    160,\\r\\n    640,\\r\\n    2560,\\r\\n    10240,\\r\\n    40960\\r\\n  ];\\r\\n  uint8[6] public LevelPricePercentage = [0, 10, 10, 15, 20, 25];\\r\\n\\r\\n  uint8 public RanksComm = 10;\\r\\n  uint8 public AcademyAndMarketingComm = 20;\\r\\n\\r\\n  // address public PoolAddr;\\r\\n  address public AcademyAndMarketingAddr;\\r\\n\\r\\n  constructor(\\r\\n    address id0,\\r\\n    address tokenAddr,\\r\\n    address academyAndMarketingAddr\\r\\n  ) {\\r\\n    Id0 = id0;\\r\\n    TOKEN = tokenAddr;\\r\\n    TokenB = IERC20(tokenAddr);\\r\\n    AcademyAndMarketingAddr = academyAndMarketingAddr;\\r\\n\\r\\n    Users[Id0].Id = 0;\\r\\n    IdToAddress[0] = Id0;\\r\\n    IsUserExists[Id0] = true;\\r\\n    for (uint8 i = 1; i \\u003c= LAST_LEVEL; i++) {\\r\\n      Users[Id0].Ranks[i].IsActive = true;\\r\\n      Users[Id0].ActiveG3X2Levels[i] = true;\\r\\n      Users[Id0].ActiveG3X7Levels[i] = true;\\r\\n      Users[Id0].G3X2Matrix[i].CurrentRef = Id0;\\r\\n      Users[Id0].G3X7Matrix[i].CurrentRef = Id0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  modifier noReentrant() {\\r\\n    require(!Locked, \\\"No re-entrancy\\\");\\r\\n    Locked = true;\\r\\n    _;\\r\\n    Locked = false;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   *\\r\\n   *\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   * external functions\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   */\\r\\n\\r\\n  function RegistrationExt(address refAddr) external noReentrant {\\r\\n    TransferHelper.safeTransferFrom(\\r\\n      TOKEN,\\r\\n      msg.sender,\\r\\n      address(this),\\r\\n      LevelPrice[1] * 2\\r\\n    );\\r\\n\\r\\n    _registration(msg.sender, refAddr);\\r\\n  }\\r\\n\\r\\n  function buyNewLevel(uint8 level, uint8 matrix) external noReentrant {\\r\\n    require(matrix == 1 || matrix == 2, \\\"GC: Invalid matrix\\\");\\r\\n\\r\\n    TransferHelper.safeTransferFrom(\\r\\n      TOKEN,\\r\\n      msg.sender,\\r\\n      address(this),\\r\\n      LevelPrice[level]\\r\\n    );\\r\\n\\r\\n    if (matrix == 1) {\\r\\n      return _buyNewLevelG3X2(msg.sender, level);\\r\\n    }\\r\\n\\r\\n    _buyNewLevelG3X7(msg.sender, level);\\r\\n  }\\r\\n\\r\\n  function _registration(address userAddr, address refAddr) private {\\r\\n    require(!IsUserExists[userAddr], \\\"GC: User exists\\\");\\r\\n    require(IsUserExists[refAddr], \\\"GC: Referrer not exists\\\");\\r\\n\\r\\n    uint8 level = 1;\\r\\n\\r\\n    Users[userAddr].Id = LastUserId;\\r\\n    Users[userAddr].Ref = refAddr;\\r\\n\\r\\n    IdToAddress[LastUserId] = userAddr;\\r\\n    IsUserExists[userAddr] = true;\\r\\n    LastUserId++;\\r\\n\\r\\n    Users[refAddr].DirectRefs++;\\r\\n    Users[refAddr].DirectRefsIds.push(LastUserId);\\r\\n\\r\\n    Users[userAddr].ActiveG3X2Levels[level] = true;\\r\\n    Users[userAddr].ActiveG3X7Levels[level] = true;\\r\\n\\r\\n    if (!Users[refAddr].Ranks[level].IsActive)\\r\\n      Users[refAddr].Ranks[level].DirectRefs++;\\r\\n\\r\\n    address freeG3X2Ref = findFreeG3X2Referrer(userAddr, level);\\r\\n    updateG3X2Referrer(userAddr, freeG3X2Ref, level);\\r\\n\\r\\n    address freeG3X7Ref = findFreeG3X7Referrer(userAddr, level);\\r\\n    updateG3X7Referrer(userAddr, freeG3X7Ref, level);\\r\\n\\r\\n    emit Registration(userAddr, refAddr, Users[userAddr].Id, Users[refAddr].Id);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   *\\r\\n   *\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   * G3X2\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   */\\r\\n\\r\\n  function _buyNewLevelG3X2(address userAddr, uint8 level) internal {\\r\\n    require(IsUserExists[userAddr], \\\"GC: Register first.\\\");\\r\\n\\r\\n    require(!Users[userAddr].ActiveG3X2Levels[level], \\\"GC: Level activated\\\");\\r\\n\\r\\n    require(level \\u003e 1 \\u0026\\u0026 level \\u003c= LAST_LEVEL, \\\"GC: Invalid level\\\");\\r\\n\\r\\n    require(\\r\\n      Users[userAddr].ActiveG3X2Levels[level - 1],\\r\\n      \\\"GC: Previous level inactive\\\"\\r\\n    );\\r\\n\\r\\n    Users[userAddr].ActiveG3X2Levels[level] = true;\\r\\n    if (Users[userAddr].G3X2Matrix[level - 1].Blocked) {\\r\\n      Users[userAddr].G3X2Matrix[level - 1].Blocked = false;\\r\\n    }\\r\\n\\r\\n    address freeG3X2Ref = findFreeG3X2Referrer(userAddr, level);\\r\\n    updateG3X2Referrer(userAddr, freeG3X2Ref, level);\\r\\n\\r\\n    emit Upgrade(Users[userAddr].Id, userAddr, freeG3X2Ref, 1, level);\\r\\n  }\\r\\n\\r\\n  function updateG3X2Referrer(\\r\\n    address userAddr,\\r\\n    address refAddr,\\r\\n    uint8 level\\r\\n  ) private {\\r\\n    require(\\r\\n      Users[refAddr].ActiveG3X2Levels[level],\\r\\n      \\\"GC: Referrer level inactive\\\"\\r\\n    );\\r\\n\\r\\n    if (Users[refAddr].G3X2Matrix[level].FirstLevelRefs.length \\u003c 3) {\\r\\n      Users[refAddr].G3X2Matrix[level].FirstLevelRefs.push(userAddr);\\r\\n      UsersTeams[refAddr].G3x2FirstTeam++;\\r\\n\\r\\n      emit NewUserPlace(\\r\\n        userAddr,\\r\\n        refAddr,\\r\\n        Users[refAddr].Id,\\r\\n        1,\\r\\n        level,\\r\\n        uint8(Users[refAddr].G3X2Matrix[level].FirstLevelRefs.length)\\r\\n      );\\r\\n\\r\\n      //set current level\\r\\n      Users[userAddr].G3X2Matrix[level].CurrentRef = refAddr;\\r\\n\\r\\n      if (refAddr == Id0) {\\r\\n        return sendG3X2TokenDividends(refAddr, userAddr, level);\\r\\n      }\\r\\n\\r\\n      address ref = Users[refAddr].G3X2Matrix[level].CurrentRef;\\r\\n      Users[ref].G3X2Matrix[level].SecondLevelRefs.push(userAddr);\\r\\n      UsersTeams[ref].G3x2SecondTeam++;\\r\\n\\r\\n      emit NewUserPlace(\\r\\n        userAddr,\\r\\n        ref,\\r\\n        Users[refAddr].Id,\\r\\n        1,\\r\\n        level,\\r\\n        uint8(Users[refAddr].G3X2Matrix[level].FirstLevelRefs.length)\\r\\n      );\\r\\n\\r\\n      return updateG3X2RefSecondLevel(userAddr, ref, level);\\r\\n    }\\r\\n\\r\\n    Users[refAddr].G3X2Matrix[level].SecondLevelRefs.push(userAddr);\\r\\n    UsersTeams[refAddr].G3x2SecondTeam++;\\r\\n\\r\\n    if (\\r\\n      (Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[0]]\\r\\n        .G3X2Matrix[level]\\r\\n        .FirstLevelRefs\\r\\n        .length \\u003c=\\r\\n        Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[1]]\\r\\n          .G3X2Matrix[level]\\r\\n          .FirstLevelRefs\\r\\n          .length) \\u0026\\u0026\\r\\n      (Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[1]]\\r\\n        .G3X2Matrix[level]\\r\\n        .FirstLevelRefs\\r\\n        .length \\u003c=\\r\\n        Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[2]]\\r\\n          .G3X2Matrix[level]\\r\\n          .FirstLevelRefs\\r\\n          .length)\\r\\n    ) {\\r\\n      updateG3X2(userAddr, refAddr, level, 0);\\r\\n    } else if (\\r\\n      Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[1]]\\r\\n        .G3X2Matrix[level]\\r\\n        .FirstLevelRefs\\r\\n        .length \\u003c=\\r\\n      Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[2]]\\r\\n        .G3X2Matrix[level]\\r\\n        .FirstLevelRefs\\r\\n        .length\\r\\n    ) {\\r\\n      updateG3X2(userAddr, refAddr, level, 1);\\r\\n    } else {\\r\\n      updateG3X2(userAddr, refAddr, level, 2);\\r\\n    }\\r\\n\\r\\n    updateG3X2RefSecondLevel(userAddr, refAddr, level);\\r\\n  }\\r\\n\\r\\n  function updateG3X2(\\r\\n    address userAddr,\\r\\n    address refAddr,\\r\\n    uint8 level,\\r\\n    uint8 x2\\r\\n  ) private {\\r\\n    Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[x2]]\\r\\n      .G3X2Matrix[level]\\r\\n      .FirstLevelRefs\\r\\n      .push(userAddr);\\r\\n\\r\\n    UsersTeams[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[x2]]\\r\\n      .G3x2FirstTeam++;\\r\\n\\r\\n    emit NewUserPlace(\\r\\n      userAddr,\\r\\n      Users[refAddr].G3X2Matrix[level].FirstLevelRefs[x2],\\r\\n      Users[refAddr].Id,\\r\\n      1,\\r\\n      level,\\r\\n      uint8(\\r\\n        Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[x2]]\\r\\n          .G3X2Matrix[level]\\r\\n          .FirstLevelRefs\\r\\n          .length\\r\\n      )\\r\\n    );\\r\\n\\r\\n    emit NewUserPlace(\\r\\n      userAddr,\\r\\n      refAddr,\\r\\n      Users[refAddr].Id,\\r\\n      1,\\r\\n      level,\\r\\n      uint8(\\r\\n        Users[Users[refAddr].G3X2Matrix[level].FirstLevelRefs[x2]]\\r\\n          .G3X2Matrix[level]\\r\\n          .FirstLevelRefs\\r\\n          .length\\r\\n      )\\r\\n    );\\r\\n\\r\\n    //set current level\\r\\n    Users[userAddr].G3X2Matrix[level].CurrentRef = Users[refAddr]\\r\\n      .G3X2Matrix[level]\\r\\n      .FirstLevelRefs[x2];\\r\\n  }\\r\\n\\r\\n  function updateG3X2RefSecondLevel(\\r\\n    address userAddr,\\r\\n    address refAddr,\\r\\n    uint8 level\\r\\n  ) private {\\r\\n    uint256 len = Users[refAddr].G3X2Matrix[level].SecondLevelRefs.length;\\r\\n\\r\\n    if (len \\u003c 9) {\\r\\n      if (\\r\\n        !Users[refAddr].ActiveG3X2Levels[level + 1] \\u0026\\u0026\\r\\n        level != LAST_LEVEL \\u0026\\u0026\\r\\n        len \\u003e 4\\r\\n      ) {\\r\\n        Users[refAddr].Amount += LevelPrice[level];\\r\\n\\r\\n        if (Users[refAddr].Amount \\u003e= LevelPrice[level + 1]) {\\r\\n          _buyNewLevelG3X2(refAddr, level + 1);\\r\\n          Users[refAddr].Amount -= LevelPrice[level + 1];\\r\\n        }\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      return sendG3X2TokenDividends(refAddr, userAddr, level);\\r\\n    }\\r\\n\\r\\n    // recycle\\r\\n    Users[refAddr].G3X2Matrix[level].FirstLevelRefs = new address[](0);\\r\\n    Users[refAddr].G3X2Matrix[level].SecondLevelRefs = new address[](0);\\r\\n\\r\\n    if (!Users[refAddr].ActiveG3X2Levels[level + 1] \\u0026\\u0026 level != LAST_LEVEL) {\\r\\n      Users[refAddr].G3X2Matrix[level].Blocked = true;\\r\\n    }\\r\\n\\r\\n    Users[refAddr].G3X2Matrix[level].ReinvestCount++;\\r\\n    Users[refAddr].G3X2Matrix[level].ReinvestTime = block.timestamp;\\r\\n\\r\\n    if (refAddr != Id0) {\\r\\n      address freeRefAddr = findFreeG3X2Referrer(refAddr, level);\\r\\n      emit Reinvest(\\r\\n        Users[refAddr].Id,\\r\\n        refAddr,\\r\\n        freeRefAddr,\\r\\n        userAddr,\\r\\n        1,\\r\\n        level\\r\\n      );\\r\\n\\r\\n      updateG3X2Referrer(refAddr, freeRefAddr, level);\\r\\n    } else {\\r\\n      emit Reinvest(Users[Id0].Id, Id0, address(0), userAddr, 1, level);\\r\\n      sendG3X2TokenDividends(Id0, userAddr, level);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function findFreeG3X2Referrer(\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) public view returns (address refAddr) {\\r\\n    while (true) {\\r\\n      if (Users[Users[userAddr].Ref].ActiveG3X2Levels[level]) {\\r\\n        return Users[userAddr].Ref;\\r\\n      }\\r\\n      userAddr = Users[userAddr].Ref;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function sendG3X2TokenDividends(\\r\\n    address refAddr,\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) private {\\r\\n    (address receiver, bool isExtraDividends) = findTokenG3X2Receiver(\\r\\n      refAddr,\\r\\n      userAddr,\\r\\n      level\\r\\n    );\\r\\n\\r\\n    uint256 amount1 = LevelPrice[level];\\r\\n    TransferHelper.safeTransfer(TOKEN, receiver, amount1);\\r\\n\\r\\n    Platform.G3X2TotalEarnings += amount1;\\r\\n    Users[receiver].G3X2Earnings += amount1;\\r\\n    Users[receiver].G3X2Matrix[level].Earnings += amount1;\\r\\n\\r\\n    if (isExtraDividends)\\r\\n      emit SentExtraTokenDividends(\\r\\n        Users[userAddr].Id,\\r\\n        userAddr,\\r\\n        receiver,\\r\\n        1,\\r\\n        level\\r\\n      );\\r\\n  }\\r\\n\\r\\n  function findTokenG3X2Receiver(\\r\\n    address refAddr,\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) private returns (address _receiver, bool _isExtraDividends) {\\r\\n    address receiver = refAddr;\\r\\n    bool isExtraDividends;\\r\\n\\r\\n    while (true) {\\r\\n      if (Users[receiver].G3X2Matrix[level].Blocked) {\\r\\n        emit MissedTokenReceive(\\r\\n          Users[receiver].Id,\\r\\n          receiver,\\r\\n          userAddr,\\r\\n          2,\\r\\n          level\\r\\n        );\\r\\n        isExtraDividends = true;\\r\\n        receiver = Users[receiver].G3X2Matrix[level].CurrentRef;\\r\\n      } else {\\r\\n        return (receiver, isExtraDividends);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   *\\r\\n   *\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   * G3X7\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   */\\r\\n\\r\\n  function _buyNewLevelG3X7(address userAddr, uint8 level) internal {\\r\\n    require(IsUserExists[userAddr], \\\"GC: Register first.\\\");\\r\\n    require(!Users[userAddr].ActiveG3X7Levels[level], \\\"GC: Level activated.\\\");\\r\\n    require(level \\u003e 1 \\u0026\\u0026 level \\u003c= LAST_LEVEL, \\\"GC: Invalid level.\\\");\\r\\n    require(\\r\\n      Users[userAddr].ActiveG3X7Levels[level - 1],\\r\\n      \\\"GC: Previous level inactive\\\"\\r\\n    );\\r\\n\\r\\n    Users[userAddr].ActiveG3X7Levels[level] = true;\\r\\n    if (Users[userAddr].G3X7Matrix[level - 1].Blocked) {\\r\\n      Users[userAddr].G3X7Matrix[level - 1].Blocked = false;\\r\\n    }\\r\\n    if (level == 2) {\\r\\n      if (\\r\\n          !Users[userAddr].Ranks[level - 1].IsActive \\u0026\\u0026\\r\\n          Users[userAddr].Ranks[level - 1].DirectRefs \\u003e= 3 \\r\\n            ) {\\r\\n          _activeUserRank(userAddr, level - 1);\\r\\n        }\\r\\n    } else if(level \\u003e 2) {\\r\\n      if (\\r\\n          !Users[userAddr].Ranks[level - 1].IsActive \\u0026\\u0026\\r\\n          Users[userAddr].Ranks[level - 1].DirectRefs \\u003e= 4 \\r\\n            ) {\\r\\n          _activeUserRank(userAddr, level - 1);\\r\\n        }\\r\\n    }\\r\\n      \\r\\n    \\r\\n\\r\\n    address freeG3X7Ref = findFreeG3X7Referrer(userAddr, level);\\r\\n    updateG3X7Referrer(userAddr, freeG3X7Ref, level);\\r\\n\\r\\n    emit Upgrade(Users[userAddr].Id, userAddr, freeG3X7Ref, 1, level);\\r\\n  }\\r\\n\\r\\n  function _activeUserRank(address userAddr, uint8 level) private {\\r\\n    if (\\r\\n      level != LAST_LEVEL \\u0026\\u0026\\r\\n      Users[userAddr].Ref != Id0 \\u0026\\u0026\\r\\n      !Users[Users[userAddr].Ref].Ranks[level + 1].IsActive\\r\\n    ) Users[Users[userAddr].Ref].Ranks[level + 1].DirectRefs++;\\r\\n\\r\\n    // IPool(PoolAddr).AddUser(level, userAddr);\\r\\n    Users[userAddr].Ranks[level].IsActive = true;\\r\\n    // emit RankEarners(Users[userAddr].Id, userAddr, level);\\r\\n  }\\r\\n\\r\\n  function _checkAndUpdateUserRank(\\r\\n    address userAddr,\\r\\n    uint8 level,\\r\\n    uint8 rank\\r\\n  ) private {\\r\\n    if (\\r\\n      RankTeamPerLineLimit[level] \\u003e= Users[userAddr].RankTeams[level][rank] \\u0026\\u0026\\r\\n      !Users[userAddr].Ranks[level].IsActive\\r\\n    ) {\\r\\n      Users[userAddr].Ranks[level].TotalTeam++;\\r\\n      Users[userAddr].RankTeams[level][rank]++;\\r\\n    }\\r\\n    \\r\\n    if(level == 1){\\r\\n      \\t  if (\\r\\n      !Users[userAddr].Ranks[level].IsActive \\u0026\\u0026\\r\\n      Users[userAddr].Ranks[level].DirectRefs \\u003e= 3 \\u0026\\u0026\\r\\n      Users[userAddr].Ranks[level].TotalTeam \\u003e= RankReqTotalTeam[level]\\r\\n    ) {\\r\\n      if (\\r\\n        (Users[userAddr].ActiveG3X7Levels[level + 1] \\u0026\\u0026 level != LAST_LEVEL) ||\\r\\n        level == LAST_LEVEL\\r\\n      ) {\\r\\n        _activeUserRank(userAddr, level);\\r\\n      }\\r\\n    }\\r\\n    }else{\\r\\n         if (\\r\\n              !Users[userAddr].Ranks[level].IsActive \\u0026\\u0026\\r\\n              Users[userAddr].Ranks[level].DirectRefs \\u003e= 4\\r\\n            ) {\\r\\n      if (\\r\\n        (Users[userAddr].ActiveG3X7Levels[level + 1] \\u0026\\u0026 level != LAST_LEVEL) ||\\r\\n        level == LAST_LEVEL\\r\\n      ) {\\r\\n        _activeUserRank(userAddr, level);\\r\\n      }\\r\\n         }\\r\\n\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function updateG3X7Referrer(\\r\\n    address userAddr,\\r\\n    address refAddr,\\r\\n    uint8 level\\r\\n  ) private {\\r\\n    require(\\r\\n      Users[refAddr].ActiveG3X7Levels[level],\\r\\n      \\\"GC: Referrer level inactive\\\"\\r\\n    );\\r\\n\\r\\n    address currentRef;\\r\\n\\r\\n    if (Users[refAddr].G3X7Matrix[level].LevelRefs[1].length \\u003c 3) {\\r\\n      return updateG3X7AllLevelRef(userAddr, refAddr, level);\\r\\n    } else if (Users[refAddr].G3X7Matrix[level].LevelRefs[2].length \\u003c 9) {\\r\\n      currentRef = getG3x7CurrentRef(refAddr, level, 2, 1);\\r\\n      return updateG3X7AllLevelRef(userAddr, currentRef, level);\\r\\n    } else if (Users[refAddr].G3X7Matrix[level].LevelRefs[3].length \\u003c 27) {\\r\\n      currentRef = getG3x7CurrentRef(refAddr, level, 8, 2);\\r\\n      return updateG3X7AllLevelRef(userAddr, currentRef, level);\\r\\n    } else if (Users[refAddr].G3X7Matrix[level].LevelRefs[4].length \\u003c 81) {\\r\\n      currentRef = getG3x7CurrentRef(refAddr, level, 26, 3);\\r\\n      return updateG3X7AllLevelRef(userAddr, currentRef, level);\\r\\n    }\\r\\n\\r\\n    currentRef = getG3x7CurrentRef(refAddr, level, 80, 4);\\r\\n    updateG3X7AllLevelRef(userAddr, currentRef, level);\\r\\n  }\\r\\n\\r\\n  function getG3x7CurrentRef(\\r\\n    address refAddr,\\r\\n    uint8 level,\\r\\n    uint16 len,\\r\\n    uint8 lr\\r\\n  ) private view returns (address) {\\r\\n    address currentRef;\\r\\n\\r\\n    // Iterate over the first level referrals of the refAddr\\u0027s G3X7Matrix[level]\\r\\n    for (uint16 j = 0; j \\u003c len; j++) {\\r\\n      bool isRef = true;\\r\\n\\r\\n      // Compare the len of the first level referrals of two Users in the G3X7Matrix[level]\\r\\n      for (uint16 i = j; i \\u003c len; i++) {\\r\\n        if (\\r\\n          Users[Users[refAddr].G3X7Matrix[level].LevelRefs[lr][i]]\\r\\n            .G3X7Matrix[level]\\r\\n            .LevelRefs[1]\\r\\n            .length \\u003e\\r\\n          Users[Users[refAddr].G3X7Matrix[level].LevelRefs[lr][i + 1]]\\r\\n            .G3X7Matrix[level]\\r\\n            .LevelRefs[1]\\r\\n            .length\\r\\n        ) {\\r\\n          isRef = false;\\r\\n          break; // Exit the inner loop\\r\\n        }\\r\\n      }\\r\\n\\r\\n      // If the condition is true (isRef is true), update the refAddr and break the loop.\\r\\n      if (isRef) {\\r\\n        currentRef = Users[refAddr].G3X7Matrix[level].LevelRefs[lr][j];\\r\\n        break;\\r\\n      }\\r\\n\\r\\n      // If we reach the last element and isRef is false, update the refAddr and break the loop.\\r\\n      if (j + 1 == len) {\\r\\n        currentRef = Users[refAddr].G3X7Matrix[level].LevelRefs[lr][j + 1];\\r\\n        break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Return the refAddr found in the loop (second-level referrer).\\r\\n    return currentRef;\\r\\n  }\\r\\n\\r\\n  function updateG3X7AllLevelRef(\\r\\n    address userAddr,\\r\\n    address curRefaddr,\\r\\n    uint8 level\\r\\n  ) private {\\r\\n    // Update the referrer\\u0027s referrals based on the level\\r\\n    Users[curRefaddr].G3X7Matrix[level].LevelRefs[1].push(userAddr);\\r\\n    Users[userAddr].G3X7Matrix[level].CurrentRef = curRefaddr;\\r\\n    UsersTeams[curRefaddr].G3x7FirstTeam++;\\r\\n    Users[curRefaddr].TotalTeam++;\\r\\n\\r\\n    _checkAndUpdateUserRank(curRefaddr, level, 1);\\r\\n\\r\\n    if (curRefaddr == Id0) {\\r\\n      return sendG3X7TokenDividends(curRefaddr, userAddr, level, 5);\\r\\n    }\\r\\n\\r\\n    address ref_currentRef = Users[curRefaddr].G3X7Matrix[level].CurrentRef;\\r\\n    Users[ref_currentRef].G3X7Matrix[level].LevelRefs[2].push(userAddr);\\r\\n    UsersTeams[ref_currentRef].G3x7SecondTeam++;\\r\\n    Users[ref_currentRef].TotalTeam++;\\r\\n\\r\\n    _checkAndUpdateUserRank(ref_currentRef, level, 2);\\r\\n\\r\\n    if (ref_currentRef == Id0) {\\r\\n      return sendG3X7TokenDividends(curRefaddr, userAddr, level, 5);\\r\\n    }\\r\\n\\r\\n    ref_currentRef = Users[ref_currentRef].G3X7Matrix[level].CurrentRef;\\r\\n    Users[ref_currentRef].G3X7Matrix[level].LevelRefs[3].push(userAddr);\\r\\n    UsersTeams[ref_currentRef].G3x7ThirdTeam++;\\r\\n    Users[ref_currentRef].TotalTeam++;\\r\\n\\r\\n    _checkAndUpdateUserRank(ref_currentRef, level, 3);\\r\\n\\r\\n    if (ref_currentRef == Id0) {\\r\\n      return sendG3X7TokenDividends(curRefaddr, userAddr, level, 5);\\r\\n    }\\r\\n\\r\\n    ref_currentRef = Users[ref_currentRef].G3X7Matrix[level].CurrentRef;\\r\\n    Users[ref_currentRef].G3X7Matrix[level].LevelRefs[4].push(userAddr);\\r\\n    UsersTeams[ref_currentRef].G3x7FourthTeam++;\\r\\n    Users[ref_currentRef].TotalTeam++;\\r\\n\\r\\n    _checkAndUpdateUserRank(ref_currentRef, level, 4);\\r\\n\\r\\n    if (ref_currentRef == Id0) {\\r\\n      return sendG3X7TokenDividends(curRefaddr, userAddr, level, 5);\\r\\n    }\\r\\n\\r\\n    ref_currentRef = Users[ref_currentRef].G3X7Matrix[level].CurrentRef;\\r\\n    Users[ref_currentRef].G3X7Matrix[level].LevelRefs[5].push(userAddr);\\r\\n    UsersTeams[ref_currentRef].G3x7FifthTeam++;\\r\\n    Users[ref_currentRef].TotalTeam++;\\r\\n\\r\\n    _checkAndUpdateUserRank(ref_currentRef, level, 5);\\r\\n    updateG3X7RefLastLevel(userAddr, ref_currentRef, curRefaddr, level);\\r\\n  }\\r\\n\\r\\n  function updateG3X7RefLastLevel(\\r\\n    address userAddr,\\r\\n    address refAddr,\\r\\n    address curRefaddr,\\r\\n    uint8 level\\r\\n  ) private {\\r\\n    uint256 len = Users[refAddr].G3X7Matrix[level].LevelRefs[5].length;\\r\\n    uint256 amount = calPerc(LevelPrice[level], LevelPricePercentage[5]);\\r\\n\\r\\n    if (len \\u003c= 239) {\\r\\n      if (\\r\\n        !Users[refAddr].ActiveG3X7Levels[level + 1] \\u0026\\u0026\\r\\n        level != LAST_LEVEL \\u0026\\u0026\\r\\n        len \\u003e= 224\\r\\n      ) {\\r\\n        Users[refAddr].Amount += amount;\\r\\n        sendG3X7TokenDividends(curRefaddr, userAddr, level, 4);\\r\\n\\r\\n        if (Users[refAddr].Amount \\u003e= LevelPrice[level + 1]) {\\r\\n          _buyNewLevelG3X7(refAddr, level + 1);\\r\\n          Users[refAddr].Amount -= LevelPrice[level + 1];\\r\\n        }\\r\\n\\r\\n        return;\\r\\n      }\\r\\n\\r\\n      return sendG3X7TokenDividends(curRefaddr, userAddr, level, 5);\\r\\n    }\\r\\n\\r\\n    if (len \\u003c 243) {\\r\\n      Users[refAddr].G3X7MatrixRecycleAmount[level] += amount;\\r\\n      return sendG3X7TokenDividends(curRefaddr, userAddr, level, 4);\\r\\n    }\\r\\n\\r\\n    Users[refAddr].G3X7MatrixRecycleAmount[level] = 0;\\r\\n    sendG3X7TokenDividends(curRefaddr, userAddr, level, 4);\\r\\n\\r\\n    // recycle\\r\\n    Users[refAddr].G3X7Matrix[level].LevelRefs[1] = new address[](0);\\r\\n    Users[refAddr].G3X7Matrix[level].LevelRefs[2] = new address[](0);\\r\\n    Users[refAddr].G3X7Matrix[level].LevelRefs[3] = new address[](0);\\r\\n    Users[refAddr].G3X7Matrix[level].LevelRefs[4] = new address[](0);\\r\\n    Users[refAddr].G3X7Matrix[level].LevelRefs[5] = new address[](0);\\r\\n\\r\\n    if (!Users[refAddr].ActiveG3X7Levels[level + 1] \\u0026\\u0026 level != LAST_LEVEL) {\\r\\n      Users[refAddr].G3X7Matrix[level].Blocked = true;\\r\\n    }\\r\\n\\r\\n    Users[refAddr].G3X7Matrix[level].ReinvestCount++;\\r\\n    Users[refAddr].G3X7Matrix[level].ReinvestTime = block.timestamp;\\r\\n\\r\\n    if (refAddr != Id0) {\\r\\n      address freeRefAddr = findFreeG3X7Referrer(refAddr, level);\\r\\n      emit Reinvest(\\r\\n        Users[refAddr].Id,\\r\\n        refAddr,\\r\\n        freeRefAddr,\\r\\n        userAddr,\\r\\n        2,\\r\\n        level\\r\\n      );\\r\\n\\r\\n      updateG3X7Referrer(refAddr, freeRefAddr, level);\\r\\n    } else {\\r\\n      emit Reinvest(Users[Id0].Id, Id0, address(0), userAddr, 2, level);\\r\\n      sendG3X7TokenDividends(Id0, userAddr, level, 5);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function findFreeG3X7Referrer(\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) public view returns (address refAddr) {\\r\\n    while (true) {\\r\\n      if (Users[Users[userAddr].Ref].ActiveG3X7Levels[level]) {\\r\\n        return Users[userAddr].Ref;\\r\\n      }\\r\\n      userAddr = Users[userAddr].Ref;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function sendG3X7TokenDividends(\\r\\n    address refAddr,\\r\\n    address userAddr,\\r\\n    uint8 level,\\r\\n    uint8 last\\r\\n  ) private {\\r\\n    (address receiver, bool isExtraDividends) = findTokenG3X7Receiver(\\r\\n      refAddr,\\r\\n      userAddr,\\r\\n      level\\r\\n    );\\r\\n\\r\\n    updateG3X7Academy(receiver, level);\\r\\n\\r\\n    for (uint8 i = 1; i \\u003c= last; i++) {\\r\\n      if (i \\u003e 1 \\u0026\\u0026 receiver != Id0)\\r\\n        receiver = Users[receiver].G3X7Matrix[level].CurrentRef;\\r\\n\\r\\n      uint256 amount2 = calPerc(LevelPrice[level], LevelPricePercentage[i]);\\r\\n      TransferHelper.safeTransfer(TOKEN, receiver, amount2);\\r\\n\\r\\n      Platform.G3X7TotalEarnings += amount2;\\r\\n      Users[receiver].G3X7Earnings += amount2;\\r\\n      Users[receiver].G3X7Matrix[level].Earnings += amount2;\\r\\n\\r\\n      if (isExtraDividends)\\r\\n        emit SentExtraTokenDividends(\\r\\n          Users[userAddr].Id,\\r\\n          userAddr,\\r\\n          receiver,\\r\\n          2,\\r\\n          level\\r\\n        );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function findTokenG3X7Receiver(\\r\\n    address refAddr,\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) private returns (address _receiver, bool _isExtraDividends) {\\r\\n    address receiver = refAddr;\\r\\n    bool isExtraDividends;\\r\\n\\r\\n    while (true) {\\r\\n      if (Users[receiver].G3X7Matrix[level].Blocked) {\\r\\n        emit MissedTokenReceive(\\r\\n          Users[receiver].Id,\\r\\n          receiver,\\r\\n          userAddr,\\r\\n          2,\\r\\n          level\\r\\n        );\\r\\n        isExtraDividends = true;\\r\\n        receiver = Users[receiver].G3X7Matrix[level].CurrentRef;\\r\\n      } else {\\r\\n        return (receiver, isExtraDividends);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n\\r\\n  function updateG3X7Academy(address userAddr, uint8 level) private {\\r\\n    uint256 commAmount = calPerc(LevelPrice[level], AcademyAndMarketingComm);\\r\\n    TransferHelper.safeTransfer(TOKEN, AcademyAndMarketingAddr, commAmount);\\r\\n    emit G3X7AcademyUpdated(Users[userAddr].Id, userAddr, level, commAmount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   *\\r\\n   *\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   * Id0\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   */\\r\\n\\r\\n  \\r\\n\\r\\n  /**\\r\\n   *\\r\\n   *\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   * view functions\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   */\\r\\n\\r\\n  function usersActiveG3X2Levels(\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) public view returns (bool) {\\r\\n    return Users[userAddr].ActiveG3X2Levels[level];\\r\\n  }\\r\\n\\r\\n  function usersActiveG3X7Levels(\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) public view returns (bool) {\\r\\n    return Users[userAddr].ActiveG3X7Levels[level];\\r\\n  }\\r\\n\\r\\n  function usersRanks(\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) public view returns (Rank memory) {\\r\\n    return\\r\\n      Rank({\\r\\n        IsActive: Users[userAddr].Ranks[level].IsActive,\\r\\n        TotalTeam: Users[userAddr].Ranks[level].TotalTeam,\\r\\n        DirectRefs: Users[userAddr].Ranks[level].DirectRefs\\r\\n      });\\r\\n  }\\r\\n\\r\\n  function usersRankTeams(\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) public view returns (RankTeam memory) {\\r\\n    return\\r\\n      RankTeam({\\r\\n        G3x7FirstTeam: Users[userAddr].RankTeams[level][1],\\r\\n        G3x7SecondTeam: Users[userAddr].RankTeams[level][2],\\r\\n        G3x7ThirdTeam: Users[userAddr].RankTeams[level][3],\\r\\n        G3x7FourthTeam: Users[userAddr].RankTeams[level][4],\\r\\n        G3x7FifthTeam: Users[userAddr].RankTeams[level][5],\\r\\n        G3x7SixthTeam: Users[userAddr].RankTeams[level][6],\\r\\n        G3x7SeventhTeam: Users[userAddr].RankTeams[level][7]\\r\\n      });\\r\\n  }\\r\\n\\r\\n  function usersG3X2Matrix(\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) public view returns (G3X2 memory) {\\r\\n    return\\r\\n      G3X2({\\r\\n        CurrentRef: Users[userAddr].G3X2Matrix[level].CurrentRef,\\r\\n        FirstLevelRefs: Users[userAddr].G3X2Matrix[level].FirstLevelRefs,\\r\\n        SecondLevelRefs: Users[userAddr].G3X2Matrix[level].SecondLevelRefs,\\r\\n        Blocked: Users[userAddr].G3X2Matrix[level].Blocked,\\r\\n        ReinvestCount: Users[userAddr].G3X2Matrix[level].ReinvestCount,\\r\\n        ReinvestTime: Users[userAddr].G3X2Matrix[level].ReinvestTime,\\r\\n        Earnings: Users[userAddr].G3X2Matrix[level].Earnings\\r\\n      });\\r\\n  }\\r\\n\\r\\n  function usersG3X7Matrix(\\r\\n    address userAddr,\\r\\n    uint8 level\\r\\n  ) public view returns (IG3X7 memory) {\\r\\n    return\\r\\n      IG3X7({\\r\\n        CurrentRef: Users[userAddr].G3X7Matrix[level].CurrentRef,\\r\\n        FirstLevelRefs: Users[userAddr].G3X7Matrix[level].LevelRefs[1],\\r\\n        SecondLevelRefs: Users[userAddr].G3X7Matrix[level].LevelRefs[2],\\r\\n        ThirdLevelRefs: Users[userAddr].G3X7Matrix[level].LevelRefs[3],\\r\\n        FourthLevelRefs: Users[userAddr].G3X7Matrix[level].LevelRefs[4],\\r\\n        FifthLevelRefs: Users[userAddr].G3X7Matrix[level].LevelRefs[5],\\r\\n        Blocked: Users[userAddr].G3X7Matrix[level].Blocked,\\r\\n        ReinvestCount: Users[userAddr].G3X7Matrix[level].ReinvestCount,\\r\\n        ReinvestTime: Users[userAddr].G3X7Matrix[level].ReinvestTime,\\r\\n        Earnings: Users[userAddr].G3X7Matrix[level].Earnings\\r\\n      });\\r\\n  }\\r\\n\\r\\n  function getDirectRefsIds(\\r\\n    address userAddr\\r\\n  ) public view returns (uint256[] memory refs) {\\r\\n    return Users[userAddr].DirectRefsIds;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   *\\r\\n   *\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   * pure functions\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   */\\r\\n\\r\\n  function calPerc(uint256 tAmount, uint8 tPerc) public pure returns (uint256) {\\r\\n    uint256 perc = (tAmount * tPerc) / 100;\\r\\n    return perc;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   *\\r\\n   *\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   * withdraw functions\\r\\n   * \\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\u003e\\r\\n   */\\r\\n\\r\\n  function withdraw() external noReentrant {\\r\\n    require(IsUserExists[msg.sender], \\\"GC: Users not exists\\\");\\r\\n    require(Users[msg.sender].Amount \\u003e 0, \\\"GC: Users didn\\u0027t have any amount\\\");\\r\\n    bool active = usersActiveG3X2Levels(msg.sender, LAST_LEVEL);\\r\\n    // for all levels\\r\\n    require(active == true, \\\"GC: User only wihdraw once user actives 8 levels\\\");\\r\\n    TransferHelper.safeTransfer(TOKEN, msg.sender, Users[msg.sender].Amount);\\r\\n    Users[msg.sender].Amount = 0;\\r\\n  }\\r\\n   function emergencyWithdraw() public{\\r\\n   require(Id0 == msg.sender, \\\"GC: !Id0\\\");\\r\\n   uint amount = TokenB.balanceOf(address(this));\\r\\n   TransferHelper.safeTransfer(TOKEN, msg.sender,amount );\\r\\n }\\r\\n}\"},\"IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.10;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"},\"IGeniosClub.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.10;\\r\\n\\r\\ninterface IGeniosClub {\\r\\n\\r\\n  event Registration(\\r\\n    address indexed user,\\r\\n    address indexed referrer,\\r\\n    uint256 indexed userId,\\r\\n    uint256 referrerId\\r\\n  );\\r\\n\\r\\n  event UserAdd(address indexed user, address indexed ref, uint8 indexed level);\\r\\n\\r\\n  event Reinvest(\\r\\n    uint256 indexed userId,\\r\\n    address indexed user,\\r\\n    address indexed CurrentRef,\\r\\n    address caller,\\r\\n    uint8 matrix,\\r\\n    uint8 level\\r\\n  );\\r\\n\\r\\n  event Upgrade(\\r\\n    uint256 indexed userId,\\r\\n    address indexed user,\\r\\n    address indexed referrer,\\r\\n    uint8 matrix,\\r\\n    uint8 level\\r\\n  );\\r\\n\\r\\n  event NewUserPlace(\\r\\n    address indexed user,\\r\\n    address indexed referrer,\\r\\n    uint256 indexed userId,\\r\\n    uint8 matrix,\\r\\n    uint8 level,\\r\\n    uint8 place\\r\\n  );\\r\\n\\r\\n  event MissedTokenReceive(\\r\\n    uint256 indexed userId,\\r\\n    address indexed receiver,\\r\\n    address indexed from,\\r\\n    uint8 matrix,\\r\\n    uint8 level\\r\\n  );\\r\\n\\r\\n  event SentExtraTokenDividends(\\r\\n    uint256 indexed userId,\\r\\n    address indexed from,\\r\\n    address indexed receiver,\\r\\n    uint8 matrix,\\r\\n    uint8 level\\r\\n  );\\r\\n\\r\\n  event G3X7RankUpdated(\\r\\n    uint256 indexed userId,\\r\\n    address indexed user,\\r\\n    uint8 indexed level,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  event G3X7ClubUpdated(\\r\\n    uint256 indexed userId,\\r\\n    address indexed user,\\r\\n    uint8 indexed level,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  event G3X7AcademyUpdated(\\r\\n    uint256 indexed userId,\\r\\n    address indexed user,\\r\\n    uint8 indexed level,\\r\\n    uint256 amount\\r\\n  );\\r\\n\\r\\n  event RankEarners(\\r\\n    uint256 indexed userId,\\r\\n    address indexed user,\\r\\n    uint8 indexed level\\r\\n  );\\r\\n}\\r\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.10;\\n\\nimport \\u0027./IERC20.sol\\u0027;\\n\\nlibrary TransferHelper {\\n    /// @notice Transfers tokens from the targeted address to the given destination\\n    /// @notice Errors with \\u0027STF\\u0027 if transfer fails\\n    /// @param token The contract address of the token to be transferred\\n    /// @param from The originating address from which the tokens will be transferred\\n    /// @param to The destination address of the transfer\\n    /// @param value The amount to be transferred\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) =\\n            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027STF\\u0027);\\n    }\\n\\n    /// @notice Transfers tokens from msg.sender to a recipient\\n    /// @dev Errors with ST if transfer fails\\n    /// @param token The contract address of the token which will be transferred\\n    /// @param to The recipient of the transfer\\n    /// @param value The value of the transfer\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027ST\\u0027);\\n    }\\n\\n    /// @notice Approves the stipulated contract to spend the given allowance in the given token\\n    /// @dev Errors with \\u0027SA\\u0027 if transfer fails\\n    /// @param token The contract address of the token to be approved\\n    /// @param to The target of the approval\\n    /// @param value The amount of the given token the target will be allowed to spend\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));\\n        require(success \\u0026\\u0026 (data.length == 0 || abi.decode(data, (bool))), \\u0027SA\\u0027);\\n    }\\n\\n    /// @notice Transfers ETH to the recipient address\\n    /// @dev Fails with `STE`\\n    /// @param to The destination of the transfer\\n    /// @param value The value to be transferred\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\u0027STE\\u0027);\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"id0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"academyAndMarketingAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"G3X7AcademyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"G3X7ClubUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"G3X7RankUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"MissedTokenReceive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"place\",\"type\":\"uint8\"}],\"name\":\"NewUserPlace\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"RankEarners\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"referrerId\",\"type\":\"uint256\"}],\"name\":\"Registration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"CurrentRef\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Reinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"SentExtraTokenDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"userId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"Upgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"ref\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"UserAdd\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AcademyAndMarketingAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AcademyAndMarketingComm\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Id0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"IdToAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"IsUserExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LAST_LEVEL\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LastUserId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LevelPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LevelPricePercentage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Platform\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"G3X2TotalEarnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3X7TotalEarnings\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RankReqTotalTeam\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RankTeamPerLineLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RanksComm\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"refAddr\",\"type\":\"address\"}],\"name\":\"RegistrationExt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"Users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"Id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"Ref\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"Amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"TotalTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectRefs\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3X2Earnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3X7Earnings\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"UsersTeams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"G3x2FirstTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x2SecondTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7FirstTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7SecondTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7ThirdTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7FourthTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7FifthTeam\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"matrix\",\"type\":\"uint8\"}],\"name\":\"buyNewLevel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"tPerc\",\"type\":\"uint8\"}],\"name\":\"calPerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"findFreeG3X2Referrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"refAddr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"findFreeG3X7Referrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"refAddr\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"}],\"name\":\"getDirectRefsIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"refs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersActiveG3X2Levels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersActiveG3X7Levels\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersG3X2Matrix\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"CurrentRef\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"FirstLevelRefs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"SecondLevelRefs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"Blocked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ReinvestCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ReinvestTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Earnings\",\"type\":\"uint256\"}],\"internalType\":\"struct GeniosClubDai.G3X2\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersG3X7Matrix\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"CurrentRef\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"FirstLevelRefs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"SecondLevelRefs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"ThirdLevelRefs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"FourthLevelRefs\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"FifthLevelRefs\",\"type\":\"address[]\"},{\"internalType\":\"bool\",\"name\":\"Blocked\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"ReinvestCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"ReinvestTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"Earnings\",\"type\":\"uint256\"}],\"internalType\":\"struct GeniosClubDai.IG3X7\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersRankTeams\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"G3x7FirstTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7SecondTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7ThirdTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7FourthTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7FifthTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7SixthTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"G3x7SeventhTeam\",\"type\":\"uint256\"}],\"internalType\":\"struct GeniosClubDai.RankTeam\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"name\":\"usersRanks\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"IsActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"TotalTeam\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"DirectRefs\",\"type\":\"uint256\"}],\"internalType\":\"struct GeniosClubDai.Rank\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "GeniosClubDai", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "000000000000000000000000354e8319b7923e009d52f973cfcc83796b3ce6900000000000000000000000008f3cf7ad23cd3cadbd9735aff958023239c6a063000000000000000000000000cc498556f6931bd93cedee7fdba5660b0362476a", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1eebe8d161a9405b2da4c58a0526f523b1c2877ea3e40bc83b0d41365cc54be1"}