{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Credits/Mortgage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./IMortgageControl.sol\\\";\\nimport \\\"../NFT/IHomeCollection.sol\\\";\\nimport \\\"../Control/IMarketContract.sol\\\";\\nimport \\\"../Control/IVaultRewards.sol\\\";\\nimport \\\"../NFT/IwrapNFT.sol\\\";\\nimport \\\"../Lending/IVaultLenders.sol\\\";\\nimport \\\"../Control/TokenInfo.sol\\\";\\nimport \\\"../Control/IControl.sol\\\";\\nimport \\\"../Lending/ILendingControl.sol\\\";\\nimport \\\"./ICalcs.sol\\\";\\nimport \\\"../Credits/IFeesVault.sol\\\";\\n\\ncontract Mortgages is AccessControl, ReentrancyGuard, IMortgageInterest, IERC721Receiver {\\n    using SafeERC20 for IERC20;\\n\\n    ///@dev developer role created\\n    bytes32 public constant DEV_ROLE = 0x51b355059847d158e68950419dbcd54fad00bdfd0634c2515a5c533288c7f0a2;\\n\\n    //Change to mainnet multisig-wallet\\n    address public walletPanoram = 0x526324c87e3e44630971fd2f6d9D69f3914e01DA; //multisig mainnet 0x526324c87e3e44630971fd2f6d9D69f3914e01DA\\n    address public mortgageControl;\\n    address public control;\\n    address public market;\\n    address public guardian = 0x988F94C0Ef61815AacD775789Af297713408D3B8; //relayer Polygon: 0x988F94C0Ef61815AacD775789Af297713408D3B8;\\n    TokenInfo public tokenInfo;\\n    ILendingControl public lControl;\\n    ICals private calc;\\n    IFeesVault public feesVault;\\n\\n    bool private paused;\\n    uint64 private maxLoan = 8500; //8500 is equal to 85%\\n    uint64 private minLoan = 1000; //1000 is equal to 10%\\n    uint64 private creditFee = 150; //150 is equal to 1.5%\\n    uint256 public mortgageId = 233; //Update to mainnet mortgage id\\n    uint256 private feeLenders = 4000; //Equals 40%\\n    uint256 private feePanoram = 6000; //Equals 60%\\n    uint256 private maxperiod = 72; //60 months is equal to 5 years.\\n    uint256 private constant MAX_UINT = 2 ** 255;\\n\\n    struct Position {\\n        address owner;\\n        uint256 idPosition;\\n    }\\n\\n    Position private position;\\n\\n    ///@dev address1 collection address\\n    ///@dev address2 wrapcontract address\\n    mapping(address => address) private wrapData;\\n    mapping(address => address) private properties;\\n    mapping(address => bool) private manual;\\n\\n    event mortgageEvent(\\n        uint256 id,\\n        address user,\\n        address collection,\\n        address wrapContract,\\n        uint256 nftId,\\n        uint256 loan,\\n        uint8 creditType\\n    );\\n    event releaseEvent(uint256 idMortgage, address user, address collection, uint256 nftId, string status);\\n    event mortgageAgain(uint256 oldId, uint256 newId, address user, uint256 newLoan, uint256 newDebt);\\n    event seized(uint256 idMortgage, address user, address collection, uint256 nftId, string status);\\n\\n    constructor(\\n        address _tokenInfo,\\n        address _mortgageControl,\\n        address _market,\\n        address _token,\\n        address vaultLenders,\\n        address rewardsLenders,\\n        address _control,\\n        address _lControl,\\n        address _feesVault\\n    ) {\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _setupRole(DEV_ROLE, msg.sender);\\n        _setupRole(DEFAULT_ADMIN_ROLE, 0x30268390218B20226FC101cD5651A51b12C07470);\\n        _setupRole(DEV_ROLE, 0x30268390218B20226FC101cD5651A51b12C07470);\\n        _setupRole(DEFAULT_ADMIN_ROLE, 0x526324c87e3e44630971fd2f6d9D69f3914e01DA); // cambiar por multisig\\n        _setupRole(DEV_ROLE, 0x526324c87e3e44630971fd2f6d9D69f3914e01DA); // cambiar por multisig\\n\\n        tokenInfo = TokenInfo(_tokenInfo);\\n        mortgageControl = _mortgageControl;\\n        control = _control;\\n        market = _market;\\n        lControl = ILendingControl(_lControl);\\n        feesVault = IFeesVault(_feesVault);\\n        permissions(_token, vaultLenders, rewardsLenders);\\n        approveToken(_token);\\n    }\\n\\n    modifier validToken(address _token) {\\n        if (!tokenInfo.getToken(_token)) {\\n            revert(\\\"Token not support\\\");\\n        }\\n        _;\\n    }\\n\\n    modifier onlydev() {\\n        if (!hasRole(DEV_ROLE, msg.sender)) {\\n            revert(\\\"have no dev role\\\");\\n        }\\n        _;\\n    }\\n\\n    modifier onlyRelayer() {\\n        if (guardian != msg.sender) {\\n            revert(\\\"not realyer\\\");\\n        }\\n        _;\\n    }\\n\\n    modifier onlyManual() {\\n        if (!manual[msg.sender]) {\\n            revert(\\\"manual only\\\");\\n        }\\n        _;\\n    }\\n\\n    /// @dev Modifier to check if the contract is paused.\\n    modifier NotPaused() {\\n        if (paused) {\\n            revert(\\\"credits is paused\\\");\\n        }\\n        _;\\n    }\\n\\n    struct LocalMortgage {\\n        address _collection;\\n        uint256 valuation;\\n        uint256 price;\\n        uint256 presalePrice;\\n        uint256 avaibleLoan;\\n        uint256 downPay;\\n        address wrapContract;\\n        uint256 fee;\\n        uint256 total;\\n        uint256 total2;\\n        uint256 total3;\\n        uint256 pan;\\n        uint256 rewards;\\n        uint256 lenders;\\n        uint256 pan2;\\n        uint256 rewards2;\\n        uint256 lenders2;\\n    }\\n\\n    struct LocalMortgage2 {\\n        uint256 amount;\\n        uint256 tokenId;\\n        string uri;\\n        uint256 minLoan;\\n        address owner;\\n        bool isPay;\\n        uint256 marketPrice;\\n        uint256 buyFee;\\n        bool mortgageAgain;\\n        uint256 linkId;\\n        uint256 subtotal;\\n        uint256 newLoan;\\n        uint256 mintfee;\\n        uint256 debt;\\n        uint256 maxAvaible;\\n        uint256 money;\\n    }\\n\\n    struct LocalMortgage3 {\\n        uint256 _loan;\\n        uint256 _period;\\n        uint256 length1;\\n        uint256 length2;\\n        uint256[] ids;\\n        uint256[] nfts;\\n    }\\n\\n    struct Localdebt {\\n        uint256 totalDebt;\\n        uint256 totalMonthlyPay;\\n        uint256 totalDelayedMonthlyPay;\\n        uint256 totalToPayOnLiquidation;\\n        uint256 lastTimePayment;\\n        bool isMonthlyPaymentPayed;\\n        bool isMonthlyPaymentDelayed;\\n        bool liquidate;\\n        uint256 newDebt;\\n    }\\n\\n    struct LocalVaults {\\n        address vaultLenders;\\n        address vaultRewards;\\n        address rewardsLenders;\\n    }\\n\\n    function openMortgage(address collection, uint256 loan, uint256 period, address token)\\n        public\\n        validToken(token)\\n        NotPaused\\n        returns (uint256 id)\\n    {\\n        (address lenders, address lenRewards,) = tokenInfo.getVaultInfo(token);\\n        if (IVaultLenders(lenders).getAvaible() >= loan) {\\n            id = _openMortgage(collection, loan, period, token, lenders, lenRewards);\\n        } else {\\n            id = _openCredit(collection, loan, period, token, lenRewards);\\n        }\\n    }\\n\\n    function openManualCredit(address collection, uint256 loan, uint256 period, address token, address _user)\\n        public\\n        validToken(token)\\n        onlyManual\\n        NotPaused\\n        returns (uint256 id)\\n    {\\n        LocalMortgage memory locals;\\n        LocalMortgage2 memory locals2;\\n        LocalMortgage3 memory locals3;\\n        LocalVaults memory vaults;\\n\\n        (, vaults.rewardsLenders,) = tokenInfo.getVaultInfo(token);\\n        locals3._loan = loan;\\n        locals3._period = period;\\n\\n        locals._collection = collection;\\n        if (locals._collection == address(0)) {\\n            revert(\\\"is address 0\\\");\\n        }\\n\\n        if (period > maxperiod) {\\n            revert(\\\"exceed maximum period\\\");\\n        }\\n\\n        locals.valuation = IHomeCollection(locals._collection).nftValuation();\\n        locals.price = IHomeCollection(locals._collection).getPrice();\\n        locals.avaibleLoan;\\n        if (locals.price >= locals.valuation) {\\n            locals.avaibleLoan = _getPortion(locals.valuation, maxLoan);\\n        } else {\\n            locals.avaibleLoan = _getPortion(locals.price, maxLoan);\\n        }\\n        if (locals3._loan > locals.avaibleLoan) {\\n            revert(\\\"exceed your maximum loan\\\");\\n        }\\n        locals2.minLoan = _getPortion(locals.valuation, minLoan);\\n        if (locals3._loan < locals2.minLoan) {\\n            revert(\\\"Less than allowed\\\");\\n        }\\n        locals.downPay = locals.price - locals3._loan;\\n\\n        id = ++mortgageId;\\n        locals.wrapContract = wrapData[locals._collection];\\n\\n        locals.fee = _getPortion(locals3._loan, creditFee); //mortgage fee calculation\\n\\n        (locals.pan, locals.lenders) = calcFees(locals.fee);\\n\\n        locals2.debt = locals3._loan + locals.fee;\\n\\n        //Distribution fees\\n        feesVault.withdraw(locals.lenders);\\n        IVaultRewards(vaults.rewardsLenders).deposit(locals.lenders, token);\\n        IERC20(token).safeTransfer(walletPanoram, locals.pan); //transfer percentage fee\\n\\n        updateLending(position.owner, position.idPosition, locals2.debt); //change to panoram position lending\\n\\n        //Create and wrap NFT\\n        locals2.tokenId = INFTMarket(market).mintingMortgage(locals._collection, address(this), _user, locals.price);\\n        locals2.uri = IHomeCollection(locals._collection).tokenURI(locals2.tokenId);\\n        IwrapNFT(locals.wrapContract).wrapNFT(_user, locals2.tokenId, locals2.uri);\\n        IHomeCollection(locals._collection).transferFrom(address(this), locals.wrapContract, locals2.tokenId);\\n\\n        //Register information\\n        IMortgageControl(mortgageControl).addMortgageId(locals._collection, locals2.tokenId, id);\\n        IMortgageControl(mortgageControl).addRegistry(\\n            id,\\n            _user,\\n            locals._collection,\\n            locals.wrapContract,\\n            locals2.tokenId,\\n            locals2.debt,\\n            locals.downPay,\\n            locals.price,\\n            block.timestamp,\\n            locals3._period\\n        );\\n        IMortgageControl(mortgageControl).addIdInfo(id, _user);\\n        IMortgageControl(mortgageControl).updateLastTimeCalc(_user, id, block.timestamp);\\n\\n        emit mortgageEvent(id, _user, locals._collection, locals.wrapContract, locals2.tokenId, locals3._loan, 2);\\n    }\\n\\n    function _openMortgage(\\n        address collection,\\n        uint256 loan,\\n        uint256 period,\\n        address token,\\n        address lenders,\\n        address lenRewards\\n    ) private returns (uint256 id) {\\n        LocalMortgage memory locals;\\n        LocalMortgage2 memory locals2;\\n        LocalMortgage3 memory locals3;\\n        LocalVaults memory vaults;\\n\\n        vaults.vaultLenders = lenders;\\n        vaults.rewardsLenders = lenRewards;\\n        locals3._loan = loan;\\n        locals3._period = period;\\n\\n        locals._collection = collection;\\n        if (locals._collection == address(0)) {\\n            revert(\\\"is address 0\\\");\\n        }\\n\\n        if (period > maxperiod) {\\n            revert(\\\"exceed maximum period\\\");\\n        }\\n\\n        locals.valuation = IHomeCollection(locals._collection).nftValuation();\\n        locals.price = IHomeCollection(locals._collection).getPrice();\\n        locals.avaibleLoan;\\n        if (locals.price >= locals.valuation) {\\n            locals.avaibleLoan = _getPortion(locals.valuation, maxLoan);\\n        } else {\\n            locals.avaibleLoan = _getPortion(locals.price, maxLoan);\\n        }\\n        if (locals3._loan > locals.avaibleLoan) {\\n            revert(\\\"exceed your maximum loan\\\");\\n        }\\n        locals2.minLoan = _getPortion(locals.valuation, minLoan);\\n        if (locals3._loan < locals2.minLoan) {\\n            revert(\\\"Less than allowed\\\");\\n        }\\n        locals.downPay = locals.price - locals3._loan;\\n\\n        id = ++mortgageId;\\n        locals.wrapContract = wrapData[locals._collection];\\n\\n        locals.fee = _getPortion(loan, creditFee); //mortgage fee calculation\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), locals.downPay); //transfer downpayment\\n\\n        //Distribution fees\\n        locals2.debt = locals3._loan + locals.fee;\\n        IVaultLenders(vaults.vaultLenders).withdraw(locals2.debt, token);\\n\\n        (locals.pan, locals.lenders) = calcFees(locals.fee);\\n\\n        IVaultRewards(vaults.rewardsLenders).deposit(locals.lenders, token);\\n        IERC20(token).safeTransfer(walletPanoram, locals.pan); //transfer percentage fee\\n\\n        address _propertyWallet = properties[collection];\\n        IERC20(token).safeTransfer(_propertyWallet, locals.price); //transfer NFT cost\\n\\n        //Create and wrap NFT\\n        locals2.tokenId =\\n            INFTMarket(market).mintingMortgage(locals._collection, address(this), msg.sender, locals.price);\\n        locals2.uri = IHomeCollection(locals._collection).tokenURI(locals2.tokenId);\\n        IwrapNFT(locals.wrapContract).wrapNFT(msg.sender, locals2.tokenId, locals2.uri);\\n        IHomeCollection(locals._collection).transferFrom(address(this), locals.wrapContract, locals2.tokenId);\\n\\n        //Register information\\n        IMortgageControl(mortgageControl).addMortgageId(locals._collection, locals2.tokenId, id);\\n        IMortgageControl(mortgageControl).addRegistry(\\n            id,\\n            msg.sender,\\n            locals._collection,\\n            locals.wrapContract,\\n            locals2.tokenId,\\n            locals2.debt,\\n            locals.downPay,\\n            locals.price,\\n            block.timestamp,\\n            locals3._period\\n        );\\n        IMortgageControl(mortgageControl).addIdInfo(id, msg.sender);\\n        IMortgageControl(mortgageControl).updateLastTimeCalc(msg.sender, id, block.timestamp);\\n\\n        emit mortgageEvent(id, msg.sender, locals._collection, locals.wrapContract, locals2.tokenId, locals2.debt, 1);\\n    }\\n\\n    function _openCredit(address collection, uint256 loan, uint256 period, address token, address lenRewards)\\n        private\\n        returns (uint256 id)\\n    {\\n        LocalMortgage memory locals;\\n        LocalMortgage2 memory locals2;\\n        LocalMortgage3 memory locals3;\\n        LocalVaults memory vaults;\\n\\n        vaults.rewardsLenders = lenRewards;\\n        locals3._loan = loan;\\n        locals3._period = period;\\n\\n        locals._collection = collection;\\n        if (locals._collection == address(0)) {\\n            revert(\\\"is address 0\\\");\\n        }\\n\\n        if (period > maxperiod) {\\n            revert(\\\"exceed maximum period\\\");\\n        }\\n\\n        locals.valuation = IHomeCollection(locals._collection).nftValuation();\\n        locals.price = IHomeCollection(locals._collection).getPrice();\\n        locals.avaibleLoan;\\n        if (locals.price >= locals.valuation) {\\n            locals.avaibleLoan = _getPortion(locals.valuation, maxLoan);\\n        } else {\\n            locals.avaibleLoan = _getPortion(locals.price, maxLoan);\\n        }\\n        if (locals3._loan > locals.avaibleLoan) {\\n            revert(\\\"exceed your maximum loan\\\");\\n        }\\n\\n        locals2.minLoan = _getPortion(locals.valuation, minLoan);\\n\\n        if (locals3._loan < locals2.minLoan) {\\n            revert(\\\"Less than allowed\\\");\\n        }\\n        locals.downPay = locals.price - locals3._loan;\\n\\n        id = ++mortgageId;\\n        locals.wrapContract = wrapData[locals._collection];\\n\\n        locals.fee = _getPortion(loan, creditFee); //mortgage fee calculation\\n\\n        locals2.debt = locals3._loan + locals.fee;\\n\\n        (locals.pan, locals.lenders) = calcFees(locals.fee);\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), locals.downPay); //transfer downpayment + fees\\n\\n        //Distribution fees\\n        feesVault.withdraw(locals.fee);\\n\\n        IVaultRewards(vaults.rewardsLenders).deposit(locals.lenders, token);\\n        IERC20(token).safeTransfer(walletPanoram, locals.pan); //transfer percentage fee\\n\\n        updateLending(position.owner, position.idPosition, locals2.debt); //change to panoram position lending\\n\\n        address _propertyWallet = properties[collection];\\n        IERC20(token).safeTransfer(_propertyWallet, locals.downPay);\\n\\n        //Create and wrap NFT\\n        locals2.tokenId =\\n            INFTMarket(market).mintingMortgage(locals._collection, address(this), msg.sender, locals.price);\\n        locals2.uri = IHomeCollection(locals._collection).tokenURI(locals2.tokenId);\\n        IwrapNFT(locals.wrapContract).wrapNFT(msg.sender, locals2.tokenId, locals2.uri);\\n        IHomeCollection(locals._collection).transferFrom(address(this), locals.wrapContract, locals2.tokenId);\\n\\n        //Register information\\n        IMortgageControl(mortgageControl).addMortgageId(locals._collection, locals2.tokenId, id);\\n        IMortgageControl(mortgageControl).addRegistry(\\n            id,\\n            msg.sender,\\n            locals._collection,\\n            locals.wrapContract,\\n            locals2.tokenId,\\n            locals2.debt,\\n            locals.downPay,\\n            locals.price,\\n            block.timestamp,\\n            locals3._period\\n        );\\n        IMortgageControl(mortgageControl).addIdInfo(id, msg.sender);\\n        IMortgageControl(mortgageControl).updateLastTimeCalc(msg.sender, id, block.timestamp);\\n\\n        emit mortgageEvent(id, msg.sender, locals._collection, locals.wrapContract, locals2.tokenId, locals3._loan, 2);\\n    }\\n\\n    function updateLending(address _wallet, uint256 id, uint256 _amount) private {\\n        (uint256 amountNow,,,,,) = lControl.getLenderInfo(_wallet, id);\\n        uint256 totalAmount = amountNow + _amount;\\n        lControl.UpdateInteresAccumulated(_wallet, id); //update rewards before update deposit\\n        uint256 payPersecond = calc.calcInterestForSecond(totalAmount, lControl.interesLenders());\\n        //uint256 payPersecond = calcInterestForSecond(totalAmount, lControl.interesLenders());\\n        lControl.updateRegistry(id, _wallet, _amount, payPersecond);\\n    }\\n\\n    /// @param amount The number of mortgages to be applied for\\n    /// @param loan Array with the amount of each loan requested\\n    /// @param period Array with duration of each loan requested.\\n    /// @custom:audit que pasa si envian una address rara o que no es una coleccion\\n    function batchMortgage(\\n        address collection,\\n        uint256 amount,\\n        uint256[] calldata loan,\\n        uint256[] calldata period,\\n        address token,\\n        uint256 totalLoans\\n    ) public validToken(token) NotPaused {\\n        (address lenders,,) = tokenInfo.getVaultInfo(token);\\n        if (IVaultLenders(lenders).getAvaible() >= totalLoans) {\\n            _batchmortgage(collection, amount, loan, period, token);\\n        } else {\\n            _batchMortgageCredit(collection, amount, loan, period, token);\\n        }\\n    }\\n\\n    function _batchmortgage(\\n        address collection,\\n        uint256 amount,\\n        uint256[] calldata loan,\\n        uint256[] calldata period,\\n        address token\\n    ) private {\\n        LocalMortgage memory locals;\\n        LocalMortgage2 memory locals2;\\n        LocalMortgage3 memory locals3;\\n\\n        locals3.length1 = loan.length;\\n        locals3.length2 = period.length;\\n        if (amount != locals3.length1 || amount != locals3.length2) {\\n            revert(\\\"Arrays mismatch\\\");\\n        }\\n\\n        for (uint256 i = 0; i < amount;) {\\n            locals3._loan = loan[i];\\n            locals3._period = period[i];\\n\\n            locals._collection = collection;\\n            if (locals._collection == address(0)) {\\n                revert(\\\"is address 0\\\");\\n            }\\n\\n            if (locals3._period > maxperiod) {\\n                revert(\\\"exceed maximum period\\\");\\n            }\\n\\n            locals.valuation = IHomeCollection(locals._collection).nftValuation();\\n            locals.price = IHomeCollection(locals._collection).getPrice();\\n            //locals.avaibleLoan;\\n            if (locals.price >= locals.valuation) {\\n                locals.avaibleLoan = _getPortion(locals.valuation, maxLoan);\\n            } else {\\n                locals.avaibleLoan = _getPortion(locals.price, maxLoan);\\n            }\\n            if (locals3._loan > locals.avaibleLoan) {\\n                revert(\\\"exceed your maximum loan\\\");\\n            }\\n            locals2.minLoan = _getPortion(locals.valuation, minLoan);\\n            if (locals3._loan < locals2.minLoan) {\\n                revert(\\\"Less than allowed\\\");\\n            }\\n            locals.downPay = locals.price - locals3._loan;\\n\\n            uint256 id = ++mortgageId;\\n            locals.wrapContract = wrapData[locals._collection];\\n\\n            locals2.debt = calcsDeposits(locals._collection, loan[i], locals.downPay, locals.price, token);\\n\\n            //Create and wrap NFT\\n            locals2.tokenId =\\n                INFTMarket(market).mintingMortgage(locals._collection, address(this), msg.sender, locals.price);\\n            locals2.uri = IHomeCollection(locals._collection).tokenURI(locals2.tokenId);\\n            IwrapNFT(locals.wrapContract).wrapNFT(msg.sender, locals2.tokenId, locals2.uri);\\n            IHomeCollection(locals._collection).transferFrom(address(this), locals.wrapContract, locals2.tokenId);\\n            //Register information\\n            IMortgageControl(mortgageControl).addMortgageId(locals._collection, locals2.tokenId, id);\\n            IMortgageControl(mortgageControl).addRegistry(\\n                id,\\n                msg.sender,\\n                locals._collection,\\n                locals.wrapContract,\\n                locals2.tokenId,\\n                locals2.debt,\\n                locals.downPay,\\n                locals.price,\\n                block.timestamp,\\n                locals3._period\\n            );\\n            IMortgageControl(mortgageControl).addIdInfo(id, msg.sender);\\n            IMortgageControl(mortgageControl).updateLastTimeCalc(msg.sender, id, block.timestamp);\\n\\n            emit mortgageEvent(\\n                id, msg.sender, locals._collection, locals.wrapContract, locals2.tokenId, locals2.debt, 1\\n            );\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function _batchMortgageCredit(\\n        address collection,\\n        uint256 amount,\\n        uint256[] calldata loan,\\n        uint256[] calldata period,\\n        address token\\n    ) private {\\n        LocalMortgage memory locals;\\n        LocalMortgage2 memory locals2;\\n        LocalMortgage3 memory locals3;\\n\\n        locals3.length1 = loan.length;\\n        locals3.length2 = period.length;\\n        if (amount != locals3.length1 || amount != locals3.length2) {\\n            revert(\\\"Arrays mismatch\\\");\\n        }\\n\\n        for (uint256 i = 0; i < amount;) {\\n            locals3._loan = loan[i];\\n            locals3._period = period[i];\\n\\n            locals._collection = collection;\\n            if (locals._collection == address(0)) {\\n                revert(\\\"is address 0\\\");\\n            }\\n\\n            if (locals3._period > maxperiod) {\\n                revert(\\\"exceed maximum period\\\");\\n            }\\n\\n            locals.valuation = IHomeCollection(locals._collection).nftValuation();\\n            locals.price = IHomeCollection(locals._collection).getPrice();\\n            //locals.avaibleLoan;\\n            if (locals.price >= locals.valuation) {\\n                locals.avaibleLoan = _getPortion(locals.valuation, maxLoan);\\n            } else {\\n                locals.avaibleLoan = _getPortion(locals.price, maxLoan);\\n            }\\n            if (locals3._loan > locals.avaibleLoan) {\\n                revert(\\\"exceed your maximum loan\\\");\\n            }\\n            locals2.minLoan = _getPortion(locals.valuation, minLoan);\\n            if (locals3._loan < locals2.minLoan) {\\n                revert(\\\"Less than allowed\\\");\\n            }\\n            locals.downPay = locals.price - locals3._loan;\\n\\n            uint256 id = ++mortgageId;\\n            locals.wrapContract = wrapData[locals._collection];\\n\\n            locals2.debt = calcsDepositsCredit(locals._collection, loan[i], token, locals.downPay);\\n\\n            //Create and wrap NFT\\n            locals2.tokenId =\\n                INFTMarket(market).mintingMortgage(locals._collection, address(this), msg.sender, locals.price);\\n            locals2.uri = IHomeCollection(locals._collection).tokenURI(locals2.tokenId);\\n            IwrapNFT(locals.wrapContract).wrapNFT(msg.sender, locals2.tokenId, locals2.uri);\\n            IHomeCollection(locals._collection).transferFrom(address(this), locals.wrapContract, locals2.tokenId);\\n            //Register information\\n            IMortgageControl(mortgageControl).addMortgageId(locals._collection, locals2.tokenId, id);\\n            IMortgageControl(mortgageControl).addRegistry(\\n                id,\\n                msg.sender,\\n                locals._collection,\\n                locals.wrapContract,\\n                locals2.tokenId,\\n                locals2.debt,\\n                locals.downPay,\\n                locals.price,\\n                block.timestamp,\\n                locals3._period\\n            );\\n            IMortgageControl(mortgageControl).addIdInfo(id, msg.sender);\\n            IMortgageControl(mortgageControl).updateLastTimeCalc(msg.sender, id, block.timestamp);\\n\\n            emit mortgageEvent(\\n                id, msg.sender, locals._collection, locals.wrapContract, locals2.tokenId, locals3._loan, 2\\n            );\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function calcsDeposits(address collection, uint256 loan, uint256 downPay, uint256 _price, address token)\\n        private\\n        returns (uint256 debt)\\n    {\\n        LocalMortgage memory locals;\\n        LocalVaults memory vaults;\\n        uint256 fee = _getPortion(loan, creditFee); //mortgage fee calculation\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), downPay); //transfer downpayment\\n\\n        (vaults.vaultLenders, vaults.rewardsLenders,) = tokenInfo.getVaultInfo(token);\\n\\n        //Distribution fees\\n        debt = loan + fee;\\n        IVaultLenders(vaults.vaultLenders).withdraw(debt, token);\\n\\n        (locals.pan, locals.lenders) = calcFees(fee);\\n        address _propertyWallet = properties[collection];\\n\\n        IVaultRewards(vaults.rewardsLenders).deposit(locals.lenders, token);\\n\\n        IERC20(token).safeTransfer(walletPanoram, locals.pan); //transfer percentage fee and NFT cost\\n        IERC20(token).safeTransfer(_propertyWallet, _price);\\n    }\\n\\n    function calcsDepositsCredit(address collection, uint256 loan, address token, uint256 downPay)\\n        private\\n        returns (uint256 debt)\\n    {\\n        LocalMortgage memory locals;\\n        LocalVaults memory vaults;\\n        uint256 fee = _getPortion(loan, creditFee); //mortgage fee calculation\\n\\n        (locals.pan, locals.lenders) = calcFees(locals.fee);\\n\\n        debt = loan + fee;\\n\\n        IERC20(token).safeTransferFrom(msg.sender, address(this), downPay); //transfer downpayment + fee\\n\\n        (, vaults.rewardsLenders,) = tokenInfo.getVaultInfo(token);\\n\\n        //Distribution fees\\n        feesVault.withdraw(locals.fee);\\n\\n        IVaultRewards(vaults.rewardsLenders).deposit(locals.lenders, token);\\n        updateLending(position.owner, position.idPosition, debt); //change to panoram position lending\\n\\n        IERC20(token).safeTransfer(walletPanoram, locals.pan); //transfer percentage fee and NFT cost\\n        address _propertyWallet = properties[collection];\\n        IERC20(token).safeTransfer(_propertyWallet, downPay);\\n    }\\n\\n    function mortgagePaid(uint256 idMortgage, address collection, address user, uint256 tokenId) public NotPaused {\\n        LocalMortgage memory locals;\\n        LocalMortgage2 memory locals2;\\n        locals._collection = collection;\\n        locals2.tokenId = tokenId;\\n        if (locals._collection == address(0)) {\\n            revert(\\\"is address 0\\\");\\n        }\\n        locals.wrapContract = wrapData[locals._collection];\\n        locals2.owner = IwrapNFT(locals.wrapContract).ownerOf(locals2.tokenId);\\n        if (locals2.owner != msg.sender) {\\n            revert(\\\"not the owner\\\");\\n        }\\n        locals2.isPay = IMortgageControl(mortgageControl).mortgageStatuts(user, idMortgage);\\n        if (!locals2.isPay) {\\n            revert(\\\"active mortgage\\\");\\n        }\\n        //burn wrapNFT and transfer the original NFT\\n        IwrapNFT(locals.wrapContract).unWrap(user, locals2.tokenId);\\n\\n        IMortgageControl(mortgageControl).eraseMortgageId(collection, tokenId);\\n\\n        emit releaseEvent(idMortgage, user, locals._collection, locals2.tokenId, \\\"released\\\");\\n    }\\n\\n    function seizeNFT(uint256 idMortgage, address collection, address user, uint256 tokenId)\\n        public\\n        NotPaused\\n        onlyRelayer\\n    {\\n        if (collection == address(0)) {\\n            revert(\\\"is address 0\\\");\\n        }\\n        bool liquidate = IMortgageControl(mortgageControl).getMortgageLiquidationStatus(user, idMortgage);\\n\\n        if (!liquidate) {\\n            revert(\\\"up to date\\\");\\n        }\\n        address _wrapContract = wrapData[collection];\\n        IwrapNFT(_wrapContract).unWrap(guardian, tokenId);\\n\\n        IControl(control).addQuantity(guardian, collection, 1);\\n        IControl(control).removeQuantity(user, collection, 1);\\n\\n        emit seized(idMortgage, user, collection, tokenId, \\\"seized\\\");\\n    }\\n\\n    function _getPortion(uint256 _valuation, uint256 _percentage) internal pure returns (uint256) {\\n        return (_valuation * (_percentage)) / 10000;\\n    }\\n\\n    function calcFees(uint256 _fee) internal view returns (uint256 panoram, uint256 lenders) {\\n        panoram = _getPortion(_fee, feePanoram);\\n        lenders = _getPortion(_fee, feeLenders);\\n        return (panoram, lenders);\\n    }\\n\\n    function addWrapData(address collection, address wrap) public onlydev {\\n        wrapData[collection] = wrap;\\n    }\\n\\n    function updateMaxPeriod(uint256 _maxPeriod) public onlydev {\\n        maxperiod = _maxPeriod;\\n    }\\n\\n    function updateRelayer(address _relay) public onlydev {\\n        guardian = _relay;\\n    }\\n\\n    function updateControl(address _newControl) public onlydev {\\n        mortgageControl = _newControl;\\n    }\\n\\n    function updateMarket(address _newMarket) public onlydev {\\n        market = _newMarket;\\n    }\\n\\n    function updateTokenInfo(address _tokenInfo) public onlydev {\\n        tokenInfo = TokenInfo(_tokenInfo);\\n    }\\n\\n    function updateMaxLoan(uint64 _maxLoan) public onlydev {\\n        maxLoan = _maxLoan;\\n    }\\n\\n    function updateMinLoan(uint64 _minLoan) public onlydev {\\n        minLoan = _minLoan;\\n    }\\n\\n    function updateFeePanoram(uint256 _newfeePanoram) public onlydev {\\n        feePanoram = _newfeePanoram;\\n    }\\n\\n    function updateFeeLenders(uint256 _newfeeLenders) public onlydev {\\n        feeLenders = _newfeeLenders;\\n    }\\n\\n    function updateWalletPanoram(address _newWalletPanoram) public onlydev {\\n        walletPanoram = _newWalletPanoram;\\n    }\\n\\n    function updateMortgageID(uint256 _mortgageId) public onlydev {\\n        mortgageId = _mortgageId;\\n    }\\n\\n    function pausedContract(bool _status) public onlydev {\\n        paused = _status;\\n    }\\n\\n    function getPropertyWallet(address _property) public view returns (address) {\\n        return properties[_property];\\n    }\\n\\n    function setPropertyWallet(address _property, address _wallet) public onlydev {\\n        properties[_property] = _wallet;\\n    }\\n\\n    function updateManual(address _newUser, bool _condition) public onlydev {\\n        manual[_newUser] = _condition;\\n    }\\n\\n    function getPosition() public view returns (address, uint256) {\\n        return (position.owner, position.idPosition);\\n    }\\n\\n    function setPosition(address _owner, uint256 _idPosition) public onlydev {\\n        position.owner = _owner;\\n        position.idPosition = _idPosition;\\n    }\\n\\n    function permissions(address _token, address _lender, address _lendersrewards) public onlydev validToken(_token) {\\n        IERC20(_token).approve(_lender, MAX_UINT);\\n        IERC20(_token).approve(_lendersrewards, MAX_UINT);\\n    }\\n\\n    function approveToken(address _token) public onlydev {\\n        IERC20(_token).approve(market, MAX_UINT); //approve BUSD Testnet\\n    }\\n\\n    // Llamar a esta funcion en cuanto se tenga desplegado el contrato de calcs\\n    /// @dev Function to set the Calcs contract address.\\n    /// @param _calcs - the calcs contract address.\\n    function updateCalcs(address _calcs) public onlydev {\\n        if (_calcs == address(0)) {\\n            revert(\\\"Address 0 not allowed\\\");\\n        }\\n        calc = ICals(_calcs);\\n    }\\n\\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Credits/IMortgageControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"./IMortgageInterest.sol\\\";\\n\\ninterface IMortgageControl is IMortgageInterest {\\n\\n    function addIdInfo(uint256 id, address wallet) external;\\n\\n    function updateCapitalPay(uint256 id, address wallet, uint256 _newDebt) external; \\n\\n    function getTotalMortgages() external view returns (uint256);\\n\\n    function getCapitalPay(address _user, uint256 _mortgageId) external view returns(uint256 _capitalPay);\\n\\n    function getDebtInfo(address _user, uint256 _mortgageId) external view returns(uint256,uint256,uint256);\\n\\n    function mortgageStatuts(address _user, uint256 _mortgageId) external view returns (bool _isPay);\\n\\n    function getMortgageLiquidationStatus(address _user, uint256 _mortgageId) external view returns(bool _status);\\n\\n    function mortgageLink(address _user, uint256 _mortgageId) external view returns (bool _mortgageAgain, uint256 _linkId);\\n\\n    function getMortgagesForWallet(address _wallet, address _collection)\\n        external\\n        view\\n        returns (uint256[] memory _idMortgagesForCollection);\\n\\n    function getuserToMortgageInterest(address _wallet, uint256 _IdMortgage)\\n        external\\n        view\\n        returns (MortgageInterest memory);\\n\\n    // Get FrontEnd Data\\n    function getFrontMortgageData(address _wallet, uint256 _IdMortage)\\n        external\\n        view\\n        returns (\\n            uint256 totalDebt,\\n            uint256 totalMonthlyPay,\\n            uint256 totalDelayedMonthlyPay,\\n            uint256 totalToPayOnLiquidation,\\n            uint256 lastTimePayment,\\n            bool isMonthlyPaymentPayed,\\n            bool isMonthlyPaymentDelayed,\\n            bool liquidate\\n        );\\n\\n    function getIdInfo(uint256 id) external view returns (address _user);\\n\\n    function getInterestRate() external view returns(uint64 _interest);\\n\\n    function getMortgageId(address _collection, uint256 _nftId) external view returns(uint256 _mortgageId);\\n\\n    function getStartDate(address _wallet, uint256 _mortgageID) external view returns(uint256);\\n\\n    function getUserInfo(address _user, uint256 _mortgageId)external view returns(address,uint256,address,uint256,uint256,uint256,uint256,uint256,uint256,bool,bool,uint256);\\n\\n    function getMortgageStatus(address _user, uint256 _mortgageId) external view returns(bool _status);\\n\\n    function addMortgageId(address _collection, uint256 _nftId, uint256 _loanId) external;\\n\\n    function eraseMortgageId(address _collection, uint256 _nftId) external;\\n\\n    function addRegistry(uint256 id, address wallet, address _collection, address _wrapContract,uint256 _nftId, uint256 _loan,uint256 _downPay,\\n    uint256 _price,uint256 _startDate,uint256 _period ) external; \\n\\n    function updateMortgageLink(\\n        uint256 oldId,\\n        uint256 newId,\\n        address wallet,\\n        uint256 _loan,\\n        uint256 _downPay,\\n        uint256 _startDate,\\n        uint256 _period,\\n        bool _mortageState\\n    ) external;\\n\\n    function updateMortgageState(\\n        uint256 id,\\n        address wallet,\\n        bool _state\\n    ) external;\\n\\n    function updateMortgagePayment(uint256 id, address wallet) external;\\n\\n    function addNormalMorgateInterestData(\\n        address _wallet,\\n        uint256 _idMortgage,\\n        MortgageInterest memory _mortgage\\n    ) external;\\n\\n    function resetMortgageInterest(address _wallet, uint256 _idMortgage) external;\\n    \\n    function resetDebt(address _wallet, uint256 _idMortgage) external;\\n    \\n    function updateLastTimeCalc(address _wallet, uint256 _idMortgage,uint256 _lastTimeCalc) external;\\n    \\n    function addDelayedMorgateInterestData(\\n        address _wallet,\\n        uint256 _idMortgage,\\n        MortgageInterest memory _mortgage\\n    ) external;\\n\\n    function updateOnPayMortgageInterest(\\n        address _wallet,\\n        uint256 _idMortgage,\\n        MortgageInterest memory mort\\n    ) external;\\n\\n    function updateTotalDebtOnAdvancePayment(\\n        address _wallet,\\n        uint256 _idMortgage,\\n        uint256 _totalDebt\\n    ) external;\\n\\n    function updateLastTimePayment(address _wallet, uint256 _idMortgage,uint256 _lastPayment) external;\\n    \\n    function getLastTimePayment(address _wallet, uint256 _idMortgage) external view returns(uint256);\\n\\n    function migrateMortgateInterest(address _wallet, uint256 _IdMortgage, MortgageInterest calldata mort) external;\\n\\n    function migrateMortgateDebt(address _wallet, uint256 _IdMortgage, Information calldata _debt) external;\\n\\n}\"\r\n    },\r\n    \"contracts/NFT/IwrapNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/IERC165.sol\\\";\\n\\ninterface IwrapNFT is IERC165 {\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function safeTransferFrom(address from, address to,uint256 tokenId,bytes calldata data ) external;\\n\\n    function safeTransferFrom(address from,address to,uint256 tokenId) external;\\n\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n \\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    function holdInfo(uint256 tokenId) external view returns (uint32);\\n\\n    function mintInfo(address _owner) external view  returns (uint32);\\n\\n    function wrapNFT(address _wallet, uint256 _Id, string memory _tokenURI) external;\\n\\n    function unWrap(address _wallet, uint256 _Id) external;\\n    \\n    function getDate(uint256 _tokenId) external view returns (uint256 _date);\\n\\n    function setDate(uint256 _tokenId) external;\\n}\"\r\n    },\r\n    \"contracts/Lending/ILendingControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\nimport \\\"./ILending.sol\\\";\\n\\n/// @title Lending Control Interface.\\n/// @author Panoram Finance.\\n/// @notice You can use this interface to connect to the Lending Control contract.\\ninterface ILendingControl is ILending {\\n\\n    /// @dev Function to register a new user and his deposit in Lending/Earn.\\n    function addRegistry(uint256 id, address wallet, uint256 _amount,address _token, uint256 _payPerSecond) external;\\n\\n    /// @dev Function to update a user deposit in Lending/Earn.\\n    function updateRegistry(uint256 id, address wallet, uint256 _amount, uint256 _payPerSecond) external;\\n    \\n    /// @dev Function to rest the amount from the amount register for the user after He set a withdrawal request.\\n    function claimMoney(uint256 id, address wallet, uint256 _amount) external;\\n\\n    /// @dev Function to sum the amount to the amount register for the user if He cancel the withdraw.\\n    function updateMoney(uint256 id, address wallet, uint256 _amount) external;\\n\\n    /// @dev Function to get the information registered for an user in Lending/Earn.\\n    function getLenderInfo(address wallet, uint256 id) external view returns (uint256 _amount, uint256 _deposit, address _token, uint96 _lastCalcTime, uint256 _payPerSecond, uint96 _withdraw);\\n\\n    /// @dev Function to associate and address to a Lending ID.\\n    function addInfo(uint256 id, address wallet) external;\\n\\n    /// @dev Function to delete the register of an address => Lending ID.\\n    function deleteInfo(address wallet) external;\\n\\n    /// @dev Function to get the Lending ID of an Address.\\n    function getIdInfo(address wallet) external view returns(uint256 _id);\\n\\n    /// @dev Function to get the interest/rewards information from the user.\\n    function getRewardsClaimed(address wallet, uint256 id) external view returns (uint256 rewards, uint96 claimTime, uint96 lastTimeClaim);\\n\\n    /// @dev Function to update the interest claimed and the last time the user claims it.\\n    function updateClaimed(uint256 id, address wallet, uint256 _rewards, uint256 _claimTime) external;\\n\\n    /// @dev Function to create a request to withdraw your investment in Lending or your interest earn.\\n    function createRequest(address _wallet, uint256 _amount, uint256 _rewards, uint8 _flag) external returns(uint256);\\n\\n    /// @dev Function to close a withdrawal request.\\n    function closeRequest(address _wallet, uint256 _id, Status _state, uint256 _idLending) external;\\n\\n    /// @dev Function to get the information registered in a withdrawal request.\\n    function getRequest(address _wallet, uint256 _id) external view returns(uint256 _amount,uint256 _rewards, Status _state, uint96 _date);\\n\\n    /// @dev Function to check if a Lending ID is associated with an address wallet.\\n    function validateId(address wallet, uint256 _id) external view returns (bool _valid);\\n\\n    /// @dev Function to get the interest paid to lenders.\\n    function interesLenders() external view returns(uint16);\\n\\n    /// @dev Function to update the amount to pay per second to a lender.\\n    function updatePayPerSecond(address _wallet, uint256 _idLending ,uint256 _newPayPerSecond) external;\\n\\n    /// @dev Function that returns the remaining days to avoid penalties for withdrawals of money deposited in lending.\\n    function getDaysLeft(address _wallet,uint256 _idLending) external view returns(uint32 daysLeft);\\n\\n    /// @dev Function to update the pending days to avoid penalties for withdrawals of money deposited in lending.\\n    function updateDaysLeft(address _wallet, uint256 _idLending, uint32 _daysLeft) external;\\n\\n    /// @dev Function to update the key information in \\\"Data\\\" struct from lending control after the user reinvest the interest generated.\\n    function updateOnReinvestmentRewards(address _wallet, uint256 _idLending, uint256 _amount, uint256 _claimed, uint256 _lastCalcTime) external;\\n\\n    /// @dev Function to update the days Left to avoid penalizations for lending withdrawals.\\n    function updatePenalization(uint256 id, address wallet) external;\\n\\n    /// @dev Function to get the variable \\\"daysBeforePenalization\\\" from LendingControl, that saves the days that a user must wait before making a withdrawal to avoid being penalized.\\n    function getDaysBeforePenalization() external view returns(uint32 _days);\\n\\n    /// @dev Function to update the last time the interest to be paid to the user was calculated.\\n    function updateLastTimeClaim(address wallet, uint256 idLending, uint256 _timeClaim) external;\\n\\n    /// @dev Function to get the pending interests to be paid to the user.\\n    function getPendingRewards(address _wallet, uint256 _idLending) external view returns(uint256);\\n\\n    /// @dev Function to update the pending interest to pay for an user.\\n    function UpdateInteresAccumulated(address _wallet, uint _id) external;\\n\\n    /// @dev Function to clear the pending rewards after the user set a claim for that rewards/interests.\\n    function updatePendingRewards(address wallet, uint256 idLending, uint256 _timeClaim) external;\\n\\n    /// @dev Function to get the date of the last time a user set a request to withdraw the generated interests.\\n    function getLastSetClaimRewards(address _wallet,uint256 _idLending) external view returns(uint96 lastSetClaimRewards);\\n\\n    /// @dev Function to migrate the data for the USDT Migration.\\n    function updatePosition(address wallet, uint256 id, Data calldata info, address _token) external;\\n\\n    function updateRequest(address _wallet, uint256 _amount, uint256 _rewards, uint8 _flag, uint96 _date, uint96 _lastCalcTime) external;\\n}\"\r\n    },\r\n    \"contracts/Lending/IVaultLenders.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\n/// @title Vault Lenders Interface.\\n/// @author Panoram Finance.\\n/// @notice You can use this interface to connect to the Vault Lenders contract.\\ninterface IVaultLenders {\\n    /// @dev Function to deposit tokens in the vault.\\n    function deposit(uint256,address) external;\\n\\n    /// @dev Function to deposit Capital payments for loans.\\n    function depositCapital(uint256 _amount,  address _token, bool flag) external;\\n\\n    /// @dev Function to withdraw money when a loan is created\\n    function withdraw(uint256,address) external;\\n\\n    /// @dev Function for the multisign to withdraw all the money in the vault if necessary.\\n    function withdrawAll() external;\\n\\n    /// @dev Function to get the variable totalSupply, that represents the total tokens in the vault.\\n    function totalSupply() external view returns (uint256);\\n\\n    /// @dev Function to get the total borrowed money.\\n    function getBorrows() external view returns(uint256 _borrows);\\n\\n    /// @dev Function to get the available money for loans.\\n    function getAvaible() external view returns(uint256 _avaible);\\n\\n    /// @dev Function to add a withdrawal request for the money that the user deposited in lending. \\n    /// @dev They will be able to withdraw the money when the withdrawal waiting time is over.\\n    function addRequest(uint256 _amount) external;\\n\\n    /// @dev Function to delete a withdrawals request when the user cancel the request.\\n    function deleteRequest(uint256 _amount) external;\\n\\n    /// @dev Function to transfer money from the vault to the lending contract to fulfill a user's withdrawal request.\\n    function claimRequest(uint256 _amount) external;\\n\\n    /// @dev Function to get the amount of money requested for withdrawal.\\n    function getMoneyRequest() external view returns(uint256);\\n\\n    /// @dev Function to get the maximum amount that can be deposit into the vault.\\n    function getMaxDeposit() external view returns(uint256);\\n\\n    /// @dev Function to get the minimum amount that can be deposit into the vault.\\n    function getMinDeposit() external view returns(uint256);\\n\\n    /// @dev Function to get the percentage of the vault used in loans, based on scale of 10k.\\n    function usageRatio() external view returns(uint256 _usage);\\n}\\n\"\r\n    },\r\n    \"contracts/Control/IMarketContract.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface INFTMarket{\\n    \\n    function mintingMortgage(address _collection, address _owner, address _user,uint256 _value)  external returns(uint256 _nftId);\\n\\n    function mintingPresaleMortgage(address _collection, address _owner, address _user,uint256 _value)  external returns(uint256 _nftId);\\n\\n    function minting(address _collection, address _owner, uint256 _value, uint256 _fee, address _token) external;\\n\\n    function batchmint(address _collection, address _owner, uint256 _amount ,uint256 _value, uint256 _fee, address _token) external;\\n\\n    function presaleMint(address _collection, address _owner, uint256 _value, uint256 _fee, address _token) external;\\n\\n    function presaleMintbatch(address _collection, address _owner, uint256 _amount ,uint256 _value, uint256 _fee, address _token) external;\\n\\n    function purchase(uint256 _saleId, address _nftContractAddress, uint256 _tokenId,address _erc20Token,uint256 _tokenAmount,uint256 _feeAmount,address _newOwner) external;\\n\\n}\"\r\n    },\r\n    \"contracts/Control/IControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity 0.8.17;\\n\\ninterface IControl {\\n\\n   function getNFTInfo(address _collection, uint256 _id) external view returns ( address,uint256, address, uint32);\\n\\n    function getNFTMinted(address _wallet) external view returns (uint256 _minted);\\n\\n    function getNFTQuantity(address _wallet, address _collection)external view returns (uint256 _quantity);\\n\\n    function getNFTTotal(address _wallet) external view returns (uint256 _total);\\n\\n    function addRegistry(address _collection, uint256 _nftId, address _wallet,uint32 _timestamp) external;\\n\\n    function removeRegistry(address _collection, uint256 _nftId) external;\\n\\n    function addQuantity(address _wallet,address _collection,uint256 _amount) external;\\n\\n    function removeQuantity(address _wallet,address _collection, uint256 _amount) external;\\n\\n    function addMinted(address _wallet,uint256 _amount) external;\\n\\n    function addCounter() external;\\n\\n    function seeCounter() external view returns(uint256);\\n\\n}\"\r\n    },\r\n    \"contracts/Credits/IFeesVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IFeesVault {\\n\\n    function deposit(uint256 _amount) external;\\n    function withdraw(uint256 _amount) external; \\n}\"\r\n    },\r\n    \"contracts/Control/TokenInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\ncontract TokenInfo is AccessControl {\\n\\n    ///@dev developer role created\\n    bytes32 public constant DEV_ROLE = keccak256(\\\"DEV_ROLE\\\");\\n\\n    \\n    modifier onlydev() {\\n         if (!hasRole(DEV_ROLE, msg.sender)) {\\n            revert(\\\"have no dev role\\\");\\n        }\\n        _;\\n    }\\n\\n    constructor(){\\n        _setupRole(DEFAULT_ADMIN_ROLE, msg.sender);\\n        _setupRole(DEV_ROLE, msg.sender);\\n        _setupRole(DEFAULT_ADMIN_ROLE, 0x30268390218B20226FC101cD5651A51b12C07470);\\n        _setupRole(DEV_ROLE, 0x30268390218B20226FC101cD5651A51b12C07470);\\n        _setupRole(DEV_ROLE, 0x1921a154365A82b8d54a3Cb6e2Fd7488cD0FFd23); \\n    }\\n\\n    struct Vaults{\\n        address lender;\\n        address lenderRewards;\\n        address referals;\\n    }\\n    //registration and control of approved tokens\\n    mapping(address => bool) internal tokens;\\n    //save the token contract and the vault for it\\n    mapping(address => Vaults) internal vaultsInfo;\\n    //save the collection contract and the rental vault contract to be used for each collection\\n    mapping(address => address) internal collectionToVault;\\n\\n    function addToken(address _token) public onlydev {\\n        tokens[_token] = true;\\n    }\\n\\n    function removeToken(address _token) public onlydev {\\n        tokens[_token] = false;\\n    }\\n\\n    function getToken(address _token) public view returns(bool _ok){\\n        return tokens[_token];\\n    }\\n\\n    function addVaultRegistry(address _token, address _lender,address _lenderRewards,address _referals) public onlydev  {\\n        vaultsInfo[_token].lender = _lender;\\n        vaultsInfo[_token].lenderRewards = _lenderRewards;\\n        vaultsInfo[_token].referals = _referals;\\n    }\\n\\n    function removeVaultRegistry(address _token) public onlydev  {\\n        delete vaultsInfo[_token].lender;\\n        delete vaultsInfo[_token].lenderRewards;\\n        delete vaultsInfo[_token].referals;\\n    }\\n\\n    function getVaultInfo(address _token) public view returns(address _lender, address _lenderRewards,address referals){\\n        return ( vaultsInfo[_token].lender,\\n        vaultsInfo[_token].lenderRewards,\\n        vaultsInfo[_token].referals);\\n    }\\n\\n    function addVaultRent(address _collection, address _vault) public onlydev {\\n        collectionToVault[_collection] = _vault;\\n    }\\n\\n    function removeVaultRent(address _collection) public onlydev {\\n        collectionToVault[_collection] = address(0);\\n    }\\n\\n    function getVaultRent(address _collection) public view returns(address _vault){\\n        return collectionToVault[_collection];\\n    }\\n}\"\r\n    },\r\n    \"contracts/Credits/ICalcs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.11;\\n\\n/// @title Calcs Interface.\\n/// @author Panoram Finance.\\n/// @notice You can use this interface in other contracts to connect to the Calcs Contract.\\ninterface ICals {\\n\\n    /// @dev Function to calculate the user's interest accumulated in Lending.  \\n    function calcInterestAccumulated(address _wallet,uint256 _idLending) external view returns(uint256 interesToPay, uint256 timeOfCalc);\\n\\n    /// @dev Function to calculate the interest paid to the user every second.\\n    function calcInterestForSecond(uint256 _amountDeposit, uint16 _interes) external pure returns(uint256 payPerSecond);\\n}\"\r\n    },\r\n    \"contracts/Control/IVaultRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\n/// @title Vault Rewards Builder & Holders Interface.\\n/// @author Panoram Finance.\\n/// @notice Use this interface in other contracts to connect to the Vault Rewards Builder & Holders Contract.\\ninterface IVaultRewards {\\n\\n    /// @dev Function to deposit money in the vault.\\n    function deposit(uint256 _amount,  address _token) external;\\n\\n    /// @dev Function to withdraw money from the vault.\\n    function withdraw(uint256 amount, address _token) external;\\n\\n    /// @dev Function for the Multisig to withdraw all the money from the vault if necessary in an emergency.\\n    function withdrawAll() external;\\n\\n    /// @dev Function to read the amount of rewards to distribute each day.\\n    function seeDaily() external returns (uint256 tempRewards);\\n\\n    /// @dev Function to get the last time the seeDaily flag was calculated.\\n    function getLastCall() external view returns(uint256 _last);\\n\\n    /// @dev Function to get the available rewards in the vault to distribute.\\n    function getAvaibleRewards() external view returns(uint256 _avaible);\\n}\\n\"\r\n    },\r\n    \"contracts/NFT/IHomeCollection.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\r\\n\\r\\ninterface IHomeCollection is IERC721 {\\r\\n    \\r\\n    function redeem( address _redeem,uint256 _amount) external returns (uint256);\\r\\n\\r\\n    function preSale(address _redeem, uint256 _amount) external returns (uint256);\\r\\n\\r\\n    function safeTransferFrom(address from, address to,uint256 tokenId,bytes calldata data ) external;\\r\\n\\r\\n    function safeTransferFrom(address from,address to,uint256 tokenId) external;\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\r\\n\\r\\n    function tokenURI(uint256 tokenId) external view returns (string memory base);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function maxSupply() external view returns (uint256);\\r\\n     \\r\\n    function getPrice() external view returns (uint256);\\r\\n    \\r\\n    function getPresale() external view returns (uint256);\\r\\n\\r\\n    function getPresaleStatus() external view returns (bool);\\r\\n\\r\\n    function nftValuation() external view returns (uint256 _nftValuation);\\r\\n\\r\\n    function getValuation() external view returns (uint256 _valuation);\\r\\n\\r\\n    function setApprovalForAll(address operator, bool approved) external;\\r\\n\\r\\n    function getDate(uint256 _tokenId) external view returns (uint256 _date);\\r\\n\\r\\n    function setDate(uint256 _tokenId) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(account),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Credits/IMortgageInterest.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.17;\\n\\ninterface IMortgageInterest {\\n    \\n    struct MortgageInterest {\\n        uint256 totalDebt; // para guardar lo que adeuda el cliente despues de cada pago\\n        uint256 totalMonthlyPay; // total a pagar en pago puntual 100\\n        uint256 amountToPanoram; // cantidad que se ira a la wallet de Panoram\\n        uint256 amountToPool; // cantidad que se ira al Pool de rewards\\n        uint256 amountToVault; // cantidad que se regresa al vault de lenders\\n        uint256 totalDelayedMonthlyPay; // total a pagar en caso de ser pago moratorio, incluye pagar las cuotas atrasadas\\n        uint256 amountToPanoramDelayed; // cantidad que se ira a la wallet de Panoram\\n        uint256 amountToPoolDelayed; // cantidad que se ira al Pool de rewards\\n        uint256 totalToPayOnLiquidation; // sumar los 3 meses con los interes\\n        uint256 totalPoolLiquidation; // intereses al pool en liquidation\\n        uint256 totalPanoramLiquidation; // total a pagar de intereses a panoram en los 3 meses que no pago.\\n        uint256 lastTimePayment; // guardamos la fecha de su ultimo pago\\n        uint256 lastTimeCalc; // la ultima vez que se calculo sus interes: para evitar calcularle 2 veces el mismo dia\\n        uint8 strikes; // cuando sean 2 se pasa a liquidacion. Resetear estas variables cuando se haga el pago\\n        bool isMonthlyPaymentPayed; // validar si ya hizo el pago mensual\\n        bool isMonthlyPaymentDelayed; // validar si el pago es moratorio\\n        bool liquidate; // true si el credito se liquido, se liquida cuando el user tiene 3 meses sin pagar\\n    }\\n\\n    ///@notice structure and mapping that keeps track of mortgage\\n    struct Information {\\n        address collection;\\n        uint256 nftId;\\n        address wrapContract;\\n        uint256 loan; // total prestado\\n        uint256 downPay;\\n        uint256 capitalPay;\\n        uint256 price;\\n        uint256 startDate;\\n        uint256 period; //months\\n        uint256 payCounter; //Start in zero\\n        bool isPay; //default is false\\n        bool mortgageAgain; //default is false\\n        uint256 linkId; //link to the new mortgage\\n    }\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/Lending/ILending.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.11;\\n\\n/// @title Lending Interface.\\n/// @author Panoram Finance.\\n/// @notice You can import this interface to access the statuses of a lending withdraw.\\ninterface ILending {\\n\\n    /// @dev Enum to declare the Status of a lending / interest withdrawal\\n    enum Status{\\n        complete, //0\\n        pending, //1\\n        pendrewards,\\n        cancelled //2\\n    }\\n\\n     /// @dev Lending Struct.\\n    struct Data {\\n        uint256 amount; // amount deposited\\n        uint256 pendRewards; // pending Rewards for withdrawals.\\n        uint256 claimed; //Amount of rewards already redeemed\\n        uint256 payPerSecond; // how much the user earn per second.\\n        uint96 depositTime;\\n        uint96 lastCalcTime; // calculate the interest based on the date, starting from the date when it was last calculated.\\n        uint96 withdrawTime; \\n        uint96 claimTime; // last time the user claim the rewards\\n        uint96 lastSetClaimRewards; // the date when the user set a claim.\\n        uint32 daysLeft; // days left to avoid penalization.\\n        address token;\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenInfo\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mortgageControl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"vaultLenders\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardsLenders\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_control\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lControl\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feesVault\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newLoan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDebt\",\"type\":\"uint256\"}],\"name\":\"mortgageAgain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"wrapContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"creditType\",\"type\":\"uint8\"}],\"name\":\"mortgageEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idMortgage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"name\":\"releaseEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"idMortgage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"status\",\"type\":\"string\"}],\"name\":\"seized\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEV_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrap\",\"type\":\"address\"}],\"name\":\"addWrapData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"approveToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"loan\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"period\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalLoans\",\"type\":\"uint256\"}],\"name\":\"batchMortgage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"control\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feesVault\",\"outputs\":[{\"internalType\":\"contract IFeesVault\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPosition\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_property\",\"type\":\"address\"}],\"name\":\"getPropertyWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"guardian\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lControl\",\"outputs\":[{\"internalType\":\"contract ILendingControl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"market\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mortgageControl\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mortgageId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idMortgage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mortgagePaid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"openManualCredit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"loan\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"openMortgage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"pausedContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_lendersrewards\",\"type\":\"address\"}],\"name\":\"permissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"idMortgage\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"seizeNFT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_idPosition\",\"type\":\"uint256\"}],\"name\":\"setPosition\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_property\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setPropertyWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenInfo\",\"outputs\":[{\"internalType\":\"contract TokenInfo\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_calcs\",\"type\":\"address\"}],\"name\":\"updateCalcs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newControl\",\"type\":\"address\"}],\"name\":\"updateControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newfeeLenders\",\"type\":\"uint256\"}],\"name\":\"updateFeeLenders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newfeePanoram\",\"type\":\"uint256\"}],\"name\":\"updateFeePanoram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newUser\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_condition\",\"type\":\"bool\"}],\"name\":\"updateManual\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newMarket\",\"type\":\"address\"}],\"name\":\"updateMarket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_maxLoan\",\"type\":\"uint64\"}],\"name\":\"updateMaxLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPeriod\",\"type\":\"uint256\"}],\"name\":\"updateMaxPeriod\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_minLoan\",\"type\":\"uint64\"}],\"name\":\"updateMinLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mortgageId\",\"type\":\"uint256\"}],\"name\":\"updateMortgageID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relay\",\"type\":\"address\"}],\"name\":\"updateRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenInfo\",\"type\":\"address\"}],\"name\":\"updateTokenInfo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWalletPanoram\",\"type\":\"address\"}],\"name\":\"updateWalletPanoram\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"walletPanoram\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Mortgages", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000f106ec236ad8e887c8c227dc8d50bb64a84a409d000000000000000000000000681c02ac64d4602e3e974d62d7a99148d82bd58b00000000000000000000000025da3d4ac52df25f809f4a3e065ccb8aa1c258e5000000000000000000000000c2132d05d31c914a87c6611c10748aeb04b58e8f000000000000000000000000f9ff515a41198a78d3643b248f0b749e5fc5e4b7000000000000000000000000941159085deb15e07452f6b09c128267f9c7d82200000000000000000000000098599068c55b4141e147519e6a33db89252f39bd000000000000000000000000757656e1cc20c087a97c48b64356d901be6480ee0000000000000000000000005d1b2c1aebca0fc815cac2a4df2f0ca66fb2d193", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}