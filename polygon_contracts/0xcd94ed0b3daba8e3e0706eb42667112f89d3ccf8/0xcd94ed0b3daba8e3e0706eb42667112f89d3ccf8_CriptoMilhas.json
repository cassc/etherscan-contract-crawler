{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/CriptoMilhas.sol\": {\r\n      \"content\": \"// Dev: Willian Gon\u00e7alves Rios\\n// O presente smart contract tem o objetivo de intermediar rela\u00e7\u00f5es comerciais entre pessoas\\n// interessadas na compra e venda de passagens a\u00e9reas e produtos\\n// Neste smart-contract, a \u00fanica autoridade do owner \u00e9 adicionar e remover mediadores. O owner\\n// n\u00e3o tem nenhum poder de fazer retiradas de fundos conforme voc\u00ea mesmo pode conferir no c\u00f3digo.\\n// As taxas que a plataforma recebe a t\u00edtulo de intermedia\u00e7\u00e3o s\u00e3o enviadas \u00e0 wallet do owner todas\\n// as vezes que o vendedor de passagem/produto faz sua retirada (ou seja, quando uma negocia\u00e7\u00e3o\\n// \u00e9 bem sucedida), isso garante que nosso smart-contract sempre haver\u00e1 fundos para pagar todos os usu\u00e1rios\\n// bem como fazer a devolu\u00e7\u00e3o caso uma compra n\u00e3o se concretize.\\n\\n// SPDX-License-Identifier: MIT\\npragma solidity 0.8.19;\\n\\ncontract Owned {\\n    error OnlyOwner();\\n    address public owner;\\n\\n    modifier onlyOwner() {\\n        if (owner != msg.sender) {\\n            revert OnlyOwner();\\n        }\\n        _;\\n    }\\n\\n    function setNewOwner(address newOwner) external onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    function getContractOwner() public view returns (address) {\\n        return owner;\\n    }\\n}\\n\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\ncontract CriptoMilhas is Owned {\\n    error OnlyBuyer();\\n    error OnlySeller();\\n    error OnlyMediators();\\n\\n    modifier onlyBuyer(string memory _purchaseId) {\\n        if (purchases[_purchaseId].buyer != msg.sender) revert OnlyBuyer();\\n        _;\\n    }\\n\\n    modifier onlySeller(string memory _purchaseId) {\\n        if (purchases[_purchaseId].seller != msg.sender) revert OnlySeller();\\n        _;\\n    }\\n\\n    modifier onlyMediators() {\\n        if (!mediators[msg.sender]) revert OnlyMediators();\\n        _;\\n    }\\n\\n    enum Category {\\n        Other,\\n        AirlineTickets,\\n        Product,\\n        Accomodation,\\n        CarRental,\\n        ClassUpgrade,\\n        Event\\n    }\\n\\n    enum Status {\\n        WaitingForSellerConfirmation, // quando o buyer deposita os tokens e aguarda a confirma\u00e7\u00e3o do seller\\n        CancelledByBuyer, // quando o buyer cancela antes do seller confirmar, ou seja, o buyer j\u00e1 resgatou seus fundos\\n        SellerConfirmed, // quando o seller confirma que vai enviar o produto ou emitir a passagem\\n        WithdrawnBySeller, // quando o seller tiver resgatado seus fundos (negocia\u00e7\u00e3o bem sucedida)\\n        ModerationRequested, // o buyer pediu para travar os fundos por demora na chegada do produto ou na entrega das passagens (entra na media\u00e7\u00e3o)\\n        BuyerWithdrawalApproved, // o mediador decidiu que o buyer poder\u00e1 resgatar (podera resgatar imediatamente)\\n        SellerWithdrawalApproved, // o mediador decidiu que o seller poder\u00e1 resgatar (deve esperar o prazo)\\n        RefundedToBuyer // quando o buyer tiver resgatado seus tokens\\n    }\\n\\n    struct Purchase {\\n        address tokenAddress; // endere\u00e7o do smart-contract da stablecoin\\n        address buyer;\\n        address seller;\\n        address feeReceiver;\\n        Status status; // status atual da compra\\n        uint value; // quantidade de tokens/dolares\\n        uint purchaseDate;\\n        uint confirmationDate; // data em que o seller confirmou que vai vender\\n        uint withdrawalAllowDate; // data em que o seller poder\u00e1 fazer o saque\\n        uint withdrawnDate; // data em que o seller fez o saque\\n        uint moderationRequestedDate; // data em que o buyer solicitou media\u00e7\u00e3o\\n        uint refundedDate; // data que os valores foram restituidos ao buyer (devolvidos na totalidade, sem taxas)\\n        uint purchaseFeePercentage;\\n        bool postponed;\\n    }\\n\\n    mapping(Category => uint) feesByCategory;\\n    mapping(string => Purchase) purchases;\\n    mapping(string => bool) private registeredPurchases;\\n    mapping(address => bool) public mediators;\\n    mapping(address => bool) public feeReceiver;\\n    mapping(address => string[]) public negotiationsByAddress;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        feeReceiver[msg.sender] = true;\\n        feesByCategory[Category.Other] = 10;\\n        feesByCategory[Category.AirlineTickets] = 8;\\n        feesByCategory[Category.Product] = 8;\\n        feesByCategory[Category.Accomodation] = 7;\\n        feesByCategory[Category.CarRental] = 7;\\n        feesByCategory[Category.ClassUpgrade] = 6;\\n        feesByCategory[Category.Event] = 6;\\n    }\\n\\n    function purchase(\\n        string memory _purchaseId,\\n        address _tokenAddress, // endere\u00e7o do smart contract da stablecoin escolhida\\n        uint _value, // quantidade de tokens\\n        address _seller,\\n        address _feeReceiver,\\n        Category _Category, // categoria do produto/servi\u00e7o\\n        uint daysToAddOnReceiveProductOrService // dias a ser adicionado para que o buyer possa receber\\n                                                // seu produto/servi\u00e7o ou mesmo retornar de viagem\\n    ) external {\\n        require(\\n            _tokenAddress != address(0),\\n            unicode\\\"Endere\u00e7o de token inv\u00e1lido\\\"\\n        );\\n        require(\\n            _seller != address(0),\\n            unicode\\\"Endere\u00e7o do vendedor inv\u00e1lido\\\"\\n        );\\n        require(registeredPurchases[_purchaseId] == false, unicode\\\"N\u00e3o \u00e9 poss\u00edvel sobrescrever uma compra.\\\");\\n        // comentado apenas para fazer testes\\n        // require(daysToAddOnReceiveProductOrService > 10, unicode\\\"Data inv\u00e1lida. M\u00ednimo de 10 dias.\\\");\\n        IERC20 token = IERC20(_tokenAddress);\\n        uint256 tokenAmount = token.balanceOf(msg.sender);\\n        require(tokenAmount >= _value, \\\"Saldo insuficiente de tokens\\\");\\n        bool success = token.transferFrom(msg.sender, address(this), _value);\\n        require(success == true, unicode\\\"Falha na transfer\u00eancia de tokens\\\");\\n        registeredPurchases[_purchaseId] = true;\\n        purchases[_purchaseId] = Purchase({\\n            tokenAddress: _tokenAddress,\\n            buyer: msg.sender,\\n            seller: _seller,\\n            feeReceiver: _feeReceiver,\\n            status: Status.WaitingForSellerConfirmation,\\n            value: _value,\\n            purchaseDate: block.timestamp,\\n            confirmationDate: 0,\\n            withdrawalAllowDate: block.timestamp + (daysToAddOnReceiveProductOrService * 1 days),\\n            withdrawnDate: 0,\\n            moderationRequestedDate: 0,\\n            refundedDate: 0,\\n            purchaseFeePercentage: getFeeByCategory(_Category),\\n            postponed: false\\n        });\\n        negotiationsByAddress[msg.sender].push(_purchaseId);\\n        negotiationsByAddress[_seller].push(_purchaseId);\\n    }\\n\\n    function sellerConfirmation(\\n        string memory _purchaseId\\n    ) external onlySeller(_purchaseId) {\\n        Purchase storage _purchase = purchases[_purchaseId];\\n        require (_purchase.status == Status.WaitingForSellerConfirmation, unicode'N\u00e3o \u00e9 poss\u00edvel fazer a confirma\u00e7\u00e3o com o status atual da compra');\\n        _purchase.status = Status.SellerConfirmed;\\n        _purchase.confirmationDate = block.timestamp;\\n    }\\n\\n    function postponePayment(\\n        string memory _purchaseId,\\n        uint _days\\n    ) external onlyBuyer(_purchaseId) {\\n        require(_days <31 , unicode'Voc\u00ea pode pedir adiamento do prazo para libera\u00e7\u00e3o dos tokens em no m\u00e1ximo 30 dias. Caso voc\u00ea entenda que n\u00e3o seja suficiente, poder\u00e1 solicitar o bloqueio dos tokens.');\\n        Purchase storage _purchase = purchases[_purchaseId];\\n        require(!_purchase.postponed, unicode'Voc\u00ea pode pedir adiamento apenas uma vez. Mas tamb\u00e9m poder\u00e1 solicitar o bloqueio dos tokens caso seja necess\u00e1rio.');\\n        _purchase.postponed = true;\\n        _purchase.withdrawalAllowDate = _purchase.withdrawalAllowDate + (_days * 1 days);\\n    }\\n\\n    function cancelPurchase(\\n        string memory _purchaseId\\n    ) external onlyBuyer(_purchaseId) {\\n        Purchase storage _purchase = purchases[_purchaseId];\\n        require(\\n            _purchase.status == Status.WaitingForSellerConfirmation,\\n            unicode\\\"Com o status atual n\u00e3o \u00e9 poss\u00edvel fazer o cancelamento.\\\"\\n        );\\n        _purchase.status = Status.CancelledByBuyer;\\n        _purchase.refundedDate = block.timestamp;\\n        IERC20 token = IERC20(_purchase.tokenAddress);\\n        require(token.transfer(msg.sender, _purchase.value), unicode\\\"Falha na transfer\u00eancia dos fundos\\\");\\n    }\\n\\n    function requestModeration(\\n        string memory _purchaseId\\n    ) external onlyBuyer(_purchaseId) {\\n        Purchase storage _purchase = purchases[_purchaseId];\\n        require(\\n            _purchase.status == Status.SellerConfirmed,\\n            unicode\\\"Com o status atual n\u00e3o \u00e9 poss\u00edvel solicitar modera\u00e7\u00e3o.\\\"\\n        );\\n        _purchase.status = Status.ModerationRequested;\\n        _purchase.moderationRequestedDate = block.timestamp;\\n    }\\n\\n\\n    function sellerWithdraw(string memory _purchaseId) external onlySeller(_purchaseId) {\\n        Purchase storage _purchase = purchases[_purchaseId];\\n        require(_purchase.status == Status.SellerConfirmed || _purchase.status == Status.SellerWithdrawalApproved, unicode\\\"N\u00e3o \u00e9 permitido fazer a retirada devido ao status atual da compra\\\");\\n        require(block.timestamp > _purchase.withdrawalAllowDate, unicode\\\"Ainda n\u00e3o \u00e9 permitido fazer a retirada, aguarde o prazo\\\");\\n        _purchase.status = Status.WithdrawnBySeller;\\n        _purchase.withdrawnDate = block.timestamp;\\n        uint feeValue = (_purchase.value * _purchase.purchaseFeePercentage) / 100;\\n        // Realizar a transfer\u00eancia dos fundos para o vendedor e tamb\u00e9m as taxas da plataforma para o feeReceiver\\n        IERC20 token = IERC20(_purchase.tokenAddress);\\n        require(token.transfer(msg.sender, _purchase.value - feeValue), unicode\\\"Falha na transfer\u00eancia dos fundos\\\");\\n        require(token.transfer(_purchase.feeReceiver, feeValue), unicode\\\"Falha na transfer\u00eancia dos fundos (taxas da plataforma)\\\");\\n    }\\n\\n    function buyerWithdraw (string memory _purchaseId) external onlyBuyer(_purchaseId) {\\n        Purchase storage _purchase = purchases[_purchaseId];\\n        require(_purchase.status == Status.BuyerWithdrawalApproved, unicode\\\"O status atual n\u00e3o permite a retirada\\\");\\n        _purchase.status = Status.RefundedToBuyer;\\n        _purchase.refundedDate = block.timestamp;\\n        IERC20 token = IERC20(_purchase.tokenAddress);\\n        require(token.transfer(msg.sender, _purchase.value), unicode\\\"Falha na transfer\u00eancia dos fundos\\\");\\n    }\\n\\n    function mediatorDecision (string memory _purchaseId,Status _statusToSet) external onlyMediators {\\n        Purchase storage _purchase = purchases[_purchaseId];\\n        require(_statusToSet == Status.BuyerWithdrawalApproved || _statusToSet == Status.SellerWithdrawalApproved, unicode'N\u00e3o \u00e9 poss\u00edvel setar esta decis\u00e3o');\\n        _purchase.status = _statusToSet;\\n    }\\n\\n    function getPurchase(string memory _purchaseId) external view returns (Purchase memory) {\\n        return purchases[_purchaseId];\\n    }\\n\\n    function setFeeByCategory (Category _purchaseCategory,uint256 _fee) external onlyOwner {\\n        feesByCategory[_purchaseCategory] = _fee;\\n    }\\n\\n    function addMediators (address[] memory addresses) external onlyOwner {\\n        uint i = 0;\\n        while (i < addresses.length) {\\n            mediators[addresses[i]] = true;\\n            i++;\\n        }\\n    }\\n\\n    function removeMediators (address[] memory addresses) external onlyOwner {\\n        uint i = 0;\\n        while (i < addresses.length) {\\n            delete mediators[addresses[i]];\\n            i++;\\n        }\\n    }\\n\\n    function setNewFeeReceiver (address _feeReceiver) external onlyOwner {\\n      feeReceiver[_feeReceiver] = true;\\n    }\\n\\n    function removeFeeReceiver (address _feeReceiverToRemove) external onlyOwner {\\n      feeReceiver[_feeReceiverToRemove] = false;\\n    }\\n\\n    function isFeeReceiver (address _feeReceiver) external view returns(bool) {\\n      return feeReceiver[_feeReceiver];\\n    }\\n\\n    function getFeeByCategory (Category _purchaseCategory) public view returns (uint256) {\\n        return feesByCategory[_purchaseCategory];\\n    }\\n\\n    function getAllNegotiationsByAddress(address _address) public view returns (string[] memory) {\\n        return negotiationsByAddress[_address];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"OnlyBuyer\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyMediators\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlySeller\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"addMediators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"}],\"name\":\"buyerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"}],\"name\":\"cancelPurchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAllNegotiationsByAddress\",\"outputs\":[{\"internalType\":\"string[]\",\"name\":\"\",\"type\":\"string[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CriptoMilhas.Category\",\"name\":\"_purchaseCategory\",\"type\":\"uint8\"}],\"name\":\"getFeeByCategory\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"}],\"name\":\"getPurchase\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeReceiver\",\"type\":\"address\"},{\"internalType\":\"enum CriptoMilhas.Status\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"confirmationDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalAllowDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"moderationRequestedDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundedDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchaseFeePercentage\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"postponed\",\"type\":\"bool\"}],\"internalType\":\"struct CriptoMilhas.Purchase\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"isFeeReceiver\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"},{\"internalType\":\"enum CriptoMilhas.Status\",\"name\":\"_statusToSet\",\"type\":\"uint8\"}],\"name\":\"mediatorDecision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mediators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"negotiationsByAddress\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_days\",\"type\":\"uint256\"}],\"name\":\"postponePayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_seller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"},{\"internalType\":\"enum CriptoMilhas.Category\",\"name\":\"_Category\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"daysToAddOnReceiveProductOrService\",\"type\":\"uint256\"}],\"name\":\"purchase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiverToRemove\",\"type\":\"address\"}],\"name\":\"removeFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"removeMediators\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"}],\"name\":\"requestModeration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"}],\"name\":\"sellerConfirmation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_purchaseId\",\"type\":\"string\"}],\"name\":\"sellerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum CriptoMilhas.Category\",\"name\":\"_purchaseCategory\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFeeByCategory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeReceiver\",\"type\":\"address\"}],\"name\":\"setNewFeeReceiver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setNewOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CriptoMilhas", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}