{"SourceCode": "//  Forge Auctions Contract\r\n//  Auctions Forge tokens every 3 days and users are able to withdraw anytime after!\r\n//\r\n//  The 0xBitcoin tokens collected by Forge Auctions go to miners and liquidity providers!\r\n//\r\n//  10,500,000 Forge tokens are Auctioned off over 100 years in this contract! In the first era ~5,000,000 are auctioned and half every era after!\r\n//\r\n//  Distributes 8,192 Forge tokens every 4-12 days for the first era(~5 years) and halves the amount of Forge every era after\r\n//\r\n// By using the burn0xBTCForMember function\r\n//       0xBitcoin Token is taken from the user and used to recieve your share of the 8,192 tokens auctioned every ~4 days\r\n\r\n\r\npragma solidity ^0.8.11;\r\n\r\ncontract Ownabled {\r\n    address public owner22;\r\n    event TransferOwnership(address _from, address _to);\r\n\r\n    constructor() public {\r\n        owner22 = msg.sender;\r\n        emit TransferOwnership(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner22() {\r\n        require(msg.sender == owner22, \"only owner\");\r\n        _;\r\n    }\r\n    function setOwner(address _owner22) internal onlyOwner22 {\r\n        emit TransferOwnership(owner22, _owner22);\r\n        owner22 = _owner22;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 z = x + y;\r\n        require(z >= x, \"Add overflow\");\r\n        return z;\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(x >= y, \"Sub underflow\");\r\n        return x - y;\r\n    }\r\n\r\n    function mult(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 z = x * y;\r\n        require(z / x == y, \"Mult overflow\");\r\n        return z;\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        return x / y;\r\n    }\r\n\r\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        uint256 r = x / y;\r\n        if (x % y != 0) {\r\n            r = r + 1;\r\n        }\r\n\r\n        return r;\r\n    }\r\n}\r\n\r\nlibrary ExtendedMath {\r\n\r\n\r\n    //return the smaller of the two inputs (a or b)\r\n    function limitLessThan(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        if(a > b) return b;\r\n\r\n        return a;\r\n\r\n    }\r\n}\r\ninterface IERC20 {\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n   \r\n    \r\n}\r\n\r\ncontract GasPump {\r\n    bytes32 private stub;\r\n\r\n    modifier requestGas(uint256 _factor) {\r\n        if (tx.gasprice == 0 || gasleft() > block.gaslimit) {\r\n            uint256 startgas = gasleft();\r\n            _;\r\n            uint256 delta = startgas - gasleft();\r\n            uint256 target = (delta * _factor) / 100;\r\n            startgas = gasleft();\r\n            while (startgas - gasleft() < target) {\r\n                // Burn gas\r\n                stub = keccak256(abi.encodePacked(stub));\r\n            }\r\n        } else {\r\n            _;\r\n        }\r\n    }\r\n}\r\n\r\ncontract ForgeMining{\r\n    function getMiningMinted() public view returns (uint256) {}\r\n    \r\n    }\r\n\r\n  contract ForgeAuctions is  GasPump, Ownabled\r\n{\r\n\r\n    using SafeMath for uint;\r\n    using ExtendedMath for uint;\r\n    address public AddressZeroXBTC;\r\n    address public AddressForgeToken;\r\n    // ERC-20 Parameters\r\n    uint256 public extraGas;\r\n    bool runonce = false;\r\n    uint256 oneEthUnit = 1000000000000000000; \r\n    uint256 one0xBTCUnit =         100000000;\r\n    string public name;\r\n    uint public decimals;\r\n\r\n    // ERC-20 Mappings\r\n    mapping(address => uint) private _balances;\r\n    mapping(address => mapping(address => uint)) private _allowances;\r\n\r\n    // Public Parameters\r\n    uint coin; uint public emission; uint public totalAuctioned = 0;\r\n    uint public currentEra; uint public currentDay;\r\n    uint public daysPerEra; uint public secondsPerDay;\r\n    uint public nextDayTime;\r\n    uint public totalBurnt; uint public totalEmitted;\r\n    // Public Mappings\r\n    \r\n    mapping(uint=>uint) public mapEra_Emission;                                             // Era->Emission\r\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_MemberCount;                        // Era,Days->MemberCount\r\n    mapping(uint=>mapping(uint=>address[])) public mapEraDay_Members;                       // Era,Days->Members\r\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_Units;                              // Era,Days->Units\r\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_UnitsRemaining;                     // Era,Days->TotalUnits\r\n    mapping(uint=>mapping(uint=>uint)) public mapEraDay_EmissionRemaining;                  // Era,Days->Emission\r\n    mapping(uint=>mapping(uint=>mapping(address=>uint))) public mapEraDay_MemberUnits;      // Era,Days,Member->Units\r\n    mapping(address=>mapping(uint=>uint[])) public mapMemberEra_Days;                       // Member,Era->Days[]   \r\n    mapping(address=>uint) public ZmapMember_EraClaimedTo;      // Era,Days,Member->Units\r\n    mapping(address=>uint) public ZmapMember_DayClaimedTo; \r\n    \r\n    ForgeMining ForgeMiningToken;\r\n    // Events\r\n    event SetExtraGas(uint256 _prev, uint256 _new);\r\n    event NewEra(uint era, uint emission, uint totalBurnt);\r\n    event NewDay(uint era, uint day, uint time, uint previousDayTotal, uint previousDayMembers);\r\n    event Burn(address indexed payer, address indexed member, uint era, uint day, uint units, uint dailyTotal);\r\n    event BurnMultipleDays(address indexed payer, address indexed member, uint era, uint NumberOfDays, uint totalUnits);\r\n  \r\n    event Withdrawal(address indexed caller, address indexed member, uint era, uint day, uint value, uint vetherRemaining);\r\n    event MegaWithdrawal(address indexed caller, address indexed member, uint era, uint TotalDays, uint256 stricttotal);\r\n    uint256 public lastMinted = 0;\r\n    bool onlyOnce = false;\r\n    //=====================================CREATION=========================================//\r\n\r\n    // Constructor\r\n    constructor () public {\r\n        name = \"Auction Contract\"; decimals = 18; \r\n        coin = 10**decimals; emission = 2048*coin;\r\n        currentEra = 1; currentDay = 1; \r\n        daysPerEra = 600; secondsPerDay = 24*60*60*3; \r\n        totalBurnt = 0;\r\n        totalEmitted = 0;\r\n        nextDayTime = block.timestamp + secondsPerDay;\r\n        mapEra_Emission[currentEra] = emission; \r\n        mapEraDay_EmissionRemaining[currentEra][currentDay] = emission; \r\n                                                              \r\n    }\r\n    \r\n    \r\n    \r\n\r\n\r\n        function zSetUP1(address token, address _ZeroXBTCAddress) public onlyOwner22 {\r\n        AddressForgeToken = token;\r\n        owner22 = address(0);\r\n        lastMinted =  0;\r\n        AddressZeroXBTC = _ZeroXBTCAddress;\r\n        ForgeMiningToken = ForgeMining(token);\r\n        lastMinted = ForgeMiningToken.getMiningMinted();\r\n\r\n    }\r\n\r\n    function changeAuctionAmt() internal {\r\n        uint tokensMinted = ForgeMiningToken.getMiningMinted();\r\n      \r\n        uint diff = tokensMinted - lastMinted;\r\n        uint expected = emission.mult(8*106).div(100);\r\n        if(diff != 0){\r\n            if( diff < expected )\r\n            {\r\n                uint excess_block_pct = (expected.mult(100)).div( diff );\r\n                uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);\r\n            \r\n            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\r\n            //make it longer since we are not mining enough\r\n            \r\n                secondsPerDay = secondsPerDay.add(secondsPerDay.mult(excess_block_pct_extra).div(1000));   //by up to 100 %\r\n            }else{\r\n                uint shortage_block_pct = (diff.mult(100)).div( expected );\r\n                uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000); //always between 0 and 1000\r\n\r\n             //make it shorter since we are mining too many\r\n                 secondsPerDay = secondsPerDay.sub(secondsPerDay.mult(shortage_block_pct_extra).div(2000));   //by up to 50 %\r\n              }\r\n        }else{\r\n            secondsPerDay = secondsPerDay * 2;\r\n        }\r\n       if(secondsPerDay <= 5)\r\n       {\r\n           secondsPerDay = 10;\r\n       }\r\n\r\n           \r\n       lastMinted = tokensMinted;\r\n\r\n    }\r\n\r\n\r\n    //Bids for Whole Era\r\n    function WholeEraBurn0xBTCForMember(address member, uint256 _0xbtcAmountTotal) public returns (bool success)\r\n    {\r\n        uint256 daysleft = daysPerEra - currentDay - 1 ;//just incase\r\n        FutureBurn0xBTCEasier(currentEra, currentDay, daysleft, member, _0xbtcAmountTotal);\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n    \r\n    //Bids for Future in consequitive days\r\n    function FutureBurn0xBTCEasier(uint _era, uint startingday, uint totalNumberrOfDays, address _member, uint _0xbtcAmountTotal) public returns (bool success)\r\n    {\r\n        uint[] memory dd = new uint[](totalNumberrOfDays); \r\n        uint[] memory amt = new uint[](totalNumberrOfDays);\r\n        uint y=0;\r\n        for(uint x=startingday; x< (startingday+totalNumberrOfDays); x++)\r\n        {\r\n            dd[y] = x;\r\n            amt[y] = _0xbtcAmountTotal/totalNumberrOfDays;\r\n            y++;\r\n        }\r\n        FutureBurn0xBTCArrays(_era, dd, _member, amt);\r\n    \r\n        return true;\r\n    }\r\n\r\n\r\n    //Burns any amount for any day(s) in any order\r\n    function FutureBurn0xBTCArrays(uint _era, uint[] memory fdays, address _member, uint[] memory _0xbtcAmount) public returns (bool success)\r\n    {\r\n        uint256 stricttotal =0;\r\n        uint256 _daysPerEra=daysPerEra;\r\n        uint _currentEra = currentEra; \r\n        uint _currentday = currentDay; \r\n        require(_era >= currentEra, \"no knucklehead only bid on this era\");\r\n        for(uint256 x = 0; x < fdays.length; x++)\r\n        {\r\n            uint256 dayamt = _0xbtcAmount[x];\r\n            if(_era == _currentEra)\r\n            {\r\n                require(fdays[x] >= currentDay, \"Must not bid behind the days\");\r\n            }\r\n            require(fdays[x] <= _daysPerEra, \"Cant bid on days not in era\");\r\n            stricttotal = stricttotal.add(dayamt);\r\n            _recordBurn(msg.sender, _member, _era, fdays[x], dayamt);\r\n        }\r\n    \r\n        require(IERC20(AddressZeroXBTC).transferFrom(msg.sender, AddressForgeToken, stricttotal), \"NO OTHER WAY, send it the required 0xBitcoin\");\r\n        \r\n        emit BurnMultipleDays(msg.sender, _member, _era, fdays.length, stricttotal);\r\n        \r\n        return true;\r\n    \r\n    }\r\n\r\n\r\n    function burn0xBTCForMember(address member, uint256 _0xbtcAmount) public returns (bool success) {\r\n        uint day = currentDay;\r\n        require(IERC20(AddressZeroXBTC).transferFrom(msg.sender, AddressForgeToken, _0xbtcAmount), \"NO WAY, requires 0xBTC send\");\r\n        _recordBurn(msg.sender, member, currentEra, currentDay, _0xbtcAmount);\r\n        emit Burn(msg.sender, member, currentEra, day, _0xbtcAmount, mapEraDay_Units[currentEra][currentDay]);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    \r\n    // Internal - Records burn\r\n    function _recordBurn(address _payer, address _member, uint _era, uint _day, uint _eth) private {\r\n        if (mapEraDay_MemberUnits[_era][_day][_member] == 0){                               // If hasn't contributed to this Day yet\r\n            mapMemberEra_Days[_member][_era].push(_day);                                    // Add it\r\n            mapEraDay_MemberCount[_era][_day] += 1;                                         // Count member\r\n            mapEraDay_Members[_era][_day].push(_member);                                    // Add member\r\n        }\r\n        mapEraDay_MemberUnits[_era][_day][_member] += _eth;                                 // Add member's share\r\n        mapEraDay_UnitsRemaining[_era][_day] += _eth;                                       // Add to total historicals\r\n        mapEraDay_Units[_era][_day] += _eth;                                                // Add to total outstanding\r\n        totalBurnt += _eth;                                                                 // Add to total burnt\r\n        _updateEmission();                                                                  // Update emission Schedule\r\n    }\r\n    \r\n    \r\n    \r\n        //======================================WITHDRAWAL======================================//\r\n    // Used to efficiently track participation in each era\r\n    function getDaysContributedForEra(address member, uint era) public view returns(uint){\r\n        return mapMemberEra_Days[member][era].length;\r\n    }\r\n    \r\n    \r\n    // Call to withdraw a claim\r\n    function withdrawShare(uint era, uint day) external returns (uint value) {\r\n        uint memberUnits = mapEraDay_MemberUnits[era][day][msg.sender];  \r\n        assert (memberUnits != 0); // Get Member Units\r\n        value = _withdrawShare(era, day, msg.sender);\r\n    }\r\n    \r\n    \r\n    // Call to withdraw a claim for another member\r\n    function withdrawShareForMember(uint era, uint day, address member) public returns (uint value) {\r\n        uint memberUnits = mapEraDay_MemberUnits[era][day][member];  \r\n        assert (memberUnits != 0); // Get Member Units\r\n        value = _withdrawShare(era, day, member);\r\n        return value;\r\n    }\r\n    \r\n    \r\n    // Internal - withdraw function\r\n    function _withdrawShare (uint _era, uint _day, address _member) private returns (uint value) {\r\n        _updateEmission(); \r\n        if (_era < currentEra) {                                                            // Allow if in previous Era\r\n            value = _processWithdrawal(_era, _day, _member);                                // Process Withdrawal\r\n        } else if (_era == currentEra) {                                                    // Handle if in current Era\r\n            if (_day < currentDay) {                                                        // Allow only if in previous Day\r\n                value = _processWithdrawal(_era, _day, _member);                            // Process Withdrawal\r\n            }\r\n        } \r\n \r\n        return value;\r\n        \r\n    }\r\n    \r\n\r\n    //To change your claiming if somehow error occurs\r\n    function z_ChangeMaxWithdrawl( uint newMaxDay, uint newMaxEra) public returns  (bool success){\r\n        ZmapMember_DayClaimedTo[msg.sender] = newMaxDay;\r\n        ZmapMember_EraClaimedTo[msg.sender] = newMaxEra;\r\n        \r\n        return true;\r\n        \r\n    }\r\n    \r\n    \r\n    //Super easy auction redeeming\r\n    function WithdrawEasiest() public\r\n    {\r\n        WithdrawEz(msg.sender);\r\n    }\r\n\r\n\r\n    //Helper Function for efficent redeeming of auctions\r\n    function WithdrawEz(address _member) public {\r\n        uint startingday = ZmapMember_DayClaimedTo[_member];\r\n        uint startingera = ZmapMember_EraClaimedTo[_member];\r\n        if(startingday == 0)\r\n        {\r\n            startingday = 1;\r\n        }\r\n        if(startingera == 0)\r\n        {\r\n            startingera = 1;\r\n        }\r\n        uint maxDay=1;\r\n        for(uint y=startingera; y <= currentEra; y++){\r\n            if(y != currentEra){\r\n                maxDay = daysPerEra;\r\n             }else{\r\n               maxDay = currentDay - 1;\r\n             }\r\n          \r\n             uint[] memory dd = new uint[](maxDay-startingday+1); \r\n             for(uint x=startingday; x<= maxDay; x++)\r\n             {\r\n                  dd[x-startingday] = x ;\r\n             }\r\n             WithdrawlsDays(y, dd, _member);\r\n        }\r\n        \r\n        ZmapMember_DayClaimedTo[_member] = maxDay;\r\n        ZmapMember_DayClaimedTo[_member] = currentEra;\r\n        \r\n    }\r\n    \r\n    \r\n    function Check_Withdraw_Amt(address _member) public view returns(uint amt) {\r\n        uint startingday = ZmapMember_DayClaimedTo[_member];\r\n        uint startingera = ZmapMember_EraClaimedTo[_member];\r\n        if(startingday == 0)\r\n        {\r\n            startingday = 1;\r\n        }\r\n        if(startingera == 0)\r\n        {\r\n            startingera = 1;\r\n        }\r\n        uint maxDay=1;\r\n        uint totz = 0;\r\n        for(uint y=startingera; y <= currentEra; y++){\r\n            if(y != currentEra){\r\n                maxDay = daysPerEra;\r\n             }else{\r\n               maxDay = currentDay - 1;\r\n             }\r\n          \r\n             uint[] memory dd = new uint[](maxDay-startingday+1); \r\n             for(uint x=startingday; x<= maxDay; x++)\r\n             {\r\n                  dd[x-startingday] = x ;\r\n             }\r\n             totz = totz + Check_Withdrawls_Days(y, dd, _member);\r\n        }\r\n        return totz;\r\n    }\r\n    \r\n    //Withdraws All days in era for member\r\n    function Check_Withdrawls_Days(uint _era, uint[] memory fdays, address _member) public view returns (uint check)\r\n    {\r\n    \r\n        uint256 stricttotal = 0;\r\n        for(uint256 x = 0; x < fdays.length; x++)\r\n        {\r\n            if (_era < currentEra) {                                                                          // Allow if in previous Era\r\n                \r\n                uint memberUnits = mapEraDay_MemberUnits[_era][fdays[x]][_member];\r\n                if (memberUnits!= 0) {\r\n                    stricttotal = stricttotal + getEmissionShare(_era, fdays[x], _member);\r\n                }\r\n            } else if (_era == currentEra) {                                                                  // Handle if in current Era\r\n                if (fdays[x] < currentDay) {                                                                      // Allow only if in previous Day\r\n                    uint memberUnits = mapEraDay_MemberUnits[_era][fdays[x]][_member];\r\n                    if (memberUnits!= 0) {\r\n                        stricttotal = stricttotal + getEmissionShare(_era, fdays[x], _member);\r\n                    }\r\n                }\r\n            } \r\n        }\r\n    \r\n        return stricttotal*4;\r\n    }\r\n\r\n    \r\n    //Withdraws All days in era for member\r\n    function WithdrawlsDays(uint _era, uint[] memory fdays, address _member) public returns (bool success)\r\n    {\r\n    \r\n        uint256 stricttotal = 0;\r\n        for(uint256 x = 0; x < fdays.length; x++)\r\n        {\r\n            if (_era < currentEra) {                                                                          // Allow if in previous Era\r\n                stricttotal = stricttotal.add( _processWithdrawalRETURNSVAL (_era, fdays[x], _member) );      // Process Withdrawal\r\n            } else if (_era == currentEra) {                                                                  // Handle if in current Era\r\n                if (fdays[x] < currentDay) {                                                                      // Allow only if in previous Day\r\n                    stricttotal = stricttotal.add( _processWithdrawalRETURNSVAL (_era, fdays[x], _member) );  // Process Withdrawal\r\n                }\r\n            } \r\n        }\r\n        IERC20(AddressForgeToken).transfer(_member, stricttotal);\r\n        emit MegaWithdrawal(msg.sender, _member, _era, fdays.length, stricttotal);\r\n    \r\n        return true;\r\n    }\r\n\r\n\r\n    function _processWithdrawalRETURNSVAL (uint _era, uint256 _day, address _member) private returns (uint256 value) {\r\n        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member];                      // Get Member Units\r\n        if (memberUnits == 0) { \r\n            value = 0;                                                                      // Do nothing if 0 (prevents revert)\r\n        } else {\r\n            value = getEmissionShare(_era, _day, _member);                                  // Get the emission Share for Member\r\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;                                 // Set to 0 since it will be withdrawn\r\n            mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units\r\n            mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission\r\n            totalEmitted += value*4;\r\n            //We emit all in one transfer.   \r\n        }\r\n        \r\n        return value*4;\r\n        \r\n    }\r\n    \r\n    \r\n    function _processWithdrawal (uint _era, uint _day, address _member) private returns (uint value) {\r\n        uint memberUnits = mapEraDay_MemberUnits[_era][_day][_member];                      // Get Member Units\r\n        if (memberUnits == 0) { \r\n            value = 0;                                                                      // Do nothing if 0 (prevents revert)\r\n        } else {\r\n            value = getEmissionShare(_era, _day, _member);                                  // Get the emission Share for Member\r\n            mapEraDay_MemberUnits[_era][_day][_member] = 0;                                 // Set to 0 since it will be withdrawn\r\n            mapEraDay_UnitsRemaining[_era][_day] = mapEraDay_UnitsRemaining[_era][_day].sub(memberUnits);  // Decrement Member Units\r\n            mapEraDay_EmissionRemaining[_era][_day] = mapEraDay_EmissionRemaining[_era][_day].sub(value);  // Decrement emission\r\n            totalEmitted += value*4;            \r\n            emit Withdrawal(msg.sender, _member, _era, _day, value*4, mapEraDay_EmissionRemaining[_era][_day]);\r\n            // ERC20 transfer function\r\n            IERC20(AddressForgeToken).transfer(_member, value*4); // 8,192 tokens a auction aka almost half the supply an era!\r\n        }\r\n        \r\n        return value*4;\r\n        \r\n    }\r\n    \r\n    \r\n    //======================================EMISSION========================================//\r\n    \r\n    function getEmissionShare(uint era, uint day, address member) public view returns (uint value) {\r\n    \r\n        uint memberUnits = mapEraDay_MemberUnits[era][day][member];                         // Get Member Units\r\n        if (memberUnits == 0) {\r\n            return 0;                                                                       // If 0, return 0\r\n        } else {\r\n            uint totalUnits = mapEraDay_UnitsRemaining[era][day];                           // Get Total Units\r\n            uint emissionRemaining = mapEraDay_EmissionRemaining[era][day];                 // Get emission remaining for Day\r\n            uint balance = IERC20(AddressForgeToken).balanceOf(address(this));                                      // Find remaining balance\r\n            if (emissionRemaining > balance) { emissionRemaining = balance; }               // In case less than required emission\r\n            value = (emissionRemaining * memberUnits) / totalUnits;                         // Calculate share\r\n            return  value;                            \r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n    // Internal - Update emission function\r\n    function _updateEmission() private {\r\n        uint _now = block.timestamp;                                                                    // Find now()\r\n        if (_now > nextDayTime) {                                                          // If time passed the next Day time\r\n            if (currentDay >= daysPerEra) {                                                 // If time passed the next Era time\r\n                currentEra += 1; currentDay = 0;                                            // Increment Era, reset Day\r\n                emission = getNextEraEmission();                                            // Get correct emission\r\n                mapEra_Emission[currentEra] = emission;                                     // Map emission to Era\r\n                emit NewEra(currentEra, emission, totalBurnt); \r\n            }\r\n            changeAuctionAmt(); \r\n            currentDay += 1;                                                                // Increment Day\r\n            nextDayTime = _now + secondsPerDay;                                             // Set next Day time\r\n         \r\n            emission = getDayEmission();  \r\n            totalAuctioned = totalAuctioned + emission*4;\r\n            // Check daily Dmission\r\n            mapEraDay_EmissionRemaining[currentEra][currentDay] = emission;                 // Map emission to Day\r\n            uint _era = currentEra; uint _day = currentDay-1;\r\n            if(currentDay == 1){ _era = currentEra-1; _day = daysPerEra; }                  // Handle New Era\r\n            emit NewDay(currentEra, currentDay, nextDayTime, \r\n            mapEraDay_Units[_era][_day], mapEraDay_MemberCount[_era][_day]);\r\n            \r\n        }\r\n    }\r\n    \r\n    \r\n    // Calculate Era emission\r\n    function getNextEraEmission() public view returns (uint) {\r\n        if (emission > coin) {                                                              // Normal Emission Schedule\r\n            return emission / 2;                                                            // Emissions: 2048 -> 1.0\r\n        } else{                                                                             // Enters Fee Era\r\n            return coin;                                                                    // Return 1.0 from fees\r\n        }\r\n    }\r\n    \r\n    \r\n     function getSecondsPerDay() public view returns (uint256) {\r\n     \r\n        return secondsPerDay;                                                             // Return 1.0 from fees\r\n    }\r\n       \r\n       \r\n    // Calculate Day emission\r\n    function getDayEmission() public view returns (uint) {\r\n        uint balance = (totalEmitted + IERC20(AddressForgeToken).balanceOf(address(this))) - totalAuctioned;                                     // Find remaining balance\r\n        if (balance > emission*4) {                                                           // Balance is sufficient\r\n            return emission;                                                                // Return emission\r\n        } else {                                                                            // Balance has dropped low\r\n            return balance/4;                                                                 // Return full balance\r\n        }\r\n    }\r\n    \r\n    \r\n    function z_transferERC20TokenToMinerContract(address tokenAddress) public returns (bool success) {\r\n        require(tokenAddress != AddressZeroXBTC && tokenAddress != AddressForgeToken);\r\n        \r\n        return IERC20(tokenAddress).transfer(AddressForgeToken, IERC20(tokenAddress).balanceOf(address(this))); \r\n    }\r\n    \r\n    \r\n  //Do not allow ETH to enter\r\n  receive() external payable {\r\n    revert();\r\n  }\r\n\r\n\r\n  fallback() external payable {\r\n    revert();\r\n  }\r\n}\r\n\r\n/*\r\n*\r\n* MIT License\r\n* ===========\r\n*\r\n* Copyright (c) 2022 Forge\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.   \r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"units\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dailyTotal\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"NumberOfDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalUnits\",\"type\":\"uint256\"}],\"name\":\"BurnMultipleDays\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TotalDays\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stricttotal\",\"type\":\"uint256\"}],\"name\":\"MegaWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousDayTotal\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousDayMembers\",\"type\":\"uint256\"}],\"name\":\"NewDay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"emission\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBurnt\",\"type\":\"uint256\"}],\"name\":\"NewEra\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_prev\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_new\",\"type\":\"uint256\"}],\"name\":\"SetExtraGas\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vetherRemaining\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"AddressForgeToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AddressZeroXBTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"Check_Withdraw_Amt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_era\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"fdays\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"Check_Withdrawls_Days\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"check\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_era\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"fdays\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"_0xbtcAmount\",\"type\":\"uint256[]\"}],\"name\":\"FutureBurn0xBTCArrays\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_era\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startingday\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalNumberrOfDays\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_0xbtcAmountTotal\",\"type\":\"uint256\"}],\"name\":\"FutureBurn0xBTCEasier\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_0xbtcAmountTotal\",\"type\":\"uint256\"}],\"name\":\"WholeEraBurn0xBTCForMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WithdrawEasiest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"WithdrawEz\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_era\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"fdays\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"WithdrawlsDays\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ZmapMember_DayClaimedTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"ZmapMember_EraClaimedTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_0xbtcAmount\",\"type\":\"uint256\"}],\"name\":\"burn0xBTCForMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daysPerEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"extraGas\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDayEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"}],\"name\":\"getDaysContributedForEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"getEmissionShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEraEmission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSecondsPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapEraDay_EmissionRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapEraDay_MemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapEraDay_MemberUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapEraDay_Members\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapEraDay_Units\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapEraDay_UnitsRemaining\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapEra_Emission\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapMemberEra_Days\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextDayTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner22\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"secondsPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAuctioned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBurnt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEmitted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"withdrawShare\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"era\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"withdrawShareForMember\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ZeroXBTCAddress\",\"type\":\"address\"}],\"name\":\"zSetUP1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newMaxDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"newMaxEra\",\"type\":\"uint256\"}],\"name\":\"z_ChangeMaxWithdrawl\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"z_transferERC20TokenToMinerContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ForgeAuctions", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d39043fefebf6a00290edc0ce49ad12e406fb9e097e3fd02db2fb1a1df738430"}