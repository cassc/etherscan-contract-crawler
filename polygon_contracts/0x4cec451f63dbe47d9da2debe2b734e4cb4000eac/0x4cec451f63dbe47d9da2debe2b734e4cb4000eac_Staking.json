{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Staking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\nimport \\\"./actions/StakingMsgProcessor.sol\\\";\\nimport \\\"./interfaces/IActionMsgReceiver.sol\\\";\\nimport \\\"./interfaces/IErc20Min.sol\\\";\\nimport \\\"./interfaces/IStakingTypes.sol\\\";\\nimport \\\"./interfaces/IVotingPower.sol\\\";\\nimport \\\"./utils/ImmutableOwnable.sol\\\";\\nimport \\\"./utils/Utils.sol\\\";\\n\\n/**\\n * @title Staking\\n * @notice It lets users stake $ZKP token for governance voting and rewards.\\n * @dev At request of smart contracts and off-chain requesters, it computes\\n * user \\\"voting power\\\" on the basis of tokens users stake.\\n * It acts as the \\\"ActionOracle\\\" for the \\\"RewardMaster\\\": if stake terms presume\\n * rewarding, it sends \\\"messages\\\" on stakes made and stakes claimed to the\\n * \\\"RewardMaster\\\" contract which rewards stakers.\\n * It supports multiple types of stakes (terms), which the owner may add or\\n * remove without contract code upgrades.\\n */\\ncontract Staking is\\n    ImmutableOwnable,\\n    Utils,\\n    StakingMsgProcessor,\\n    IStakingTypes,\\n    IVotingPower\\n{\\n    // solhint-disable var-name-mixedcase\\n    /// @notice Staking token\\n    IErc20Min public immutable TOKEN;\\n\\n    /// @dev Block the contract deployed in\\n    uint256 public immutable START_BLOCK;\\n\\n    /// @notice RewardMaster contract instance\\n    IActionMsgReceiver public immutable REWARD_MASTER;\\n\\n    // solhint-enable var-name-mixedcase\\n\\n    // Scale for min/max limits\\n    uint256 private constant SCALE = 1e18;\\n\\n    /// @notice Total token amount staked\\n    /// @dev Staking token is deemed to have max total supply of 1e27\\n    uint96 public totalStaked = 0;\\n\\n    /// @dev Mapping from stake type to terms\\n    mapping(bytes4 => Terms) public terms;\\n\\n    /// @dev Mapping from the staker address to stakes of the staker\\n    mapping(address => Stake[]) public stakes;\\n\\n    // Special address to store global state\\n    address private constant GLOBAL_ACCOUNT = address(0);\\n\\n    /// @dev Voting power integrants for each account\\n    // special case: GLOBAL_ACCOUNT for total voting power\\n    mapping(address => Power) public power;\\n\\n    /// @dev Snapshots of each account\\n    // special case: GLOBAL_ACCOUNT for global snapshots\\n    mapping(address => Snapshot[]) private snapshots;\\n\\n    /// @dev Emitted on a new stake made\\n    event StakeCreated(\\n        address indexed account,\\n        uint256 indexed stakeID,\\n        uint256 amount,\\n        bytes4 stakeType,\\n        uint256 lockedTill\\n    );\\n\\n    /// @dev Emitted on a stake claimed (i.e. \\\"unstaked\\\")\\n    event StakeClaimed(address indexed account, uint256 indexed stakeID);\\n\\n    /// @dev Voting power delegated\\n    event Delegation(\\n        address indexed owner,\\n        address indexed from,\\n        address indexed to,\\n        uint256 stakeID,\\n        uint256 amount\\n    );\\n\\n    /// @dev New terms (for the given stake type) added\\n    event TermsAdded(bytes4 stakeType);\\n\\n    /// @dev Terms (for the given stake type) are disabled\\n    event TermsDisabled(bytes4 stakeType);\\n\\n    /// @dev Call to REWARD_MASTER reverted\\n    event RewardMasterRevert(address staker, uint256 stakeID);\\n\\n    /**\\n     * @notice Sets staking token, owner and\\n     * @param stakingToken - Address of the {ZKPToken} contract\\n     * @param rewardMaster - Address of the {RewardMaster} contract\\n     * @param owner - Address of the owner account\\n     */\\n    constructor(\\n        address stakingToken,\\n        address rewardMaster,\\n        address owner\\n    ) ImmutableOwnable(owner) {\\n        require(\\n            stakingToken != address(0) && rewardMaster != address(0),\\n            \\\"Staking:C1\\\"\\n        );\\n        TOKEN = IErc20Min(stakingToken);\\n        REWARD_MASTER = IActionMsgReceiver(rewardMaster);\\n        START_BLOCK = blockNow();\\n    }\\n\\n    /**\\n     * @notice Stakes tokens\\n     * @dev This contract should be approve()'d for amount\\n     * @param amount - Amount to stake\\n     * @param stakeType - Type of the stake\\n     * @param data - Arbitrary data for \\\"RewardMaster\\\" (zero, if inapplicable)\\n     * @return stake ID\\n     */\\n    function stake(\\n        uint256 amount,\\n        bytes4 stakeType,\\n        bytes calldata data\\n    ) public returns (uint256) {\\n        return _createStake(msg.sender, amount, stakeType, data);\\n    }\\n\\n    /**\\n     * @notice Approves this contract to transfer `amount` tokens from the `msg.sender`\\n     * and stakes these tokens. Only the owner of tokens (i.e. the staker) may call.\\n     * @dev This contract does not need to be approve()'d in advance - see EIP-2612\\n     * @param owner - The owner of tokens being staked (i.e. the `msg.sender`)\\n     * @param amount - Amount to stake\\n     * @param v - \\\"v\\\" param of the signature from `owner` for \\\"permit\\\"\\n     * @param r - \\\"r\\\" param of the signature from `owner` for \\\"permit\\\"\\n     * @param s - \\\"s\\\" param of the signature from `owner` for \\\"permit\\\"\\n     * @param stakeType - Type of the stake\\n     * @param data - Arbitrary data for \\\"RewardMaster\\\" (zero, if inapplicable)\\n     * @return stake ID\\n     */\\n    function permitAndStake(\\n        address owner,\\n        uint256 amount,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s,\\n        bytes4 stakeType,\\n        bytes calldata data\\n    ) external returns (uint256) {\\n        require(owner == msg.sender, \\\"Staking: owner must be msg.sender\\\");\\n        TOKEN.permit(owner, address(this), amount, deadline, v, r, s);\\n        return _createStake(owner, amount, stakeType, data);\\n    }\\n\\n    /**\\n     * @notice Claims staked token\\n     * @param stakeID - ID of the stake to claim\\n     * @param data - Arbitrary data for \\\"RewardMaster\\\" (zero, if inapplicable)\\n     * @param _isForced - Do not revert if \\\"RewardMaster\\\" fails\\n     */\\n    function unstake(\\n        uint256 stakeID,\\n        bytes calldata data,\\n        bool _isForced\\n    ) external stakeExist(msg.sender, stakeID) {\\n        Stake memory _stake = stakes[msg.sender][stakeID];\\n\\n        require(_stake.claimedAt == 0, \\\"Staking: Stake claimed\\\");\\n        require(_stake.lockedTill < safe32TimeNow(), \\\"Staking: Stake locked\\\");\\n\\n        if (_stake.delegatee != address(0)) {\\n            _undelegatePower(_stake.delegatee, msg.sender, _stake.amount);\\n        }\\n        _removePower(msg.sender, _stake.amount);\\n\\n        stakes[msg.sender][stakeID].claimedAt = safe32TimeNow();\\n\\n        totalStaked = safe96(uint256(totalStaked) - uint256(_stake.amount));\\n\\n        emit StakeClaimed(msg.sender, stakeID);\\n\\n        // known contract - reentrancy guard and `safeTransfer` unneeded\\n        require(\\n            TOKEN.transfer(msg.sender, _stake.amount),\\n            \\\"Staking: transfer failed\\\"\\n        );\\n\\n        Terms memory _terms = terms[_stake.stakeType];\\n        if (_terms.isRewarded) {\\n            _sendUnstakedMsg(msg.sender, _stake, data, _isForced);\\n        }\\n    }\\n\\n    /**\\n     * @notice Updates vote delegation\\n     * @param stakeID - ID of the stake to delegate votes uber\\n     * @param to - address to delegate to\\n     */\\n    function delegate(uint256 stakeID, address to)\\n        public\\n        stakeExist(msg.sender, stakeID)\\n    {\\n        require(\\n            to != GLOBAL_ACCOUNT,\\n            \\\"Staking: Can't delegate to GLOBAL_ACCOUNT\\\"\\n        );\\n\\n        Stake memory s = stakes[msg.sender][stakeID];\\n        require(s.claimedAt == 0, \\\"Staking: Stake claimed\\\");\\n        require(s.delegatee != to, \\\"Staking: Already delegated\\\");\\n\\n        if (s.delegatee == address(0)) {\\n            _delegatePower(msg.sender, to, s.amount);\\n        } else {\\n            if (to == msg.sender) {\\n                _undelegatePower(s.delegatee, msg.sender, s.amount);\\n            } else {\\n                _reDelegatePower(s.delegatee, to, s.amount);\\n            }\\n        }\\n\\n        emit Delegation(msg.sender, s.delegatee, to, stakeID, s.amount);\\n\\n        stakes[msg.sender][stakeID].delegatee = to;\\n    }\\n\\n    /**\\n     * @notice Delegates voting power of stake back to self\\n     * @param stakeID - ID of the stake to delegate votes back to self\\n     */\\n    function undelegate(uint256 stakeID) external {\\n        delegate(stakeID, msg.sender);\\n    }\\n\\n    /// @notice Returns number of stakes of given _account\\n    function stakesNum(address _account) external view returns (uint256) {\\n        return stakes[_account].length;\\n    }\\n\\n    /// @notice Returns stakes of given account\\n    function accountStakes(address _account)\\n        external\\n        view\\n        returns (Stake[] memory)\\n    {\\n        Stake[] memory _stakes = stakes[_account];\\n        return _stakes;\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function totalVotingPower() external view override returns (uint256) {\\n        Power memory _power = power[GLOBAL_ACCOUNT];\\n        return _power.own + _power.delegated;\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function totalPower() external view override returns (Power memory) {\\n        return power[GLOBAL_ACCOUNT];\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function latestGlobalsSnapshotBlock()\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return latestSnapshotBlock(GLOBAL_ACCOUNT);\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function latestSnapshotBlock(address _account)\\n        public\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        if (snapshots[_account].length == 0) return 0;\\n\\n        return snapshots[_account][snapshots[_account].length - 1].beforeBlock;\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function globalsSnapshotLength() external view override returns (uint256) {\\n        return snapshots[GLOBAL_ACCOUNT].length;\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function snapshotLength(address _account)\\n        external\\n        view\\n        override\\n        returns (uint256)\\n    {\\n        return snapshots[_account].length;\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function globalsSnapshot(uint256 _index)\\n        external\\n        view\\n        override\\n        returns (Snapshot memory)\\n    {\\n        return snapshots[GLOBAL_ACCOUNT][_index];\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function snapshot(address _account, uint256 _index)\\n        external\\n        view\\n        override\\n        returns (Snapshot memory)\\n    {\\n        return snapshots[_account][_index];\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function globalSnapshotAt(uint256 blockNum, uint256 hint)\\n        external\\n        view\\n        override\\n        returns (Snapshot memory)\\n    {\\n        return _snapshotAt(GLOBAL_ACCOUNT, blockNum, hint);\\n    }\\n\\n    /// @inheritdoc IVotingPower\\n    function snapshotAt(\\n        address _account,\\n        uint256 blockNum,\\n        uint256 hint\\n    ) external view override returns (Snapshot memory) {\\n        return _snapshotAt(_account, blockNum, hint);\\n    }\\n\\n    /// Only for the owner functions\\n\\n    /// @notice Adds a new stake type with given terms\\n    /// @dev May be only called by the {OWNER}\\n    function addTerms(bytes4 stakeType, Terms memory _terms)\\n        external\\n        onlyOwner\\n        nonZeroStakeType(stakeType)\\n    {\\n        Terms memory existingTerms = terms[stakeType];\\n        require(!_isDefinedTerms(existingTerms), \\\"Staking:E1\\\");\\n        require(_terms.isEnabled, \\\"Staking:E2\\\");\\n\\n        uint256 _now = timeNow();\\n\\n        if (_terms.allowedTill != 0) {\\n            require(_terms.allowedTill > _now, \\\"Staking:E3\\\");\\n            require(_terms.allowedTill > _terms.allowedSince, \\\"Staking:E4\\\");\\n        }\\n\\n        if (_terms.maxAmountScaled != 0) {\\n            require(\\n                _terms.maxAmountScaled > _terms.minAmountScaled,\\n                \\\"Staking:E5\\\"\\n            );\\n        }\\n\\n        // only one of three \\\"lock time\\\" parameters must be non-zero\\n        if (_terms.lockedTill != 0) {\\n            require(\\n                _terms.exactLockPeriod == 0 && _terms.minLockPeriod == 0,\\n                \\\"Staking:E6\\\"\\n            );\\n            require(\\n                _terms.lockedTill > _now &&\\n                    _terms.lockedTill >= _terms.allowedTill,\\n                \\\"Staking:E7\\\"\\n            );\\n        } else {\\n            require(\\n                // one of two params must be non-zero\\n                (_terms.exactLockPeriod == 0) != (_terms.minLockPeriod == 0),\\n                \\\"Staking:E8\\\"\\n            );\\n        }\\n\\n        terms[stakeType] = _terms;\\n        emit TermsAdded(stakeType);\\n    }\\n\\n    function disableTerms(bytes4 stakeType)\\n        external\\n        onlyOwner\\n        nonZeroStakeType(stakeType)\\n    {\\n        Terms memory _terms = terms[stakeType];\\n        require(_isDefinedTerms(terms[stakeType]), \\\"Staking:E9\\\");\\n        require(_terms.isEnabled, \\\"Staking:EA\\\");\\n\\n        terms[stakeType].isEnabled = false;\\n        emit TermsDisabled(stakeType);\\n    }\\n\\n    /// Internal and private functions follow\\n\\n    function _createStake(\\n        address staker,\\n        uint256 amount,\\n        bytes4 stakeType,\\n        bytes calldata data\\n    ) internal nonZeroStakeType(stakeType) returns (uint256) {\\n        Terms memory _terms = terms[stakeType];\\n        require(_terms.isEnabled, \\\"Staking: Terms unknown or disabled\\\");\\n\\n        require(amount > 0, \\\"Staking: Amount not set\\\");\\n        uint256 _totalStake = amount + uint256(totalStaked);\\n        require(_totalStake < 2**96, \\\"Staking: Too big amount\\\");\\n\\n        require(\\n            _terms.minAmountScaled == 0 ||\\n                amount >= SCALE * _terms.minAmountScaled,\\n            \\\"Staking: Too small amount\\\"\\n        );\\n        require(\\n            _terms.maxAmountScaled == 0 ||\\n                amount <= SCALE * _terms.maxAmountScaled,\\n            \\\"Staking: Too large amount\\\"\\n        );\\n\\n        uint32 _now = safe32TimeNow();\\n        require(\\n            _terms.allowedSince == 0 || _now >= _terms.allowedSince,\\n            \\\"Staking: Not yet allowed\\\"\\n        );\\n        require(\\n            _terms.allowedTill == 0 || _terms.allowedTill > _now,\\n            \\\"Staking: Not allowed anymore\\\"\\n        );\\n\\n        // known contract - reentrancy guard and `safeTransferFrom` unneeded\\n        require(\\n            TOKEN.transferFrom(staker, address(this), amount),\\n            \\\"Staking: transferFrom failed\\\"\\n        );\\n\\n        uint256 stakeID = stakes[staker].length;\\n\\n        uint32 lockedTill = _terms.lockedTill;\\n        if (lockedTill == 0) {\\n            uint256 period = _terms.exactLockPeriod == 0\\n                ? _terms.minLockPeriod\\n                : _terms.exactLockPeriod;\\n            lockedTill = safe32(period + _now);\\n        }\\n\\n        Stake memory _stake = Stake(\\n            uint32(stakeID), // overflow risk ignored\\n            stakeType,\\n            _now, // stakedAt\\n            lockedTill,\\n            0, // claimedAt\\n            uint96(amount),\\n            address(0) // no delegatee\\n        );\\n        stakes[staker].push(_stake);\\n\\n        totalStaked = uint96(_totalStake);\\n        _addPower(staker, amount);\\n\\n        emit StakeCreated(staker, stakeID, amount, stakeType, lockedTill);\\n\\n        if (_terms.isRewarded) {\\n            _sendStakedMsg(staker, _stake, data);\\n        }\\n        return stakeID;\\n    }\\n\\n    function _addPower(address to, uint256 amount) private {\\n        _takeSnapshot(GLOBAL_ACCOUNT);\\n        _takeSnapshot(to);\\n        power[GLOBAL_ACCOUNT].own += uint96(amount);\\n        power[to].own += uint96(amount);\\n    }\\n\\n    function _removePower(address from, uint256 amount) private {\\n        _takeSnapshot(GLOBAL_ACCOUNT);\\n        _takeSnapshot(from);\\n        power[GLOBAL_ACCOUNT].own -= uint96(amount);\\n        power[from].own -= uint96(amount);\\n    }\\n\\n    function _delegatePower(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        _takeSnapshot(GLOBAL_ACCOUNT);\\n        _takeSnapshot(to);\\n        _takeSnapshot(from);\\n        power[GLOBAL_ACCOUNT].own -= uint96(amount);\\n        power[from].own -= uint96(amount);\\n        power[GLOBAL_ACCOUNT].delegated += uint96(amount);\\n        power[to].delegated += uint96(amount);\\n    }\\n\\n    function _reDelegatePower(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        _takeSnapshot(to);\\n        _takeSnapshot(from);\\n        power[from].delegated -= uint96(amount);\\n        power[to].delegated += uint96(amount);\\n    }\\n\\n    function _undelegatePower(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) private {\\n        power[GLOBAL_ACCOUNT].delegated -= uint96(amount);\\n        power[from].delegated -= uint96(amount);\\n        power[GLOBAL_ACCOUNT].own += uint96(amount);\\n        power[to].own += uint96(amount);\\n    }\\n\\n    function _takeSnapshot(address _account) internal {\\n        uint32 curBlockNum = safe32BlockNow();\\n        if (latestSnapshotBlock(_account) < curBlockNum) {\\n            // make new snapshot as the latest one taken before current block\\n            snapshots[_account].push(\\n                Snapshot(\\n                    curBlockNum,\\n                    power[_account].own,\\n                    power[_account].delegated\\n                )\\n            );\\n        }\\n    }\\n\\n    function _snapshotAt(\\n        address _account,\\n        uint256 blockNum,\\n        uint256 hint\\n    ) internal view returns (Snapshot memory) {\\n        _sanitizeBlockNum(blockNum);\\n\\n        Snapshot[] storage snapshotsInfo = snapshots[_account];\\n\\n        if (\\n            // hint is correct?\\n            hint <= snapshotsInfo.length &&\\n            (hint == 0 || snapshotsInfo[hint - 1].beforeBlock < blockNum) &&\\n            (hint == snapshotsInfo.length ||\\n                snapshotsInfo[hint].beforeBlock >= blockNum)\\n        ) {\\n            // yes, return the hinted snapshot\\n            if (hint < snapshotsInfo.length) {\\n                return snapshotsInfo[hint];\\n            } else {\\n                return\\n                    Snapshot(\\n                        uint32(blockNum),\\n                        power[_account].own,\\n                        power[_account].delegated\\n                    );\\n            }\\n        }\\n        // no, fall back to binary search\\n        else return _snapshotAt(_account, blockNum);\\n    }\\n\\n    function _snapshotAt(address _account, uint256 blockNum)\\n        internal\\n        view\\n        returns (Snapshot memory)\\n    {\\n        _sanitizeBlockNum(blockNum);\\n\\n        // https://en.wikipedia.org/wiki/Binary_search_algorithm\\n        Snapshot[] storage snapshotsInfo = snapshots[_account];\\n        uint256 index;\\n        uint256 low = 0;\\n        uint256 high = snapshotsInfo.length;\\n\\n        while (low < high) {\\n            uint256 mid = (low + high) / 2;\\n\\n            if (snapshotsInfo[mid].beforeBlock > blockNum) {\\n                high = mid;\\n            } else {\\n                low = mid + 1;\\n            }\\n        }\\n\\n        // `low` is the exclusive upper bound. Find the inclusive upper bounds and set to index\\n        if (low > 0 && snapshotsInfo[low - 1].beforeBlock == blockNum) {\\n            return snapshotsInfo[low - 1];\\n        } else {\\n            index = low;\\n        }\\n\\n        // If index is equal to snapshot array length, then no update made after the requested blockNum.\\n        // This means the latest value is the right one.\\n        if (index == snapshotsInfo.length) {\\n            return\\n                Snapshot(\\n                    uint32(blockNum),\\n                    uint96(power[_account].own),\\n                    uint96(power[_account].delegated)\\n                );\\n        } else {\\n            return snapshotsInfo[index];\\n        }\\n    }\\n\\n    function _sanitizeBlockNum(uint256 blockNum) private view {\\n        require(blockNum <= safe32BlockNow(), \\\"Staking: Too big block number\\\");\\n    }\\n\\n    function _isDefinedTerms(Terms memory _terms) internal pure returns (bool) {\\n        return\\n            (_terms.minLockPeriod != 0) ||\\n            (_terms.exactLockPeriod != 0) ||\\n            (_terms.lockedTill != 0);\\n    }\\n\\n    function _sendStakedMsg(\\n        address staker,\\n        Stake memory _stake,\\n        bytes calldata data\\n    ) internal {\\n        bytes4 action = _encodeStakeActionType(_stake.stakeType);\\n        bytes memory message = _packStakingActionMsg(staker, _stake, data);\\n        // known contract - reentrancy guard unneeded\\n        // solhint-disable-next-line no-empty-blocks\\n        try REWARD_MASTER.onAction(action, message) {} catch {\\n            revert(\\\"Staking: onStake msg failed\\\");\\n        }\\n    }\\n\\n    function _sendUnstakedMsg(\\n        address staker,\\n        Stake memory _stake,\\n        bytes calldata data,\\n        bool _isForced\\n    ) internal {\\n        bytes4 action = _encodeUnstakeActionType(_stake.stakeType);\\n        bytes memory message = _packStakingActionMsg(staker, _stake, data);\\n        // known contract - reentrancy guard unneeded\\n        // solhint-disable-next-line no-empty-blocks\\n        try REWARD_MASTER.onAction(action, message) {} catch {\\n            emit RewardMasterRevert(staker, _stake.id);\\n            // REWARD_MASTER must be unable to revert forced calls\\n            require(_isForced, \\\"Staking: REWARD_MASTER reverts\\\");\\n        }\\n    }\\n\\n    modifier stakeExist(address staker, uint256 stakeID) {\\n        require(\\n            stakes[staker].length > stakeID,\\n            \\\"Staking: Stake doesn't exist\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier nonZeroStakeType(bytes4 stakeType) {\\n        require(stakeType != bytes4(0), \\\"Staking: Invalid stake type 0\\\");\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/actions/StakingMsgProcessor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IStakingTypes.sol\\\";\\n\\nabstract contract StakingMsgProcessor {\\n    bytes4 internal constant STAKE_ACTION = bytes4(keccak256(\\\"stake\\\"));\\n    bytes4 internal constant UNSTAKE_ACTION = bytes4(keccak256(\\\"unstake\\\"));\\n\\n    function _encodeStakeActionType(bytes4 stakeType)\\n        internal\\n        pure\\n        returns (bytes4)\\n    {\\n        return bytes4(keccak256(abi.encodePacked(STAKE_ACTION, stakeType)));\\n    }\\n\\n    function _encodeUnstakeActionType(bytes4 stakeType)\\n        internal\\n        pure\\n        returns (bytes4)\\n    {\\n        return bytes4(keccak256(abi.encodePacked(UNSTAKE_ACTION, stakeType)));\\n    }\\n\\n    function _packStakingActionMsg(\\n        address staker,\\n        IStakingTypes.Stake memory stake,\\n        bytes calldata data\\n    ) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(\\n                staker, // address\\n                stake.amount, // uint96\\n                stake.id, // uint32\\n                stake.stakedAt, // uint32\\n                stake.lockedTill, // uint32\\n                stake.claimedAt, // uint32\\n                data // bytes\\n            );\\n    }\\n\\n    // For efficiency we use \\\"packed\\\" (rather than \\\"ABI\\\") encoding.\\n    // It results in shorter data, but requires custom unpack function.\\n    function _unpackStakingActionMsg(bytes memory message)\\n        internal\\n        pure\\n        returns (\\n            address staker,\\n            uint96 amount,\\n            uint32 id,\\n            uint32 stakedAt,\\n            uint32 lockedTill,\\n            uint32 claimedAt,\\n            bytes memory data\\n        )\\n    {\\n        // staker, amount, id and 3 timestamps occupy exactly 48 bytes\\n        // (`data` may be of zero length)\\n        require(message.length >= 48, \\\"SMP: unexpected msg length\\\");\\n\\n        uint256 stakerAndAmount;\\n        uint256 idAndStamps;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            // the 1st word (32 bytes) contains the `message.length`\\n            // we need the (entire) 2nd word ..\\n            stakerAndAmount := mload(add(message, 0x20))\\n            // .. and (16 bytes of) the 3rd word\\n            idAndStamps := mload(add(message, 0x40))\\n        }\\n\\n        staker = address(uint160(stakerAndAmount >> 96));\\n        amount = uint96(stakerAndAmount & 0xFFFFFFFFFFFFFFFFFFFFFFFF);\\n\\n        id = uint32((idAndStamps >> 224) & 0xFFFFFFFF);\\n        stakedAt = uint32((idAndStamps >> 192) & 0xFFFFFFFF);\\n        lockedTill = uint32((idAndStamps >> 160) & 0xFFFFFFFF);\\n        claimedAt = uint32((idAndStamps >> 128) & 0xFFFFFFFF);\\n\\n        uint256 dataLength = message.length - 48;\\n        data = new bytes(dataLength);\\n        for (uint256 i = 0; i < dataLength; i++) {\\n            data[i] = message[i + 48];\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IActionMsgReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IActionMsgReceiver {\\n    function onAction(bytes4 action, bytes memory message) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IErc20Min.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IErc20Min {\\n    /// @dev ERC-20 `balanceOf`\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /// @dev ERC-20 `transfer`\\n    function transfer(address recipient, uint256 amount)\\n        external\\n        returns (bool);\\n\\n    /// @dev ERC-20 `transferFrom`\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /// @dev EIP-2612 `permit`\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IStakingTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\ninterface IStakingTypes {\\n    // Stake type terms\\n    struct Terms {\\n        // if stakes of this kind allowed\\n        bool isEnabled;\\n        // if messages on stakes to be sent to the {RewardMaster}\\n        bool isRewarded;\\n        // limit on the minimum amount staked, no limit if zero\\n        uint32 minAmountScaled;\\n        // limit on the maximum amount staked, no limit if zero\\n        uint32 maxAmountScaled;\\n        // Stakes not accepted before this time, has no effect if zero\\n        uint32 allowedSince;\\n        // Stakes not accepted after this time, has no effect if zero\\n        uint32 allowedTill;\\n        // One (at least) of the following three params must be non-zero\\n        // if non-zero, overrides both `exactLockPeriod` and `minLockPeriod`\\n        uint32 lockedTill;\\n        // ignored if non-zero `lockedTill` defined, overrides `minLockPeriod`\\n        uint32 exactLockPeriod;\\n        // has effect only if both `lockedTill` and `exactLockPeriod` are zero\\n        uint32 minLockPeriod;\\n    }\\n\\n    struct Stake {\\n        // index in the `Stake[]` array of `stakes`\\n        uint32 id;\\n        // defines Terms\\n        bytes4 stakeType;\\n        // time this stake was created at\\n        uint32 stakedAt;\\n        // time this stake can be claimed at\\n        uint32 lockedTill;\\n        // time this stake was claimed at (unclaimed if 0)\\n        uint32 claimedAt;\\n        // amount of tokens on this stake (assumed to be less 1e27)\\n        uint96 amount;\\n        // address stake voting power is delegated to\\n        address delegatee;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVotingPower.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title IStaking\\ninterface IVotingPower {\\n    struct Snapshot {\\n        uint32 beforeBlock;\\n        uint96 ownPower;\\n        uint96 delegatedPower;\\n    }\\n\\n    /// @dev Voting power integrants\\n    struct Power {\\n        uint96 own; // voting power that remains after delegating to others\\n        uint96 delegated; // voting power delegated by others\\n    }\\n\\n    /// @notice Returns total voting power staked\\n    /// @dev \\\"own\\\" and \\\"delegated\\\" voting power summed up\\n    function totalVotingPower() external view returns (uint256);\\n\\n    /// @notice Returns total \\\"own\\\" and total \\\"delegated\\\" voting power separately\\n    /// @dev Useful, if \\\"own\\\" and \\\"delegated\\\" voting power treated differently\\n    function totalPower() external view returns (Power memory);\\n\\n    /// @notice Returns global snapshot for given block\\n    /// @param blockNum - block number to get state at\\n    /// @param hint - off-chain computed index of the required snapshot\\n    function globalSnapshotAt(uint256 blockNum, uint256 hint)\\n        external\\n        view\\n        returns (Snapshot memory);\\n\\n    /// @notice Returns snapshot on given block for given account\\n    /// @param _account - account to get snapshot for\\n    /// @param blockNum - block number to get state at\\n    /// @param hint - off-chain computed index of the required snapshot\\n    function snapshotAt(\\n        address _account,\\n        uint256 blockNum,\\n        uint256 hint\\n    ) external view returns (Snapshot memory);\\n\\n    /// @dev Returns block number of the latest global snapshot\\n    function latestGlobalsSnapshotBlock() external view returns (uint256);\\n\\n    /// @dev Returns block number of the given account latest snapshot\\n    function latestSnapshotBlock(address _account)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /// @dev Returns number of global snapshots\\n    function globalsSnapshotLength() external view returns (uint256);\\n\\n    /// @dev Returns number of snapshots for given account\\n    function snapshotLength(address _account) external view returns (uint256);\\n\\n    /// @dev Returns global snapshot at given index\\n    function globalsSnapshot(uint256 _index)\\n        external\\n        view\\n        returns (Snapshot memory);\\n\\n    /// @dev Returns snapshot at given index for given account\\n    function snapshot(address _account, uint256 _index)\\n        external\\n        view\\n        returns (Snapshot memory);\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ImmutableOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\n/// @title Staking\\nabstract contract ImmutableOwnable {\\n    /// @notice The owner who has privileged rights\\n    // solhint-disable-next-line var-name-mixedcase\\n    address public immutable OWNER;\\n\\n    /// @dev Throws if called by any account other than the {OWNER}.\\n    modifier onlyOwner() {\\n        require(OWNER == msg.sender, \\\"ImmOwn: unauthorized\\\");\\n        _;\\n    }\\n\\n    constructor(address _owner) {\\n        require(_owner != address(0), \\\"ImmOwn: zero owner address\\\");\\n        OWNER = _owner;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Utils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-fixed, compiler-gt-0_8\\npragma solidity ^0.8.0;\\n\\nabstract contract Utils {\\n    function safe32(uint256 n) internal pure returns (uint32) {\\n        require(n < 2**32, \\\"UNSAFE32\\\");\\n        return uint32(n);\\n    }\\n\\n    function safe96(uint256 n) internal pure returns (uint96) {\\n        require(n < 2**96, \\\"UNSAFE96\\\");\\n        return uint96(n);\\n    }\\n\\n    function safe128(uint256 n) internal pure returns (uint128) {\\n        require(n < 2**128, \\\"UNSAFE128\\\");\\n        return uint128(n);\\n    }\\n\\n    function safe160(uint256 n) internal pure returns (uint160) {\\n        require(n < 2**160, \\\"UNSAFE160\\\");\\n        return uint160(n);\\n    }\\n\\n    function safe32TimeNow() internal view returns (uint32) {\\n        return safe32(timeNow());\\n    }\\n\\n    function safe32BlockNow() internal view returns (uint32) {\\n        return safe32(blockNow());\\n    }\\n\\n    /// @dev Returns the current block timestamp (added to ease testing)\\n    function timeNow() internal view virtual returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /// @dev Returns the current block number (added to ease testing)\\n    function blockNow() internal view virtual returns (uint256) {\\n        return block.number;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 800\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"stakingToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardMaster\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Delegation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"RewardMasterRevert\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"StakeClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedTill\",\"type\":\"uint256\"}],\"name\":\"StakeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"}],\"name\":\"TermsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"}],\"name\":\"TermsDisabled\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"OWNER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REWARD_MASTER\",\"outputs\":[{\"internalType\":\"contract IActionMsgReceiver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"START_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKEN\",\"outputs\":[{\"internalType\":\"contract IErc20Min\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"accountStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"},{\"internalType\":\"uint32\",\"name\":\"stakedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lockedTill\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"claimedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"internalType\":\"struct IStakingTypes.Stake[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"},{\"components\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRewarded\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"minAmountScaled\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxAmountScaled\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"allowedSince\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"allowedTill\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lockedTill\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exactLockPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minLockPeriod\",\"type\":\"uint32\"}],\"internalType\":\"struct IStakingTypes.Terms\",\"name\":\"_terms\",\"type\":\"tuple\"}],\"name\":\"addTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"}],\"name\":\"disableTerms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hint\",\"type\":\"uint256\"}],\"name\":\"globalSnapshotAt\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"beforeBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"ownPower\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"delegatedPower\",\"type\":\"uint96\"}],\"internalType\":\"struct IVotingPower.Snapshot\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"globalsSnapshot\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"beforeBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"ownPower\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"delegatedPower\",\"type\":\"uint96\"}],\"internalType\":\"struct IVotingPower.Snapshot\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalsSnapshotLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestGlobalsSnapshotBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"latestSnapshotBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"permitAndStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"power\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"own\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"delegated\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"snapshot\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"beforeBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"ownPower\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"delegatedPower\",\"type\":\"uint96\"}],\"internalType\":\"struct IVotingPower.Snapshot\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockNum\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hint\",\"type\":\"uint256\"}],\"name\":\"snapshotAt\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"beforeBlock\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"ownPower\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"delegatedPower\",\"type\":\"uint96\"}],\"internalType\":\"struct IVotingPower.Snapshot\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"snapshotLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"stake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"bytes4\",\"name\":\"stakeType\",\"type\":\"bytes4\"},{\"internalType\":\"uint32\",\"name\":\"stakedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lockedTill\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"claimedAt\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"amount\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"delegatee\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"stakesNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"terms\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isEnabled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isRewarded\",\"type\":\"bool\"},{\"internalType\":\"uint32\",\"name\":\"minAmountScaled\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"maxAmountScaled\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"allowedSince\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"allowedTill\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"lockedTill\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exactLockPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"minLockPeriod\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPower\",\"outputs\":[{\"components\":[{\"internalType\":\"uint96\",\"name\":\"own\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"delegated\",\"type\":\"uint96\"}],\"internalType\":\"struct IVotingPower.Power\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVotingPower\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"}],\"name\":\"undelegate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeID\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"_isForced\",\"type\":\"bool\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Staking", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "800", "ConstructorArguments": "0000000000000000000000009a06db14d639796b25a6cec6a1bf614fd98815ec00000000000000000000000009220dd0c342ee92c333faa6879984d63b4dff03000000000000000000000000208fb9169bbec5915722e0aff8b0eeedabf8a6f0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}