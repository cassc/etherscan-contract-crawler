{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"StatsFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibUnicornDNA} from \\\"LibUnicornDNA.sol\\\";\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibStats} from \\\"LibStats.sol\\\";\\nimport {LibERC721} from \\\"LibERC721.sol\\\";\\nimport {ITwTUnicornInfo} from \\\"ITwTUnicornInfo.sol\\\";\\n\\ncontract StatsFacet is ITwTUnicornInfo {\\n\\n    //  TODO: move _deriveStat into a library and convert all of these functions\\n    function getAttack(uint256 _dna) public view returns (uint256) {\\n        return _deriveStat(_dna, LibUnicornDNA.STAT_ATTACK);\\n    }\\n\\n    function getAccuracy(uint256 _dna) public view returns (uint256) {\\n        return _deriveStat(_dna, LibUnicornDNA.STAT_ACCURACY);\\n    }\\n\\n    function getMovementSpeed(uint256 _dna) public view returns (uint256) {\\n        return _deriveStat(_dna, LibUnicornDNA.STAT_MOVE_SPEED);\\n    }\\n\\n    function getAttackSpeed(uint256 _dna) public view returns (uint256) {\\n        return _deriveStat(_dna, LibUnicornDNA.STAT_ATTACK_SPEED);\\n    }\\n\\n    function getDefense(uint256 _dna) public view returns (uint256) {\\n        return _deriveStat(_dna, LibUnicornDNA.STAT_DEFENSE);\\n    }\\n\\n    function getVitality(uint256 _dna) public view returns (uint256) {\\n        return _deriveStat(_dna, LibUnicornDNA.STAT_VITALITY);\\n    }\\n\\n    function getResistance(uint256 _dna) public view returns (uint256) {\\n        return _deriveStat(_dna, LibUnicornDNA.STAT_RESISTANCE);\\n    }\\n\\n    function getMagic(uint256 _dna) public view returns (uint256) {\\n        return _deriveStat(_dna, LibUnicornDNA.STAT_MAGIC);\\n    }\\n\\n    function getUnicornMetadata(uint256 _tokenId)\\n        external\\n        view\\n        returns (\\n            bool origin,\\n            bool gameLocked,\\n            bool limitedEdition,\\n            uint256 lifecycleStage,\\n            uint256 breedingPoints,\\n            uint256 unicornClass,\\n            uint256 hatchBirthday\\n        )\\n    {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 dna = LibUnicornDNA._getDNA(_tokenId);\\n        LibUnicornDNA.enforceDNAVersionMatch(dna);\\n        origin = LibUnicornDNA._getOrigin(dna);\\n        gameLocked = LibUnicornDNA._getGameLocked(dna);\\n        limitedEdition = LibUnicornDNA._getLimitedEdition(dna);\\n        lifecycleStage = LibUnicornDNA._getLifecycleStage(dna);\\n        breedingPoints = LibUnicornDNA._getBreedingPoints(dna);\\n        unicornClass = LibUnicornDNA._getClass(dna);\\n        hatchBirthday = LibUnicornDNA._getBirthday(_tokenId);\\n    }\\n\\n    function getUnicornBodyParts(uint256 _dna)\\n        external\\n        view\\n        returns (\\n            uint256 bodyPartId,\\n            uint256 facePartId,\\n            uint256 hornPartId,\\n            uint256 hoovesPartId,\\n            uint256 manePartId,\\n            uint256 tailPartId,\\n            uint8 mythicCount\\n        )\\n    {\\n        LibUnicornDNA.enforceDNAVersionMatch(_dna);\\n\\n        if(LibUnicornDNA._getLifecycleStage(_dna) == LibUnicornDNA.LIFECYCLE_EGG) {\\n            return (0, 0, 0, 0, 0, 0, 0);\\n        }\\n\\n        uint8 classId = LibUnicornDNA._getClass(_dna);\\n        (bodyPartId, facePartId, hornPartId, hoovesPartId, manePartId, tailPartId) = getUnicornBodyPartIds(_dna, classId);\\n        mythicCount = getMythicPartCount(bodyPartId, facePartId, hornPartId, hoovesPartId, manePartId, tailPartId);\\n    }\\n\\n    function getMythicPartCount(uint256 bodyPartId, uint256 facePartId, uint256 hoovesPartId, uint256 hornPartId, uint256 manePartId, uint256 tailPartId) internal view returns (uint8 mythicCount) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        if (ds.bodyPartIsMythic[bodyPartId]) ++mythicCount;\\n        if (ds.bodyPartIsMythic[facePartId]) ++mythicCount;\\n        if (ds.bodyPartIsMythic[hoovesPartId]) ++mythicCount;\\n        if (ds.bodyPartIsMythic[hornPartId]) ++mythicCount;\\n        if (ds.bodyPartIsMythic[manePartId]) ++mythicCount;\\n        if (ds.bodyPartIsMythic[tailPartId]) ++mythicCount;\\n    }\\n\\n    function getUnicornBodyPartsLocal(uint256 _dna)\\n        external\\n        view\\n        returns (\\n            uint256 bodyPartLocalId,\\n            uint256 facePartLocalId,\\n            uint256 hornPartLocalId,\\n            uint256 hoovesPartLocalId,\\n            uint256 manePartLocalId,\\n            uint256 tailPartLocalId\\n        )\\n    {\\n        LibUnicornDNA.enforceDNAVersionMatch(_dna);\\n        bodyPartLocalId = LibUnicornDNA._getBodyPart(_dna);\\n        facePartLocalId = LibUnicornDNA._getFacePart(_dna);\\n        hoovesPartLocalId = LibUnicornDNA._getHoovesPart(_dna);\\n        hornPartLocalId = LibUnicornDNA._getHornPart(_dna);\\n        manePartLocalId = LibUnicornDNA._getManePart(_dna);\\n        tailPartLocalId = LibUnicornDNA._getTailPart(_dna);\\n    }\\n\\n    function getStats(uint256 _dna)\\n        external\\n        view\\n        returns (\\n            uint256 attack,\\n            uint256 accuracy,\\n            uint256 movementSpeed,\\n            uint256 attackSpeed,\\n            uint256 defense,\\n            uint256 vitality,\\n            uint256 resistance,\\n            uint256 magic\\n        )\\n    {\\n        attack = getAttack(_dna);\\n        accuracy = getAccuracy(_dna);\\n        movementSpeed = getMovementSpeed(_dna);\\n        attackSpeed = getAttackSpeed(_dna);\\n        defense = getDefense(_dna);\\n        vitality = getVitality(_dna);\\n        resistance = getResistance(_dna);\\n        magic = getMagic(_dna);\\n    }\\n\\n    function _deriveStat(uint256 _dna, uint256 _statId)\\n        internal\\n        view\\n        returns (uint256)\\n    {\\n        LibUnicornDNA.enforceDNAVersionMatch(_dna);\\n        require(\\n            LibUnicornDNA._getLifecycleStage(_dna) ==\\n                LibUnicornDNA.LIFECYCLE_ADULT ||\\n                LibUnicornDNA._getLifecycleStage(_dna) ==\\n                LibUnicornDNA.LIFECYCLE_BABY,\\n            \\\"LibStats: Invalid DNA Lifecycle Stage, must be baby or adult\\\"\\n        );\\n\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 class = LibUnicornDNA._getClass(_dna);\\n        uint256 statBase = ds.baseStats[class][_statId];\\n\\n        if (\\n            LibUnicornDNA._getLifecycleStage(_dna) ==\\n            LibUnicornDNA.LIFECYCLE_ADULT\\n        ) {\\n            statBase += (statBase / 5); //  add 20%\\n        }\\n\\n        uint256[] memory geneId = new uint256[](18);\\n\\n        geneId[0] = LibUnicornDNA._getBodyMajorGene(_dna);\\n        geneId[1] = LibUnicornDNA._getBodyMidGene(_dna);\\n        geneId[2] = LibUnicornDNA._getBodyMinorGene(_dna);\\n\\n        geneId[3] = LibUnicornDNA._getFaceMajorGene(_dna);\\n        geneId[4] = LibUnicornDNA._getFaceMidGene(_dna);\\n        geneId[5] = LibUnicornDNA._getFaceMinorGene(_dna);\\n\\n        geneId[6] = LibUnicornDNA._getHoovesMajorGene(_dna);\\n        geneId[7] = LibUnicornDNA._getHoovesMidGene(_dna);\\n        geneId[8] = LibUnicornDNA._getHoovesMinorGene(_dna);\\n\\n        geneId[9] = LibUnicornDNA._getHornMajorGene(_dna);\\n        geneId[10] = LibUnicornDNA._getHornMidGene(_dna);\\n        geneId[11] = LibUnicornDNA._getHornMinorGene(_dna);\\n\\n        geneId[12] = LibUnicornDNA._getManeMajorGene(_dna);\\n        geneId[13] = LibUnicornDNA._getManeMidGene(_dna);\\n        geneId[14] = LibUnicornDNA._getManeMinorGene(_dna);\\n\\n        geneId[15] = LibUnicornDNA._getTailMajorGene(_dna);\\n        geneId[16] = LibUnicornDNA._getTailMidGene(_dna);\\n        geneId[17] = LibUnicornDNA._getTailMinorGene(_dna);\\n\\n        uint256 addition = 0;\\n        uint256 multiplier = 0;\\n\\n        for (uint256 i = 0; i < 18; ++i) {\\n            for (uint256 j = 1; j <= 3; ++j) {\\n                if (ds.geneBonusStatByGeneId[geneId[i]][j] == _statId) {\\n                    if (ds.geneApplicationById[geneId[i]] == 1) {\\n                        multiplier += ds.geneBonusValueByGeneId[geneId[i]][j];\\n                    } else if (ds.geneApplicationById[geneId[i]] == 2) {\\n                        addition += ds.geneBonusValueByGeneId[geneId[i]][j];\\n                    }\\n                }\\n            }\\n        }\\n\\n        uint256 stat = statBase + addition;\\n        stat += ((stat * multiplier) / 100);\\n        return (stat <= 1000) ? stat : 1000;\\n    }\\n\\n    function getPowerScore(uint256 tokenId) public view returns (uint256) {\\n        uint256 dna = LibUnicornDNA._getDNA(tokenId);\\n        uint256 attack = getAttack(dna);\\n        uint256 accuracy = getAccuracy(dna);\\n        return LibStats.getPowerScore(attack, accuracy);\\n    }\\n\\n    function getSpeedScore(uint256 tokenId) public view returns (uint256) {\\n        uint256 dna = LibUnicornDNA._getDNA(tokenId);\\n        uint256 movementSpeed = getMovementSpeed(dna);\\n        uint256 attackSpeed = getAttackSpeed(dna);\\n        return LibStats.getSpeedScore(movementSpeed, attackSpeed);\\n    }\\n\\n    function getEnduranceScore(uint256 tokenId) public view returns (uint256) {\\n        uint256 dna = LibUnicornDNA._getDNA(tokenId);\\n        uint256 vitality = getVitality(dna);\\n        uint256 defense = getDefense(dna);\\n        return LibStats.getEnduranceScore(vitality, defense);\\n    }\\n\\n    function getIntelligenceScore(uint256 tokenId) public view returns (uint256) {\\n        uint256 dna = LibUnicornDNA._getDNA(tokenId);\\n        uint256 magic = getMagic(dna);\\n        uint256 resistance = getResistance(dna);\\n        return LibStats.getIntelligenceScore(magic, resistance);\\n    }\\n\\n    function twtGetUnicornInfoMultiple(uint256[3] memory tokenIds, uint256[] memory relevantStats, address user) external view returns (ITwTUnicornInfo.TwTUnicornInfo[] memory unicornInfo) {\\n        unicornInfo = new ITwTUnicornInfo.TwTUnicornInfo[](tokenIds.length);\\n        for(uint256 i = 0; i < tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n            uint256 dna = LibUnicornDNA._getDNA(tokenId);\\n            uint8 class = LibUnicornDNA._getClass(dna);\\n\\n            ITwTUnicornInfo.TwTUnicornInfo memory twtUnicornInfo = ITwTUnicornInfo.TwTUnicornInfo(\\n                {\\n                    belongsToUser: LibERC721.ownerOf(tokenId) == user,\\n                    isTransferrable: LibERC721.unicornIsTransferable(tokenId),\\n                    isGenesis: LibUnicornDNA._getOrigin(dna),\\n                    isAdult: LibUnicornDNA._getLifecycleStage(dna) == LibUnicornDNA.LIFECYCLE_ADULT,\\n                    amountOfMythicParts: getMythicAmountByDnaAndClass(dna, class),\\n                    class: class,\\n                    statsValues: deriveStats(relevantStats, dna)\\n                }\\n            );\\n            unicornInfo[i] = twtUnicornInfo;\\n        }\\n    }\\n\\n    function deriveStats(uint256[] memory relevantStats, uint256 dna) internal view returns (uint256[] memory statsValues) {\\n        statsValues = new uint256[](relevantStats.length);\\n        for(uint256 i = 0; i < relevantStats.length; i++) {\\n            statsValues[i] = _deriveStat(dna, relevantStats[i]);\\n        }\\n    }\\n\\n    function getMythicAmountByDnaAndClass(uint256 dna, uint8 class) internal view returns (uint8 mythicCount) {\\n        (uint256 bodyPartId, uint256 facePartId, uint256 hornPartId, uint256 hoovesPartId, uint256 manePartId, uint256 tailPartId) = getUnicornBodyPartIds(dna, class);\\n        mythicCount = getMythicPartCount(bodyPartId, facePartId, hornPartId, hoovesPartId, manePartId, tailPartId);\\n    }\\n\\n    function getUnicornBodyPartIds(uint256 _dna, uint8 class) internal view returns (uint256 bodyPartId, uint256 facePartId, uint256 hornPartId, uint256 hoovesPartId, uint256 manePartId, uint256 tailPartId) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        bodyPartId = ds.bodyPartGlobalIdFromLocalId[class][1][\\n            LibUnicornDNA._getBodyPart(_dna)\\n        ];\\n        facePartId = ds.bodyPartGlobalIdFromLocalId[class][2][\\n            LibUnicornDNA._getFacePart(_dna)\\n        ];\\n        hornPartId = ds.bodyPartGlobalIdFromLocalId[class][3][\\n            LibUnicornDNA._getHornPart(_dna)\\n        ];\\n        hoovesPartId = ds.bodyPartGlobalIdFromLocalId[class][4][\\n            LibUnicornDNA._getHoovesPart(_dna)\\n        ];\\n        manePartId = ds.bodyPartGlobalIdFromLocalId[class][5][\\n            LibUnicornDNA._getManePart(_dna)\\n        ];\\n        tailPartId = ds.bodyPartGlobalIdFromLocalId[class][6][\\n            LibUnicornDNA._getTailPart(_dna)\\n        ];\\n    }\\n}\\n\"\r\n    },\r\n    \"LibUnicornDNA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibBin} from \\\"LibBin.sol\\\";\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibHatching} from \\\"LibHatching.sol\\\";\\n\\n\\nlibrary LibUnicornDNA {\\n    event DNAUpdated(uint256 tokenId, uint256 dna);\\n\\n    uint256 internal constant STAT_ATTACK = 1;\\n    uint256 internal constant STAT_ACCURACY = 2;\\n    uint256 internal constant STAT_MOVE_SPEED = 3;\\n    uint256 internal constant STAT_ATTACK_SPEED = 4;\\n    uint256 internal constant STAT_DEFENSE = 5;\\n    uint256 internal constant STAT_VITALITY = 6;\\n    uint256 internal constant STAT_RESISTANCE = 7;\\n    uint256 internal constant STAT_MAGIC = 8;\\n\\n    // uint256 internal constant DNA_VERSION = 1;   // deprecated - use targetDNAVersion()\\n    uint256 internal constant MAX =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    //  version is in bits 0-7 = 0b11111111\\n    uint256 internal constant DNA_VERSION_MASK = 0xFF;\\n    //  origin is in bit 8 = 0b100000000\\n    uint256 internal constant DNA_ORIGIN_MASK = 0x100;\\n    //  locked is in bit 9 = 0b1000000000\\n    uint256 internal constant DNA_LOCKED_MASK = 0x200;\\n    //  limitedEdition is in bit 10 = 0b10000000000\\n    uint256 internal constant DNA_LIMITEDEDITION_MASK = 0x400;\\n    //  lifecycleStage is in bits 11-12 = 0b1100000000000\\n    uint256 internal constant DNA_LIFECYCLESTAGE_MASK = 0x1800;\\n    //  breedingPoints is in bits 13-16 = 0b11110000000000000\\n    uint256 internal constant DNA_BREEDINGPOINTS_MASK = 0x1E000;\\n    //  class is in bits 17-20 = 0b111100000000000000000\\n    uint256 internal constant DNA_CLASS_MASK = 0x1E0000;\\n    //  bodyArt is in bits 21-28 = 0b11111111000000000000000000000\\n    uint256 internal constant DNA_BODYART_MASK = 0x1FE00000;\\n    //  bodyMajorGene is in bits 29-36 = 0b1111111100000000000000000000000000000\\n    uint256 internal constant DNA_BODYMAJORGENE_MASK = 0x1FE0000000;\\n    //  bodyMidGene is in bits 37-44 = 0b111111110000000000000000000000000000000000000\\n    uint256 internal constant DNA_BODYMIDGENE_MASK = 0x1FE000000000;\\n    //  bodyMinorGene is in bits 45-52 = 0b11111111000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_BODYMINORGENE_MASK = 0x1FE00000000000;\\n    //  faceArt is in bits 53-60 = 0b1111111100000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_FACEART_MASK = 0x1FE0000000000000;\\n    //  faceMajorGene is in bits 61-68 = 0b111111110000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_FACEMAJORGENE_MASK = 0x1FE000000000000000;\\n    //  faceMidGene is in bits 69-76 = 0b11111111000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_FACEMIDGENE_MASK = 0x1FE00000000000000000;\\n    //  faceMinorGene is in bits 77-84 = 0b1111111100000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_FACEMINORGENE_MASK = 0x1FE0000000000000000000;\\n    //  hornArt is in bits 85-92 = 0b111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_HORNART_MASK = 0x1FE000000000000000000000;\\n    //  hornMajorGene is in bits 93-100 = 0b11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_HORNMAJORGENE_MASK =\\n        0x1FE00000000000000000000000;\\n    //  hornMidGene is in bits 101-108 = 0b1111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_HORNMIDGENE_MASK =\\n        0x1FE0000000000000000000000000;\\n    //  hornMinorGene is in bits 109-116 = 0b111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_HORNMINORGENE_MASK =\\n        0x1FE000000000000000000000000000;\\n    //  hoovesArt is in bits 117-124 = 0b11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_HOOVESART_MASK =\\n        0x1FE00000000000000000000000000000;\\n    //  hoovesMajorGene is in bits 125-132 = 0b1111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_HOOVESMAJORGENE_MASK =\\n        0x1FE0000000000000000000000000000000;\\n    //  hoovesMidGene is in bits 133-140 = 0b111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_HOOVESMIDGENE_MASK =\\n        0x1FE000000000000000000000000000000000;\\n    //  hoovesMinorGene is in bits 141-148 = 0b11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_HOOVESMINORGENE_MASK =\\n        0x1FE00000000000000000000000000000000000;\\n    //  maneArt is in bits 149-156 = 0b1111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_MANEART_MASK =\\n        0x001FE0000000000000000000000000000000000000;\\n    //  maneMajorGene is in bits 157-164 = 0b111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_MANEMAJORGENE_MASK =\\n        0x1FE000000000000000000000000000000000000000;\\n    //  maneMidGene is in bits 165-172 = 0b11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_MANEMIDGENE_MASK =\\n        0x1FE00000000000000000000000000000000000000000;\\n    //  maneMinorGene is in bits 173-180 = 0b1111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_MANEMINORGENE_MASK =\\n        0x1FE0000000000000000000000000000000000000000000;\\n    //  tailArt is in bits 181-188 = 0b111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_TAILART_MASK =\\n        0x1FE000000000000000000000000000000000000000000000;\\n    //  tailMajorGene is in bits 189-196 = 0b11111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_TAILMAJORGENE_MASK =\\n        0x1FE00000000000000000000000000000000000000000000000;\\n    //  tailMidGene is in bits 197-204 = 0b1111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_TAILMIDGENE_MASK =\\n        0x1FE0000000000000000000000000000000000000000000000000;\\n    //  tailMinorGene is in bits 205-212 = 0b111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_TAILMINORGENE_MASK =\\n        0x1FE000000000000000000000000000000000000000000000000000;\\n\\n    //  firstName index is in bits 213-222 = 0b1111111111000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_FIRST_NAME = 0x7FE00000000000000000000000000000000000000000000000000000;\\n    //  lastName index is in bits 223-232 = 0b11111111110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint256 internal constant DNA_LAST_NAME = 0x1FF80000000000000000000000000000000000000000000000000000000;\\n\\n    uint8 internal constant LIFECYCLE_EGG = 0;\\n    uint8 internal constant LIFECYCLE_BABY = 1;\\n    uint8 internal constant LIFECYCLE_ADULT = 2;\\n\\n    uint8 internal constant DEFAULT_BREEDING_POINTS = 8;\\n\\n    bytes32 private constant DNA_STORAGE_POSITION = keccak256(\\\"diamond.libUnicornDNA.storage\\\");\\n\\n    struct LibDNAStorage {\\n        mapping(uint256 => uint256) cachedDNA;\\n    }\\n\\n    function dnaStorage() internal pure returns (LibDNAStorage storage lds) {\\n        bytes32 position = DNA_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            lds.slot := position\\n        }\\n    }\\n\\n    function _getDNA(uint256 _tokenId) internal view returns (uint256) {\\n        if(dnaStorage().cachedDNA[_tokenId] > 0) {\\n            return dnaStorage().cachedDNA[_tokenId];\\n        } else if (LibHatching.shouldUsePredictiveDNA(_tokenId)) {\\n            return LibHatching.predictBabyDNA(_tokenId);\\n        }\\n\\n        return LibDiamond.diamondStorage().unicorn_dna[_tokenId];\\n    }\\n\\n    function _getCanonicalDNA(uint256 _tokenId) internal view returns (uint256) {\\n        return LibDiamond.diamondStorage().unicorn_dna[_tokenId];\\n    }\\n\\n    function _setDNA(uint256 _tokenId, uint256 _dna)\\n        internal\\n        returns (uint256)\\n    {\\n        require(_dna > 0, \\\"LibUnicornDNA: cannot set 0 DNA\\\");\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.unicorn_dna[_tokenId] = _dna;\\n        emit DNAUpdated(_tokenId, _dna);\\n        return _dna;\\n    }\\n\\n    function _getBirthday(uint256 _tokenId) internal view returns (uint256) {\\n        if (LibHatching.shouldUsePredictiveDNA(_tokenId)) {\\n            return LibHatching.predictBabyBirthday(_tokenId);\\n        }\\n        return LibDiamond.diamondStorage().hatch_birthday[_tokenId];\\n    }\\n\\n    //  The currently supported DNA version - all DNA should be at this number,\\n    //  or lower if migrating...\\n    function _targetDNAVersion() internal view returns (uint256) {\\n        return LibDiamond.diamondStorage().targetDNAVersion;\\n    }\\n\\n    function _setVersion(uint256 _dna, uint256 _value)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _value, DNA_VERSION_MASK);\\n    }\\n\\n    function _getVersion(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_VERSION_MASK);\\n    }\\n\\n    function enforceDNAVersionMatch(uint256 _dna) internal view {\\n        require(\\n            _getVersion(_dna) == _targetDNAVersion(),\\n            \\\"LibUnicornDNA: Invalid DNA version\\\"\\n        );\\n    }\\n\\n    function _setOrigin(uint256 _dna, bool _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_ORIGIN_MASK);\\n    }\\n\\n    function _getOrigin(uint256 _dna) internal pure returns (bool) {\\n        return LibBin.extractBool(_dna, DNA_ORIGIN_MASK);\\n    }\\n\\n    function _setGameLocked(uint256 _dna, bool _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_LOCKED_MASK);\\n    }\\n\\n    function _getGameLocked(uint256 _dna) internal pure returns (bool) {\\n        return LibBin.extractBool(_dna, DNA_LOCKED_MASK);\\n    }\\n\\n    function _setLimitedEdition(uint256 _dna, bool _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_LIMITEDEDITION_MASK);\\n    }\\n\\n    function _getLimitedEdition(uint256 _dna) internal pure returns (bool) {\\n        return LibBin.extractBool(_dna, DNA_LIMITEDEDITION_MASK);\\n    }\\n\\n    function _setLifecycleStage(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_LIFECYCLESTAGE_MASK);\\n    }\\n\\n    function _getLifecycleStage(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_LIFECYCLESTAGE_MASK);\\n    }\\n\\n    function _setBreedingPoints(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_BREEDINGPOINTS_MASK);\\n    }\\n\\n    function _getBreedingPoints(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_BREEDINGPOINTS_MASK);\\n    }\\n\\n    function _setClass(uint256 _dna, uint8 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, uint256(_val), DNA_CLASS_MASK);\\n    }\\n\\n    function _getClass(uint256 _dna) internal pure returns (uint8) {\\n        return uint8(LibBin.extract(_dna, DNA_CLASS_MASK));\\n    }\\n\\n    function _multiSetBody(\\n        uint256 _dna,\\n        uint256 _part,\\n        uint256 _majorGene,\\n        uint256 _midGene,\\n        uint256 _minorGene\\n    ) internal pure returns (uint256) {\\n        return LibBin.splice(\\n            LibBin.splice(\\n                LibBin.splice(\\n                    LibBin.splice(_dna, _minorGene, DNA_BODYMINORGENE_MASK),\\n                    _midGene,\\n                    DNA_BODYMIDGENE_MASK\\n                ),\\n                _majorGene,\\n                DNA_BODYMAJORGENE_MASK\\n            ),\\n            _part,\\n            DNA_BODYART_MASK\\n        );\\n    }\\n\\n    function _inheritBody(\\n        uint256 _dna,\\n        uint256 _inherited\\n    ) internal pure returns (uint256) {\\n        return _multiSetBody(\\n            _dna,\\n            _getBodyPart(_inherited),\\n            _getBodyMajorGene(_inherited),\\n            _getBodyMidGene(_inherited),\\n            _getBodyMinorGene(_inherited)\\n        );\\n    }\\n\\n    function _setBodyPart(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_BODYART_MASK);\\n    }\\n\\n    function _getBodyPart(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_BODYART_MASK);\\n    }\\n\\n    function _setBodyMajorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_BODYMAJORGENE_MASK);\\n    }\\n\\n    function _getBodyMajorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_BODYMAJORGENE_MASK);\\n    }\\n\\n    function _setBodyMidGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_BODYMIDGENE_MASK);\\n    }\\n\\n    function _getBodyMidGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_BODYMIDGENE_MASK);\\n    }\\n\\n    function _setBodyMinorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_BODYMINORGENE_MASK);\\n    }\\n\\n    function _getBodyMinorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_BODYMINORGENE_MASK);\\n    }\\n\\n    function _multiSetFace(\\n        uint256 _dna,\\n        uint256 _part,\\n        uint256 _majorGene,\\n        uint256 _midGene,\\n        uint256 _minorGene\\n    ) internal pure returns (uint256) {\\n        return LibBin.splice(\\n            LibBin.splice(\\n                LibBin.splice(\\n                    LibBin.splice(_dna, _minorGene, DNA_FACEMINORGENE_MASK),\\n                    _midGene,\\n                    DNA_FACEMIDGENE_MASK\\n                ),\\n                _majorGene,\\n                DNA_FACEMAJORGENE_MASK\\n            ),\\n            _part,\\n            DNA_FACEART_MASK\\n        );\\n    }\\n\\n    function _inheritFace(\\n        uint256 _dna,\\n        uint256 _inherited\\n    ) internal pure returns (uint256) {\\n        return _multiSetFace(\\n            _dna,\\n            _getFacePart(_inherited),\\n            _getFaceMajorGene(_inherited),\\n            _getFaceMidGene(_inherited),\\n            _getFaceMinorGene(_inherited)\\n        );\\n    }\\n\\n    function _setFacePart(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_FACEART_MASK);\\n    }\\n\\n    function _getFacePart(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_FACEART_MASK);\\n    }\\n\\n    function _setFaceMajorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_FACEMAJORGENE_MASK);\\n    }\\n\\n    function _getFaceMajorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_FACEMAJORGENE_MASK);\\n    }\\n\\n    function _setFaceMidGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_FACEMIDGENE_MASK);\\n    }\\n\\n    function _getFaceMidGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_FACEMIDGENE_MASK);\\n    }\\n\\n    function _setFaceMinorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_FACEMINORGENE_MASK);\\n    }\\n\\n    function _getFaceMinorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_FACEMINORGENE_MASK);\\n    }\\n\\n    function _multiSetHooves(\\n        uint256 _dna,\\n        uint256 _part,\\n        uint256 _majorGene,\\n        uint256 _midGene,\\n        uint256 _minorGene\\n    ) internal pure returns (uint256) {\\n        return LibBin.splice(\\n            LibBin.splice(\\n                LibBin.splice(\\n                    LibBin.splice(_dna, _minorGene, DNA_HOOVESMINORGENE_MASK),\\n                    _midGene,\\n                    DNA_HOOVESMIDGENE_MASK\\n                ),\\n                _majorGene,\\n                DNA_HOOVESMAJORGENE_MASK\\n            ),\\n            _part,\\n            DNA_HOOVESART_MASK\\n        );\\n    }\\n\\n    function _inheritHooves(\\n        uint256 _dna,\\n        uint256 _inherited\\n    ) internal pure returns (uint256) {\\n        return _multiSetHooves(\\n            _dna,\\n            _getHoovesPart(_inherited),\\n            _getHoovesMajorGene(_inherited),\\n            _getHoovesMidGene(_inherited),\\n            _getHoovesMinorGene(_inherited)\\n        );\\n    }\\n\\n    function _setHoovesPart(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_HOOVESART_MASK);\\n    }\\n\\n    function _getHoovesPart(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_HOOVESART_MASK);\\n    }\\n\\n    function _setHoovesMajorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_HOOVESMAJORGENE_MASK);\\n    }\\n\\n    function _getHoovesMajorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_HOOVESMAJORGENE_MASK);\\n    }\\n\\n    function _setHoovesMidGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_HOOVESMIDGENE_MASK);\\n    }\\n\\n    function _getHoovesMidGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_HOOVESMIDGENE_MASK);\\n    }\\n\\n    function _setHoovesMinorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_HOOVESMINORGENE_MASK);\\n    }\\n\\n    function _getHoovesMinorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_HOOVESMINORGENE_MASK);\\n    }\\n\\n    function _multiSetHorn(\\n        uint256 _dna,\\n        uint256 _part,\\n        uint256 _majorGene,\\n        uint256 _midGene,\\n        uint256 _minorGene\\n    ) internal pure returns (uint256) {\\n        return LibBin.splice(\\n            LibBin.splice(\\n                LibBin.splice(\\n                    LibBin.splice(_dna, _minorGene, DNA_HORNMINORGENE_MASK),\\n                    _midGene,\\n                    DNA_HORNMIDGENE_MASK\\n                ),\\n                _majorGene,\\n                DNA_HORNMAJORGENE_MASK\\n            ),\\n            _part,\\n            DNA_HORNART_MASK\\n        );\\n    }\\n\\n    function _inheritHorn(\\n        uint256 _dna,\\n        uint256 _inherited\\n    ) internal pure returns (uint256) {\\n        return _multiSetHorn(\\n            _dna,\\n            _getHornPart(_inherited),\\n            _getHornMajorGene(_inherited),\\n            _getHornMidGene(_inherited),\\n            _getHornMinorGene(_inherited)\\n        );\\n    }\\n\\n    function _setHornPart(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_HORNART_MASK);\\n    }\\n\\n    function _getHornPart(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_HORNART_MASK);\\n    }\\n\\n    function _setHornMajorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_HORNMAJORGENE_MASK);\\n    }\\n\\n    function _getHornMajorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_HORNMAJORGENE_MASK);\\n    }\\n\\n    function _setHornMidGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_HORNMIDGENE_MASK);\\n    }\\n\\n    function _getHornMidGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_HORNMIDGENE_MASK);\\n    }\\n\\n    function _setHornMinorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_HORNMINORGENE_MASK);\\n    }\\n\\n    function _getHornMinorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_HORNMINORGENE_MASK);\\n    }\\n\\n    function _multiSetMane(\\n        uint256 _dna,\\n        uint256 _part,\\n        uint256 _majorGene,\\n        uint256 _midGene,\\n        uint256 _minorGene\\n    ) internal pure returns (uint256) {\\n        return LibBin.splice(\\n            LibBin.splice(\\n                LibBin.splice(\\n                    LibBin.splice(_dna, _minorGene, DNA_MANEMINORGENE_MASK),\\n                    _midGene,\\n                    DNA_MANEMIDGENE_MASK\\n                ),\\n                _majorGene,\\n                DNA_MANEMAJORGENE_MASK\\n            ),\\n            _part,\\n            DNA_MANEART_MASK\\n        );\\n    }\\n\\n    function _inheritMane(\\n        uint256 _dna,\\n        uint256 _inherited\\n    ) internal pure returns (uint256) {\\n        return _multiSetMane(\\n            _dna,\\n            _getManePart(_inherited),\\n            _getManeMajorGene(_inherited),\\n            _getManeMidGene(_inherited),\\n            _getManeMinorGene(_inherited)\\n        );\\n    }\\n\\n    function _setManePart(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_MANEART_MASK);\\n    }\\n\\n    function _getManePart(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_MANEART_MASK);\\n    }\\n\\n    function _setManeMajorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_MANEMAJORGENE_MASK);\\n    }\\n\\n    function _getManeMajorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_MANEMAJORGENE_MASK);\\n    }\\n\\n    function _setManeMidGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_MANEMIDGENE_MASK);\\n    }\\n\\n    function _getManeMidGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_MANEMIDGENE_MASK);\\n    }\\n\\n    function _setManeMinorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_MANEMINORGENE_MASK);\\n    }\\n\\n    function _getManeMinorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_MANEMINORGENE_MASK);\\n    }\\n\\n    function _multiSetTail(\\n        uint256 _dna,\\n        uint256 _part,\\n        uint256 _majorGene,\\n        uint256 _midGene,\\n        uint256 _minorGene\\n    ) internal pure returns (uint256) {\\n        return LibBin.splice(\\n            LibBin.splice(\\n                LibBin.splice(\\n                    LibBin.splice(_dna, _minorGene, DNA_TAILMINORGENE_MASK),\\n                    _midGene,\\n                    DNA_TAILMIDGENE_MASK\\n                ),\\n                _majorGene,\\n                DNA_TAILMAJORGENE_MASK\\n            ),\\n            _part,\\n            DNA_TAILART_MASK\\n        );\\n    }\\n\\n    function _inheritTail(\\n        uint256 _dna,\\n        uint256 _inherited\\n    ) internal pure returns (uint256) {\\n        return _multiSetTail(\\n            _dna,\\n            _getTailPart(_inherited),\\n            _getTailMajorGene(_inherited),\\n            _getTailMidGene(_inherited),\\n            _getTailMinorGene(_inherited)\\n        );\\n    }\\n\\n    function _setTailPart(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_TAILART_MASK);\\n    }\\n\\n    function _getTailPart(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_TAILART_MASK);\\n    }\\n\\n    function _setTailMajorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_TAILMAJORGENE_MASK);\\n    }\\n\\n    function _getTailMajorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_TAILMAJORGENE_MASK);\\n    }\\n\\n    function _setTailMidGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_TAILMIDGENE_MASK);\\n    }\\n\\n    function _getTailMidGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_TAILMIDGENE_MASK);\\n    }\\n\\n    function _setTailMinorGene(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_TAILMINORGENE_MASK);\\n    }\\n\\n    function _getTailMinorGene(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_TAILMINORGENE_MASK);\\n    }\\n\\n    function _setFirstNameIndex(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_FIRST_NAME);\\n    }\\n\\n    function _getFirstNameIndex(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_FIRST_NAME);\\n    }\\n\\n    function _setLastNameIndex(uint256 _dna, uint256 _val)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return LibBin.splice(_dna, _val, DNA_LAST_NAME);\\n    }\\n\\n    function _getLastNameIndex(uint256 _dna) internal pure returns (uint256) {\\n        return LibBin.extract(_dna, DNA_LAST_NAME);\\n    }\\n\\n    //  @return bodyPartIds - An ordered array of bodypart globalIds [body, face, horn, hooves, mane, tail]\\n    //  @return geneIds - An ordered array of geen ids [\\n        // bodyMajor, bodyMid, bodyMinor, \\n        // faceMajor, faceMid, faceMinor, \\n        // hornMajor, hornMid, hornMinor, \\n        // hoovesMajor, hoovesMid, hoovesMinor, \\n        // maneMajor, maneMid, maneMinor, \\n        // tailMajor, tailMid, tailMinor]\\n    function _getGeneMapFromDNA(uint256 _dna) internal view returns(uint256[6] memory parts, uint256[18] memory genes){\\n        parts = [uint256(0),0,0,0,0,0];\\n        genes = [uint256(0),0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];\\n        if(_getLifecycleStage(_dna) != LibUnicornDNA.LIFECYCLE_EGG) {\\n            mapping(uint256 => mapping(uint256 => uint256)) storage globalIdsByBucket = LibDiamond.diamondStorage().bodyPartGlobalIdFromLocalId[_getClass(_dna)];\\n            \\n            parts = [\\n                globalIdsByBucket[1][_getBodyPart(_dna)],\\n                globalIdsByBucket[2][_getFacePart(_dna)],\\n                globalIdsByBucket[3][_getHornPart(_dna)],\\n                globalIdsByBucket[4][_getHoovesPart(_dna)],\\n                globalIdsByBucket[5][_getManePart(_dna)],\\n                globalIdsByBucket[6][_getTailPart(_dna)]\\n            ];\\n            genes = [\\n                _getBodyMajorGene(_dna),\\n                _getBodyMidGene(_dna),\\n                _getBodyMinorGene(_dna),\\n                _getFaceMajorGene(_dna),\\n                _getFaceMidGene(_dna),\\n                _getFaceMinorGene(_dna),\\n                _getHornMajorGene(_dna),\\n                _getHornMidGene(_dna),\\n                _getHornMinorGene(_dna),\\n                _getHoovesMajorGene(_dna),\\n                _getHoovesMidGene(_dna),\\n                _getHoovesMinorGene(_dna),\\n                _getManeMajorGene(_dna),\\n                _getManeMidGene(_dna),\\n                _getManeMinorGene(_dna),\\n                _getTailMajorGene(_dna),\\n                _getTailMidGene(_dna),\\n                _getTailMinorGene(_dna)\\n            ];    \\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"LibBin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary LibBin {\\n\\n    uint256 internal constant MAX =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    // Using the mask, determine how many bits we need to shift to extract the desired value\\n    //  @param _mask A bitstring with right-padding zeroes\\n    //  @return The number of right-padding zeroes on the _mask\\n    function _getShiftAmount(uint256 _mask) internal pure returns (uint256) {\\n        uint256 count = 0;\\n        while (_mask & 0x1 == 0) {\\n            _mask >>= 1;\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\n    //  Insert _insertion data into the _bitArray bitstring\\n    //  @param _bitArray The base dna to manipulate\\n    //  @param _insertion Data to insert (no right-padding zeroes)\\n    //  @param _mask The location in the _bitArray where the insertion will take place\\n    //  @return The combined _bitArray bitstring\\n    function splice(\\n        uint256 _bitArray,\\n        uint256 _insertion,\\n        uint256 _mask\\n    ) internal pure returns (uint256) {\\n        uint256 offset = _getShiftAmount(_mask);\\n        uint256 passthroughMask = MAX ^ _mask;\\n        require(_insertion & (passthroughMask >> offset) == 0, \\\"LibBin: Overflow, review carefuly the mask limits\\\");\\n        //  remove old value,  shift new value to correct spot,  mask new value\\n        return (_bitArray & passthroughMask) | ((_insertion << offset) & _mask);\\n    }\\n\\n    //  Alternate function signature for boolean insertion\\n    function splice(\\n        uint256 _bitArray,\\n        bool _insertion,\\n        uint256 _mask\\n    ) internal pure returns (uint256) {\\n        return splice(_bitArray, _insertion ? 1 : 0, _mask);\\n    }\\n\\n    //  Retrieves a segment from the _bitArray bitstring\\n    //  @param _bitArray The dna to parse\\n    //  @param _mask The location in teh _bitArray to isolate\\n    //  @return The data from _bitArray that was isolated in the _mask (no right-padding zeroes)\\n    function extract(uint256 _bitArray, uint256 _mask)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 offset = _getShiftAmount(_mask);\\n        return (_bitArray & _mask) >> offset;\\n    }\\n\\n    //  Alternate function signature for boolean retrieval\\n    function extractBool(uint256 _bitArray, uint256 _mask)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return (_bitArray & _mask) != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Modified from original contract, which was written by:\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\nimport {IDiamondCut} from \\\"IDiamondCut.sol\\\";\\n\\n\\nlibrary LibDiamond {\\n    bytes32 internal constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    //TODO: Should this go into DiamondStorage?\\n    uint256 internal constant ERC721_GENESIS_TOKENS = 10000;\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    /* solhint-disable var-name-mixedcase */\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n        // LG game server wallet\\n        address gameServer;\\n        // Erc721 state:\\n        // Mapping from token ID to owner address\\n        mapping(uint256 => address) erc721_owners;\\n        // Mapping owner address to token count\\n        mapping(address => uint256) erc721_balances;\\n        // Mapping of owners to owned token IDs\\n        mapping(address => mapping(uint256 => uint256)) erc721_ownedTokens;\\n        // Mapping of tokens to their index in their owners ownedTokens array.\\n        mapping(uint256 => uint256) erc721_ownedTokensIndex;\\n        // Array with all token ids, used for enumeration\\n        uint256[] erc721_allTokens;\\n        // Mapping from token id to position in the allTokens array\\n        mapping(uint256 => uint256) erc721_allTokensIndex;\\n        // Mapping from token ID to approved address\\n        mapping(uint256 => address) erc721_tokenApprovals;\\n        // Mapping from owner to operator approvals\\n        mapping(address => mapping(address => bool)) erc721_operatorApprovals;\\n        string erc721_name;\\n        // Token symbol\\n        string erc721_symbol;\\n        // Token contractURI - permaweb location of the contract json file\\n        string erc721_contractURI;\\n        // Token licenseURI - permaweb location of the license.txt file\\n        string erc721_licenseURI;\\n        // Timestamp when genesis eggs can be bought\\n        uint256 erc721_genesisEggPresaleUnlockTime;\\n        // Timestamp when genesis eggs can hatch\\n        uint256 erc721_genesisEggHatchUnlockTime;\\n        // Token URIs\\n        mapping(uint256 => string) erc721_tokenURIs;\\n        //whitelist_addresses\\n        mapping(address => uint8) erc721_mint_whitelist;\\n        uint256 erc721_current_token_id;\\n        //wETH token address (this is the one used to buy unicorns/land)\\n        address WethTokenAddress;\\n        // Unicorn token -> DNA mapping. DNA is represented by a uint256.\\n        mapping(uint256 => uint256) unicorn_dna; // DO NOT ACCESS DIRECTLY! Use LibUnicornDNA\\n        // The state of the NFT when it is round-tripping with the server\\n        mapping(uint256 => uint256) idempotence_state;\\n        // Unicorn token -> Timestamp (in seconds) when Egg hatched\\n        mapping(uint256 => uint256) hatch_birthday;\\n        // Unicorn token -> Timestamp (in seconds) when Unicorn last bred/hatched/evolved\\n        mapping(uint256 => uint256) bio_clock;\\n        // Seed for the cheap RNG\\n        uint256 rngNonce;\\n        // [geneTier][geneDominance] => chance to upgrade [0-100]\\n        mapping(uint256 => mapping(uint256 => uint256)) geneUpgradeChances;\\n        // [geneId] => tier of the gene [1-6]\\n        mapping(uint256 => uint256) geneTierById;\\n        // [geneId] => id of the next tier version of the gene\\n        mapping(uint256 => uint256) geneTierUpgradeById;\\n        // [geneId] => how the bonuses are applied (1 = multiply, 2 = add)\\n        mapping(uint256 => uint256) geneApplicationById;\\n        // [classId] => List of available gene globalIds for that class\\n        mapping(uint256 => uint256[]) geneBuckets;\\n        // [classId] => sum of weights in a geneBucket\\n        mapping(uint256 => uint256) geneBucketSumWeights;\\n        // uint256 geneWeightSum;\\n        mapping(uint256 => uint256) geneWeightById;\\n        //  [geneId][geneBonusSlot] => statId to affect\\n        mapping(uint256 => mapping(uint256 => uint256)) geneBonusStatByGeneId;\\n        //  [geneId][geneBonusSlot] => increase amount (percentages are scaled * 100)\\n        mapping(uint256 => mapping(uint256 => uint256)) geneBonusValueByGeneId;\\n        //  [globalPartId] => localPartId\\n        mapping(uint256 => uint256) bodyPartLocalIdFromGlobalId;\\n        //  [globalPartId] => true if mythic\\n        mapping(uint256 => bool) bodyPartIsMythic;\\n        //  [globalPartId] => globalPartId of next tier version of the gene\\n        mapping(uint256 => uint256) bodyPartInheritedGene;\\n        // [ClassId][PartSlotId] => globalIds[] - this is how we randomize slots\\n        mapping(uint256 => mapping(uint256 => uint256[])) bodyPartBuckets;\\n        // [ClassId][PartSlotId][localPartId] => globalPartId\\n        mapping(uint256 => mapping(uint256 => mapping(uint256 => uint256))) bodyPartGlobalIdFromLocalId;\\n        //  [globalPartId] => weight\\n        mapping(uint256 => uint256) bodyPartWeight;\\n        // [classId][statId] => base stat value\\n        mapping(uint256 => mapping(uint256 => uint256)) baseStats;\\n        // requestId (number provided by ChainLink) => mechanicId (ie BREEDING, EVOLVING, etc.)\\n        // This map allows us to share RNG facet between mechanichs.\\n        mapping(bytes32 => uint256) rng_mechanicIdByVRFRequestId;\\n        // requestId => randomness provided by ChainLink\\n        mapping(bytes32 => uint256) rng_randomness;\\n        // ChainLink's keyhash\\n        bytes32 rng_chainlinkVRFKeyhash;\\n        // ChainLink's fee\\n        uint256 rng_chainlinkVRFFee;\\n        // transactionId => an array that represents breeding structure\\n        mapping(uint256 => uint256[8]) breedingByRoundTripId;\\n        // requestId => the transactionId that requested that randomness\\n        mapping(bytes32 => uint256) roundTripIdByVRFRequestId;\\n        // RBW token address\\n        address rbwTokenAddress;\\n        // UNIM token address\\n        address unimTokenAddress;\\n        // LINK token address\\n        address linkTokenAddress;\\n        // Nonces for each VRF key from which randomness has been requested.\\n        // Must stay in sync with VRFCoordinator[_keyHash][this]\\n        // keyHash => nonce\\n        mapping(bytes32 => uint256) rng_nonces;\\n        //VRF coordinator address\\n        address vrfCoordinator;\\n\\n        // Unicorn token -> Last timestamp when it was unlocked forcefully\\n        mapping(uint256 => uint256) erc721_unicornLastForceUnlock;\\n        // After unlocking forcefully, user has to wait erc721_forceUnlockUnicornCooldown seconds to be able to transfer\\n        uint256 erc721_forceUnlockUnicornCooldown;\\n\\n        mapping(uint256 => uint256[2]) unicornParents;\\n        // transactionId => an array that represents hatching structure\\n        mapping(uint256 => uint256[3]) hatchingByRoundTripId;   //  DEPRECATED - do not use\\n        // Blocks that we wait for Chainlink's response after SSS bundle is sent\\n        uint256 vrfBlocksToRespond;\\n\\n        // nameIndex -> name string\\n        mapping(uint256 => string) firstNamesList;\\n        mapping(uint256 => string) lastNamesList;\\n\\n        // Names which can be chosen by RNG for new lands (unordered)\\n        uint256[] validFirstNames;\\n        uint256[] validLastNames;\\n\\n        //  The currently supported DNA Version\\n        uint256 targetDNAVersion;\\n\\n        // roundTripId => an array that represents evolution structure // not being used actually, replaced by libEvolutionStorage\\n        mapping(uint256 => uint256[3]) evolutionByRoundTripId;\\n\\n        //Scalars for score calculations\\n        uint256 power_scalar;\\n        uint256 power_attack_scalar;\\n        uint256 power_accuracy_scalar;\\n        uint256 speed_scalar;\\n        uint256 speed_movespeed_scalar;\\n        uint256 speed_attackspeed_scalar;\\n        uint256 endurance_scalar;\\n        uint256 endurance_vitality_scalar;\\n        uint256 endurance_defense_scalar;\\n        uint256 intelligence_scalar;\\n        uint256 intelligence_magic_scalar;\\n        uint256 intelligence_resistance_scalar;\\n\\n        // game bank address, used to transfer funds from operations like breeding\\n        address gameBankAddress;\\n\\n    } /* solhint-enable var-name-mixedcase */\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    // Ownership functionality\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function setGameServerAddress(address _newAddress) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.gameServer = _newAddress;\\n    }\\n\\n    function setName(string memory _name) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.erc721_name = _name;\\n    }\\n\\n    function setSymbol(string memory _symbol) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.erc721_symbol = _symbol;\\n    }\\n\\n    function setContractURI(string memory _uri) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.erc721_contractURI = _uri;\\n    }\\n\\n    function setLicenseURI(string memory _uri) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.erc721_licenseURI = _uri;\\n    }\\n\\n    function setGenesisEggPresaleUnlockTime(uint256 _timestamp) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.erc721_genesisEggPresaleUnlockTime = _timestamp;\\n    }\\n\\n    function setGenesisEggHatchUnlockTime(uint256 _timestamp) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.erc721_genesisEggHatchUnlockTime = _timestamp;\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function gameServer() internal view returns (address) {\\n        return diamondStorage().gameServer;\\n    }\\n\\n    //TODO: Now using this to set the WethTokenAddress\\n    function setWethTokenAddress(address _wethTokenAddress) internal {\\n        enforceIsContractOwner();\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.WethTokenAddress = _wethTokenAddress;\\n    }\\n\\n    function setRbwTokenAddress(address _rbwTokenAddress) internal {\\n        enforceIsContractOwner();\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.rbwTokenAddress = _rbwTokenAddress;\\n    }\\n\\n    function setUnimTokenAddress(address _unimTokenAddress) internal {\\n        enforceIsContractOwner();\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.unimTokenAddress = _unimTokenAddress;\\n    }\\n\\n    function setLinkTokenAddress(address _linkTokenAddress) internal {\\n        enforceIsContractOwner();\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.linkTokenAddress = _linkTokenAddress;\\n    }\\n\\n    function setGameBankAddress(address _gameBankAddress) internal {\\n        enforceIsContractOwner();\\n        DiamondStorage storage ds = diamondStorage();\\n        ds.gameBankAddress = _gameBankAddress;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(\\n            msg.sender == diamondStorage().contractOwner,\\n            \\\"LibDiamond: Must be contract owner\\\"\\n        );\\n    }\\n\\n    function enforceIsGameServer() internal view {\\n        require(\\n            msg.sender == diamondStorage().gameServer,\\n            \\\"LibDiamond: Must be trusted game server\\\"\\n        );\\n    }\\n\\n    function enforceIsOwnerOrGameServer() internal view {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        require(\\n            msg.sender == ds.contractOwner ||\\n            msg.sender == ds.gameServer,\\n            \\\"LibDiamond: Must be contract owner or trusted game server\\\"\\n        );\\n    }\\n\\n    function enforceCallerOwnsNFT(uint256 _tokenId) internal view {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        require(\\n            msg.sender == ds.erc721_owners[_tokenId],\\n            \\\"LibDiamond: NFT must belong to the caller\\\"\\n        );\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint96 selectorPosition = uint96(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress == address(0),\\n                \\\"LibDiamondCut: Can't add function that already exists\\\"\\n            );\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint96 selectorPosition = uint96(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress != _facetAddress,\\n                \\\"LibDiamondCut: Can't replace function with same function\\\"\\n            );\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(\\n            _facetAddress == address(0),\\n            \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n        );\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress)\\n        internal\\n    {\\n        enforceHasContractCode(\\n            _facetAddress,\\n            \\\"LibDiamondCut: New facet has no code\\\"\\n        );\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\\n            .facetAddresses\\n            .length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        DiamondStorage storage ds,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n            _selector\\n        );\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(\\n        DiamondStorage storage ds,\\n        address _facetAddress,\\n        bytes4 _selector\\n    ) internal {\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n        );\\n        // an immutable function is a function defined directly in a diamond\\n        require(\\n            _facetAddress != address(this),\\n            \\\"LibDiamondCut: Can't remove immutable function\\\"\\n        );\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds\\n            .facetFunctionSelectors[_facetAddress]\\n            .functionSelectors\\n            .length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n                    selectorPosition\\n                ] = lastSelector;\\n            ds\\n                .selectorToFacetAndPosition[lastSelector]\\n                .functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[\\n                    lastFacetAddressPosition\\n                ];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds\\n                    .facetFunctionSelectors[lastFacetAddress]\\n                    .facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata)\\n        internal\\n    {\\n        if (_init == address(0)) {\\n            require(\\n                _calldata.length == 0,\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\n            );\\n        } else {\\n            require(\\n                _calldata.length > 0,\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\n            );\\n            if (_init != address(this)) {\\n                enforceHasContractCode(\\n                    _init,\\n                    \\\"LibDiamondCut: _init address has no code\\\"\\n                );\\n            }\\n            // solhint-disable-next-line avoid-low-level-calls\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n\\n    function enforceBlockDeadlineIsValid(uint256 blockDeadline) internal view {\\n        require(block.number < blockDeadline, \\\"blockDeadline is overdue\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"IDiamondCut.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/******************************************************************************\\\\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\n/******************************************************************************/\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {Add, Replace, Remove}\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"LibHatching.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibERC721} from \\\"LibERC721.sol\\\";\\nimport {LibIdempotence} from \\\"LibIdempotence.sol\\\";\\nimport {LibRNG} from \\\"LibRNG.sol\\\";\\nimport {LibUnicornDNA} from \\\"LibUnicornDNA.sol\\\";\\nimport {IPermissionProvider} from \\\"IPermissionProvider.sol\\\";\\nimport {LibPermissions} from \\\"LibPermissions.sol\\\";\\n\\nlibrary LibHatching {\\n\\n    event HatchingRNGRequested(uint256 indexed roundTripId, bytes32 indexed vrfRequestId, address indexed playerWallet);\\n    event HatchingRNGRequestedV2(uint256 indexed roundTripId, bytes32 indexed vrfRequestId, address indexed owner, address playerWallet);\\n    event HatchingReadyForTokenURI(uint256 indexed roundTripId, address indexed playerWallet);\\n    event HatchingReadyForTokenURIV2(uint256 indexed roundTripId, address indexed owner, address indexed playerWallet);\\n    event HatchingComplete(uint256 indexed roundTripId, address indexed playerWallet);\\n    event HatchingCompleteV2(uint256 indexed roundTripId, address indexed owner, address indexed playerWallet);\\n\\n    bytes32 private constant HATCHING_STORAGE_POSITION = keccak256(\\\"diamond.libHatching.storage\\\");\\n\\n    uint256 private constant BODY_SLOT = 1;\\n    uint256 private constant FACE_SLOT = 2;\\n    uint256 private constant HORN_SLOT = 3;\\n    uint256 private constant HOOVES_SLOT = 4;\\n    uint256 private constant MANE_SLOT = 5;\\n    uint256 private constant TAIL_SLOT = 6;\\n\\n    uint256 private constant SALT_11 = 11;\\n    uint256 private constant SALT_12 = 12;\\n    uint256 private constant SALT_13 = 13;\\n    uint256 private constant SALT_14 = 14;\\n    uint256 private constant SALT_15 = 15;\\n    uint256 private constant SALT_16 = 16;\\n\\n    uint256 private constant SALT_21 = 21;\\n    uint256 private constant SALT_22 = 22;\\n    uint256 private constant SALT_23 = 23;\\n    uint256 private constant SALT_24 = 24;\\n    uint256 private constant SALT_25 = 25;\\n    uint256 private constant SALT_26 = 26;\\n\\n    uint256 private constant SALT_31 = 31;\\n    uint256 private constant SALT_32 = 32;\\n    uint256 private constant SALT_33 = 33;\\n    uint256 private constant SALT_34 = 34;\\n    uint256 private constant SALT_35 = 35;\\n    uint256 private constant SALT_36 = 36;\\n\\n    uint256 private constant SALT_41 = 41;\\n    uint256 private constant SALT_42 = 42;\\n    uint256 private constant SALT_43 = 43;\\n    uint256 private constant SALT_44 = 44;\\n    uint256 private constant SALT_45 = 45;\\n    uint256 private constant SALT_46 = 46;\\n\\n    uint256 private constant SALT_51 = 51;\\n    uint256 private constant SALT_52 = 52;\\n    uint256 private constant SALT_53 = 53;\\n    uint256 private constant SALT_54 = 54;\\n    uint256 private constant SALT_55 = 55;\\n    uint256 private constant SALT_56 = 56;\\n\\n    uint256 private constant SALT_61 = 61;\\n    uint256 private constant SALT_62 = 62;\\n    uint256 private constant SALT_63 = 63;\\n    uint256 private constant SALT_64 = 64;\\n    uint256 private constant SALT_65 = 65;\\n    uint256 private constant SALT_66 = 66;\\n\\n    struct LibHatchingStorage {\\n        mapping(bytes32 => uint256) blockDeadlineByVRFRequestId;\\n        mapping(bytes32 => uint256) roundTripIdByVRFRequestId;\\n        mapping(uint256 => bytes32) vrfRequestIdByRoundTripId;\\n        mapping(bytes32 => uint256) tokenIdByVRFRequestId;\\n        mapping(bytes32 => uint256) inheritanceChanceByVRFRequestId;\\n        mapping(bytes32 => uint256) rngByVRFRequestId;\\n        mapping(bytes32 => uint256) rngBlockNumberByVRFRequestId;\\n        mapping(bytes32 => uint256) birthdayByVRFRequestId;\\n        mapping(uint256 => uint256) roundTripIdByTokenId;\\n    }\\n\\n    function hatchingStorage() internal pure returns (LibHatchingStorage storage lhs) {\\n        bytes32 position = HATCHING_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            lhs.slot := position\\n        }\\n    }\\n\\n    function saveDataOnHatchingStruct(\\n        uint256 roundTripId,\\n        bytes32 vrfRequestId,\\n        uint256 blockDeadline,\\n        uint256 tokenId,\\n        uint256 inheritanceChance\\n    ) internal {\\n        LibHatchingStorage storage lhs = hatchingStorage();\\n        lhs.blockDeadlineByVRFRequestId[vrfRequestId] = blockDeadline;\\n        lhs.roundTripIdByVRFRequestId[vrfRequestId] = roundTripId;\\n        lhs.tokenIdByVRFRequestId[vrfRequestId] = tokenId;\\n        lhs.inheritanceChanceByVRFRequestId[vrfRequestId] = inheritanceChance;\\n        lhs.vrfRequestIdByRoundTripId[roundTripId] = vrfRequestId;\\n        lhs.roundTripIdByTokenId[tokenId] = roundTripId;\\n        lhs.birthdayByVRFRequestId[vrfRequestId] = block.timestamp;\\n    }\\n\\n    function cleanUpRoundTrip(bytes32 vrfRequestId) internal {\\n        LibHatchingStorage storage lhs = hatchingStorage();\\n        uint256 roundTripId = lhs.roundTripIdByVRFRequestId[vrfRequestId];\\n        uint256 tokenId = lhs.tokenIdByVRFRequestId[vrfRequestId];\\n        delete lhs.blockDeadlineByVRFRequestId[vrfRequestId];\\n        delete lhs.roundTripIdByVRFRequestId[vrfRequestId];\\n        delete lhs.vrfRequestIdByRoundTripId[roundTripId];\\n        delete lhs.tokenIdByVRFRequestId[vrfRequestId];\\n        delete lhs.inheritanceChanceByVRFRequestId[vrfRequestId];\\n        delete lhs.rngByVRFRequestId[vrfRequestId];\\n        delete lhs.rngBlockNumberByVRFRequestId[vrfRequestId];\\n        delete lhs.birthdayByVRFRequestId[vrfRequestId];\\n        delete lhs.roundTripIdByTokenId[tokenId];\\n    }\\n\\n    function getVRFRequestId(uint256 roundTripId) internal view returns (bytes32) {\\n        return hatchingStorage().vrfRequestIdByRoundTripId[roundTripId];\\n    }\\n\\n    function getRoundTripId(bytes32 vrfRequestId) internal view returns (uint256) {\\n        return hatchingStorage().roundTripIdByVRFRequestId[vrfRequestId];\\n    }\\n\\n    function getRoundTripIdForToken(uint256 tokenId) internal view returns (uint256) {\\n        return hatchingStorage().roundTripIdByTokenId[tokenId];\\n    }\\n\\n    function getBlockDeadline(bytes32 vrfRequestId) internal view returns (uint256) {\\n        return hatchingStorage().blockDeadlineByVRFRequestId[vrfRequestId];\\n    }\\n\\n    function getTokenId(bytes32 vrfRequestId) internal view returns (uint256) {\\n        return hatchingStorage().tokenIdByVRFRequestId[vrfRequestId];\\n    }\\n\\n    function setRandomness(bytes32 vrfRequestId, uint256 randomness) internal {\\n        LibHatchingStorage storage lhs = hatchingStorage();\\n        lhs.rngByVRFRequestId[vrfRequestId] = randomness;\\n        lhs.rngBlockNumberByVRFRequestId[vrfRequestId] = block.number;\\n    }\\n\\n    function setBirthday(bytes32 vrfRequestId, uint256 timestamp) internal {\\n        hatchingStorage().birthdayByVRFRequestId[vrfRequestId] = timestamp;\\n    }\\n\\n    function shouldUsePredictiveDNA(uint256 tokenId) internal view returns (bool) {\\n        if (\\n            LibIdempotence._getHatchingRandomnessFulfilled(tokenId) &&\\n            !LibIdempotence._getHatchingStarted(tokenId)\\n        ) {\\n            LibHatchingStorage storage lhs = hatchingStorage();\\n            uint256 roundTripId = lhs.roundTripIdByTokenId[tokenId];\\n            bytes32 vrfRequestId = lhs.vrfRequestIdByRoundTripId[roundTripId];\\n            if (\\n                lhs.rngBlockNumberByVRFRequestId[vrfRequestId] > 0 &&\\n                lhs.rngBlockNumberByVRFRequestId[vrfRequestId] < block.number\\n            ) {\\n                return true;\\n            } \\n        }\\n        return false;\\n    }\\n\\n    function predictBabyBirthday(uint256 tokenId) internal view returns (uint256) {\\n        require(!LibIdempotence._getHatchingStarted(tokenId), \\\"LibHatching: RNG not ready\\\");\\n        require(LibIdempotence._getHatchingRandomnessFulfilled(tokenId), \\\"LibHatching: Waiting for VRF TTL\\\");\\n        LibHatchingStorage storage lhs = hatchingStorage();\\n        uint256 roundTripId = lhs.roundTripIdByTokenId[tokenId];\\n        bytes32 vrfRequestId = lhs.vrfRequestIdByRoundTripId[roundTripId];\\n        uint256 eggDNA = LibUnicornDNA._getCanonicalDNA(tokenId);\\n        require(LibUnicornDNA._getLifecycleStage(eggDNA) == LibUnicornDNA.LIFECYCLE_EGG, \\\"LibHatching: DNA has already been persisted (birthday)\\\");\\n        return lhs.birthdayByVRFRequestId[vrfRequestId];\\n    }\\n\\n    //  This is gigantic hack to move gas costs out of the Chainlink VRF call. Instead of rolling for\\n    //  random DNA and saving it, the dna is calculated on-the-fly when it's needed. When hatching is\\n    //  completed, this dna is written into storage and the temporary state is deleted. -RS\\n    //\\n    //  This code MUST be deterministic - DO NOT MODIFY THE RANDOMNESS OR SALT CONSTANTS\\n\\n    function predictBabyDNA(uint256 tokenId) internal view returns (uint256) {\\n        require(!LibIdempotence._getHatchingStarted(tokenId), \\\"LibHatching: RNG not ready\\\");\\n        require(LibIdempotence._getHatchingRandomnessFulfilled(tokenId), \\\"LibHatching: Waiting for VRF TTL\\\");\\n        LibHatchingStorage storage lhs = hatchingStorage();\\n\\n        bytes32 vrfRequestId = lhs.vrfRequestIdByRoundTripId[lhs.roundTripIdByTokenId[tokenId]];\\n        require(lhs.rngBlockNumberByVRFRequestId[vrfRequestId] > 0, \\\"LibHatching: No RNG set\\\");\\n        require(lhs.rngBlockNumberByVRFRequestId[vrfRequestId] < block.number, \\\"LibHatching: Prediction masked during RNG set block\\\");\\n\\n        uint256 inheritanceChance  = lhs.inheritanceChanceByVRFRequestId[vrfRequestId];\\n        uint256 randomness = lhs.rngByVRFRequestId[vrfRequestId];\\n        uint256 dna = LibUnicornDNA._getCanonicalDNA(tokenId);\\n        require(LibUnicornDNA._getLifecycleStage(dna) == LibUnicornDNA.LIFECYCLE_EGG, \\\"LibHatching: DNA has already been persisted (dna)\\\");\\n\\n        uint256 classId = LibUnicornDNA._getClass(dna);\\n\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 firstParentDNA = LibUnicornDNA._getDNA(ds.unicornParents[tokenId][0]);\\n        uint256 secondParentDNA = LibUnicornDNA._getDNA(ds.unicornParents[tokenId][1]);\\n\\n        //  Optimization for stack depth limit:\\n        //  {0: neither,  1: firstParent,  2: secondParent,  3: both}\\n        uint256 matching = 0;\\n\\n        if(classId == LibUnicornDNA._getClass(firstParentDNA)) {\\n            matching += 1;\\n        }\\n\\n        if(classId == LibUnicornDNA._getClass(secondParentDNA)) {\\n            matching += 2;\\n        }\\n\\n        dna = LibUnicornDNA._setLifecycleStage(dna, LibUnicornDNA.LIFECYCLE_BABY);\\n        \\n        uint256 partId;\\n\\n        //  BODY\\n        if (matching > 0 && LibRNG.expand(10000, randomness, SALT_11) < inheritanceChance) {\\n            //  inherit\\n            if (matching == 3) {\\n                if(LibRNG.expand(2, randomness, SALT_12) == 1) {\\n                    dna = LibUnicornDNA._inheritBody(dna, firstParentDNA);\\n                } else {\\n                    dna = LibUnicornDNA._inheritBody(dna, secondParentDNA);\\n                }\\n            } else if (matching == 2) {\\n                dna = LibUnicornDNA._inheritBody(dna, secondParentDNA);\\n            } else {\\n                dna = LibUnicornDNA._inheritBody(dna, firstParentDNA);\\n            }\\n        } else {\\n            //  randomize\\n            partId = getRandomPartId(ds, classId, BODY_SLOT, randomness, SALT_13);\\n            dna = LibUnicornDNA._multiSetBody(\\n                dna,\\n                ds.bodyPartLocalIdFromGlobalId[partId],\\n                ds.bodyPartInheritedGene[partId],\\n                getRandomGeneId(ds, classId, randomness, SALT_15),\\n                getRandomGeneId(ds, classId, randomness, SALT_16)\\n            );\\n        }\\n\\n        //  FACE\\n        if (matching > 0 && LibRNG.expand(10000, randomness, SALT_21) < inheritanceChance) {\\n            //  inherit\\n            if (matching == 3) {\\n                if(LibRNG.expand(2, randomness, SALT_22) == 1) {\\n                    dna = LibUnicornDNA._inheritFace(dna, firstParentDNA);\\n                } else {\\n                    dna = LibUnicornDNA._inheritFace(dna, secondParentDNA);\\n                }\\n            } else if (matching == 2) {\\n                dna = LibUnicornDNA._inheritFace(dna, secondParentDNA);\\n            } else {\\n                dna = LibUnicornDNA._inheritFace(dna, firstParentDNA);\\n            }\\n        } else {\\n            //  randomize\\n            partId = getRandomPartId(ds, classId, FACE_SLOT, randomness, SALT_23);\\n            dna = LibUnicornDNA._multiSetFace(\\n                dna,\\n                ds.bodyPartLocalIdFromGlobalId[partId],\\n                ds.bodyPartInheritedGene[partId],\\n                getRandomGeneId(ds, classId, randomness, SALT_25),\\n                getRandomGeneId(ds, classId, randomness, SALT_26)\\n            );\\n        }\\n\\n        //  HORN\\n        if (matching > 0 && LibRNG.expand(10000, randomness, SALT_31) < inheritanceChance) {\\n            //  inherit\\n            if (matching == 3) {\\n                if(LibRNG.expand(2, randomness, SALT_32) == 1) {\\n                    dna = LibUnicornDNA._inheritHorn(dna, firstParentDNA);\\n                } else {\\n                    dna = LibUnicornDNA._inheritHorn(dna, secondParentDNA);\\n                }\\n            } else if (matching == 2) {\\n                dna = LibUnicornDNA._inheritHorn(dna, secondParentDNA);\\n            } else {\\n                dna = LibUnicornDNA._inheritHorn(dna, firstParentDNA);\\n            }\\n        } else {\\n            //  randomize\\n            partId = getRandomPartId(ds, classId, HORN_SLOT, randomness, SALT_33);\\n            dna = LibUnicornDNA._multiSetHorn(\\n                dna,\\n                ds.bodyPartLocalIdFromGlobalId[partId],\\n                ds.bodyPartInheritedGene[partId],\\n                getRandomGeneId(ds, classId, randomness, SALT_35),\\n                getRandomGeneId(ds, classId, randomness, SALT_36)\\n            );\\n        }\\n\\n        //  HOOVES\\n        if (matching > 0 && LibRNG.expand(10000, randomness, SALT_41) < inheritanceChance) {\\n            //  inherit\\n            if (matching == 3) {\\n                if(LibRNG.expand(2, randomness, SALT_42) == 1) {\\n                    dna = LibUnicornDNA._inheritHooves(dna, firstParentDNA);\\n                } else {\\n                    dna = LibUnicornDNA._inheritHooves(dna, secondParentDNA);\\n                }\\n            } else if (matching == 2) {\\n                dna = LibUnicornDNA._inheritHooves(dna, secondParentDNA);\\n            } else {\\n                dna = LibUnicornDNA._inheritHooves(dna, firstParentDNA);\\n            }\\n        } else {\\n            //  randomize\\n            partId = getRandomPartId(ds, classId, HOOVES_SLOT, randomness, SALT_43);\\n            dna = LibUnicornDNA._multiSetHooves(\\n                dna,\\n                ds.bodyPartLocalIdFromGlobalId[partId],\\n                ds.bodyPartInheritedGene[partId],\\n                getRandomGeneId(ds, classId, randomness, SALT_45),\\n                getRandomGeneId(ds, classId, randomness, SALT_46)\\n            );\\n        }\\n\\n        //  MANE\\n        if (matching > 0 && LibRNG.expand(10000, randomness, SALT_51) < inheritanceChance) {\\n            //  inherit\\n            if (matching == 3) {\\n                if(LibRNG.expand(2, randomness, SALT_52) == 1) {\\n                    dna = LibUnicornDNA._inheritMane(dna, firstParentDNA);\\n                } else {\\n                    dna = LibUnicornDNA._inheritMane(dna, secondParentDNA);\\n                }\\n            } else if(matching == 2) {\\n                dna = LibUnicornDNA._inheritMane(dna, secondParentDNA);\\n            } else {\\n                dna = LibUnicornDNA._inheritMane(dna, firstParentDNA);\\n            }\\n        } else {\\n            //  randomize\\n            partId = getRandomPartId(ds, classId, MANE_SLOT, randomness, SALT_53);\\n            dna = LibUnicornDNA._multiSetMane(\\n                dna,\\n                ds.bodyPartLocalIdFromGlobalId[partId],\\n                ds.bodyPartInheritedGene[partId],\\n                getRandomGeneId(ds, classId, randomness, SALT_55),\\n                getRandomGeneId(ds, classId, randomness, SALT_56)\\n            );\\n        }\\n\\n        //  TAIL\\n        if (matching > 0 && LibRNG.expand(10000, randomness, SALT_61) < inheritanceChance) {\\n            //  inherit\\n            if (matching == 3) {\\n                if(LibRNG.expand(2, randomness, SALT_62) == 1) {\\n                    dna = LibUnicornDNA._inheritTail(dna, firstParentDNA);\\n                } else {\\n                    dna = LibUnicornDNA._inheritTail(dna, secondParentDNA);\\n                }\\n            } else if (matching == 2){\\n                dna = LibUnicornDNA._inheritTail(dna, secondParentDNA);\\n            } else {\\n                dna = LibUnicornDNA._inheritTail(dna, firstParentDNA);\\n            }\\n        } else {\\n            //  randomize\\n            partId = getRandomPartId(ds, classId, TAIL_SLOT, randomness, SALT_63);\\n            dna = LibUnicornDNA._multiSetTail(\\n                dna,\\n                ds.bodyPartLocalIdFromGlobalId[partId],\\n                ds.bodyPartInheritedGene[partId],\\n                getRandomGeneId(ds, classId, randomness, SALT_65),\\n                getRandomGeneId(ds, classId, randomness, SALT_66)\\n            );\\n        }\\n        return dna;\\n    }\\n\\n    //  Chooses a bodypart from the weighted random pool in `partsBySlot` and returns the id\\n    //  @param _classId Index the unicorn class\\n    //  @param _slotId Index of the bodypart slot\\n    //  @return Struct of the body part\\n    function getRandomPartId(\\n        LibDiamond.DiamondStorage storage ds,\\n        uint256 _classId,\\n        uint256 _slotId,\\n        uint256 _rngSeed,\\n        uint256 _salt\\n    ) internal view returns (uint256) {\\n        uint256 numBodyParts = ds.bodyPartBuckets[_classId][_slotId].length;\\n        uint256 totalWeight = 0;\\n        for (uint i = 0; i < numBodyParts; i++) {\\n            totalWeight += ds.bodyPartWeight[ds.bodyPartBuckets[_classId][_slotId][i]];\\n        }\\n        uint256 target = LibRNG.expand(totalWeight, _rngSeed, _salt) + 1;\\n        uint256 cumulativeWeight = 0;\\n        for (uint i = 0; i < numBodyParts; ++i) {\\n            uint256 globalId = ds.bodyPartBuckets[_classId][_slotId][i];\\n            uint256 partWeight = ds.bodyPartWeight[globalId];\\n            cumulativeWeight += partWeight;\\n            if (target <= cumulativeWeight) {\\n                return globalId;\\n            }\\n        }\\n        revert(\\\"LibHatching: Failed getting RNG bodyparts\\\");\\n    }\\n\\n    function getRandomGeneId(\\n        LibDiamond.DiamondStorage storage ds,\\n        uint256 _classId,\\n        uint256 _rngSeed,\\n        uint256 _salt\\n    ) internal view returns (uint256) {\\n        uint256 numGenes = ds.geneBuckets[_classId].length;\\n        uint256 target = LibRNG.expand(ds.geneBucketSumWeights[_classId], _rngSeed, _salt) + 1;\\n        uint256 cumulativeWeight = 0;\\n        for (uint i = 0; i < numGenes; ++i) {\\n            uint256 geneId = ds.geneBuckets[_classId][i];\\n            cumulativeWeight += ds.geneWeightById[geneId];\\n            if (target <= cumulativeWeight) {\\n                return geneId;\\n            }\\n        }\\n        revert(\\\"LibHatching: Failed getting RNG gene\\\");\\n    }\\n\\n    function completeBeginHatching(bytes32 vrfRequestId, uint256 blockDeadline, uint256 tokenId, uint256 inheritanceChance, uint256 roundTripId) private {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        saveDataOnHatchingStruct(roundTripId, vrfRequestId, blockDeadline, tokenId, inheritanceChance);\\n        LibIdempotence._setIdempotenceState(tokenId, LibIdempotence._setHatchingStarted(tokenId, true));\\n        emit HatchingRNGRequested(roundTripId, vrfRequestId, ds.erc721_owners[tokenId]);\\n        emit HatchingRNGRequestedV2(roundTripId, vrfRequestId, ds.erc721_owners[tokenId], msg.sender);\\n    }\\n\\n    function beginHatching(uint256 roundTripId, uint256 blockDeadline, uint256 tokenId, uint256 inheritanceChance) internal {\\n        validateBeginHatching(blockDeadline, tokenId);\\n        uint256 vrfRequestId = LibRNG.requestRandomWordsFor(LibRNG.RNG_HATCHING);\\n        completeBeginHatching(bytes32(vrfRequestId), blockDeadline, tokenId, inheritanceChance, roundTripId);\\n    }\\n\\n    function validateBeginHatching(uint256 blockDeadline, uint256 tokenId) private view {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        require(blockDeadline >= ds.vrfBlocksToRespond + block.number , \\\"LibHatching: TTL has expired.\\\"); \\n\\n        LibPermissions.enforceCallerOwnsNFTOrHasPermission(tokenId, IPermissionProvider.Permission.UNICORN_HATCHING_ALLOWED);\\n        require(!LibIdempotence._getGenesisHatching(tokenId), \\\"LibHatching: IDMP currently genesisHatching\\\");\\n        require(!LibIdempotence._getHatching(tokenId), \\\"LibHatching: IDMP currently hatching\\\");\\n        require(!LibIdempotence._getHatchingStarted(tokenId), \\\"LibHatching: IDMP already started hatching\\\");\\n        require(!LibIdempotence._getHatchingRandomnessFulfilled(tokenId), \\\"LibHatching: IDMP already received hatch RNG\\\");\\n        require(!LibIdempotence._getNewEggWaitingForRNG(tokenId), \\\"LibHatching: IDMP new egg waiting for RNG\\\");\\n        require(!LibIdempotence._getNewEggReceivedRNGWaitingForTokenURI(tokenId), \\\"LibHatching: IDMP new egg waiting for tokenURI\\\");\\n        require(ds.bio_clock[tokenId] + 300 <= block.timestamp, \\\"LibHatching: Egg has to be at least 5 minutes old to hatch\\\");\\n        uint256 dna = LibUnicornDNA._getDNA(tokenId);\\n        LibUnicornDNA.enforceDNAVersionMatch(dna);\\n        require(LibUnicornDNA._getLifecycleStage(dna) == LibUnicornDNA.LIFECYCLE_EGG, \\\"LibHatching: Only eggs can be hatched\\\");\\n        require(!LibUnicornDNA._getOrigin(dna), \\\"LibHatching: Only non origin eggs can be hatched in this facet\\\");\\n        require(LibUnicornDNA._getGameLocked(dna), \\\"LibHatching: Egg must be locked in order to begin hatching\\\");\\n    }\\n\\n    function hatchingFulfillRandomness(bytes32 requestId, uint256 randomness) internal {\\n        LibDiamond.enforceBlockDeadlineIsValid(getBlockDeadline(requestId));\\n        uint256 tokenId = getTokenId(requestId);\\n        require(LibIdempotence._getHatchingStarted(tokenId), \\\"LibHatching: Hatching has to be in STARTED state to fulfillRandomness\\\");\\n        setRandomness(requestId, randomness);\\n        updateIdempotenceAndEmitEvent(tokenId, getRoundTripId(requestId));\\n    }\\n\\n    function updateIdempotenceAndEmitEvent(uint256 tokenId, uint256 roundTripId) internal {\\n        LibIdempotence._setIdempotenceState(tokenId, LibIdempotence._setHatchingStarted(tokenId, false));\\n        LibIdempotence._setIdempotenceState(tokenId, LibIdempotence._setHatchingRandomnessFulfilled(tokenId, true));\\n        emit HatchingReadyForTokenURI(roundTripId, LibDiamond.diamondStorage().erc721_owners[tokenId]);\\n        emit HatchingReadyForTokenURIV2(roundTripId, LibDiamond.diamondStorage().erc721_owners[tokenId], msg.sender);\\n    }\\n\\n    //  Chooses a bodypart from the weighted random pool in `partsBySlot` and returns the id\\n    //  @param _classId Index the unicorn class\\n    //  @param _slotId Index of the bodypart slot\\n    //  @return Struct of the body part\\n    function getRandomPartId(uint256 _classId, uint256 _slotId) internal returns (uint256) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\n        uint256 i = 0;\\n        uint256 numBodyParts = ds.bodyPartBuckets[_classId][_slotId].length;\\n\\n        uint256 totalWeight = 0;\\n        for (i = 0; i < numBodyParts; i++) {\\n            totalWeight += ds.bodyPartWeight[ds.bodyPartBuckets[_classId][_slotId][i]];\\n        }\\n\\n        uint256 target = LibRNG.getRuntimeRNG(totalWeight) + 1;\\n        uint256 cumulativeWeight = 0;\\n\\n        for (i = 0; i < numBodyParts; i++) {\\n            uint256 globalId = ds.bodyPartBuckets[_classId][_slotId][i];\\n            uint256 partWeight = ds.bodyPartWeight[globalId];\\n            cumulativeWeight += partWeight;\\n            if(target <= cumulativeWeight) {\\n                return globalId;\\n            }\\n        }\\n        revert(\\\"LibHatching: Failed getting RNG bodyparts\\\");\\n    }\\n\\n    function getRandomGeneId(uint256 _classId) internal returns (uint256) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\n        uint256 numGenes = ds.geneBuckets[_classId].length;\\n\\n        uint256 i = 0;\\n        uint256 totalWeight = ds.geneBucketSumWeights[_classId];\\n\\n        uint256 target = LibRNG.getRuntimeRNG(totalWeight) + 1;\\n        uint256 cumulativeWeight = 0;\\n\\n        for (i = 0; i < numGenes; i++) {\\n            uint256 geneId = ds.geneBuckets[_classId][i];\\n            cumulativeWeight += ds.geneWeightById[geneId];\\n            if(target <= cumulativeWeight) {\\n                return geneId;\\n            }\\n        }\\n\\n        revert(\\\"LibHatching: Failed getting RNG gene\\\");\\n    }\\n\\n    function getParentDNAs(uint256 tokenId) internal view returns(uint256[2] memory parentDNA) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 firstParentId = ds.unicornParents[tokenId][0];\\n        uint256 secondParentId = ds.unicornParents[tokenId][1];\\n        parentDNA[0] = LibUnicornDNA._getDNA(firstParentId);\\n        parentDNA[1] = LibUnicornDNA._getDNA(secondParentId);\\n        return parentDNA;\\n    }\\n\\n    function retryHatching(uint256 roundTripId) internal {\\n        bytes32 requestId = getVRFRequestId(roundTripId);\\n        uint256 tokenId = getTokenId(requestId);\\n\\n        LibPermissions.enforceCallerOwnsNFTOrHasPermission(tokenId, IPermissionProvider.Permission.UNICORN_HATCHING_ALLOWED);\\n        uint256 blockDeadline = getBlockDeadline(requestId);\\n        require(blockDeadline > 0, \\\"LibHatching: Transaction not found\\\");\\n        require(block.number > blockDeadline, \\\"LibHatching: Cannot retry while old TTL is ongoing\\\");\\n        require(LibIdempotence._getHatchingStarted(tokenId), \\\"LibHatching: Hatching has to be in STARTED state to retry hatching\\\");\\n        uint256 randomness = LibRNG.getRuntimeRNG();\\n        setRandomness(requestId, randomness);\\n        updateIdempotenceAndEmitEvent(tokenId, roundTripId);\\n    }\\n\\n    function finishHatching(uint256 roundTripId, uint256 tokenId, bytes32 vrfRequestId, string memory tokenURI) internal {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\n        LibPermissions.enforceCallerOwnsNFTOrHasPermission(tokenId, IPermissionProvider.Permission.UNICORN_HATCHING_ALLOWED);\\n        require(LibIdempotence._getHatchingRandomnessFulfilled(tokenId), \\\"LibHatching: Cannot finish hatching before randomness has been fulfilled\\\");\\n        LibERC721.setTokenURI(tokenId, tokenURI);\\n\\n        uint256 newDNA;\\n        uint256 newBirthday = predictBabyBirthday(tokenId);\\n        \\n        if(LibUnicornDNA.dnaStorage().cachedDNA[tokenId] > 0) {\\n            // Check for any DNA held over from old versions of the deterministic logic...\\n            newDNA = LibUnicornDNA.dnaStorage().cachedDNA[tokenId];\\n            delete LibUnicornDNA.dnaStorage().cachedDNA[tokenId];\\n        } else {\\n            newDNA = predictBabyDNA(tokenId);\\n        }\\n\\n        ds.hatch_birthday[tokenId] = newBirthday;\\n        LibUnicornDNA._setDNA(tokenId, newDNA);\\n        ds.bio_clock[tokenId] = block.timestamp;\\n        \\n        LibIdempotence._setIdempotenceState(tokenId, LibIdempotence._setHatchingRandomnessFulfilled(tokenId, false));\\n        emit HatchingComplete(roundTripId, ds.erc721_owners[tokenId]);\\n        emit HatchingCompleteV2(roundTripId, ds.erc721_owners[tokenId], msg.sender);\\n        //  clean up workflow data:\\n        delete ds.rng_randomness[vrfRequestId];\\n        cleanUpRoundTrip(vrfRequestId);\\n    }\\n\\n}\"\r\n    },\r\n    \"LibERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC721Receiver.sol\\\";\\nimport \\\"Address.sol\\\";\\n\\nimport {LibUnicornDNA} from \\\"LibUnicornDNA.sol\\\";\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibAirlock} from \\\"LibAirlock.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\n\\nlibrary LibERC721 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal {\\n        transfer(from, to, tokenId);\\n        require(\\n            checkOnERC721Received(from, to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`mint`),\\n     * and stop existing when they are burned (`burn`).\\n     */\\n    function exists(uint256 tokenId) internal view returns (bool) {\\n        return LibDiamond.diamondStorage().erc721_owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(\\n            exists(tokenId),\\n            \\\"ERC721: operator query for nonexistent token\\\"\\n        );\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeMint(address to, uint256 tokenId) internal {\\n        safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-safeMint-address-uint256-}[`safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal {\\n        mint(to, tokenId);\\n        require(\\n            checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        beforeTokenTransfer(address(0), to, tokenId);\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.erc721_balances[to] += 1;\\n        ds.erc721_owners[tokenId] = to;\\n\\n        emit LibEvents.Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function burn(uint256 tokenId) internal {\\n        enforceUnicornIsTransferable(tokenId);\\n        address owner = ownerOf(tokenId);\\n\\n        beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        approve(address(0), tokenId);\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.erc721_balances[owner] -= 1;\\n        delete ds.erc721_owners[tokenId];\\n\\n        if (bytes(ds.erc721_tokenURIs[tokenId]).length != 0) {\\n            delete ds.erc721_tokenURIs[tokenId];\\n        }\\n\\n        emit LibEvents.Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(\\n            ownerOf(tokenId) == from,\\n            \\\"ERC721: transfer of token that is not own\\\"\\n        );\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        enforceUnicornIsTransferable(tokenId);\\n\\n        beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        approve(address(0), tokenId);\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.erc721_balances[from] -= 1;\\n        ds.erc721_balances[to] += 1;\\n        ds.erc721_owners[tokenId] = to;\\n\\n        emit LibEvents.Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) internal {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.erc721_tokenApprovals[tokenId] = to;\\n        emit LibEvents.Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.erc721_operatorApprovals[owner][operator] = approved;\\n        emit LibEvents.ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal returns (bool) {\\n        if (to.isContract()) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\n                        \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n                    );\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        if (from == address(0)) {\\n            addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function addTokenToOwnerEnumeration(address to, uint256 tokenId) internal {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 length = balanceOf(to);\\n        ds.erc721_ownedTokens[to][length] = tokenId;\\n        ds.erc721_ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\\n        internal\\n    {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n        uint256 lastTokenIndex = balanceOf(from) - 1;\\n        uint256 tokenIndex = ds.erc721_ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = ds.erc721_ownedTokens[from][lastTokenIndex];\\n\\n            ds.erc721_ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            ds.erc721_ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete ds.erc721_ownedTokensIndex[tokenId];\\n        delete ds.erc721_ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function addTokenToAllTokensEnumeration(uint256 tokenId) internal {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\n        ds.erc721_allTokensIndex[tokenId] = ds.erc721_allTokens.length;\\n        ds.erc721_allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function removeTokenFromAllTokensEnumeration(uint256 tokenId) internal {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ds.erc721_allTokens.length - 1;\\n        uint256 tokenIndex = ds.erc721_allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = ds.erc721_allTokens[lastTokenIndex];\\n\\n        ds.erc721_allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        ds.erc721_allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete ds.erc721_allTokensIndex[tokenId];\\n        ds.erc721_allTokens.pop();\\n    }\\n\\n    function ownerOf(uint256 tokenId) internal view returns(address) {\\n        address owner = LibDiamond.diamondStorage().erc721_owners[tokenId];\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: owner query for nonexistent token\\\"\\n        );\\n        return owner;\\n    }\\n\\n    function getApproved(uint256 tokenId) internal view returns(address) {\\n        require(\\n            exists(tokenId),\\n            \\\"ERC721: approved query for nonexistent token\\\"\\n        );\\n\\n        return LibDiamond.diamondStorage().erc721_tokenApprovals[tokenId];\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) internal view returns(bool) {\\n        return LibDiamond.diamondStorage().erc721_operatorApprovals[owner][operator];\\n    }\\n\\n    function balanceOf(address owner) internal view returns(uint256) {\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: balance query for the zero address\\\"\\n        );\\n        return LibDiamond.diamondStorage().erc721_balances[owner];\\n    }\\n\\n    function enforceUnicornIsTransferable(uint256 tokenId) internal view {\\n        require(\\n            unicornIsTransferable(tokenId),\\n            \\\"LibERC721: Unicorn must be unlocked from game before transfering\\\"\\n        );\\n    }\\n\\n    function unicornIsTransferable(uint256 tokenId) internal view returns(bool) {\\n        return (\\n            LibAirlock.unicornIsLocked(tokenId) == false &&\\n            LibAirlock.unicornIsCoolingDown(tokenId) == false\\n            //  TODO: add idempotence checks here\\n        );\\n    }\\n\\n    function getTokenURI(uint256 tokenId) internal view returns (string memory) {\\n        return LibDiamond.diamondStorage().erc721_tokenURIs[tokenId];\\n    }\\n\\n    function setTokenURI(uint256 tokenId, string memory tokenURI) internal {\\n        LibDiamond.diamondStorage().erc721_tokenURIs[tokenId] = tokenURI;\\n    }\\n\\n    function enforceCallerOwnsNFT(uint256 tokenId) internal view {\\n        require(\\n            ownerOf(tokenId) == msg.sender,\\n            \\\"ERC721: Caller must own NFT\\\"\\n        );\\n    }\\n\\n    function mintNextToken(address _to)\\n        internal\\n        returns (uint256 nextTokenId)\\n    {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        nextTokenId = ds.erc721_current_token_id + 1;\\n        mint(_to, nextTokenId);\\n        ds.erc721_current_token_id = nextTokenId;\\n        return nextTokenId;\\n    }\\n\\n    function setDNAForGenesisToken(uint256 _tokenId, uint8 _class)\\n        internal\\n        returns (uint256)\\n    {\\n        require(\\n            _tokenId <= LibDiamond.ERC721_GENESIS_TOKENS,\\n            \\\"LibERC721: Can only set DNA for genesis tokens\\\"\\n        );\\n        uint256 dna = 0;\\n        dna = LibUnicornDNA._setVersion(dna, LibUnicornDNA._targetDNAVersion());\\n        dna = LibUnicornDNA._setOrigin(dna, true);\\n        dna = LibUnicornDNA._setGameLocked(dna, false);\\n        dna = LibUnicornDNA._setLimitedEdition(dna, false);\\n        dna = LibUnicornDNA._setLifecycleStage(\\n            dna,\\n            LibUnicornDNA.LIFECYCLE_EGG\\n        );\\n        dna = LibUnicornDNA._setBreedingPoints(dna, 0);\\n        dna = LibUnicornDNA._setClass(dna, _class);\\n        return LibUnicornDNA._setDNA(_tokenId, dna);\\n    }\\n\\n    /**\\n     * Unicorn DNA methods\\n     */\\n    function getDNA(uint256 _tokenId) internal view returns (uint256) {\\n        return LibUnicornDNA._getDNA(_tokenId);\\n    }\\n\\n}\"\r\n    },\r\n    \"IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"LibAirlock.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibERC721} from \\\"LibERC721.sol\\\";\\nimport {LibServerSideSigning} from \\\"LibServerSideSigning.sol\\\";\\nimport {LibUnicornDNA} from \\\"LibUnicornDNA.sol\\\";\\n\\n\\nlibrary LibAirlock {\\n\\n    event UnicornLockedIntoGame(uint256 tokenId, address locker);\\n    event UnicornLockedIntoGameV2(uint256 indexed tokenId, address indexed owner, address indexed locker);\\n    event UnicornUnlockedOutOfGame(uint256 tokenId, address locker);\\n    event UnicornUnlockedOutOfGameV2(uint256 indexed tokenId, address indexed owner, address indexed locker);\\n    event UnicornUnlockedOutOfGameForcefully(uint256 timestamp, uint256 tokenId, address locker);\\n\\n    function enforceDNAIsLocked(uint256 dna) internal pure {\\n        require(\\n            LibUnicornDNA._getGameLocked(dna),\\n            \\\"LibAirlock: Unicorn DNA must be locked into game.\\\"\\n        );\\n    }\\n\\n    function enforceUnicornIsLocked(uint256 tokenId) internal view {\\n        require(\\n            LibUnicornDNA._getGameLocked(LibUnicornDNA._getDNA(tokenId)),\\n            \\\"LibAirlock: Unicorn must be locked into game.\\\"\\n        );\\n    }\\n\\n    function enforceDNAIsUnlocked(uint256 dna) internal pure {\\n        require(\\n            LibUnicornDNA._getGameLocked(dna) == false,\\n            \\\"LibAirlock: Unicorn DNA must be unlocked.\\\"\\n        );\\n    }\\n\\n    function enforceUnicornIsUnlocked(uint256 tokenId) internal view {\\n        require(\\n            LibUnicornDNA._getGameLocked(LibUnicornDNA._getDNA(tokenId)) == false,\\n            \\\"LibAirlock: Unicorn must be unlocked.\\\"\\n        );\\n    }\\n\\n    function enforceUnicornIsNotCoolingDown(uint256 tokenId) internal view {\\n        require(!unicornIsCoolingDown(tokenId),\\n            \\\"LibAirlock: Unicorn is cooling down from force unlock.\\\"\\n        );\\n    }\\n\\n    function unicornIsLocked(uint256 tokenId) internal view returns (bool) {\\n        return LibUnicornDNA._getGameLocked(LibUnicornDNA._getDNA(tokenId));\\n    }\\n\\n    function dnaIsLocked(uint256 dna) internal pure returns (bool) {\\n        return LibUnicornDNA._getGameLocked(dna);\\n    }\\n\\n    function unicornIsCoolingDown(uint256 tokenId) internal view returns (bool) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        return ds.erc721_unicornLastForceUnlock[tokenId] != 0 && (ds.erc721_unicornLastForceUnlock[tokenId] + ds.erc721_forceUnlockUnicornCooldown) >= block.timestamp;\\n    }\\n\\n    function lockUnicornIntoGame(uint256 tokenId) internal {\\n        lockUnicornIntoGame(tokenId, true);\\n    }\\n\\n    function lockUnicornIntoGame(uint256 tokenId, bool emitLockedEvent) internal {\\n        enforceUnicornIsNotCoolingDown(tokenId);\\n        uint256 dna = LibUnicornDNA._getDNA(tokenId);\\n        LibUnicornDNA.enforceDNAVersionMatch(dna);\\n        enforceDNAIsUnlocked(dna);\\n        dna = LibUnicornDNA._setGameLocked(dna, true);\\n        LibUnicornDNA._setDNA(tokenId, dna);\\n        if (emitLockedEvent) {\\n            emit UnicornLockedIntoGame(tokenId, msg.sender);\\n            emit UnicornLockedIntoGameV2(tokenId, LibDiamond.diamondStorage().erc721_owners[tokenId], msg.sender);\\n        }\\n    }\\n\\n    function unlockUnicornOutOfGameGenerateMessageHash(\\n        uint256 tokenId,\\n        string memory tokenURI,\\n        uint256 requestId,\\n        uint256 blockDeadline\\n    ) internal view returns (bytes32) {\\n        /* solhint-disable max-line-length */\\n        bytes32 structHash = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"UnlockUnicornOutOfGamePayload(uint256 tokenId, string memory tokenURI, uint256 requestId, uint256 blockDeadline)\\\"\\n                ),\\n                tokenId,\\n                tokenURI,\\n                requestId,\\n                blockDeadline\\n            )\\n        );\\n        return LibServerSideSigning._hashTypedDataV4(structHash);\\n        /* solhint-enable max-line-length */\\n    }\\n\\n    function unlockUnicornOutOfGame(\\n        uint256 tokenId,\\n        string memory tokenURI\\n    ) internal {\\n        unlockUnicornOutOfGame(tokenId, tokenURI, true);\\n    }\\n\\n    function unlockUnicornOutOfGame(\\n        uint256 tokenId,\\n        string memory tokenURI,\\n        bool emitUnlockEvent\\n    ) internal {\\n        \\n        _unlockUnicorn(tokenId);\\n        LibERC721.setTokenURI(tokenId, tokenURI);\\n        if (emitUnlockEvent) {\\n            emit UnicornUnlockedOutOfGame(tokenId, msg.sender);\\n            emit UnicornUnlockedOutOfGameV2(tokenId, LibDiamond.diamondStorage().erc721_owners[tokenId], msg.sender);\\n        }\\n    }\\n\\n    function forceUnlockUnicornOutOfGame(uint256 tokenId) internal {\\n        _unlockUnicorn(tokenId);\\n        LibDiamond.diamondStorage().erc721_unicornLastForceUnlock[tokenId] = block.timestamp;\\n        emit UnicornUnlockedOutOfGameForcefully(block.timestamp, tokenId, msg.sender);\\n    }\\n\\n    function _unlockUnicorn(uint256 tokenId) private {\\n        uint256 dna = LibUnicornDNA._getDNA(tokenId);\\n        LibUnicornDNA.enforceDNAVersionMatch(dna);\\n        enforceDNAIsLocked(dna);\\n        enforceUnicornIsNotCoolingDown(tokenId);\\n        dna = LibUnicornDNA._setGameLocked(dna, false);\\n        LibUnicornDNA._setDNA(tokenId, dna);\\n    }\\n}\\n\"\r\n    },\r\n    \"LibServerSideSigning.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\n/**\\n * Much of the functionality in this library is adapted from OpenZeppelin's EIP712 implementation:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/cryptography/draft-EIP712.sol\\n */\\n\\nimport \\\"ECDSA.sol\\\";\\n\\nlibrary LibServerSideSigning {\\n    bytes32 internal constant SERVER_SIDE_SIGNING_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.ServerSideSigning.storage\\\");\\n\\n    /* solhint-disable var-name-mixedcase */\\n    struct ServerSideSigningStorage {\\n        string name;\\n        string version;\\n        bytes32 CACHED_DOMAIN_SEPARATOR;\\n        uint256 CACHED_CHAIN_ID;\\n        bytes32 HASHED_NAME;\\n        bytes32 HASHED_VERSION;\\n        bytes32 TYPE_HASH;\\n        mapping(uint256 => bool) completedRequests;\\n    } /* solhint-enable var-name-mixedcase */\\n\\n    function serverSideSigningStorage()\\n        internal\\n        pure\\n        returns (ServerSideSigningStorage storage ss)\\n    {\\n        bytes32 position = SERVER_SIDE_SIGNING_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            ss.slot := position\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) internal view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    function _setEIP712Parameters(string memory name, string memory version)\\n        internal\\n    {\\n        ServerSideSigningStorage storage ss = serverSideSigningStorage();\\n        ss.name = name;\\n        ss.version = version;\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        ss.HASHED_NAME = hashedName;\\n        ss.HASHED_VERSION = hashedVersion;\\n        ss.CACHED_CHAIN_ID = block.chainid;\\n        ss.CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\\n            typeHash,\\n            hashedName,\\n            hashedVersion\\n        );\\n        ss.TYPE_HASH = typeHash;\\n    }\\n\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        ServerSideSigningStorage storage ss = serverSideSigningStorage();\\n        if (block.chainid == ss.CACHED_CHAIN_ID) {\\n            return ss.CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(ss.TYPE_HASH, ss.HASHED_NAME, ss.HASHED_VERSION);\\n        }\\n    }\\n\\n    function _hashTypedDataV4(bytes32 structHash) internal view returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n\\n    function _completeRequest(uint256 requestId) internal {\\n        ServerSideSigningStorage storage ss = serverSideSigningStorage();\\n        ss.completedRequests[requestId] = true;\\n    }\\n\\n    function _clearRequest(uint256 requestId) internal {\\n        ServerSideSigningStorage storage ss = serverSideSigningStorage();\\n        ss.completedRequests[requestId] = false;\\n    }\\n\\n    function _checkRequest(uint256 requestId) internal view returns (bool) {\\n        ServerSideSigningStorage storage ss = serverSideSigningStorage();\\n        return ss.completedRequests[requestId];\\n    }\\n\\n    // TODO(zomglings): Add a function called `_invalidateServerSideSigningRequest(uint256 requestId)`.\\n    // Invalidation can be achieved by setting completedRequests[requestId] = true.\\n    // Similarly, we may want to add a `_clearRequest` function which sets to false.\\n}\\n\"\r\n    },\r\n    \"ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"LibEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary LibEvents {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n}\"\r\n    },\r\n    \"LibIdempotence.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibBin} from \\\"LibBin.sol\\\";\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibUtil} from \\\"LibUtil.sol\\\";\\n\\nlibrary LibIdempotence {\\n\\n    uint256 internal constant MAX =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    //  GENESIS_HATCHING is in bit 0 = 0b1\\n    uint256 public constant IDMP_GENESIS_HATCHING_MASK = 0x1;\\n    //  HATCHING is in bit 1 = 0b10\\n    uint256 public constant IDMP_HATCHING_MASK = 0x2;\\n    //  EVOLVING is in bit 2 = 0b100\\n    uint256 public constant IDMP_EVOLVING_MASK = 0x4;\\n    //  PARENT IS BREEDING is in bit 3 = 0b1000\\n    uint256 public constant IDMP_PARENT_IS_BREEDING_MASK = 0x8;\\n    // NEW_EGG_WAITING_FOR_RNG is in bit 4 = 0b10000\\n    uint256 public constant IDMP_NEW_EGG_WAITING_FOR_RNG_MASK = 0x10;\\n    // NEW_EGG_RNG_RECEIVED_WAITING_FOR_TOKENURI is in bit 5 = 0b100000\\n    uint256 public constant IDMP_NEW_EGG_RNG_RECEIVED_WAITING_FOR_TOKENURI_MASK = 0x20;\\n    // HATCHING_STARTED is in bit 6 = 0b1000000\\n    uint256 public constant IDMP_HATCHING_STARTED_MASK = 0x40;\\n    // HATCHING_RANDOMNESS_FULFILLED is in bit 7 = 0b10000000\\n    uint256 public constant IDMP_HATCHING_RANDOMNESS_FULFILLED_MASK = 0x80;\\n    // EVOLUTION_STARTED is int bit 8 = 0b100000000\\n    uint256 public constant IDMP_EVOLUTION_STARTED_MASK = 0x100;\\n    // EVOLUTION_RANDOMNESS_FULFILLED is int bit 9 = 0b1000000000\\n    uint256 public constant IDMP_EVOLUTION_RANDOMNESS_FULFILLED_MASK = 0x200;\\n\\n    function enforceCleanState(uint256 _tokenId) internal view returns (bool) {\\n        require(\\n            !_getGenesisHatching(_tokenId) &&\\n            !_getHatching(_tokenId) &&\\n            !_getEvolving(_tokenId) &&\\n            !_getParentIsBreeding(_tokenId) &&\\n            !_getNewEggWaitingForRNG(_tokenId) &&\\n            !_getNewEggReceivedRNGWaitingForTokenURI(_tokenId),\\n            LibUtil.concat(\\n                \\\"LibIdempotence: Token [\\\",\\n                LibUtil.uintToString(_tokenId),\\n                \\\"] is already in a workflow: \\\",\\n                LibUtil.uintToString(_getIdempotenceState(_tokenId))\\n            )\\n        );\\n    }\\n\\n    function _getIdempotenceState(uint256 _tokenId) internal view returns (uint256) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        return ds.idempotence_state[_tokenId];\\n    }\\n\\n    function _setIdempotenceState(uint256 _tokenId, uint256 _state)\\n        internal\\n        returns (uint256)\\n    {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.idempotence_state[_tokenId] = _state;\\n        return _state;\\n    }\\n\\n    function _clearState(uint256 _tokenId) internal {\\n        _setIdempotenceState(_tokenId, 0);\\n    }\\n\\n    function _setGenesisHatching(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val, IDMP_GENESIS_HATCHING_MASK);\\n    }\\n\\n    function _getGenesisHatching(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_GENESIS_HATCHING_MASK);\\n    }\\n\\n    function _setHatching(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val, IDMP_HATCHING_MASK);\\n    }\\n\\n    function _getHatching(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_HATCHING_MASK);\\n    }\\n\\n    function _setHatchingStarted(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        require((_getHatchingRandomnessFulfilled(_tokenId) && _val) == false, \\\"Cannot set both hatching flags in true\\\");\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val, IDMP_HATCHING_STARTED_MASK);\\n    }\\n\\n    function _getHatchingStarted(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_HATCHING_STARTED_MASK);\\n    }\\n\\n    function _setHatchingRandomnessFulfilled(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        require((_getHatchingStarted(_tokenId) && _val) == false, \\\"Cannot set both hatching flags in true\\\");\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val, IDMP_HATCHING_RANDOMNESS_FULFILLED_MASK);\\n    }\\n\\n    function _getHatchingRandomnessFulfilled(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_HATCHING_RANDOMNESS_FULFILLED_MASK);\\n    }\\n\\n    function _setEvolving(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val, IDMP_EVOLVING_MASK);\\n    }\\n\\n    function _getEvolving(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_EVOLVING_MASK);\\n    }\\n\\n    function _setParentIsBreeding(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val, IDMP_PARENT_IS_BREEDING_MASK);\\n    }\\n    function _getParentIsBreeding(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_PARENT_IS_BREEDING_MASK);\\n    }\\n\\n    function _setNewEggWaitingForRNG(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        require((_getNewEggReceivedRNGWaitingForTokenURI(_tokenId) && _val) == false, \\\"Cannot set both new_egg flags in true\\\");\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val, IDMP_NEW_EGG_WAITING_FOR_RNG_MASK);\\n    }\\n    function _getNewEggWaitingForRNG(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_NEW_EGG_WAITING_FOR_RNG_MASK);\\n    }\\n\\n    function _setNewEggReceivedRNGWaitingForTokenURI(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        require((_getNewEggWaitingForRNG(_tokenId) && _val) == false, \\\"Cannot set both new_egg flags in true\\\");\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val, IDMP_NEW_EGG_RNG_RECEIVED_WAITING_FOR_TOKENURI_MASK);\\n    }\\n\\n    function _getNewEggReceivedRNGWaitingForTokenURI(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_NEW_EGG_RNG_RECEIVED_WAITING_FOR_TOKENURI_MASK);\\n    }\\n\\n    function _setEvolutionStarted(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        require((_getEvolutionRandomnessFulfilled(_tokenId) && _val) == false, \\\"Cannot set both evolution flags in true\\\");\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val,  IDMP_EVOLUTION_STARTED_MASK);\\n    }\\n\\n    function _getEvolutionStarted(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_EVOLUTION_STARTED_MASK);\\n    }\\n\\n    function _setEvolutionRandomnessFulfilled(uint256 _tokenId, bool _val)\\n        internal\\n        returns (uint256)\\n    {\\n        require((_getEvolutionStarted(_tokenId) && _val) == false, \\\"Cannot set both evolution flags in true\\\");\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.splice(state, _val,  IDMP_EVOLUTION_RANDOMNESS_FULFILLED_MASK);\\n    }\\n\\n    function _getEvolutionRandomnessFulfilled(uint256 _tokenId) internal view returns (bool) {\\n        uint256 state = _getIdempotenceState(_tokenId);\\n        return LibBin.extractBool(state, IDMP_EVOLUTION_RANDOMNESS_FULFILLED_MASK);\\n    }\\n}\\n\"\r\n    },\r\n    \"LibUtil.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibBin} from \\\"LibBin.sol\\\";\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\n\\n\\nlibrary LibUtil {\\n\\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\\n        return string(abi.encodePacked(a, \\\" \\\", b));\\n    }\\n\\n    function concat(string memory a, string memory b, string memory c) internal pure returns (string memory) {\\n        return string(abi.encodePacked(a, \\\" \\\", b, \\\" \\\", c));\\n    }\\n\\n    function concat(\\n        string memory a,\\n        string memory b,\\n        string memory c,\\n        string memory d\\n    ) internal pure returns (string memory) {\\n        return string(abi.encodePacked(a, \\\" \\\", b, \\\" \\\", c, \\\" \\\", d));\\n    }\\n\\n    //  @see: https://stackoverflow.com/questions/47129173/how-to-convert-uint-to-string-in-solidity\\n    function uintToString(uint _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len;\\n        while (_i != 0) {\\n            k = k-1;\\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\"\r\n    },\r\n    \"LibRNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LinkTokenInterface} from \\\"LinkTokenInterface.sol\\\";\\nimport \\\"VRFCoordinatorV2Interface.sol\\\";\\n\\nlibrary LibRNG {\\n    uint256 internal constant RNG_BREEDING = 1;\\n    uint256 internal constant RNG_HATCHING = 2;\\n    uint256 internal constant RNG_EVOLUTION = 3;\\n\\n    bytes32 private constant RNGVRF_STORAGE_POSITION = keccak256(\\\"diamond.LibRNGVRFV2.storage\\\");\\n\\n    struct LibRNGVRFV2Storage {\\n        // Your subscription ID.\\n        //1923 mumbai\\n        uint64 subscriptionId;\\n\\n        // see https://docs.chain.link/docs/vrf-contracts/#configurations\\n        // mumbai = 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed\\n        address vrfCoordinator;\\n\\n        // The gas lane to use, which specifies the maximum gas price to bump to.\\n        // For a list of available gas lanes on each network,\\n        // see https://docs.chain.link/docs/vrf-contracts/#configurations\\n        //mumbai = 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f\\n        bytes32 keyHash;\\n\\n        // Depends on the number of requested values that you want sent to the\\n        // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\\n        // so 100,000 is a safe default for this example contract. Test and adjust\\n        // this limit based on the network that you select, the size of the request,\\n        // and the processing of the callback request in the fulfillRandomWords()\\n        // function.\\n        mapping (uint256 => uint32) callbackGasLimitForMechanicId;\\n\\n        // The default is 3, but you can set this higher.\\n        mapping (uint256 => uint16) confirmationsForMechanicId;\\n\\n        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.\\n        uint32 numWords;\\n    }\\n\\n    function vrfV2Storage() internal pure returns (LibRNGVRFV2Storage storage vrf) {\\n        bytes32 position = RNGVRF_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            vrf.slot := position\\n        }\\n    }\\n\\n    function requestRandomnessFor(uint256 mechanicId) internal returns(bytes32) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        bytes32 requestId = requestRandomness(\\n                ds.rng_chainlinkVRFKeyhash,\\n                ds.rng_chainlinkVRFFee\\n        );\\n        ds.rng_mechanicIdByVRFRequestId[requestId] = mechanicId;\\n        return requestId;\\n    }\\n\\n    function requestRandomWordsFor(uint256 mechanicId) internal returns(uint256) {\\n\\t\\tLibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        LibRNGVRFV2Storage storage vrfs = vrfV2Storage();\\n        uint32 callbackGasLimit = vrfs.callbackGasLimitForMechanicId[mechanicId];\\n        uint16 requestConfirmations = vrfs.confirmationsForMechanicId[mechanicId];\\n        uint256 requestId = VRFCoordinatorV2Interface(vrfs.vrfCoordinator).requestRandomWords(\\n            vrfs.keyHash,\\n            vrfs.subscriptionId,\\n            requestConfirmations,\\n            callbackGasLimit,\\n            vrfs.numWords\\n        );\\n\\t\\tds.rng_mechanicIdByVRFRequestId[bytes32(requestId)] = mechanicId;\\n\\t\\treturn requestId;\\n\\t}\\n\\n    function setVRFV2RequestConfirmationsByMechanicId(uint256 mechanicId, uint16 confirmations) internal {\\n\\t    vrfV2Storage().confirmationsForMechanicId[mechanicId] = confirmations;\\n    }\\n\\n    function setVRFV2NumWords(uint32 words) internal {\\n        vrfV2Storage().numWords = words;\\n    }\\n\\n    function setVRFV2CallbackGasLimitByMechanicId(uint256 mechanicId, uint32 limit) internal {\\n        vrfV2Storage().callbackGasLimitForMechanicId[mechanicId] = limit;\\n    }\\n\\n    function setVRFV2KeyHash(bytes32 keyHash) internal {\\n        vrfV2Storage().keyHash = keyHash;\\n    }\\n\\n    function setVRFV2VrfCoordinatorAddress(address coordinator) internal {\\n        vrfV2Storage().vrfCoordinator = coordinator;\\n    }\\n\\n    function setVRFV2SubscriptionId(uint64 subscriptionId) internal {\\n        vrfV2Storage().subscriptionId = subscriptionId;\\n    }\\n\\n    function getVRFV2RequestConfirmationsByMechanicId(uint256 mechanicId) internal view returns(uint16) {\\n        return vrfV2Storage().confirmationsForMechanicId[mechanicId];\\n    }\\n\\n    function getVRFV2NumWords() internal view returns(uint32) {\\n        return vrfV2Storage().numWords;\\n    }\\n\\n    function getVRFV2CallbackGasLimitByMechanicId(uint256 mechanicId) internal view returns(uint32) {\\n        return vrfV2Storage().callbackGasLimitForMechanicId[mechanicId];\\n    }\\n\\n    function getVRFV2KeyHash() internal view returns(bytes32) {\\n        return vrfV2Storage().keyHash;\\n    }\\n\\n    function getVRFV2VrfCoordinatorAddress() internal view returns(address) {\\n        return vrfV2Storage().vrfCoordinator;\\n    }\\n\\n    function getVRFV2SubscriptionId() internal view returns(uint64) {\\n        return vrfV2Storage().subscriptionId;\\n    }\\n\\n\\tfunction makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n    }\\n\\tfunction makeVRFInputSeed(\\n        bytes32 _keyHash,\\n        uint256 _userSeed,\\n        address _requester,\\n        uint256 _nonce\\n    ) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n    }\\n\\n\\tfunction requestRandomness(\\n        bytes32 _keyHash,\\n        uint256 _fee\\n    ) internal returns (bytes32 requestId) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n\\t\\tLinkTokenInterface(ds.linkTokenAddress).transferAndCall(ds.vrfCoordinator, _fee, abi.encode(_keyHash, 0));\\n        // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n        // the hash of the block containing this request to obtain the seed/input\\n        // which is finally passed to the VRF cryptographic machinery.\\n        // So the seed doesn't actually do anything and is left over from an old API.\\n        uint256 vrfSeed = makeVRFInputSeed(_keyHash, 0, address(this), ds.rng_nonces[_keyHash]);\\n        // nonces[_keyHash] must stay in sync with\\n        // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\\n        // successful Link.transferAndCall (in VRFCoordinator.randomnessRequest).\\n        // This provides protection against the user repeating their input\\n        // seed, which would result in a predictable/duplicate output.\\n        ds.rng_nonces[_keyHash]++;\\n        return makeRequestId(_keyHash, vrfSeed);\\n    }\\n\\n    //  Generates a pseudo-random integer. This is cheaper than VRF but less secure.\\n    //  The rngNonce seed should be rotated by VRF before using this pRNG.\\n    //  @see: https://www.geeksforgeeks.org/random-number-generator-in-solidity-using-keccak256/\\n    //  @see: https://docs.chain.link/docs/chainlink-vrf-best-practices/\\n    //  @return Random integer in the range of [0-_modulus)\\n\\tfunction getCheapRNG(uint _modulus) internal returns (uint256) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ++ds.rngNonce;\\n        // return uint(keccak256(abi.encodePacked(block.timestamp, msg.sender, ds.rngNonce))) % _modulus;\\n        return uint256(keccak256(abi.encode(ds.rngNonce))) % _modulus;\\n    }\\n\\n    function expand(uint256 _modulus, uint256 _seed, uint256 _salt) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(_seed, _salt))) % _modulus;\\n    }\\n\\n    function getRuntimeRNG() internal returns (uint256) {\\n        return getRuntimeRNG(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    }\\n\\n    function getRuntimeRNG(uint _modulus) internal returns (uint256) {\\n        require(msg.sender != block.coinbase, \\\"RNG: Validators are not allowed to generate their own RNG\\\");\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        return uint256(keccak256(abi.encodePacked(block.coinbase, gasleft(), block.number, ++ds.rngNonce))) % _modulus;\\n    }\\n\\n    function enforceSenderIsSelf() internal {\\n        require(msg.sender == address(this), \\\"Caller must be the CU Diamond\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\\n\\n  function approve(address spender, uint256 value) external returns (bool success);\\n\\n  function balanceOf(address owner) external view returns (uint256 balance);\\n\\n  function decimals() external view returns (uint8 decimalPlaces);\\n\\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\\n\\n  function increaseApproval(address spender, uint256 subtractedValue) external;\\n\\n  function name() external view returns (string memory tokenName);\\n\\n  function symbol() external view returns (string memory tokenSymbol);\\n\\n  function totalSupply() external view returns (uint256 totalTokensIssued);\\n\\n  function transfer(address to, uint256 value) external returns (bool success);\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  ) external returns (bool success);\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IPermissionProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IPermissionProvider {\\n\\n    enum Permission {               // WARNING: This list must NEVER be re-ordered\\n        FARM_ALLOWED,                                                   //0\\n        JOUST_ALLOWED,              //  Not in use yet                  //1\\n        RACE_ALLOWED,               //  Not in use yet                  //2\\n        PVP_ALLOWED,                //  Not in use yet                  //3\\n        UNIGATCHI_ALLOWED,          //  Not in use yet                  //4\\n        RAINBOW_RUMBLE_ALLOWED,     //  Not in use yet                  //5\\n        UNICORN_PARTY_ALLOWED,      //  Not in use yet                  //6\\n\\n        UNICORN_BREEDING_ALLOWED,                                       //7\\n        UNICORN_HATCHING_ALLOWED,                                       //8\\n        UNICORN_EVOLVING_ALLOWED,                                       //9\\n        UNICORN_AIRLOCK_IN_ALLOWED,                                     //10\\n        UNICORN_AIRLOCK_OUT_ALLOWED,                                    //11\\n\\n        LAND_AIRLOCK_IN_ALLOWED,                                        //12\\n        LAND_AIRLOCK_OUT_ALLOWED,                                       //13\\n\\n        BANK_STASH_RBW_IN_ALLOWED,                                      //14\\n        BANK_STASH_RBW_OUT_ALLOWED,                                     //15\\n        BANK_STASH_UNIM_IN_ALLOWED,                                     //16\\n        BANK_STASH_UNIM_OUT_ALLOWED,                                    //17\\n        BANK_STASH_LOOTBOX_IN_ALLOWED,                                  //18                                \\n        BANK_STASH_KEYSTONE_OUT_ALLOWED,                                //19\\n\\n        FARM_RMP_BUY,                                                   //20\\n        FARM_RMP_SELL                                                   //21\\n    }\\n    \\n    event PermissionsChanged(\\n        address indexed owner,\\n        address indexed delegate,\\n        uint256 oldPermissions,\\n        uint256 newPermissions\\n    );\\n\\n    \\n    \\n}\"\r\n    },\r\n    \"LibPermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {IDelegatePermissions} from \\\"IDelegatePermissions.sol\\\";\\nimport {IPermissionProvider} from \\\"IPermissionProvider.sol\\\";\\nimport {LibERC721} from \\\"LibERC721.sol\\\";\\n\\nlibrary LibPermissions {\\n    struct LibDelegationStorage {\\n        address permissionProvider;\\n    }\\n\\n    bytes32 private constant DELEGATION_STORAGE_POSITION = keccak256(\\\"diamond.libDelegation.storage\\\");\\n    \\n\\n    function delegationStorage() internal pure returns (LibDelegationStorage storage lhs) {        \\n        bytes32 position = DELEGATION_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            lhs.slot := position\\n        }\\n    }\\n\\n    function setPermissionProvider(address permissionProvider) internal {\\n        delegationStorage().permissionProvider = permissionProvider;\\n    }\\n\\n    function getPermissionProvider() internal view returns(IDelegatePermissions){\\n        return IDelegatePermissions(delegationStorage().permissionProvider);\\n    }\\n    function allTrue(bool[] memory booleans) private pure returns(bool) {\\n        uint256 i = 0;\\n        while(i < booleans.length && booleans[i] == true){\\n            i++;\\n        }\\n        return (i == booleans.length);\\n    }\\n    // pros: we reuse this function in every previous enforceCallerOwnsNFT.\\n    // cons: it's not generic\\n    function enforceCallerOwnsNFTOrHasPermissions(uint256 tokenId, IPermissionProvider.Permission[] memory permissions) internal view {\\n        IDelegatePermissions pp = getPermissionProvider();\\n        address ownerOfNFT = LibERC721.ownerOf(tokenId);\\n\\n        // Warning: this can be address(0) if the msg.sender is the delegator\\n        address delegator = pp.getDelegator(msg.sender);\\n\\n        //Sender owns the NFT or sender's owner owns the NFT and sender has specific permission for this action.\\n        require(ownerOfNFT == msg.sender || (ownerOfNFT == delegator && pp.checkDelegatePermissions(delegator, permissions)), \\\"LibPermissions: Must own the NFT or have permission from owner\\\");\\n    }\\n\\n    function enforceCallerOwnsNFTOrHasPermission(uint256 tokenId, IPermissionProvider.Permission permission) internal view {\\n        IDelegatePermissions pp = getPermissionProvider();\\n        address ownerOfNFT = LibERC721.ownerOf(tokenId);\\n\\n        // Warning: this can be address(0) if the msg.sender is the delegator\\n        address delegator = pp.getDelegator(msg.sender);\\n\\n        //Sender owns the NFT or sender's owner owns the NFT and sender has specific permission for this action.\\n        require(ownerOfNFT == msg.sender || (ownerOfNFT == delegator && pp.checkDelegatePermission(delegator, permission)), \\\"LibPermissions: Must own the NFT or have permission from owner\\\");\\n    }\\n}\"\r\n    },\r\n    \"IDelegatePermissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\nimport {IPermissionProvider} from \\\"IPermissionProvider.sol\\\";\\n\\ninterface IDelegatePermissions {\\n    //  Resets all permissions granted by the caller (delegator) to 0/false.\\n    //  @emits PermissionsChanged\\n    function resetDelegatePermissions() external;\\n\\n    //  Returns the delegate address of a wallet, or 0 if unset.\\n    //  @param address delegator - The delegator/scholar address to query\\n    //  @return address delegate - The address with permissions on this account\\n    function getDelegate(address delegator) external view returns (address delegate);\\n\\n\\n    //  Returns the delegator address for a delegate, or 0 if unset.\\n    //  @param address delegate - The address with delegated permissions\\n    //  @return address delegator - The address granting permissions to the delegate\\n    function getDelegator(address delegate) external view returns (address delegator);\\n\\n\\n    //  Returns the location of a Permission in the raw permissions binary map.\\n    //  @param Permission p - A permission to lookup\\n    //  @return uint256 index - The location of the permission-bit in the rawPermissions\\n    function getIndexForDelegatePermission(IPermissionProvider.Permission p) external pure returns (uint256 index);\\n\\n\\n    //  Returns the raw permission bit array granted by an delegator to a delegate.\\n    //  If the delegator and delegate arguments don't match the getDelegator/getDelegate\\n    //  mapping, an error will be thrown.\\n    //  delegate-less wallet to check the current permission settings.\\n    //  @param address delegator - The address granteing permission\\n    //  @return uint256 rawPermissions - The raw bit array of granted permissions\\n    function getRawDelegatePermissions(address delegator) external view returns (uint256 rawPermissions);\\n\\n\\n    //  Sets the raw permission bit array granted by the caller.\\n    //  @return uint256 rawPermissions - The raw bit array of granted permissions\\n    //  @emits PermissionsChanged\\n    function setDelegatePermissionsRaw(uint256 rawPermissions) external;\\n\\n\\n    //  Returns true if the delegator is granting the permission to the delegate.\\n    //  @param address delegator - The address granteing permission\\n    //  @param Permission p - The permission to check\\n    //  @return bool - True if the permission is allowed, otherwise false\\n    function checkDelegatePermission(address delegator, IPermissionProvider.Permission p) external view returns (bool);\\n\\n\\n    //  Checks if the delegator is granting permission to the delegate for a list \\n    //  of permissions.\\n    //  @param address delegator - The address granteing permission\\n    //  @param Permission[] p - List of permissions to check\\n    //  @return bool - Returns if the delegate associated to the delegator has all the permissions inside the Permission[] array\\n    function checkDelegatePermissions(address delegator, IPermissionProvider.Permission[] calldata p) external view returns (bool);\\n\\n\\n    //  Checks if the delegator is granting the permission to the delegate. If the \\n    //  permission is not allowed, the transaction will be reverted with an error.\\n    //  @param address delegator - The address granteing permission\\n    //  @param Permission p - The permission to check\\n    function requireDelegatePermission(address delegator, IPermissionProvider.Permission p) external view;\\n\\n\\n    //  Checks if the delegator is granting multiple permissions to the delegate.\\n    //  If any of the permissions are not allowed, the transaction will be reverted\\n    //  with an error.\\n    //  @param address delegator - The address granteing permission\\n    //  @param Permission[] p - List of permissions to check\\n    function requireDelegatePermissions(address delegator, IPermissionProvider.Permission[] calldata p) external view;\\n\\n\\n    //  Sets an individual permission bit flag to true or false for the caller,\\n    //  which grants that permission to the associated delegate address. If no \\n    //  delegate is assigned (ie. address 0) then the permission is still set and\\n    //  will become active when a delegate address is set.\\n    //  @param Permission permission - The permission to set\\n    //  @param bool state - True to allow permission, or false to revoke\\n    //  @emits PermissionsChanged\\n    function setDelegatePermission(IPermissionProvider.Permission permission, bool state) external;\\n\\n\\n    //  Sets multiple permissions to true or false for the caller, which grants\\n    //  those permissions t othe associated delegate address. If no delegate is \\n    //  assigned (ie. address 0) then the permissions will still be set and will\\n    //  become active when a delegate address is set.\\n    //  @param Permission[] permissions - A list of permissions\\n    //  @param bool[] states - True or false for each Permission\\n    //  @emits PermissionsChanged\\n    function setDelegatePermissions(IPermissionProvider.Permission[] calldata permissions, bool[] calldata states) external;\\n}\"\r\n    },\r\n    \"LibStats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibUnicornDNA} from \\\"LibUnicornDNA.sol\\\";\\n\\nlibrary LibStats {\\n    function getPowerScore(uint256 attack, uint256 accuracy) internal view returns (uint256) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 powerAttackScalar = ds.power_attack_scalar;\\n        uint256 powerAccuracyScalar = ds.power_accuracy_scalar;\\n        uint256 powerScalar = ds.power_scalar;\\n        uint256 finalAttack = attack * powerAttackScalar;\\n        uint256 finalAccuracy = accuracy * powerAccuracyScalar;\\n        uint256 power = (finalAttack + finalAccuracy) * powerScalar;\\n        return power;\\n    }\\n\\n    function getSpeedScore(uint256 movementSpeed, uint256 attackSpeed) internal view returns (uint256) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 movementSpeedScalar = ds.speed_movespeed_scalar;\\n        uint256 attackSpeedScalar = ds.speed_attackspeed_scalar;\\n        uint256 speedScalar = ds.speed_scalar;\\n        uint256 finalMovementSpeed = movementSpeed * movementSpeedScalar;\\n        uint256 finalAttackSpeed = attackSpeed * attackSpeedScalar;\\n        uint256 speed = (finalMovementSpeed + finalAttackSpeed) * speedScalar;\\n        return speed;\\n    }\\n\\n    function getEnduranceScore(uint256 vitality, uint256 defense) internal view returns (uint256) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 vitalityScalar = ds.endurance_vitality_scalar;\\n        uint256 defenseScalar = ds.endurance_defense_scalar;\\n        uint256 enduranceScalar = ds.endurance_scalar;\\n        uint256 finalVitality = vitality * vitalityScalar;\\n        uint256 finalDefense = defense * defenseScalar;\\n        uint256 endurance = (finalVitality + finalDefense) * enduranceScalar;\\n        return endurance;\\n    }\\n\\n    function getIntelligenceScore(uint256 magic, uint256 resistance) internal view returns (uint256) {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        uint256 magicScalar = ds.intelligence_magic_scalar;\\n        uint256 resistanceScalar = ds.intelligence_resistance_scalar;\\n        uint256 intelligenceScalar = ds.intelligence_scalar;\\n        uint256 finalMagic = magic * magicScalar;\\n        uint256 finalResistance = resistance * resistanceScalar;\\n        uint256 intelligence = (finalMagic + finalResistance) * intelligenceScalar;\\n        return intelligence;\\n    }\\n}\\n\"\r\n    },\r\n    \"ITwTUnicornInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface ITwTUnicornInfo {\\n    \\n    struct TwTUnicornInfo {\\n        bool belongsToUser;\\n        bool isTransferrable;\\n        bool isGenesis;\\n        bool isAdult;\\n        uint8 amountOfMythicParts;\\n        uint8 class;\\n        uint256[] statsValues;\\n    }\\n\\n    function twtGetUnicornInfoMultiple(uint256[3] memory tokenIds, uint256[] memory relevantStats, address user) external view returns (TwTUnicornInfo[] memory);\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"StatsFacet.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getAccuracy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getAttack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getAttackSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getDefense\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getEnduranceScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getIntelligenceScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getMagic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getMovementSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getPowerScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getResistance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getSpeedScore\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"attack\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accuracy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"movementSpeed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"attackSpeed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"defense\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"vitality\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"resistance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"magic\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getUnicornBodyParts\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bodyPartId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"facePartId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hornPartId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hoovesPartId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"manePartId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tailPartId\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"mythicCount\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getUnicornBodyPartsLocal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"bodyPartLocalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"facePartLocalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hornPartLocalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hoovesPartLocalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"manePartLocalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tailPartLocalId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getUnicornMetadata\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"origin\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"gameLocked\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"limitedEdition\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lifecycleStage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"breedingPoints\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unicornClass\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"hatchBirthday\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"getVitality\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[3]\",\"name\":\"tokenIds\",\"type\":\"uint256[3]\"},{\"internalType\":\"uint256[]\",\"name\":\"relevantStats\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"twtGetUnicornInfoMultiple\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"belongsToUser\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isTransferrable\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isGenesis\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isAdult\",\"type\":\"bool\"},{\"internalType\":\"uint8\",\"name\":\"amountOfMythicParts\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"class\",\"type\":\"uint8\"},{\"internalType\":\"uint256[]\",\"name\":\"statsValues\",\"type\":\"uint256[]\"}],\"internalType\":\"struct ITwTUnicornInfo.TwTUnicornInfo[]\",\"name\":\"unicornInfo\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "StatsFacet", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": ""}