{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/Core.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\n/// Common mathematical functions used in both SD59x18 and UD60x18. Note that these global functions do not\\n/// always operate with SD59x18 and UD60x18 numbers.\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                CUSTOM ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Emitted when the ending result in the fixed-point version of `mulDiv` would overflow uint256.\\nerror PRBMath__MulDiv18Overflow(uint256 x, uint256 y);\\n\\n/// @notice Emitted when the ending result in `mulDiv` would overflow uint256.\\nerror PRBMath__MulDivOverflow(uint256 x, uint256 y, uint256 denominator);\\n\\n/// @notice Emitted when attempting to run `mulDiv` with one of the inputs `type(int256).min`.\\nerror PRBMath__MulDivSignedInputTooSmall();\\n\\n/// @notice Emitted when the ending result in the signed version of `mulDiv` would overflow int256.\\nerror PRBMath__MulDivSignedOverflow(int256 x, int256 y);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CONSTANTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @dev How many trailing decimals can be represented.\\nuint256 constant UNIT = 1e18;\\n\\n/// @dev Largest power of two that is a divisor of `UNIT`.\\nuint256 constant UNIT_LPOTD = 262144;\\n\\n/// @dev The `UNIT` number inverted mod 2^256.\\nuint256 constant UNIT_INVERSE = 78156646155174841979727994598816262306175212592076161876661_508869554232690281;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Finds the zero-based index of the first one in the binary representation of x.\\n/// @dev See the note on msb in the \\\"Find First Set\\\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\\n///\\n/// Each of the steps in this implementation is equivalent to this high-level code:\\n///\\n/// ```solidity\\n/// if (x >= 2 ** 128) {\\n///     x >>= 128;\\n///     result += 128;\\n/// }\\n/// ```\\n///\\n/// Where 128 is swapped with each respective power of two factor. See the full high-level implementation here:\\n/// https://gist.github.com/paulrberg/f932f8693f2733e30c4d479e8e980948\\n///\\n/// A list of the Yul instructions used below:\\n/// - \\\"gt\\\" is \\\"greater than\\\"\\n/// - \\\"or\\\" is the OR bitwise operator\\n/// - \\\"shl\\\" is \\\"shift left\\\"\\n/// - \\\"shr\\\" is \\\"shift right\\\"\\n///\\n/// @param x The uint256 number for which to find the index of the most significant bit.\\n/// @return result The index of the most significant bit as an uint256.\\nfunction msb(uint256 x) pure returns (uint256 result) {\\n    // 2^128\\n    assembly {\\n        let factor := shl(7, gt(x, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^64\\n    assembly {\\n        let factor := shl(6, gt(x, 0xFFFFFFFFFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^32\\n    assembly {\\n        let factor := shl(5, gt(x, 0xFFFFFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^16\\n    assembly {\\n        let factor := shl(4, gt(x, 0xFFFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^8\\n    assembly {\\n        let factor := shl(3, gt(x, 0xFF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^4\\n    assembly {\\n        let factor := shl(2, gt(x, 0xF))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^2\\n    assembly {\\n        let factor := shl(1, gt(x, 0x3))\\n        x := shr(factor, x)\\n        result := or(result, factor)\\n    }\\n    // 2^1\\n    // No need to shift x any more.\\n    assembly {\\n        let factor := gt(x, 0x1)\\n        result := or(result, factor)\\n    }\\n}\\n\\n/// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n///\\n/// @dev Credits to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\\n///\\n/// Requirements:\\n/// - The denominator cannot be zero.\\n/// - The result must fit within uint256.\\n///\\n/// Caveats:\\n/// - This function does not work with fixed-point numbers.\\n///\\n/// @param x The multiplicand as an uint256.\\n/// @param y The multiplier as an uint256.\\n/// @param denominator The divisor as an uint256.\\n/// @return result The result as an uint256.\\nfunction mulDiv(uint256 x, uint256 y, uint256 denominator) pure returns (uint256 result) {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / denominator;\\n        }\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    if (prod1 >= denominator) {\\n        revert PRBMath__MulDivOverflow(x, y, denominator);\\n    }\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly {\\n        // Compute remainder using the mulmod Yul instruction.\\n        remainder := mulmod(x, y, denominator)\\n\\n        // Subtract 256 bit number from 512 bit number.\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n    }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n    unchecked {\\n        // Does not overflow because the denominator cannot be zero at this stage in the function.\\n        uint256 lpotdod = denominator & (~denominator + 1);\\n        assembly {\\n            // Divide denominator by lpotdod.\\n            denominator := div(denominator, lpotdod)\\n\\n            // Divide [prod1 prod0] by lpotdod.\\n            prod0 := div(prod0, lpotdod)\\n\\n            // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\\n            lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\\n        }\\n\\n        // Shift in bits from prod1 into prod0.\\n        prod0 |= prod1 * lpotdod;\\n\\n        // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n        // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n        // four bits. That is, denominator * inv = 1 mod 2^4.\\n        uint256 inverse = (3 * denominator) ^ 2;\\n\\n        // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n        // in modular arithmetic, doubling the correct bits in each step.\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n        inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n        // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n        // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n        // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n        // is no longer required.\\n        result = prod0 * inverse;\\n    }\\n}\\n\\n/// @notice Calculates floor(x*y\u00f71e18) with full precision.\\n///\\n/// @dev Variant of `mulDiv` with constant folding, i.e. in which the denominator is always 1e18. Before returning the\\n/// final result, we add 1 if `(x * y) % UNIT >= HALF_UNIT`. Without this adjustment, 6.6e-19 would be truncated to 0\\n/// instead of being rounded to 1e-18. See \\\"Listing 6\\\" and text above it at https://accu.org/index.php/journals/1717.\\n///\\n/// Requirements:\\n/// - The result must fit within uint256.\\n///\\n/// Caveats:\\n/// - The body is purposely left uncommented; to understand how this works, see the NatSpec comments in `mulDiv`.\\n/// - It is assumed that the result can never be `type(uint256).max` when x and y solve the following two equations:\\n///     1. x * y = type(uint256).max * UNIT\\n///     2. (x * y) % UNIT >= UNIT / 2\\n///\\n/// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\\n/// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\nfunction mulDiv18(uint256 x, uint256 y) pure returns (uint256 result) {\\n    uint256 prod0;\\n    uint256 prod1;\\n    assembly {\\n        let mm := mulmod(x, y, not(0))\\n        prod0 := mul(x, y)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    if (prod1 >= UNIT) {\\n        revert PRBMath__MulDiv18Overflow(x, y);\\n    }\\n\\n    uint256 remainder;\\n    assembly {\\n        remainder := mulmod(x, y, UNIT)\\n    }\\n\\n    if (prod1 == 0) {\\n        unchecked {\\n            return prod0 / UNIT;\\n        }\\n    }\\n\\n    assembly {\\n        result := mul(\\n            or(\\n                div(sub(prod0, remainder), UNIT_LPOTD),\\n                mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, UNIT_LPOTD), UNIT_LPOTD), 1))\\n            ),\\n            UNIT_INVERSE\\n        )\\n    }\\n}\\n\\n/// @notice Calculates floor(x*y\u00f7denominator) with full precision.\\n///\\n/// @dev An extension of `mulDiv` for signed numbers. Works by computing the signs and the absolute values separately.\\n///\\n/// Requirements:\\n/// - None of the inputs can be `type(int256).min`.\\n/// - The result must fit within int256.\\n///\\n/// @param x The multiplicand as an int256.\\n/// @param y The multiplier as an int256.\\n/// @param denominator The divisor as an int256.\\n/// @return result The result as an int256.\\nfunction mulDivSigned(int256 x, int256 y, int256 denominator) pure returns (int256 result) {\\n    if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\\n        revert PRBMath__MulDivSignedInputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x, y and the denominator.\\n    uint256 absX;\\n    uint256 absY;\\n    uint256 absD;\\n    unchecked {\\n        absX = x < 0 ? uint256(-x) : uint256(x);\\n        absY = y < 0 ? uint256(-y) : uint256(y);\\n        absD = denominator < 0 ? uint256(-denominator) : uint256(denominator);\\n    }\\n\\n    // Compute the absolute value of (x*y)\u00f7denominator. The result must fit within int256.\\n    uint256 rAbs = mulDiv(absX, absY, absD);\\n    if (rAbs > uint256(type(int256).max)) {\\n        revert PRBMath__MulDivSignedOverflow(x, y);\\n    }\\n\\n    // Get the signs of x, y and the denominator.\\n    uint256 sx;\\n    uint256 sy;\\n    uint256 sd;\\n    assembly {\\n        // This works thanks to two's complement.\\n        // \\\"sgt\\\" stands for \\\"signed greater than\\\" and \\\"sub(0,1)\\\" is max uint256.\\n        sx := sgt(x, sub(0, 1))\\n        sy := sgt(y, sub(0, 1))\\n        sd := sgt(denominator, sub(0, 1))\\n    }\\n\\n    // XOR over sx, sy and sd. What this does is to check whether there are 1 or 3 negative signs in the inputs.\\n    // If there are, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n/// @dev Has to use 192.64-bit fixed-point numbers.\\n/// See https://ethereum.stackexchange.com/a/96594/24693.\\n/// @param x The exponent as an unsigned 192.64-bit fixed-point number.\\n/// @return result The result as an unsigned 60.18-decimal fixed-point number.\\nfunction prbExp2(uint256 x) pure returns (uint256 result) {\\n    unchecked {\\n        // Start from 0.5 in the 192.64-bit fixed-point format.\\n        result = 0x800000000000000000000000000000000000000000000000;\\n\\n        // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\\n        // because the initial result is 2^191 and all magic factors are less than 2^65.\\n        if (x & 0xFF00000000000000 > 0) {\\n            if (x & 0x8000000000000000 > 0) {\\n                result = (result * 0x16A09E667F3BCC909) >> 64;\\n            }\\n            if (x & 0x4000000000000000 > 0) {\\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\\n            }\\n            if (x & 0x2000000000000000 > 0) {\\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\\n            }\\n            if (x & 0x1000000000000000 > 0) {\\n                result = (result * 0x10B5586CF9890F62A) >> 64;\\n            }\\n            if (x & 0x800000000000000 > 0) {\\n                result = (result * 0x1059B0D31585743AE) >> 64;\\n            }\\n            if (x & 0x400000000000000 > 0) {\\n                result = (result * 0x102C9A3E778060EE7) >> 64;\\n            }\\n            if (x & 0x200000000000000 > 0) {\\n                result = (result * 0x10163DA9FB33356D8) >> 64;\\n            }\\n            if (x & 0x100000000000000 > 0) {\\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF000000000000 > 0) {\\n            if (x & 0x80000000000000 > 0) {\\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\\n            }\\n            if (x & 0x40000000000000 > 0) {\\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\\n            }\\n            if (x & 0x20000000000000 > 0) {\\n                result = (result * 0x100162F3904051FA1) >> 64;\\n            }\\n            if (x & 0x10000000000000 > 0) {\\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\\n            }\\n            if (x & 0x8000000000000 > 0) {\\n                result = (result * 0x100058BA01FB9F96D) >> 64;\\n            }\\n            if (x & 0x4000000000000 > 0) {\\n                result = (result * 0x10002C5CC37DA9492) >> 64;\\n            }\\n            if (x & 0x2000000000000 > 0) {\\n                result = (result * 0x1000162E525EE0547) >> 64;\\n            }\\n            if (x & 0x1000000000000 > 0) {\\n                result = (result * 0x10000B17255775C04) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000000000 > 0) {\\n            if (x & 0x800000000000 > 0) {\\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\\n            }\\n            if (x & 0x400000000000 > 0) {\\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\\n            }\\n            if (x & 0x200000000000 > 0) {\\n                result = (result * 0x10000162E43F4F831) >> 64;\\n            }\\n            if (x & 0x100000000000 > 0) {\\n                result = (result * 0x100000B1721BCFC9A) >> 64;\\n            }\\n            if (x & 0x80000000000 > 0) {\\n                result = (result * 0x10000058B90CF1E6E) >> 64;\\n            }\\n            if (x & 0x40000000000 > 0) {\\n                result = (result * 0x1000002C5C863B73F) >> 64;\\n            }\\n            if (x & 0x20000000000 > 0) {\\n                result = (result * 0x100000162E430E5A2) >> 64;\\n            }\\n            if (x & 0x10000000000 > 0) {\\n                result = (result * 0x1000000B172183551) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00000000 > 0) {\\n            if (x & 0x8000000000 > 0) {\\n                result = (result * 0x100000058B90C0B49) >> 64;\\n            }\\n            if (x & 0x4000000000 > 0) {\\n                result = (result * 0x10000002C5C8601CC) >> 64;\\n            }\\n            if (x & 0x2000000000 > 0) {\\n                result = (result * 0x1000000162E42FFF0) >> 64;\\n            }\\n            if (x & 0x1000000000 > 0) {\\n                result = (result * 0x10000000B17217FBB) >> 64;\\n            }\\n            if (x & 0x800000000 > 0) {\\n                result = (result * 0x1000000058B90BFCE) >> 64;\\n            }\\n            if (x & 0x400000000 > 0) {\\n                result = (result * 0x100000002C5C85FE3) >> 64;\\n            }\\n            if (x & 0x200000000 > 0) {\\n                result = (result * 0x10000000162E42FF1) >> 64;\\n            }\\n            if (x & 0x100000000 > 0) {\\n                result = (result * 0x100000000B17217F8) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00000000 > 0) {\\n            if (x & 0x80000000 > 0) {\\n                result = (result * 0x10000000058B90BFC) >> 64;\\n            }\\n            if (x & 0x40000000 > 0) {\\n                result = (result * 0x1000000002C5C85FE) >> 64;\\n            }\\n            if (x & 0x20000000 > 0) {\\n                result = (result * 0x100000000162E42FF) >> 64;\\n            }\\n            if (x & 0x10000000 > 0) {\\n                result = (result * 0x1000000000B17217F) >> 64;\\n            }\\n            if (x & 0x8000000 > 0) {\\n                result = (result * 0x100000000058B90C0) >> 64;\\n            }\\n            if (x & 0x4000000 > 0) {\\n                result = (result * 0x10000000002C5C860) >> 64;\\n            }\\n            if (x & 0x2000000 > 0) {\\n                result = (result * 0x1000000000162E430) >> 64;\\n            }\\n            if (x & 0x1000000 > 0) {\\n                result = (result * 0x10000000000B17218) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF0000 > 0) {\\n            if (x & 0x800000 > 0) {\\n                result = (result * 0x1000000000058B90C) >> 64;\\n            }\\n            if (x & 0x400000 > 0) {\\n                result = (result * 0x100000000002C5C86) >> 64;\\n            }\\n            if (x & 0x200000 > 0) {\\n                result = (result * 0x10000000000162E43) >> 64;\\n            }\\n            if (x & 0x100000 > 0) {\\n                result = (result * 0x100000000000B1721) >> 64;\\n            }\\n            if (x & 0x80000 > 0) {\\n                result = (result * 0x10000000000058B91) >> 64;\\n            }\\n            if (x & 0x40000 > 0) {\\n                result = (result * 0x1000000000002C5C8) >> 64;\\n            }\\n            if (x & 0x20000 > 0) {\\n                result = (result * 0x100000000000162E4) >> 64;\\n            }\\n            if (x & 0x10000 > 0) {\\n                result = (result * 0x1000000000000B172) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF00 > 0) {\\n            if (x & 0x8000 > 0) {\\n                result = (result * 0x100000000000058B9) >> 64;\\n            }\\n            if (x & 0x4000 > 0) {\\n                result = (result * 0x10000000000002C5D) >> 64;\\n            }\\n            if (x & 0x2000 > 0) {\\n                result = (result * 0x1000000000000162E) >> 64;\\n            }\\n            if (x & 0x1000 > 0) {\\n                result = (result * 0x10000000000000B17) >> 64;\\n            }\\n            if (x & 0x800 > 0) {\\n                result = (result * 0x1000000000000058C) >> 64;\\n            }\\n            if (x & 0x400 > 0) {\\n                result = (result * 0x100000000000002C6) >> 64;\\n            }\\n            if (x & 0x200 > 0) {\\n                result = (result * 0x10000000000000163) >> 64;\\n            }\\n            if (x & 0x100 > 0) {\\n                result = (result * 0x100000000000000B1) >> 64;\\n            }\\n        }\\n\\n        if (x & 0xFF > 0) {\\n            if (x & 0x80 > 0) {\\n                result = (result * 0x10000000000000059) >> 64;\\n            }\\n            if (x & 0x40 > 0) {\\n                result = (result * 0x1000000000000002C) >> 64;\\n            }\\n            if (x & 0x20 > 0) {\\n                result = (result * 0x10000000000000016) >> 64;\\n            }\\n            if (x & 0x10 > 0) {\\n                result = (result * 0x1000000000000000B) >> 64;\\n            }\\n            if (x & 0x8 > 0) {\\n                result = (result * 0x10000000000000006) >> 64;\\n            }\\n            if (x & 0x4 > 0) {\\n                result = (result * 0x10000000000000003) >> 64;\\n            }\\n            if (x & 0x2 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n            if (x & 0x1 > 0) {\\n                result = (result * 0x10000000000000001) >> 64;\\n            }\\n        }\\n\\n        // We're doing two things at the same time:\\n        //\\n        //   1. Multiply the result by 2^n + 1, where \\\"2^n\\\" is the integer part and the one is added to account for\\n        //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\\n        //      rather than 192.\\n        //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\\n        //\\n        // This works because 2^(191-ip) = 2^ip / 2^191, where \\\"ip\\\" is the integer part \\\"2^n\\\".\\n        result *= UNIT;\\n        result >>= (191 - (x >> 64));\\n    }\\n}\\n\\n/// @notice Calculates the square root of x, rounding down if x is not a perfect square.\\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n/// Credits to OpenZeppelin for the explanations in code comments below.\\n///\\n/// Caveats:\\n/// - This function does not work with fixed-point numbers.\\n///\\n/// @param x The uint256 number for which to calculate the square root.\\n/// @return result The result as an uint256.\\nfunction prbSqrt(uint256 x) pure returns (uint256 result) {\\n    if (x == 0) {\\n        return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of x.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of x is a power of 2 such that we have:\\n    //\\n    // $$\\n    // msb(x) <= x <= 2*msb(x)$\\n    // $$\\n    //\\n    // We write $msb(x)$ as $2^k$ and we get:\\n    //\\n    // $$\\n    // k = log_2(x)\\n    // $$\\n    //\\n    // Thus we can write the initial inequality as:\\n    //\\n    // $$\\n    // 2^{log_2(x)} <= x <= 2*2^{log_2(x)+1} \\\\\\\\\\n    // sqrt(2^k) <= sqrt(x) < sqrt(2^{k+1}) \\\\\\\\\\n    // 2^{k/2} <= sqrt(x) < 2^{(k+1)/2} <= 2^{(k/2)+1}\\n    // $$\\n    //\\n    // Consequently, $2^{log_2(x) /2}` is a good first approximation of sqrt(x) with at least one correct bit.\\n    uint256 xAux = uint256(x);\\n    result = 1;\\n    if (xAux >= 2 ** 128) {\\n        xAux >>= 128;\\n        result <<= 64;\\n    }\\n    if (xAux >= 2 ** 64) {\\n        xAux >>= 64;\\n        result <<= 32;\\n    }\\n    if (xAux >= 2 ** 32) {\\n        xAux >>= 32;\\n        result <<= 16;\\n    }\\n    if (xAux >= 2 ** 16) {\\n        xAux >>= 16;\\n        result <<= 8;\\n    }\\n    if (xAux >= 2 ** 8) {\\n        xAux >>= 8;\\n        result <<= 4;\\n    }\\n    if (xAux >= 2 ** 4) {\\n        xAux >>= 4;\\n        result <<= 2;\\n    }\\n    if (xAux >= 2 ** 2) {\\n        result <<= 1;\\n    }\\n\\n    // At this point, `result` is an estimation with at least one bit of precision. We know the true value has at\\n    // most 128 bits, since  it is the square root of a uint256. Newton's method converges quadratically (precision\\n    // doubles at every iteration). We thus need at most 7 iteration to turn our partial result with one bit of\\n    // precision into the expected uint128 result.\\n    unchecked {\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n        result = (result + x / result) >> 1;\\n\\n        // Round down the result in case x is not a perfect square.\\n        uint256 roundedDownResult = x / result;\\n        if (result >= roundedDownResult) {\\n            result = roundedDownResult;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@prb/math/src/SD59x18.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.13;\\n\\nimport { msb, mulDiv, mulDiv18, prbExp2, prbSqrt } from \\\"./Core.sol\\\";\\n\\n/// @notice The signed 59.18-decimal fixed-point number representation, which can have up to 59 digits and up to 18 decimals.\\n/// The values of this are bound by the minimum and the maximum values permitted by the underlying Solidity type int256.\\ntype SD59x18 is int256;\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                CUSTOM ERRORS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Emitted when taking the absolute value of `MIN_SD59x18`.\\nerror PRBMathSD59x18__AbsMinSD59x18();\\n\\n/// @notice Emitted when ceiling a number overflows SD59x18.\\nerror PRBMathSD59x18__CeilOverflow(SD59x18 x);\\n\\n/// @notice Emitted when dividing two numbers and one of them is `MIN_SD59x18`.\\nerror PRBMathSD59x18__DivInputTooSmall();\\n\\n/// @notice Emitted when dividing two numbers and one of the intermediary unsigned results overflows SD59x18.\\nerror PRBMathSD59x18__DivOverflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Emitted when taking the natural exponent of a base greater than 133.084258667509499441.\\nerror PRBMathSD59x18__ExpInputTooBig(SD59x18 x);\\n\\n/// @notice Emitted when taking the binary exponent of a base greater than 192.\\nerror PRBMathSD59x18__Exp2InputTooBig(SD59x18 x);\\n\\n/// @notice Emitted when flooring a number underflows SD59x18.\\nerror PRBMathSD59x18__FloorUnderflow(SD59x18 x);\\n\\n/// @notice Emitted when taking the geometric mean of two numbers and their product is negative.\\nerror PRBMathSD59x18__GmNegativeProduct(SD59x18 x, SD59x18 y);\\n\\n/// @notice Emitted when taking the geometric mean of two numbers and multiplying them overflows SD59x18.\\nerror PRBMathSD59x18__GmOverflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Emitted when taking the logarithm of a number less than or equal to zero.\\nerror PRBMathSD59x18__LogInputTooSmall(SD59x18 x);\\n\\n/// @notice Emitted when multiplying two numbers and one of the inputs is `MIN_SD59x18`.\\nerror PRBMathSD59x18__MulInputTooSmall();\\n\\n/// @notice Emitted when multiplying two numbers and the intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__MulOverflow(SD59x18 x, SD59x18 y);\\n\\n/// @notice Emitted when raising a number to a power and hte intermediary absolute result overflows SD59x18.\\nerror PRBMathSD59x18__PowuOverflow(SD59x18 x, uint256 y);\\n\\n/// @notice Emitted when taking the square root of a negative number.\\nerror PRBMathSD59x18__SqrtNegativeInput(SD59x18 x);\\n\\n/// @notice Emitted when the calculating the square root overflows SD59x18.\\nerror PRBMathSD59x18__SqrtOverflow(SD59x18 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\\nerror PRBMathSD59x18__ToSD59x18Overflow(int256 x);\\n\\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\\nerror PRBMathSD59x18__ToSD59x18Underflow(int256 x);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                                    CONSTANTS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// NOTICE: the \\\"u\\\" prefix stands for \\\"unwrapped\\\".\\n\\n/// @dev Euler's number as an SD59x18 number.\\nSD59x18 constant E = SD59x18.wrap(2_718281828459045235);\\n\\n/// @dev Half the UNIT number.\\nint256 constant uHALF_UNIT = 0.5e18;\\nSD59x18 constant HALF_UNIT = SD59x18.wrap(uHALF_UNIT);\\n\\n/// @dev log2(10) as an SD59x18 number.\\nint256 constant uLOG2_10 = 3_321928094887362347;\\nSD59x18 constant LOG2_10 = SD59x18.wrap(uLOG2_10);\\n\\n/// @dev log2(e) as an SD59x18 number.\\nint256 constant uLOG2_E = 1_442695040888963407;\\nSD59x18 constant LOG2_E = SD59x18.wrap(uLOG2_E);\\n\\n/// @dev The maximum value an SD59x18 number can have.\\nint256 constant uMAX_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_792003956564819967;\\nSD59x18 constant MAX_SD59x18 = SD59x18.wrap(uMAX_SD59x18);\\n\\n/// @dev The maximum whole value an SD59x18 number can have.\\nint256 constant uMAX_WHOLE_SD59x18 = 57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\nSD59x18 constant MAX_WHOLE_SD59x18 = SD59x18.wrap(uMAX_WHOLE_SD59x18);\\n\\n/// @dev The minimum value an SD59x18 number can have.\\nint256 constant uMIN_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_792003956564819968;\\nSD59x18 constant MIN_SD59x18 = SD59x18.wrap(uMIN_SD59x18);\\n\\n/// @dev The minimum whole value an SD59x18 number can have.\\nint256 constant uMIN_WHOLE_SD59x18 = -57896044618658097711785492504343953926634992332820282019728_000000000000000000;\\nSD59x18 constant MIN_WHOLE_SD59x18 = SD59x18.wrap(uMIN_WHOLE_SD59x18);\\n\\n/// @dev PI as an SD59x18 number.\\nSD59x18 constant PI = SD59x18.wrap(3_141592653589793238);\\n\\n/// @dev The unit amount which implies how many trailing decimals can be represented.\\nSD59x18 constant UNIT = SD59x18.wrap(1e18);\\nint256 constant uUNIT = 1e18;\\n\\n/// @dev Zero as an SD59x18 number.\\nSD59x18 constant ZERO = SD59x18.wrap(0);\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            MATHEMATICAL FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing { abs, avg, ceil, div, exp, exp2, floor, frac, gm, inv, log10, log2, ln, mul, pow, powu, sqrt } for SD59x18 global;\\n\\n/// @notice Calculate the absolute value of x.\\n///\\n/// @dev Requirements:\\n/// - x must be greater than `MIN_SD59x18`.\\n///\\n/// @param x The SD59x18 number for which to calculate the absolute value.\\n/// @param result The absolute value of x as an SD59x18 number.\\nfunction abs(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt == uMIN_SD59x18) {\\n        revert PRBMathSD59x18__AbsMinSD59x18();\\n    }\\n    result = xInt < 0 ? wrap(-xInt) : x;\\n}\\n\\n/// @notice Calculates the arithmetic average of x and y, rounding towards zero.\\n/// @param x The first operand as an SD59x18 number.\\n/// @param y The second operand as an SD59x18 number.\\n/// @return result The arithmetic average as an SD59x18 number.\\nfunction avg(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n\\n    unchecked {\\n        // This is equivalent to \\\"x / 2 +  y / 2\\\" but faster.\\n        // This operation can never overflow.\\n        int256 sum = (xInt >> 1) + (yInt >> 1);\\n\\n        if (sum < 0) {\\n            // If at least one of x and y is odd, we add 1 to the result, since shifting negative numbers to the right rounds\\n            // down to infinity. The right part is equivalent to \\\"sum + (x % 2 == 1 || y % 2 == 1)\\\" but faster.\\n            assembly {\\n                result := add(sum, and(or(xInt, yInt), 1))\\n            }\\n        } else {\\n            // We need to add 1 if both x and y are odd to account for the double 0.5 remainder that is truncated after shifting.\\n            result = wrap(sum + (xInt & yInt & 1));\\n        }\\n    }\\n}\\n\\n/// @notice Yields the smallest whole SD59x18 number greater than or equal to x.\\n///\\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be less than or equal to `MAX_WHOLE_SD59x18`.\\n///\\n/// @param x The SD59x18 number to ceil.\\n/// @param result The least number greater than or equal to x, as an SD59x18 number.\\nfunction ceil(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt > uMAX_WHOLE_SD59x18) {\\n        revert PRBMathSD59x18__CeilOverflow(x);\\n    }\\n\\n    int256 remainder = xInt % uUNIT;\\n    if (remainder == 0) {\\n        result = x;\\n    } else {\\n        unchecked {\\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n            int256 resultInt = xInt - remainder;\\n            if (xInt > 0) {\\n                resultInt += uUNIT;\\n            }\\n            result = wrap(resultInt);\\n        }\\n    }\\n}\\n\\n/// @notice Divides two SD59x18 numbers, returning a new SD59x18 number. Rounds towards zero.\\n///\\n/// @dev This is a variant of `mulDiv` that works with signed numbers. Works by computing the signs and the absolute values\\n/// separately.\\n///\\n/// Requirements:\\n/// - All from `Core/mulDiv`.\\n/// - None of the inputs can be `MIN_SD59x18`.\\n/// - The denominator cannot be zero.\\n/// - The result must fit within int256.\\n///\\n/// Caveats:\\n/// - All from `Core/mulDiv`.\\n///\\n/// @param x The numerator as an SD59x18 number.\\n/// @param y The denominator as an SD59x18 number.\\n/// @param result The quotient as an SD59x18 number.\\nfunction div(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\\n        revert PRBMathSD59x18__DivInputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x and y.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    unchecked {\\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\\n    }\\n\\n    // Compute the absolute value (x*UNIT)\u00f7y. The resulting value must fit within int256.\\n    uint256 resultAbs = mulDiv(xAbs, uint256(uUNIT), yAbs);\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert PRBMathSD59x18__DivOverflow(x, y);\\n    }\\n\\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\\n    bool sameSign = (xInt ^ yInt) > -1;\\n\\n    // If the inputs don't have the same sign, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\\n    }\\n}\\n\\n/// @notice Calculates the natural exponent of x.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// e^x = 2^{x * log_2{e}}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n/// - x must be less than 133.084258667509499441.\\n///\\n/// Caveats:\\n/// - All from `exp2`.\\n/// - For any x less than -41.446531673892822322, the result is zero.\\n///\\n/// @param x The exponent as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\nfunction exp(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    // Without this check, the value passed to `exp2` would be less than -59.794705707972522261.\\n    if (xInt < -41_446531673892822322) {\\n        return ZERO;\\n    }\\n\\n    // Without this check, the value passed to `exp2` would be greater than 192.\\n    if (xInt >= 133_084258667509499441) {\\n        revert PRBMathSD59x18__ExpInputTooBig(x);\\n    }\\n\\n    unchecked {\\n        // Do the fixed-point multiplication inline to save gas.\\n        int256 doubleUnitProduct = xInt * uLOG2_E;\\n        result = exp2(wrap(doubleUnitProduct / uUNIT));\\n    }\\n}\\n\\n/// @notice Calculates the binary exponent of x using the binary fraction method.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// 2^{-x} = \\\\frac{1}{2^x}\\n/// $$\\n///\\n/// See https://ethereum.stackexchange.com/q/79903/24693.\\n///\\n/// Requirements:\\n/// - x must be 192 or less.\\n/// - The result must fit within `MAX_SD59x18`.\\n///\\n/// Caveats:\\n/// - For any x less than -59.794705707972522261, the result is zero.\\n///\\n/// @param x The exponent as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\nfunction exp2(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt < 0) {\\n        // 2^59.794705707972522262 is the maximum number whose inverse does not truncate down to zero.\\n        if (xInt < -59_794705707972522261) {\\n            return ZERO;\\n        }\\n\\n        unchecked {\\n            // Do the fixed-point inversion $1/2^x$ inline to save gas. 1e36 is UNIT * UNIT.\\n            result = wrap(1e36 / unwrap(exp2(wrap(-xInt))));\\n        }\\n    } else {\\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\\n        if (xInt >= 192e18) {\\n            revert PRBMathSD59x18__Exp2InputTooBig(x);\\n        }\\n\\n        unchecked {\\n            // Convert x to the 192.64-bit fixed-point format.\\n            uint256 x_192x64 = uint256((xInt << 64) / uUNIT);\\n\\n            // It is safe to convert the result to int256 with no checks because the maximum input allowed in this function is 192.\\n            result = wrap(int256(prbExp2(x_192x64)));\\n        }\\n    }\\n}\\n\\n/// @notice Yields the greatest whole SD59x18 number less than or equal to x.\\n///\\n/// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\\n/// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\\n///\\n/// Requirements:\\n/// - x must be greater than or equal to `MIN_WHOLE_SD59x18`.\\n///\\n/// @param x The SD59x18 number to floor.\\n/// @param result The greatest integer less than or equal to x, as an SD59x18 number.\\nfunction floor(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt < uMIN_WHOLE_SD59x18) {\\n        revert PRBMathSD59x18__FloorUnderflow(x);\\n    }\\n\\n    int256 remainder = xInt % uUNIT;\\n    if (remainder == 0) {\\n        result = x;\\n    } else {\\n        unchecked {\\n            // Solidity uses C fmod style, which returns a modulus with the same sign as x.\\n            int256 resultInt = xInt - remainder;\\n            if (xInt < 0) {\\n                resultInt -= uUNIT;\\n            }\\n            result = wrap(resultInt);\\n        }\\n    }\\n}\\n\\n/// @notice Yields the excess beyond the floor of x for positive numbers and the part of the number to the right.\\n/// of the radix point for negative numbers.\\n/// @dev Based on the odd function definition. https://en.wikipedia.org/wiki/Fractional_part\\n/// @param x The SD59x18 number to get the fractional part of.\\n/// @param result The fractional part of x as an SD59x18 number.\\nfunction frac(SD59x18 x) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) % uUNIT);\\n}\\n\\n/// @notice Calculates the geometric mean of x and y, i.e. sqrt(x * y), rounding down.\\n///\\n/// @dev Requirements:\\n/// - x * y must fit within `MAX_SD59x18`, lest it overflows.\\n/// - x * y must not be negative, since this library does not handle complex numbers.\\n///\\n/// @param x The first operand as an SD59x18 number.\\n/// @param y The second operand as an SD59x18 number.\\n/// @return result The result as an SD59x18 number.\\nfunction gm(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n    if (xInt == 0 || yInt == 0) {\\n        return ZERO;\\n    }\\n\\n    unchecked {\\n        // Equivalent to \\\"xy / x != y\\\". Checking for overflow this way is faster than letting Solidity do it.\\n        int256 xyInt = xInt * yInt;\\n        if (xyInt / xInt != yInt) {\\n            revert PRBMathSD59x18__GmOverflow(x, y);\\n        }\\n\\n        // The product must not be negative, since this library does not handle complex numbers.\\n        if (xyInt < 0) {\\n            revert PRBMathSD59x18__GmNegativeProduct(x, y);\\n        }\\n\\n        // We don't need to multiply the result by `UNIT` here because the x*y product had picked up a factor of `UNIT`\\n        // during multiplication. See the comments within the `prbSqrt` function.\\n        uint256 resultUint = prbSqrt(uint256(xyInt));\\n        result = wrap(int256(resultUint));\\n    }\\n}\\n\\n/// @notice Calculates 1 / x, rounding toward zero.\\n///\\n/// @dev Requirements:\\n/// - x cannot be zero.\\n///\\n/// @param x The SD59x18 number for which to calculate the inverse.\\n/// @return result The inverse as an SD59x18 number.\\nfunction inv(SD59x18 x) pure returns (SD59x18 result) {\\n    // 1e36 is UNIT * UNIT.\\n    result = wrap(1e36 / unwrap(x));\\n}\\n\\n/// @notice Calculates the natural logarithm of x.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// ln{x} = log_2{x} / log_2{e}$$.\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n///\\n/// Caveats:\\n/// - All from `log2`.\\n/// - This doesn't return exactly 1 for 2.718281828459045235, for that more fine-grained precision is needed.\\n///\\n/// @param x The SD59x18 number for which to calculate the natural logarithm.\\n/// @return result The natural logarithm as an SD59x18 number.\\nfunction ln(SD59x18 x) pure returns (SD59x18 result) {\\n    // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\\n    // can return is 195.205294292027477728.\\n    result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_E);\\n}\\n\\n/// @notice Calculates the common logarithm of x.\\n///\\n/// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\\n/// logarithm based on the formula:\\n///\\n/// $$\\n/// log_{10}{x} = log_2{x} / log_2{10}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `log2`.\\n///\\n/// Caveats:\\n/// - All from `log2`.\\n///\\n/// @param x The SD59x18 number for which to calculate the common logarithm.\\n/// @return result The common logarithm as an SD59x18 number.\\nfunction log10(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMathSD59x18__LogInputTooSmall(x);\\n    }\\n\\n    // Note that the `mul` in this block is the assembly mul operation, not the SD59x18 `mul`.\\n    // prettier-ignore\\n    assembly {\\n        switch x\\n        case 1 { result := mul(uUNIT, sub(0, 18)) }\\n        case 10 { result := mul(uUNIT, sub(1, 18)) }\\n        case 100 { result := mul(uUNIT, sub(2, 18)) }\\n        case 1000 { result := mul(uUNIT, sub(3, 18)) }\\n        case 10000 { result := mul(uUNIT, sub(4, 18)) }\\n        case 100000 { result := mul(uUNIT, sub(5, 18)) }\\n        case 1000000 { result := mul(uUNIT, sub(6, 18)) }\\n        case 10000000 { result := mul(uUNIT, sub(7, 18)) }\\n        case 100000000 { result := mul(uUNIT, sub(8, 18)) }\\n        case 1000000000 { result := mul(uUNIT, sub(9, 18)) }\\n        case 10000000000 { result := mul(uUNIT, sub(10, 18)) }\\n        case 100000000000 { result := mul(uUNIT, sub(11, 18)) }\\n        case 1000000000000 { result := mul(uUNIT, sub(12, 18)) }\\n        case 10000000000000 { result := mul(uUNIT, sub(13, 18)) }\\n        case 100000000000000 { result := mul(uUNIT, sub(14, 18)) }\\n        case 1000000000000000 { result := mul(uUNIT, sub(15, 18)) }\\n        case 10000000000000000 { result := mul(uUNIT, sub(16, 18)) }\\n        case 100000000000000000 { result := mul(uUNIT, sub(17, 18)) }\\n        case 1000000000000000000 { result := 0 }\\n        case 10000000000000000000 { result := uUNIT }\\n        case 100000000000000000000 { result := mul(uUNIT, 2) }\\n        case 1000000000000000000000 { result := mul(uUNIT, 3) }\\n        case 10000000000000000000000 { result := mul(uUNIT, 4) }\\n        case 100000000000000000000000 { result := mul(uUNIT, 5) }\\n        case 1000000000000000000000000 { result := mul(uUNIT, 6) }\\n        case 10000000000000000000000000 { result := mul(uUNIT, 7) }\\n        case 100000000000000000000000000 { result := mul(uUNIT, 8) }\\n        case 1000000000000000000000000000 { result := mul(uUNIT, 9) }\\n        case 10000000000000000000000000000 { result := mul(uUNIT, 10) }\\n        case 100000000000000000000000000000 { result := mul(uUNIT, 11) }\\n        case 1000000000000000000000000000000 { result := mul(uUNIT, 12) }\\n        case 10000000000000000000000000000000 { result := mul(uUNIT, 13) }\\n        case 100000000000000000000000000000000 { result := mul(uUNIT, 14) }\\n        case 1000000000000000000000000000000000 { result := mul(uUNIT, 15) }\\n        case 10000000000000000000000000000000000 { result := mul(uUNIT, 16) }\\n        case 100000000000000000000000000000000000 { result := mul(uUNIT, 17) }\\n        case 1000000000000000000000000000000000000 { result := mul(uUNIT, 18) }\\n        case 10000000000000000000000000000000000000 { result := mul(uUNIT, 19) }\\n        case 100000000000000000000000000000000000000 { result := mul(uUNIT, 20) }\\n        case 1000000000000000000000000000000000000000 { result := mul(uUNIT, 21) }\\n        case 10000000000000000000000000000000000000000 { result := mul(uUNIT, 22) }\\n        case 100000000000000000000000000000000000000000 { result := mul(uUNIT, 23) }\\n        case 1000000000000000000000000000000000000000000 { result := mul(uUNIT, 24) }\\n        case 10000000000000000000000000000000000000000000 { result := mul(uUNIT, 25) }\\n        case 100000000000000000000000000000000000000000000 { result := mul(uUNIT, 26) }\\n        case 1000000000000000000000000000000000000000000000 { result := mul(uUNIT, 27) }\\n        case 10000000000000000000000000000000000000000000000 { result := mul(uUNIT, 28) }\\n        case 100000000000000000000000000000000000000000000000 { result := mul(uUNIT, 29) }\\n        case 1000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 30) }\\n        case 10000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 31) }\\n        case 100000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 32) }\\n        case 1000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 33) }\\n        case 10000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 34) }\\n        case 100000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 35) }\\n        case 1000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 36) }\\n        case 10000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 37) }\\n        case 100000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 38) }\\n        case 1000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 39) }\\n        case 10000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 40) }\\n        case 100000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 41) }\\n        case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 42) }\\n        case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 43) }\\n        case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 44) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 45) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 46) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 47) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 48) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 49) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 50) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 51) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 52) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 53) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 54) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 55) }\\n        case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 56) }\\n        case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 57) }\\n        case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(uUNIT, 58) }\\n        default {\\n            result := uMAX_SD59x18\\n        }\\n    }\\n\\n    if (unwrap(result) == uMAX_SD59x18) {\\n        unchecked {\\n            // Do the fixed-point division inline to save gas.\\n            result = wrap((unwrap(log2(x)) * uUNIT) / uLOG2_10);\\n        }\\n    }\\n}\\n\\n/// @notice Calculates the binary logarithm of x.\\n///\\n/// @dev Based on the iterative approximation algorithm.\\n/// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\\n///\\n/// Requirements:\\n/// - x must be greater than zero.\\n///\\n/// Caveats:\\n/// - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\\n///\\n/// @param x The SD59x18 number for which to calculate the binary logarithm.\\n/// @return result The binary logarithm as an SD59x18 number.\\nfunction log2(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt <= 0) {\\n        revert PRBMathSD59x18__LogInputTooSmall(x);\\n    }\\n\\n    unchecked {\\n        // This works because of:\\n        //\\n        // $$\\n        // log_2{x} = -log_2{\\\\frac{1}{x}}\\n        // $$\\n        int256 sign;\\n        if (xInt >= uUNIT) {\\n            sign = 1;\\n        } else {\\n            sign = -1;\\n            // Do the fixed-point inversion inline to save gas. The numerator is UNIT * UNIT.\\n            xInt = 1e36 / xInt;\\n        }\\n\\n        // Calculate the integer part of the logarithm and add it to the result and finally calculate $y = x * 2^(-n)$.\\n        uint256 n = msb(uint256(xInt / uUNIT));\\n\\n        // This is the integer part of the logarithm as an SD59x18 number. The operation can't overflow\\n        // because n is maximum 255, UNIT is 1e18 and sign is either 1 or -1.\\n        int256 resultInt = int256(n) * uUNIT;\\n\\n        // This is $y = x * 2^{-n}$.\\n        int256 y = xInt >> n;\\n\\n        // If y is 1, the fractional part is zero.\\n        if (y == uUNIT) {\\n            return wrap(resultInt * sign);\\n        }\\n\\n        // Calculate the fractional part via the iterative approximation.\\n        // The \\\"delta >>= 1\\\" part is equivalent to \\\"delta /= 2\\\", but shifting bits is faster.\\n        int256 DOUBLE_UNIT = 2e18;\\n        for (int256 delta = uHALF_UNIT; delta > 0; delta >>= 1) {\\n            y = (y * y) / uUNIT;\\n\\n            // Is $y^2 > 2$ and so in the range [2,4)?\\n            if (y >= DOUBLE_UNIT) {\\n                // Add the 2^{-m} factor to the logarithm.\\n                resultInt = resultInt + delta;\\n\\n                // Corresponds to z/2 on Wikipedia.\\n                y >>= 1;\\n            }\\n        }\\n        resultInt *= sign;\\n        result = wrap(resultInt);\\n    }\\n}\\n\\n/// @notice Multiplies two SD59x18 numbers together, returning a new SD59x18 number.\\n///\\n/// @dev This is a variant of `mulDiv` that works with signed numbers and employs constant folding, i.e. the denominator\\n/// is always 1e18.\\n///\\n/// Requirements:\\n/// - All from `Core/mulDiv18`.\\n/// - None of the inputs can be `MIN_SD59x18`.\\n/// - The result must fit within `MAX_SD59x18`.\\n///\\n/// Caveats:\\n/// - To understand how this works in detail, see the NatSpec comments in `Core/mulDivSigned`.\\n///\\n/// @param x The multiplicand as an SD59x18 number.\\n/// @param y The multiplier as an SD59x18 number.\\n/// @return result The product as an SD59x18 number.\\nfunction mul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n    if (xInt == uMIN_SD59x18 || yInt == uMIN_SD59x18) {\\n        revert PRBMathSD59x18__MulInputTooSmall();\\n    }\\n\\n    // Get hold of the absolute values of x and y.\\n    uint256 xAbs;\\n    uint256 yAbs;\\n    unchecked {\\n        xAbs = xInt < 0 ? uint256(-xInt) : uint256(xInt);\\n        yAbs = yInt < 0 ? uint256(-yInt) : uint256(yInt);\\n    }\\n\\n    uint256 resultAbs = mulDiv18(xAbs, yAbs);\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert PRBMathSD59x18__MulOverflow(x, y);\\n    }\\n\\n    // Check if x and y have the same sign. This works thanks to two's complement; the left-most bit is the sign bit.\\n    bool sameSign = (xInt ^ yInt) > -1;\\n\\n    // If the inputs have the same sign, the result should be negative. Otherwise, it should be positive.\\n    unchecked {\\n        result = wrap(sameSign ? int256(resultAbs) : -int256(resultAbs));\\n    }\\n}\\n\\n/// @notice Raises x to the power of y.\\n///\\n/// @dev Based on the formula:\\n///\\n/// $$\\n/// x^y = 2^{log_2{x} * y}\\n/// $$\\n///\\n/// Requirements:\\n/// - All from `exp2`, `log2` and `mul`.\\n/// - x cannot be zero.\\n///\\n/// Caveats:\\n/// - All from `exp2`, `log2` and `mul`.\\n/// - Assumes 0^0 is 1.\\n///\\n/// @param x Number to raise to given power y, as an SD59x18 number.\\n/// @param y Exponent to raise x to, as an SD59x18 number\\n/// @return result x raised to power y, as an SD59x18 number.\\nfunction pow(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    int256 yInt = unwrap(y);\\n\\n    if (xInt == 0) {\\n        result = yInt == 0 ? UNIT : ZERO;\\n    } else {\\n        if (yInt == uUNIT) {\\n            result = x;\\n        } else {\\n            result = exp2(mul(log2(x), y));\\n        }\\n    }\\n}\\n\\n/// @notice Raises x (an SD59x18 number) to the power y (unsigned basic integer) using the famous algorithm\\n/// algorithm \\\"exponentiation by squaring\\\".\\n///\\n/// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\\n///\\n/// Requirements:\\n/// - All from `abs` and `Core/mulDiv18`.\\n/// - The result must fit within `MAX_SD59x18`.\\n///\\n/// Caveats:\\n/// - All from `Core/mulDiv18`.\\n/// - Assumes 0^0 is 1.\\n///\\n/// @param x The base as an SD59x18 number.\\n/// @param y The exponent as an uint256.\\n/// @return result The result as an SD59x18 number.\\nfunction powu(SD59x18 x, uint256 y) pure returns (SD59x18 result) {\\n    uint256 xAbs = uint256(unwrap(abs(x)));\\n\\n    // Calculate the first iteration of the loop in advance.\\n    uint256 resultAbs = y & 1 > 0 ? xAbs : uint256(uUNIT);\\n\\n    // Equivalent to \\\"for(y /= 2; y > 0; y /= 2)\\\" but faster.\\n    uint256 yAux = y;\\n    for (yAux >>= 1; yAux > 0; yAux >>= 1) {\\n        xAbs = mulDiv18(xAbs, xAbs);\\n\\n        // Equivalent to \\\"y % 2 == 1\\\" but faster.\\n        if (yAux & 1 > 0) {\\n            resultAbs = mulDiv18(resultAbs, xAbs);\\n        }\\n    }\\n\\n    // The result must fit within `MAX_SD59x18`.\\n    if (resultAbs > uint256(uMAX_SD59x18)) {\\n        revert PRBMathSD59x18__PowuOverflow(x, y);\\n    }\\n\\n    unchecked {\\n        // Is the base negative and the exponent an odd number?\\n        int256 resultInt = int256(resultAbs);\\n        bool isNegative = unwrap(x) < 0 && y & 1 == 1;\\n        if (isNegative) {\\n            resultInt = -resultInt;\\n        }\\n        result = wrap(resultInt);\\n    }\\n}\\n\\n/// @notice Calculates the square root of x, rounding down. Only the positive root is returned.\\n/// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\\n///\\n/// Requirements:\\n/// - x cannot be negative, since this library does not handle complex numbers.\\n/// - x must be less than `MAX_SD59x18` divided by `UNIT`.\\n///\\n/// @param x The SD59x18 number for which to calculate the square root.\\n/// @return result The result as an SD59x18 number.\\nfunction sqrt(SD59x18 x) pure returns (SD59x18 result) {\\n    int256 xInt = unwrap(x);\\n    if (xInt < 0) {\\n        revert PRBMathSD59x18__SqrtNegativeInput(x);\\n    }\\n    if (xInt > uMAX_SD59x18 / uUNIT) {\\n        revert PRBMathSD59x18__SqrtOverflow(x);\\n    }\\n\\n    unchecked {\\n        // Multiply x by `UNIT` to account for the factor of `UNIT` that is picked up when multiplying two SD59x18\\n        // numbers together (in this case, the two numbers are both the square root).\\n        uint256 resultUint = prbSqrt(uint256(xInt * uUNIT));\\n        result = wrap(int256(resultUint));\\n    }\\n}\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                            CONVERSION FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\n/// @notice Converts an SD59x18 number to a simple integer by dividing it by `UNIT`. Rounds towards zero in the process.\\n/// @param x The SD59x18 number to convert.\\n/// @return result The same number as a simple integer.\\nfunction fromSD59x18(SD59x18 x) pure returns (int256 result) {\\n    result = unwrap(x) / uUNIT;\\n}\\n\\n/// @notice Wraps a signed integer into the SD59x18 type.\\nfunction sd(int256 x) pure returns (SD59x18 result) {\\n    result = wrap(x);\\n}\\n\\n/// @notice Wraps a signed integer into the SD59x18 type.\\n/// @dev Alias for the \\\"sd\\\" function defined above.\\nfunction sd59x18(int256 x) pure returns (SD59x18 result) {\\n    result = wrap(x);\\n}\\n\\n/// @notice Converts a simple integer to SD59x18 by multiplying it by `UNIT`.\\n///\\n/// @dev Requirements:\\n/// - x must be greater than or equal to `MIN_SD59x18` divided by `UNIT`.\\n/// - x must be less than or equal to `MAX_SD59x18` divided by `UNIT`.\\n///\\n/// @param x The basic integer to convert.\\n/// @param result The same number converted to SD59x18.\\nfunction toSD59x18(int256 x) pure returns (SD59x18 result) {\\n    if (x < uMIN_SD59x18 / uUNIT) {\\n        revert PRBMathSD59x18__ToSD59x18Underflow(x);\\n    }\\n    if (x > uMAX_SD59x18 / uUNIT) {\\n        revert PRBMathSD59x18__ToSD59x18Overflow(x);\\n    }\\n    unchecked {\\n        result = wrap(x * uUNIT);\\n    }\\n}\\n\\n/// @notice Unwraps an SD59x18 number into the underlying signed integer.\\nfunction unwrap(SD59x18 x) pure returns (int256 result) {\\n    result = SD59x18.unwrap(x);\\n}\\n\\n/// @notice Wraps a signed integer into the SD59x18 type.\\nfunction wrap(int256 x) pure returns (SD59x18 result) {\\n    result = SD59x18.wrap(x);\\n}\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                        GLOBAL-SCOPED HELPER FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing {\\n    add,\\n    and,\\n    eq,\\n    gt,\\n    gte,\\n    isZero,\\n    lshift,\\n    lt,\\n    lte,\\n    mod,\\n    neq,\\n    or,\\n    rshift,\\n    sub,\\n    uncheckedAdd,\\n    uncheckedSub,\\n    uncheckedUnary,\\n    xor\\n} for SD59x18 global;\\n\\n/// @notice Implements the checked addition operation (+) in the SD59x18 type.\\nfunction add(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    return wrap(unwrap(x) + unwrap(y));\\n}\\n\\n/// @notice Implements the AND (&) bitwise operation in the SD59x18 type.\\nfunction and(SD59x18 x, int256 bits) pure returns (SD59x18 result) {\\n    return wrap(unwrap(x) & bits);\\n}\\n\\n/// @notice Implements the equal (=) operation in the SD59x18 type.\\nfunction eq(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) == unwrap(y);\\n}\\n\\n/// @notice Implements the greater than operation (>) in the SD59x18 type.\\nfunction gt(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) > unwrap(y);\\n}\\n\\n/// @notice Implements the greater than or equal to operation (>=) in the SD59x18 type.\\nfunction gte(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) >= unwrap(y);\\n}\\n\\n/// @notice Implements a zero comparison check function in the SD59x18 type.\\nfunction isZero(SD59x18 x) pure returns (bool result) {\\n    result = unwrap(x) == 0;\\n}\\n\\n/// @notice Implements the left shift operation (<<) in the SD59x18 type.\\nfunction lshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) << bits);\\n}\\n\\n/// @notice Implements the lower than operation (<) in the SD59x18 type.\\nfunction lt(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) < unwrap(y);\\n}\\n\\n/// @notice Implements the lower than or equal to operation (<=) in the SD59x18 type.\\nfunction lte(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) <= unwrap(y);\\n}\\n\\n/// @notice Implements the unchecked modulo operation (%) in the SD59x18 type.\\nfunction mod(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) % unwrap(y));\\n}\\n\\n/// @notice Implements the not equal operation (!=) in the SD59x18 type.\\nfunction neq(SD59x18 x, SD59x18 y) pure returns (bool result) {\\n    result = unwrap(x) != unwrap(y);\\n}\\n\\n/// @notice Implements the OR (|) bitwise operation in the SD59x18 type.\\nfunction or(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) | unwrap(y));\\n}\\n\\n/// @notice Implements the right shift operation (>>) in the SD59x18 type.\\nfunction rshift(SD59x18 x, uint256 bits) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) >> bits);\\n}\\n\\n/// @notice Implements the checked subtraction operation (-) in the SD59x18 type.\\nfunction sub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) - unwrap(y));\\n}\\n\\n/// @notice Implements the unchecked addition operation (+) in the SD59x18 type.\\nfunction uncheckedAdd(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(unwrap(x) + unwrap(y));\\n    }\\n}\\n\\n/// @notice Implements the unchecked subtraction operation (-) in the SD59x18 type.\\nfunction uncheckedSub(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(unwrap(x) - unwrap(y));\\n    }\\n}\\n\\n/// @notice Implements the unchecked unary minus operation (-) in the SD59x18 type.\\nfunction uncheckedUnary(SD59x18 x) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(-unwrap(x));\\n    }\\n}\\n\\n/// @notice Implements the XOR (^) bitwise operation in the SD59x18 type.\\nfunction xor(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    result = wrap(unwrap(x) ^ unwrap(y));\\n}\\n\\n/*//////////////////////////////////////////////////////////////////////////\\n                        FILE-SCOPED HELPER FUNCTIONS\\n//////////////////////////////////////////////////////////////////////////*/\\n\\nusing { uncheckedDiv, uncheckedMul } for SD59x18;\\n\\n/// @notice Implements the unchecked standard division operation in the SD59x18 type.\\nfunction uncheckedDiv(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(unwrap(x) / unwrap(y));\\n    }\\n}\\n\\n/// @notice Implements the unchecked standard multiplication operation in the SD59x18 type.\\nfunction uncheckedMul(SD59x18 x, SD59x18 y) pure returns (SD59x18 result) {\\n    unchecked {\\n        result = wrap(unwrap(x) * unwrap(y));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/IvPair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"../types.sol\\\";\\n\\ninterface IvPair {\\n    event Mint(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        uint lpTokens,\\n        uint poolLPTokens\\n    );\\n\\n    event Burn(\\n        address indexed sender,\\n        uint256 amount0,\\n        uint256 amount1,\\n        address indexed to,\\n        uint256 totalSupply\\n    );\\n\\n    event Swap(\\n        address indexed sender,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        address indexed to\\n    );\\n\\n    event SwapReserve(\\n        address indexed sender,\\n        address tokenIn,\\n        address tokenOut,\\n        uint256 amountIn,\\n        uint256 amountOut,\\n        address ikPool,\\n        address indexed to\\n    );\\n\\n    event AllowListChanged(address[] tokens);\\n\\n    event Sync(uint112 balance0, uint112 balance1);\\n\\n    event ReserveSync(address asset, uint256 balance, uint256 rRatio);\\n\\n    event FeeChanged(uint16 fee, uint16 vFee);\\n\\n    event ReserveThresholdChanged(uint256 newThreshold);\\n\\n    event AllowListCountChanged(uint24 _maxAllowListCount);\\n\\n    event EmergencyDiscountChanged(uint256 _newEmergencyDiscount);\\n\\n    event BlocksDelayChanged(uint256 _newBlocksDelay);\\n\\n    event ReserveRatioWarningThresholdChanged(\\n        uint256 _newReserveRatioWarningThreshold\\n    );\\n\\n    function fee() external view returns (uint16);\\n\\n    function vFee() external view returns (uint16);\\n\\n    function setFee(uint16 _fee, uint16 _vFee) external;\\n\\n    function swapNative(\\n        uint256 amountOut,\\n        address tokenOut,\\n        address to,\\n        bytes calldata data\\n    ) external returns (uint256 _amountIn);\\n\\n    function swapReserveToNative(\\n        uint256 amountOut,\\n        address ikPair,\\n        address to,\\n        bytes calldata data\\n    ) external returns (uint256 _amountIn);\\n\\n    function swapNativeToReserve(\\n        uint256 amountOut,\\n        address ikPair,\\n        address to,\\n        uint256 incentivesLimitPct,\\n        bytes calldata data\\n    ) external returns (address _token, uint256 _leftovers);\\n\\n    function mint(address to) external returns (uint256 liquidity);\\n\\n    function burn(\\n        address to\\n    ) external returns (uint256 amount0, uint256 amount1);\\n\\n    function setAllowList(address[] memory _allowList) external;\\n\\n    function setMaxAllowListCount(uint24 _maxAllowListCount) external;\\n\\n    function allowListMap(address _token) external view returns (bool allowed);\\n\\n    function calculateReserveRatio() external view returns (uint256 rRatio);\\n\\n    function setMaxReserveThreshold(uint256 threshold) external;\\n\\n    function setReserveRatioWarningThreshold(uint256 threshold) external;\\n\\n    function setEmergencyDiscount(uint256 discount) external;\\n\\n    function setBlocksDelay(uint256 _newBlocksDelay) external;\\n\\n    function token0() external view returns (address);\\n\\n    function token1() external view returns (address);\\n\\n    function pairBalance0() external view returns (uint112);\\n\\n    function pairBalance1() external view returns (uint112);\\n\\n    function maxAllowListCount() external view returns (uint24);\\n\\n    function maxReserveRatio() external view returns (uint256);\\n\\n    function getBalances() external view returns (uint112, uint112);\\n\\n    function getLastBalances()\\n        external\\n        view\\n        returns (\\n            uint112 _lastBalance0,\\n            uint112 _lastBalance1,\\n            uint32 _blockNumber\\n        );\\n\\n    function getTokens() external view returns (address, address);\\n\\n    function reservesBaseValue(\\n        address reserveAddress\\n    ) external view returns (uint256);\\n\\n    function reserves(address reserveAddress) external view returns (uint256);\\n\\n    function reservesBaseValueSum() external view returns (uint256);\\n\\n    function reserveRatioFactor() external pure returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/external/interfaces/IvPairFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity 0.8.18;\\n\\ninterface IvPairFactory {\\n    event PairCreated(\\n        address poolAddress,\\n        address factory,\\n        address token0,\\n        address token1,\\n        uint16 fee,\\n        uint16 vFee,\\n        uint256 maxReserveRatio\\n    );\\n\\n    event DefaultAllowListChanged(address[] allowList);\\n\\n    event FactoryNewAdmin(address newAdmin);\\n    event FactoryNewPendingAdmin(address newPendingAdmin);\\n\\n    event FactoryNewEmergencyAdmin(address newEmergencyAdmin);\\n    event FactoryNewPendingEmergencyAdmin(address newPendingEmergencyAdmin);\\n\\n    event ExchangeReserveAddressChanged(address newExchangeReserve);\\n\\n    event FactoryVPoolManagerChanged(address newVPoolManager);\\n\\n    function createPair(\\n        address tokenA,\\n        address tokenB\\n    ) external returns (address);\\n\\n    function pairs(\\n        address tokenA,\\n        address tokenB\\n    ) external view returns (address);\\n\\n    function setDefaultAllowList(address[] calldata _defaultAllowList) external;\\n\\n    function allPairs(uint256 index) external view returns (address);\\n\\n    function allPairsLength() external view returns (uint256);\\n\\n    function vPoolManager() external view returns (address);\\n\\n    function admin() external view returns (address);\\n\\n    function emergencyAdmin() external view returns (address);\\n\\n    function pendingEmergencyAdmin() external view returns (address);\\n\\n    function setPendingEmergencyAdmin(address newEmergencyAdmin) external;\\n\\n    function acceptEmergencyAdmin() external;\\n\\n    function pendingAdmin() external view returns (address);\\n\\n    function setPendingAdmin(address newAdmin) external;\\n\\n    function setVPoolManagerAddress(address _vPoolManager) external;\\n\\n    function acceptAdmin() external;\\n\\n    function exchangeReserves() external view returns (address);\\n\\n    function setExchangeReservesAddress(address _exchangeReserves) external;\\n}\\n\"\r\n    },\r\n    \"contracts/external/types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\npragma solidity 0.8.18;\\n\\nstruct MaxTradeAmountParams {\\n    uint256 fee;\\n    uint256 balance0;\\n    uint256 balance1;\\n    uint256 vBalance0;\\n    uint256 vBalance1;\\n    uint256 reserveRatioFactor;\\n    uint256 priceFeeFactor;\\n    uint256 maxReserveRatio;\\n    uint256 reserves;\\n    uint256 reservesBaseValueSum;\\n}\\n\\nstruct VirtualPoolModel {\\n    uint24 fee;\\n    address token0;\\n    address token1;\\n    uint256 balance0;\\n    uint256 balance1;\\n    address commonToken;\\n    address jkPair;\\n    address ikPair;\\n}\\n\\nstruct VirtualPoolTokens {\\n    address jk0;\\n    address jk1;\\n    address ik0;\\n    address ik1;\\n}\\n\\nstruct ExchangeReserveCallbackParams {\\n    address jkPair1;\\n    address ikPair1;\\n    address jkPair2;\\n    address ikPair2;\\n    address caller;\\n    uint256 flashAmountOut;\\n}\\n\\nstruct SwapCallbackData {\\n    address caller;\\n    uint256 tokenInMax;\\n    uint ETHValue;\\n    address jkPool;\\n}\\n\\nstruct PoolCreationDefaults {\\n    address factory;\\n    address token0;\\n    address token1;\\n    uint16 fee;\\n    uint16 vFee;\\n    uint24 maxAllowListCount;\\n    uint256 maxReserveRatio;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVChainMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\n/**\\n * @title Interface for vChainMinter contract, which handles VRSW and veVRSW tokens distribution\\n * among stakers.\\n */\\ninterface IVChainMinter {\\n    /**\\n     * @notice Emitted when a new partner reward is distributing.\\n     * @param partnerToken is a partner token address\\n     * @param amount is an amount of partner tokens to distribute\\n     * @param pool is a pool address for which the partner token is distributed\\n     * @param from is a timestamp of the distribution start\\n     * @param duration is a distribution duration in seconds\\n     */\\n    event PartnerRewards(address indexed partnerToken, uint128 amount,\\n                        address indexed pool, uint128 from, uint128 duration);\\n\\n    /**\\n     * @notice Emitted when a new stakeris set.\\n     * @param stakerAddress is the address of the new staker factory.\\n     */\\n    event NewStaker(address stakerAddress);\\n\\n    /**\\n     * @notice Emitted when rewards are transferred to an address.\\n     * @param to The address receiving the rewards.\\n     * @param pool The address of pool for staking in which the rewards are transferred.\\n     * @param rewardToken The address of the reward token transferred\\n     * @param amount The amount of rewards transferred.\\n     */\\n    event TransferRewards(\\n        address indexed to,\\n        address indexed pool,\\n        address indexed rewardToken,\\n        uint256 amount\\n    );\\n\\n    event AllocationPointsChanged(address[] _pools, uint[] _allocationPoints);\\n\\n    /**\\n     * @notice Changes minting epoch duration and preparation time.\\n     * @param _epochDuration The duration (in seconds) of the epoch starting from the next\\n     * @param _epochPreparationTime The time (in seconds) before the next epoch for transfering\\n     * tokens.\\n     *\\n     * Requirements:\\n     * - The caller must be the owner of the contract.\\n     */\\n    function setEpochParams(\\n        uint32 _epochDuration,\\n        uint32 _epochPreparationTime\\n    ) external;\\n\\n    /**\\n     * @notice Accepts necessary amount of VRSW tokens for the\\n     * next mining epoch according to the schedule defined in EmissionMath library.\\n     * Currently the transfers are done manually using intermediary wallet (contracts owner).\\n     * @param nextBalance Amount of VRSW tokens for the next epoch.\\n     *\\n     * Requirements:\\n     * - The caller must be the owner of the contract.\\n     */\\n    function prepareForNextEpoch(uint256 nextBalance) external;\\n\\n    /**\\n     * @dev Sets the allocation points for a list of pools.\\n     *\\n     * This function allows the owner of the contract to set the allocation points\\n     * for a list of pools, which determines their share of the total rewards\\n     * distributed by the contract. The total allocation points must be non-zero,\\n     * and each pool must be registered in Virtuswap pairs factory.\\n     *\\n     * @param pools The addresses of the pools to set the allocation points for.\\n     * @param allocationPoints The allocation points to set for each staker.\\n     *\\n     * Requirements:\\n     * - The caller must be the owner of the contract.\\n     */\\n    function setAllocationPoints(\\n        address[] calldata pools,\\n        uint256[] calldata allocationPoints\\n    ) external;\\n\\n    /**\\n     * @notice Sets the address of the staker contract.\\n     * @dev Can be called only by owner.\\n     * @notice The staker factory can be set only once\\n     * @param _newStaker The address of the new staker contract.\\n     */\\n    function setStaker(address _newStaker) external;\\n\\n    /**\\n     * @notice Returns the timestamp when VRSW emission began.\\n     * @return The timestamp when VRSW emission began.\\n     */\\n    function emissionStartTs() external view returns (uint256);\\n\\n    /**\\n     * @notice Transfers a specified amount of reward tokens to a recipient.\\n     *\\n     * This function allows a registered staker to transfer a specified amount of\\n     * rewards tokens to a recipient address. The caller must be a registered staker,\\n     * and the current timestamp must be later than the contract's emission start time.\\n     *\\n     * @param to The address of the recipient to transfer tokens to.\\n     * @param pool The address of the pool from which rewards are transferred.\\n     * @param rewardTokens The reward tokens addresses.\\n     * @param amounts The amounts of reward tokens to transfer.\\n     *\\n     * Requirements:\\n     * - The current timestamp must be later than the contract's emission start time.\\n     * - The amount to transfer must be greater than zero.\\n     */\\n    function transferRewards(\\n        address to,\\n        address pool,\\n        address[] calldata rewardTokens,\\n        uint256[] calldata amounts\\n    ) external;\\n\\n    /**\\n     * @notice Mint veVrsw tokens to the specified to address.\\n     * @param to The address to which the minted veVrsw tokens will be sent.\\n     * @param amount The amount of veVrsw tokens to be minted.\\n     * Requirements:\\n     * - amount must be greater than zero.\\n     * - The sender must be a valid staker.\\n     */\\n    function mintVeVrsw(address to, uint256 amount) external;\\n\\n    /**\\n     * @notice Burn amount of veVrsw tokens from the specified to address.\\n     * @param from The address from which the veVrsw tokens will be burned.\\n     * @param amount The amount of veVrsw tokens to be burned.\\n     * Requirements:\\n     * - amount must be greater than zero.\\n     * - The sender must be a valid staker.\\n     */\\n    function burnVeVrsw(address from, uint256 amount) external;\\n\\n    /**\\n     * @notice Triggers next epoch transition\\n     */\\n    function triggerEpochTransition() external;\\n\\n    /**\\n     * @notice Returns reward tokens addresses for specified pool\\n     * @param pool The address of pool.\\n     * @return List of reward tokens addresses for specified pool\\n     */\\n    function getRewardTokens(\\n        address pool\\n    ) external view returns (address[] memory);\\n\\n    /**\\n     * @notice Distributes amount of partnerToken for a specified pool. The\\n     * distribution is linear.\\n     * @param partnerToken The address of the partner token.\\n     * @param amount The amount of the partner token.\\n     * @param pool The pool address for which distribution is created\\n     * @param from The timestamp of the distribution start\\n     * @param duration The duration of the distribution\\n     */\\n    function distributePartnerToken(\\n        address partnerToken,\\n        uint128 amount,\\n        address pool,\\n        uint128 from,\\n        uint128 duration\\n    ) external;\\n\\n    /**\\n     * @notice Calculates the amount of reward tokens a pool is eligible to receive.\\n     * @param pool The address of the staker pool.\\n     * @param rewardToken The address of the reward token.\\n     * @return The amount of tokens the pool is eligible to receive.\\n     */\\n    function calculateTokensForPool(\\n        address pool,\\n        address rewardToken\\n    ) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVStaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport \\\"../Types.sol\\\";\\n\\n/**\\n * @title Interface for vStaker contract for staking VRSW and LP tokens.\\n */\\ninterface IVStaker {\\n    /**\\n     * @notice Emitted when who stakes amount of VRSW tokens.\\n     * @param who Address of the account that stakes the tokens.\\n     * @param amount Amount of VRSW tokens being staked.\\n     * @param startTs start timestamp of the current position\\n     * @param discountFactor discount factor for the current position equals exp(-r * stakeTime)  used in formula (3) in Virtuswap Tokenomics Whitepaper\\n     */\\n    event StakeVrsw(\\n        address indexed who,\\n        uint256 amount,\\n        uint128 startTs,\\n        uint256 discountFactor\\n    );\\n\\n    /**\\n     * @notice Emitted when who stakes amount of LP tokens.\\n     * @param who Address of the account that stakes the tokens.\\n     * @param lpToken Address of staked LP token.\\n     * @param amount Amount of LP tokens being staked.\\n     */\\n    event StakeLp(address indexed who, address indexed lpToken, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when who unstakes amount of LP tokens.\\n     * @param who Address of the account that unstakes the tokens.\\n     * @param lpToken Address of unstaked LP token.\\n     * @param amount Amount of LP tokens being unstaked.\\n     */\\n    event UnstakeLp(\\n        address indexed who,\\n        address indexed lpToken,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @notice Emitted when who unstakes amount of VRSW tokens.\\n     * @param who Address of the account that unstakes the tokens.\\n     * @param amount Amount of VRSW tokens being unstaked.\\n     */\\n    event UnstakeVrsw(address indexed who, uint256 amount);\\n\\n    /**\\n     * @notice Emitted when who locks amount of VRSW tokens for lockDuration seconds.\\n     * @param who Address of the account that locks the tokens.\\n     * @param amount Amount of VRSW tokens being locked.\\n     * @param lockDuration Duration in seconds for which the tokens are locked.\\n     * @param startTs start timestamp of the current position\\n     * @param discountFactor discount factor for the current position equals exp(-r * stakeTime)  used in formula (3) in Virtuswap Tokenomics Whitepaper\\n     **/\\n    event LockVrsw(\\n        address indexed who,\\n        uint256 amount,\\n        uint128 lockDuration,\\n        uint128 startTs,\\n        uint256 discountFactor\\n    );\\n\\n    /**\\n     * @notice Emitted when who locks amount of staked VRSW tokens for lockDuration seconds.\\n     * @param who Address of the account that locks the tokens.\\n     * @param amount Amount of staked VRSW tokens being locked.\\n     * @param lockDuration Duration in seconds for which the tokens are locked.\\n     */\\n    event LockStakedVrsw(\\n        address indexed who,\\n        uint256 amount,\\n        uint128 lockDuration,\\n        uint128 startTs,\\n        uint256 discountFactor\\n    );\\n\\n    event MuChanged(\\n        address indexed who,\\n        address indexed pool,\\n        uint256 mu,\\n        uint256 totalMu\\n    );\\n\\n    /**\\n     * @notice Emitted when who unlocks amount of VRSW tokens.\\n     * @param who Address of the account that unlocks the tokens.\\n     * @param amount Amount of VRSW tokens being unlocked.\\n     */\\n    event UnlockVrsw(address indexed who, uint256 amount);\\n\\n    /**\\n     * @notice Stake VRSW tokens into the vStaker contract.\\n     * @param amount The amount of VRSW tokens to stake.\\n     */\\n    function stakeVrsw(uint256 amount) external;\\n\\n    /**\\n     * @notice Stake LP tokens into the vStaker contract.\\n     * @param lpToken Address of staked LP token.\\n     * @param amount The amount of LP tokens to stake.\\n     */\\n    function stakeLp(address lpToken, uint256 amount) external;\\n\\n    /**\\n\\n     * @notice Allows a user to claim their accrued VRSW rewards. The user's accrued rewards are calculated using the\\n     * @param pool Address of pool.\\n     * _calculateAccruedRewards function. The rewards claimed are transferred\\n     * to the user's address using the transferRewards function of the IvMinter contract.\\n*/\\n    function claimRewards(address pool) external;\\n\\n    /**\\n     * @notice Returns the amount of reward tokens that a user has accrued but not yet claimed. The user's accrued rewards are\\n     * calculated using the _calculateAccruedRewards function.\\n     * @param who The address of the user to query for accrued rewards.\\n     * @param pool Address of pool.\\n     * @param rewardToken The address of the reward token.\\n     * @return rewards The amount of VRSW rewards that the user has accrued but not yet claimed.\\n     */\\n    function viewRewards(\\n        address who,\\n        address pool,\\n        address rewardToken\\n    ) external view returns (uint256 rewards);\\n\\n    /**\\n     *\\n     * @notice Returns an array of VrswStake structures containing information about the user's VRSW stakes.\\n     * @return vrswStakes An array of VrswStake structures containing information about the user's VRSW stakes.\\n     */\\n    function viewVrswStakes()\\n        external\\n        view\\n        returns (VrswStake[] memory vrswStakes);\\n\\n    /**\\n     *\\n     * @notice Returns an array of LpStake structures containing information about the user's LP tokens stakes.\\n     * @return lpStakes An array of LpStake structures containing information about the user's LP tokens stakes.\\n     */\\n    function viewLpStakes() external view returns (LpStake[] memory lpStakes);\\n\\n    /**\\n     * @notice Checks if pool is a valid pool registered in Virtuswap pairs factory\\n     * @param pool Address of pool.\\n     * @return Whether pool is valid\\n     */\\n    function isPoolValid(address pool) external view returns (bool);\\n\\n    /**\\n     * @dev Allows the user to unstake LP tokens from the contract. The LP tokens are transferred back to the user's wallet.\\n     * @param lpToken Address of unstaked LP token.\\n     * @param amount The amount of LP tokens to unstake.\\n     */\\n    function unstakeLp(address lpToken, uint256 amount) external;\\n\\n    /**\\n     * @notice Allows the user to lock VRSW tokens in the contract for a specified duration of time.\\n     * @param amount The amount of VRSW tokens to lock.\\n     * @param lockDuration The duration of time to lock the tokens for.\\n     */\\n    function lockVrsw(uint256 amount, uint128 lockDuration) external;\\n\\n    /**\\n     * @notice Locks a specified amount of staked VRSW tokens for a specified duration.\\n     * @param amount The amount of VRSW tokens to lock.\\n     * @param lockDuration The duration to lock the tokens for, in seconds.\\n     */\\n    function lockStakedVrsw(uint256 amount, uint128 lockDuration) external;\\n\\n    /**\\n     * @notice Allows the user to unstake VRSW tokens from the contract.\\n     * @param amount The amount of VRSW tokens to unstake.\\n     */\\n    function unstakeVrsw(uint256 amount) external;\\n\\n    /**\\n     * @notice Checks for any stake positions that are currently unlocked\\n     * @dev The unlockedPositions returned from there are invalidated after\\n     * unlockVrsw call.\\n     * @param who The address of the user to check the stake positions for\\n     * @return unlockedPositions An array of indices of the unlocked stake positions\\n     */\\n    function checkLock(\\n        address who\\n    ) external view returns (uint[] memory unlockedPositions);\\n\\n    /**\\n     * @notice Unlocks a previously locked VRSW stake position with expired lock duration.\\n     * @dev Unlocked tokens stay staked for a user.\\n     * @param who The address of the staker who owns the stake to unlock.\\n     * @param position The position of the stake to unlock.\\n     */\\n    function unlockVrsw(address who, uint256 position) external;\\n\\n    /**\\n     * @notice Manually triggers state update before a change for specified wallets\\n     * @dev Should be used in very rare cases (for example, changing global tokenomics params)\\n     * @param wallets The addresses of the users for whom state update is triggered.\\n     */\\n    function triggerStateUpdateBefore(address[] calldata wallets) external;\\n\\n    /**\\n     * @notice Manually triggers state update after a change for specified wallets\\n     * @dev Should be used in very rare cases (for example, changing global tokenomics params)\\n     * @param wallets The addresses of the users for whom state update is triggered.\\n     */\\n    function triggerStateUpdateAfter(address[] calldata wallets) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IVTokenomicsParams.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport {SD59x18} from \\\"@prb/math/src/SD59x18.sol\\\";\\n\\n/**\\n@title IVTokenomicsParams\\n@dev Interface for the tokenomics parameters.\\n\\nTo learn more about these parameters\\nyou can refer to Virtuswap Tokenomics Whitepaper.\\n\\n*/\\ninterface IVTokenomicsParams {\\n    /**\\n     * @dev Emitted when the tokenomics parameters are updated.\\n     */\\n    event UpdateTokenomicsParams(\\n        SD59x18 r,\\n        SD59x18 b,\\n        SD59x18 alpha,\\n        SD59x18 beta,\\n        SD59x18 gamma\\n    );\\n\\n    /**\\n     * @dev Emitted when the lpBaseShare and lpBaseShareFactor are updated.\\n     */\\n    event UpdateLpBaseRewardsShare(\\n        SD59x18 lpBaseRewardsShare,\\n        SD59x18 lpBaseRewardsShareFactor\\n    );\\n\\n    /**\\n     * @dev Allows the owner to update the tokenomics parameters.\\n     */\\n    function updateParams(\\n        SD59x18 _r,\\n        SD59x18 _b,\\n        SD59x18 _alpha,\\n        SD59x18 _beta,\\n        SD59x18 _gamma\\n    ) external;\\n\\n    /**\\n     * @dev Allows the owner to update the lp base rewards share parameters.\\n     */\\n    function updateLpBaseRewardsShare(\\n        SD59x18 _lpBaseRewardsShare,\\n        SD59x18 _lpBaseRewardsShareFactor\\n    ) external;\\n\\n    function r() external view returns (SD59x18);\\n\\n    function b() external view returns (SD59x18);\\n\\n    function alpha() external view returns (SD59x18);\\n\\n    function beta() external view returns (SD59x18);\\n\\n    function gamma() external view returns (SD59x18);\\n\\n    function lpBaseRewardsShare() external view returns (SD59x18);\\n\\n    function lpBaseRewardsShareFactor() external view returns (SD59x18);\\n}\\n\"\r\n    },\r\n    \"contracts/Types.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport {SD59x18} from \\\"@prb/math/src/SD59x18.sol\\\";\\n\\nstruct VrswStake {\\n    // start timestamp of the current position\\n    uint128 startTs;\\n    // lock duration of the current posisiton (0 if position is not locked)\\n    uint128 lockDuration;\\n    // discount factor for the current position equals exp(-r * stakeTime)\\n    // used in formula (3) in Virtuswap Tokenomics Whitepaper\\n    SD59x18 discountFactor;\\n    // amount of tokens staked for current position\\n    SD59x18 amount;\\n}\\n\\nstruct LpStake {\\n    // address of staked lpToken\\n    address lpToken;\\n    // amount of lpTokens staked\\n    SD59x18 amount;\\n}\\n\"\r\n    },\r\n    \"contracts/VStaker.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.18;\\n\\nimport {SD59x18, sd, unwrap, exp, UNIT, ZERO} from \\\"@prb/math/src/SD59x18.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"./Types.sol\\\";\\nimport \\\"./interfaces/IVStaker.sol\\\";\\nimport \\\"./interfaces/IVChainMinter.sol\\\";\\nimport \\\"./interfaces/IVTokenomicsParams.sol\\\";\\nimport \\\"./external/interfaces/IvPair.sol\\\";\\nimport \\\"./external/interfaces/IvPairFactory.sol\\\";\\n\\ncontract VStaker is IVStaker {\\n    // approximately 3 years limit\\n    uint256 public constant LOCK_DURATION_LIMIT = 3 * 12 * 4 weeks;\\n    // 1 staking positions for unlocked VRSW + 20 for locked VRSW\\n    uint256 public constant STAKE_POSITIONS_LIMIT = 21;\\n\\n    /**\\n     * @dev The amount of LP tokens staked by each user.\\n     * [wallet]\\n     */\\n    mapping(address => LpStake[]) public lpStakes;\\n\\n    /**\\n     * @dev The index in lpStakes array of [wallet][lpToken]\\n     */\\n    mapping(address => mapping(address => uint)) public lpStakeIndex;\\n\\n    /**\\n     * @dev The mu value of each user's LP stake. You can learn more about mu and\\n     * staking formula in Virtuswap Tokenomics Whitepaper.\\n     * [wallet][lpToken]\\n     */\\n    mapping(address => mapping(address => SD59x18)) public mu;\\n\\n    /**\\n     * @dev Accrued rewards currently available for user to withdraw for staking\\n     * specified lpToken.\\n     * [wallet][lpToken][rewardToken]\\n     */\\n    mapping(address => mapping(address => mapping(address => SD59x18)))\\n        public rewards;\\n\\n    /**\\n     * @dev The snapshot of extraRewardsCoefficintGlobal at the time of the last update.\\n     * [wallet][lpToken][rewardToken]\\n     */\\n    mapping(address => mapping(address => mapping(address => SD59x18)))\\n        public extraRewardsCoefficient;\\n\\n    /**\\n     * @dev The snapshot of baseRewardsCoefficintGlobal at the time of the last update.\\n     * [wallet][lpToken][rewardToken]\\n     */\\n    mapping(address => mapping(address => mapping(address => SD59x18)))\\n        public baseRewardsCoefficient;\\n\\n    /**\\n     * @dev The VRSW stakes of each user.\\n     * [wallet]\\n     */\\n    mapping(address => VrswStake[]) public vrswStakes;\\n\\n    /**\\n     * @dev Sum of all user's mu values for a specified lpToken.\\n     * [lpToken]\\n     */\\n    mapping(address => SD59x18) public totalMu;\\n\\n    /**\\n     * @dev Sum of all user's lp tokens staked for a specified pool.\\n     * [pool]\\n     */\\n    mapping(address => SD59x18) public totalLpStaked;\\n\\n    /**\\n     * @dev Coefficient needed to calculate accrued rewards. It's equal to:\\n     * SUM(vrswEmission(t_{i - 1}, t_{i}) / totalMu(t_i)), where t_i is the\\n     * timestamp when totalMu has changed.\\n     * [lpToken][rewardToken]\\n     */\\n    mapping(address => mapping(address => SD59x18))\\n        public extraRewardsCoefficientGlobal;\\n\\n    /**\\n     * @dev Coefficient needed to calculate accrued rewards. It's equal to:\\n     * SUM(vrswEmission(t_{i - 1}, t_{i}) / totalLpStaked(t_i)), where t_i is the\\n     * timestamp when totalMu has changed.\\n     * [lpToken][rewardToken]\\n     */\\n    mapping(address => mapping(address => SD59x18))\\n        public baseRewardsCoefficientGlobal;\\n\\n    /**\\n     * @dev The total amount of reward tokens available for distribution\\n     * for staking specified lpToken.\\n     * [lpToken][rewardToken]\\n     */\\n    mapping(address => mapping(address => SD59x18))\\n        public totalExtraRewardTokensAvailable;\\n\\n    /**\\n     * @dev The total amount of reward tokens available for distribution\\n     * for staking specified lpToken.\\n     * [lpToken][rewardToken]\\n     */\\n    mapping(address => mapping(address => SD59x18))\\n        public totalBaseRewardTokensAvailable;\\n\\n    // Virtuswap pair factory address\\n    address public immutable vPairFactory;\\n\\n    // minter address\\n    address public immutable minter;\\n\\n    // VRSW token address\\n    address public immutable vrswToken;\\n\\n    // tokenomics params address\\n    address public immutable tokenomicsParams;\\n\\n    // start of VRSW emission in seconds\\n    uint256 public immutable emissionStartTs;\\n\\n    address public immutable oldStaker;\\n\\n    mapping(address => uint256) public positionMigrationCounter;\\n\\n    modifier notBefore(uint256 timestamp) {\\n        require(block.timestamp >= timestamp, \\\"too early\\\");\\n        _;\\n    }\\n\\n    modifier validLockDuration(uint128 lockDuration) {\\n        require(\\n            lockDuration > 0 && lockDuration <= LOCK_DURATION_LIMIT,\\n            \\\"insufficient lock duration\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier positiveAmount(uint256 amount) {\\n        require(amount > 0, \\\"insufficient amount\\\");\\n        _;\\n    }\\n\\n    modifier validPool(address pool) {\\n        require(isPoolValid(pool), \\\"invalid lp token\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _vrswToken,\\n        address _minter,\\n        address _tokenomicsParams,\\n        address _vPairFactory,\\n        address _oldStaker\\n    ) {\\n        oldStaker = _oldStaker;\\n        minter = _minter;\\n        vrswToken = _vrswToken;\\n        tokenomicsParams = _tokenomicsParams;\\n        emissionStartTs = IVChainMinter(minter).emissionStartTs();\\n        vPairFactory = _vPairFactory;\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function stakeVrsw(\\n        uint256 amount\\n    ) external override notBefore(emissionStartTs) positiveAmount(amount) {\\n        if (lpStakes[msg.sender].length == 0)\\n            lpStakes[msg.sender].push(LpStake(address(0), ZERO));\\n\\n        _updateEveryStateBefore(msg.sender);\\n        VrswStake memory stake = _stakeUnlocked(msg.sender, amount);\\n        lpStakes[msg.sender][0].amount = lpStakes[msg.sender][0].amount.add(\\n            sd(int256(amount))\\n        );\\n        unchecked {\\n            totalLpStaked[address(0)] = totalLpStaked[address(0)].add(\\n                sd(int256(amount))\\n            );\\n        }\\n        _updateEveryStateAfter(msg.sender);\\n\\n        SafeERC20.safeTransferFrom(\\n            IERC20(vrswToken),\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n        IVChainMinter(minter).mintVeVrsw(msg.sender, amount);\\n        emit StakeVrsw(\\n            msg.sender,\\n            amount,\\n            stake.startTs,\\n            uint256(unwrap(stake.discountFactor))\\n        );\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function stakeLp(\\n        address lpToken,\\n        uint256 amount\\n    )\\n        external\\n        override\\n        notBefore(emissionStartTs)\\n        positiveAmount(amount)\\n        validPool(lpToken)\\n    {\\n        if (lpStakes[msg.sender].length == 0)\\n            lpStakes[msg.sender].push(LpStake(address(0), ZERO));\\n\\n        _updateStateBefore(msg.sender, lpToken);\\n        uint lpStakeIdx = lpStakeIndex[msg.sender][lpToken];\\n        if (lpStakeIdx == 0) {\\n            lpStakes[msg.sender].push(LpStake(lpToken, sd(int256(amount))));\\n            lpStakeIndex[msg.sender][lpToken] = lpStakes[msg.sender].length - 1;\\n        } else {\\n            lpStakes[msg.sender][lpStakeIdx].amount = lpStakes[msg.sender][\\n                lpStakeIdx\\n            ].amount.add(sd(int256(amount)));\\n        }\\n        unchecked {\\n            totalLpStaked[lpToken] = totalLpStaked[lpToken].add(\\n                sd(int256(amount))\\n            );\\n        }\\n        _updateStateAfter(msg.sender, lpToken);\\n\\n        SafeERC20.safeTransferFrom(\\n            IERC20(lpToken),\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n        emit StakeLp(msg.sender, lpToken, amount);\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function claimRewards(\\n        address lpToken\\n    ) external override notBefore(emissionStartTs) {\\n        _updateStateBefore(msg.sender, lpToken);\\n\\n        address[] memory rewardTokens = IVChainMinter(minter).getRewardTokens(\\n            lpToken\\n        );\\n        uint[] memory amounts = new uint[](rewardTokens.length);\\n        for (uint i = 0; i < rewardTokens.length; ++i) {\\n            amounts[i] = _calculateAccruedRewards(\\n                msg.sender,\\n                lpToken,\\n                rewardTokens[i],\\n                true\\n            );\\n            rewards[msg.sender][lpToken][rewardTokens[i]] = ZERO;\\n        }\\n        IVChainMinter(minter).transferRewards(\\n            msg.sender,\\n            lpToken,\\n            rewardTokens,\\n            amounts\\n        );\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function unstakeLp(\\n        address lpToken,\\n        uint256 amount\\n    )\\n        external\\n        override\\n        notBefore(emissionStartTs)\\n        positiveAmount(amount)\\n        validPool(lpToken)\\n    {\\n        uint lpStakeIdx = lpStakeIndex[msg.sender][lpToken];\\n        SD59x18 currentAmount = lpStakes[msg.sender][lpStakeIdx].amount;\\n        require(lpStakeIdx != 0, \\\"no such stake\\\");\\n        require(amount <= uint256(unwrap(currentAmount)), \\\"not enough tokens\\\");\\n\\n        _updateStateBefore(msg.sender, lpToken);\\n        SD59x18 newAmount = currentAmount.sub(sd(int256(amount)));\\n        lpStakes[msg.sender][lpStakeIdx].amount = newAmount;\\n        unchecked {\\n            totalLpStaked[lpToken] = totalLpStaked[lpToken].sub(\\n                sd(int256(amount))\\n            );\\n        }\\n        _updateStateAfter(msg.sender, lpToken);\\n\\n        if (unwrap(newAmount) == 0) {\\n            lpStakes[msg.sender][lpStakeIdx] = lpStakes[msg.sender][\\n                lpStakes[msg.sender].length - 1\\n            ];\\n            lpStakeIndex[msg.sender][\\n                lpStakes[msg.sender][lpStakeIdx].lpToken\\n            ] = lpStakeIdx;\\n            delete lpStakeIndex[msg.sender][lpToken];\\n            lpStakes[msg.sender].pop();\\n        }\\n\\n        SafeERC20.safeTransfer(IERC20(lpToken), msg.sender, amount);\\n\\n        emit UnstakeLp(msg.sender, lpToken, amount);\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function unstakeVrsw(\\n        uint256 amount\\n    ) external override notBefore(emissionStartTs) positiveAmount(amount) {\\n        VrswStake[] storage senderStakes = vrswStakes[msg.sender];\\n        require(senderStakes.length > 0, \\\"no stakes\\\");\\n        require(\\n            amount <= uint256(unwrap(senderStakes[0].amount)),\\n            \\\"not enough tokens\\\"\\n        );\\n\\n        _updateEveryStateBefore(msg.sender);\\n        senderStakes[0].amount = senderStakes[0].amount.sub(sd(int256(amount)));\\n        lpStakes[msg.sender][0].amount = lpStakes[msg.sender][0].amount.sub(\\n            sd(int256(amount))\\n        );\\n        unchecked {\\n            totalLpStaked[address(0)] = totalLpStaked[address(0)].sub(\\n                sd(int256(amount))\\n            );\\n        }\\n        _updateEveryStateAfter(msg.sender);\\n\\n        SafeERC20.safeTransfer(IERC20(vrswToken), msg.sender, amount);\\n        IVChainMinter(minter).burnVeVrsw(msg.sender, amount);\\n\\n        emit UnstakeVrsw(msg.sender, amount);\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function lockVrsw(\\n        uint256 amount,\\n        uint128 lockDuration\\n    )\\n        external\\n        override\\n        notBefore(emissionStartTs)\\n        validLockDuration(lockDuration)\\n        positiveAmount(amount)\\n    {\\n        VrswStake[] storage senderStakes = vrswStakes[msg.sender];\\n        require(\\n            senderStakes.length <= STAKE_POSITIONS_LIMIT,\\n            \\\"stake positions limit is exceeded\\\"\\n        );\\n        if (senderStakes.length == 0) {\\n            senderStakes.push(VrswStake(0, 0, ZERO, ZERO));\\n        }\\n        if (lpStakes[msg.sender].length == 0)\\n            lpStakes[msg.sender].push(LpStake(address(0), ZERO));\\n\\n        _updateEveryStateBefore(msg.sender);\\n        lpStakes[msg.sender][0].amount = lpStakes[msg.sender][0].amount.add(\\n            sd(int256(amount))\\n        );\\n        VrswStake memory stake = _newStakePosition(amount, lockDuration);\\n        unchecked {\\n            totalLpStaked[address(0)] = totalLpStaked[address(0)].add(\\n                sd(int256(amount))\\n            );\\n        }\\n        _updateEveryStateAfter(msg.sender);\\n\\n        SafeERC20.safeTransferFrom(\\n            IERC20(vrswToken),\\n            msg.sender,\\n            address(this),\\n            amount\\n        );\\n        IVChainMinter(minter).mintVeVrsw(msg.sender, amount);\\n        emit LockVrsw(\\n            msg.sender,\\n            amount,\\n            lockDuration,\\n            stake.startTs,\\n            uint256(unwrap(stake.discountFactor))\\n        );\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function lockStakedVrsw(\\n        uint256 amount,\\n        uint128 lockDuration\\n    )\\n        external\\n        override\\n        notBefore(emissionStartTs)\\n        validLockDuration(lockDuration)\\n        positiveAmount(amount)\\n    {\\n        VrswStake[] storage senderStakes = vrswStakes[msg.sender];\\n        require(senderStakes.length > 0, \\\"no stakes\\\");\\n        require(\\n            senderStakes.length <= STAKE_POSITIONS_LIMIT,\\n            \\\"stake positions limit is exceeded\\\"\\n        );\\n        require(\\n            amount <= uint256(unwrap(senderStakes[0].amount)),\\n            \\\"not enough tokens\\\"\\n        );\\n\\n        _updateEveryStateBefore(msg.sender);\\n        senderStakes[0].amount = senderStakes[0].amount.sub(sd(int256(amount)));\\n        VrswStake memory stake = _newStakePosition(amount, lockDuration);\\n        _updateEveryStateAfter(msg.sender);\\n        emit LockStakedVrsw(\\n            msg.sender,\\n            amount,\\n            lockDuration,\\n            stake.startTs,\\n            uint256(unwrap(stake.discountFactor))\\n        );\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function unlockVrsw(\\n        address who,\\n        uint256 position\\n    ) external override notBefore(emissionStartTs) {\\n        uint userStakesNumber = vrswStakes[who].length;\\n        require(who != address(0), \\\"zero address\\\");\\n        require(\\n            position > 0 && position < userStakesNumber,\\n            \\\"invalid position\\\"\\n        );\\n\\n        VrswStake memory userStake = vrswStakes[who][position];\\n        require(\\n            userStake.startTs + userStake.lockDuration <= block.timestamp,\\n            \\\"locked\\\"\\n        );\\n\\n        uint256 vrswToUnlock = uint256(unwrap(userStake.amount));\\n\\n        _updateEveryStateBefore(who);\\n        vrswStakes[who][position] = vrswStakes[who][userStakesNumber - 1];\\n        vrswStakes[who].pop();\\n        _stakeUnlocked(who, vrswToUnlock);\\n        _updateEveryStateAfter(who);\\n\\n        emit UnlockVrsw(who, vrswToUnlock);\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function checkLock(\\n        address who\\n    ) external view override returns (uint[] memory unlockedPositions) {\\n        VrswStake[] storage userStakes = vrswStakes[who];\\n        uint256 stakesLength = userStakes.length;\\n        uint256 unlockedPositionsNumber;\\n        for (uint256 i = 1; i < stakesLength; ++i) {\\n            if (\\n                userStakes[i].startTs + userStakes[i].lockDuration <=\\n                block.timestamp\\n            ) {\\n                ++unlockedPositionsNumber;\\n            }\\n        }\\n        unlockedPositions = new uint[](unlockedPositionsNumber);\\n        for (uint256 i = 1; i < stakesLength; ++i) {\\n            if (\\n                userStakes[i].startTs + userStakes[i].lockDuration <=\\n                block.timestamp\\n            ) {\\n                unlockedPositions[--unlockedPositionsNumber] = i;\\n            }\\n        }\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function viewRewards(\\n        address who,\\n        address lpToken,\\n        address rewardToken\\n    ) external view override returns (uint256) {\\n        return _calculateAccruedRewards(who, lpToken, rewardToken, false);\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function viewVrswStakes()\\n        external\\n        view\\n        override\\n        returns (VrswStake[] memory _vrswStakes)\\n    {\\n        _vrswStakes = vrswStakes[msg.sender];\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function viewLpStakes()\\n        external\\n        view\\n        override\\n        returns (LpStake[] memory _lpStakes)\\n    {\\n        _lpStakes = lpStakes[msg.sender];\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function triggerStateUpdateBefore(\\n        address[] calldata wallets\\n    ) public override {\\n        for (uint i = 0; i < wallets.length; ++i) {\\n            _updateEveryStateBefore(wallets[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function triggerStateUpdateAfter(\\n        address[] calldata wallets\\n    ) public override {\\n        for (uint i = 0; i < wallets.length; ++i) {\\n            _updateEveryStateAfter(wallets[i]);\\n        }\\n    }\\n\\n    /// @inheritdoc IVStaker\\n    function isPoolValid(address pool) public view override returns (bool) {\\n        (address token0, address token1) = IvPair(pool).getTokens();\\n        return IvPairFactory(vPairFactory).pairs(token0, token1) == pool;\\n    }\\n\\n    /**\\n     * @dev Adds a new stake position for the staker\\n     * @param amount Amount of VRSW tokens to stake\\n     * @param lockDuration Duration of the lock period for the stake\\n     */\\n    function _newStakePosition(\\n        uint256 amount,\\n        uint128 lockDuration\\n    ) private returns (VrswStake memory stake) {\\n        VrswStake[] storage senderStakes = vrswStakes[msg.sender];\\n        stake = VrswStake(\\n            uint128(block.timestamp),\\n            lockDuration,\\n            _calculateDiscountFactor(senderStakes.length),\\n            sd(int256(amount))\\n        );\\n        senderStakes.push(stake);\\n    }\\n\\n    /**\\n     * @dev Stakes VRSW after the lock has expired\\n     * @param who The staker address\\n     * @param amount Amount of VRSW tokens to stake\\n     */\\n    function _stakeUnlocked(\\n        address who,\\n        uint256 amount\\n    ) private returns (VrswStake memory) {\\n        VrswStake[] storage senderStakes = vrswStakes[who];\\n\\n        if (senderStakes.length == 0) {\\n            senderStakes.push(VrswStake(0, 0, ZERO, ZERO));\\n        }\\n\\n        VrswStake memory oldStake = senderStakes[0];\\n\\n        // discount factor here is calculated considering old discount factor such that\\n        // it satisfies equation: (a1 + a2) * f2 = (a1 * exp(-rt1) + a2 * exp(-rt2))\\n        // where a1 - the amount that was already staked,\\n        //       a2 - the amount that is staking,\\n        //       f1 - old discount factor,\\n        //       f2 - new discount factor,\\n        //       r  - tokenomics param,\\n        //       t1, t2 - the timestamps of old stake and new stake respectively\\n        senderStakes[0] = VrswStake(\\n            uint128(block.timestamp),\\n            0,\\n            oldStake\\n                .amount\\n                .mul(oldStake.discountFactor)\\n                .add(sd(int256(amount)).mul(_calculateDiscountFactor(0)))\\n                .div(oldStake.amount.add(sd(int256(amount)))),\\n            oldStake.amount.add(sd(int256(amount)))\\n        );\\n\\n        return senderStakes[0];\\n    }\\n\\n    /**\\n     * @dev Updates every user's state of all staked lpTokens before the update\\n     * @param who The user's address\\n     */\\n    function _updateEveryStateBefore(address who) private {\\n        uint lpStakesNumber = lpStakes[who].length;\\n        for (uint i = 0; i < lpStakesNumber; ++i) {\\n            _updateStateBefore(who, lpStakes[who][i].lpToken);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates every user's state of all staked lpTokens after the update\\n     * @param who The user's address\\n     */\\n    function _updateEveryStateAfter(address who) private {\\n        SD59x18 vrswMultiplier = _calculateVrswMultiplier(who);\\n        SD59x18 newMu;\\n        SD59x18 newTotalMu;\\n        uint lpStakesNumber = lpStakes[who].length;\\n        address lpToken;\\n        for (uint i = 0; i < lpStakesNumber; ++i) {\\n            lpToken = lpStakes[who][i].lpToken;\\n            (newMu, newTotalMu) = _calculateStateAfter(\\n                who,\\n                lpToken,\\n                vrswMultiplier\\n            );\\n            (mu[who][lpToken], totalMu[lpToken]) = (newMu, newTotalMu);\\n            emit MuChanged(\\n                who,\\n                lpToken,\\n                uint256(unwrap(newMu)),\\n                uint256(unwrap(newTotalMu))\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates the state of the user before the update\\n     * @param who The user's address\\n     */\\n    function _updateStateBefore(address who, address lpToken) private {\\n        address[] memory rewardTokens = IVChainMinter(minter).getRewardTokens(\\n            lpToken\\n        );\\n        for (uint i = 0; i < rewardTokens.length; ++i) {\\n            (\\n                totalExtraRewardTokensAvailable[lpToken][rewardTokens[i]],\\n                totalBaseRewardTokensAvailable[lpToken][rewardTokens[i]],\\n                extraRewardsCoefficient[who][lpToken][rewardTokens[i]],\\n                extraRewardsCoefficientGlobal[lpToken][rewardTokens[i]],\\n                baseRewardsCoefficient[who][lpToken][rewardTokens[i]],\\n                baseRewardsCoefficientGlobal[lpToken][rewardTokens[i]],\\n                rewards[who][lpToken][rewardTokens[i]]\\n            ) = _calculateStateBefore(who, lpToken, rewardTokens[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Updates the state of the user after the update\\n     * @param who The user's address\\n     */\\n    function _updateStateAfter(address who, address lpToken) private {\\n        SD59x18 vrswMultiplier = _calculateVrswMultiplier(who);\\n        (SD59x18 newMu, SD59x18 newTotalMu) = _calculateStateAfter(\\n            who,\\n            lpToken,\\n            vrswMultiplier\\n        );\\n        (mu[who][lpToken], totalMu[lpToken]) = (newMu, newTotalMu);\\n        emit MuChanged(\\n            who,\\n            lpToken,\\n            uint256(unwrap(newMu)),\\n            uint256(unwrap(newTotalMu))\\n        );\\n    }\\n\\n    /**\\n     * @dev Calculates the accrued rewards for the user\\n     * @param who The user's address\\n     * @param isStateChanged Whether the global state was changed before this function call\\n     * @return The amount of accrued rewards\\n     */\\n    function _calculateAccruedRewards(\\n        address who,\\n        address lpToken,\\n        address rewardToken,\\n        bool isStateChanged\\n    ) private view returns (uint256) {\\n        (, , , , , , SD59x18 _senderRewards) = isStateChanged\\n            ? (\\n                ZERO,\\n                ZERO,\\n                ZERO,\\n                ZERO,\\n                ZERO,\\n                ZERO,\\n                rewards[who][lpToken][rewardToken]\\n            )\\n            : _calculateStateBefore(who, lpToken, rewardToken);\\n        return uint256(unwrap(_senderRewards));\\n    }\\n\\n    /**\\n     * @dev Calculates the state of the user before the update\\n     * @param lpToken The staked lpToken address\\n     * @param who The staker address\\n     */\\n    function _calculateStateBefore(\\n        address who,\\n        address lpToken,\\n        address rewardToken\\n    )\\n        private\\n        view\\n        returns (\\n            SD59x18 _totalExtraRewardTokensAvailable,\\n            SD59x18 _totalBaseRewardTokensAvailable,\\n            SD59x18 _senderExtraRewardsCoefficient,\\n            SD59x18 _extraRewardsCoefficientGlobal,\\n            SD59x18 _senderBaseRewardsCoefficient,\\n            SD59x18 _baseRewardsCoefficientGlobal,\\n            SD59x18 _senderRewards\\n        )\\n    {\\n        _senderRewards = rewards[who][lpToken][rewardToken];\\n\\n        SD59x18 _totalRewardTokensAvailable = sd(\\n            int256(\\n                uint256(\\n                    IVChainMinter(minter).calculateTokensForPool(\\n                        lpToken,\\n                        rewardToken\\n                    )\\n                )\\n            )\\n        );\\n\\n        SD59x18 lpBaseRewardsShare = IVTokenomicsParams(tokenomicsParams)\\n            .lpBaseRewardsShare();\\n        SD59x18 lpBaseRewardsShareFactor = IVTokenomicsParams(tokenomicsParams)\\n            .lpBaseRewardsShareFactor();\\n\\n        if (unwrap(totalMu[lpToken]) != 0) {\\n            SD59x18 rewardTokensDiff = _totalRewardTokensAvailable.sub(\\n                totalExtraRewardTokensAvailable[lpToken][rewardToken]\\n            );\\n            SD59x18 extraRewards = rewardTokensDiff\\n                .mul(lpBaseRewardsShareFactor.sub(lpBaseRewardsShare))\\n                .div(lpBaseRewardsShareFactor);\\n            _totalExtraRewardTokensAvailable = _totalRewardTokensAvailable;\\n            _extraRewardsCoefficientGlobal = extraRewardsCoefficientGlobal[\\n                lpToken\\n            ][rewardToken].add(extraRewards.div(totalMu[lpToken]));\\n            _senderExtraRewardsCoefficient = _extraRewardsCoefficientGlobal;\\n            // you can learn more about the formula in Virtuswap Tokenomics Whitepaper\\n            _senderRewards = _senderRewards.add(\\n                mu[who][lpToken].mul(\\n                    _extraRewardsCoefficientGlobal.sub(\\n                        extraRewardsCoefficient[who][lpToken][rewardToken]\\n                    )\\n                )\\n            );\\n        } else {\\n            (\\n                _totalExtraRewardTokensAvailable,\\n                _senderExtraRewardsCoefficient,\\n                _extraRewardsCoefficientGlobal\\n            ) = (\\n                totalExtraRewardTokensAvailable[lpToken][rewardToken],\\n                extraRewardsCoefficient[who][lpToken][rewardToken],\\n                extraRewardsCoefficientGlobal[lpToken][rewardToken]\\n            );\\n        }\\n        if (unwrap(totalLpStaked[lpToken]) != 0) {\\n            SD59x18 rewardTokensDiff = _totalRewardTokensAvailable.sub(\\n                totalBaseRewardTokensAvailable[lpToken][rewardToken]\\n            );\\n            SD59x18 baseRewards = rewardTokensDiff.mul(lpBaseRewardsShare).div(\\n                lpBaseRewardsShareFactor\\n            );\\n            _totalBaseRewardTokensAvailable = _totalRewardTokensAvailable;\\n            _baseRewardsCoefficientGlobal = baseRewardsCoefficientGlobal[\\n                lpToken\\n            ][rewardToken].add(baseRewards.div(totalLpStaked[lpToken]));\\n            _senderBaseRewardsCoefficient = _baseRewardsCoefficientGlobal;\\n            if (\\n                (lpToken == address(0) || lpStakeIndex[who][lpToken] != 0) &&\\n                lpStakes[who].length > 0\\n            ) {\\n                _senderRewards = _senderRewards.add(\\n                    lpStakes[who][lpStakeIndex[who][lpToken]].amount.mul(\\n                        _baseRewardsCoefficientGlobal.sub(\\n                            baseRewardsCoefficient[who][lpToken][rewardToken]\\n                        )\\n                    )\\n                );\\n            }\\n        } else {\\n            (\\n                _totalBaseRewardTokensAvailable,\\n                _senderBaseRewardsCoefficient,\\n                _baseRewardsCoefficientGlobal\\n            ) = (\\n                totalBaseRewardTokensAvailable[lpToken][rewardToken],\\n                baseRewardsCoefficient[who][lpToken][rewardToken],\\n                baseRewardsCoefficientGlobal[lpToken][rewardToken]\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates VRSW multiplier of the user\\n     * @param who The staker address\\n     */\\n    function _calculateVrswMultiplier(\\n        address who\\n    ) private view returns (SD59x18 mult) {\\n        VrswStake[] storage senderStakes = vrswStakes[who];\\n        uint256 stakesLength = senderStakes.length;\\n        for (uint256 i = 0; i < stakesLength; ++i) {\\n            mult = mult.add(\\n                senderStakes[i].amount.mul(senderStakes[i].discountFactor).mul(\\n                    UNIT.add(\\n                        IVTokenomicsParams(tokenomicsParams).b().mul(\\n                            sd(\\n                                int256(uint256(senderStakes[i].lockDuration)) *\\n                                    1e18\\n                            ).pow(IVTokenomicsParams(tokenomicsParams).gamma())\\n                        )\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Calculates the state of the user before the update\\n     * @param lpToken The staked lpToken address\\n     * @param who The staker address\\n     * @param vrswMultiplier The VRSW multiplier\\n     */\\n    function _calculateStateAfter(\\n        address who,\\n        address lpToken,\\n        SD59x18 vrswMultiplier\\n    ) private view returns (SD59x18 _mu, SD59x18 _totalMu) {\\n        _mu = lpStakes[who][lpStakeIndex[who][lpToken]]\\n            .amount\\n            .pow(IVTokenomicsParams(tokenomicsParams).alpha())\\n            .mul(\\n                vrswMultiplier.pow(IVTokenomicsParams(tokenomicsParams).beta())\\n            );\\n        unchecked {\\n            _totalMu = totalMu[lpToken].add(_mu.sub(mu[who][lpToken]));\\n        }\\n    }\\n\\n    function _calculateDiscountFactor(\\n        uint256 position\\n    ) private returns (SD59x18) {\\n        if (position == 0 || positionMigrationCounter[msg.sender] < position) {\\n            (bool success, bytes memory result) = oldStaker.staticcall(\\n                abi.encodeWithSignature(\\n                    \\\"vrswStakes(address,uint256)\\\",\\n                    msg.sender,\\n                    position\\n                )\\n            );\\n            if (success) {\\n                VrswStake memory oldVrswStake = abi.decode(result, (VrswStake));\\n                if (position > 0) {\\n                    ++positionMigrationCounter[msg.sender];\\n                    return oldVrswStake.discountFactor;\\n                } else if (\\n                    unwrap(oldVrswStake.amount) > 0 &&\\n                    unwrap(vrswStakes[msg.sender][0].discountFactor) == 0\\n                ) {\\n                    return oldVrswStake.discountFactor;\\n                }\\n            }\\n        }\\n        return\\n            exp(\\n                IVTokenomicsParams(tokenomicsParams).r().mul(\\n                    sd(-int256(block.timestamp - emissionStartTs) * 1e18)\\n                )\\n            );\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vrswToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenomicsParams\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vPairFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oldStaker\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PRBMathSD59x18__DivInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"SD59x18\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"SD59x18\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__DivOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"SD59x18\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__Exp2InputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"SD59x18\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__ExpInputTooBig\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"SD59x18\",\"name\":\"x\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__LogInputTooSmall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PRBMathSD59x18__MulInputTooSmall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"SD59x18\",\"name\":\"x\",\"type\":\"int256\"},{\"internalType\":\"SD59x18\",\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"PRBMathSD59x18__MulOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDiv18Overflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"x\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"y\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"PRBMath__MulDivOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lockDuration\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"startTs\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discountFactor\",\"type\":\"uint256\"}],\"name\":\"LockStakedVrsw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"lockDuration\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"startTs\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discountFactor\",\"type\":\"uint256\"}],\"name\":\"LockVrsw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mu\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalMu\",\"type\":\"uint256\"}],\"name\":\"MuChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"StakeLp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"startTs\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discountFactor\",\"type\":\"uint256\"}],\"name\":\"StakeVrsw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnlockVrsw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeLp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"UnstakeVrsw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LOCK_DURATION_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STAKE_POSITIONS_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"baseRewardsCoefficient\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"baseRewardsCoefficientGlobal\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"checkLock\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"unlockedPositions\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"}],\"name\":\"claimRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emissionStartTs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"extraRewardsCoefficient\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"extraRewardsCoefficientGlobal\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"isPoolValid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"lockDuration\",\"type\":\"uint128\"}],\"name\":\"lockStakedVrsw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"lockDuration\",\"type\":\"uint128\"}],\"name\":\"lockVrsw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"lpStakeIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lpStakes\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"SD59x18\",\"name\":\"amount\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"mu\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldStaker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"positionMigrationCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"rewards\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"stakeVrsw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenomicsParams\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBaseRewardTokensAvailable\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalExtraRewardTokensAvailable\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalLpStaked\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalMu\",\"outputs\":[{\"internalType\":\"SD59x18\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"triggerStateUpdateAfter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"wallets\",\"type\":\"address[]\"}],\"name\":\"triggerStateUpdateBefore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"position\",\"type\":\"uint256\"}],\"name\":\"unlockVrsw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeLp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"unstakeVrsw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vPairFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewLpStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"SD59x18\",\"name\":\"amount\",\"type\":\"int256\"}],\"internalType\":\"struct LpStake[]\",\"name\":\"_lpStakes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"}],\"name\":\"viewRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewVrswStakes\",\"outputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"startTs\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lockDuration\",\"type\":\"uint128\"},{\"internalType\":\"SD59x18\",\"name\":\"discountFactor\",\"type\":\"int256\"},{\"internalType\":\"SD59x18\",\"name\":\"amount\",\"type\":\"int256\"}],\"internalType\":\"struct VrswStake[]\",\"name\":\"_vrswStakes\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vrswStakes\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"startTs\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"lockDuration\",\"type\":\"uint128\"},{\"internalType\":\"SD59x18\",\"name\":\"discountFactor\",\"type\":\"int256\"},{\"internalType\":\"SD59x18\",\"name\":\"amount\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vrswToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "VStaker", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "000000000000000000000000a70de8592cd98edc01988d68b5b5bb3cc593fe88000000000000000000000000ddb2cc23e4bc634a2ba8391c1d12ef53543ae9c40000000000000000000000008b8f5b6872a31cc3ae1a3fd12d67e4851793f405000000000000000000000000161bceef7fb69d8f4d3dc55693d22ab33f791d7b0000000000000000000000006c2dba00f8b7308f475dc9525054a02228ac4d21", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}