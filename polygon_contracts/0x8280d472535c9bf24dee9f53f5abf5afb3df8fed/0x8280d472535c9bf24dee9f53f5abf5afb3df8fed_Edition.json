{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"lib/nft-editions/contracts/Edition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\n/**\\n * \u2588\u2584\u2591\u2588\u2003\u2588\u2580\u2580\u2003\u2580\u2588\u2580\u2003 \u2003\u2588\u2580\u2580\u2003\u2588\u2580\u2584\u2003\u2588\u2003\u2580\u2588\u2580\u2003\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2584\u2591\u2588\u2003\u2588\u2580\\n * \u2588\u2591\u2580\u2588\u2003\u2588\u2580\u2591\u2003\u2591\u2588\u2591\u2003 \u2003\u2588\u2588\u2584\u2003\u2588\u2584\u2580\u2003\u2588\u2003\u2591\u2588\u2591\u2003\u2588\u2003\u2588\u2584\u2588\u2003\u2588\u2591\u2580\u2588\u2003\u2584\u2588\\n *\\n * \u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2588\u2580\u2588\u2003\u2584\u2580\u2588\\n * \u2588\u2584\u2003\u2588\u2584\u2588\u2003\u2588\u2580\u2584\u2003\u2588\u2580\u2588\\n */\\n\\npragma solidity ^0.8.6;\\n\\nimport {\\n    IERC2981Upgradeable,\\n    IERC165Upgradeable\\n} from \\\"@openzeppelin-contracts-upgradeable/interfaces/IERC2981Upgradeable.sol\\\";\\nimport {AddressUpgradeable} from \\\"@openzeppelin-contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\n\\nimport {ERC721, ERC721I} from \\\"./solmate-initializable/tokens/ERC721I.sol\\\";\\nimport {OwnedInitializable} from \\\"./solmate-initializable/auth/OwnedInitializable.sol\\\";\\n\\nimport {EditionMetadataRenderer} from \\\"./EditionMetadataRenderer.sol\\\";\\nimport {IEdition} from \\\"./interfaces/IEdition.sol\\\";\\nimport {OptionalOperatorFilterer} from \\\"./utils/OptionalOperatorFilterer.sol\\\";\\n\\nimport \\\"./interfaces/Errors.sol\\\";\\n\\n/// @notice This is a smart contract for handling dynamic contract minting.\\n/// @dev This allows creators to mint a unique serial edition of the same media within a custom contract\\n/// @dev This is a fork of ZORA Editions for Showtime Drops\\n/// @author karmacoma [Showtime Drops](https://github.com/showtime-xyz/nft-editions)\\n/// @author iain nash [ZORA Editions](https://github.com/ourzora/nft-editions)\\ncontract Edition is\\n    EditionMetadataRenderer,\\n    ERC721I,\\n    IEdition,\\n    IERC2981Upgradeable,\\n    OwnedInitializable,\\n    OptionalOperatorFilterer\\n{\\n    struct EditionState {\\n        // how many tokens have been minted (can not be more than editionSize)\\n        uint64 numberMinted;\\n        // reserved space to keep the state a uint256\\n        uint16 __reserved;\\n        // Price to mint in twei (1 twei = 1000 gwei), so the supported price range is 0.000001 to 4294.967295 ETH\\n        // To accept ERC20 or a different price range, use a specialized sales contract as the approved minter\\n        uint32 salePriceTwei;\\n        // Royalty amount in bps (uint16 is large enough to store 10000 bps)\\n        uint16 royaltyBPS;\\n        // the edition can be minted up to this timestamp in seconds -- 0 means no end date\\n        uint64 endOfMintPeriod;\\n        // Total size of edition that can be minted\\n        uint64 editionSize;\\n    }\\n\\n    EditionState private state;\\n\\n    // Addresses allowed to mint edition\\n    mapping(address => bool) allowedMinters;\\n\\n    /// @notice Function to create a new edition. Can only be called by the allowed creator\\n    ///         Sets the only allowed minter to the address that creates/owns the edition.\\n    ///         This can be re-assigned or updated later\\n    /// @param _owner User that owns and can mint the edition, gets royalty and sales payouts and can update the base url if needed.\\n    /// @param _name Name of edition, used in the title as \\\"$NAME NUMBER/TOTAL\\\"\\n    /// @param _symbol Symbol of the new token contract\\n    /// @param _description Description of edition, used in the description field of the NFT\\n    /// @param _imageUrl Image URL of the edition. Strongly encouraged to be used, but if necessary, only animation URL can be used. One of animation and image url need to exist in a edition to render the NFT.\\n    /// @param _animationUrl Animation URL of the edition. Not required, but if omitted image URL needs to be included. This follows the opensea spec for NFTs\\n    /// @param _editionSize Number of editions that can be minted in total. If 0, unlimited editions can be minted.\\n    /// @param _royaltyBPS BPS of the royalty set on the contract. Can be 0 for no royalty.\\n    /// @param _mintPeriodSeconds The amount of time in seconds after which editions can no longer be minted or purchased. Use 0 to have no expiration\\n    function initialize(\\n        address _owner,\\n        string calldata _name,\\n        string calldata _symbol,\\n        string calldata _description,\\n        string calldata _animationUrl,\\n        string calldata _imageUrl,\\n        uint256 _editionSize,\\n        uint256 _royaltyBPS,\\n        uint256 _mintPeriodSeconds\\n    ) public override initializer {\\n        __ERC721_init(_name, _symbol);\\n\\n        // Set ownership to original sender of contract call\\n        __Owned_init(_owner);\\n\\n        description = _description;\\n        animationUrl = _animationUrl;\\n        imageUrl = _imageUrl;\\n\\n        uint64 _endOfMintPeriod;\\n        if (_mintPeriodSeconds > 0) {\\n            // overflows are not expected to happen for timestamps, and have no security implications\\n            unchecked {\\n                uint256 endOfMintPeriodUint256 = block.timestamp + _mintPeriodSeconds;\\n                _endOfMintPeriod = requireUint64(endOfMintPeriodUint256);\\n            }\\n        }\\n\\n        state = EditionState({\\n            editionSize: requireUint64(_editionSize),\\n            endOfMintPeriod: _endOfMintPeriod,\\n            royaltyBPS: requireUint16(_royaltyBPS),\\n            salePriceTwei: 0,\\n            numberMinted: 0,\\n            __reserved: 0\\n        });\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      OPERATOR FILTERER OVERRIDES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\\n        super.transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override onlyAllowedOperator(from) {\\n        super.safeTransferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data)\\n        public\\n        override\\n        onlyAllowedOperator(from)\\n    {\\n        super.safeTransferFrom(from, to, tokenId, data);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                  CREATOR / COLLECTION OWNER FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice This sets a simple ETH sales price\\n    /// Setting a sales price allows users to mint the edition until it sells out.\\n    /// The supported price range is 0.000001 to 4294.967295 ETH (or relevant chain gas token)\\n    /// For more granular sales, use an external sales contract.\\n    /// @param _salePriceWei sale price in wei, 0 to disable sales\\n    function setSalePrice(uint256 _salePriceWei) external override onlyOwner {\\n        // convert to milli-eth internally\\n        uint32 salePriceTwei = requireUint32(_salePriceWei / 1e12);\\n        if (salePriceTwei == 0 && _salePriceWei > 0) {\\n            revert PriceTooLow();\\n        }\\n\\n        state.salePriceTwei = salePriceTwei;\\n        emit PriceChanged(_salePriceWei);\\n    }\\n\\n    /// @dev This withdraws ETH from the contract to the contract owner.\\n    function withdraw() external override onlyOwner {\\n        // No need for gas limit to trusted address.\\n        AddressUpgradeable.sendValue(payable(owner), address(this).balance);\\n    }\\n\\n    /// @notice Sets the approved minting status of the given address.\\n    /// @param minter address to set approved minting status for\\n    /// @param allowed boolean if that address is allowed to mint\\n    /// @dev This requires that msg.sender is the owner of the given edition id.\\n    /// @dev If the ZeroAddress (address(0x0)) is set as a minter, anyone will be allowed to mint.\\n    /// @dev This setup is similar to setApprovalForAll in the ERC721 spec.\\n    function setApprovedMinter(address minter, bool allowed) public override onlyOwner {\\n        allowedMinters[minter] = allowed;\\n    }\\n\\n    /// @notice Updates the external_url field in the metadata\\n    function setExternalUrl(string calldata _externalUrl) public override onlyOwner {\\n        emit ExternalUrlUpdated(externalUrl, _externalUrl);\\n\\n        externalUrl = _externalUrl;\\n    }\\n\\n    function setStringProperties(string[] calldata names, string[] calldata values) public override onlyOwner {\\n        uint256 length = names.length;\\n        if (values.length != length) {\\n            revert LengthMismatch();\\n        }\\n\\n        namesOfStringProperties = names;\\n        for (uint256 i = 0; i < length;) {\\n            string calldata name = names[i];\\n            string calldata value = values[i];\\n            if (bytes(name).length == 0 || bytes(value).length == 0) {\\n                revert BadAttribute(name, value);\\n            }\\n\\n            emit PropertyUpdated(name, stringProperties[name], value);\\n\\n            stringProperties[name] = value;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function setOperatorFilter(address operatorFilter) public override onlyOwner {\\n        _setOperatorFilter(operatorFilter);\\n    }\\n\\n    function enableDefaultOperatorFilter() public override onlyOwner {\\n        _setOperatorFilter(CANONICAL_OPENSEA_SUBSCRIPTION);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                   COLLECTOR / TOKEN OWNER FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @param to address to send the newly minted edition to\\n    /// @dev This mints one edition to the given address by an allowed minter\\n    function mint(address to) external payable override returns (uint256 tokenId) {\\n        tokenId = _mintPreFlightChecks(1);\\n        _mint(to, tokenId);\\n    }\\n\\n    function safeMint(address to) external payable override returns (uint256 tokenId) {\\n        tokenId = _mintPreFlightChecks(1);\\n        _safeMint(to, tokenId);\\n    }\\n\\n    /// @param recipients list of addresses to send the newly minted editions to\\n    /// @dev This mints multiple editions to the given list of addresses.\\n    function mintBatch(address[] calldata recipients) external payable override returns (uint256 lastTokenId) {\\n        uint64 n = uint64(recipients.length);\\n        if (n == 0) {\\n            revert InvalidArgument();\\n        }\\n\\n        lastTokenId = _mintPreFlightChecks(n);\\n\\n        unchecked {\\n            uint256 firstTokenId = lastTokenId + 1 - n;\\n            for (uint256 i = 0; i < n;) {\\n                _safeMint(recipients[i], firstTokenId + i);\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function requireUint16(uint256 value) internal pure returns (uint16) {\\n        if (value > uint256(type(uint16).max)) {\\n            revert IntegerOverflow(value);\\n        }\\n        return uint16(value);\\n    }\\n\\n    function requireUint32(uint256 value) internal pure returns (uint32) {\\n        if (value > uint256(type(uint32).max)) {\\n            revert IntegerOverflow(value);\\n        }\\n        return uint32(value);\\n    }\\n\\n    function requireUint64(uint256 value) internal pure returns (uint64) {\\n        if (value > uint256(type(uint64).max)) {\\n            revert IntegerOverflow(value);\\n        }\\n        return uint64(value);\\n    }\\n\\n    /// @dev stateless version of isMintingEnded\\n    function enforceTimeLimit(uint64 _endOfMintPeriod) internal view {\\n        if (_endOfMintPeriod > 0 && uint64(block.timestamp) > _endOfMintPeriod) {\\n            revert TimeLimitReached();\\n        }\\n    }\\n\\n    function enforceSupplyLimit(uint64 _editionSize, uint64 _numberMinted) internal pure {\\n        if (_editionSize > 0 && _numberMinted > _editionSize) {\\n            revert SoldOut();\\n        }\\n    }\\n\\n    function enforceSalePrice(uint256 _salePriceTwei, uint256 quantity) internal view {\\n        unchecked {\\n            if (msg.value != quantity * _salePriceTwei * 1e12) {\\n                revert WrongPrice();\\n            }\\n        }\\n    }\\n\\n    /// @dev This helper function checks if the msg.sender is allowed to mint\\n    function _isAllowedToMint() internal view returns (bool) {\\n        // optimize by likelihood:\\n        // 1. check allowlist/minter contracts\\n        // 2. open mints\\n        // 3. owner mints\\n        return allowedMinters[msg.sender] || allowedMinters[address(0x0)] || owner == msg.sender;\\n    }\\n\\n    /// @dev Validates the supply and time limits for minting with a single SLOAD and SSTORE\\n    function _mintPreFlightChecks(uint256 quantity) internal returns (uint64 _tokenId) {\\n        if (!_isAllowedToMint()) {\\n            revert Unauthorized();\\n        }\\n\\n        uint256 _state;\\n        uint256 _postState;\\n        uint64 _editionSize;\\n        uint64 _endOfMintPeriod;\\n        uint32 _salePriceTwei;\\n\\n        assembly (\\\"memory-safe\\\") {\\n            _state := sload(state.slot)\\n            _editionSize := shr(192, _state)\\n            _endOfMintPeriod := shr(128, _state)\\n            _salePriceTwei := shr(80, _state)\\n\\n            // can not realistically overflow\\n            // the fields in EditionState are ordered so that incrementing state increments numberMinted\\n            _postState := add(_state, quantity)\\n\\n            // perform the addition only once and extract numberMinted + 1 from _postState\\n            _tokenId := and(_postState, 0xffffffffffffffff)\\n        }\\n\\n        enforceSupplyLimit(_editionSize, _tokenId);\\n        enforceTimeLimit(_endOfMintPeriod);\\n        enforceSalePrice(_salePriceTwei, quantity);\\n\\n        // update storage\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(state.slot, _postState)\\n        }\\n\\n        return _tokenId;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                           METADATA FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function editionSize() external view override returns (uint256) {\\n        return state.editionSize;\\n    }\\n\\n    /// @dev Returns the sale price in wei\\n    function salePrice() public view override returns (uint256) {\\n        unchecked {\\n            // can not overflow\\n            return uint256(state.salePriceTwei) * 1e12;\\n        }\\n    }\\n\\n    /// Returns the timestamp when the minting period ends, or 0 if there is no time limit\\n    function endOfMintPeriod() public view override returns (uint256) {\\n        return state.endOfMintPeriod;\\n    }\\n\\n    /// Returns whether the edition can still be minted/purchased\\n    function isMintingEnded() public view override returns (bool) {\\n        uint256 _endOfMintPeriod = state.endOfMintPeriod;\\n        return _endOfMintPeriod > 0 && uint64(block.timestamp) > _endOfMintPeriod;\\n    }\\n\\n    function totalSupply() public view override returns (uint256) {\\n        return state.numberMinted;\\n    }\\n\\n    /// @notice Get the base64-encoded json metadata for a token\\n    /// @param tokenId the token id to get the metadata for\\n    /// @return base64-encoded json metadata object\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_ownerOf[tokenId] != address(0), \\\"No token\\\");\\n\\n        return createTokenMetadata(name, tokenId, state.editionSize);\\n    }\\n\\n    /// @notice Get the base64-encoded json metadata object for the edition\\n    function contractURI() public view override returns (string memory) {\\n        return createContractMetadata(name, state.royaltyBPS, owner);\\n    }\\n\\n    /// @notice Get royalty information for token\\n    /// @param _salePrice Sale price for the token\\n    function royaltyInfo(uint256, uint256 _salePrice)\\n        external\\n        view\\n        override\\n        returns (address receiver, uint256 royaltyAmount)\\n    {\\n        if (owner == address(0x0)) {\\n            return (address(0x0), 0);\\n        }\\n        return (owner, (_salePrice * state.royaltyBPS) / 10_000);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) public view override (ERC721, IERC165Upgradeable) returns (bool) {\\n        return type(IERC2981Upgradeable).interfaceId == interfaceId || ERC721.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/EditionMetadataRenderer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\n\\npragma solidity ^0.8.6;\\n\\nimport {Base64} from \\\"./utils/Base64.sol\\\";\\nimport {LibString} from \\\"./utils/LibString.sol\\\";\\n\\nimport {EditionMetadataState} from \\\"./EditionMetadataState.sol\\\";\\n\\n/// logic for rendering metadata associated with editions\\ncontract EditionMetadataRenderer is EditionMetadataState {\\n    /// Generate edition metadata from storage information as base64-json blob\\n    /// Combines the media data and metadata\\n    /// @param name Name of NFT in metadata\\n    /// @param tokenId Token ID for specific token\\n    /// @param editionSize Size of entire edition to show\\n    function createTokenMetadata(\\n        string memory name,\\n        uint256 tokenId,\\n        uint256 editionSize\\n    ) internal view returns (string memory) {\\n        return\\n            toBase64DataUrl(\\n                createTokenMetadataJson(name, tokenId, editionSize)\\n            );\\n    }\\n\\n    /// Function to create the metadata json string for the nft edition\\n    /// @param name Name of NFT in metadata\\n    /// @param tokenId Token ID for specific token\\n    /// @param editionSize Size of entire edition to show\\n    function createTokenMetadataJson(\\n        string memory name,\\n        uint256 tokenId,\\n        uint256 editionSize\\n    ) internal view returns (string memory) {\\n        string memory editionSizeText;\\n        if (editionSize > 0) {\\n            editionSizeText = string.concat(\\n                \\\"/\\\",\\n                LibString.toString(editionSize)\\n            );\\n        }\\n\\n        string memory externalURLText = \\\"\\\";\\n        if (bytes(externalUrl).length > 0) {\\n            externalURLText = string.concat('\\\",\\\"external_url\\\":\\\"', externalUrl);\\n        }\\n\\n        string memory mediaData = tokenMediaData(imageUrl, animationUrl);\\n\\n        return\\n            string.concat(\\n                '{\\\"name\\\":\\\"',\\n                LibString.escapeJSON(name),\\n                \\\" #\\\",\\n                LibString.toString(tokenId),\\n                editionSizeText,\\n                '\\\",\\\"',\\n                'description\\\":\\\"',\\n                LibString.escapeJSON(description),\\n                externalURLText,\\n                '\\\"',\\n                mediaData,\\n                getPropertiesJson(),\\n                \\\"}\\\"\\n            );\\n    }\\n\\n    /// Encodes contract level metadata into base64-data url format\\n    /// @dev see https://docs.opensea.io/docs/contract-level-metadata\\n    /// @dev borrowed from https://github.com/ourzora/zora-drops-contracts/blob/main/src/utils/NFTMetadataRenderer.sol\\n    function createContractMetadata(\\n        string memory name,\\n        uint256 royaltyBPS,\\n        address royaltyRecipient\\n    ) internal view returns (string memory) {\\n        string memory imageSpace = \\\"\\\";\\n        if (bytes(imageUrl).length > 0) {\\n            imageSpace = string.concat('\\\",\\\"image\\\":\\\"', imageUrl);\\n        }\\n\\n        string memory externalURLSpace = \\\"\\\";\\n        if (bytes(externalUrl).length > 0) {\\n            externalURLSpace = string.concat(\\n                '\\\",\\\"external_link\\\":\\\"',\\n                externalUrl\\n            );\\n        }\\n\\n        return\\n            toBase64DataUrl(\\n                string.concat(\\n                    '{\\\"name\\\":\\\"',\\n                    LibString.escapeJSON(name),\\n                    '\\\",\\\"description\\\":\\\"',\\n                    LibString.escapeJSON(description),\\n                    // this is for opensea since they don't respect ERC2981 right now\\n                    '\\\",\\\"seller_fee_basis_points\\\":',\\n                    LibString.toString(royaltyBPS),\\n                    ',\\\"fee_recipient\\\":\\\"',\\n                    LibString.toHexString(royaltyRecipient),\\n                    imageSpace,\\n                    externalURLSpace,\\n                    '\\\"}'\\n                )\\n            );\\n    }\\n\\n    /// Encodes the argument json bytes into base64-data uri format\\n    /// @param json Raw json to base64 and turn into a data-uri\\n    function toBase64DataUrl(string memory json)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        return\\n            string.concat(\\n                \\\"data:application/json;base64,\\\",\\n                Base64.encode(bytes(json))\\n            );\\n    }\\n\\n    function tokenMediaData(string memory imageUrl, string memory animationUrl)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        bool hasImage = bytes(imageUrl).length > 0;\\n        bool hasAnimation = bytes(animationUrl).length > 0;\\n        string memory buffer = \\\"\\\";\\n\\n        if (hasImage) {\\n            buffer = string.concat(',\\\"image\\\":\\\"', imageUrl, '\\\"');\\n        }\\n\\n        if (hasAnimation) {\\n            buffer = string.concat(\\n                buffer,\\n                ',\\\"animation_url\\\":\\\"',\\n                animationUrl,\\n                '\\\"'\\n            );\\n        }\\n\\n        return buffer;\\n    }\\n\\n    /// Produces Enjin Metadata style simple properties\\n    /// @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1155.md#erc-1155-metadata-uri-json-schema\\n    function getPropertiesJson() internal view returns (string memory) {\\n        uint256 length = namesOfStringProperties.length;\\n        if (length == 0) {\\n            return ',\\\"properties\\\":{}';\\n        }\\n\\n        string memory buffer = ',\\\"properties\\\":{';\\n\\n        unchecked {\\n            // `length - 1` can not underflow because of the `length == 0` check above\\n            uint256 lengthMinusOne = length - 1;\\n\\n            for (uint256 i = 0; i < lengthMinusOne; ) {\\n                string storage _name = namesOfStringProperties[i];\\n                string storage _value = stringProperties[_name];\\n\\n                buffer = string.concat(\\n                    buffer,\\n                    stringifyStringAttribute(_name, _value),\\n                    \\\",\\\"\\n                );\\n\\n                // counter increment can not overflow\\n                ++i;\\n            }\\n\\n            // add the last attribute without a trailing comma\\n            string storage lastName = namesOfStringProperties[lengthMinusOne];\\n            buffer = string.concat(\\n                buffer,\\n                stringifyStringAttribute(lastName, stringProperties[lastName])\\n            );\\n        }\\n\\n        buffer = string.concat(buffer, \\\"}\\\");\\n\\n        return buffer;\\n    }\\n\\n    function stringifyStringAttribute(string storage name, string storage value)\\n        internal\\n        pure\\n        returns (string memory)\\n    {\\n        // let's only escape the value, property names should not be using any special characters\\n        return\\n            string.concat('\\\"', name, '\\\":\\\"', LibString.escapeJSON(value), '\\\"');\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/EditionMetadataState.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\ncontract EditionMetadataState {\\n    string public description;\\n\\n    // Media Urls\\n    // animation_url field in the metadata\\n    string public animationUrl;\\n\\n    // Image in the metadata\\n    string public imageUrl;\\n\\n    // URL that will appear below the asset's image on OpenSea\\n    string public externalUrl;\\n\\n    string[] internal namesOfStringProperties;\\n\\n    mapping(string => string) internal stringProperties;\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/interfaces/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\nerror BadAttribute(string name, string value);\\nerror IntegerOverflow(uint256 value);\\nerror InvalidArgument();\\nerror LengthMismatch();\\nerror NotForSale();\\nerror OperatorNotAllowed(address operator);\\nerror PriceTooLow();\\nerror SoldOut();\\nerror TimeLimitReached();\\nerror Unauthorized();\\nerror WrongPrice();\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/interfaces/IEdition.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\ninterface IEdition {\\n    event PriceChanged(uint256 amount);\\n    event ExternalUrlUpdated(string oldExternalUrl, string newExternalUrl);\\n    event PropertyUpdated(string name, string oldValue, string newValue);\\n\\n    function contractURI() external view returns (string memory);\\n\\n    function editionSize() external view returns (uint256);\\n\\n    function initialize(\\n        address _owner,\\n        string memory _name,\\n        string memory _symbol,\\n        string memory _description,\\n        string memory _animationUrl,\\n        string memory _imageUrl,\\n        uint256 _editionSize,\\n        uint256 _royaltyBPS,\\n        uint256 _mintPeriodSeconds\\n    ) external;\\n\\n    function enableDefaultOperatorFilter() external;\\n\\n    function endOfMintPeriod() external view returns (uint256);\\n\\n    function isMintingEnded() external view returns (bool);\\n\\n    function mint(address to) external payable returns (uint256);\\n\\n    function safeMint(address to) external payable returns (uint256);\\n\\n    function mintBatch(address[] memory recipients) external payable returns (uint256);\\n\\n    function salePrice() external view returns (uint256);\\n\\n    function setApprovedMinter(address minter, bool allowed) external;\\n\\n    function setExternalUrl(string calldata _externalUrl) external;\\n\\n    function setOperatorFilter(address operatorFilter) external;\\n\\n    function setStringProperties(string[] calldata names, string[] calldata values) external;\\n\\n    function setSalePrice(uint256 _salePrice) external;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function withdraw() external;\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/solmate-initializable/auth/OwnedInitializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {Initializable} from \\\"../utils/Initializable.sol\\\";\\n\\n/// @notice Simple single owner authorization mixin.\\n/// @author karmacoma (replaced constructor with initializer)\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/auth/Owned.sol)\\nabstract contract OwnedInitializable is Initializable {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event OwnershipTransferred(address indexed user, address indexed newOwner);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            OWNERSHIP STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    address public owner;\\n\\n    modifier onlyOwner() virtual {\\n        require(msg.sender == owner, \\\"UNAUTHORIZED\\\");\\n\\n        _;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              INITIALIZER\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function __Owned_init(address _owner) internal onlyInitializing {\\n        owner = _owner;\\n\\n        emit OwnershipTransferred(address(0), _owner);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             OWNERSHIP LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        owner = newOwner;\\n\\n        emit OwnershipTransferred(msg.sender, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/solmate-initializable/tokens/ERC721I.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {Initializable} from \\\"../utils/Initializable.sol\\\";\\n\\nimport {ERC721} from \\\"solmate/tokens/ERC721.sol\\\";\\nimport {ERC721TokenReceiver} from \\\"./ERC721TokenReceiver.sol\\\";\\n\\n/// @notice Initializable version of Solmate's ERC721\\nabstract contract ERC721I is ERC721, Initializable {\\n    /*//////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor() ERC721(\\\"\\\", \\\"\\\") {\\n        _lockInitializers();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              INITIALIZER\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function __ERC721_init(string memory _name, string memory _symbol)\\n        internal\\n        onlyInitializing\\n    {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/solmate-initializable/tokens/ERC721TokenReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/solmate-initializable/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient Initializable implementation with no reinitializers\\n/// @dev warning: this contract is not compatible with OpenZeppelin's Initializable\\n/// @dev warning: this should be considered very experimental\\n/// @author karmacoma\\nabstract contract Initializable {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Initialized();\\n\\n    /*//////////////////////////////////////////////////////////////\\n                                STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    enum InitState {\\n        NOT_INITIALIZED,\\n        INITIALIZING,\\n        INITIALIZED\\n    }\\n\\n    InitState private _initState;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                          INITIALIZABLE LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    modifier initializer() {\\n        bool isTopLevelCall = _initState == InitState.NOT_INITIALIZED;\\n\\n        require(\\n            (isTopLevelCall) || (_initState == InitState.INITIALIZING),\\n            \\\"ALREADY_INITIALIZED\\\"\\n        );\\n        if (isTopLevelCall) {\\n            _initState = InitState.INITIALIZING;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initState = InitState.INITIALIZED;\\n            emit Initialized();\\n        }\\n    }\\n\\n    modifier onlyInitializing() {\\n        require(_initState == InitState.INITIALIZING, \\\"NOT_INITIALIZING\\\");\\n        _;\\n    }\\n\\n    /// locks the contract, preventing any further initialization\\n    function _lockInitializers() internal virtual {\\n        require(\\n            _initState == InitState.NOT_INITIALIZED,\\n            \\\"MUST_BE_NOT_INITIALIZED\\\"\\n        );\\n        _initState = InitState.INITIALIZED;\\n        emit Initialized();\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/utils/Base64.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library to encode strings in Base64.\\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Base64.sol) @ 41d29ed\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/Base64.sol)\\n/// @author Modified from (https://github.com/Brechtpd/base64/blob/main/base64.sol) by Brecht Devos - <brecht@loopring.org>.\\nlibrary Base64 {\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// See: https://datatracker.ietf.org/doc/html/rfc4648\\n    /// @param fileSafe  Whether to replace '+' with '-' and '/' with '_'.\\n    /// @param noPadding Whether to strip away the padding.\\n    function encode(\\n        bytes memory data,\\n        bool fileSafe,\\n        bool noPadding\\n    ) internal pure returns (string memory result) {\\n        assembly (\\\"memory-safe\\\") {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                // Multiply by 4/3 rounded up.\\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\\n\\n                // Set `result` to point to the start of the free memory.\\n                result := mload(0x40)\\n\\n                // Store the table into the scratch space.\\n                // Offsetted by -1 byte so that the `mload` will load the character.\\n                // We will rewrite the free memory pointer at `0x40` later with\\n                // the allocated size.\\n                // The magic constant 0x0230 will translate \\\"-_\\\" + \\\"+/\\\".\\n                mstore(0x1f, \\\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\\\")\\n                mstore(\\n                    0x3f,\\n                    sub(\\n                        \\\"ghijklmnopqrstuvwxyz0123456789-_\\\",\\n                        mul(iszero(fileSafe), 0x0230)\\n                    )\\n                )\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n                let end := add(ptr, encodedLength)\\n\\n                // Run over the input, 3 bytes at a time.\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    data := add(data, 3) // Advance 3 bytes.\\n                    let input := mload(data)\\n\\n                    // Write 4 bytes. Optimized for fewer stack operations.\\n                    mstore8(    ptr    , mload(and(shr(18, input), 0x3F)))\\n                    mstore8(add(ptr, 1), mload(and(shr(12, input), 0x3F)))\\n                    mstore8(add(ptr, 2), mload(and(shr( 6, input), 0x3F)))\\n                    mstore8(add(ptr, 3), mload(and(        input , 0x3F)))\\n\\n                    ptr := add(ptr, 4) // Advance 4 bytes.\\n                    // prettier-ignore\\n                    if iszero(lt(ptr, end)) { break }\\n                }\\n\\n                let r := mod(dataLength, 3)\\n\\n                switch noPadding\\n                case 0 {\\n                    // Offset `ptr` and pad with '='. We can simply write over the end.\\n                    mstore8(sub(ptr, iszero(iszero(r))), 0x3d) // Pad at `ptr - 1` if `r > 0`.\\n                    mstore8(sub(ptr, shl(1, eq(r, 1))), 0x3d) // Pad at `ptr - 2` if `r == 1`.\\n                    // Write the length of the string.\\n                    mstore(result, encodedLength)\\n                }\\n                default {\\n                    // Write the length of the string.\\n                    mstore(\\n                        result,\\n                        sub(encodedLength, add(iszero(iszero(r)), eq(r, 1)))\\n                    )\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(end, 31), not(31)))\\n            }\\n        }\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, false, false)`.\\n    function encode(bytes memory data)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, false, false);\\n    }\\n\\n    /// @dev Encodes `data` using the base64 encoding described in RFC 4648.\\n    /// Equivalent to `encode(data, fileSafe, false)`.\\n    function encode(bytes memory data, bool fileSafe)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = encode(data, fileSafe, false);\\n    }\\n\\n    /// @dev Encodes base64 encoded `data`.\\n    ///\\n    /// Supports:\\n    /// - RFC 4648 (both standard and file-safe mode).\\n    /// - RFC 3501 (63: ',').\\n    ///\\n    /// Does not support:\\n    /// - Line breaks.\\n    ///\\n    /// Note: For performance reasons,\\n    /// this function will NOT revert on invalid `data` inputs.\\n    /// Outputs for invalid inputs will simply be undefined behaviour.\\n    /// It is the user's responsibility to ensure that the `data`\\n    /// is a valid base64 encoded string.\\n    function decode(string memory data)\\n        internal\\n        pure\\n        returns (bytes memory result)\\n    {\\n        assembly {\\n            let dataLength := mload(data)\\n\\n            if dataLength {\\n                let end := add(data, dataLength)\\n                let decodedLength := mul(shr(2, dataLength), 3)\\n\\n                switch and(dataLength, 3)\\n                case 0 {\\n                    // If padded.\\n                    decodedLength := sub(\\n                        decodedLength,\\n                        add(\\n                            eq(and(mload(end), 0xFF), 0x3d),\\n                            eq(and(mload(end), 0xFFFF), 0x3d3d)\\n                        )\\n                    )\\n                }\\n                default {\\n                    // If non-padded.\\n                    decodedLength := add(\\n                        decodedLength,\\n                        sub(and(dataLength, 3), 1)\\n                    )\\n                }\\n\\n                result := mload(0x40)\\n\\n                // Write the length of the string.\\n                mstore(result, decodedLength)\\n\\n                // Skip the first slot, which stores the length.\\n                let ptr := add(result, 0x20)\\n\\n                // Load the table into the scratch space.\\n                // Constants are optimized for smaller bytecode with zero gas overhead.\\n                // `m` also doubles as the mask of the upper 6 bits.\\n                let\\n                    m\\n                := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\\n                mstore(0x5b, m)\\n                mstore(\\n                    0x3b,\\n                    0x04080c1014181c2024282c3034383c4044484c5054585c6064\\n                )\\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\\n\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Read 4 bytes.\\n                    data := add(data, 4)\\n                    let input := mload(data)\\n\\n                    // Write 3 bytes.\\n                    mstore(ptr, or(\\n                        and(m, mload(byte(28, input))),\\n                        shr(6, or(\\n                            and(m, mload(byte(29, input))),\\n                            shr(6, or(\\n                                and(m, mload(byte(30, input))),\\n                                shr(6, mload(byte(31, input)))\\n                            ))\\n                        ))\\n                    ))\\n\\n                    ptr := add(ptr, 3)\\n\\n                    // prettier-ignore\\n                    if iszero(lt(data, end)) { break }\\n                }\\n\\n                // Allocate the memory for the string.\\n                // Add 32 + 31 and mask with `not(31)` to round the\\n                // free memory pointer up the next multiple of 32.\\n                mstore(0x40, and(add(add(result, decodedLength), 63), not(31)))\\n\\n                // Restore the zero slot.\\n                mstore(0x60, 0)\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/utils/LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Library for converting numbers into strings and other string operations.\\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/LibString.sol) @ 016c4ac\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)\\nlibrary LibString {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                        CUSTOM ERRORS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The `length` of the output is too small to contain all the hex digits.\\n    error HexLengthInsufficient();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The constant returned when the `search` is not found in the string.\\n    uint256 internal constant NOT_FOUND = uint256(int256(-1));\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                     DECIMAL OPERATIONS                     */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the base 10 decimal representation of `value`.\\n    function toString(uint256 value) internal pure returns (string memory str) {\\n        assembly (\\\"memory-safe\\\") {\\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\\n            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.\\n            let m := add(mload(0x40), 0xa0)\\n            // Update the free memory pointer to allocate.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end of the memory to calculate the length later.\\n            let end := str\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 1)\\n                // Write the character to the pointer.\\n                // The ASCII index of the '0' character is 48.\\n                mstore8(str, add(48, mod(temp, 10)))\\n                // Keep dividing `temp` until zero.\\n                temp := div(temp, 10)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            let length := sub(end, str)\\n            // Move the pointer 32 bytes leftwards to make room for the length.\\n            str := sub(str, 0x20)\\n            // Store the length.\\n            mstore(str, length)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   HEXADECIMAL OPERATIONS                   */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns the hexadecimal representation of `value`,\\n    /// left-padded to an input length of `length` bytes.\\n    /// The output is prefixed with \\\"0x\\\" encoded using 2 hexadecimal digits per byte,\\n    /// giving a total length of `length * 2 + 2` bytes.\\n    /// Reverts if `length` is too small for the output to contain all the digits.\\n    function toHexString(uint256 value, uint256 length)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, `length * 2` bytes\\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\\n            // We add 0x20 to the total and round down to a multiple of 0x20.\\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\\n            let m := add(start, and(add(shl(1, length), 0x62), not(0x1f)))\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let temp := value\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for {} 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                // prettier-ignore\\n                if iszero(length) { break }\\n            }\\n\\n            if temp {\\n                // Store the function selector of `HexLengthInsufficient()`.\\n                mstore(0x00, 0x2194895a)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := add(sub(end, str), 2)\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 0x20)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    /// As address are 20 bytes long, the output will left-padded to have\\n    /// a length of `20 * 2 + 2` bytes.\\n    function toHexString(uint256 value)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        assembly {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\\n            let m := add(start, 0xa0)\\n            // Allocate the memory.\\n            mstore(0x40, m)\\n            // Assign the `str` to the end.\\n            str := sub(m, 0x20)\\n            // Zeroize the slot after the string.\\n            mstore(str, 0)\\n\\n            // Cache the end to calculate the length later.\\n            let end := str\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                // prettier-ignore\\n                if iszero(temp) { break }\\n            }\\n\\n            // Compute the string's length.\\n            let strLength := add(sub(end, str), 2)\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 0x20)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, strLength)\\n        }\\n    }\\n\\n    /// @dev Returns the hexadecimal representation of `value`.\\n    /// The output is prefixed with \\\"0x\\\" and encoded using 2 hexadecimal digits per byte.\\n    function toHexString(address value)\\n        internal\\n        pure\\n        returns (string memory str)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            let start := mload(0x40)\\n            // We need 0x20 bytes for the length, 0x02 bytes for the prefix,\\n            // and 0x28 bytes for the digits.\\n            // The next multiple of 0x20 above (0x20 + 0x02 + 0x28) is 0x60.\\n            str := add(start, 0x60)\\n\\n            // Allocate the memory.\\n            mstore(0x40, str)\\n            // Store \\\"0123456789abcdef\\\" in scratch space.\\n            mstore(0x0f, 0x30313233343536373839616263646566)\\n\\n            let length := 20\\n            // We write the string from rightmost digit to leftmost digit.\\n            // The following is essentially a do-while loop that also handles the zero case.\\n            // prettier-ignore\\n            for { let temp := value } 1 {} {\\n                str := sub(str, 2)\\n                mstore8(add(str, 1), mload(and(temp, 15)))\\n                mstore8(str, mload(and(shr(4, temp), 15)))\\n                temp := shr(8, temp)\\n                length := sub(length, 1)\\n                // prettier-ignore\\n                if iszero(length) { break }\\n            }\\n\\n            // Move the pointer and write the \\\"0x\\\" prefix.\\n            str := sub(str, 32)\\n            mstore(str, 0x3078)\\n            // Move the pointer and write the length.\\n            str := sub(str, 2)\\n            mstore(str, 42)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   OTHER STRING OPERATIONS                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    // For performance and bytecode compactness, all indices of the following operations\\n    // are byte (ASCII) offsets, not UTF character offsets.\\n\\n    /// @dev Returns `subject` all occurances of `search` replaced with `replacement`.\\n    function replace(\\n        string memory subject,\\n        string memory search,\\n        string memory replacement\\n    ) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n            let replacementLength := mload(replacement)\\n\\n            subject := add(subject, 0x20)\\n            search := add(search, 0x20)\\n            replacement := add(replacement, 0x20)\\n            result := add(mload(0x40), 0x20)\\n\\n            let subjectEnd := add(subject, subjectLength)\\n            if iszero(gt(searchLength, subjectLength)) {\\n                let subjectSearchEnd := add(sub(subjectEnd, searchLength), 1)\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) {\\n                    h := keccak256(search, searchLength)\\n                }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                mstore(result, t)\\n                                result := add(result, 1)\\n                                subject := add(subject, 1)\\n                                // prettier-ignore\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Copy the `replacement` one word at a time.\\n                        // prettier-ignore\\n                        for { let o := 0 } 1 {} {\\n                            mstore(add(result, o), mload(add(replacement, o)))\\n                            o := add(o, 0x20)\\n                            // prettier-ignore\\n                            if iszero(lt(o, replacementLength)) { break }\\n                        }\\n                        result := add(result, replacementLength)\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            // prettier-ignore\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    mstore(result, t)\\n                    result := add(result, 1)\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n            }\\n\\n            let resultRemainder := result\\n            result := add(mload(0x40), 0x20)\\n            let k := add(sub(resultRemainder, result), sub(subjectEnd, subject))\\n            // Copy the rest of the string one word at a time.\\n            // prettier-ignore\\n            for {} lt(subject, subjectEnd) {} {\\n                mstore(resultRemainder, mload(subject))\\n                resultRemainder := add(resultRemainder, 0x20)\\n                subject := add(subject, 0x20)\\n            }\\n            result := sub(result, 0x20)\\n            // Zeroize the slot after the string.\\n            let last := add(add(result, 0x20), k)\\n            mstore(last, 0)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n            // Store the length of the result.\\n            mstore(result, k)\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(\\n        string memory subject,\\n        string memory search,\\n        uint256 from\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            // prettier-ignore\\n            for { let subjectLength := mload(subject) } 1 {} {\\n                if iszero(mload(search)) {\\n                    // `result = min(from, subjectLength)`.\\n                    result := xor(from, mul(xor(from, subjectLength), lt(subjectLength, from)))\\n                    break\\n                }\\n                let searchLength := mload(search)\\n                let subjectStart := add(subject, 0x20)\\n\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                subject := add(subjectStart, from)\\n                let subjectSearchEnd := add(sub(add(subjectStart, subjectLength), searchLength), 1)\\n\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(add(search, 0x20))\\n\\n                // prettier-ignore\\n                if iszero(lt(subject, subjectSearchEnd)) { break }\\n\\n                if iszero(lt(searchLength, 32)) {\\n                    // prettier-ignore\\n                    for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                        if iszero(shr(m, xor(mload(subject), s))) {\\n                            if eq(keccak256(subject, searchLength), h) {\\n                                result := sub(subject, subjectStart)\\n                                break\\n                            }\\n                        }\\n                        subject := add(subject, 1)\\n                        // prettier-ignore\\n                        if iszero(lt(subject, subjectSearchEnd)) { break }\\n                    }\\n                    break\\n                }\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    if iszero(shr(m, xor(mload(subject), s))) {\\n                        result := sub(subject, subjectStart)\\n                        break\\n                    }\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from left to right.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function indexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = indexOf(subject, search, 0);\\n    }\\n\\n    /// @dev Returns the byte index of the first location of `search` in `subject`,\\n    /// searching from right to left, starting from `from`.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(\\n        string memory subject,\\n        string memory search,\\n        uint256 from\\n    ) internal pure returns (uint256 result) {\\n        assembly {\\n            // prettier-ignore\\n            for {} 1 {} {\\n                let searchLength := mload(search)\\n                let fromMax := sub(mload(subject), searchLength)\\n                if iszero(gt(fromMax, from)) {\\n                    from := fromMax\\n                }\\n                if iszero(mload(search)) {\\n                    result := from\\n                    break\\n                }\\n                result := not(0) // Initialize to `NOT_FOUND`.\\n\\n                let subjectSearchEnd := sub(add(subject, 0x20), 1)\\n\\n                subject := add(add(subject, 0x20), from)\\n                // prettier-ignore\\n                if iszero(gt(subject, subjectSearchEnd)) { break }\\n                // As this function is not too often used,\\n                // we shall simply use keccak256 for smaller bytecode size.\\n                // prettier-ignore\\n                for { let h := keccak256(add(search, 0x20), searchLength) } 1 {} {\\n                    if eq(keccak256(subject, searchLength), h) {\\n                        result := sub(subject, add(subjectSearchEnd, 1))\\n                        break\\n                    }\\n                    subject := sub(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(gt(subject, subjectSearchEnd)) { break }\\n                }\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the index of the first location of `search` in `subject`,\\n    /// searching from right to left.\\n    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `search` is not found.\\n    function lastIndexOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256 result)\\n    {\\n        result = lastIndexOf(subject, search, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns whether `subject` starts with `search`.\\n    function startsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        assembly {\\n            let searchLength := mload(search)\\n            // Just using keccak256 directly is actually cheaper.\\n            result := and(\\n                iszero(gt(searchLength, mload(subject))),\\n                eq(\\n                    keccak256(add(subject, 0x20), searchLength),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns whether `subject` ends with `search`.\\n    function endsWith(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (bool result)\\n    {\\n        assembly {\\n            let searchLength := mload(search)\\n            let subjectLength := mload(subject)\\n            // Whether `search` is not longer than `subject`.\\n            let withinRange := iszero(gt(searchLength, subjectLength))\\n            // Just using keccak256 directly is actually cheaper.\\n            result := and(\\n                withinRange,\\n                eq(\\n                    keccak256(\\n                        // `subject + 0x20 + max(subjectLength - searchLength, 0)`.\\n                        add(\\n                            add(subject, 0x20),\\n                            mul(withinRange, sub(subjectLength, searchLength))\\n                        ),\\n                        searchLength\\n                    ),\\n                    keccak256(add(search, 0x20), searchLength)\\n                )\\n            )\\n        }\\n    }\\n\\n    /// @dev Returns `subject` repeated `times`.\\n    function repeat(string memory subject, uint256 times)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(or(iszero(times), iszero(subjectLength))) {\\n                subject := add(subject, 0x20)\\n                result := mload(0x40)\\n                let output := add(result, 0x20)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    // Copy the `subject` one word at a time.\\n                    // prettier-ignore\\n                    for { let o := 0 } 1 {} {\\n                        mstore(add(output, o), mload(add(subject, o)))\\n                        o := add(o, 0x20)\\n                        // prettier-ignore\\n                        if iszero(lt(o, subjectLength)) { break }\\n                    }\\n                    output := add(output, subjectLength)\\n                    times := sub(times, 1)\\n                    // prettier-ignore\\n                    if iszero(times) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(output, 0)\\n                // Store the length.\\n                let resultLength := sub(output, add(result, 0x20))\\n                mstore(result, resultLength)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to `end` (exclusive).\\n    /// `start` and `end` are byte offsets.\\n    function slice(\\n        string memory subject,\\n        uint256 start,\\n        uint256 end\\n    ) internal pure returns (string memory result) {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            if iszero(gt(subjectLength, end)) {\\n                end := subjectLength\\n            }\\n            if iszero(gt(subjectLength, start)) {\\n                start := subjectLength\\n            }\\n            if lt(start, end) {\\n                result := mload(0x40)\\n                let resultLength := sub(end, start)\\n                mstore(result, resultLength)\\n                subject := add(subject, start)\\n                // Copy the `subject` one word at a time, backwards.\\n                // prettier-ignore\\n                for { let o := and(add(resultLength, 31), not(31)) } 1 {} {\\n                    mstore(add(result, o), mload(add(subject, o)))\\n                    o := sub(o, 0x20)\\n                    // prettier-ignore\\n                    if iszero(o) { break }\\n                }\\n                // Zeroize the slot after the string.\\n                mstore(add(add(result, 0x20), resultLength), 0)\\n                // Allocate memory for the length and the bytes,\\n                // rounded up to a multiple of 32.\\n                mstore(0x40, add(result, and(add(resultLength, 63), not(31))))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a copy of `subject` sliced from `start` to the end of the string.\\n    /// `start` is a byte offset.\\n    function slice(string memory subject, uint256 start)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        result = slice(subject, start, uint256(int256(-1)));\\n    }\\n\\n    /// @dev Returns all the indices of `search` in `subject`.\\n    /// The indices are byte offsets.\\n    function indicesOf(string memory subject, string memory search)\\n        internal\\n        pure\\n        returns (uint256[] memory result)\\n    {\\n        assembly {\\n            let subjectLength := mload(subject)\\n            let searchLength := mload(search)\\n\\n            if iszero(gt(searchLength, subjectLength)) {\\n                subject := add(subject, 0x20)\\n                search := add(search, 0x20)\\n                result := add(mload(0x40), 0x20)\\n\\n                let subjectStart := subject\\n                let subjectSearchEnd := add(\\n                    sub(add(subject, subjectLength), searchLength),\\n                    1\\n                )\\n                let h := 0\\n                if iszero(lt(searchLength, 32)) {\\n                    h := keccak256(search, searchLength)\\n                }\\n                let m := shl(3, sub(32, and(searchLength, 31)))\\n                let s := mload(search)\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let t := mload(subject)\\n                    // Whether the first `searchLength % 32` bytes of\\n                    // `subject` and `search` matches.\\n                    if iszero(shr(m, xor(t, s))) {\\n                        if h {\\n                            if iszero(eq(keccak256(subject, searchLength), h)) {\\n                                subject := add(subject, 1)\\n                                // prettier-ignore\\n                                if iszero(lt(subject, subjectSearchEnd)) { break }\\n                                continue\\n                            }\\n                        }\\n                        // Append to `result`.\\n                        mstore(result, sub(subject, subjectStart))\\n                        result := add(result, 0x20)\\n                        // Advance `subject` by `searchLength`.\\n                        subject := add(subject, searchLength)\\n                        if searchLength {\\n                            // prettier-ignore\\n                            if iszero(lt(subject, subjectSearchEnd)) { break }\\n                            continue\\n                        }\\n                    }\\n                    subject := add(subject, 1)\\n                    // prettier-ignore\\n                    if iszero(lt(subject, subjectSearchEnd)) { break }\\n                }\\n                let resultEnd := result\\n                // Assign `result` to the free memory pointer.\\n                result := mload(0x40)\\n                // Store the length of `result`.\\n                mstore(result, shr(5, sub(resultEnd, add(result, 0x20))))\\n                // Allocate memory for result.\\n                // We allocate one more word, so this array can be recycled for {split}.\\n                mstore(0x40, add(resultEnd, 0x20))\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a arrays of strings based on the `delimiter` inside of the `subject` string.\\n    function split(string memory subject, string memory delimiter)\\n        internal\\n        pure\\n        returns (string[] memory result)\\n    {\\n        uint256[] memory indices = indicesOf(subject, delimiter);\\n        assembly {\\n            if mload(indices) {\\n                let indexPtr := add(indices, 0x20)\\n                let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\\n                mstore(sub(indicesEnd, 0x20), mload(subject))\\n                mstore(indices, add(mload(indices), 1))\\n                let prevIndex := 0\\n                // prettier-ignore\\n                for {} 1 {} {\\n                    let index := mload(indexPtr)\\n                    mstore(indexPtr, 0x60)\\n                    if iszero(eq(index, prevIndex)) {\\n                        let element := mload(0x40)\\n                        let elementLength := sub(index, prevIndex)\\n                        mstore(element, elementLength)\\n                        // Copy the `subject` one word at a time, backwards.\\n                        // prettier-ignore\\n                        for { let o := and(add(elementLength, 31), not(31)) } 1 {} {\\n                            mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\\n                            o := sub(o, 0x20)\\n                            // prettier-ignore\\n                            if iszero(o) { break }\\n                        }\\n                        // Zeroize the slot after the string.\\n                        mstore(add(add(element, 0x20), elementLength), 0)\\n                        // Allocate memory for the length and the bytes,\\n                        // rounded up to a multiple of 32.\\n                        mstore(0x40, add(element, and(add(elementLength, 63), not(31))))\\n                        // Store the `element` into the array.\\n                        mstore(indexPtr, element)\\n                    }\\n                    prevIndex := add(index, mload(delimiter))\\n                    indexPtr := add(indexPtr, 0x20)\\n                    // prettier-ignore\\n                    if iszero(lt(indexPtr, indicesEnd)) { break }\\n                }\\n                result := indices\\n                if iszero(mload(delimiter)) {\\n                    result := add(indices, 0x20)\\n                    mstore(result, sub(mload(indices), 2))\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns a concatenated string of `a` and `b`.\\n    /// Cheaper than `string.concat()` and does not de-align the free memory pointer.\\n    function concat(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            result := mload(0x40)\\n            let aLength := mload(a)\\n            // Copy `a` one word at a time, backwards.\\n            // prettier-ignore\\n            for { let o := and(add(mload(a), 32), not(31)) } 1 {} {\\n                mstore(add(result, o), mload(add(a, o)))\\n                o := sub(o, 0x20)\\n                // prettier-ignore\\n                if iszero(o) { break }\\n            }\\n            let bLength := mload(b)\\n            let output := add(result, mload(a))\\n            // Copy `b` one word at a time, backwards.\\n            // prettier-ignore\\n            for { let o := and(add(bLength, 32), not(31)) } 1 {} {\\n                mstore(add(output, o), mload(add(b, o)))\\n                o := sub(o, 0x20)\\n                // prettier-ignore\\n                if iszero(o) { break }\\n            }\\n            let totalLength := add(aLength, bLength)\\n            let last := add(add(result, 0x20), totalLength)\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Stores the length.\\n            mstore(result, totalLength)\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n        }\\n    }\\n\\n    /// @dev Escapes the string to be used within double-quotes in a JSON.\\n    function escapeJSON(string memory s)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        assembly (\\\"memory-safe\\\") {\\n            // prettier-ignore\\n            for {\\n                let end := add(s, mload(s))\\n                result := add(mload(0x40), 0x20)\\n                // Store \\\"\\\\\\\\u0000\\\" in scratch space.\\n                // Store \\\"0123456789abcdef\\\" in scratch space.\\n                // Also, store `{0x08:\\\"b\\\", 0x09:\\\"t\\\", 0x0a:\\\"n\\\", 0x0c:\\\"f\\\", 0x0d:\\\"r\\\"}`.\\n                // into the scratch space.\\n                mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\\n                // Bitmask for detecting `[\\\"\\\\\\\"\\\", \\\"\\\\\\\\\\\"]`.\\n                let e := or(shl(0x22, 1), shl(0x5c, 1))\\n            } iszero(eq(s, end)) {} {\\n                s := add(s, 1)\\n                let c := and(mload(s), 0xff)\\n                if iszero(lt(c, 0x20)) {\\n                    if iszero(and(shl(c, 1), e)) { // Not in `[\\\"\\\\\\\"\\\",\\\"\\\\\\\\\\\"]`.\\n                        mstore8(result, c)\\n                        result := add(result, 1)\\n                        continue\\n                    }\\n                    mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                    mstore8(add(result, 1), c)\\n                    result := add(result, 2)\\n                    continue\\n                }\\n                if iszero(and(shl(c, 1), 0x3700)) { // Not in `[\\\"\\\\b\\\",\\\"\\\\t\\\",\\\"\\\\n\\\",\\\"\\\\f\\\",\\\"\\\\d\\\"]`.\\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\\n                    mstore(result, mload(0x19)) // \\\"\\\\\\\\u00XX\\\".\\n                    result := add(result, 6)\\n                    continue\\n                }\\n                mstore8(result, 0x5c) // \\\"\\\\\\\\\\\".\\n                mstore8(add(result, 1), mload(add(c, 8)))\\n                result := add(result, 2)\\n            }\\n            let last := result\\n            // Zeroize the slot after the string.\\n            mstore(last, 0)\\n            // Restore the result to the start of the free memory.\\n            result := mload(0x40)\\n            // Store the length of the result.\\n            mstore(result, sub(last, add(result, 0x20)))\\n            // Allocate memory for the length and the bytes,\\n            // rounded up to a multiple of 32.\\n            mstore(0x40, and(add(last, 31), not(31)))\\n        }\\n    }\\n\\n    /// @dev Packs a single string with its length into a single word.\\n    /// Returns `bytes32(0)` if the length is zero or greater than 31.\\n    function packOne(string memory a) internal pure returns (bytes32 result) {\\n        assembly {\\n            // We don't need to zero right pad the string,\\n            // since this is our own custom non-standard packing scheme.\\n            result := mul(\\n                // Load the length and the bytes.\\n                mload(add(a, 0x1f)),\\n                // `length != 0 && length < 32`. Abuses underflow.\\n                // Assumes that the length is valid and within the block gas limit.\\n                lt(sub(mload(a), 1), 0x1f)\\n            )\\n        }\\n    }\\n\\n    /// @dev Unpacks a string packed using {packOne}.\\n    /// Returns the empty string if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packOne}, the output behaviour is undefined.\\n    function unpackOne(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory result)\\n    {\\n        assembly {\\n            // Grab the free memory pointer.\\n            result := mload(0x40)\\n            // Allocate 2 words (1 for the length, 1 for the bytes).\\n            mstore(0x40, add(result, 0x40))\\n            // Zeroize the length slot.\\n            mstore(result, 0)\\n            // Store the length and bytes.\\n            mstore(add(result, 0x1f), packed)\\n            // Right pad with zeroes.\\n            mstore(add(add(result, 0x20), mload(result)), 0)\\n        }\\n    }\\n\\n    /// @dev Packs two strings with their lengths into a single word.\\n    /// Returns `bytes32(0)` if combined length is zero or greater than 30.\\n    function packTwo(string memory a, string memory b)\\n        internal\\n        pure\\n        returns (bytes32 result)\\n    {\\n        assembly {\\n            let aLength := mload(a)\\n            // We don't need to zero right pad the strings,\\n            // since this is our own custom non-standard packing scheme.\\n            result := mul(\\n                // Load the length and the bytes of `a` and `b`.\\n                or(\\n                    shl(shl(3, sub(0x1f, aLength)), mload(add(a, aLength))),\\n                    mload(sub(add(b, 0x1e), aLength))\\n                ),\\n                // `totalLength != 0 && totalLength < 31`. Abuses underflow.\\n                // Assumes that the lengths are valid and within the block gas limit.\\n                lt(sub(add(aLength, mload(b)), 1), 0x1e)\\n            )\\n        }\\n    }\\n\\n    /// @dev Unpacks strings packed using {packTwo}.\\n    /// Returns the empty strings if `packed` is `bytes32(0)`.\\n    /// If `packed` is not an output of {packTwo}, the output behaviour is undefined.\\n    function unpackTwo(bytes32 packed)\\n        internal\\n        pure\\n        returns (string memory resultA, string memory resultB)\\n    {\\n        assembly {\\n            // Grab the free memory pointer.\\n            resultA := mload(0x40)\\n            resultB := add(resultA, 0x40)\\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\\n            mstore(0x40, add(resultB, 0x40))\\n            // Zeroize the length slots.\\n            mstore(resultA, 0)\\n            mstore(resultB, 0)\\n            // Store the lengths and bytes.\\n            mstore(add(resultA, 0x1f), packed)\\n            mstore(\\n                add(resultB, 0x1f),\\n                mload(add(add(resultA, 0x20), mload(resultA)))\\n            )\\n            // Right pad with zeroes.\\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\\n        }\\n    }\\n\\n    /// @dev Directly returns `a` without copying.\\n    function directReturn(string memory a) internal pure {\\n        assembly {\\n            // Right pad with zeroes. Just in case the string is produced\\n            // by a method that doesn't zero right pad.\\n            mstore(add(add(a, 0x20), mload(a)), 0)\\n            // Store the return offset.\\n            // Assumes that the string does not start from the scratch space.\\n            mstore(sub(a, 0x20), 0x20)\\n            // End the transaction, returning the string.\\n            return(sub(a, 0x20), add(mload(a), 0x40))\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/contracts/utils/OptionalOperatorFilterer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.6;\\n\\nimport { IOperatorFilterRegistry } from \\\"operator-filter-registry/IOperatorFilterRegistry.sol\\\";\\n\\nimport { OperatorNotAllowed } from \\\"../interfaces/Errors.sol\\\";\\n\\n/// Less aggro than DefaultOperatorFilterer, it does not automatically register and subscribe to the default filter\\n/// Instead, this is off by default, opt-in, and relies only on view functions (no register call)\\nabstract contract OptionalOperatorFilterer {\\n    address public constant CANONICAL_OPENSEA_SUBSCRIPTION = address(0x3cc6CddA760b79bAfa08dF41ECFA224f810dCeB6);\\n    address public constant CANONICAL_OPENSEA_REGISTRY = address(0x000000000000AAeB6D7670E522A718067333cd4E);\\n\\n    address public activeOperatorFilter = address(0);\\n\\n    event OperatorFilterChanged(address indexed operatorFilter);\\n\\n    /// Set to CANONICAL_OPENSEA_SUBSCRIPTION to use the default OpenSea operator filter\\n    /// Set to address(0) to disable operator filtering\\n    function _setOperatorFilter(address operatorFilter) internal {\\n        activeOperatorFilter = operatorFilter;\\n        emit OperatorFilterChanged(operatorFilter);\\n    }\\n\\n    /// @dev modified from operator-filter-registry/OperatorFilterer.sol\\n    modifier onlyAllowedOperator(address from) virtual {\\n        // Allow spending tokens from addresses with balance\\n        // Note that this still allows listings and marketplaces with escrow to transfer tokens if transferred\\n        // from an EOA.\\n        if (from != msg.sender) {\\n            _checkFilterOperator(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    /// @dev modified from operator-filter-registry/OperatorFilterer.sol\\n    function _checkFilterOperator(address operator) internal view {\\n        if (activeOperatorFilter == address(0)) {\\n            return;\\n        }\\n\\n        // Check registry code length to facilitate testing in environments without a deployed registry.\\n        if (CANONICAL_OPENSEA_REGISTRY.code.length == 0) {\\n            return;\\n        }\\n\\n        if (!IOperatorFilterRegistry(CANONICAL_OPENSEA_REGISTRY).isOperatorAllowed(activeOperatorFilter, operator)) {\\n            revert OperatorNotAllowed(operator);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/lib/operator-filter-registry/src/IOperatorFilterRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IOperatorFilterRegistry {\\n    function isOperatorAllowed(address registrant, address operator) external view returns (bool);\\n    function register(address registrant) external;\\n    function registerAndSubscribe(address registrant, address subscription) external;\\n    function registerAndCopyEntries(address registrant, address registrantToCopy) external;\\n    function unregister(address addr) external;\\n    function updateOperator(address registrant, address operator, bool filtered) external;\\n    function updateOperators(address registrant, address[] calldata operators, bool filtered) external;\\n    function updateCodeHash(address registrant, bytes32 codehash, bool filtered) external;\\n    function updateCodeHashes(address registrant, bytes32[] calldata codeHashes, bool filtered) external;\\n    function subscribe(address registrant, address registrantToSubscribe) external;\\n    function unsubscribe(address registrant, bool copyExistingEntries) external;\\n    function subscriptionOf(address addr) external returns (address registrant);\\n    function subscribers(address registrant) external returns (address[] memory);\\n    function subscriberAt(address registrant, uint256 index) external returns (address);\\n    function copyEntriesOf(address registrant, address registrantToCopy) external;\\n    function isOperatorFiltered(address registrant, address operator) external returns (bool);\\n    function isCodeHashOfFiltered(address registrant, address operatorWithCode) external returns (bool);\\n    function isCodeHashFiltered(address registrant, bytes32 codeHash) external returns (bool);\\n    function filteredOperators(address addr) external returns (address[] memory);\\n    function filteredCodeHashes(address addr) external returns (bytes32[] memory);\\n    function filteredOperatorAt(address registrant, uint256 index) external returns (address);\\n    function filteredCodeHashAt(address registrant, uint256 index) external returns (bytes32);\\n    function isRegistered(address addr) external returns (bool);\\n    function codeHashOf(address addr) external returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"lib/nft-editions/lib/solmate/src/tokens/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                      ERC721 BALANCE/OWNER STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) internal _ownerOf;\\n\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    function ownerOf(uint256 id) public view virtual returns (address owner) {\\n        require((owner = _ownerOf[id]) != address(0), \\\"NOT_MINTED\\\");\\n    }\\n\\n    function balanceOf(address owner) public view virtual returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS\\\");\\n\\n        return _balanceOf[owner];\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                         ERC721 APPROVAL STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == _ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || isApprovedForAll[from][msg.sender] || msg.sender == getApproved[id],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            _balanceOf[from]--;\\n\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes calldata data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(_ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            _balanceOf[to]++;\\n        }\\n\\n        _ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = _ownerOf[id];\\n\\n        require(owner != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            _balanceOf[owner]--;\\n        }\\n\\n        delete _ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC721.sol)\\nabstract contract ERC721TokenReceiver {\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/interfaces/IERC2981Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Interface for the NFT Royalty Standard.\\n *\\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\\n *\\n * _Available since v4.5._\\n */\\ninterface IERC2981Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\\n     */\\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\\n        external\\n        view\\n        returns (address receiver, uint256 royaltyAmount);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts-upgradeable/contracts/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ensdomains/=lib/nft-editions/node_modules/@ensdomains/\",\r\n      \"@openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/\",\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"base64/=lib/base64/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"eth-gas-reporter/=lib/nft-editions/node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"gsn/=lib/gsn/\",\r\n      \"hardhat-deploy/=lib/nft-editions/node_modules/hardhat-deploy/\",\r\n      \"hardhat/=lib/nft-editions/node_modules/hardhat/\",\r\n      \"lib/=lib/\",\r\n      \"nft-editions/=lib/nft-editions/contracts/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"operator-filter-registry/=lib/nft-editions/lib/operator-filter-registry/src/\",\r\n      \"solmate/=lib/nft-editions/lib/solmate/src/\",\r\n      \"src/=src/\",\r\n      \"test/=test/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"viaIR\": true,\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"value\",\"type\":\"string\"}],\"name\":\"BadAttribute\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"IntegerOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidArgument\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorNotAllowed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceTooLow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SoldOut\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TimeLimitReached\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongPrice\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldExternalUrl\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newExternalUrl\",\"type\":\"string\"}],\"name\":\"ExternalUrlUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operatorFilter\",\"type\":\"address\"}],\"name\":\"OperatorFilterChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"oldValue\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"newValue\",\"type\":\"string\"}],\"name\":\"PropertyUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CANONICAL_OPENSEA_REGISTRY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CANONICAL_OPENSEA_SUBSCRIPTION\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"activeOperatorFilter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"animationUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"description\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"editionSize\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableDefaultOperatorFilter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endOfMintPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"externalUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"imageUrl\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_animationUrl\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_imageUrl\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_editionSize\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_royaltyBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_mintPeriodSeconds\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMintingEnded\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"}],\"name\":\"mintBatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_salePrice\",\"type\":\"uint256\"}],\"name\":\"royaltyInfo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"royaltyAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"safeMint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"salePrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"allowed\",\"type\":\"bool\"}],\"name\":\"setApprovedMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_externalUrl\",\"type\":\"string\"}],\"name\":\"setExternalUrl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operatorFilter\",\"type\":\"address\"}],\"name\":\"setOperatorFilter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_salePriceWei\",\"type\":\"uint256\"}],\"name\":\"setSalePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"names\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"values\",\"type\":\"string[]\"}],\"name\":\"setStringProperties\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Edition", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}