{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.19;\r\n\r\ninterface IERC20 {\r\n    function totalSupply() external view returns (uint256);\r\n    function decimals() external view returns (uint256);\r\n    function symbol() external view returns (string memory);\r\n    function name() external view returns (string memory);\r\n    function getOwner() external view returns (address);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address _owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function mint(address recipient, uint256 amount) external returns (bool);\r\n    function burnFrom(address sender,uint256 amount) external returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ninterface IDEXRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(    \r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface ILmncRouterV1 {\r\n    function getemitBlock() external view returns (uint256[] memory);\r\n    function getemitPrice() external view returns (uint256[] memory);\r\n    function getRebalancedPrice() external view returns (uint256);\r\n    function swapExactPegForTokens(uint256 amountIn,address to) external returns (bool);\r\n    function swapExactTokensForPeg(uint256 amountIn,address to) external returns (bool,uint256[] memory);\r\n    function getAmountTokenFromExactPeg(uint256 amountIn) external view returns (uint256[] memory);\r\n    function getAmountPegFromExactToken(uint256 amountIn) external view returns (uint256[] memory);\r\n}\r\n\r\ninterface ILmncQueueV1 {\r\n    function queue(uint256 id) external view returns (address,uint256,uint256,bool);\r\n    function queueId() external view returns (uint256);\r\n    function queueAmount() external view returns (uint256);\r\n    function getQueueOwner(uint256 id) external view returns (address);\r\n    function getQueueAmount(uint256 id) external view returns (uint256);\r\n    function getQueueReinvest(uint256 id) external view returns (uint256);\r\n    function getQueueisReinvest(uint256 id) external view returns (bool);\r\n    function getIndexedData() external view returns (uint256[] memory);\r\n    function getAccountQueue(address account) external view returns (uint256[] memory);\r\n    function withdrawToken(address token,address to,uint256 amount) external returns (bool);\r\n    function newQueueWithPermit(address account,uint256 amount) external returns (bool);\r\n    function replaceQueueWithPermit(uint256 id,bool isNonValue) external returns (bool);\r\n}\r\n\r\ninterface ILmncUserV1 {\r\n    function getUsers() external view returns (address[] memory);\r\n    function getTotalUsers() external view returns (uint256);\r\n    function getUser(address account) external view returns (uint256,address,bool);\r\n    function getUserReferree(address account,uint256 level) external view returns (address[] memory);\r\n    function getUserId(address account) external view returns (uint256);\r\n    function getUserReferral(address account) external view returns (address);\r\n    function getUserRegistered(address account) external view returns (bool);\r\n    function getUserUpline(address account,uint256 level) external view returns (address[] memory);\r\n    function Id2Address(uint256 id) external view returns (address);\r\n    function register(address referree,address referral) external returns (bool);\r\n    function updateUserWithPermit(address account,uint256 id,address ref,bool registerd) external returns (bool);\r\n    function updateUserReferreeWithPermit(address account,address[] memory refmap,uint256 level) external returns (bool);\r\n    function updateUserRefScoreWithPermit(address account,address[] memory refscore,uint256 level) external returns (bool);\r\n    function pushUserReferreeWithPermit(address referree,address referral,uint256 level) external returns (bool);\r\n    function pushUserRefScoreWithPermit(address referree,address referral,uint256 cycle) external returns (bool);\r\n    function hashtable(address primarykey,string memory child) external view returns (uint256);\r\n    function updateHashtableWithPermit(address account,string memory key,uint256 value) external returns (bool);\r\n    function increaseHashtableWithPermit(address account,string memory key,uint256 value) external returns (bool);\r\n    function decreaseHashtableWithPermit(address account,string memory key,uint256 value) external returns (bool);\r\n}\r\n\r\ninterface ILmncRankingV1 {\r\n    function getAddressScoreAtCycle(address account,uint256 cycle) external view returns (uint256);\r\n    function getSponsorDataStructor(uint256 cycle) external view returns (address[] memory,uint256[] memory);\r\n    function getTopWinner(uint256 cycle) external view returns (address[] memory,uint256[] memory);\r\n    function getPeriodToNextCycel() external view returns (uint256);\r\n    function getCurrentCycle() external view returns (uint256,uint256);\r\n    function getCycle(uint256 blockstamp) external view returns (uint256);\r\n    function increaseAccountScore(address account,address from,uint256 amount) external returns (bool);\r\n    function updateCycleMemory(uint256 cycle,string memory slot,uint256 value) external returns (bool);\r\n    function increaseCycleMemory(uint256 cycle,string memory slot,uint256 amount) external returns (bool);\r\n    function decreaseCycleMemory(uint256 cycle,string memory slot,uint256 amount) external returns (bool);\r\n    function updateNameWithPermit(address account,string memory name) external returns (bool);\r\n}\r\n\r\ncontract permission {\r\n\r\n    address private _owner;\r\n    mapping(address => mapping(string => bytes32)) private _permit;\r\n\r\n    modifier forRole(string memory str) {\r\n        require(checkpermit(msg.sender,str),\"Permit Revert!\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        newpermit(msg.sender,\"owner\");\r\n        newpermit(msg.sender,\"permit\");\r\n        _owner = msg.sender;\r\n    }\r\n\r\n    function owner() public view returns (address) { return _owner; }\r\n    function newpermit(address adr,string memory str) internal { _permit[adr][str] = bytes32(keccak256(abi.encode(adr,str))); }\r\n    function clearpermit(address adr,string memory str) internal { _permit[adr][str] = bytes32(keccak256(abi.encode(\"null\"))); }\r\n    function checkpermit(address adr,string memory str) public view returns (bool) {\r\n        if(_permit[adr][str]==bytes32(keccak256(abi.encode(adr,str)))){ return true; }else{ return false; }\r\n    }\r\n\r\n    function grantRole(address adr,string memory role) public forRole(\"owner\") returns (bool) { newpermit(adr,role); return true; }\r\n    function revokeRole(address adr,string memory role) public forRole(\"owner\") returns (bool) { clearpermit(adr,role); return true; }\r\n\r\n    function transferOwnership(address adr) public forRole(\"owner\") returns (bool) {\r\n        newpermit(adr,\"owner\");\r\n        clearpermit(msg.sender,\"owner\");\r\n        _owner = adr;\r\n        return true;\r\n    }\r\n\r\n    function renounceOwnership() public forRole(\"owner\") returns (bool) {\r\n        newpermit(address(0),\"owner\");\r\n        clearpermit(msg.sender,\"owner\");\r\n        _owner = address(0);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract RepeatsDAPP is permission {\r\n\r\n    ILmncRouterV1 public routerv1;\r\n    ILmncRankingV1 public rankingv1;\r\n    ILmncQueueV1 public queuev1;\r\n    ILmncUserV1 public userv1;\r\n    IERC20 public LmncToken;\r\n    IERC20 public LmncPeg;\r\n    IERC20 public LmncChip;\r\n    IERC20 public LmncVotePower;\r\n    \r\n    IDEXRouter router;\r\n\r\n    address public burnWallet;\r\n    address public marketingWallet;\r\n    address public airdropWallet;\r\n    address public gameWallet;\r\n    address[] teamWallet;\r\n\r\n    address QuickRouter = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;\r\n\r\n    mapping(uint256 => bool) public allowAmount;\r\n    mapping(uint256 => uint256) public maxReinvest;\r\n\r\n    bool locked;\r\n    modifier noReentrant() {\r\n        require(!locked, \"No re-entrancy\");\r\n        locked = true;\r\n        _;\r\n        locked = false;\r\n    }\r\n\r\n    constructor() {\r\n        burnWallet = 0xbEe35889Cd9597daBE4A1AD9744295cFB49de2a8;\r\n        marketingWallet = 0x755209fFF9b90a12C243b7711f309CE972da097C;\r\n        airdropWallet = 0xA5b678918D992764385Ad952f0f1794aA810D282;\r\n        gameWallet = 0xC15Bda1aF35412B4b5B4Fd2982F3F8F5BB3cf30A;\r\n        teamWallet = [0x177eeB67f444823e85f1A5e3Bff2a7e70B9de7DE,0xf20B3e159EAf56932726e928a41d13dEA86BC073,0x08418E10BBf1B2b9ECd35b0659514f3F70836D55,0x3F115412B4A64265501CcddB7d73156c6852A0CA];\r\n        //default\r\n        routerv1 = ILmncRouterV1(0x46d8288161555B974243b942B02B48f1c690E7ef);\r\n        rankingv1 = ILmncRankingV1(0xa5B2C1Aa627c67bcAe703a2C6bB3fCafa72551e0);\r\n        queuev1 = ILmncQueueV1(0x58644D847AF5e76352675fbEd4e7b2235c91288e);\r\n        userv1 = ILmncUserV1(0xa2e8AC40ea5C7fB52F89ACaf985AE620E865FbC4);\r\n        LmncToken = IERC20(0x73D0F83Be72535D24a6Ea276fcD788ecc33597a5);\r\n        LmncPeg = IERC20(0xc2132D05D31c914a87C6611C10748AEb04B58e8F);\r\n        LmncChip = IERC20(0x779f1b57e7a4Af734ae5371B0590ab2745c26cDD);\r\n        LmncVotePower = IERC20(0x7e35c0617382e8a5ebf90D2f5c8804De2FceDA0E);\r\n        LmncToken.approve(address(routerv1),type(uint256).max);\r\n        LmncPeg.approve(address(routerv1),type(uint256).max);\r\n        //\r\n        router = IDEXRouter(QuickRouter);\r\n    }\r\n\r\n    function getMaticRequire(uint256 dollar) public view returns (uint256) {\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = address(LmncPeg);\r\n        uint[] memory getAmountsIn = router.getAmountsIn(dollar,path);\r\n        return getAmountsIn[0];\r\n    }\r\n\r\n    function depositETHFor(address account,uint256 amount,address referral,address givescore) public payable noReentrant() returns (bool) {\r\n        uint256 maticRequire = getMaticRequire(amount);\r\n        require(msg.value>=maticRequire,\"Not enougth ETH for deposit\");\r\n        require(allowAmount[amount],\"LmncDAPP Error: This Deposit Value Was Not Allowed\");\r\n        address[] memory path = new address[](2);\r\n        path[0] = router.WETH();\r\n        path[1] = address(LmncPeg);\r\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{ value: msg.value }(    \r\n            amount,\r\n            path,\r\n            address(this),\r\n            block.timestamp\r\n        );\r\n        process(account,amount,referral,givescore);\r\n        queuev1.newQueueWithPermit(account,amount);\r\n        return true;\r\n    }\r\n\r\n    function depositFor(address account,uint256 amount,address referral,address givescore) public noReentrant returns (bool) {\r\n        require(allowAmount[amount],\"LmncDAPP Error: This Deposit Value Was Not Allowed\");\r\n        LmncPeg.transferFrom(msg.sender,address(this),amount);\r\n        process(account,amount,referral,givescore);\r\n        queuev1.newQueueWithPermit(account,amount);\r\n        return true;\r\n    }\r\n\r\n    function editName(address account,string memory input) public noReentrant returns (bool) {\r\n        uint256[] memory fee = routerv1.getAmountTokenFromExactPeg(1000000);\r\n        LmncPeg.transferFrom(msg.sender,address(userv1),fee[1]);\r\n        rankingv1.updateNameWithPermit(account,input);\r\n        return true;\r\n    }\r\n\r\n    function rerunFor(uint256 id,address givescore) public noReentrant returns (bool) {\r\n        (address owner,uint256 amount,uint256 reinvest,bool isReinvest) = queuev1.queue(id);\r\n        LmncPeg.transferFrom(msg.sender,address(this),amount);\r\n        uint256[] memory indexedData = queuev1.getIndexedData();\r\n        uint256[] memory balanceAmount = routerv1.getAmountPegFromExactToken(IERC20(address(LmncToken)).balanceOf(address(queuev1)));\r\n        uint256 paidOutAmount = userv1.hashtable(address(queuev1),\"Total_PaidOut_USD\");\r\n        require(indexedData[id-1] * 800 / 1000 <= balanceAmount[1] + paidOutAmount,\"LmncDAPP Error: Not Enougth Balance For Reinvest\");\r\n        require(!isReinvest,\"LmncDAPP Error: This Queue Id Was Reinvested\");\r\n        require(reinvest<maxReinvest[amount],\"LmncDAPP Error: Revert By Max Reinvest Instance\");\r\n        uint256 toSwapAmount = amount * 800 / 1000;\r\n        uint256[] memory toWithdrawAmount = routerv1.getAmountTokenFromExactPeg(toSwapAmount);\r\n        userv1.increaseHashtableWithPermit(address(queuev1),\"Total_PaidOut_USD\",toSwapAmount);\r\n        IERC20(LmncToken).transferFrom(address(queuev1),address(this),toWithdrawAmount[1]);\r\n        routerv1.swapExactTokensForPeg(toWithdrawAmount[1],owner);\r\n        process(owner,amount,address(0),givescore);\r\n        if(reinvest+1 < maxReinvest[amount]){\r\n            queuev1.replaceQueueWithPermit(id,false);\r\n        }else{\r\n            queuev1.replaceQueueWithPermit(id,true);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function process(address account,uint256 amount,address referral,address givescore) internal {\r\n        require(account!=givescore,\"LmncDAPP Error: Account And GiveScore Must Not Be Same\");\r\n        address[] memory upline = new address[](3);\r\n        if(!userv1.getUserRegistered(account)){\r\n            require(userv1.getUserRegistered(referral),\"LmncDAPP Error: Referral Address Must Be Registered\");\r\n            userv1.register(account,referral);\r\n            upline = userv1.getUserUpline(account,3);\r\n            for(uint256 i=0; i < 3; i++){\r\n                if(upline[i]!=address(0)){\r\n                    userv1.pushUserReferreeWithPermit(account,upline[i],i);\r\n                }\r\n            }\r\n        }\r\n        upline = userv1.getUserUpline(account,3);\r\n        uint256 hasTeam = userv1.hashtable(address(account),\"Has_Team\");\r\n        if(hasTeam==0 && givescore != address(userv1) && !isDead(givescore)){\r\n            userv1.updateHashtableWithPermit(account,\"Locked_Team\",addr2unit(givescore));\r\n            userv1.updateHashtableWithPermit(account,\"Has_Team\",1);\r\n            userv1.pushUserRefScoreWithPermit(account,givescore,0);\r\n        }\r\n        if(hasTeam==1){\r\n            address lockedAddress = unit2addr(userv1.hashtable(account,\"Locked_Team\"));\r\n            rankingv1.increaseAccountScore(lockedAddress,account,amount);\r\n        }else{\r\n            rankingv1.increaseAccountScore(givescore,account,amount);\r\n        }\r\n        uint256 tokenBefore = LmncToken.balanceOf(address(this));\r\n        routerv1.swapExactPegForTokens(amount,address(this));\r\n        uint256 divAmount = LmncToken.balanceOf(address(this)) - tokenBefore;\r\n        LmncToken.transfer(account,divAmount*400/1000);\r\n        LmncToken.transfer(address(queuev1),divAmount*300/1000);\r\n        LmncToken.transfer(address(rankingv1),divAmount*50/1000);\r\n        LmncToken.transfer(safeAddr(upline[0]),divAmount*50/1000);\r\n        distribute(divAmount*200/1000);\r\n        userv1.increaseHashtableWithPermit(account,\"Total_Deposit_Amount\",amount);\r\n        userv1.increaseHashtableWithPermit(upline[0],\"Total_Referral_Amount_level_1\",divAmount*50/1000);\r\n        (,uint256 cycle) = rankingv1.getCurrentCycle();\r\n        rankingv1.increaseCycleMemory(cycle,\"cycle_reward\",divAmount*50/1000);\r\n        LmncVotePower.mint(account,amount);\r\n        LmncChip.mint(account,amount*10);\r\n        LmncChip.mint(safeAddr(upline[0]),amount);\r\n    }\r\n\r\n    function distribute(uint256 amount) internal {\r\n        LmncToken.transfer(burnWallet,amount*30/200);\r\n        LmncToken.transfer(marketingWallet,amount*100/200);\r\n        LmncToken.transfer(airdropWallet,amount*20/200);\r\n        LmncToken.transfer(gameWallet,amount*20/200);\r\n        uint256 teamDividend = amount*30/200;\r\n        LmncToken.transfer(teamWallet[0],teamDividend/4);\r\n        LmncToken.transfer(teamWallet[1],teamDividend/4);\r\n        LmncToken.transfer(teamWallet[2],teamDividend/4);\r\n        LmncToken.transfer(teamWallet[3],teamDividend/4);\r\n    }\r\n\r\n    function updateStateContract(address LMNCrouter,address ranking,address queue,address user,address token,address peg,address coupon,address power) public forRole(\"owner\") returns (bool) {\r\n        routerv1 = ILmncRouterV1(LMNCrouter);\r\n        rankingv1 = ILmncRankingV1(ranking);\r\n        queuev1 = ILmncQueueV1(queue);\r\n        userv1 = ILmncUserV1(user);\r\n        LmncToken = IERC20(token);\r\n        LmncPeg = IERC20(peg);\r\n        LmncChip = IERC20(coupon);\r\n        LmncVotePower = IERC20(power);\r\n        LmncToken.approve(address(routerv1),type(uint256).max);\r\n        LmncPeg.approve(address(routerv1),type(uint256).max);\r\n        return true;\r\n    }\r\n\r\n    function updateWalletAddress(address[] memory accounts,address[] memory teamAddresses) public forRole(\"owner\") returns (bool) {\r\n        burnWallet = accounts[0];\r\n        marketingWallet = accounts[1];\r\n        airdropWallet = accounts[2];\r\n        gameWallet = accounts[3];\r\n        teamWallet[0] = teamAddresses[0];\r\n        teamWallet[1] = teamAddresses[1];\r\n        teamWallet[2] = teamAddresses[2];\r\n        teamWallet[3] = teamAddresses[3];\r\n        return true;\r\n    }\r\n\r\n    function getCostData(uint256 cost) public view returns (bool,uint256) {\r\n        return (allowAmount[cost],maxReinvest[cost]);\r\n    }\r\n\r\n    function updateAllowAmount(uint256 cost,bool flag) public forRole(\"owner\") returns (bool) {\r\n        allowAmount[cost] = flag;\r\n        return true;\r\n    }\r\n\r\n    function updateMaxReinvest(uint256 cost,uint256 amount) public forRole(\"owner\") returns (bool) {\r\n        maxReinvest[cost] = amount;\r\n        return true;\r\n    }\r\n\r\n    function settingCostData(uint256 cost,bool flag,uint256 reinvest) public forRole(\"owner\") returns (bool) {\r\n        allowAmount[cost] = flag;\r\n        maxReinvest[cost] = reinvest;\r\n        return true;\r\n    }\r\n\r\n    function unit2addr(uint256 value) public pure returns (address) {\r\n        bytes32 bytesValue = bytes32(value);\r\n        address addr = address(uint160(uint256(bytesValue)));\r\n        return addr;\r\n    }\r\n\r\n    function addr2unit(address addr) public pure returns (uint256) {\r\n        uint160 numericValue = uint160(addr);\r\n        uint256 result = uint256(numericValue);\r\n        return result;\r\n    }\r\n\r\n    function safeAddr(address account) internal view returns (address) {\r\n        if(isDead(account)){ return address(userv1); }else{ return account; }\r\n    }\r\n\r\n    function isDead(address account) internal pure returns (bool) {\r\n        if(account==address(0)||account==address(0xdead)){ return true; }else{ return false; }\r\n    }\r\n\r\n    function callWithData(address to,bytes memory data) public forRole(\"owner\") returns (bytes memory) {\r\n        (bool success,bytes memory result) = to.call(data);\r\n        require(success,\"call with data fail!\");\r\n        return result;\r\n    }\r\n\r\n    function withdrawETH(address to,uint256 amount) public forRole(\"owner\") returns (bool) {\r\n        (bool success,) = to.call{ value: amount }(\"\");\r\n        require(success, \"FAIL TO SEND ETH!\");\r\n        return true;\r\n    }\r\n\r\n    function getDataForCall() public view returns (bytes memory) {\r\n        return abi.encodeWithSignature(\"approve(address,uint256)\", address(this), type(uint256).max);\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LmncChip\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LmncPeg\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LmncToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LmncVotePower\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addr2unit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"burnWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"callWithData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"str\",\"type\":\"string\"}],\"name\":\"checkpermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"givescore\",\"type\":\"address\"}],\"name\":\"depositETHFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"givescore\",\"type\":\"address\"}],\"name\":\"depositFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"input\",\"type\":\"string\"}],\"name\":\"editName\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"}],\"name\":\"getCostData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDataForCall\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dollar\",\"type\":\"uint256\"}],\"name\":\"getMaticRequire\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"grantRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketingWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxReinvest\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"queuev1\",\"outputs\":[{\"internalType\":\"contract ILmncQueueV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rankingv1\",\"outputs\":[{\"internalType\":\"contract ILmncRankingV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"givescore\",\"type\":\"address\"}],\"name\":\"rerunFor\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"role\",\"type\":\"string\"}],\"name\":\"revokeRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"routerv1\",\"outputs\":[{\"internalType\":\"contract ILmncRouterV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"reinvest\",\"type\":\"uint256\"}],\"name\":\"settingCostData\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"unit2addr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"updateAllowAmount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cost\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateMaxReinvest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"LMNCrouter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ranking\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"queue\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"peg\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"coupon\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"power\",\"type\":\"address\"}],\"name\":\"updateStateContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"teamAddresses\",\"type\":\"address[]\"}],\"name\":\"updateWalletAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"userv1\",\"outputs\":[{\"internalType\":\"contract ILmncUserV1\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RepeatsDAPP", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://7b8c780e0bb8ad5b22bf8bd9d36eb3e4f15a68cf21263917954fdb8069708fbc"}