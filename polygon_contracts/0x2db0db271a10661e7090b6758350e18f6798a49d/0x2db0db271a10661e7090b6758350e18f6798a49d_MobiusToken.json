{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/MobiusToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport './base/Token.sol';\\nimport './base/Importable.sol';\\nimport './interfaces/IMobiusToken.sol';\\nimport './interfaces/IIssuer.sol';\\nimport './interfaces/IResolver.sol';\\n\\ncontract MobiusToken is Importable, Token, IMobiusToken {\\n    bytes32[] private MINTABLE_CONTRACTS = [CONTRACT_REWARD_COLLATERAL, CONTRACT_REWARD_STAKING,CONTRACT_REWARD_TRADING];\\n    uint256 public MAX_SUPPLY = 1e8;\\n    uint256 public AIRDROP_LIMIT = 55000000 * (10 ** uint256(decimals()));\\n    address DEPOSITOR_ROLE;\\n\\n    modifier onlyResolver() {\\n        require(msg.sender == address(resolver), 'MobiusToken: caller is not the Resolver');\\n        _;\\n    }\\n\\n    constructor(IResolver _resolver) Importable(_resolver) Token('Mobius Token','MOT',CONTRACT_MOBIUS_TOKEN) {\\n        imports = [\\n            CONTRACT_REWARD_COLLATERAL,\\n            CONTRACT_REWARD_STAKING,\\n            CONTRACT_REWARD_TRADING\\n        ];\\n    }\\n\\n    function setDepositor(address addr) external onlyOwner {\\n        DEPOSITOR_ROLE = addr;\\n    }\\n\\n    function mint(address account, uint256 amount) external override containAddress(MINTABLE_CONTRACTS) returns (bool) {\\n        require(totalSupply() + amount <= MAX_SUPPLY * (10 ** uint256(decimals())),'can not mint more');\\n        _mint(account, amount);\\n        return true;\\n    }\\n\\n    function migrate(address from, address to) external override onlyResolver returns (bool) {\\n        uint256 amount = balanceOf(from);\\n        if (amount == 0) return true;\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n    \\n    function airdrop(address to,uint256 amount) external onlyOwner returns (bool) {\\n        require(AIRDROP_LIMIT  >= amount, 'can not airdrop more');\\n        AIRDROP_LIMIT = AIRDROP_LIMIT - amount;\\n        _mint(to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @notice called when token is deposited on root chain\\n     * @dev Should be callable only by ChildChainManager\\n     * Should handle deposit by minting the required amount for user\\n     * Make sure minting is done only by this function\\n     * @param user user address for whom deposit is being done\\n     * @param depositData abi encoded amount\\n     */\\n    function deposit(address user, bytes calldata depositData) external {\\n        require(msg.sender == DEPOSITOR_ROLE, \\\"caller is not DEPOSITOR_ROLE\\\");\\n        uint256 amount = abi.decode(depositData, (uint256));\\n        _mint(user, amount);\\n    }\\n\\n    /**\\n     * @notice called when user wants to withdraw tokens back to root chain\\n     * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\\n     * @param amount amount of tokens to withdraw\\n     */\\n    function withdraw(uint256 amount) external {\\n        _burn(msg.sender, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/base/Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ncontract Constants {\\n    bytes32 internal constant MOT = 'MOT';\\n    bytes32 internal constant USD = 'moUSD';\\n\\n    bytes32 internal constant CONTRACT_RESOLVER = 'Resolver';\\n    bytes32 internal constant CONTRACT_ASSET_PRICE = 'AssetPrice';\\n    bytes32 internal constant CONTRACT_SETTING = 'Setting';\\n\\n    bytes32 internal constant CONTRACT_MOBIUS = 'Mobius';\\n    bytes32 internal constant CONTRACT_ESCROW = 'Escrow';\\n    bytes32 internal constant CONTRACT_ISSUER = 'Issuer';\\n\\n    bytes32 internal constant CONTRACT_STAKER = 'Staker';\\n    bytes32 internal constant CONTRACT_TRADER = 'Trader';\\n    bytes32 internal constant CONTRACT_TEAM = 'Team';\\n\\n    bytes32 internal constant CONTRACT_MOBIUS_TOKEN = 'MobiusToken';\\n\\n    bytes32 internal constant CONTRACT_LIQUIDATOR = 'Liquidator';\\n\\n    bytes32 internal constant CONTRACT_REWARD_COLLATERAL = 'RewardCollateral';\\n    bytes32 internal constant CONTRACT_REWARD_STAKING = 'RewardStaking';\\n    bytes32 internal constant CONTRACT_REWARD_TRADING = 'RewardTradings';\\n\\n    bytes32 internal constant TRADING_FEE_ADDRESS = 'TradingFeeAddress';\\n    bytes32 internal constant LIQUIDATION_FEE_ADDRESS = 'LiquidationFeeAddress';\\n\\n    bytes32 internal constant CONTRACT_DYNCMIC_TRADING_FEE = 'DynamicTradingFee';\\n}\\n\"\r\n    },\r\n    \"/contracts/base/ExternalStorable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport './Ownable.sol';\\nimport '../lib/Strings.sol';\\n\\ncontract ExternalStorable is Ownable {\\n    using Strings for string;\\n    address private _storage;\\n\\n    event StorageChanged(address indexed previousValue, address indexed newValue);\\n\\n    modifier onlyStorageSetup() {\\n        require(_storage != address(0), contractName.concat(': Storage not set'));\\n        _;\\n    }\\n\\n    function setStorage(address value) public onlyOwner {\\n        require(value != address(0), \\\"storage is a zero address\\\");\\n        emit StorageChanged(_storage, value);\\n        _storage = value;\\n    }\\n\\n    function getStorage() public view onlyStorageSetup returns (address) {\\n        return _storage;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/base/Importable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport './Ownable.sol';\\nimport '../interfaces/IResolver.sol';\\nimport '../lib/Strings.sol';\\n\\ncontract Importable is Ownable {\\n    using Strings for string;\\n\\n    IResolver public resolver;\\n    bytes32[] internal imports;\\n\\n    mapping(bytes32 => address) private _cache;\\n\\n    constructor(IResolver _resolver) {\\n        resolver = _resolver;\\n    }\\n\\n    modifier onlyAddress(bytes32 name) {\\n        require(msg.sender == _cache[name], contractName.concat(': caller is not the ', name));\\n        _;\\n    }\\n\\n    modifier containAddress(bytes32[] memory names) {\\n        require(names.length < 20, contractName.concat(': cannot have more than 20 items'));\\n\\n        bool contain = false;\\n        for (uint256 i = 0; i < names.length; i++) {\\n            if (msg.sender == _cache[names[i]]) {\\n                contain = true;\\n                break;\\n            }\\n        }\\n        require(contain, contractName.concat(': caller is not in contains'));\\n        _;\\n    }\\n\\n    modifier containAddressOrOwner(bytes32[] memory names) {\\n        require(names.length < 20, contractName.concat(': cannot have more than 20 items'));\\n\\n        bool contain = false;\\n        for (uint256 i = 0; i < names.length; i++) {\\n            if (msg.sender == _cache[names[i]]) {\\n                contain = true;\\n                break;\\n            }\\n        }\\n        if (!contain) contain = (msg.sender == owner);\\n        require(contain, contractName.concat(': caller is not in dependencies'));\\n        _;\\n    }\\n\\n    function refreshCache() external onlyOwner {\\n        for (uint256 i = 0; i < imports.length; i++) {\\n            bytes32 item = imports[i];\\n            _cache[item] = resolver.getAddress(item);\\n        }\\n    }\\n\\n    function getImports() external view returns (bytes32[] memory) {\\n        return imports;\\n    }\\n\\n    function requireAsset(bytes32 assetType, bytes32 assetName) internal view returns (address) {\\n        (bool exist, address assetAddress) = resolver.getAsset(assetType, assetName);\\n        require(exist, contractName.concat(': Missing Asset Token ', assetName));\\n        return assetAddress;\\n    }\\n\\n    function assets(bytes32 assetType) internal view returns (bytes32[] memory) {\\n        return resolver.getAssets(assetType);\\n    }\\n\\n    function addAddress(bytes32 name) external onlyOwner {\\n        _cache[name] = resolver.getAddress(name);\\n        imports.push(name);\\n    }\\n\\n    function requireAddress(bytes32 name) internal view returns (address) {\\n        require(_cache[name] != address(0), contractName.concat(': Missing ', name));\\n        return _cache[name];\\n    }\\n\\n    function getAddress(bytes32 name) external view returns (address) {\\n        return _cache[name];\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/base/Ownable.sol\": {\r\n      \"content\": \"pragma solidity =0.8.4;\\n\\n// SPDX-License-Identifier: MIT\\nimport '../lib/Strings.sol';\\nimport './Constants.sol';\\nimport '../interfaces/IOwnable.sol';\\n\\ncontract Ownable is Constants, IOwnable {\\n    using Strings for string;\\n\\n    string public override contractName;\\n    address public owner;\\n    address public manager;\\n\\n    constructor() {\\n        owner = msg.sender;\\n        manager = msg.sender;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, contractName.concat(': caller is not the owner'));\\n        _;\\n    }\\n\\n    modifier onlyManager(bytes32 managerName) {\\n        require(msg.sender == manager, contractName.concat(': caller is not the ', managerName));\\n        _;\\n    }\\n\\n    modifier allManager() {\\n        require(\\n            msg.sender == manager || msg.sender == owner,\\n            contractName.concat(': caller is not the manager or the owner')\\n        );\\n        _;\\n    }\\n\\n    function setOwner(address _owner) public onlyOwner {\\n        require(_owner != address(0), contractName.concat(': new owner is the zero address'));\\n        emit OwnerChanged(owner, _owner);\\n        owner = _owner;\\n    }\\n\\n    function setManager(address _manager) public virtual onlyOwner {\\n        require(_manager != address(0), contractName.concat(': new manager is the zero address'));\\n        emit ManagerChanged(manager, _manager);\\n        manager = _manager;\\n    }\\n\\n    function setContractName(bytes32 _contractName) internal {\\n        contractName = string(abi.encodePacked(_contractName));\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/base/Token.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport '../lib/Strings.sol';\\nimport './ExternalStorable.sol';\\nimport '../interfaces/storages/ITokenStorage.sol';\\nimport '../interfaces/IERC20.sol';\\n\\ncontract Token is ExternalStorable, IERC20 {\\n    using Strings for string;\\n    \\n    bytes32 private constant TOTAL = 'Total';\\n    bytes32 private constant BALANCE = 'Balance';\\n\\n    string internal _name;\\n    string internal _symbol;\\n\\n    constructor(string memory __name,string memory __symbol,bytes32 contractName) {\\n        setContractName(contractName);\\n        _name = __name;\\n        _symbol = __symbol;\\n    }\\n\\n    function Storage() internal view returns (ITokenStorage) {\\n        return ITokenStorage(getStorage());\\n    }\\n\\n    function name() external override view returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() external override view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    function decimals() public override pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    function totalSupply() public override view returns (uint256) {\\n        return Storage().getUint(TOTAL, address(0));\\n    }\\n\\n    function balanceOf(address account) public override view returns (uint256) {\\n        return Storage().getUint(BALANCE, account);\\n    }\\n\\n    function allowance(address owner, address spender) external override view returns (uint256) {\\n        return Storage().getAllowance(owner, spender);\\n    }\\n\\n    function approve(address spender, uint256 amount) external override returns (bool) {\\n        _approve(msg.sender, spender, amount);\\n        return true;\\n    }\\n\\n    function transfer(address recipient, uint256 amount) external override returns (bool) {\\n        _transfer(msg.sender, recipient, amount);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        uint256 delta = Storage().getAllowance(sender, msg.sender) - amount;\\n        _approve(sender, msg.sender, delta);\\n        return true;\\n    }\\n\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        Storage().setAllowance(owner, spender, amount);\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        Storage().decrementUint(BALANCE, sender, amount);\\n        Storage().incrementUint(BALANCE, recipient, amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    function _mint(address account, uint256 amount) internal {\\n        Storage().incrementUint(BALANCE, account, amount);\\n        Storage().incrementUint(TOTAL, address(0), amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    function _burn(address account, uint256 amount) internal {\\n        Storage().decrementUint(BALANCE, account, amount);\\n        Storage().decrementUint(TOTAL, address(0), amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface IERC20 {\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n\\n    function decimals() external view returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function transfer(address recipient, uint256 value) external returns (bool);\\n\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IIssuer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface IIssuer {\\n    function issueDebt(\\n        bytes32 stake,\\n        address account,\\n        bytes32 debtType,\\n        uint256 amountInUSD,\\n        uint256 amountInSynth\\n    ) external;\\n\\n    function issueDebtWithPreviousStake(\\n        bytes32 stake, \\n        address account, \\n        bytes32 debtType, \\n        uint256 amountInSynth\\n    ) external;\\n\\n    function getIssuable(bytes32 stake, address account, bytes32 debtType) external view returns (uint256);\\n\\n    function burnDebt(\\n        bytes32 stake,\\n        address account,\\n        bytes32 debtType,\\n        uint256 amount,\\n        address payer\\n    ) external returns (uint256);\\n\\n    function issueSynth(\\n        bytes32 synth,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function burnSynth(\\n        bytes32 synth,\\n        address account,\\n        uint256 amount\\n    ) external;\\n\\n    function getDebt(bytes32 stake, address account, bytes32 debtType) external view returns (uint256);\\n    function getDebtOriginal(bytes32 stake, address account, bytes32 debtType) external view returns (uint256, uint256, uint256);\\n    function getUsersTotalDebtInSynth(bytes32 synth) external view returns (uint256);\\n\\n    function getDynamicTotalDebt() external view returns (uint256 platTotalDebt, uint256 usersTotalDebt, uint256 usersTotalDebtOriginal);\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IMobiusToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nimport './IERC20.sol';\\n\\ninterface IMobiusToken is IERC20 {\\n    function mint(address account, uint256 amount) external returns (bool);\\n    function migrate(address from, address to) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface IOwnable {\\n    function contractName() external view returns (string memory);\\n\\n    event OwnerChanged(address indexed previousValue, address indexed newValue);\\n    event ManagerChanged(address indexed previousValue, address indexed newValue);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/IResolver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface IResolver {\\n    function getAddress(bytes32 name) external view returns (address);\\n\\n    function getAsset(bytes32 assetType, bytes32 assetName) external view returns (bool, address);\\n\\n    function getAssets(bytes32 assetType) external view returns (bytes32[] memory);\\n\\n    event AssetChanged(bytes32 indexed assetType, bytes32 indexed assetName, address previousValue, address newValue);\\n    event AddressChanged(bytes32 indexed name, address indexed previousValue, address indexed newValue);\\n    event MobiusTokenMigrated(bytes32 indexed name, address indexed previousValue, address indexed newValue);\\n}\\n\"\r\n    },\r\n    \"/contracts/interfaces/storages/ITokenStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\ninterface ITokenStorage {\\n    function setAllowance(\\n        address key,\\n        address field,\\n        uint256 value\\n    ) external;\\n\\n    function getAllowance(address key, address field) external view returns (uint256);\\n\\n    function incrementUint(\\n        bytes32 key,\\n        address field,\\n        uint256 value\\n    ) external returns (uint256);\\n\\n    function decrementUint(\\n        bytes32 key,\\n        address field,\\n        uint256 value\\n    ) external returns (uint256);\\n\\n    function setUint(\\n        bytes32 key,\\n        address field,\\n        uint256 value\\n    ) external;\\n\\n    function getUint(bytes32 key, address field) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/lib/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.4;\\n\\nlibrary Strings {\\n    function toBytes32(string memory a) internal pure returns (bytes32) {\\n        bytes32 b;\\n        assembly {\\n            b := mload(add(a, 32))\\n        }\\n        return b;\\n    }\\n\\n    function concat(string memory a, string memory b) internal pure returns (string memory) {\\n        return string(abi.encodePacked(a, b));\\n    }\\n\\n    function concat(\\n        string memory a,\\n        string memory b,\\n        bytes32 c\\n    ) internal pure returns (string memory) {\\n        return string(abi.encodePacked(a, b, c));\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IResolver\",\"name\":\"_resolver\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"OwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousValue\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newValue\",\"type\":\"address\"}],\"name\":\"StorageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AIRDROP_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"addAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"airdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"depositData\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"getAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getImports\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getStorage\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refreshCache\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"internalType\":\"contract IResolver\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setDepositor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"value\",\"type\":\"address\"}],\"name\":\"setStorage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MobiusToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000001e02cdbba6729b6470de81ad4d2cca4c514521b9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}