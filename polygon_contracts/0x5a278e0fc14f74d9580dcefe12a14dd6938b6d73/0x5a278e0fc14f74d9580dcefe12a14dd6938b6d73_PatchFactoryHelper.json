{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n *\\n * @custom:oz-upgrades-unsafe-allow delegatecall\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n        __ERC1967Upgrade_init_unchained();\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallSecure(\\n        address newImplementation,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        address oldImplementation = _getImplementation();\\n\\n        // Initial upgrade and setup call\\n        _setImplementation(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(newImplementation, data);\\n        }\\n\\n        // Perform rollback test if not already in progress\\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\\n        if (!rollbackTesting.value) {\\n            // Trigger rollback using upgradeTo from the new implementation\\n            rollbackTesting.value = true;\\n            _functionDelegateCall(\\n                newImplementation,\\n                abi.encodeWithSignature(\\\"upgradeTo(address)\\\", oldImplementation)\\n            );\\n            rollbackTesting.value = false;\\n            // Check rollback was effective\\n            require(oldImplementation == _getImplementation(), \\\"ERC1967Upgrade: upgrade breaks further upgrades\\\");\\n            // Finally reset to the new implementation and log the upgrade\\n            _upgradeTo(newImplementation);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Emitted when the beacon is upgraded.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(\\n        address newBeacon,\\n        bytes memory data,\\n        bool forceCall\\n    ) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\\n        require(AddressUpgradeable.isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return AddressUpgradeable.verifyCallResult(success, returndata, \\\"Address: low-level delegate call failed\\\");\\n    }\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n        __ERC1967Upgrade_init_unchained();\\n        __UUPSUpgradeable_init_unchained();\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallSecure(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/EIP2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title EIP-2612: permit - 712-signed approvals\\r\\n *\\r\\n * @notice A function permit extending ERC-20 which allows for approvals to be made via secp256k1 signatures.\\r\\n *      This kind of \u201caccount abstraction for ERC-20\u201d brings about two main benefits:\\r\\n *        - transactions involving ERC-20 operations can be paid using the token itself rather than ETH,\\r\\n *        - approve and pull operations can happen in a single transaction instead of two consecutive transactions,\\r\\n *        - while adding as little as possible over the existing ERC-20 standard.\\r\\n *\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-2612#specification\\r\\n */\\r\\ninterface EIP2612 {\\r\\n\\t/**\\r\\n\\t * @notice EIP712 domain separator of the smart contract. It should be unique to the contract\\r\\n\\t *      and chain to prevent replay attacks from other domains, and satisfy the requirements of EIP-712,\\r\\n\\t *      but is otherwise unconstrained.\\r\\n\\t */\\r\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Counter of the nonces used for the given address; nonce are used sequentially\\r\\n\\t *\\r\\n\\t * @dev To prevent from replay attacks nonce is incremented for each address after a successful `permit` execution\\r\\n\\t *\\r\\n\\t * @param owner an address to query number of used nonces for\\r\\n\\t * @return number of used nonce, nonce number to be used next\\r\\n\\t */\\r\\n\\tfunction nonces(address owner) external view returns (uint);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice For all addresses owner, spender, uint256s value, deadline and nonce, uint8 v, bytes32 r and s,\\r\\n\\t *      a call to permit(owner, spender, value, deadline, v, r, s) will set approval[owner][spender] to value,\\r\\n\\t *      increment nonces[owner] by 1, and emit a corresponding Approval event,\\r\\n\\t *      if and only if the following conditions are met:\\r\\n\\t *        - The current blocktime is less than or equal to deadline.\\r\\n\\t *        - owner is not the zero address.\\r\\n\\t *        - nonces[owner] (before the state update) is equal to nonce.\\r\\n\\t *        - r, s and v is a valid secp256k1 signature from owner of the message:\\r\\n\\t *\\r\\n\\t * @param owner token owner address, granting an approval to spend its tokens\\r\\n\\t * @param spender an address approved by the owner (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param value an amount of tokens spender `spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/EIP3009.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title EIP-3009: Transfer With Authorization\\r\\n *\\r\\n * @notice A contract interface that enables transferring of fungible assets via a signed authorization.\\r\\n *      See https://eips.ethereum.org/EIPS/eip-3009\\r\\n *      See https://eips.ethereum.org/EIPS/eip-3009#specification\\r\\n */\\r\\ninterface EIP3009 {\\r\\n\\t/**\\r\\n\\t * @dev Fired whenever the nonce gets used (ex.: `transferWithAuthorization`, `receiveWithAuthorization`)\\r\\n\\t *\\r\\n\\t * @param authorizer an address which has used the nonce\\r\\n\\t * @param nonce the nonce used\\r\\n\\t */\\r\\n\\tevent AuthorizationUsed(address indexed authorizer, bytes32 indexed nonce);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired whenever the nonce gets cancelled (ex.: `cancelAuthorization`)\\r\\n\\t *\\r\\n\\t * @dev Both `AuthorizationUsed` and `AuthorizationCanceled` imply the nonce\\r\\n\\t *      cannot be longer used, the only difference is that `AuthorizationCanceled`\\r\\n\\t *      implies no smart contract state change made (except the nonce marked as cancelled)\\r\\n\\t *\\r\\n\\t * @param authorizer an address which has cancelled the nonce\\r\\n\\t * @param nonce the nonce cancelled\\r\\n\\t */\\r\\n\\tevent AuthorizationCanceled(address indexed authorizer, bytes32 indexed nonce);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Returns the state of an authorization, more specifically\\r\\n\\t *      if the specified nonce was already used by the address specified\\r\\n\\t *\\r\\n\\t * @dev Nonces are expected to be client-side randomly generated 32-byte data\\r\\n\\t *      unique to the authorizer's address\\r\\n\\t *\\r\\n\\t * @param authorizer    Authorizer's address\\r\\n\\t * @param nonce         Nonce of the authorization\\r\\n\\t * @return true if the nonce is used\\r\\n\\t */\\r\\n\\tfunction authorizationState(\\r\\n\\t\\taddress authorizer,\\r\\n\\t\\tbytes32 nonce\\r\\n\\t) external view returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Execute a transfer with a signed authorization\\r\\n\\t *\\r\\n\\t * @param from          Payer's address (Authorizer)\\r\\n\\t * @param to            Payee's address\\r\\n\\t * @param value         Amount to be transferred\\r\\n\\t * @param validAfter    The time after which this is valid (unix time)\\r\\n\\t * @param validBefore   The time before which this is valid (unix time)\\r\\n\\t * @param nonce         Unique nonce\\r\\n\\t * @param v             v of the signature\\r\\n\\t * @param r             r of the signature\\r\\n\\t * @param s             s of the signature\\r\\n\\t */\\r\\n\\tfunction transferWithAuthorization(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 value,\\r\\n\\t\\tuint256 validAfter,\\r\\n\\t\\tuint256 validBefore,\\r\\n\\t\\tbytes32 nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Receive a transfer with a signed authorization from the payer\\r\\n\\t *\\r\\n\\t * @dev This has an additional check to ensure that the payee's address matches\\r\\n\\t *      the caller of this function to prevent front-running attacks.\\r\\n\\t * @dev See https://eips.ethereum.org/EIPS/eip-3009#security-considerations\\r\\n\\t *\\r\\n\\t * @param from          Payer's address (Authorizer)\\r\\n\\t * @param to            Payee's address\\r\\n\\t * @param value         Amount to be transferred\\r\\n\\t * @param validAfter    The time after which this is valid (unix time)\\r\\n\\t * @param validBefore   The time before which this is valid (unix time)\\r\\n\\t * @param nonce         Unique nonce\\r\\n\\t * @param v             v of the signature\\r\\n\\t * @param r             r of the signature\\r\\n\\t * @param s             s of the signature\\r\\n\\t */\\r\\n\\tfunction receiveWithAuthorization(\\r\\n\\t\\taddress from,\\r\\n\\t\\taddress to,\\r\\n\\t\\tuint256 value,\\r\\n\\t\\tuint256 validAfter,\\r\\n\\t\\tuint256 validBefore,\\r\\n\\t\\tbytes32 nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Attempt to cancel an authorization\\r\\n\\t *\\r\\n\\t * @param authorizer    Authorizer's address\\r\\n\\t * @param nonce         Nonce of the authorization\\r\\n\\t * @param v             v of the signature\\r\\n\\t * @param r             r of the signature\\r\\n\\t * @param s             s of the signature\\r\\n\\t */\\r\\n\\tfunction cancelAuthorization(\\r\\n\\t\\taddress authorizer,\\r\\n\\t\\tbytes32 nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC1363Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"./ERC20Spec.sol\\\";\\r\\nimport \\\"./ERC165Spec.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC1363 Interface\\r\\n *\\r\\n * @dev Interface defining a ERC1363 Payable Token contract.\\r\\n *      Implementing contracts MUST implement the ERC1363 interface as well as the ERC20 and ERC165 interfaces.\\r\\n */\\r\\ninterface ERC1363 is ERC20, ERC165  {\\r\\n\\t/*\\r\\n\\t * Note: the ERC-165 identifier for this interface is 0xb0202a11.\\r\\n\\t * 0xb0202a11 ===\\r\\n\\t *   bytes4(keccak256('transferAndCall(address,uint256)')) ^\\r\\n\\t *   bytes4(keccak256('transferAndCall(address,uint256,bytes)')) ^\\r\\n\\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256)')) ^\\r\\n\\t *   bytes4(keccak256('transferFromAndCall(address,address,uint256,bytes)')) ^\\r\\n\\t *   bytes4(keccak256('approveAndCall(address,uint256)')) ^\\r\\n\\t *   bytes4(keccak256('approveAndCall(address,uint256,bytes)'))\\r\\n\\t */\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\\r\\n\\t * @param to address The address which you want to transfer to\\r\\n\\t * @param value uint256 The amount of tokens to be transferred\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction transferAndCall(address to, uint256 value) external returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\\r\\n\\t * @param to address The address which you want to transfer to\\r\\n\\t * @param value uint256 The amount of tokens to be transferred\\r\\n\\t * @param data bytes Additional data with no specified format, sent in call to `to`\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction transferAndCall(address to, uint256 value, bytes memory data) external returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\\r\\n\\t * @param from address The address which you want to send tokens from\\r\\n\\t * @param to address The address which you want to transfer to\\r\\n\\t * @param value uint256 The amount of tokens to be transferred\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction transferFromAndCall(address from, address to, uint256 value) external returns (bool);\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfer tokens from one address to another and then call `onTransferReceived` on receiver\\r\\n\\t * @param from address The address which you want to send tokens from\\r\\n\\t * @param to address The address which you want to transfer to\\r\\n\\t * @param value uint256 The amount of tokens to be transferred\\r\\n\\t * @param data bytes Additional data with no specified format, sent in call to `to`\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction transferFromAndCall(address from, address to, uint256 value, bytes memory data) external returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\\r\\n\\t * and then call `onApprovalReceived` on spender.\\r\\n\\t * @param spender address The address which will spend the funds\\r\\n\\t * @param value uint256 The amount of tokens to be spent\\r\\n\\t */\\r\\n\\tfunction approveAndCall(address spender, uint256 value) external returns (bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Approve the passed address to spend the specified amount of tokens on behalf of msg.sender\\r\\n\\t * and then call `onApprovalReceived` on spender.\\r\\n\\t * @param spender address The address which will spend the funds\\r\\n\\t * @param value uint256 The amount of tokens to be spent\\r\\n\\t * @param data bytes Additional data with no specified format, sent in call to `spender`\\r\\n\\t */\\r\\n\\tfunction approveAndCall(address spender, uint256 value, bytes memory data) external returns (bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC1363Receiver Interface\\r\\n *\\r\\n * @dev Interface for any contract that wants to support `transferAndCall` or `transferFromAndCall`\\r\\n *      from ERC1363 token contracts.\\r\\n */\\r\\ninterface ERC1363Receiver {\\r\\n\\t/*\\r\\n\\t * Note: the ERC-165 identifier for this interface is 0x88a7ca5c.\\r\\n\\t * 0x88a7ca5c === bytes4(keccak256(\\\"onTransferReceived(address,address,uint256,bytes)\\\"))\\r\\n\\t */\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Handle the receipt of ERC1363 tokens\\r\\n\\t *\\r\\n\\t * @dev Any ERC1363 smart contract calls this function on the recipient\\r\\n\\t *      after a `transfer` or a `transferFrom`. This function MAY throw to revert and reject the\\r\\n\\t *      transfer. Return of other than the magic value MUST result in the\\r\\n\\t *      transaction being reverted.\\r\\n\\t *      Note: the token contract address is always the message sender.\\r\\n\\t *\\r\\n\\t * @param operator address The address which called `transferAndCall` or `transferFromAndCall` function\\r\\n\\t * @param from address The address which are token transferred from\\r\\n\\t * @param value uint256 The amount of tokens transferred\\r\\n\\t * @param data bytes Additional data with no specified format\\r\\n\\t * @return `bytes4(keccak256(\\\"onTransferReceived(address,address,uint256,bytes)\\\"))`\\r\\n\\t *      unless throwing\\r\\n\\t */\\r\\n\\tfunction onTransferReceived(address operator, address from, uint256 value, bytes memory data) external returns (bytes4);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC1363Spender Interface\\r\\n *\\r\\n * @dev Interface for any contract that wants to support `approveAndCall`\\r\\n *      from ERC1363 token contracts.\\r\\n */\\r\\ninterface ERC1363Spender {\\r\\n\\t/*\\r\\n\\t * Note: the ERC-165 identifier for this interface is 0x7b04a2d0.\\r\\n\\t * 0x7b04a2d0 === bytes4(keccak256(\\\"onApprovalReceived(address,uint256,bytes)\\\"))\\r\\n\\t */\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Handle the approval of ERC1363 tokens\\r\\n\\t *\\r\\n\\t * @dev Any ERC1363 smart contract calls this function on the recipient\\r\\n\\t *      after an `approve`. This function MAY throw to revert and reject the\\r\\n\\t *      approval. Return of other than the magic value MUST result in the\\r\\n\\t *      transaction being reverted.\\r\\n\\t *      Note: the token contract address is always the message sender.\\r\\n\\t *\\r\\n\\t * @param owner address The address which called `approveAndCall` function\\r\\n\\t * @param value uint256 The amount of tokens to be spent\\r\\n\\t * @param data bytes Additional data with no specified format\\r\\n\\t * @return `bytes4(keccak256(\\\"onApprovalReceived(address,uint256,bytes)\\\"))`\\r\\n\\t *      unless throwing\\r\\n\\t */\\r\\n\\tfunction onApprovalReceived(address owner, uint256 value, bytes memory data) external returns (bytes4);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC165Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title ERC-165 Standard Interface Detection\\r\\n *\\r\\n * @dev Interface of the ERC165 standard, as defined in the\\r\\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\\r\\n *\\r\\n * @dev Implementers can declare support of contract interfaces,\\r\\n *      which can then be queried by others.\\r\\n *\\r\\n * @author Christian Reitwie\u00dfner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\\r\\n */\\r\\ninterface ERC165 {\\r\\n\\t/**\\r\\n\\t * @notice Query if a contract implements an interface\\r\\n\\t *\\r\\n\\t * @dev Interface identification is specified in ERC-165.\\r\\n\\t *      This function uses less than 30,000 gas.\\r\\n\\t *\\r\\n\\t * @param interfaceID The interface identifier, as specified in ERC-165\\r\\n\\t * @return `true` if the contract implements `interfaceID` and\\r\\n\\t *      `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n\\t */\\r\\n\\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC20Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title EIP-20: ERC-20 Token Standard\\r\\n *\\r\\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\\r\\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\\r\\n *\\r\\n * @notice It provides functionalities like to transfer tokens from one account to another,\\r\\n *      to get the current token balance of an account and also the total supply of the token available on the network.\\r\\n *      Besides these it also has some other functionalities like to approve that an amount of\\r\\n *      token from an account can be spent by a third party account.\\r\\n *\\r\\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\\r\\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\\r\\n *\\r\\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-20\\r\\n */\\r\\ninterface ERC20 {\\r\\n\\t/**\\r\\n\\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\\r\\n\\t *\\r\\n\\t * @param from an address tokens were consumed from\\r\\n\\t * @param to an address tokens were sent to\\r\\n\\t * @param value number of tokens transferred\\r\\n\\t */\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in approve() to indicate an approval event happened\\r\\n\\t *\\r\\n\\t * @param owner an address which granted a permission to transfer\\r\\n\\t *      tokens on its behalf\\r\\n\\t * @param spender an address which received a permission to transfer\\r\\n\\t *      tokens on behalf of the owner `_owner`\\r\\n\\t * @param value amount of tokens granted to transfer on behalf\\r\\n\\t */\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return name of the token (ex.: USD Coin)\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function name() external view returns (string memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return symbol of the token (ex.: USDC)\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function symbol() external view returns (string memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the number of decimals used to get its user representation.\\r\\n\\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n\\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n\\t *\\r\\n\\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\\r\\n\\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n\\t *      overridden;\\r\\n\\t *\\r\\n\\t * @dev NOTE: This information is only used for _display_ purposes: it in\\r\\n\\t *      no way affects any of the arithmetic of the contract, including\\r\\n\\t *      {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n\\t *\\r\\n\\t * @return token decimals\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function decimals() external view returns (uint8);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return the amount of tokens in existence\\r\\n\\t */\\r\\n\\tfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Gets the balance of a particular address\\r\\n\\t *\\r\\n\\t * @param _owner the address to query the the balance for\\r\\n\\t * @return balance an amount of tokens owned by the address specified\\r\\n\\t */\\r\\n\\tfunction balanceOf(address _owner) external view returns (uint256 balance);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens to an external address or a smart contract\\r\\n\\t *\\r\\n\\t * @dev Called by token owner (an address which has a\\r\\n\\t *      positive token balance tracked by this smart contract)\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * self address or\\r\\n\\t *          * smart contract which doesn't support ERC20\\r\\n\\t *\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      compliant with the ERC20 standard\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction transfer(address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\r\\n\\t *      to some other address `_to`\\r\\n\\t *\\r\\n\\t * @dev Called by token owner on his own or approved address,\\r\\n\\t *      an address approved earlier by token owner to\\r\\n\\t *      transfer some amount of tokens on its behalf\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * smart contract which doesn't support ERC20\\r\\n\\t *\\r\\n\\t * @param _from token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      compliant with the ERC20 standard\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Approves address called `_spender` to transfer some amount\\r\\n\\t *      of tokens on behalf of the owner (transaction sender)\\r\\n\\t *\\r\\n\\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\\r\\n\\t *\\r\\n\\t * @param _spender an address approved by the caller (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction approve(address _spender, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\\r\\n\\t *\\r\\n\\t * @dev A function to check an amount of tokens owner approved\\r\\n\\t *      to transfer on its behalf by some other address called \\\"spender\\\"\\r\\n\\t *\\r\\n\\t * @param _owner an address which approves transferring some tokens on its behalf\\r\\n\\t * @param _spender an address approved to transfer some tokens on behalf\\r\\n\\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\\r\\n\\t *      of token owner `_owner`\\r\\n\\t */\\r\\n\\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/ERC721Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"./ERC165Spec.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard\\r\\n *\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\r\\n *\\r\\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\\r\\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\\r\\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\\r\\n *      For example, a payable function in this interface may be implemented as nonpayable\\r\\n *      (no state mutability specified) in implementing contract.\\r\\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\\r\\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\\r\\n *      we have removed all \\\"payable\\\" modifiers.\\r\\n *\\r\\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\\r\\n *\\r\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\r\\n */\\r\\ninterface ERC721 is ERC165 {\\r\\n\\t/// @dev This emits when ownership of any NFT changes by any mechanism.\\r\\n\\t///  This event emits when NFTs are created (`from` == 0) and destroyed\\r\\n\\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\\r\\n\\t///  may be created and assigned without emitting Transfer. At the time of\\r\\n\\t///  any transfer, the approved address for that NFT (if any) is reset to none.\\r\\n\\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n\\r\\n\\t/// @dev This emits when the approved address for an NFT is changed or\\r\\n\\t///  reaffirmed. The zero address indicates there is no approved address.\\r\\n\\t///  When a Transfer event emits, this also indicates that the approved\\r\\n\\t///  address for that NFT (if any) is reset to none.\\r\\n\\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n\\r\\n\\t/// @dev This emits when an operator is enabled or disabled for an owner.\\r\\n\\t///  The operator can manage all NFTs of the owner.\\r\\n\\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n\\t/// @notice Count all NFTs assigned to an owner\\r\\n\\t/// @dev NFTs assigned to the zero address are considered invalid, and this\\r\\n\\t///  function throws for queries about the zero address.\\r\\n\\t/// @param _owner An address for whom to query the balance\\r\\n\\t/// @return The number of NFTs owned by `_owner`, possibly zero\\r\\n\\tfunction balanceOf(address _owner) external view returns (uint256);\\r\\n\\r\\n\\t/// @notice Find the owner of an NFT\\r\\n\\t/// @dev NFTs assigned to zero address are considered invalid, and queries\\r\\n\\t///  about them do throw.\\r\\n\\t/// @param _tokenId The identifier for an NFT\\r\\n\\t/// @return The address of the owner of the NFT\\r\\n\\tfunction ownerOf(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\r\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n\\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\r\\n\\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t///  `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t/// @param _from The current owner of the NFT\\r\\n\\t/// @param _to The new owner\\r\\n\\t/// @param _tokenId The NFT to transfer\\r\\n\\t/// @param _data Additional data with no specified format, sent in call to `_to`\\r\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\\r\\n\\r\\n\\t/// @notice Transfers the ownership of an NFT from one address to another address\\r\\n\\t/// @dev This works identically to the other function with an extra data parameter,\\r\\n\\t///  except this function just sets data to \\\"\\\".\\r\\n\\t/// @param _from The current owner of the NFT\\r\\n\\t/// @param _to The new owner\\r\\n\\t/// @param _tokenId The NFT to transfer\\r\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\r\\n\\r\\n\\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\r\\n\\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\r\\n\\t///  THEY MAY BE PERMANENTLY LOST\\r\\n\\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n\\t///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n\\t///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n\\t///  `_tokenId` is not a valid NFT.\\r\\n\\t/// @param _from The current owner of the NFT\\r\\n\\t/// @param _to The new owner\\r\\n\\t/// @param _tokenId The NFT to transfer\\r\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\\r\\n\\r\\n\\t/// @notice Change or reaffirm the approved address for an NFT\\r\\n\\t/// @dev The zero address indicates there is no approved address.\\r\\n\\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\r\\n\\t///  operator of the current owner.\\r\\n\\t/// @param _approved The new approved NFT controller\\r\\n\\t/// @param _tokenId The NFT to approve\\r\\n\\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\\r\\n\\r\\n\\t/// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n\\t///  all of `msg.sender`'s assets\\r\\n\\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\\r\\n\\t///  multiple operators per owner.\\r\\n\\t/// @param _operator Address to add to the set of authorized operators\\r\\n\\t/// @param _approved True if the operator is approved, false to revoke approval\\r\\n\\tfunction setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n\\t/// @notice Get the approved address for a single NFT\\r\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT.\\r\\n\\t/// @param _tokenId The NFT to find the approved address for\\r\\n\\t/// @return The approved address for this NFT, or the zero address if there is none\\r\\n\\tfunction getApproved(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n\\t/// @notice Query if an address is an authorized operator for another address\\r\\n\\t/// @param _owner The address that owns the NFTs\\r\\n\\t/// @param _operator The address that acts on behalf of the owner\\r\\n\\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\r\\n\\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\\r\\n}\\r\\n\\r\\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\\r\\ninterface ERC721TokenReceiver {\\r\\n\\t/// @notice Handle the receipt of an NFT\\r\\n\\t/// @dev The ERC721 smart contract calls this function on the recipient\\r\\n\\t///  after a `transfer`. This function MAY throw to revert and reject the\\r\\n\\t///  transfer. Return of other than the magic value MUST result in the\\r\\n\\t///  transaction being reverted.\\r\\n\\t///  Note: the contract address is always the message sender.\\r\\n\\t/// @param _operator The address which called `safeTransferFrom` function\\r\\n\\t/// @param _from The address which previously owned the token\\r\\n\\t/// @param _tokenId The NFT identifier which is being transferred\\r\\n\\t/// @param _data Additional data with no specified format\\r\\n\\t/// @return `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`\\r\\n\\t///  unless throwing\\r\\n\\tfunction onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns(bytes4);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\r\\n *\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\r\\n *\\r\\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\\r\\n *\\r\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\r\\n */\\r\\ninterface ERC721Metadata is ERC721 {\\r\\n\\t/// @notice A descriptive name for a collection of NFTs in this contract\\r\\n\\tfunction name() external view returns (string memory _name);\\r\\n\\r\\n\\t/// @notice An abbreviated name for NFTs in this contract\\r\\n\\tfunction symbol() external view returns (string memory _symbol);\\r\\n\\r\\n\\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\\r\\n\\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\\r\\n\\t///  3986. The URI may point to a JSON file that conforms to the \\\"ERC721\\r\\n\\t///  Metadata JSON Schema\\\".\\r\\n\\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\r\\n *\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-721\\r\\n *\\r\\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\\r\\n *\\r\\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\\r\\n */\\r\\ninterface ERC721Enumerable is ERC721 {\\r\\n\\t/// @notice Count NFTs tracked by this contract\\r\\n\\t/// @return A count of valid NFTs tracked by this contract, where each one of\\r\\n\\t///  them has an assigned and queryable owner not equal to the zero address\\r\\n\\tfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n\\t/// @notice Enumerate valid NFTs\\r\\n\\t/// @dev Throws if `_index` >= `totalSupply()`.\\r\\n\\t/// @param _index A counter less than `totalSupply()`\\r\\n\\t/// @return The token identifier for the `_index`th NFT,\\r\\n\\t///  (sort order not specified)\\r\\n\\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\\r\\n\\r\\n\\t/// @notice Enumerate NFTs assigned to an owner\\r\\n\\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\\r\\n\\t///  `_owner` is the zero address, representing invalid NFTs.\\r\\n\\t/// @param _owner An address where we are interested in NFTs owned by them\\r\\n\\t/// @param _index A counter less than `balanceOf(_owner)`\\r\\n\\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\\r\\n\\t///   (sort order not specified)\\r\\n\\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/TreeCoinERC721Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title Mintable ERC721\\r\\n *\\r\\n * @notice Defines mint capabilities for ERC721 tokens.\\r\\n *      This interface should be treated as a definition of what mintable means for ERC721\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\ninterface MintableERC721 {\\r\\n\\t/**\\r\\n\\t * @notice Checks if specified token exists\\r\\n\\t *\\r\\n\\t * @dev Returns whether the specified token ID has an ownership\\r\\n\\t *      information associated with it\\r\\n\\t *\\r\\n\\t * @param _tokenId ID of the token to query existence for\\r\\n\\t * @return whether the token exists (true - exists, false - doesn't exist)\\r\\n\\t */\\r\\n\\tfunction exists(uint256 _tokenId) external view returns(bool);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\r\\n\\t *      Prefer the use of `saveMint` instead of `mint`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t */\\r\\n\\tfunction mint(address _to, uint256 _tokenId) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\r\\n\\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint tokens to\\r\\n\\t * @param _tokenId ID of the first token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t */\\r\\n\\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t */\\r\\n\\tfunction safeMint(address _to, uint256 _tokenId) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\r\\n\\t */\\r\\n\\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t */\\r\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Should have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\r\\n\\t */\\r\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title Burnable ERC721\\r\\n *\\r\\n * @notice Defines burn capabilities for ERC721 tokens.\\r\\n *      This interface should be treated as a definition of what burnable means for ERC721\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\ninterface BurnableERC721 {\\r\\n\\t/**\\r\\n\\t * @notice Destroys the token with token ID specified\\r\\n\\t *\\r\\n\\t * @dev Should be accessible publicly by token owners.\\r\\n\\t *      May have a restricted access handled by the implementation\\r\\n\\t *\\r\\n\\t * @param _tokenId ID of the token to burn\\r\\n\\t */\\r\\n\\tfunction burn(uint256 _tokenId) external;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title With Base URI\\r\\n *\\r\\n * @notice A marker interface for the contracts having the baseURI() function\\r\\n *      or public string variable named baseURI\\r\\n *      NFT implementations like TinyERC721, or ShortERC721 are example of such smart contracts\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\ninterface WithBaseURI {\\r\\n\\t/**\\r\\n\\t * @dev Usually used in NFT implementations to construct ERC721Metadata.tokenURI as\\r\\n\\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\\r\\n\\t *\\r\\n\\t * @dev For example, if base URI is https://api.com/token/, then token #1\\r\\n\\t *      will have an URI https://api.com/token/1\\r\\n\\t */\\r\\n\\tfunction baseURI() external view returns(string memory);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/AddressUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title Address Utils\\r\\n *\\r\\n * @dev Utility library of inline functions on addresses\\r\\n *\\r\\n * @dev Copy of the Zeppelin's library:\\r\\n *      https://github.com/gnosis/openzeppelin-solidity/blob/master/contracts/AddressUtils.sol\\r\\n */\\r\\nlibrary AddressUtils {\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if the target address is a contract\\r\\n\\t *\\r\\n\\t * @dev It is unsafe to assume that an address for which this function returns\\r\\n\\t *      false is an externally-owned account (EOA) and not a contract.\\r\\n\\t *\\r\\n\\t * @dev Among others, `isContract` will return false for the following\\r\\n\\t *      types of addresses:\\r\\n\\t *        - an externally-owned account\\r\\n\\t *        - a contract in construction\\r\\n\\t *        - an address where a contract will be created\\r\\n\\t *        - an address where a contract lived, but was destroyed\\r\\n\\t *\\r\\n\\t * @param addr address to check\\r\\n\\t * @return whether the target address is a contract\\r\\n\\t */\\r\\n\\tfunction isContract(address addr) internal view returns (bool) {\\r\\n\\t\\t// a variable to load `extcodesize` to\\r\\n\\t\\tuint256 size = 0;\\r\\n\\r\\n\\t\\t// XXX Currently there is no better way to check if there is a contract in an address\\r\\n\\t\\t// than to check the size of the code at that address.\\r\\n\\t\\t// See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\\r\\n\\t\\t// TODO: Check this again before the Serenity release, because all addresses will be contracts.\\r\\n\\t\\t// solium-disable-next-line security/no-inline-assembly\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\t// retrieve the size of the code at address `addr`\\r\\n\\t\\t\\tsize := extcodesize(addr)\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// positive size indicates a smart contract address\\r\\n\\t\\treturn size > 0;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/ArrayUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title Array Utils\\r\\n *\\r\\n * @notice Solidity doesn't always work with arrays in an optimal way.\\r\\n *      This library collects functions helping to optimize gas usage\\r\\n *      when working with arrays in Solidity.\\r\\n *\\r\\n * @dev One of the most important use cases for arrays is \\\"tight\\\" arrays -\\r\\n *      arrays which store values significantly less than 256-bits numbers\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\nlibrary ArrayUtils {\\r\\n\\t/**\\r\\n\\t * @dev Pushes `n` 32-bits values sequentially into storage allocated array `data`\\r\\n\\t *      starting from the 32-bits value `v0`\\r\\n\\t *\\r\\n\\t * @dev Optimizations comparing to non-assembly implementation:\\r\\n\\t *      - reads+writes to array size slot only once (instead of `n` times)\\r\\n\\t *      - reads from the array data slots only once (instead of `7n/8` times)\\r\\n\\t *      - writes into array data slots `n/8` times (instead of `n` times)\\r\\n\\t *\\r\\n\\t * @dev Maximum gas saving estimate: ~3n sstore, or 15,000 * n\\r\\n\\t *\\r\\n\\t * @param data storage array pointer to an array of 32-bits elements\\r\\n\\t * @param v0 first number to push into the array\\r\\n\\t * @param n number of values to push, pushes [v0, ..., v0 + n - 1]\\r\\n\\t */\\r\\n\\tfunction push32(uint32[] storage data, uint32 v0, uint32 n) internal {\\r\\n\\t\\t// we're going to write 32-bits values into 256-bits storage slots of the array\\r\\n\\t\\t// each 256-slot can store up to 8 32-bits sub-blocks, it can also be partially empty\\r\\n\\t\\tassembly {\\r\\n\\t\\t\\t// for dynamic arrays their slot (array.slot) contains the array length\\r\\n\\t\\t\\t// array data is stored separately in consequent storage slots starting\\r\\n\\t\\t\\t// from the slot with the address keccak256(array.slot)\\r\\n\\r\\n\\t\\t\\t// read the array length into `len` and increase it by `n`\\r\\n\\t\\t\\tlet len := sload(data.slot)\\r\\n\\t\\t\\tsstore(data.slot, add(len, n))\\r\\n\\r\\n\\t\\t\\t// find where to write elements and store this location into `loc`\\r\\n\\t\\t\\t// load array storage slot number into memory onto position 0,\\r\\n\\t\\t\\t// calculate the keccak256 of the slot number (first 32 bytes at position 0)\\r\\n\\t\\t\\t// - this will point to the beginning of the array,\\r\\n\\t\\t\\t// so we add array length divided by 8 to point to the last array slot\\r\\n\\t\\t\\tmstore(0, data.slot)\\r\\n\\t\\t\\tlet loc := add(keccak256(0, 32), div(len, 8))\\r\\n\\r\\n\\t\\t\\t// if we start writing data into already partially occupied slot (`len % 8 != 0`)\\r\\n\\t\\t\\t// we need to modify the contents of that slot: read it and rewrite it\\r\\n\\t\\t\\tlet offset := mod(len, 8)\\r\\n\\t\\t\\tif not(iszero(offset)) {\\r\\n\\t\\t\\t\\t// how many 32-bits sub-blocks left in the slot\\r\\n\\t\\t\\t\\tlet left := sub(8, offset)\\r\\n\\t\\t\\t\\t// update the `left` value not to exceed `n`\\r\\n\\t\\t\\t\\tif gt(left, n) { left := n }\\r\\n\\t\\t\\t\\t// load the contents of the first slot (partially occupied)\\r\\n\\t\\t\\t\\tlet v256 := sload(loc)\\r\\n\\t\\t\\t\\t// write the slot in 32-bits sub-blocks\\r\\n\\t\\t\\t\\tfor { let j := 0 } lt(j, left) { j := add(j, 1) } {\\r\\n\\t\\t\\t\\t\\t// write sub-block `j` at offset: `(j + offset) * 32` bits, length: 32-bits\\r\\n\\t\\t\\t\\t\\t// v256 |= (v0 + j) << (j + offset) * 32\\r\\n\\t\\t\\t\\t\\tv256 := or(v256, shl(mul(add(j, offset), 32), add(v0, j)))\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t// write first slot back, it can be still partially occupied, it can also be full\\r\\n\\t\\t\\t\\tsstore(loc, v256)\\r\\n\\t\\t\\t\\t// update `loc`: move to the next slot\\r\\n\\t\\t\\t\\tloc := add(loc, 1)\\r\\n\\t\\t\\t\\t// update `v0`: increment by number of values pushed\\r\\n\\t\\t\\t\\tv0 := add(v0, left)\\r\\n\\t\\t\\t\\t// update `n`: decrement by number of values pushed\\r\\n\\t\\t\\t\\tn := sub(n, left)\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// rest of the slots (if any) are empty and will be only written to\\r\\n\\t\\t\\t// write the array in 256-bits (8x32) slots\\r\\n\\t\\t\\t// `i` iterates [0, n) with the 256-bits step, which is 8 taken `n` is 32-bits long\\r\\n\\t\\t\\tfor { let i := 0 } lt(i, n) { i := add(i, 8) } {\\r\\n\\t\\t\\t\\t// how many 32-bits sub-blocks left in the slot\\r\\n\\t\\t\\t\\tlet left := 8\\r\\n\\t\\t\\t\\t// update the `left` value not to exceed `n`\\r\\n\\t\\t\\t\\tif gt(left, n) { left := n }\\r\\n\\t\\t\\t\\t// init the 256-bits slot value\\r\\n\\t\\t\\t\\tlet v256 := 0\\r\\n\\t\\t\\t\\t// write the slot in 32-bits sub-blocks\\r\\n\\t\\t\\t\\tfor { let j := 0 } lt(j, left) { j := add(j, 1) } {\\r\\n\\t\\t\\t\\t\\t// write sub-block `j` at offset: `j * 32` bits, length: 32-bits\\r\\n\\t\\t\\t\\t\\t// v256 |= (v0 + i + j) << j * 32\\r\\n\\t\\t\\t\\t\\tv256 := or(v256, shl(mul(j, 32), add(v0, add(i, j))))\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t\\t// write slot `i / 8`\\r\\n\\t\\t\\t\\tsstore(add(loc, div(i, 8)), v256)\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\r\\n *\\r\\n * These functions can be used to verify that a message was signed by the holder\\r\\n * of the private keys of a given address.\\r\\n *\\r\\n * @dev Copy of the Zeppelin's library:\\r\\n *      https://github.com/OpenZeppelin/openzeppelin-contracts/blob/b0cf6fbb7a70f31527f36579ad644e1cf12fdf4e/contracts/utils/cryptography/ECDSA.sol\\r\\n */\\r\\nlibrary ECDSA {\\r\\n\\t/**\\r\\n\\t * @dev Returns the address that signed a hashed message (`hash`) with\\r\\n\\t * `signature`. This address can then be used for verification purposes.\\r\\n\\t *\\r\\n\\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\r\\n\\t * this function rejects them by requiring the `s` value to be in the lower\\r\\n\\t * half order, and the `v` value to be either 27 or 28.\\r\\n\\t *\\r\\n\\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\r\\n\\t * verification to be secure: it is possible to craft signatures that\\r\\n\\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\r\\n\\t * this is by receiving a hash of the original message (which may otherwise\\r\\n\\t * be too long), and then calling {toEthSignedMessageHash} on it.\\r\\n\\t *\\r\\n\\t * Documentation for signature generation:\\r\\n\\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\r\\n\\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\r\\n\\t */\\r\\n\\tfunction recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\r\\n\\t\\t// Divide the signature in r, s and v variables\\r\\n\\t\\tbytes32 r;\\r\\n\\t\\tbytes32 s;\\r\\n\\t\\tuint8 v;\\r\\n\\r\\n\\t\\t// Check the signature length\\r\\n\\t\\t// - case 65: r,s,v signature (standard)\\r\\n\\t\\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\r\\n\\t\\tif (signature.length == 65) {\\r\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\r\\n\\t\\t\\t// currently is to use assembly.\\r\\n\\t\\t\\tassembly {\\r\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\r\\n\\t\\t\\t\\ts := mload(add(signature, 0x40))\\r\\n\\t\\t\\t\\tv := byte(0, mload(add(signature, 0x60)))\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\telse if (signature.length == 64) {\\r\\n\\t\\t\\t// ecrecover takes the signature parameters, and the only way to get them\\r\\n\\t\\t\\t// currently is to use assembly.\\r\\n\\t\\t\\tassembly {\\r\\n\\t\\t\\t\\tlet vs := mload(add(signature, 0x40))\\r\\n\\t\\t\\t\\tr := mload(add(signature, 0x20))\\r\\n\\t\\t\\t\\ts := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\r\\n\\t\\t\\t\\tv := add(shr(255, vs), 27)\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\trevert(\\\"invalid signature length\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\treturn recover(hash, v, r, s);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Overload of {ECDSA-recover} that receives the `v`,\\r\\n\\t * `r` and `s` signature fields separately.\\r\\n\\t */\\r\\n\\tfunction recover(\\r\\n\\t\\tbytes32 hash,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) internal pure returns (address) {\\r\\n\\t\\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\r\\n\\t\\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\r\\n\\t\\t// the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\\r\\n\\t\\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\\r\\n\\t\\t//\\r\\n\\t\\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\r\\n\\t\\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\r\\n\\t\\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\r\\n\\t\\t// these malleable signatures as well.\\r\\n\\t\\trequire(\\r\\n\\t\\t\\tuint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\r\\n\\t\\t\\t\\\"invalid signature 's' value\\\"\\r\\n\\t\\t);\\r\\n\\t\\trequire(v == 27 || v == 28, \\\"invalid signature 'v' value\\\");\\r\\n\\r\\n\\t\\t// If the signature is valid (and not malleable), return the signer address\\r\\n\\t\\taddress signer = ecrecover(hash, v, r, s);\\r\\n\\t\\trequire(signer != address(0), \\\"invalid signature\\\");\\r\\n\\r\\n\\t\\treturn signer;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\r\\n\\t * produces hash corresponding to the one signed with the\\r\\n\\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\r\\n\\t * JSON-RPC method as part of EIP-191.\\r\\n\\t *\\r\\n\\t * See {recover}.\\r\\n\\t */\\r\\n\\tfunction toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\r\\n\\t\\t// 32 is the length in bytes of hash,\\r\\n\\t\\t// enforced by the type signature above\\r\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns an Ethereum Signed Typed Data, created from a\\r\\n\\t * `domainSeparator` and a `structHash`. This produces hash corresponding\\r\\n\\t * to the one signed with the\\r\\n\\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\r\\n\\t * JSON-RPC method as part of EIP-712.\\r\\n\\t *\\r\\n\\t * See {recover}.\\r\\n\\t */\\r\\n\\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\r\\n\\t\\treturn keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/StringUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title String Utils Library\\r\\n *\\r\\n * @dev Library for working with strings, primarily converting\\r\\n *      between strings and integer types\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\nlibrary StringUtils {\\r\\n\\t/**\\r\\n\\t * @dev Converts a string to unsigned integer using the specified `base`\\r\\n\\t * @dev Throws on invalid input\\r\\n\\t *      (wrong characters for a given `base`)\\r\\n\\t * @dev Throws if given `base` is not supported\\r\\n\\t * @param a string to convert\\r\\n\\t * @param base number base, one of 2, 8, 10, 16\\r\\n\\t * @return i a number representing given string\\r\\n\\t */\\r\\n\\tfunction atoi(string memory a, uint8 base) internal pure returns (uint256 i) {\\r\\n\\t\\t// check if the base is valid\\r\\n\\t\\trequire(base == 2 || base == 8 || base == 10 || base == 16);\\r\\n\\r\\n\\t\\t// convert string into bytes for convenient iteration\\r\\n\\t\\tbytes memory buf = bytes(a);\\r\\n\\r\\n\\t\\t// iterate over the string (bytes buffer)\\r\\n\\t\\tfor(uint256 p = 0; p < buf.length; p++) {\\r\\n\\t\\t\\t// extract the digit\\r\\n\\t\\t\\tuint8 digit = uint8(buf[p]) - 0x30;\\r\\n\\r\\n\\t\\t\\t// if digit is greater then 10 - mind the gap\\r\\n\\t\\t\\t// see `itoa` function for more details\\r\\n\\t\\t\\tif(digit > 10) {\\r\\n\\t\\t\\t\\t// remove the gap\\r\\n\\t\\t\\t\\tdigit -= 7;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// check if digit meets the base\\r\\n\\t\\t\\trequire(digit < base);\\r\\n\\r\\n\\t\\t\\t// move to the next digit slot\\r\\n\\t\\t\\ti *= base;\\r\\n\\r\\n\\t\\t\\t// add digit to the result\\r\\n\\t\\t\\ti += digit;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// return the result\\r\\n\\t\\treturn i;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Converts a integer to a string using the specified `base`\\r\\n\\t * @dev Throws if given `base` is not supported\\r\\n\\t * @param i integer to convert\\r\\n\\t * @param base number base, one of 2, 8, 10, 16\\r\\n\\t * @return a a string representing given integer\\r\\n\\t */\\r\\n\\tfunction itoa(uint256 i, uint8 base) internal pure returns (string memory a) {\\r\\n\\t\\t// check if the base is valid\\r\\n\\t\\trequire(base == 2 || base == 8 || base == 10 || base == 16);\\r\\n\\r\\n\\t\\t// for zero input the result is \\\"0\\\" string for any base\\r\\n\\t\\tif(i == 0) {\\r\\n\\t\\t\\treturn \\\"0\\\";\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// bytes buffer to put ASCII characters into\\r\\n\\t\\tbytes memory buf = new bytes(256);\\r\\n\\r\\n\\t\\t// position within a buffer to be used in cycle\\r\\n\\t\\tuint256 p = 0;\\r\\n\\r\\n\\t\\t// extract digits one by one in a cycle\\r\\n\\t\\twhile(i > 0) {\\r\\n\\t\\t\\t// extract current digit\\r\\n\\t\\t\\tuint8 digit = uint8(i % base);\\r\\n\\r\\n\\t\\t\\t// convert it to an ASCII code\\r\\n\\t\\t\\t// 0x20 is \\\" \\\"\\r\\n\\t\\t\\t// 0x30-0x39 is \\\"0\\\"-\\\"9\\\"\\r\\n\\t\\t\\t// 0x41-0x5A is \\\"A\\\"-\\\"Z\\\"\\r\\n\\t\\t\\t// 0x61-0x7A is \\\"a\\\"-\\\"z\\\" (\\\"A\\\"-\\\"Z\\\" XOR \\\" \\\")\\r\\n\\t\\t\\tuint8 ascii = digit + 0x30;\\r\\n\\r\\n\\t\\t\\t// if digit is greater then 10,\\r\\n\\t\\t\\t// fix the 0x3A-0x40 gap of punctuation marks\\r\\n\\t\\t\\t// (7 characters in ASCII table)\\r\\n\\t\\t\\tif(digit >= 10) {\\r\\n\\t\\t\\t\\t// jump through the gap\\r\\n\\t\\t\\t\\tascii += 7;\\r\\n\\t\\t\\t}\\r\\n\\r\\n\\t\\t\\t// write character into the buffer\\r\\n\\t\\t\\tbuf[p++] = bytes1(ascii);\\r\\n\\r\\n\\t\\t\\t// move to the next digit\\r\\n\\t\\t\\ti /= base;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// `p` contains real length of the buffer now,\\r\\n\\t\\t// allocate the resulting buffer of that size\\r\\n\\t\\tbytes memory result = new bytes(p);\\r\\n\\r\\n\\t\\t// copy the buffer in the reversed order\\r\\n\\t\\tfor(p = 0; p < result.length; p++) {\\r\\n\\t\\t\\t// copy from the beginning of the original buffer\\r\\n\\t\\t\\t// to the end of resulting smaller buffer\\r\\n\\t\\t\\tresult[result.length - p - 1] = buf[p];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// construct string and return\\r\\n\\t\\treturn string(result);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Concatenates two strings `s1` and `s2`, for example, if\\r\\n\\t *      `s1` == `foo` and `s2` == `bar`, the result `s` == `foobar`\\r\\n\\t * @param s1 first string\\r\\n\\t * @param s2 second string\\r\\n\\t * @return s concatenation result s1 + s2\\r\\n\\t */\\r\\n\\tfunction concat(string memory s1, string memory s2) internal pure returns (string memory s) {\\r\\n\\t\\t// an old way of string concatenation (Solidity 0.4) is commented out\\r\\n/*\\r\\n\\t\\t// convert s1 into buffer 1\\r\\n\\t\\tbytes memory buf1 = bytes(s1);\\r\\n\\t\\t// convert s2 into buffer 2\\r\\n\\t\\tbytes memory buf2 = bytes(s2);\\r\\n\\t\\t// create a buffer for concatenation result\\r\\n\\t\\tbytes memory buf = new bytes(buf1.length + buf2.length);\\r\\n\\r\\n\\t\\t// copy buffer 1 into buffer\\r\\n\\t\\tfor(uint256 i = 0; i < buf1.length; i++) {\\r\\n\\t\\t\\tbuf[i] = buf1[i];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// copy buffer 2 into buffer\\r\\n\\t\\tfor(uint256 j = buf1.length; j < buf2.length; j++) {\\r\\n\\t\\t\\tbuf[j] = buf2[j - buf1.length];\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// construct string and return\\r\\n\\t\\treturn string(buf);\\r\\n*/\\r\\n\\r\\n\\t\\t// simply use built in function\\r\\n\\t\\treturn string(abi.encodePacked(s1, s2));\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/PatchFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./XCCERC20.sol\\\";\\r\\nimport \\\"./PatchOwnershipNFT.sol\\\";\\r\\nimport \\\"../interfaces/EIP3009.sol\\\";\\r\\nimport \\\"../utils/UpgradeableAccessControl.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Treecoin Patch Factory\\r\\n *\\r\\n * @notice When creating an new Patch, Patch details will be registerd and OwnershipNFT token will\\r\\n *      be created using this smart contract.\\r\\n *      An OwnershipNFT will be sent to one primary owner of Patch and later Owner will distribute\\r\\n *\\t \\tPatch Ownership token to all other sub-owner of Patch.\\r\\n */\\r\\ncontract PatchFactory is UpgradeableAccessControl {\\r\\n\\r\\n\\t/// @dev Patch Token address list\\r\\n\\taddress[] public patchTokenList;\\r\\n\\r\\n\\t/// @dev Patch Token Mapping by index of PatchID\\r\\n\\tmapping(uint256 => address) public patchTokenbyPatchID;\\r\\n\\r\\n    /// @dev Patch Token Mapping by index of PatchID\\r\\n\\tmapping(address => uint256) public patchIDbyPatchToken;\\r\\n\\r\\n    /// @dev Patch Event Mapping by index of PatchID\\r\\n\\tmapping(uint256 => PatchEventInfo[]) public patchEventDetails;\\r\\n\\r\\n\\t/// @dev Patch Details Mapping by index of PatchID\\r\\n\\tmapping(uint256 => PatchInfo) public patchDetails;\\r\\n\\r\\n\\t/// @dev Treasury Wallet address where XCC token will be sent\\r\\n\\taddress public treasuryWallet;\\r\\n\\r\\n    /// @dev Registered Patch Count\\r\\n    uint256 public totalPatchRegistered;\\r\\n\\r\\n\\t/// @dev XCC-G token contract address\\r\\n\\taddress public XCC_Gold;\\r\\n\\r\\n    /// @dev XCC-S token contract address\\r\\n\\taddress public XCC_Silver;\\r\\n\\r\\n    /// @dev XCC-B token contract address\\r\\n\\taddress public XCC_Bronze;\\r\\n\\r\\n\\t/// @dev Enables config manager to edit configurable parameters\\r\\n\\tuint32 public constant ROLE_CONFIG_MANAGER = 0x0001_0000;\\r\\n\\r\\n\\t/// @dev Enables token manager to update role for PatchOwnerShip token\\r\\n\\tuint32 public constant ROLE_PO_TOKEN_MANAGER = 0x0002_0000;\\r\\n\\r\\n\\t/// @dev Enables token manager to update role for PatchOwnerShip token\\r\\n\\tuint32 public constant ROLE_PATCH_REGISTRY_MANAGER = 0x0004_0000;\\r\\n\\r\\n\\t/// @dev Enables token manager to update role for PatchOwnerShip token\\r\\n\\tuint32 public constant ROLE_PATCH_EVENT_MANAGER = 0x0008_0000;\\r\\n\\r\\n\\t/// @dev Struct to store Patch information\\r\\n\\tstruct PatchInfo {\\r\\n\\t\\tuint256 patchId;\\r\\n        string patchName;\\r\\n        string patchDetailURI;\\r\\n\\t\\taddress patchInitialOwner;\\r\\n        address ownershipTokenAddress;\\r\\n        uint256 noOfEventRegistered;\\r\\n\\t\\tuint256 patchRegistrationTime;\\r\\n\\t\\tuint256 totalCO2OffSet;\\r\\n\\t\\tuint256 treePlantedArea;\\r\\n\\t\\tuint256 treeVolume;\\r\\n        bool isPatchActive;\\r\\n\\t\\tuint256[][] patchGeoFenceDetails;\\r\\n\\t}\\r\\n\\r\\n    /// @dev Struct to store Patch Event information\\r\\n\\tstruct PatchEventInfo {\\r\\n        uint256 patchId;\\r\\n        uint256 co2OffsetAmt;\\r\\n        uint256 eventPeriod;\\r\\n\\t\\taddress emitedToken;\\r\\n        uint256 emittedTokenAmt;\\r\\n        uint256 eventRegistrationTime;\\r\\n\\t\\tuint256 oldTreeVolume;\\r\\n\\t\\tuint256 newTreeVolume;\\r\\n        uint256 khatamReportId;\\r\\n        string khatamReportURI;\\r\\n\\t}\\r\\n\\r\\n\\t/// @dev PatchRegistered event will be emit from registerPatch() function\\r\\n\\tevent PatchRegistered(\\r\\n\\t\\t\\t\\taddress indexed _user,\\r\\n\\t\\t\\t\\tuint256 indexed _patchId,\\r\\n\\t\\t\\t\\tstring _patchName,\\r\\n\\t\\t\\t\\tstring _patchDetailURI,\\r\\n\\t\\t\\t\\tuint256 _treePlantedArea,\\r\\n\\t\\t\\t\\tuint256 _treeVolume,\\r\\n\\t\\t\\t\\taddress _initialOwner,\\r\\n\\t\\t\\t\\taddress _ownershipTokenAddr,\\r\\n\\t\\t\\t\\tuint256[][] _patchGeoFenceDetails,\\r\\n\\t\\t\\t\\tuint256 _patchRegisterationTime\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t/// @dev PatchEventRegistered event will be emit from registerEvent() function\\r\\n\\tevent PatchEventRegistered(\\r\\n\\t\\t\\t\\taddress indexed _user,\\r\\n\\t\\t\\t\\tuint256 indexed _patchId,\\r\\n\\t\\t\\t\\tuint256 _co2OffsetAmt,\\r\\n\\t\\t\\t\\tuint256 _treeVolume,\\r\\n\\t\\t\\t\\tuint256 _eventPeriod,\\r\\n\\t\\t\\t\\taddress _emitedToken,\\r\\n\\t\\t\\t\\tuint256 _emittedTokenAmt,\\r\\n\\t\\t\\t\\tuint256 _eventRegistrationTime\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t/// @dev PatchDeactivated event will be emit from deactivatePatch() function\\r\\n\\tevent PatchDeactivated(\\r\\n\\t\\t\\t\\taddress indexed _user,\\r\\n\\t\\t\\t\\tuint256 indexed _patchId\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t/// @dev PatchActivated event will be emit from activatePatch() function\\r\\n\\tevent PatchActivated(\\r\\n\\t\\t\\t\\taddress indexed _user,\\r\\n\\t\\t\\t\\tuint256 indexed _patchId\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t/// @dev PatchDetailsUpdated event will be emit from updatePatchDetails() function\\r\\n\\tevent PatchDetailsUpdated(\\r\\n\\t\\t\\t\\taddress indexed _user,\\r\\n\\t\\t\\t\\tuint256 indexed _patchId,\\r\\n\\t\\t\\t\\tstring _patchName,\\r\\n\\t\\t\\t\\tstring _patchDetailURI,\\r\\n\\t\\t\\t\\tuint256 _treePlantedArea,\\r\\n\\t\\t\\t\\tuint256 _treeVolume,\\r\\n\\t\\t\\t\\tuint256[][] _patchGeoFenceDetails\\r\\n\\t\\t\\t);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev \\\"Constructor replacement\\\" for upgradeable, must be execute immediately after deployment\\r\\n\\t *\\t  see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\\r\\n\\t *\\r\\n\\t * @dev Binds PatchFactory instance to already deployed\\r\\n\\t *\\t  XCC-G, XCC-S and XCC-B token instances\\r\\n\\t *\\r\\n\\t * @param _xccGold address of deployed XCC_GOLD token\\r\\n\\t * @param _xccSilver address of deployed XCC_SILVER token\\r\\n\\t * @param _xccBronze address of deployed XCC_BRONZE token\\r\\n\\t * @param _treasuryWallet address of treasury where XCC token will be sent\\r\\n\\t */\\r\\n\\tfunction postConstruct(\\r\\n\\t\\taddress _xccGold,\\r\\n\\t\\taddress _xccSilver,\\r\\n\\t\\taddress _xccBronze,\\r\\n\\t\\taddress _treasuryWallet\\r\\n\\t) public virtual initializer {\\r\\n\\t\\trequire(_xccGold != address(0), \\\"_xccGold address is not set\\\");\\r\\n\\t\\trequire(_xccSilver != address(0), \\\"_xccSilver address is not set\\\");\\r\\n\\t\\trequire(_xccBronze != address(0), \\\"_xccBronze address is not set\\\");\\r\\n\\t\\trequire(_treasuryWallet != address(0), \\\"_treasuryWallet address is not set\\\");\\r\\n\\r\\n\\t\\t// update smart contract internal state\\r\\n\\t\\tXCC_Gold = _xccGold;\\r\\n\\t\\tXCC_Silver = _xccSilver;\\r\\n\\t\\tXCC_Bronze = _xccBronze;\\r\\n\\t\\ttreasuryWallet = _treasuryWallet;\\r\\n\\t\\t\\r\\n\\t\\t// execute all parent initializers in cascade\\r\\n\\t\\tUpgradeableAccessControl._postConstruct(msg.sender);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates the role for given ownershipToken\\r\\n\\t * @param _ownershipToken Token address\\r\\n\\t * @param _to address of user to grant a role\\r\\n\\t * @param _role bitmask representing a set of permissions to\\r\\n\\t *\\t\\t enable/disable for a user specified\\r\\n\\t */\\r\\n\\tfunction updateTokenRole(address _ownershipToken, address _to, uint256 _role) public virtual {\\r\\n\\t\\t// verify executor is allowed to share token  roles\\r\\n\\t\\trequire(isSenderInRole(ROLE_PO_TOKEN_MANAGER), \\\"access denied\\\");\\r\\n\\t\\t// verify executor has the roles they want to share\\r\\n\\t\\trequire(isSenderInRole(_role), \\\"no role\\\");\\r\\n\\r\\n\\t\\t// execute role update\\r\\n\\t\\tPatchOwnershipNFT(_ownershipToken).updateRole(_to, _role);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates XCC Token address\\r\\n\\t * @param _xccToken Token address\\r\\n\\t * @param _type token type(1: XCC-GOld/2: XCC-Silver/3: XCC-Bronze)\\r\\n\\t */\\r\\n\\tfunction updateXccToken(address _xccToken, uint256 _type) public virtual {\\r\\n\\t\\t// verify executor is allowed to share token  roles\\r\\n\\t\\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \\\"access denied\\\");\\r\\n\\t\\t\\r\\n\\t\\tif (_type == 1) {\\r\\n\\t\\t\\tXCC_Gold = _xccToken;\\r\\n\\t\\t} else if (_type == 2) {\\r\\n\\t\\t\\tXCC_Silver = _xccToken;\\r\\n\\t\\t} else if (_type ==3 ) {\\r\\n\\t\\t\\tXCC_Bronze = _xccToken;\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\t\\t\\r\\n\\t/**\\r\\n\\t * @notice Register the new Patch\\r\\n\\t * @param _patchName Name of Patch\\r\\n\\t * @param _patchDetailURI patch detail URI link\\r\\n\\t * @param _ownershipTokenAddr Ownership NFT token Address\\r\\n\\t * @param _treePlantedArea tree planted Area in metric\\r\\n\\t * @param _treeVolume planted tree Volume\\r\\n\\t * @param _initialOwner address of Patch Initial owner on which O-NFT token will be minted\\r\\n\\t * @param _patchGeoFenceDetails patch geo fense details\\r\\n\\t * @return (uint256) PatchId of newly register patch\\r\\n\\t */\\r\\n\\tfunction registerPatch(\\r\\n\\t\\tstring memory _patchName,\\r\\n\\t\\tstring memory _patchDetailURI,\\r\\n\\t\\tuint256 _treePlantedArea,\\r\\n\\t\\tuint256 _treeVolume,\\r\\n\\t\\taddress _ownershipTokenAddr,\\r\\n\\t\\taddress _initialOwner,\\r\\n\\t\\tuint256[][] memory _patchGeoFenceDetails\\r\\n\\t) public virtual returns (uint256) {\\r\\n\\r\\n\\t\\t// check if caller has sufficient permissions to mint tokens\\r\\n\\t\\trequire(isSenderInRole(ROLE_PATCH_REGISTRY_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\trequire(bytes(_patchName).length != 0, \\\"Invalid _patchName!!\\\");\\r\\n\\t\\trequire(bytes(_patchDetailURI).length != 0, \\\"Invalid _patchDetailURI!!\\\");\\r\\n\\t\\trequire(_ownershipTokenAddr != address(0), \\\"Invalid _ownershipTokenAddr\\\");\\r\\n\\t\\trequire(_initialOwner != address(0), \\\"Invalid _initialOwner!!\\\");\\r\\n\\t\\trequire(_patchGeoFenceDetails.length != 0, \\\"Invalid _patchGeoFenceDetails!!\\\");\\r\\n\\r\\n\\t\\tMintableERC721(_ownershipTokenAddr).mintBatch(_initialOwner, 1, 100);\\r\\n\\r\\n\\t\\tPatchInfo memory newPatch;\\r\\n\\t\\tnewPatch.patchName = _patchName;\\r\\n\\t\\tnewPatch.patchDetailURI = _patchDetailURI;\\r\\n\\t\\tnewPatch.treePlantedArea = _treePlantedArea;\\r\\n\\t\\tnewPatch.treeVolume = _treeVolume;\\r\\n\\t\\tnewPatch.patchGeoFenceDetails = _patchGeoFenceDetails;\\r\\n\\t\\tnewPatch.patchInitialOwner = _initialOwner;\\r\\n\\t\\tnewPatch.ownershipTokenAddress = _ownershipTokenAddr;\\r\\n\\t\\tnewPatch.patchRegistrationTime = block.timestamp;\\r\\n\\t\\tnewPatch.isPatchActive = true;\\r\\n\\t\\tnewPatch.noOfEventRegistered = 0;\\r\\n\\r\\n\\t\\ttotalPatchRegistered++;\\r\\n\\t\\tnewPatch.patchId = totalPatchRegistered;\\r\\n\\t\\tpatchTokenList.push(_ownershipTokenAddr);\\r\\n\\r\\n\\t\\tpatchTokenbyPatchID[newPatch.patchId] = _ownershipTokenAddr;\\r\\n\\t\\tpatchIDbyPatchToken[_ownershipTokenAddr] = newPatch.patchId;\\r\\n\\r\\n\\t\\tpatchDetails[newPatch.patchId] = newPatch;\\r\\n\\r\\n\\t\\temit PatchRegistered(msg.sender,\\r\\n\\t\\t\\t\\t\\t\\t\\tnewPatch.patchId,\\r\\n\\t\\t\\t\\t\\t\\t\\t_patchName,\\r\\n\\t\\t\\t\\t\\t\\t\\t_patchDetailURI,\\r\\n\\t\\t\\t\\t\\t\\t\\t_treePlantedArea,\\r\\n\\t\\t\\t\\t\\t\\t\\t_treeVolume,\\r\\n\\t\\t\\t\\t\\t\\t\\t_initialOwner,\\r\\n\\t\\t\\t\\t\\t\\t\\t_ownershipTokenAddr,\\r\\n\\t\\t\\t\\t\\t\\t\\t_patchGeoFenceDetails,\\r\\n\\t\\t\\t\\t\\t\\t\\tblock.timestamp);\\r\\n\\r\\n\\t\\treturn totalPatchRegistered;\\r\\n\\t}\\r\\n  \\r\\n\\t/**\\r\\n\\t * @notice Register the new Event\\r\\n\\t * @param _patchId Name of Patch\\r\\n\\t * @param _co2OffsetAmt CO2 Offseted in particular period of event\\r\\n\\t * @param _treeVolume tree volume planted on land\\r\\n\\t * @param _eventPeriod Recorded Event Period\\r\\n\\t * @param _emitedToken token address which will be release for particular event(XCC-G/XCC-S/XCC-B)\\r\\n\\t * @param _emittedTokenAmt emited token Amount\\r\\n\\t * @param _eventRegistrationTime Event registration time\\r\\n\\t * @param _khatamReportId Khatam report ID \\r\\n\\t * @param _khatamReportURI Khatam report URI\\r\\n\\t */\\r\\n\\tfunction registerEvent(\\r\\n\\t\\tuint256 _patchId,\\r\\n\\t\\tuint256 _co2OffsetAmt,\\r\\n\\t\\tuint256 _treeVolume,\\r\\n\\t\\tuint256 _eventPeriod,\\r\\n\\t\\taddress _emitedToken,\\r\\n\\t\\tuint256 _emittedTokenAmt,\\r\\n\\t\\tuint256 _eventRegistrationTime,\\r\\n\\t\\tuint256 _khatamReportId,\\r\\n\\t\\tstring memory _khatamReportURI\\r\\n\\t) public virtual {\\r\\n\\r\\n\\t\\t// check if caller has sufficient permissions to mint tokens\\r\\n\\t\\trequire(isSenderInRole(ROLE_PATCH_EVENT_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\trequire(_patchId <= totalPatchRegistered,\\\"Invalid PatchId!!\\\");\\r\\n\\t\\trequire(patchDetails[_patchId].isPatchActive, \\\"Patch is In-Active!!\\\");\\r\\n\\t\\trequire(_co2OffsetAmt > 0, \\\"Invalid _co2OffsetAmt!!\\\");\\r\\n\\t\\trequire(_eventPeriod > 0, \\\"Invalid _eventPeriod!!\\\");\\r\\n\\t\\trequire(_emitedToken == XCC_Gold ||\\r\\n\\t\\t\\t\\t_emitedToken == XCC_Silver ||\\r\\n\\t\\t\\t\\t_emitedToken == XCC_Bronze, \\\"Invalid _emitedToken!!\\\");\\r\\n\\t\\trequire(_emittedTokenAmt > 0 , \\\"Invalid _emittedTokenAmt!!\\\");\\r\\n\\t\\trequire(_eventRegistrationTime > patchDetails[_patchId].patchRegistrationTime, \\\"Invalid _eventRegistrationTime!!\\\");\\t\\r\\n\\r\\n\\t\\tPatchEventInfo memory newEvent;\\r\\n\\t\\tnewEvent.patchId = _patchId;\\r\\n\\t\\tnewEvent.co2OffsetAmt = _co2OffsetAmt;\\r\\n\\t\\tnewEvent.oldTreeVolume = patchDetails[_patchId].treeVolume;\\r\\n\\t\\tnewEvent.newTreeVolume = _treeVolume;\\r\\n\\t\\tnewEvent.eventPeriod = _eventPeriod;\\r\\n\\t\\tnewEvent.emitedToken = _emitedToken;\\r\\n\\t\\tnewEvent.emittedTokenAmt = _emittedTokenAmt;\\r\\n\\t\\tnewEvent.eventRegistrationTime = _eventRegistrationTime;\\r\\n\\t\\tnewEvent.khatamReportId = _khatamReportId;\\r\\n\\t\\tnewEvent.khatamReportURI = _khatamReportURI;\\r\\n\\r\\n\\t\\tpatchDetails[_patchId].noOfEventRegistered++;\\r\\n\\t\\tpatchDetails[_patchId].totalCO2OffSet += _co2OffsetAmt;\\r\\n\\t\\tpatchDetails[_patchId].treeVolume = _treeVolume;\\r\\n\\t\\tpatchEventDetails[_patchId].push(newEvent);\\r\\n\\r\\n\\t\\tXCCERC20(_emitedToken).mint(treasuryWallet, _emittedTokenAmt);\\r\\n\\r\\n\\t\\temit PatchEventRegistered(msg.sender,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_patchId,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_co2OffsetAmt,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_treeVolume,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_eventPeriod,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_emitedToken,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_emittedTokenAmt,\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t_eventRegistrationTime\\r\\n\\t\\t\\t\\t\\t\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Register the new Event in Batch\\r\\n\\t * @param _patchId Name of Patch\\r\\n\\t * @param _co2OffsetAmt CO2 Offseted in particular period of event\\r\\n\\t * @param _treeVolume tree volume planted on land\\r\\n\\t * @param _eventPeriod Recorded Event Period\\r\\n\\t * @param _emitedToken token address which will be release for particular event(XCC-G/XCC-S/XCC-B)\\r\\n\\t * @param _emittedTokenAmt emited token Amount\\r\\n\\t * @param _eventRegistrationTime Event registration time\\r\\n\\t * @param _khatamReportId Khatam report ID \\r\\n\\t * @param _khatamReportURI Khatam report URI\\r\\n\\t */\\r\\n\\tfunction registerEventInBatch(\\r\\n\\t\\tuint256[] memory _patchId,\\r\\n\\t\\tuint256[] memory _co2OffsetAmt,\\r\\n\\t\\tuint256[] memory _treeVolume,\\r\\n\\t\\tuint256[] memory _eventPeriod,\\r\\n\\t\\taddress[] memory _emitedToken,\\r\\n\\t\\tuint256[] memory _emittedTokenAmt,\\r\\n\\t\\tuint256[] memory _eventRegistrationTime,\\r\\n\\t\\tuint256[] memory _khatamReportId,\\r\\n\\t\\tstring[] memory _khatamReportURI\\r\\n\\t) public virtual {\\r\\n\\t\\tfor (uint256 i = 0; i < _patchId.length; i++) {\\r\\n\\t\\t\\tregisterEvent(_patchId[i],\\r\\n\\t\\t\\t\\t\\t\\t_co2OffsetAmt[i],\\r\\n\\t\\t\\t\\t\\t\\t_treeVolume[i],\\r\\n\\t\\t\\t\\t\\t\\t_eventPeriod[i],\\r\\n\\t\\t\\t\\t\\t\\t_emitedToken[i],\\r\\n\\t\\t\\t\\t\\t\\t_emittedTokenAmt[i],\\r\\n\\t\\t\\t\\t\\t\\t_eventRegistrationTime[i],\\r\\n\\t\\t\\t\\t\\t\\t_khatamReportId[i],\\r\\n\\t\\t\\t\\t\\t\\t_khatamReportURI[i]);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice De-active/De-register patch\\r\\n\\t * @param _patchId Patch ID\\r\\n\\t **/\\r\\n\\tfunction deactivatePatch(\\r\\n\\t\\tuint256 _patchId\\r\\n\\t) public virtual {\\r\\n\\t\\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\trequire(_patchId <= totalPatchRegistered,\\\"Invalid PatchId!!\\\");\\r\\n\\t\\trequire(patchDetails[_patchId].isPatchActive, \\\"Patch is In-Active!!\\\");\\r\\n\\r\\n\\t\\tpatchDetails[_patchId].isPatchActive = false;\\r\\n\\r\\n\\t\\temit PatchDeactivated(msg.sender, _patchId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice active/Re-register patch\\r\\n\\t * @param _patchId Patch ID\\r\\n\\t **/\\r\\n\\tfunction activatePatch(\\r\\n\\t\\tuint256 _patchId\\r\\n\\t) public virtual {\\r\\n\\t\\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\trequire(_patchId <= totalPatchRegistered,\\\"Invalid PatchId!!\\\");\\r\\n\\t\\trequire(!patchDetails[_patchId].isPatchActive, \\\"Patch is Active!!\\\");\\r\\n\\r\\n\\t\\tpatchDetails[_patchId].isPatchActive = true;\\r\\n\\r\\n\\t\\temit PatchActivated(msg.sender, _patchId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates Tree-coin treasury wallet\\r\\n\\t * @param _treasuryWallet New treasury wallet address\\r\\n\\t **/\\r\\n\\tfunction updateTreasuryWallet(\\r\\n\\t\\taddress _treasuryWallet\\r\\n\\t) public virtual {\\r\\n\\t\\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \\\"access denied\\\");\\r\\n\\t\\trequire(_treasuryWallet != address(0), \\\"Invalid _treasuryWallet address!!\\\");\\r\\n\\r\\n\\t\\ttreasuryWallet = _treasuryWallet;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates Patch details\\r\\n\\t * @param _patchId Patch ID\\r\\n\\t * @param _patchName Name of Patch\\r\\n\\t * @param _patchDetailURI patch detail URI link\\r\\n\\t * @param _treePlantedArea tree planted Area in metric\\r\\n\\t * @param _treeVolume planted tree Volume\\r\\n\\t * @param _patchGeoFenceDetails patch geo fense details\\r\\n\\t **/\\r\\n\\tfunction updatePatchDetails(\\r\\n\\t\\tuint256 _patchId,\\r\\n\\t\\tstring memory _patchName,\\r\\n\\t\\tstring memory _patchDetailURI,\\r\\n\\t\\tuint256 _treePlantedArea,\\r\\n\\t\\tuint256 _treeVolume,\\r\\n\\t\\tuint256[][] memory _patchGeoFenceDetails\\r\\n\\t) public virtual {\\r\\n\\t\\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\trequire(_patchId <= totalPatchRegistered,\\\"Invalid PatchId!!\\\");\\r\\n\\t\\trequire(patchDetails[_patchId].isPatchActive, \\\"Patch is In-Active!!\\\");\\r\\n\\r\\n\\t\\tif (bytes(_patchName).length != 0) {\\r\\n\\t\\t\\tpatchDetails[_patchId].patchName = _patchName;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (bytes(_patchDetailURI).length != 0) {\\r\\n\\t\\t\\tpatchDetails[_patchId].patchDetailURI = _patchDetailURI;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (_treePlantedArea != 0) {\\r\\n\\t\\t\\tpatchDetails[_patchId].treePlantedArea = _treePlantedArea;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (_treeVolume !=0 ) {\\r\\n\\t\\t\\tpatchDetails[_patchId].treeVolume = _treeVolume;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\tif (_patchGeoFenceDetails.length != 0) {\\r\\n\\t\\t\\tpatchDetails[_patchId].patchGeoFenceDetails = _patchGeoFenceDetails;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\temit PatchDetailsUpdated(msg.sender,\\r\\n\\t\\t\\t\\t\\t\\t\\t_patchId,\\r\\n\\t\\t\\t\\t\\t\\t\\t_patchName,\\r\\n\\t\\t\\t\\t\\t\\t\\t_patchDetailURI,\\r\\n\\t\\t\\t\\t\\t\\t\\t_treePlantedArea,\\r\\n\\t\\t\\t\\t\\t\\t\\t_treeVolume,\\r\\n\\t\\t\\t\\t\\t\\t\\t_patchGeoFenceDetails\\r\\n\\t\\t\\t\\t\\t\\t);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Get length of token address list created\\r\\n\\t * @return (uint256) Returns the token address list length\\r\\n\\t */\\r\\n\\tfunction getTokenListLength() external view virtual returns (uint256) {\\r\\n\\t\\treturn patchTokenList.length;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Get Patch geo-fence details\\r\\n\\t * @param  _patchId patchId of patch\\r\\n\\t * @return (uint256[][]) Returns the 2-d array contain geo-fence details\\r\\n\\t */\\r\\n\\tfunction getPatchGeoFenceDetails(uint256 _patchId) external view virtual returns (uint256[][] memory) {\\r\\n\\t\\treturn patchDetails[_patchId].patchGeoFenceDetails;\\r\\n\\t}\\r\\n}\"\r\n    },\r\n    \"contracts/token/PatchFactoryHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.4;\\r\\n\\r\\nimport \\\"./PatchOwnershipNFT.sol\\\";\\r\\nimport \\\"./PatchFactory.sol\\\";\\r\\nimport \\\"../lib/AddressUtils.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Treecoin Patch Factory Helper\\r\\n *\\r\\n * @notice When creating an new Patch, Patch details will be registerd and OwnershipNFT token will\\r\\n *      be created using this smart contract.\\r\\n *      An OwnershipNFT will be sent to one primary owner of Patch and later Owner will distribute\\r\\n *\\t \\tPatch Ownership token to all other sub-owner of Patch.\\r\\n */\\r\\ncontract PatchFactoryHelper is AccessControl {\\r\\n\\r\\n    /// @dev Patch Factory contract address\\r\\n    address public patchFactory;\\r\\n\\r\\n    /// @dev Enables user configuration for token creation\\r\\n    uint32 public constant ROLE_PATCH_REGISTERY_MANAGER = 0x0001_0000;\\r\\n\\r\\n    /// @dev Enables config manager to edit configurable parameters\\r\\n\\tuint32 public constant ROLE_CONFIG_MANAGER = 0x0002_0000;\\r\\n\\r\\n\\t/// @dev Bitmask representing all the possible permissions (super admin role)\\r\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\r\\n\\r\\n    /**\\r\\n\\t * @dev Deploys the Patch Factory Helper smart contract.\\r\\n\\t *\\r\\n\\t * @param _patchFactory Patch Factory contract address\\r\\n\\t */\\r\\n\\tconstructor(address _patchFactory) {\\r\\n        require(_patchFactory != address(0x0), \\\"Invalid _patchFactory!!\\\");\\r\\n\\r\\n        patchFactory = _patchFactory;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n\\t * @notice Register the new Patch\\r\\n\\t * @param _patchName Name of Patch\\r\\n\\t * @param _patchDetailURI patch detail URI link\\r\\n     * @param _treePlantedArea tree planted Area in metric\\r\\n     * @param _plantedTreeVolume planted tree Volume\\r\\n\\t * @param _initialOwner address of Patch Initial owner on which O-NFT token will be minted\\r\\n\\t * @param _patchGeoFenseDetails patch geo fense details\\r\\n     * @return (uint256) PatchId of new Patch\\r\\n\\t * @return (address) Patch ownership Token address\\r\\n\\t */\\r\\n\\tfunction registerPatch(\\r\\n\\t\\tstring memory _patchName,\\r\\n\\t\\tstring memory _patchDetailURI,\\r\\n        uint256 _treePlantedArea,\\r\\n        uint256 _plantedTreeVolume,\\r\\n\\t\\taddress _initialOwner,\\r\\n\\t\\tuint256[][] memory _patchGeoFenseDetails\\r\\n\\t) public virtual returns (uint256, address) {\\r\\n\\r\\n        // check if caller has sufficient permissions to mint tokens\\r\\n\\t\\trequire(isSenderInRole(ROLE_PATCH_REGISTERY_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n        address O_NFTAddr = address(new PatchOwnershipNFT(\\\"OwnershipToken\\\", \\\"O-NFT\\\"));\\r\\n        require(O_NFTAddr != address(0), \\\"Failed to create Ownership NFT token!!\\\");\\r\\n\\r\\n        // Give full privilage to patch factory contract\\r\\n        PatchOwnershipNFT(O_NFTAddr).updateRole(patchFactory, FULL_PRIVILEGES_MASK);\\r\\n        // Revoke all privilage of Factory Helper\\r\\n        PatchOwnershipNFT(O_NFTAddr).updateRole(address(this), 0);\\r\\n\\r\\n        uint256 patchId = PatchFactory(patchFactory).registerPatch(_patchName,\\r\\n                                                 _patchDetailURI, \\r\\n                                                 _treePlantedArea,\\r\\n                                                 _plantedTreeVolume,\\r\\n                                                 O_NFTAddr, \\r\\n                                                 _initialOwner, \\r\\n                                                 _patchGeoFenseDetails\\r\\n                                                );\\r\\n        return (patchId, O_NFTAddr);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n\\t * @notice update factroy contract address\\r\\n\\t * @param _newPatchFactory New patch factory address\\r\\n\\t */\\r\\n\\tfunction updatePatchFactory(\\r\\n\\t\\taddress _newPatchFactory\\r\\n\\t) public virtual {\\r\\n\\r\\n        // check if caller has sufficient permissions to mint tokens\\r\\n\\t\\trequire(isSenderInRole(ROLE_CONFIG_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n        require(_newPatchFactory != address(0), \\\"Invalid _newPatchFactory!!\\\");\\r\\n\\r\\n        patchFactory = _newPatchFactory;\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/token/PatchOwnershipNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\nimport \\\"./TinyERC721.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Patch Ownership NFT \\r\\n *\\r\\n * @notice Patch Ownership NFT is an ERC721 token used as landed holding identity\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\ncontract PatchOwnershipNFT is TinyERC721 {\\r\\n\\r\\n\\t/// @dev Bitmask representing all the possible features\\r\\n\\tuint256 private constant FULL_FEATURE_MASK = 0xFFFF;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Constructs/deploys ERC721 with the name and symbol specified\\r\\n\\t *\\r\\n\\t * @param _name name of the token to be accessible as `name()`,\\r\\n\\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\\r\\n\\t * @param _symbol token symbol to be accessible as `symbol()`,\\r\\n\\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\\r\\n\\t */\\r\\n\\tconstructor(string memory _name, string memory _symbol) TinyERC721(_name, _symbol) {\\r\\n\\t\\t// Enable all features of Patch Ownership contract\\r\\n        updateFeatures(FULL_FEATURE_MASK);\\t\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/TinyERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"../interfaces/ERC721Spec.sol\\\";\\r\\nimport \\\"../interfaces/TreeCoinERC721Spec.sol\\\";\\r\\nimport \\\"../lib/AddressUtils.sol\\\";\\r\\nimport \\\"../lib/ArrayUtils.sol\\\";\\r\\nimport \\\"../lib/StringUtils.sol\\\";\\r\\nimport \\\"../lib/ECDSA.sol\\\";\\r\\nimport \\\"../utils/AccessControl.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Tiny ERC721\\r\\n *\\r\\n * @notice Tiny ERC721 defines an NFT with a very small (up to 32 bits) ID space.\\r\\n *      ERC721 enumeration support requires additional writes to the storage:\\r\\n *      - when transferring a token in order to update the NFT collections of\\r\\n *        the previous and next owners,\\r\\n *      - when minting/burning a token in order to update global NFT collection\\r\\n *\\r\\n * @notice Reducing NFT ID space to 32 bits allows\\r\\n *      - to eliminate the need to have and to write to two additional storage mappings\\r\\n *        (also achievable with the 48 bits ID space)\\r\\n *      - for batch minting optimization by writing 8 tokens instead of 5 at once into\\r\\n *        global/local collections\\r\\n *\\r\\n * @notice This smart contract is designed to be inherited by concrete implementations,\\r\\n *      which are expected to define token metadata, auxiliary functions to access the metadata,\\r\\n *      and explicitly define token minting interface, which should be built on top\\r\\n *      of current smart contract internal interface\\r\\n *\\r\\n * @notice Fully ERC721-compatible with all optional interfaces implemented (metadata, enumeration),\\r\\n *      see https://eips.ethereum.org/EIPS/eip-721\\r\\n *\\r\\n * @dev ERC721: contract has passed adopted OpenZeppelin ERC721 tests\\r\\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/ERC721.behavior.js\\r\\n *        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/test/token/ERC721/extensions/ERC721URIStorage.test.js\\r\\n *\\r\\n * @dev A note on token URI: there are major differences on how token URI behaves comparing to Zeppelin impl:\\r\\n *      1. A token URI can be set for non-existing token for pre-allocation purposes,\\r\\n *         still the URI will be deleted once token is burnt\\r\\n *      2. If token URI is set, base URI has no affect on the token URI, the two are not concatenated,\\r\\n *         base URI is used to construct the token URI only if the latter was not explicitly set\\r\\n *\\r\\n * @dev Supports EIP-712 powered permits - permit() - approve() with signature.\\r\\n *      Supports EIP-712 powered operator permits - permitForAll() - setApprovalForAll() with signature.\\r\\n *\\r\\n * @dev EIP712 Domain:\\r\\n *      name: PatchERC721\\r\\n *      version: not in use, omitted (name already contains version)\\r\\n *      chainId: EIP-155 chain id\\r\\n *      verifyingContract: deployed contract address\\r\\n *      salt: permitNonces[owner], where owner is an address which allows operation on their tokens\\r\\n *\\r\\n * @dev Permit type:\\r\\n *      owner: address\\r\\n *      operator: address\\r\\n *      tokenId: uint256\\r\\n *      nonce: uint256\\r\\n *      deadline: uint256\\r\\n *\\r\\n * @dev Permit typeHash:\\r\\n *        keccak256(\\\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\\\")\\r\\n *\\r\\n * @dev PermitForAll type:\\r\\n *      owner: address\\r\\n *      operator: address\\r\\n *      approved: bool\\r\\n *      nonce: uint256\\r\\n *      deadline: uint256\\r\\n *\\r\\n * @dev PermitForAll typeHash:\\r\\n *        keccak256(\\\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\\\")\\r\\n *\\r\\n * @dev See https://eips.ethereum.org/EIPS/eip-712\\r\\n * @dev See usage examples in tests: erc721_permits.js\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\nabstract contract TinyERC721 is ERC721Enumerable, ERC721Metadata, WithBaseURI, MintableERC721, BurnableERC721, AccessControl {\\r\\n\\t// enable push32 optimization for uint32[]\\r\\n\\tusing ArrayUtils for uint32[];\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice ERC-20 compatible descriptive name for a collection of NFTs in this contract\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC721Metadata\\r\\n\\t */\\r\\n\\tstring public override name;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice ERC-20 compatible abbreviated name for a collection of NFTs in this contract\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC721Metadata\\r\\n\\t */\\r\\n\\tstring public override symbol;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Current implementation includes a function `decimals` that returns uint8(0)\\r\\n\\t *      to be more compatible with ERC-20\\r\\n\\t *\\r\\n\\t * @dev ERC20 compliant token decimals is equal to zero since ERC721 token is non-fungible\\r\\n\\t *      and therefore non-divisible\\r\\n\\t */\\r\\n\\tuint8 public constant decimals = 0;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Ownership information for all the tokens in existence\\r\\n\\t *\\r\\n\\t * @dev Maps `Token ID => Token ID Global Index | Token ID Local Index | Token Owner Address`, where\\r\\n\\t *      - Token ID Global Index denotes Token ID index in the array of all the tokens,\\r\\n\\t *      - Token ID Local Index denotes Token ID index in the array of all the tokens owned by the owner,\\r\\n\\t *      - Token ID indexes are 32 bits long,\\r\\n\\t *      - `|` denotes bitwise concatenation of the values\\r\\n\\t * @dev Token Owner Address for a given Token ID is lower 160 bits of the mapping value\\r\\n\\t */\\r\\n\\tmapping(uint256 => uint256) internal tokens;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enumerated collections of the tokens owned by particular owners\\r\\n\\t *\\r\\n\\t * @dev We call these collections \\\"Local\\\" token collections\\r\\n\\t *\\r\\n\\t * @dev Maps `Token Owner Address => Owned Token IDs Array`\\r\\n\\t *\\r\\n\\t * @dev Token owner balance is the length of their token collection:\\r\\n\\t *      `balanceOf(owner) = collections[owner].length`\\r\\n\\t */\\r\\n\\tmapping(address => uint32[]) internal collections;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice An array of all the tokens in existence\\r\\n\\t *\\r\\n\\t * @dev We call this collection \\\"Global\\\" token collection\\r\\n\\t *\\r\\n\\t * @dev Array with all Token IDs, used for enumeration\\r\\n\\t *\\r\\n\\t * @dev Total token supply `tokenSupply` is the length of this collection:\\r\\n\\t *      `totalSupply() = allTokens.length`\\r\\n\\t */\\r\\n\\tuint32[] internal allTokens;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Mapping from tokenId to last snap time\\r\\n\\t *\\r\\n\\t * @dev Store timestamp of transfer event of particular tokenId\\r\\n\\t */\\r\\n    mapping(uint256 => uint256) public _lastSnap;\\r\\n    \\r\\n\\t/**\\r\\n\\t * @notice Mapping from tokenId to epoch index\\r\\n\\t *\\r\\n\\t * @dev Store counter of number of transfered event of \\r\\n\\t *\\t\\tparticular tokenId\\r\\n\\t */\\r\\n    mapping(uint256 => uint256) public _generatedEpochs;\\r\\n    \\r\\n\\t/**\\r\\n\\t * @notice Mapping from TokenId to epoch data of index\\r\\n\\t *\\r\\n\\t * @dev Store counter of number of transfered event of \\r\\n\\t *\\t\\tparticular tokenId\\r\\n\\t */\\r\\n    mapping(uint256 => mapping(uint256 => Epoch)) public _epochData;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Sturcture which hold token transfer details\\r\\n\\t *\\r\\n\\t * @dev Epoch Data will be used to transfer token holding time, \\r\\n\\t *\\t\\tbased on which XCC will be distributed.\\r\\n\\t */\\r\\n    struct Epoch {\\r\\n        uint256 start;\\r\\n        uint256 end;\\r\\n        address HolderAddr;\\r\\n    }\\r\\n\\t\\r\\n\\t/**\\r\\n\\t * @notice Addresses approved by token owners to transfer their tokens\\r\\n\\t *\\r\\n\\t * @dev `Maps Token ID => Approved Address`, where\\r\\n\\t *      Approved Address is an address allowed transfer ownership for the token\\r\\n\\t *      defined by Token ID\\r\\n\\t */\\r\\n\\tmapping(uint256 => address) internal approvals;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Addresses approved by token owners to transfer all their tokens\\r\\n\\t *\\r\\n\\t * @dev Maps `Token Owner Address => Operator Address => Approval State` - true/false (approved/not), where\\r\\n\\t *      - Token Owner Address is any address which may own tokens or not,\\r\\n\\t *      - Operator Address is any other address which may own tokens or not,\\r\\n\\t *      - Approval State is a flag indicating if Operator Address is allowed to\\r\\n\\t *        transfer tokens owned by Token Owner Address o their behalf\\r\\n\\t */\\r\\n\\tmapping(address => mapping(address => bool)) internal approvedOperators;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev A record of nonces for signing/validating signatures in EIP-712 based\\r\\n\\t *      `permit` and `permitForAll` functions\\r\\n\\t *\\r\\n\\t * @dev Each time the nonce is used, it is increased by one, meaning reordering\\r\\n\\t *      of the EIP-712 transactions is not possible\\r\\n\\t *\\r\\n\\t * @dev Inspired by EIP-2612 extension for ERC20 token standard\\r\\n\\t *\\r\\n\\t * @dev Maps token owner address => token owner nonce\\r\\n\\t */\\r\\n\\tmapping(address => uint256) public permitNonces;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\\r\\n\\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\\r\\n\\t *\\r\\n\\t * @dev For example, if base URI is https://api.com/token/, then token #1\\r\\n\\t *      will have an URI https://api.com/token/1\\r\\n\\t *\\r\\n\\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\\r\\n\\t */\\r\\n\\tstring public override baseURI = \\\"\\\";\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Optional mapping for token URIs to be returned as is when `tokenURI()`\\r\\n\\t *      is called; if mapping doesn't exist for token, the URI is constructed\\r\\n\\t *      as `base URI + token ID`, where plus (+) denotes string concatenation\\r\\n\\t */\\r\\n\\tmapping(uint256 => string) internal _tokenURIs;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev 32 bit token ID space is optimal for batch minting in batches of size 8\\r\\n\\t *      8 * 32 = 256 - single storage slot in global/local collection(s)\\r\\n\\t */\\r\\n\\tuint8 public constant BATCH_SIZE_MULTIPLIER = 8;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables ERC721 transfers of the tokens\\r\\n\\t *      (transfer by the token owner himself)\\r\\n\\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\\r\\n\\t *      `transferFrom()` function to succeed when executed by token owner\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables ERC721 transfers on behalf\\r\\n\\t *      (transfer by someone else on behalf of token owner)\\r\\n\\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\\r\\n\\t *      `transferFrom()` function to succeed whe executed by approved operator\\r\\n\\t * @dev Token owner must call `approve()` or `setApprovalForAll()`\\r\\n\\t *      first to authorize the transfer on behalf\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables token owners to burn their own tokens\\r\\n\\t *\\r\\n\\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\\r\\n\\t *      `burn()` function to succeed when called by token owner\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0004;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables approved operators to burn tokens on behalf of their owners\\r\\n\\t *\\r\\n\\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\\r\\n\\t *      `burn()` function to succeed when called by approved operator\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0008;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables approvals on behalf (permits via an EIP712 signature)\\r\\n\\t * @dev Feature FEATURE_PERMITS must be enabled in order for\\r\\n\\t *      `permit()` function to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_PERMITS = 0x0000_0010;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables operator approvals on behalf (permits for all via an EIP712 signature)\\r\\n\\t * @dev Feature FEATURE_OPERATOR_PERMITS must be enabled in order for\\r\\n\\t *      `permitForAll()` function to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_OPERATOR_PERMITS = 0x0000_0020;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Token creator is responsible for creating (minting)\\r\\n\\t *      tokens to an arbitrary address\\r\\n\\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\\r\\n\\t *      (calling `mint` function)\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Token destroyer is responsible for destroying (burning)\\r\\n\\t *      tokens owned by an arbitrary address\\r\\n\\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\\r\\n\\t *      (calling `burn` function)\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice URI manager is responsible for managing base URI\\r\\n\\t *      part of the token URI ERC721Metadata interface\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\\r\\n\\t *      (executing `setBaseURI` function)\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_URI_MANAGER = 0x0004_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract's domain typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t *\\r\\n\\t * @dev Note: we do not include version into the domain typehash/separator,\\r\\n\\t *      it is implied version is concatenated to the name field, like \\\"PatchERC721\\\"\\r\\n\\t */\\r\\n\\t// keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\")\\r\\n\\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract's domain separator,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t */\\r\\n\\tbytes32 public immutable DOMAIN_SEPARATOR;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"Permit(address owner,address operator,uint256 tokenId,uint256 nonce,uint256 deadline)\\\")\\r\\n\\tbytes32 public constant PERMIT_TYPEHASH = 0xee2282d7affd5a432b221a559e429129347b0c19a3f102179a5fb1859eef3d29;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 permitForAll (EIP-2612) struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\\\")\\r\\n\\tbytes32 public constant PERMIT_FOR_ALL_TYPEHASH = 0x47ab88482c90e4bb94b82a947ae78fa91fb25de1469ab491f4c15b9a0a2677ee;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in setBaseURI()\\r\\n\\t *\\r\\n\\t * @param _by an address which executed update\\r\\n\\t * @param _oldVal old _baseURI value\\r\\n\\t * @param _newVal new _baseURI value\\r\\n\\t */\\r\\n\\tevent BaseURIUpdated(address indexed _by, string _oldVal, string _newVal);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in setTokenURI()\\r\\n\\t *\\r\\n\\t * @param _by an address which executed update\\r\\n\\t * @param _tokenId token ID which URI was updated\\r\\n\\t * @param _oldVal old _baseURI value\\r\\n\\t * @param _newVal new _baseURI value\\r\\n\\t */\\r\\n\\tevent TokenURIUpdated(address indexed _by, uint256 _tokenId, string _oldVal, string _newVal);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Constructs/deploys ERC721 instance with the name and symbol specified\\r\\n\\t *\\r\\n\\t * @param _name name of the token to be accessible as `name()`,\\r\\n\\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\\r\\n\\t * @param _symbol token symbol to be accessible as `symbol()`,\\r\\n\\t *      ERC-20 compatible descriptive name for a collection of NFTs in this contract\\r\\n\\t */\\r\\n\\tconstructor(string memory _name, string memory _symbol) {\\r\\n\\t\\t// set the name\\r\\n\\t\\tname = _name;\\r\\n\\r\\n\\t\\t// set the symbol\\r\\n\\t\\tsymbol = _symbol;\\r\\n\\r\\n\\t\\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t\\t// note: we specify contract version in its name\\r\\n\\t\\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"PatchERC721\\\")), block.chainid, address(this)));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Verifies if token is transferable (i.e. can change ownership, allowed to be transferred);\\r\\n\\t *      The default behaviour is to always allow transfer if token exists\\r\\n\\t *\\r\\n\\t * @dev Implementations may modify the default behaviour based on token metadata\\r\\n\\t *      if required\\r\\n\\t *\\r\\n\\t * @param _tokenId ID of the token to check if it's transferable\\r\\n\\t * @return true if token is transferable, false otherwise\\r\\n\\t */\\r\\n\\tfunction isTransferable(uint256 _tokenId) public view virtual returns(bool) {\\r\\n\\t\\t// validate token existence\\r\\n\\t\\trequire(exists(_tokenId), \\\"token doesn't exist\\\");\\r\\n\\r\\n\\t\\t// generic implementation returns true if token exists\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if specified token exists\\r\\n\\t *\\r\\n\\t * @dev Returns whether the specified token ID has an ownership\\r\\n\\t *      information associated with it\\r\\n\\t *\\r\\n\\t * @inheritdoc MintableERC721\\r\\n\\t *\\r\\n\\t * @param _tokenId ID of the token to query existence for\\r\\n\\t * @return whether the token exists (true - exists, false - doesn't exist)\\r\\n\\t */\\r\\n\\tfunction exists(uint256 _tokenId) public override view returns(bool) {\\r\\n\\t\\t// read ownership information and return a check if it's not zero (set)\\r\\n\\t\\treturn tokens[_tokenId] != 0;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC165\\r\\n\\t */\\r\\n\\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n\\t\\t// construct the interface support from required and optional ERC721 interfaces\\r\\n\\t\\treturn interfaceId == type(ERC165).interfaceId\\r\\n\\t\\t\\t|| interfaceId == type(ERC721).interfaceId\\r\\n\\t\\t\\t|| interfaceId == type(ERC721Metadata).interfaceId\\r\\n\\t\\t\\t|| interfaceId == type(ERC721Enumerable).interfaceId\\r\\n\\t\\t\\t|| interfaceId == type(MintableERC721).interfaceId\\r\\n\\t\\t\\t|| interfaceId == type(BurnableERC721).interfaceId;\\r\\n\\t}\\r\\n\\r\\n\\t// ===== Start: ERC721 Metadata =====\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Restricted access function which updates base URI used to construct\\r\\n\\t *      ERC721Metadata.tokenURI\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have ROLE_URI_MANAGER permission\\r\\n\\t *\\r\\n\\t * @param _baseURI new base URI to set\\r\\n\\t */\\r\\n\\tfunction setBaseURI(string memory _baseURI) public virtual {\\r\\n\\t\\t// verify the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_URI_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// emit an event first - to log both old and new values\\r\\n\\t\\temit BaseURIUpdated(msg.sender, baseURI, _baseURI);\\r\\n\\r\\n\\t\\t// and update base URI\\r\\n\\t\\tbaseURI = _baseURI;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns token URI if it was previously set with `setTokenURI`,\\r\\n\\t *      otherwise constructs it as base URI + token ID\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC721Metadata\\r\\n\\t */\\r\\n\\tfunction tokenURI(uint256 _tokenId) public view override returns (string memory) {\\r\\n\\t\\t// verify token exists\\r\\n\\t\\trequire(exists(_tokenId), \\\"token doesn't exist\\\");\\r\\n\\r\\n\\t\\t// read the token URI for the token specified\\r\\n\\t\\tstring memory _tokenURI = _tokenURIs[_tokenId];\\r\\n\\r\\n\\t\\t// if token URI is set\\r\\n\\t\\tif(bytes(_tokenURI).length > 0) {\\r\\n\\t\\t\\t// just return it\\r\\n\\t\\t\\treturn _tokenURI;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// if base URI is not set\\r\\n\\t\\tif(bytes(baseURI).length == 0) {\\r\\n\\t\\t\\t// return an empty string\\r\\n\\t\\t\\treturn \\\"\\\";\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// otherwise concatenate base URI + token ID\\r\\n\\t\\treturn StringUtils.concat(baseURI, StringUtils.itoa(_tokenId, 10));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Sets the token URI for the token defined by its ID\\r\\n\\t *\\r\\n\\t * @param _tokenId an ID of the token to set URI for\\r\\n\\t * @param _tokenURI token URI to set\\r\\n\\t */\\r\\n\\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\\r\\n\\t\\t// verify the access permission\\r\\n\\t\\trequire(isSenderInRole(ROLE_URI_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// we do not verify token existence: we want to be able to\\r\\n\\t\\t// preallocate token URIs before tokens are actually minted\\r\\n\\r\\n\\t\\t// emit an event first - to log both old and new values\\r\\n\\t\\temit TokenURIUpdated(msg.sender, _tokenId, _tokenURIs[_tokenId], _tokenURI);\\r\\n\\r\\n\\t\\t// and update token URI\\r\\n\\t\\t_tokenURIs[_tokenId] = _tokenURI;\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: ERC721 Metadata =====\\r\\n\\r\\n\\t// ===== Start: ERC721, ERC721Enumerable Getters (view functions) =====\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction balanceOf(address _owner) public view override returns (uint256) {\\r\\n\\t\\t// check `_owner` address is set\\r\\n\\t\\trequire(_owner != address(0), \\\"zero address\\\");\\r\\n\\r\\n\\t\\t// derive owner balance for the their owned tokens collection\\r\\n\\t\\t// as the length of that collection\\r\\n\\t\\treturn collections[_owner].length;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction ownerOf(uint256 _tokenId) public view override returns (address) {\\r\\n\\t\\t// derive ownership information of the token from the ownership mapping\\r\\n\\t\\t// by extracting lower 160 bits of the mapping value as an address\\r\\n\\t\\taddress owner = address(uint160(tokens[_tokenId]));\\r\\n\\r\\n\\t\\t// verify owner/token exists\\r\\n\\t\\trequire(owner != address(0), \\\"token doesn't exist\\\");\\r\\n\\r\\n\\t\\t// return owner address\\r\\n\\t\\treturn owner;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721Enumerable\\r\\n\\t */\\r\\n\\tfunction totalSupply() public view override returns (uint256) {\\r\\n\\t\\t// derive total supply value from the array of all existing tokens\\r\\n\\t\\t// as the length of this array\\r\\n\\t\\treturn allTokens.length;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721Enumerable\\r\\n\\t */\\r\\n\\tfunction tokenByIndex(uint256 _index) public view override returns (uint256) {\\r\\n\\t\\t// index out of bounds check\\r\\n\\t\\trequire(_index < totalSupply(), \\\"index out of bounds\\\");\\r\\n\\r\\n\\t\\t// find the token ID requested and return\\r\\n\\t\\treturn allTokens[_index];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721Enumerable\\r\\n\\t */\\r\\n\\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) public view override returns (uint256) {\\r\\n\\t\\t// index out of bounds check\\r\\n\\t\\trequire(_index < balanceOf(_owner), \\\"index out of bounds\\\");\\r\\n\\r\\n\\t\\t// find the token ID requested and return\\r\\n\\t\\treturn collections[_owner][_index];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction getApproved(uint256 _tokenId) public view override returns (address) {\\r\\n\\t\\t// verify token specified exists\\r\\n\\t\\trequire(exists(_tokenId), \\\"token doesn't exist\\\");\\r\\n\\r\\n\\t\\t// read the approval value and return\\r\\n\\t\\treturn approvals[_tokenId];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction isApprovedForAll(address _owner, address _operator) public view override returns (bool) {\\r\\n\\t\\t// read the approval state value and return\\r\\n\\t\\treturn approvedOperators[_owner][_operator];\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: ERC721, ERC721Enumerable Getters (view functions) =====\\r\\n\\r\\n\\t// ===== Start: ERC721 mutative functions (transfers, approvals) =====\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Batch Safe Transfer token ID specified\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @param _from an address from where token will transfered \\r\\n\\t * @param _to an address to which token will be transfer\\r\\n\\t * @param _tokenId array of tokenID of the token to Transfer\\r\\n\\t * @param _data array of additional data with no specified format, sent in call to `_to`\\r\\n\\t */\\r\\n\\t function batchSafeTransferFrom(address _from, address _to, uint256[] memory _tokenId, bytes[] memory _data) public {\\r\\n\\t\\tfor(uint256 i = 0; i < _tokenId.length; i++){\\r\\n\\t\\t\\t// Transfer token\\r\\n\\t\\t\\tsafeTransferFrom(_from, _to, _tokenId[i], _data[i]);\\r\\n\\t\\t}\\r\\n\\t }\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) public override {\\r\\n\\t\\t// delegate call to unsafe transfer on behalf `transferFrom()`\\r\\n\\t\\ttransferFrom(_from, _to, _tokenId);\\r\\n\\r\\n\\t\\t// if receiver `_to` is a smart contract\\r\\n\\t\\tif(AddressUtils.isContract(_to)) {\\r\\n\\t\\t\\t// check it supports ERC721 interface - execute onERC721Received()\\r\\n\\t\\t\\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\\r\\n\\r\\n\\t\\t\\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\\r\\n\\t\\t\\t// bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))\\r\\n\\t\\t\\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \\\"invalid onERC721Received response\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) public override {\\r\\n\\t\\t// delegate call to overloaded `safeTransferFrom()`, set data to \\\"\\\"\\r\\n\\t\\tsafeTransferFrom(_from, _to, _tokenId, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Batch Transfer token ID specified\\r\\n\\t *\\r\\n\\t * @param _from an address from where token will transfered \\r\\n\\t * @param _to an address to which token will be transfer\\r\\n\\t * @param _tokenId array of tokenID of the token to Transfer\\r\\n\\t */\\r\\n\\t function batchTransferFrom(address _from, address _to, uint256[] memory _tokenId) public {\\r\\n\\t\\tfor(uint256 i = 0; i < _tokenId.length; i++){\\r\\n\\t\\t\\t// Transfer token\\r\\n\\t\\t\\ttransferFrom(_from, _to, _tokenId[i]);\\r\\n\\t\\t}\\r\\n\\t } \\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction transferFrom(address _from, address _to, uint256 _tokenId) public override {\\r\\n\\t\\t// if `_from` is equal to sender, require transfers feature to be enabled\\r\\n\\t\\t// otherwise require transfers on behalf feature to be enabled\\r\\n\\t\\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\\r\\n\\t\\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\\r\\n\\t\\t        _from == msg.sender? \\\"transfers are disabled\\\": \\\"transfers on behalf are disabled\\\");\\r\\n\\r\\n\\t\\t// validate destination address is set\\r\\n\\t\\trequire(_to != address(0), \\\"zero address\\\");\\r\\n\\r\\n\\t\\t// validate token ownership, which also\\r\\n\\t\\t// validates token existence under the hood\\r\\n\\t\\trequire(_from == ownerOf(_tokenId), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// verify operator (transaction sender) is either token owner,\\r\\n\\t\\t// or is approved by the token owner to transfer this particular token,\\r\\n\\t\\t// or is approved by the token owner to transfer any of his tokens\\r\\n\\t\\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// transfer is not allowed for a locked token\\r\\n\\t\\trequire(isTransferable(_tokenId), \\\"locked token\\\");\\r\\n\\r\\n\\t\\t// Register token holding Epcho\\r\\n\\t\\t_beforeTokenTransfer(_from, _to, _tokenId);\\r\\n\\r\\n\\t\\t// if required, move token ownership,\\r\\n\\t\\t// update old and new owner's token collections accordingly:\\r\\n\\t\\tif(_from != _to) {\\r\\n\\t\\t\\t// remove token from old owner's collection (also clears approval)\\r\\n\\t\\t\\t__removeLocal(_tokenId);\\r\\n\\t\\t\\t// add token to the new owner's collection\\r\\n\\t\\t\\t__addLocal(_tokenId, _to);\\r\\n\\t\\t}\\r\\n\\t\\t// even if no real changes are required, approval needs to be erased\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// clear token approval (also emits an Approval event)\\r\\n\\t\\t\\t__clearApproval(_from, _tokenId);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// fire ERC721 transfer event\\r\\n\\t\\temit Transfer(_from, _to, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction approve(address _approved, uint256 _tokenId) public override {\\r\\n\\t\\t// make an internal approve - delegate to `__approve`\\r\\n\\t\\t__approve(msg.sender, _approved, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Powers the meta transaction for `approve` - EIP-712 signed `permit`\\r\\n\\t *\\r\\n\\t * @dev Approves address called `_operator` to transfer token `_tokenId`\\r\\n\\t *      on behalf of the `_owner`\\r\\n\\t *\\r\\n\\t * @dev Zero `_operator` address indicates there is no approved address,\\r\\n\\t *      and effectively removes an approval for the token specified\\r\\n\\t *\\r\\n\\t * @dev `_owner` must own token `_tokenId` to grant the permission\\r\\n\\t * @dev Throws if `_operator` is a self address (`_owner`),\\r\\n\\t *      or if `_tokenId` doesn't exist\\r\\n\\t *\\r\\n\\t * @param _owner owner of the token `_tokenId` to set approval on behalf of\\r\\n\\t * @param _operator an address approved by the token owner\\r\\n\\t *      to spend token `_tokenId` on its behalf\\r\\n\\t * @param _tokenId token ID operator `_approved` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t */\\r\\n\\tfunction __approve(address _owner, address _operator, uint256 _tokenId) private {\\r\\n\\t\\t// get token owner address\\r\\n\\t\\taddress owner = ownerOf(_tokenId);\\r\\n\\r\\n\\t\\t// approving owner address itself doesn't make sense and is not allowed\\r\\n\\t\\trequire(_operator != owner, \\\"self approval\\\");\\r\\n\\r\\n\\t\\t// only token owner or/and approved operator can set the approval\\r\\n\\t\\trequire(_owner == owner || isApprovedForAll(owner, _owner), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// update the approval\\r\\n\\t\\tapprovals[_tokenId] = _operator;\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit Approval(owner, _operator, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC721\\r\\n\\t */\\r\\n\\tfunction setApprovalForAll(address _operator, bool _approved) public override {\\r\\n\\t\\t// make an internal approve - delegate to `__approveForAll`\\r\\n\\t\\t__approveForAll(msg.sender, _operator, _approved);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Powers the meta transaction for `setApprovalForAll` - EIP-712 signed `permitForAll`\\r\\n\\t *\\r\\n\\t * @dev Approves address called `_operator` to transfer any tokens\\r\\n\\t *      on behalf of the `_owner`\\r\\n\\t *\\r\\n\\t * @dev `_owner` must not necessarily own any tokens to grant the permission\\r\\n\\t * @dev Throws if `_operator` is a self address (`_owner`)\\r\\n\\t *\\r\\n\\t * @param _owner owner of the tokens to set approval on behalf of\\r\\n\\t * @param _operator an address to add to the set of authorized operators, i.e.\\r\\n\\t *      an address approved by the token owner to spend tokens on its behalf\\r\\n\\t * @param _approved true if the operator is approved, false to revoke approval\\r\\n\\t */\\r\\n\\tfunction __approveForAll(address _owner, address _operator, bool _approved) private {\\r\\n\\t\\t// approving tx sender address itself doesn't make sense and is not allowed\\r\\n\\t\\trequire(_operator != _owner, \\\"self approval\\\");\\r\\n\\r\\n\\t\\t// update the approval\\r\\n\\t\\tapprovedOperators[_owner][_operator] = _approved;\\r\\n\\r\\n\\t\\t// emit an event\\r\\n\\t\\temit ApprovalForAll(_owner, _operator, _approved);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Clears approval for a given token owned by a given owner,\\r\\n\\t *      emits an Approval event\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't check the validity of inputs (must be kept private),\\r\\n\\t *      assuming the check is done by the caller\\r\\n\\t *      - token existence\\r\\n\\t *      - token ownership\\r\\n\\t *\\r\\n\\t * @param _owner token owner to be logged into Approved event as is\\r\\n\\t * @param _tokenId token ID to erase approval for and to log into Approved event as is\\r\\n\\t */\\r\\n\\tfunction __clearApproval(address _owner, uint256 _tokenId) internal {\\r\\n\\t\\t// clear token approval\\r\\n\\t\\tdelete approvals[_tokenId];\\r\\n\\t\\t// emit an ERC721 Approval event:\\r\\n\\t\\t// \\\"When a Transfer event emits, this also indicates that the approved\\r\\n\\t\\t// address for that NFT (if any) is reset to none.\\\"\\r\\n\\t\\temit Approval(_owner, address(0), _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: ERC721 mutative functions (transfers, approvals) =====\\r\\n\\r\\n\\t// ===== Start: Meta-transactions Support =====\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Change or reaffirm the approved address for an NFT on behalf\\r\\n\\t *\\r\\n\\t * @dev Executes approve(_operator, _tokenId) on behalf of the token owner\\r\\n\\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\\r\\n\\t *\\r\\n\\t * @dev Sets the `_tokenId` as the allowance of `_operator` over `_owner` token,\\r\\n\\t *      given `_owner` EIP-712 signed approval\\r\\n\\t *\\r\\n\\t * @dev Emits `Approval` event in the same way as `approve` does\\r\\n\\t *\\r\\n\\t * @dev Requires:\\r\\n\\t *     - `_operator` to be non-zero address\\r\\n\\t *     - `_exp` to be a timestamp in the future\\r\\n\\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\\r\\n\\t *        over the EIP712-formatted function arguments.\\r\\n\\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\\r\\n\\t *\\r\\n\\t * @dev For more information on the signature format, see the\\r\\n\\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\\r\\n\\t *\\r\\n\\t * @param _owner owner of the token to set approval on behalf of,\\r\\n\\t *      an address which signed the EIP-712 message\\r\\n\\t * @param _operator new approved NFT controller\\r\\n\\t * @param _tokenId token ID to approve\\r\\n\\t * @param _exp signature expiration time (unix timestamp)\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction permit(address _owner, address _operator, uint256 _tokenId, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\\r\\n\\t\\t// verify permits are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_PERMITS), \\\"permits are disabled\\\");\\r\\n\\r\\n\\t\\t// derive signer of the EIP712 Permit message, and\\r\\n\\t\\t// update the nonce for that particular signer to avoid replay attack!!! ----------->>> \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _operator, _tokenId, permitNonces[_owner]++, _exp), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _owner, \\\"invalid signature\\\");\\r\\n\\t\\trequire(block.timestamp < _exp, \\\"signature expired\\\");\\r\\n\\r\\n\\t\\t// delegate call to `__approve` - execute the logic required\\r\\n\\t\\t__approve(_owner, _operator, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n\\t *      all of owner's assets - on behalf\\r\\n\\t *\\r\\n\\t * @dev Executes setApprovalForAll(_operator, _approved) on behalf of the owner\\r\\n\\t *      who EIP-712 signed the transaction, i.e. as if transaction sender is the EIP712 signer\\r\\n\\t *\\r\\n\\t * @dev Sets the `_operator` as the token operator for `_owner` tokens,\\r\\n\\t *      given `_owner` EIP-712 signed approval\\r\\n\\t *\\r\\n\\t * @dev Emits `ApprovalForAll` event in the same way as `setApprovalForAll` does\\r\\n\\t *\\r\\n\\t * @dev Requires:\\r\\n\\t *     - `_operator` to be non-zero address\\r\\n\\t *     - `_exp` to be a timestamp in the future\\r\\n\\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\\r\\n\\t *        over the EIP712-formatted function arguments.\\r\\n\\t *     - the signature to use `_owner` current nonce (see `permitNonces`).\\r\\n\\t *\\r\\n\\t * @dev For more information on the signature format, see the\\r\\n\\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\\r\\n\\t *\\r\\n\\t * @param _owner owner of the tokens to set approval on behalf of,\\r\\n\\t *      an address which signed the EIP-712 message\\r\\n\\t * @param _operator an address to add to the set of authorized operators, i.e.\\r\\n\\t *      an address approved by the token owner to spend tokens on its behalf\\r\\n\\t * @param _approved true if the operator is approved, false to revoke approval\\r\\n\\t * @param _exp signature expiration time (unix timestamp)\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction permitForAll(address _owner, address _operator, bool _approved, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public {\\r\\n\\t\\t// verify permits are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_OPERATOR_PERMITS), \\\"operator permits are disabled\\\");\\r\\n\\r\\n\\t\\t// derive signer of the EIP712 PermitForAll message, and\\r\\n\\t\\t// update the nonce for that particular signer to avoid replay attack!!! --------------------->>> \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(PERMIT_FOR_ALL_TYPEHASH, _owner, _operator, _approved, permitNonces[_owner]++, _exp), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _owner, \\\"invalid signature\\\");\\r\\n\\t\\trequire(block.timestamp < _exp, \\\"signature expired\\\");\\r\\n\\r\\n\\t\\t// delegate call to `__approve` - execute the logic required\\r\\n\\t\\t__approveForAll(_owner, _operator, _approved);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\\r\\n\\t *\\r\\n\\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\\r\\n\\t\\t// build the EIP-712 hashStruct of the message\\r\\n\\t\\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\\r\\n\\r\\n\\t\\t// calculate the EIP-712 digest \\\"\\\\x19\\\\x01\\\" \u2016 domainSeparator \u2016 hashStruct(message)\\r\\n\\t\\tbytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, hashStruct));\\r\\n\\r\\n\\t\\t// recover the address which signed the message with v, r, s\\r\\n\\t\\taddress signer = ECDSA.recover(digest, v, r, s);\\r\\n\\r\\n\\t\\t// return the signer address derived from the signature\\r\\n\\t\\treturn signer;\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: Meta-transactions Support =====\\r\\n\\r\\n\\t// ===== Start: mint/burn support =====\\r\\n\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\r\\n\\t */\\r\\n\\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public override {\\r\\n\\t\\t// delegate to unsafe mint\\r\\n\\t\\tmint(_to, _tokenId);\\r\\n\\r\\n\\t\\t// make it safe: execute `onERC721Received`\\r\\n\\r\\n\\t\\t// if receiver `_to` is a smart contract\\r\\n\\t\\tif(AddressUtils.isContract(_to)) {\\r\\n\\t\\t\\t// check it supports ERC721 interface - execute onERC721Received()\\r\\n\\t\\t\\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId, _data);\\r\\n\\r\\n\\t\\t\\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\\r\\n\\t\\t\\t// bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))\\r\\n\\t\\t\\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \\\"invalid onERC721Received response\\\");\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t */\\r\\n\\tfunction safeMint(address _to, uint256 _tokenId) public override {\\r\\n\\t\\t// delegate to `safeMint` with empty data\\r\\n\\t\\tsafeMint(_to, _tokenId, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t * @param _data additional data with no specified format, sent in call to `_to`\\r\\n\\t */\\r\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) public override {\\r\\n\\t\\t// delegate to unsafe mint\\r\\n\\t\\tmintBatch(_to, _tokenId, n);\\r\\n\\r\\n\\t\\t// make it safe: execute `onERC721Received`\\r\\n\\r\\n\\t\\t// if receiver `_to` is a smart contract\\r\\n\\t\\tif(AddressUtils.isContract(_to)) {\\r\\n\\t\\t\\t// onERC721Received: for each token minted\\r\\n\\t\\t\\tfor(uint256 i = 0; i < n; i++) {\\r\\n\\t\\t\\t\\t// check it supports ERC721 interface - execute onERC721Received()\\r\\n\\t\\t\\t\\tbytes4 response = ERC721TokenReceiver(_to).onERC721Received(msg.sender, address(0), _tokenId + i, _data);\\r\\n\\r\\n\\t\\t\\t\\t// expected response is ERC721TokenReceiver(_to).onERC721Received.selector\\r\\n\\t\\t\\t\\t// bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))\\r\\n\\t\\t\\t\\trequire(response == ERC721TokenReceiver(_to).onERC721Received.selector, \\\"invalid onERC721Received response\\\");\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n\\t *      `onERC721Received` on `_to` and throws if the return value is not\\r\\n\\t *      `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t */\\r\\n\\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) public override {\\r\\n\\t\\t// delegate to `safeMint` with empty data\\r\\n\\t\\tsafeMintBatch(_to, _tokenId, n, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new token with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for this token\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\r\\n\\t *      Prefer the use of `saveMint` instead of `mint`.\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\\r\\n\\t *\\r\\n\\t * @param _to an address to mint token to\\r\\n\\t * @param _tokenId ID of the token to mint\\r\\n\\t */\\r\\n\\tfunction mint(address _to, uint256 _tokenId) public override {\\r\\n\\t\\t// check if caller has sufficient permissions to mint tokens\\r\\n\\t\\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// verify the inputs\\r\\n\\r\\n\\t\\t// verify destination address is set\\r\\n\\t\\trequire(_to != address(0), \\\"zero address\\\");\\r\\n\\t\\t// verify the token ID is \\\"tiny\\\" (32 bits long at most)\\r\\n\\t\\trequire(uint32(_tokenId) == _tokenId, \\\"token ID overflow\\\");\\r\\n\\r\\n\\t\\t// verify token doesn't yet exist\\r\\n\\t\\trequire(!exists(_tokenId), \\\"already minted\\\");\\r\\n\\r\\n\\t\\t// Register token holding Epcho\\r\\n\\t\\t_beforeTokenTransfer(address(0), _to, _tokenId);\\r\\n\\r\\n\\t\\t// create token ownership record,\\r\\n\\t\\t// add token to `allTokens` and new owner's collections\\r\\n\\t\\t// add token to both local and global collections (enumerations)\\r\\n\\t\\t__addToken(_tokenId, _to);\\r\\n\\r\\n\\t\\t// fire ERC721 transfer event\\r\\n\\t\\temit Transfer(address(0), _to, _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Creates new tokens starting with token ID specified\\r\\n\\t *      and assigns an ownership `_to` for these tokens\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\\r\\n\\t *\\r\\n\\t * @dev n must be greater or equal 2: `n > 1`\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\\r\\n\\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\\r\\n\\t *\\r\\n\\t * @param _to an address to mint tokens to\\r\\n\\t * @param _tokenId ID of the first token to mint\\r\\n\\t * @param n how many tokens to mint, sequentially increasing the _tokenId\\r\\n\\t */\\r\\n\\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) public override {\\r\\n\\t\\t// check if caller has sufficient permissions to mint tokens\\r\\n\\t\\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// verify the inputs\\r\\n\\r\\n\\t\\t// verify destination address is set\\r\\n\\t\\trequire(_to != address(0), \\\"zero address\\\");\\r\\n\\t\\t// verify n is set properly\\r\\n\\t\\trequire(n > 1, \\\"n is too small\\\");\\r\\n\\t\\t// verify the token ID is \\\"tiny\\\" (32 bits long at most)\\r\\n\\t\\trequire(uint32(_tokenId) == _tokenId, \\\"token ID overflow\\\");\\r\\n\\t\\trequire(uint32(_tokenId + n - 1) == _tokenId + n - 1, \\\"n-th token ID overflow\\\");\\r\\n\\r\\n\\t\\t// verification: for each token to be minted\\r\\n\\t\\tfor(uint256 i = 0; i < n; i++) {\\r\\n\\t\\t\\t// verify token doesn't yet exist\\r\\n\\t\\t\\trequire(!exists(_tokenId + i), \\\"already minted\\\");\\r\\n\\r\\n\\t\\t\\t// Register token holding Epcho\\r\\n\\t\\t\\t_beforeTokenTransfer(address(0), _to, _tokenId + i);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// create token ownership records,\\r\\n\\t\\t// add tokens to `allTokens` and new owner's collections\\r\\n\\t\\t// add tokens to both local and global collections (enumerations)\\r\\n\\t\\t__addTokens(_to, _tokenId, n);\\r\\n\\r\\n\\t\\t// events: for each token minted\\r\\n\\t\\tfor(uint256 i = 0; i < n; i++) {\\r\\n\\t\\t\\t// fire ERC721 transfer event\\r\\n\\t\\t\\temit Transfer(address(0), _to, _tokenId + i);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Destroys the token with token ID specified\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\\r\\n\\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\\r\\n\\t *\\r\\n\\t * @dev Can be disabled by the contract creator forever by disabling\\r\\n\\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\\r\\n\\t *      its own roles to burn tokens and to enable burning features\\r\\n\\t *\\r\\n\\t * @param _tokenId ID of the token to burn\\r\\n\\t */\\r\\n\\tfunction burn(uint256 _tokenId) public override {\\r\\n\\t\\t// read token owner data\\r\\n\\t\\t// verifies token exists under the hood\\r\\n\\t\\taddress _from = ownerOf(_tokenId);\\r\\n\\r\\n\\t\\t// check if caller has sufficient permissions to burn tokens\\r\\n\\t\\t// and if not - check for possibility to burn own tokens or to burn on behalf\\r\\n\\t\\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\\r\\n\\t\\t\\t// if `_from` is equal to sender, require own burns feature to be enabled\\r\\n\\t\\t\\t// otherwise require burns on behalf feature to be enabled\\r\\n\\t\\t\\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\\r\\n\\t\\t\\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\\r\\n\\t\\t\\t        _from == msg.sender? \\\"burns are disabled\\\": \\\"burns on behalf are disabled\\\");\\r\\n\\r\\n\\t\\t\\t// verify sender is either token owner, or approved by the token owner to burn tokens\\r\\n\\t\\t\\trequire(_from == msg.sender || msg.sender == getApproved(_tokenId) || isApprovedForAll(_from, msg.sender), \\\"access denied\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// Register token holding Epcho\\r\\n\\t\\t_beforeTokenTransfer(msg.sender, address(0x0), _tokenId);\\r\\n\\r\\n\\t\\t// remove token ownership record (also clears approval),\\r\\n\\t\\t// remove token from both local and global collections\\r\\n\\t\\t__removeToken(_tokenId);\\r\\n\\r\\n\\t\\t// delete token URI mapping\\r\\n\\t\\tdelete _tokenURIs[_tokenId];\\r\\n\\r\\n\\t\\t// fire ERC721 transfer event\\r\\n\\t\\temit Transfer(_from, address(0), _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: mint/burn support =====\\r\\n\\r\\n\\t// ===== Start: Epcho Data support =====\\r\\n\\r\\n\\t/**\\r\\n     * @dev Hook that is called before any token transfer. This includes minting\\r\\n     * and burning.\\r\\n     *\\r\\n     * @dev Calling conditions:\\r\\n     *\\r\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\r\\n     * transferred to `to`.\\r\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\r\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\r\\n     * - `from` and `to` are never both zero.\\r\\n     *\\r\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\r\\n\\t *\\r\\n\\t * @param _from old owner address of token\\r\\n\\t * @param _to new owner address to add token to\\r\\n\\t * @param _tokenId token ID to add\\r\\n     */\\r\\n    function _beforeTokenTransfer(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _tokenId\\r\\n    ) internal virtual {\\r\\n\\t\\tif (_from != _to) {\\r\\n\\t\\t\\t_epochData[_tokenId][_generatedEpochs[_tokenId]] = Epoch(_lastSnap[_tokenId], block.timestamp, _from);\\r\\n\\t\\t\\t_generatedEpochs[_tokenId]++;\\r\\n\\t\\t\\t_lastSnap[_tokenId] = block.timestamp;\\r\\n\\t\\t}\\r\\n    }\\r\\n\\r\\n\\t// ===== End: Epcho Data support =====\\r\\n\\r\\n\\t// ----- Start: auxiliary internal/private functions -----\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Adds token to the new owner's collection (local),\\r\\n\\t *      used internally to transfer existing tokens, to mint new\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't check for data structures consistency\\r\\n\\t *      (token existence, token ownership, etc.)\\r\\n\\t *\\r\\n\\t * @dev Must be kept private at all times. Inheriting smart contracts\\r\\n\\t *      may be interested in overriding this function.\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to add\\r\\n\\t * @param _to new owner address to add token to\\r\\n\\t */\\r\\n\\tfunction __addLocal(uint256 _tokenId, address _to) internal virtual {\\r\\n\\t\\t// get a reference to the collection where token goes to\\r\\n\\t\\tuint32[] storage destination = collections[_to];\\r\\n\\r\\n\\t\\t// update local index and ownership, do not change global index\\r\\n\\t\\ttokens[_tokenId] = tokens[_tokenId]\\r\\n\\t\\t\\t//  |unused |global | local | ownership information (address)      |\\r\\n\\t\\t\\t& 0x00000000FFFFFFFF000000000000000000000000000000000000000000000000\\r\\n\\t\\t\\t| uint192(destination.length) << 160 | uint160(_to);\\r\\n\\r\\n\\t\\t// push token into the local collection\\r\\n\\t\\tdestination.push(uint32(_tokenId));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Add token to both local and global collections (enumerations),\\r\\n\\t *      used internally to mint new tokens\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't check for data structures consistency\\r\\n\\t *      (token existence, token ownership, etc.)\\r\\n\\t *\\r\\n\\t * @dev Must be kept private at all times. Inheriting smart contracts\\r\\n\\t *      may be interested in overriding this function.\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to add\\r\\n\\t * @param _to new owner address to add token to\\r\\n\\t */\\r\\n\\tfunction __addToken(uint256 _tokenId, address _to) internal virtual {\\r\\n\\t\\t// get a reference to the collection where token goes to\\r\\n\\t\\tuint32[] storage destination = collections[_to];\\r\\n\\r\\n\\t\\t// update token global and local indexes, ownership\\r\\n\\t\\ttokens[_tokenId] = uint224(allTokens.length) << 192 | uint192(destination.length) << 160 | uint160(_to);\\r\\n\\r\\n\\t\\t// push token into the collection\\r\\n\\t\\tdestination.push(uint32(_tokenId));\\r\\n\\r\\n\\t\\t// push it into the global `allTokens` collection (enumeration)\\r\\n\\t\\tallTokens.push(uint32(_tokenId));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Add tokens to both local and global collections (enumerations),\\r\\n\\t *      used internally to mint new tokens in batches\\r\\n\\t *\\r\\n\\t * @dev Token IDs to be added: [_tokenId, _tokenId + n)\\r\\n\\t *      n is expected to be greater or equal 2, but this is not checked\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't check for data structures consistency\\r\\n\\t *      (token existence, token ownership, etc.)\\r\\n\\t *\\r\\n\\t * @dev Must be kept private at all times. Inheriting smart contracts\\r\\n\\t *      may be interested in overriding this function.\\r\\n\\t *\\r\\n\\t * @param _to new owner address to add token to\\r\\n\\t * @param _tokenId first token ID to add\\r\\n\\t * @param n how many tokens to add, sequentially increasing the _tokenId\\r\\n\\t */\\r\\n\\tfunction __addTokens(address _to, uint256 _tokenId, uint256 n) internal virtual {\\r\\n\\t\\t// get a reference to the collection where tokens go to\\r\\n\\t\\tuint32[] storage destination = collections[_to];\\r\\n\\r\\n\\t\\t// for each token to be added\\r\\n\\t\\tfor(uint256 i = 0; i < n; i++) {\\r\\n\\t\\t\\t// update token global and local indexes, ownership\\r\\n\\t\\t\\ttokens[_tokenId + i] = uint224(allTokens.length + i) << 192 | uint192(destination.length + i) << 160 | uint160(_to);\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// push tokens into the local collection\\r\\n\\t\\tdestination.push32(uint32(_tokenId), uint32(n));\\r\\n\\t\\t// push tokens into the global `allTokens` collection (enumeration)\\r\\n\\t\\tallTokens.push32(uint32(_tokenId), uint32(n));\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Removes token from owner's local collection,\\r\\n\\t *      used internally to transfer or burn existing tokens\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't check for data structures consistency\\r\\n\\t *      (token existence, token ownership, etc.)\\r\\n\\t *\\r\\n\\t * @dev Must be kept private at all times. Inheriting smart contracts\\r\\n\\t *      may be interested in overriding this function.\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to remove\\r\\n\\t */\\r\\n\\tfunction __removeLocal(uint256 _tokenId) internal virtual {\\r\\n\\t\\t// read token data, containing global and local indexes, owner address\\r\\n\\t\\tuint256 token = tokens[_tokenId];\\r\\n\\r\\n\\t\\t// get a reference to the token's owner collection (local)\\r\\n\\t\\tuint32[] storage source = collections[address(uint160(token))];\\r\\n\\r\\n\\t\\t// token index within the collection\\r\\n\\t\\tuint32 i = uint32(token >> 160);\\r\\n\\r\\n\\t\\t// get an ID of the last token in the collection\\r\\n\\t\\tuint32 sourceId = source[source.length - 1];\\r\\n\\r\\n\\t\\t// if the token we're to remove from the collection is not the last one,\\r\\n\\t\\t// we need to move last token in the collection into index `i`\\r\\n\\t\\tif(i != source.length - 1) {\\r\\n\\t\\t\\t// we put the last token in the collection to the position released\\r\\n\\r\\n\\t\\t\\t// update last token local index to point to proper place in the collection\\r\\n\\t\\t\\t// preserve global index and ownership info\\r\\n\\t\\t\\ttokens[sourceId] = tokens[sourceId]\\r\\n\\t\\t\\t\\t//  |unused |global | local | ownership information (address)      |\\r\\n\\t\\t\\t\\t& 0x00000000FFFFFFFF00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\r\\n\\t\\t\\t\\t| uint192(i) << 160;\\r\\n\\r\\n\\t\\t\\t// put it into the position `i` within the collection\\r\\n\\t\\t\\tsource[i] = sourceId;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// trim the collection by removing last element\\r\\n\\t\\tsource.pop();\\r\\n\\r\\n\\t\\t// clear token approval (also emits an Approval event)\\r\\n\\t\\t__clearApproval(address(uint160(token)), _tokenId);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Removes token from both local and global collections (enumerations),\\r\\n\\t *      used internally to burn existing tokens\\r\\n\\t *\\r\\n\\t * @dev Unsafe: doesn't check for data structures consistency\\r\\n\\t *      (token existence, token ownership, etc.)\\r\\n\\t *\\r\\n\\t * @dev Must be kept private at all times. Inheriting smart contracts\\r\\n\\t *      may be interested in overriding this function.\\r\\n\\t *\\r\\n\\t * @param _tokenId token ID to remove\\r\\n\\t */\\r\\n\\tfunction __removeToken(uint256 _tokenId) internal virtual {\\r\\n\\t\\t// remove token from owner's (local) collection first\\r\\n\\t\\t__removeLocal(_tokenId);\\r\\n\\r\\n\\t\\t// token index within the global collection\\r\\n\\t\\tuint32 i = uint32(tokens[_tokenId] >> 192);\\r\\n\\r\\n\\t\\t// delete the token\\r\\n\\t\\tdelete tokens[_tokenId];\\r\\n\\r\\n\\t\\t// get an ID of the last token in the collection\\r\\n\\t\\tuint32 lastId = allTokens[allTokens.length - 1];\\r\\n\\r\\n\\t\\t// if the token we're to remove from the collection is not the last one,\\r\\n\\t\\t// we need to move last token in the collection into index `i`\\r\\n\\t\\tif(i != allTokens.length - 1) {\\r\\n\\t\\t\\t// we put the last token in the collection to the position released\\r\\n\\r\\n\\t\\t\\t// update last token global index to point to proper place in the collection\\r\\n\\t\\t\\t// preserve local index and ownership info\\r\\n\\t\\t\\ttokens[lastId] = tokens[lastId]\\r\\n\\t\\t\\t\\t//  |unused |global | local | ownership information (address)      |\\r\\n\\t\\t\\t\\t& 0x0000000000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\r\\n\\t\\t\\t\\t| uint224(i) << 192;\\r\\n\\r\\n\\t\\t\\t// put it into the position `i` within the collection\\r\\n\\t\\t\\tallTokens[i] = lastId;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// trim the collection by removing last element\\r\\n\\t\\tallTokens.pop();\\r\\n\\t}\\r\\n\\r\\n\\t// ----- End: auxiliary internal/private functions -----\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/XCCERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"../interfaces/ERC1363Spec.sol\\\";\\r\\nimport \\\"../interfaces/EIP2612.sol\\\";\\r\\nimport \\\"../interfaces/EIP3009.sol\\\";\\r\\nimport \\\"../utils/AccessControl.sol\\\";\\r\\nimport \\\"../lib/AddressUtils.sol\\\";\\r\\nimport \\\"../lib/ECDSA.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title XCC-G ERC20 Token (XCC-GOLD, XCC-G)\\r\\n *\\r\\n * @notice XCC-G is the native utility token of the TreeCoin Protocol.\\r\\n *\\r\\n * @notice Token Summary:\\r\\n *      - Symbol: XCC-G\\r\\n *      - Name: XCC-GOLD\\r\\n *      - Decimals: 18\\r\\n *      - Initial/maximum total supply:  // TODO: [DEFINE]\\r\\n *      - Initial supply holder (initial holder) address: // TODO: [DEFINE]\\r\\n *\\t\\t- Mintable: XCC-G token will be mintable by Patch-Factory Contract\\r\\n *      - Burnable: existing tokens may get destroyed, total supply may decrease\\r\\n *\\r\\n * @dev Smart contract doesn't use safe math. All arithmetic operations are overflow/underflow safe.\\r\\n *      Additionally, Solidity 0.8.7 enforces overflow/underflow safety.\\r\\n *\\r\\n * @dev Reviewed\\r\\n *      ERC-20   - according to https://eips.ethereum.org/EIPS/eip-20\\r\\n *      ERC-1363 - according to https://eips.ethereum.org/EIPS/eip-1363\\r\\n *      EIP-2612 - according to https://eips.ethereum.org/EIPS/eip-2612\\r\\n *      EIP-3009 - according to https://eips.ethereum.org/EIPS/eip-3009\\r\\n *\\r\\n * @dev Reference implementations \\\"used\\\":\\r\\n *      - Atomic allowance:    https://github.com/OpenZeppelin/openzeppelin-contracts\\r\\n *      - Unlimited allowance: https://github.com/0xProject/protocol\\r\\n *                             https://github.com/OpenZeppelin/openzeppelin-contracts\\r\\n *      - ERC-1363:            https://github.com/vittominacori/erc1363-payable-token\\r\\n *      - EIP-2612:            https://github.com/Uniswap/uniswap-v2-core\\r\\n *      - EIP-3009:            https://github.com/centrehq/centre-tokens\\r\\n *                             https://github.com/CoinbaseStablecoin/eip-3009\\r\\n *      - Meta transactions:   https://github.com/0xProject/protocol\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\ncontract XCCERC20 is ERC1363, EIP2612, EIP3009, AccessControl {\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Name of the token: XCC-GOLD\\r\\n\\t *\\r\\n\\t * @notice ERC20 name of the token (long name)\\r\\n\\t *\\r\\n\\t * @dev ERC20 `function name() public view returns (string)`\\r\\n\\t *\\r\\n\\t * @dev Field is declared public: getter name() is created when compiled,\\r\\n\\t *      it returns the name of the token.\\r\\n\\t */\\r\\n\\tstring public constant name = \\\"XCC-GOLD\\\";\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Symbol of the token: XCC-G\\r\\n\\t *\\r\\n\\t * @notice ERC20 symbol of that token (short name)\\r\\n\\t *\\r\\n\\t * @dev ERC20 `function symbol() public view returns (string)`\\r\\n\\t *\\r\\n\\t * @dev Field is declared public: getter symbol() is created when compiled,\\r\\n\\t *      it returns the symbol of the token\\r\\n\\t */\\r\\n\\tstring public constant symbol = \\\"XCC-G\\\";\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Decimals of the token: 18\\r\\n\\t *\\r\\n\\t * @dev ERC20 `function decimals() public view returns (uint8)`\\r\\n\\t *\\r\\n\\t * @dev Field is declared public: getter decimals() is created when compiled,\\r\\n\\t *      it returns the number of decimals used to get its user representation.\\r\\n\\t *      For example, if `decimals` equals `6`, a balance of `1,500,000` tokens should\\r\\n\\t *      be displayed to a user as `1,5` (`1,500,000 / 10 ** 6`).\\r\\n\\t *\\r\\n\\t * @dev NOTE: This information is only used for _display_ purposes: it in\\r\\n\\t *      no way affects any of the arithmetic of the contract, including balanceOf() and transfer().\\r\\n\\t */\\r\\n\\tuint8 public constant decimals = 18;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Total supply of the token: initially 10,000,000,000,\\r\\n\\t *      with the potential to decline over time as some tokens may get burnt but not minted\\r\\n\\t *\\r\\n\\t * @dev ERC20 `function totalSupply() public view returns (uint256)`\\r\\n\\t *\\r\\n\\t * @dev Field is declared public: getter totalSupply() is created when compiled,\\r\\n\\t *      it returns the amount of tokens in existence.\\r\\n\\t */\\r\\n\\tuint256 public override totalSupply; // is set to 10 billion * 10^18 in the constructor\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev A record of all the token balances\\r\\n\\t * @dev This mapping keeps record of all token owners:\\r\\n\\t *      owner => balance\\r\\n\\t */\\r\\n\\tmapping(address => uint256) private tokenBalances;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev A record of nonces for signing/validating signatures in EIP-2612 `permit`\\r\\n\\t *\\r\\n\\t * @dev Note: EIP2612 doesn't imply a possibility for nonce randomization like in EIP-3009\\r\\n\\t *\\r\\n\\t * @dev Maps delegate address => delegate nonce\\r\\n\\t */\\r\\n\\tmapping(address => uint256) public override nonces;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev A record of used nonces for EIP-3009 transactions\\r\\n\\t *\\r\\n\\t * @dev A record of used nonces for signing/validating signatures\\r\\n\\t *      in `delegateWithAuthorization` for every delegate\\r\\n\\t *\\r\\n\\t * @dev Maps authorizer address => nonce => true/false (used unused)\\r\\n\\t */\\r\\n\\tmapping(address => mapping(bytes32 => bool)) private usedNonces;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice A record of all the allowances to spend tokens on behalf\\r\\n\\t * @dev Maps token owner address to an address approved to spend\\r\\n\\t *      some tokens on behalf, maps approved address to that amount\\r\\n\\t * @dev owner => spender => value\\r\\n\\t */\\r\\n\\tmapping(address => mapping(address => uint256)) private transferAllowances;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables ERC20 transfers of the tokens\\r\\n\\t *      (transfer by the token owner himself)\\r\\n\\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\\r\\n\\t *      `transfer()` function to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables ERC20 transfers on behalf\\r\\n\\t *      (transfer by someone else on behalf of token owner)\\r\\n\\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\\r\\n\\t *      `transferFrom()` function to succeed\\r\\n\\t * @dev Token owner must call `approve()` first to authorize\\r\\n\\t *      the transfer on behalf\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Defines if the default behavior of `transfer` and `transferFrom`\\r\\n\\t *      checks if the receiver smart contract supports ERC20 tokens\\r\\n\\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is enabled the transfers do not\\r\\n\\t *      check if the receiver smart contract supports ERC20 tokens,\\r\\n\\t *      i.e. `transfer` and `transferFrom` behave like `unsafeTransferFrom`\\r\\n\\t * @dev When feature FEATURE_UNSAFE_TRANSFERS is disabled (default) the transfers\\r\\n\\t *      check if the receiver smart contract supports ERC20 tokens,\\r\\n\\t *      i.e. `transfer` and `transferFrom` behave like `transferFromAndCall`\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_UNSAFE_TRANSFERS = 0x0000_0004;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables token owners to burn their own tokens\\r\\n\\t *\\r\\n\\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\\r\\n\\t *      `burn()` function to succeed when called by token owner\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables approved operators to burn tokens on behalf of their owners\\r\\n\\t *\\r\\n\\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\\r\\n\\t *      `burn()` function to succeed when called by approved operator\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables ERC-1363 transfers with callback\\r\\n\\t * @dev Feature FEATURE_ERC1363_TRANSFERS must be enabled in order for\\r\\n\\t *      ERC-1363 `transferFromAndCall` functions to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_ERC1363_TRANSFERS = 0x0000_0020;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables ERC-1363 approvals with callback\\r\\n\\t * @dev Feature FEATURE_ERC1363_APPROVALS must be enabled in order for\\r\\n\\t *      ERC-1363 `approveAndCall` functions to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_ERC1363_APPROVALS = 0x0000_0040;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables approvals on behalf (EIP2612 permits\\r\\n\\t *      via an EIP712 signature)\\r\\n\\t * @dev Feature FEATURE_EIP2612_PERMITS must be enabled in order for\\r\\n\\t *      `permit()` function to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_EIP2612_PERMITS = 0x0000_0080;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables meta transfers on behalf (EIP3009 transfers\\r\\n\\t *      via an EIP712 signature)\\r\\n\\t * @dev Feature FEATURE_EIP3009_TRANSFERS must be enabled in order for\\r\\n\\t *      `transferWithAuthorization()` function to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_EIP3009_TRANSFERS = 0x0000_0100;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Enables meta transfers on behalf (EIP3009 transfers\\r\\n\\t *      via an EIP712 signature)\\r\\n\\t * @dev Feature FEATURE_EIP3009_RECEPTIONS must be enabled in order for\\r\\n\\t *      `receiveWithAuthorization()` function to succeed\\r\\n\\t */\\r\\n\\tuint32 public constant FEATURE_EIP3009_RECEPTIONS = 0x0000_0200;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Token creator is responsible for creating (minting)\\r\\n\\t *      tokens to an arbitrary address\\r\\n\\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\\r\\n\\t *      (calling `mint` function)\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Token destroyer is responsible for destroying (burning)\\r\\n\\t *      tokens owned by an arbitrary address\\r\\n\\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\\r\\n\\t *      (calling `burn` function)\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice ERC20 receivers are allowed to receive tokens without ERC20 safety checks,\\r\\n\\t *      which may be useful to simplify tokens transfers into \\\"legacy\\\" smart contracts\\r\\n\\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled addresses having\\r\\n\\t *      `ROLE_ERC20_RECEIVER` permission are allowed to receive tokens\\r\\n\\t *      via `transfer` and `transferFrom` functions in the same way they\\r\\n\\t *      would via `unsafeTransferFrom` function\\r\\n\\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_RECEIVER` permission\\r\\n\\t *      doesn't affect the transfer behaviour since\\r\\n\\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\\r\\n\\t * @dev ROLE_ERC20_RECEIVER is a shortening for ROLE_UNSAFE_ERC20_RECEIVER\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_ERC20_RECEIVER = 0x0004_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice ERC20 senders are allowed to send tokens without ERC20 safety checks,\\r\\n\\t *      which may be useful to simplify tokens transfers into \\\"legacy\\\" smart contracts\\r\\n\\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is not enabled senders having\\r\\n\\t *      `ROLE_ERC20_SENDER` permission are allowed to send tokens\\r\\n\\t *      via `transfer` and `transferFrom` functions in the same way they\\r\\n\\t *      would via `unsafeTransferFrom` function\\r\\n\\t * @dev When `FEATURE_UNSAFE_TRANSFERS` is enabled `ROLE_ERC20_SENDER` permission\\r\\n\\t *      doesn't affect the transfer behaviour since\\r\\n\\t *      `transfer` and `transferFrom` behave like `unsafeTransferFrom` for any receiver\\r\\n\\t * @dev ROLE_ERC20_SENDER is a shortening for ROLE_UNSAFE_ERC20_SENDER\\r\\n\\t */\\r\\n\\tuint32 public constant ROLE_ERC20_SENDER = 0x0008_0000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract's domain typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t *\\r\\n\\t * @dev Note: we do not include version into the domain typehash/separator,\\r\\n\\t *      it is implied version is concatenated to the name field, like \\\"XCC-G\\\"\\r\\n\\t */\\r\\n\\t// keccak256(\\\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\\\")\\r\\n\\tbytes32 public constant DOMAIN_TYPEHASH = 0x8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a866;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 contract's domain separator,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t */\\r\\n\\tbytes32 public immutable override DOMAIN_SEPARATOR;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 permit (EIP-2612) struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\")\\r\\n\\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 TransferWithAuthorization (EIP-3009) struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\r\\n\\tbytes32 public constant TRANSFER_WITH_AUTHORIZATION_TYPEHASH = 0x7c7c6cdb67a18743f49ec6fa9b35f50d52ed05cbed4cc592e13b44501c1a2267;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 ReceiveWithAuthorization (EIP-3009) struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"ReceiveWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)\\\")\\r\\n\\tbytes32 public constant RECEIVE_WITH_AUTHORIZATION_TYPEHASH = 0xd099cc98ef71107a616c4f0f941f04c322d8e254fe26b3c6668db87aae413de8;\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice EIP-712 CancelAuthorization (EIP-3009) struct typeHash,\\r\\n\\t *      see https://eips.ethereum.org/EIPS/eip-712#rationale-for-typehash\\r\\n\\t */\\r\\n\\t// keccak256(\\\"CancelAuthorization(address authorizer,bytes32 nonce)\\\")\\r\\n\\tbytes32 public constant CANCEL_AUTHORIZATION_TYPEHASH = 0x158b0a9edf7a828aad02f63cd515c68ef2f50ba807396f6d12842833a1597429;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in mint() function\\r\\n\\t *\\r\\n\\t * @param by an address which minted some tokens (transaction sender)\\r\\n\\t * @param to an address the tokens were minted to\\r\\n\\t * @param value an amount of tokens minted\\r\\n\\t */\\r\\n\\tevent Minted(address indexed by, address indexed to, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in burn() function\\r\\n\\t *\\r\\n\\t * @param by an address which burned some tokens (transaction sender)\\r\\n\\t * @param from an address the tokens were burnt from\\r\\n\\t * @param value an amount of tokens burnt\\r\\n\\t */\\r\\n\\tevent Burnt(address indexed by, address indexed from, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\r\\n\\t *\\r\\n\\t * @dev Similar to ERC20 Transfer event, but also logs an address which executed transfer\\r\\n\\t *\\r\\n\\t * @dev Fired in transfer(), transferFrom() and some other (non-ERC20) functions\\r\\n\\t *\\r\\n\\t * @param by an address which performed the transfer\\r\\n\\t * @param from an address tokens were consumed from\\r\\n\\t * @param to an address tokens were sent to\\r\\n\\t * @param value number of tokens transferred\\r\\n\\t */\\r\\n\\tevent Transfer(address indexed by, address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\r\\n\\t *\\r\\n\\t * @dev Similar to ERC20 Approve event, but also logs old approval value\\r\\n\\t *\\r\\n\\t * @dev Fired in approve(), increaseAllowance(), decreaseAllowance() functions,\\r\\n\\t *      may get fired in transfer functions\\r\\n\\t *\\r\\n\\t * @param owner an address which granted a permission to transfer\\r\\n\\t *      tokens on its behalf\\r\\n\\t * @param spender an address which received a permission to transfer\\r\\n\\t *      tokens on behalf of the owner `_owner`\\r\\n\\t * @param oldValue previously granted amount of tokens to transfer on behalf\\r\\n\\t * @param value new granted amount of tokens to transfer on behalf\\r\\n\\t */\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 oldValue, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Deploys the token smart contract,\\r\\n\\t *      assigns initial token supply to the address specified\\r\\n\\t *\\r\\n\\t * @param _initialHolder owner of the initial token supply\\r\\n\\t */\\r\\n\\tconstructor(address _initialHolder) {\\r\\n\\t\\t// verify initial holder address non-zero (is set)\\r\\n\\t\\trequire(_initialHolder != address(0), \\\"_initialHolder not set (zero address)\\\");\\r\\n\\r\\n\\t\\t// build the EIP-712 contract domain separator, see https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator\\r\\n\\t\\t// note: we specify contract version in its name\\r\\n\\t\\tDOMAIN_SEPARATOR = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(\\\"XCC-G\\\")), block.chainid, address(this)));\\r\\n\\r\\n\\t\\t// mint initial supply (1000 XCC Token)\\r\\n\\t\\tmint(_initialHolder, 1000e18);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc ERC165\\r\\n\\t */\\r\\n\\tfunction supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\\r\\n\\t\\t// reconstruct from current interface(s) and super interface(s) (if any)\\r\\n\\t\\treturn interfaceId == type(ERC165).interfaceId\\r\\n\\t\\t    || interfaceId == type(ERC20).interfaceId\\r\\n\\t\\t    || interfaceId == type(ERC1363).interfaceId\\r\\n\\t\\t    || interfaceId == type(EIP2612).interfaceId\\r\\n\\t\\t    || interfaceId == type(EIP3009).interfaceId;\\r\\n\\t}\\r\\n\\r\\n\\t// ===== Start: ERC-1363 functions =====\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC1363\\r\\n\\t *\\r\\n\\t * @dev Called by token owner (an address which has a\\r\\n\\t *      positive token balance tracked by this smart contract)\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\\r\\n\\t * @dev Returns true on success, throws otherwise\\r\\n\\t *\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be a smart contract, implementing ERC1363Receiver\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction transferAndCall(address _to, uint256 _value) public override returns (bool) {\\r\\n\\t\\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\\r\\n\\t\\treturn transferFromAndCall(msg.sender, _to, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens and then executes `onTransferReceived` callback on the receiver\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC1363\\r\\n\\t *\\r\\n\\t * @dev Called by token owner (an address which has a\\r\\n\\t *      positive token balance tracked by this smart contract)\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\\r\\n\\t * @dev Returns true on success, throws otherwise\\r\\n\\t *\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be a smart contract, implementing ERC1363Receiver\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @param _data [optional] additional data with no specified format,\\r\\n\\t *      sent in onTransferReceived call to `_to`\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction transferAndCall(address _to, uint256 _value, bytes memory _data) public override returns (bool) {\\r\\n\\t\\t// delegate to `transferFromAndCall` passing `msg.sender` as `_from`\\r\\n\\t\\treturn transferFromAndCall(msg.sender, _to, _value, _data);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\r\\n\\t *      to some other address `_to` and then executes `onTransferReceived` callback on the receiver\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC1363\\r\\n\\t *\\r\\n\\t * @dev Called by token owner on his own or approved address,\\r\\n\\t *      an address approved earlier by token owner to\\r\\n\\t *      transfer some amount of tokens on its behalf\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\\r\\n\\t * @dev Returns true on success, throws otherwise\\r\\n\\t *\\r\\n\\t * @param _from token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be a smart contract, implementing ERC1363Receiver\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction transferFromAndCall(address _from, address _to, uint256 _value) public override returns (bool) {\\r\\n\\t\\t// delegate to `transferFromAndCall` passing empty data param\\r\\n\\t\\treturn transferFromAndCall(_from, _to, _value, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\r\\n\\t *      to some other address `_to` and then executes a `onTransferReceived` callback on the receiver\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC1363\\r\\n\\t *\\r\\n\\t * @dev Called by token owner on his own or approved address,\\r\\n\\t *      an address approved earlier by token owner to\\r\\n\\t *      transfer some amount of tokens on its behalf\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * EOA or smart contract which doesn't support ERC1363Receiver interface\\r\\n\\t * @dev Returns true on success, throws otherwise\\r\\n\\t *\\r\\n\\t * @param _from token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be a smart contract, implementing ERC1363Receiver\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @param _data [optional] additional data with no specified format,\\r\\n\\t *      sent in onTransferReceived call to `_to`\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction transferFromAndCall(address _from, address _to, uint256 _value, bytes memory _data) public override returns (bool) {\\r\\n\\t\\t// ensure ERC-1363 transfers are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_ERC1363_TRANSFERS), \\\"ERC1363 transfers are disabled\\\");\\r\\n\\r\\n\\t\\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\\r\\n\\t\\tunsafeTransferFrom(_from, _to, _value);\\r\\n\\r\\n\\t\\t// after the successful transfer - check if receiver supports\\r\\n\\t\\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\\r\\n\\t\\t// reverting whole transaction on any error\\r\\n\\t\\t_notifyTransferred(_from, _to, _value, _data, false);\\r\\n\\r\\n\\t\\t// function throws on any error, so if we're here - it means operation successful, just return true\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Approves address called `_spender` to transfer some amount\\r\\n\\t *      of tokens on behalf of the owner, then executes a `onApprovalReceived` callback on `_spender`\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC1363\\r\\n\\t *\\r\\n\\t * @dev Caller must not necessarily own any tokens to grant the permission\\r\\n\\t *\\r\\n\\t * @dev Throws if `_spender` is an EOA or a smart contract which doesn't support ERC1363Spender interface\\r\\n\\t *\\r\\n\\t * @param _spender an address approved by the caller (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction approveAndCall(address _spender, uint256 _value) public override returns (bool) {\\r\\n\\t\\t// delegate to `approveAndCall` passing empty data\\r\\n\\t\\treturn approveAndCall(_spender, _value, \\\"\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Approves address called `_spender` to transfer some amount\\r\\n\\t *      of tokens on behalf of the owner, then executes a callback on `_spender`\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC1363\\r\\n\\t *\\r\\n\\t * @dev Caller must not necessarily own any tokens to grant the permission\\r\\n\\t *\\r\\n\\t * @param _spender an address approved by the caller (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t * @param _data [optional] additional data with no specified format,\\r\\n\\t *      sent in onApprovalReceived call to `_spender`\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction approveAndCall(address _spender, uint256 _value, bytes memory _data) public override returns (bool) {\\r\\n\\t\\t// ensure ERC-1363 approvals are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_ERC1363_APPROVALS), \\\"ERC1363 approvals are disabled\\\");\\r\\n\\r\\n\\t\\t// execute regular ERC20 approve - delegate to `approve`\\r\\n\\t\\tapprove(_spender, _value);\\r\\n\\r\\n\\t\\t// after the successful approve - check if receiver supports\\r\\n\\t\\t// ERC1363Spender and execute a callback handler `onApprovalReceived`,\\r\\n\\t\\t// reverting whole transaction on any error\\r\\n\\t\\t_notifyApproved(_spender, _value, _data);\\r\\n\\r\\n\\t\\t// function throws on any error, so if we're here - it means operation successful, just return true\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to invoke `onTransferReceived` on a target address\\r\\n\\t *      The call is not executed if the target address is not a contract; in such\\r\\n\\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\\r\\n\\t *\\r\\n\\t * @dev Throws on any error; returns silently on success\\r\\n\\t *\\r\\n\\t * @param _from representing the previous owner of the given token value\\r\\n\\t * @param _to target address that will receive the tokens\\r\\n\\t * @param _value the amount mount of tokens to be transferred\\r\\n\\t * @param _data [optional] data to send along with the call\\r\\n\\t * @param allowEoa indicates if function should fail if `_to` is an EOA\\r\\n\\t */\\r\\n\\tfunction _notifyTransferred(address _from, address _to, uint256 _value, bytes memory _data, bool allowEoa) private {\\r\\n\\t\\t// if recipient `_to` is EOA\\r\\n\\t\\tif (!AddressUtils.isContract(_to)) {\\r\\n\\t\\t\\t// ensure EOA recipient is allowed\\r\\n\\t\\t\\trequire(allowEoa, \\\"EOA recipient\\\");\\r\\n\\r\\n\\t\\t\\t// exit if successful\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// otherwise - if `_to` is a contract - execute onTransferReceived\\r\\n\\t\\tbytes4 response = ERC1363Receiver(_to).onTransferReceived(msg.sender, _from, _value, _data);\\r\\n\\r\\n\\t\\t// expected response is ERC1363Receiver(_to).onTransferReceived.selector\\r\\n\\t\\t// bytes4(keccak256(\\\"onTransferReceived(address,address,uint256,bytes)\\\"))\\r\\n\\t\\trequire(response == ERC1363Receiver(_to).onTransferReceived.selector, \\\"invalid onTransferReceived response\\\");\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to invoke `onApprovalReceived` on a target address\\r\\n\\t *      The call is not executed if the target address is not a contract; in such\\r\\n\\t *      a case function throws if `allowEoa` is set to false, succeeds if it's true\\r\\n\\t *\\r\\n\\t * @dev Throws on any error; returns silently on success\\r\\n\\t *\\r\\n\\t * @param _spender the address which will spend the funds\\r\\n\\t * @param _value the amount of tokens to be spent\\r\\n\\t * @param _data [optional] data to send along with the call\\r\\n\\t */\\r\\n\\tfunction _notifyApproved(address _spender, uint256 _value, bytes memory _data) private {\\r\\n\\t\\t// ensure recipient is not EOA\\r\\n\\t\\trequire(AddressUtils.isContract(_spender), \\\"EOA spender\\\");\\r\\n\\r\\n\\t\\t// otherwise - if `_to` is a contract - execute onApprovalReceived\\r\\n\\t\\tbytes4 response = ERC1363Spender(_spender).onApprovalReceived(msg.sender, _value, _data);\\r\\n\\r\\n\\t\\t// expected response is ERC1363Spender(_to).onApprovalReceived.selector\\r\\n\\t\\t// bytes4(keccak256(\\\"onApprovalReceived(address,uint256,bytes)\\\"))\\r\\n\\t\\trequire(response == ERC1363Spender(_spender).onApprovalReceived.selector, \\\"invalid onApprovalReceived response\\\");\\r\\n\\t}\\r\\n\\t// ===== End: ERC-1363 functions =====\\r\\n\\r\\n\\t// ===== Start: ERC20 functions =====\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Gets the balance of a particular address\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC20\\r\\n\\t *\\r\\n\\t * @param _owner the address to query the the balance for\\r\\n\\t * @return balance an amount of tokens owned by the address specified\\r\\n\\t */\\r\\n\\tfunction balanceOf(address _owner) public view override returns (uint256 balance) {\\r\\n\\t\\t// read the balance and return\\r\\n\\t\\treturn tokenBalances[_owner];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens to an external address or a smart contract\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC20\\r\\n\\t *\\r\\n\\t * @dev Called by token owner (an address which has a\\r\\n\\t *      positive token balance tracked by this smart contract)\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * self address or\\r\\n\\t *          * smart contract which doesn't support ERC20\\r\\n\\t *\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      compliant with the ERC20 standard\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction transfer(address _to, uint256 _value) public override returns (bool success) {\\r\\n\\t\\t// just delegate call to `transferFrom`,\\r\\n\\t\\t// `FEATURE_TRANSFERS` is verified inside it\\r\\n\\t\\treturn transferFrom(msg.sender, _to, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\r\\n\\t *      to some other address `_to`\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC20\\r\\n\\t *\\r\\n\\t * @dev Called by token owner on his own or approved address,\\r\\n\\t *      an address approved earlier by token owner to\\r\\n\\t *      transfer some amount of tokens on its behalf\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * smart contract which doesn't support ERC20\\r\\n\\t *\\r\\n\\t * @param _from token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      compliant with the ERC20 standard\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) public override returns (bool success) {\\r\\n\\t\\t// depending on `FEATURE_UNSAFE_TRANSFERS` we execute either safe (default)\\r\\n\\t\\t// or unsafe transfer\\r\\n\\t\\t// if `FEATURE_UNSAFE_TRANSFERS` is enabled\\r\\n\\t\\t// or receiver has `ROLE_ERC20_RECEIVER` permission\\r\\n\\t\\t// or sender has `ROLE_ERC20_SENDER` permission\\r\\n\\t\\tif(isFeatureEnabled(FEATURE_UNSAFE_TRANSFERS)\\r\\n\\t\\t\\t|| isOperatorInRole(_to, ROLE_ERC20_RECEIVER)\\r\\n\\t\\t\\t|| isSenderInRole(ROLE_ERC20_SENDER)) {\\r\\n\\t\\t\\t// we execute unsafe transfer - delegate call to `unsafeTransferFrom`,\\r\\n\\t\\t\\t// `FEATURE_TRANSFERS` is verified inside it\\r\\n\\t\\t\\tunsafeTransferFrom(_from, _to, _value);\\r\\n\\t\\t}\\r\\n\\t\\t// otherwise - if `FEATURE_UNSAFE_TRANSFERS` is disabled\\r\\n\\t\\t// and receiver doesn't have `ROLE_ERC20_RECEIVER` permission\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// we execute safe transfer - delegate call to `safeTransferFrom`, passing empty `_data`,\\r\\n\\t\\t\\t// `FEATURE_TRANSFERS` is verified inside it\\r\\n\\t\\t\\tsafeTransferFrom(_from, _to, _value, \\\"\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// both `unsafeTransferFrom` and `safeTransferFrom` throw on any error, so\\r\\n\\t\\t// if we're here - it means operation successful,\\r\\n\\t\\t// just return true\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\r\\n\\t *      to some other address `_to` and then executes `onTransferReceived` callback\\r\\n\\t *      on the receiver if it is a smart contract (not an EOA)\\r\\n\\t *\\r\\n\\t * @dev Called by token owner on his own or approved address,\\r\\n\\t *      an address approved earlier by token owner to\\r\\n\\t *      transfer some amount of tokens on its behalf\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * smart contract which doesn't support ERC1363Receiver interface\\r\\n\\t * @dev Returns true on success, throws otherwise\\r\\n\\t *\\r\\n\\t * @param _from token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      implementing ERC1363Receiver\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @param _data [optional] additional data with no specified format,\\r\\n\\t *      sent in onTransferReceived call to `_to` in case if its a smart contract\\r\\n\\t * @return true unless throwing\\r\\n\\t */\\r\\n\\tfunction safeTransferFrom(address _from, address _to, uint256 _value, bytes memory _data) public returns (bool) {\\r\\n\\t\\t// first delegate call to `unsafeTransferFrom` to perform the unsafe token(s) transfer\\r\\n\\t\\tunsafeTransferFrom(_from, _to, _value);\\r\\n\\r\\n\\t\\t// after the successful transfer - check if receiver supports\\r\\n\\t\\t// ERC1363Receiver and execute a callback handler `onTransferReceived`,\\r\\n\\t\\t// reverting whole transaction on any error\\r\\n\\t\\t_notifyTransferred(_from, _to, _value, _data, true);\\r\\n\\r\\n\\t\\t// function throws on any error, so if we're here - it means operation successful, just return true\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\r\\n\\t *      to some other address `_to`\\r\\n\\t *\\r\\n\\t * @dev In contrast to `transferFromAndCall` doesn't check recipient\\r\\n\\t *      smart contract to support ERC20 tokens (ERC1363Receiver)\\r\\n\\t * @dev Designed to be used by developers when the receiver is known\\r\\n\\t *      to support ERC20 tokens but doesn't implement ERC1363Receiver interface\\r\\n\\t * @dev Called by token owner on his own or approved address,\\r\\n\\t *      an address approved earlier by token owner to\\r\\n\\t *      transfer some amount of tokens on its behalf\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t * @dev Returns silently on success, throws otherwise\\r\\n\\t *\\r\\n\\t * @param _from token sender, token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to token receiver, an address to transfer tokens to\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t */\\r\\n\\tfunction unsafeTransferFrom(address _from, address _to, uint256 _value) public {\\r\\n\\t\\t// make an internal transferFrom - delegate to `__transferFrom`\\r\\n\\t\\t__transferFrom(msg.sender, _from, _to, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Powers the meta transactions for `unsafeTransferFrom` - EIP-3009 `transferWithAuthorization`\\r\\n\\t *      and `receiveWithAuthorization`\\r\\n\\t *\\r\\n\\t * @dev See `unsafeTransferFrom` and `transferFrom` soldoc for details\\r\\n\\t *\\r\\n\\t * @param _by an address executing the transfer, it can be token owner itself,\\r\\n\\t *      or an operator previously approved with `approve()`\\r\\n\\t * @param _from token sender, token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to token receiver, an address to transfer tokens to\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t */\\r\\n\\tfunction __transferFrom(address _by, address _from, address _to, uint256 _value) private {\\r\\n\\t\\t// if `_from` is equal to sender, require transfers feature to be enabled\\r\\n\\t\\t// otherwise require transfers on behalf feature to be enabled\\r\\n\\t\\trequire(_from == _by && isFeatureEnabled(FEATURE_TRANSFERS)\\r\\n\\t\\t     || _from != _by && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\\r\\n\\t\\t        _from == _by? \\\"transfers are disabled\\\": \\\"transfers on behalf are disabled\\\");\\r\\n\\r\\n\\t\\t// non-zero source address check - Zeppelin\\r\\n\\t\\t// obviously, zero source address is a client mistake\\r\\n\\t\\t// it's not part of ERC20 standard but it's reasonable to fail fast\\r\\n\\t\\t// since for zero value transfer transaction succeeds otherwise\\r\\n\\t\\trequire(_from != address(0), \\\"transfer from the zero address\\\");\\r\\n\\r\\n\\t\\t// non-zero recipient address check\\r\\n\\t\\trequire(_to != address(0), \\\"transfer to the zero address\\\");\\r\\n\\r\\n\\t\\t// sender and recipient cannot be the same\\r\\n\\t\\trequire(_from != _to, \\\"sender and recipient are the same (_from = _to)\\\");\\r\\n\\r\\n\\t\\t// sending tokens to the token smart contract itself is a client mistake\\r\\n\\t\\trequire(_to != address(this), \\\"invalid recipient (transfer to the token smart contract itself)\\\");\\r\\n\\r\\n\\t\\t// according to ERC-20 Token Standard, https://eips.ethereum.org/EIPS/eip-20\\r\\n\\t\\t// \\\"Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\\\"\\r\\n\\t\\tif(_value == 0) {\\r\\n\\t\\t\\t// emit an ERC20 transfer event\\r\\n\\t\\t\\temit Transfer(_from, _to, _value);\\r\\n\\r\\n\\t\\t\\t// don't forget to return - we're done\\r\\n\\t\\t\\treturn;\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// no need to make arithmetic overflow check on the _value - by design of mint()\\r\\n\\r\\n\\t\\t// in case of transfer on behalf\\r\\n\\t\\tif(_from != _by) {\\r\\n\\t\\t\\t// read allowance value - the amount of tokens allowed to transfer - into the stack\\r\\n\\t\\t\\tuint256 _allowance = transferAllowances[_from][_by];\\r\\n\\r\\n\\t\\t\\t// verify sender has an allowance to transfer amount of tokens requested\\r\\n\\t\\t\\trequire(_allowance >= _value, \\\"transfer amount exceeds allowance\\\");\\r\\n\\r\\n\\t\\t\\t// we treat max uint256 allowance value as an \\\"unlimited\\\" and\\r\\n\\t\\t\\t// do not decrease allowance when it is set to \\\"unlimited\\\" value\\r\\n\\t\\t\\tif(_allowance < type(uint256).max) {\\r\\n\\t\\t\\t\\t// update allowance value on the stack\\r\\n\\t\\t\\t\\t_allowance -= _value;\\r\\n\\r\\n\\t\\t\\t\\t// update the allowance value in storage\\r\\n\\t\\t\\t\\ttransferAllowances[_from][_by] = _allowance;\\r\\n\\r\\n\\t\\t\\t\\t// emit an improved atomic approve event\\r\\n\\t\\t\\t\\temit Approval(_from, _by, _allowance + _value, _allowance);\\r\\n\\r\\n\\t\\t\\t\\t// emit an ERC20 approval event to reflect the decrease\\r\\n\\t\\t\\t\\temit Approval(_from, _by, _allowance);\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// verify sender has enough tokens to transfer on behalf\\r\\n\\t\\trequire(tokenBalances[_from] >= _value, \\\"transfer amount exceeds balance\\\");\\r\\n\\r\\n\\t\\t// perform the transfer:\\r\\n\\t\\t// decrease token owner (sender) balance\\r\\n\\t\\ttokenBalances[_from] -= _value;\\r\\n\\r\\n\\t\\t// increase `_to` address (receiver) balance\\r\\n\\t\\ttokenBalances[_to] += _value;\\r\\n\\r\\n\\t\\t// emit an improved transfer event (arXiv:1907.00903)\\r\\n\\t\\temit Transfer(_by, _from, _to, _value);\\r\\n\\r\\n\\t\\t// emit an ERC20 transfer event\\r\\n\\t\\temit Transfer(_from, _to, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Approves address called `_spender` to transfer some amount\\r\\n\\t *      of tokens on behalf of the owner (transaction sender)\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC20\\r\\n\\t *\\r\\n\\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\\r\\n\\t *\\r\\n\\t * @param _spender an address approved by the caller (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction approve(address _spender, uint256 _value) public override returns (bool success) {\\r\\n\\t\\t// make an internal approve - delegate to `__approve`\\r\\n\\t\\t__approve(msg.sender, _spender, _value);\\r\\n\\r\\n\\t\\t// operation successful, return true\\r\\n\\t\\treturn true;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Powers the meta transaction for `approve` - EIP-2612 `permit`\\r\\n\\t *\\r\\n\\t * @dev Approves address called `_spender` to transfer some amount\\r\\n\\t *      of tokens on behalf of the `_owner`\\r\\n\\t *\\r\\n\\t * @dev `_owner` must not necessarily own any tokens to grant the permission\\r\\n\\t * @dev Throws if `_spender` is a zero address\\r\\n\\t *\\r\\n\\t * @param _owner owner of the tokens to set approval on behalf of\\r\\n\\t * @param _spender an address approved by the token owner\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t */\\r\\n\\tfunction __approve(address _owner, address _spender, uint256 _value) private {\\r\\n\\t\\t// non-zero spender address check - Zeppelin\\r\\n\\t\\t// obviously, zero spender address is a client mistake\\r\\n\\t\\t// it's not part of ERC20 standard but it's reasonable to fail fast\\r\\n\\t\\trequire(_spender != address(0), \\\"approve to the zero address\\\");\\r\\n\\r\\n\\t\\t// read old approval value to emmit an improved event (arXiv:1907.00903)\\r\\n\\t\\tuint256 _oldValue = transferAllowances[_owner][_spender];\\r\\n\\r\\n\\t\\t// perform an operation: write value requested into the storage\\r\\n\\t\\ttransferAllowances[_owner][_spender] = _value;\\r\\n\\r\\n\\t\\t// emit an improved atomic approve event (arXiv:1907.00903)\\r\\n\\t\\temit Approval(_owner, _spender, _oldValue, _value);\\r\\n\\r\\n\\t\\t// emit an ERC20 approval event\\r\\n\\t\\temit Approval(_owner, _spender, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\\r\\n\\t *\\r\\n\\t * @inheritdoc ERC20\\r\\n\\t *\\r\\n\\t * @dev A function to check an amount of tokens owner approved\\r\\n\\t *      to transfer on its behalf by some other address called \\\"spender\\\"\\r\\n\\t *\\r\\n\\t * @param _owner an address which approves transferring some tokens on its behalf\\r\\n\\t * @param _spender an address approved to transfer some tokens on behalf\\r\\n\\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\\r\\n\\t *      of token owner `_owner`\\r\\n\\t */\\r\\n\\tfunction allowance(address _owner, address _spender) public view override returns (uint256 remaining) {\\r\\n\\t\\t// read the value from storage and return\\r\\n\\t\\treturn transferAllowances[_owner][_spender];\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: ERC20 functions =====\\r\\n\\r\\n\\t// ===== Start: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Increases the allowance granted to `spender` by the transaction sender\\r\\n\\t *\\r\\n\\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\r\\n\\t *\\r\\n\\t * @dev Throws if value to increase by is zero or too big and causes arithmetic overflow\\r\\n\\t *\\r\\n\\t * @param _spender an address approved by the caller (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens to increase by\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction increaseAllowance(address _spender, uint256 _value) public returns (bool) {\\r\\n\\t\\t// read current allowance value\\r\\n\\t\\tuint256 currentVal = transferAllowances[msg.sender][_spender];\\r\\n\\r\\n\\t\\t// non-zero _value and arithmetic overflow check on the allowance\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\\r\\n\\t\\t\\trequire(currentVal + _value > currentVal, \\\"zero value approval increase or arithmetic overflow\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// delegate call to `approve` with the new value\\r\\n\\t\\treturn approve(_spender, currentVal + _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Decreases the allowance granted to `spender` by the caller.\\r\\n\\t *\\r\\n\\t * @dev Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\r\\n\\t *\\r\\n\\t * @dev Throws if value to decrease by is zero or is greater than currently allowed value\\r\\n\\t *\\r\\n\\t * @param _spender an address approved by the caller (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens to decrease by\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction decreaseAllowance(address _spender, uint256 _value) public returns (bool) {\\r\\n\\t\\t// read current allowance value\\r\\n\\t\\tuint256 currentVal = transferAllowances[msg.sender][_spender];\\r\\n\\r\\n\\t\\t// non-zero _value check on the allowance\\r\\n\\t\\trequire(_value > 0, \\\"zero value approval decrease\\\");\\r\\n\\r\\n\\t\\t// verify allowance decrease doesn't underflow\\r\\n\\t\\trequire(currentVal >= _value, \\\"ERC20: decreased allowance below zero\\\");\\r\\n\\r\\n\\t\\t// delegate call to `approve` with the new value\\r\\n\\t\\treturn approve(_spender, currentVal - _value);\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: Resolution for the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903) =====\\r\\n\\r\\n\\t// ===== Start: Minting/burning extension =====\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Mints (creates) some tokens to address specified\\r\\n\\t * @dev The value specified is treated as is without taking\\r\\n\\t *      into account what `decimals` value is\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\\r\\n\\t *\\r\\n\\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint256\\r\\n\\t *\\r\\n\\t * @param _to an address to mint tokens to\\r\\n\\t * @param _value an amount of tokens to mint (create)\\r\\n\\t */\\r\\n\\tfunction mint(address _to, uint256 _value) public {\\r\\n\\t\\t// check if caller has sufficient permissions to mint tokens\\r\\n\\t\\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// non-zero recipient address check\\r\\n\\t\\trequire(_to != address(0), \\\"zero address\\\");\\r\\n\\r\\n\\t\\t// non-zero _value and arithmetic overflow check on the total supply\\r\\n\\t\\t// this check automatically secures arithmetic overflow on the individual balance\\r\\n\\t\\tunchecked {\\r\\n\\t\\t\\t// put operation into unchecked block to display user-friendly overflow error message for Solidity 0.8+\\r\\n\\t\\t\\trequire(totalSupply + _value > totalSupply, \\\"zero value or arithmetic overflow\\\");\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// uint192 overflow check (required by voting delegation)\\r\\n\\t\\trequire(totalSupply + _value <= type(uint192).max, \\\"total supply overflow (uint192)\\\");\\r\\n\\r\\n\\t\\t// perform mint:\\r\\n\\t\\t// increase total amount of tokens value\\r\\n\\t\\ttotalSupply += _value;\\r\\n\\r\\n\\t\\t// increase `_to` address balance\\r\\n\\t\\ttokenBalances[_to] += _value;\\r\\n\\r\\n\\t\\t// fire a minted event\\r\\n\\t\\temit Minted(msg.sender, _to, _value);\\r\\n\\r\\n\\t\\t// emit an improved transfer event (arXiv:1907.00903)\\r\\n\\t\\temit Transfer(msg.sender, address(0), _to, _value);\\r\\n\\r\\n\\t\\t// fire ERC20 compliant transfer event\\r\\n\\t\\temit Transfer(address(0), _to, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Burns (destroys) some tokens from the address specified\\r\\n\\t *\\r\\n\\t * @dev The value specified is treated as is without taking\\r\\n\\t *      into account what `decimals` value is\\r\\n\\t *\\r\\n\\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\\r\\n\\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\\r\\n\\t *\\r\\n\\t * @dev Can be disabled by the contract creator forever by disabling\\r\\n\\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\\r\\n\\t *      its own roles to burn tokens and to enable burning features\\r\\n\\t *\\r\\n\\t * @param _from an address to burn some tokens from\\r\\n\\t * @param _value an amount of tokens to burn (destroy)\\r\\n\\t */\\r\\n\\tfunction burn(address _from, uint256 _value) public {\\r\\n\\t\\t// check if caller has sufficient permissions to burn tokens\\r\\n\\t\\t// and if not - check for possibility to burn own tokens or to burn on behalf\\r\\n\\t\\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\\r\\n\\t\\t\\t// if `_from` is equal to sender, require own burns feature to be enabled\\r\\n\\t\\t\\t// otherwise require burns on behalf feature to be enabled\\r\\n\\t\\t\\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\\r\\n\\t\\t\\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\\r\\n\\t\\t\\t        _from == msg.sender? \\\"burns are disabled\\\": \\\"burns on behalf are disabled\\\");\\r\\n\\r\\n\\t\\t\\t// in case of burn on behalf\\r\\n\\t\\t\\tif(_from != msg.sender) {\\r\\n\\t\\t\\t\\t// read allowance value - the amount of tokens allowed to be burnt - into the stack\\r\\n\\t\\t\\t\\tuint256 _allowance = transferAllowances[_from][msg.sender];\\r\\n\\r\\n\\t\\t\\t\\t// verify sender has an allowance to burn amount of tokens requested\\r\\n\\t\\t\\t\\trequire(_allowance >= _value, \\\"burn amount exceeds allowance\\\");\\r\\n\\r\\n\\t\\t\\t\\t// we treat max uint256 allowance value as an \\\"unlimited\\\" and\\r\\n\\t\\t\\t\\t// do not decrease allowance when it is set to \\\"unlimited\\\" value\\r\\n\\t\\t\\t\\tif(_allowance < type(uint256).max) {\\r\\n\\t\\t\\t\\t\\t// update allowance value on the stack\\r\\n\\t\\t\\t\\t\\t_allowance -= _value;\\r\\n\\r\\n\\t\\t\\t\\t\\t// update the allowance value in storage\\r\\n\\t\\t\\t\\t\\ttransferAllowances[_from][msg.sender] = _allowance;\\r\\n\\r\\n\\t\\t\\t\\t\\t// emit an improved atomic approve event (arXiv:1907.00903)\\r\\n\\t\\t\\t\\t\\temit Approval(msg.sender, _from, _allowance + _value, _allowance);\\r\\n\\r\\n\\t\\t\\t\\t\\t// emit an ERC20 approval event to reflect the decrease\\r\\n\\t\\t\\t\\t\\temit Approval(_from, msg.sender, _allowance);\\r\\n\\t\\t\\t\\t}\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\r\\n\\t\\t// at this point we know that either sender is ROLE_TOKEN_DESTROYER or\\r\\n\\t\\t// we burn own tokens or on behalf (in latest case we already checked and updated allowances)\\r\\n\\t\\t// we have left to execute balance checks and burning logic itself\\r\\n\\r\\n\\t\\t// non-zero burn value check\\r\\n\\t\\trequire(_value != 0, \\\"zero value burn\\\");\\r\\n\\r\\n\\t\\t// non-zero source address check - Zeppelin\\r\\n\\t\\trequire(_from != address(0), \\\"burn from the zero address\\\");\\r\\n\\r\\n\\t\\t// verify `_from` address has enough tokens to destroy\\r\\n\\t\\t// (basically this is a arithmetic overflow check)\\r\\n\\t\\trequire(tokenBalances[_from] >= _value, \\\"burn amount exceeds balance\\\");\\r\\n\\r\\n\\t\\t// perform burn:\\r\\n\\t\\t// decrease `_from` address balance\\r\\n\\t\\ttokenBalances[_from] -= _value;\\r\\n\\r\\n\\t\\t// decrease total amount of tokens value\\r\\n\\t\\ttotalSupply -= _value;\\r\\n\\r\\n\\t\\t// fire a burnt event\\r\\n\\t\\temit Burnt(msg.sender, _from, _value);\\r\\n\\r\\n\\t\\t// emit an improved transfer event (arXiv:1907.00903)\\r\\n\\t\\temit Transfer(msg.sender, _from, address(0), _value);\\r\\n\\r\\n\\t\\t// fire ERC20 compliant transfer event\\r\\n\\t\\temit Transfer(_from, address(0), _value);\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: Minting/burning extension =====\\r\\n\\r\\n\\t// ===== Start: EIP-2612 functions =====\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc EIP2612\\r\\n\\t *\\r\\n\\t * @dev Executes approve(_spender, _value) on behalf of the owner who EIP-712\\r\\n\\t *      signed the transaction, i.e. as if transaction sender is the EIP712 signer\\r\\n\\t *\\r\\n\\t * @dev Sets the `_value` as the allowance of `_spender` over `_owner` tokens,\\r\\n\\t *      given `_owner` EIP-712 signed approval\\r\\n\\t *\\r\\n\\t * @dev Inherits the Multiple Withdrawal Attack on ERC20 Tokens (arXiv:1907.00903)\\r\\n\\t *      vulnerability in the same way as ERC20 `approve`, use standard ERC20 workaround\\r\\n\\t *      if this might become an issue:\\r\\n\\t *      https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit\\r\\n\\t *\\r\\n\\t * @dev Emits `Approval` event(s) in the same way as `approve` does\\r\\n\\t *\\r\\n\\t * @dev Requires:\\r\\n\\t *     - `_spender` to be non-zero address\\r\\n\\t *     - `_exp` to be a timestamp in the future\\r\\n\\t *     - `v`, `r` and `s` to be a valid `secp256k1` signature from `_owner`\\r\\n\\t *        over the EIP712-formatted function arguments.\\r\\n\\t *     - the signature to use `_owner` current nonce (see `nonces`).\\r\\n\\t *\\r\\n\\t * @dev For more information on the signature format, see the\\r\\n\\t *      https://eips.ethereum.org/EIPS/eip-2612#specification\\r\\n\\t *\\r\\n\\t * @param _owner owner of the tokens to set approval on behalf of,\\r\\n\\t *      an address which signed the EIP-712 message\\r\\n\\t * @param _spender an address approved by the token owner\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t * @param _exp signature expiration time (unix timestamp)\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction permit(address _owner, address _spender, uint256 _value, uint256 _exp, uint8 v, bytes32 r, bytes32 s) public override {\\r\\n\\t\\t// verify permits are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_EIP2612_PERMITS), \\\"EIP2612 permits are disabled\\\");\\r\\n\\r\\n\\t\\t// derive signer of the EIP712 Permit message, and\\r\\n\\t\\t// update the nonce for that particular signer to avoid replay attack!!! --------->>> \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(PERMIT_TYPEHASH, _owner, _spender, _value, nonces[_owner]++, _exp), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _owner, \\\"invalid signature\\\");\\r\\n\\t\\trequire(block.timestamp < _exp, \\\"signature expired\\\");\\r\\n\\r\\n\\t\\t// delegate call to `__approve` - execute the logic required\\r\\n\\t\\t__approve(_owner, _spender, _value);\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: EIP-2612 functions =====\\r\\n\\r\\n\\t// ===== Start: EIP-3009 functions =====\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc EIP3009\\r\\n\\t *\\r\\n\\t * @notice Checks if specified nonce was already used\\r\\n\\t *\\r\\n\\t * @dev Nonces are expected to be client-side randomly generated 32-byte values\\r\\n\\t *      unique to the authorizer's address\\r\\n\\t *\\r\\n\\t * @dev Alias for usedNonces(authorizer, nonce)\\r\\n\\t *\\r\\n\\t * @param _authorizer an address to check nonce for\\r\\n\\t * @param _nonce a nonce to check\\r\\n\\t * @return true if the nonce was used, false otherwise\\r\\n\\t */\\r\\n\\tfunction authorizationState(address _authorizer, bytes32 _nonce) public override view returns (bool) {\\r\\n\\t\\t// simply return the value from the mapping\\r\\n\\t\\treturn usedNonces[_authorizer][_nonce];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc EIP3009\\r\\n\\t *\\r\\n\\t * @notice Execute a transfer with a signed authorization\\r\\n\\t *\\r\\n\\t * @param _from token sender and transaction authorizer\\r\\n\\t * @param _to token receiver\\r\\n\\t * @param _value amount to be transferred\\r\\n\\t * @param _validAfter signature valid after time (unix timestamp)\\r\\n\\t * @param _validBefore signature valid before time (unix timestamp)\\r\\n\\t * @param _nonce unique random nonce\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction transferWithAuthorization(\\r\\n\\t\\taddress _from,\\r\\n\\t\\taddress _to,\\r\\n\\t\\tuint256 _value,\\r\\n\\t\\tuint256 _validAfter,\\r\\n\\t\\tuint256 _validBefore,\\r\\n\\t\\tbytes32 _nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) public override {\\r\\n\\t\\t// ensure EIP-3009 transfers are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_EIP3009_TRANSFERS), \\\"EIP3009 transfers are disabled\\\");\\r\\n\\r\\n\\t\\t// derive signer of the EIP712 TransferWithAuthorization message\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(TRANSFER_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _from, \\\"invalid signature\\\");\\r\\n\\t\\trequire(block.timestamp > _validAfter, \\\"signature not yet valid\\\");\\r\\n\\t\\trequire(block.timestamp < _validBefore, \\\"signature expired\\\");\\r\\n\\r\\n\\t\\t// use the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(_from, _nonce, false);\\r\\n\\r\\n\\t\\t// delegate call to `__transferFrom` - execute the logic required\\r\\n\\t\\t__transferFrom(signer, _from, _to, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc EIP3009\\r\\n\\t *\\r\\n\\t * @notice Receive a transfer with a signed authorization from the payer\\r\\n\\t *\\r\\n\\t * @dev This has an additional check to ensure that the payee's address\\r\\n\\t *      matches the caller of this function to prevent front-running attacks.\\r\\n\\t *\\r\\n\\t * @param _from token sender and transaction authorizer\\r\\n\\t * @param _to token receiver\\r\\n\\t * @param _value amount to be transferred\\r\\n\\t * @param _validAfter signature valid after time (unix timestamp)\\r\\n\\t * @param _validBefore signature valid before time (unix timestamp)\\r\\n\\t * @param _nonce unique random nonce\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction receiveWithAuthorization(\\r\\n\\t\\taddress _from,\\r\\n\\t\\taddress _to,\\r\\n\\t\\tuint256 _value,\\r\\n\\t\\tuint256 _validAfter,\\r\\n\\t\\tuint256 _validBefore,\\r\\n\\t\\tbytes32 _nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) public override {\\r\\n\\t\\t// verify EIP3009 receptions are enabled\\r\\n\\t\\trequire(isFeatureEnabled(FEATURE_EIP3009_RECEPTIONS), \\\"EIP3009 receptions are disabled\\\");\\r\\n\\r\\n\\t\\t// derive signer of the EIP712 ReceiveWithAuthorization message\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(RECEIVE_WITH_AUTHORIZATION_TYPEHASH, _from, _to, _value, _validAfter, _validBefore, _nonce), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _from, \\\"invalid signature\\\");\\r\\n\\t\\trequire(block.timestamp > _validAfter, \\\"signature not yet valid\\\");\\r\\n\\t\\trequire(block.timestamp < _validBefore, \\\"signature expired\\\");\\r\\n\\t\\trequire(_to == msg.sender, \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// use the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(_from, _nonce, false);\\r\\n\\r\\n\\t\\t// delegate call to `__transferFrom` - execute the logic required\\r\\n\\t\\t__transferFrom(signer, _from, _to, _value);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @inheritdoc EIP3009\\r\\n\\t *\\r\\n\\t * @notice Attempt to cancel an authorization\\r\\n\\t *\\r\\n\\t * @param _authorizer transaction authorizer\\r\\n\\t * @param _nonce unique random nonce to cancel (mark as used)\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction cancelAuthorization(\\r\\n\\t\\taddress _authorizer,\\r\\n\\t\\tbytes32 _nonce,\\r\\n\\t\\tuint8 v,\\r\\n\\t\\tbytes32 r,\\r\\n\\t\\tbytes32 s\\r\\n\\t) public override {\\r\\n\\t\\t// derive signer of the EIP712 ReceiveWithAuthorization message\\r\\n\\t\\taddress signer = __deriveSigner(abi.encode(CANCEL_AUTHORIZATION_TYPEHASH, _authorizer, _nonce), v, r, s);\\r\\n\\r\\n\\t\\t// perform message integrity and security validations\\r\\n\\t\\trequire(signer == _authorizer, \\\"invalid signature\\\");\\r\\n\\r\\n\\t\\t// cancel the nonce supplied (verify, mark as used, emit event)\\r\\n\\t\\t__useNonce(_authorizer, _nonce, true);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to verify structured EIP712 message signature and derive its signer\\r\\n\\t *\\r\\n\\t * @param abiEncodedTypehash abi.encode of the message typehash together with all its parameters\\r\\n\\t * @param v the recovery byte of the signature\\r\\n\\t * @param r half of the ECDSA signature pair\\r\\n\\t * @param s half of the ECDSA signature pair\\r\\n\\t */\\r\\n\\tfunction __deriveSigner(bytes memory abiEncodedTypehash, uint8 v, bytes32 r, bytes32 s) private view returns(address) {\\r\\n\\t\\t// build the EIP-712 hashStruct of the message\\r\\n\\t\\tbytes32 hashStruct = keccak256(abiEncodedTypehash);\\r\\n\\r\\n\\t\\t// calculate the EIP-712 digest \\\"\\\\x19\\\\x01\\\" \u2016 domainSeparator \u2016 hashStruct(message)\\r\\n\\t\\tbytes32 digest = keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", DOMAIN_SEPARATOR, hashStruct));\\r\\n\\r\\n\\t\\t// recover the address which signed the message with v, r, s\\r\\n\\t\\taddress signer = ECDSA.recover(digest, v, r, s);\\r\\n\\r\\n\\t\\t// return the signer address derived from the signature\\r\\n\\t\\treturn signer;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Auxiliary function to use/cancel the nonce supplied for a given authorizer:\\r\\n\\t *      1. Verifies the nonce was not used before\\r\\n\\t *      2. Marks the nonce as used\\r\\n\\t *      3. Emits an event that the nonce was used/cancelled\\r\\n\\t *\\r\\n\\t * @dev Set `_cancellation` to false (default) to use nonce,\\r\\n\\t *      set `_cancellation` to true to cancel nonce\\r\\n\\t *\\r\\n\\t * @dev It is expected that the nonce supplied is a randomly\\r\\n\\t *      generated uint256 generated by the client\\r\\n\\t *\\r\\n\\t * @param _authorizer an address to use/cancel nonce for\\r\\n\\t * @param _nonce random nonce to use\\r\\n\\t * @param _cancellation true to emit `AuthorizationCancelled`, false to emit `AuthorizationUsed` event\\r\\n\\t */\\r\\n\\tfunction __useNonce(address _authorizer, bytes32 _nonce, bool _cancellation) private {\\r\\n\\t\\t// verify nonce was not used before\\r\\n\\t\\trequire(!usedNonces[_authorizer][_nonce], \\\"invalid nonce\\\");\\r\\n\\r\\n\\t\\t// update the nonce state to \\\"used\\\" for that particular signer to avoid replay attack\\r\\n\\t\\tusedNonces[_authorizer][_nonce] = true;\\r\\n\\r\\n\\t\\t// depending on the usage type (use/cancel)\\r\\n\\t\\tif(_cancellation) {\\r\\n\\t\\t\\t// emit an event regarding the nonce cancelled\\r\\n\\t\\t\\temit AuthorizationCanceled(_authorizer, _nonce);\\r\\n\\t\\t}\\r\\n\\t\\telse {\\r\\n\\t\\t\\t// emit an event regarding the nonce used\\r\\n\\t\\t\\temit AuthorizationUsed(_authorizer, _nonce);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n\\r\\n\\t// ===== End: EIP-3009 functions =====\\r\\n}\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/utils/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title Access Control List\\r\\n *\\r\\n * @notice Access control smart contract provides an API to check\\r\\n *      if specific operation is permitted globally and/or\\r\\n *      if particular user has a permission to execute it.\\r\\n *\\r\\n * @notice It deals with two main entities: features and roles.\\r\\n *\\r\\n * @notice Features are designed to be used to enable/disable specific\\r\\n *      functions (public functions) of the smart contract for everyone.\\r\\n * @notice User roles are designed to restrict access to specific\\r\\n *      functions (restricted functions) of the smart contract to some users.\\r\\n *\\r\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\r\\n *      in the documentation text and may be used interchangeably.\\r\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\r\\n *\\r\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\r\\n *      Access managers can only grant/revoke permissions which they have themselves.\\r\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\r\\n *      access manager permission and nothing else.\\r\\n *\\r\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\r\\n *      Access manager with even no other permission can interfere with another account by\\r\\n *      granting own access manager permission to it and effectively creating more powerful\\r\\n *      permission set than its own.\\r\\n *\\r\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\r\\n *      to check/know \\\"who is allowed to do this thing\\\".\\r\\n * @dev Zeppelin implementation is more flexible:\\r\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\r\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\r\\n * @dev Current implementation is more lightweight:\\r\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\r\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\r\\n *        setting only one role in a single transaction\\r\\n *\\r\\n * @dev This smart contract is designed to be inherited by other\\r\\n *      smart contracts which require access control management capabilities.\\r\\n *\\r\\n * @dev Access manager permission has a bit 255 set.\\r\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\r\\n *\\r\\n * @author Unblock Technolabs (Vijay Bhayani)\\r\\n */\\r\\ncontract AccessControl {\\r\\n\\t/**\\r\\n\\t * @notice Access manager is responsible for assigning the roles to users,\\r\\n\\t *      enabling/disabling global features of the smart contract\\r\\n\\t * @notice Access manager can add, remove and update user roles,\\r\\n\\t *      remove and update global features\\r\\n\\t *\\r\\n\\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\\r\\n\\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\\r\\n\\t */\\r\\n\\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Bitmask representing all the possible permissions (super admin role)\\r\\n\\t * @dev Has all the bits are enabled (2^256 - 1 value)\\r\\n\\t */\\r\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Privileged addresses with defined roles/permissions\\r\\n\\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\\r\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\r\\n\\t *\\r\\n\\t * @dev Maps user address to the permissions bitmask (role), where each bit\\r\\n\\t *      represents a permission\\r\\n\\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\r\\n\\t *      represents all possible permissions\\r\\n\\t * @dev 'This' address mapping represents global features of the smart contract\\r\\n\\t */\\r\\n\\tmapping(address => uint256) public userRoles;\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in updateRole() and updateFeatures()\\r\\n\\t *\\r\\n\\t * @param _by operator which called the function\\r\\n\\t * @param _to address which was granted/revoked permissions\\r\\n\\t * @param _requested permissions requested\\r\\n\\t * @param _actual permissions effectively set\\r\\n\\t */\\r\\n\\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Creates an access control instance,\\r\\n\\t *      setting contract creator to have full privileges\\r\\n\\t */\\r\\n\\tconstructor() {\\r\\n\\t\\t// contract creator has full privileges\\r\\n\\t\\tuserRoles[msg.sender] = FULL_PRIVILEGES_MASK;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Retrieves globally set of features enabled\\r\\n\\t *\\r\\n\\t * @dev Effectively reads userRoles role for the contract itself\\r\\n\\t *\\r\\n\\t * @return 256-bit bitmask of the features enabled\\r\\n\\t */\\r\\n\\tfunction features() public view returns(uint256) {\\r\\n\\t\\t// features are stored in 'this' address  mapping of `userRoles` structure\\r\\n\\t\\treturn userRoles[address(this)];\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates set of the globally enabled features (`features`),\\r\\n\\t *      taking into account sender's permissions\\r\\n\\t *\\r\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\r\\n\\t * @dev Function is left for backward compatibility with older versions\\r\\n\\t *\\r\\n\\t * @param _mask bitmask representing a set of features to enable/disable\\r\\n\\t */\\r\\n\\tfunction updateFeatures(uint256 _mask) public {\\r\\n\\t\\t// delegate call to `updateRole`\\r\\n\\t\\tupdateRole(address(this), _mask);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Updates set of permissions (role) for a given user,\\r\\n\\t *      taking into account sender's permissions.\\r\\n\\t *\\r\\n\\t * @dev Setting role to zero is equivalent to removing an all permissions\\r\\n\\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\\r\\n\\t *      copying senders' permissions (role) to the user\\r\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\r\\n\\t *\\r\\n\\t * @param operator address of a user to alter permissions for or zero\\r\\n\\t *      to alter global features of the smart contract\\r\\n\\t * @param role bitmask representing a set of permissions to\\r\\n\\t *      enable/disable for a user specified\\r\\n\\t */\\r\\n\\tfunction updateRole(address operator, uint256 role) public {\\r\\n\\t\\t// caller must have a permission to update user roles\\r\\n\\t\\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \\\"access denied\\\");\\r\\n\\r\\n\\t\\t// evaluate the role and reassign it\\r\\n\\t\\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\\r\\n\\r\\n\\t\\t// fire an event\\r\\n\\t\\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Determines the permission bitmask an operator can set on the\\r\\n\\t *      target permission set\\r\\n\\t * @notice Used to calculate the permission bitmask to be set when requested\\r\\n\\t *     in `updateRole` and `updateFeatures` functions\\r\\n\\t *\\r\\n\\t * @dev Calculated based on:\\r\\n\\t *      1) operator's own permission set read from userRoles[operator]\\r\\n\\t *      2) target permission set - what is already set on the target\\r\\n\\t *      3) desired permission set - what do we want set target to\\r\\n\\t *\\r\\n\\t * @dev Corner cases:\\r\\n\\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\\r\\n\\t *        `desired` bitset is returned regardless of the `target` permission set value\\r\\n\\t *        (what operator sets is what they get)\\r\\n\\t *      2) Operator with no permissions (zero bitset):\\r\\n\\t *        `target` bitset is returned regardless of the `desired` value\\r\\n\\t *        (operator has no authority and cannot modify anything)\\r\\n\\t *\\r\\n\\t * @dev Example:\\r\\n\\t *      Consider an operator with the permissions bitmask     00001111\\r\\n\\t *      is about to modify the target permission set          01010101\\r\\n\\t *      Operator wants to set that permission set to          00110011\\r\\n\\t *      Based on their role, an operator has the permissions\\r\\n\\t *      to update only lowest 4 bits on the target, meaning that\\r\\n\\t *      high 4 bits of the target set in this example is left\\r\\n\\t *      unchanged and low 4 bits get changed as desired:      01010011\\r\\n\\t *\\r\\n\\t * @param operator address of the contract operator which is about to set the permissions\\r\\n\\t * @param target input set of permissions to operator is going to modify\\r\\n\\t * @param desired desired set of permissions operator would like to set\\r\\n\\t * @return resulting set of permissions given operator will set\\r\\n\\t */\\r\\n\\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns(uint256) {\\r\\n\\t\\t// read operator's permissions\\r\\n\\t\\tuint256 p = userRoles[operator];\\r\\n\\r\\n\\t\\t// taking into account operator's permissions,\\r\\n\\t\\t// 1) enable the permissions desired on the `target`\\r\\n\\t\\ttarget |= p & desired;\\r\\n\\t\\t// 2) disable the permissions desired on the `target`\\r\\n\\t\\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\\r\\n\\r\\n\\t\\t// return calculated result\\r\\n\\t\\treturn target;\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if requested set of features is enabled globally on the contract\\r\\n\\t *\\r\\n\\t * @param required set of features to check against\\r\\n\\t * @return true if all the features requested are enabled, false otherwise\\r\\n\\t */\\r\\n\\tfunction isFeatureEnabled(uint256 required) public view returns(bool) {\\r\\n\\t\\t// delegate call to `__hasRole`, passing `features` property\\r\\n\\t\\treturn __hasRole(features(), required);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\\r\\n\\t *\\r\\n\\t * @param required set of permissions (role) to check against\\r\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\r\\n\\t */\\r\\n\\tfunction isSenderInRole(uint256 required) public view returns(bool) {\\r\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\r\\n\\t\\treturn isOperatorInRole(msg.sender, required);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Checks if operator has all the permissions (role) required\\r\\n\\t *\\r\\n\\t * @param operator address of the user to check role for\\r\\n\\t * @param required set of permissions (role) to check\\r\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\r\\n\\t */\\r\\n\\tfunction isOperatorInRole(address operator, uint256 required) public view returns(bool) {\\r\\n\\t\\t// delegate call to `__hasRole`, passing operator's permissions (role)\\r\\n\\t\\treturn __hasRole(userRoles[operator], required);\\r\\n\\t}\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Checks if role `actual` contains all the permissions required `required`\\r\\n\\t *\\r\\n\\t * @param actual existent role\\r\\n\\t * @param required required role\\r\\n\\t * @return true if actual has required role (all permissions), false otherwise\\r\\n\\t */\\r\\n\\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns(bool) {\\r\\n\\t\\t// check the bitmask for the role required and return the result\\r\\n\\t\\treturn actual & required == required;\\r\\n\\t}\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/utils/UpgradeableAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\n\\n/**\\n * @title Upgradeable Access Control List // ERC1967Proxy\\n *\\n * @notice Access control smart contract provides an API to check\\n *      if a specific operation is permitted globally and/or\\n *      if a particular user has a permission to execute it.\\n *\\n * @notice It deals with two main entities: features and roles.\\n *\\n * @notice Features are designed to be used to enable/disable public functions\\n *      of the smart contract (used by a wide audience).\\n * @notice User roles are designed to control the access to restricted functions\\n *      of the smart contract (used by a limited set of maintainers).\\n *\\n * @notice Terms \\\"role\\\", \\\"permissions\\\" and \\\"set of permissions\\\" have equal meaning\\n *      in the documentation text and may be used interchangeably.\\n * @notice Terms \\\"permission\\\", \\\"single permission\\\" implies only one permission bit set.\\n *\\n * @notice Access manager is a special role which allows to grant/revoke other roles.\\n *      Access managers can only grant/revoke permissions which they have themselves.\\n *      As an example, access manager with no other roles set can only grant/revoke its own\\n *      access manager permission and nothing else.\\n *\\n * @notice Access manager permission should be treated carefully, as a super admin permission:\\n *      Access manager with even no other permission can interfere with another account by\\n *      granting own access manager permission to it and effectively creating more powerful\\n *      permission set than its own.\\n *\\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\\n *      to check/know \\\"who is allowed to do this thing\\\".\\n * @dev Zeppelin implementation is more flexible:\\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\\n *      - it allows setting an admin for each role, while current allows having only one global admin\\n * @dev Current implementation is more lightweight:\\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\\n *        setting only one role in a single transaction\\n *\\n * @dev This smart contract is designed to be inherited by other\\n *      smart contracts which require access control management capabilities.\\n *\\n * @dev Access manager permission has a bit 255 set.\\n *      This bit must not be used by inheriting contracts for any other permissions/features.\\n *\\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\\n *\\n * @author Unblock Technolabs (Vijay Bhayani)\\n */\\n// TODO: add version history: 2018-2021\\nabstract contract UpgradeableAccessControl is UUPSUpgradeable {\\n\\t/**\\n\\t * @notice Privileged addresses with defined roles/permissions\\n\\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\\n\\t *      allow minting or burning tokens, transferring on behalf and so on\\n\\t *\\n\\t * @dev Maps user address to the permissions bitmask (role), where each bit\\n\\t *      represents a permission\\n\\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\\n\\t *      represents all possible permissions\\n\\t * @dev 'This' address mapping represents global features of the smart contract\\n\\t */\\n\\tmapping(address => uint256) public userRoles;\\n\\n\\t/**\\n\\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\\n\\t *      the amount of storage used by a contract always adds up to the 50.\\n\\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n\\t */\\n\\tuint256[49] private __gap;\\n\\n\\t/**\\n\\t * @notice Access manager is responsible for assigning the roles to users,\\n\\t *      enabling/disabling global features of the smart contract\\n\\t * @notice Access manager can add, remove and update user roles,\\n\\t *      remove and update global features\\n\\t *\\n\\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\\n\\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\\n\\t */\\n\\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t/**\\n\\t * @notice Upgrade manager is responsible for smart contract upgrades,\\n\\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\\n\\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\\n\\t *\\n\\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\\n\\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\\n\\t */\\n\\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\\n\\n\\t/**\\n\\t * @dev Bitmask representing all the possible permissions (super admin role)\\n\\t * @dev Has all the bits are enabled (2^256 - 1 value)\\n\\t */\\n\\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\\n\\n\\t/**\\n\\t * @dev Fired in updateRole() and updateFeatures()\\n\\t *\\n\\t * @param _by operator which called the function\\n\\t * @param _to address which was granted/revoked permissions\\n\\t * @param _requested permissions requested\\n\\t * @param _actual permissions effectively set\\n\\t */\\n\\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\\n\\n\\t/**\\n\\t * @dev UUPS initializer, sets the contract owner to have full privileges\\n\\t *\\n\\t * @dev Can be executed only in constructor during deployment,\\n\\t *      reverts when executed in already deployed contract\\n\\t *\\n\\t * @dev IMPORTANT:\\n\\t *      this function MUST be executed during proxy deployment (in proxy constructor),\\n\\t *      otherwise it renders useless and cannot be executed at all,\\n\\t *      resulting in no admin control over the proxy and no possibility to do future upgrades\\n\\t *\\n\\t * @param _owner smart contract owner having full privileges\\n\\t */\\n\\tfunction _postConstruct(address _owner) internal virtual initializer {\\n\\t\\t// ensure this function is execute only in constructor\\n\\t\\trequire(!AddressUpgradeable.isContract(address(this)), \\\"invalid context\\\");\\n\\n\\t\\t// grant owner full privileges\\n\\t\\tuserRoles[_owner] = FULL_PRIVILEGES_MASK;\\n\\n\\t\\t// fire an event\\n\\t\\temit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Returns an address of the implementation smart contract,\\n\\t *      see ERC1967Upgrade._getImplementation()\\n\\t *\\n\\t * @return the current implementation address\\n\\t */\\n\\tfunction getImplementation() public view virtual returns (address) {\\n\\t\\t// delegate to `ERC1967Upgrade._getImplementation()`\\n\\t\\treturn _getImplementation();\\n\\t}\\n\\n\\t/**\\n\\t * @notice Retrieves globally set of features enabled\\n\\t *\\n\\t * @dev Effectively reads userRoles role for the contract itself\\n\\t *\\n\\t * @return 256-bit bitmask of the features enabled\\n\\t */\\n\\tfunction features() public view returns (uint256) {\\n\\t\\t// features are stored in 'this' address  mapping of `userRoles` structure\\n\\t\\treturn userRoles[address(this)];\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of the globally enabled features (`features`),\\n\\t *      taking into account sender's permissions\\n\\t *\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t * @dev Function is left for backward compatibility with older versions\\n\\t *\\n\\t * @param _mask bitmask representing a set of features to enable/disable\\n\\t */\\n\\tfunction updateFeatures(uint256 _mask) public {\\n\\t\\t// delegate call to `updateRole`\\n\\t\\tupdateRole(address(this), _mask);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Updates set of permissions (role) for a given user,\\n\\t *      taking into account sender's permissions.\\n\\t *\\n\\t * @dev Setting role to zero is equivalent to removing an all permissions\\n\\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\\n\\t *      copying senders' permissions (role) to the user\\n\\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\\n\\t *\\n\\t * @param operator address of a user to alter permissions for or zero\\n\\t *      to alter global features of the smart contract\\n\\t * @param role bitmask representing a set of permissions to\\n\\t *      enable/disable for a user specified\\n\\t */\\n\\tfunction updateRole(address operator, uint256 role) public {\\n\\t\\t// caller must have a permission to update user roles\\n\\t\\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \\\"access denied\\\");\\n\\n\\t\\t// evaluate the role and reassign it\\n\\t\\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\\n\\n\\t\\t// fire an event\\n\\t\\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Determines the permission bitmask an operator can set on the\\n\\t *      target permission set\\n\\t * @notice Used to calculate the permission bitmask to be set when requested\\n\\t *     in `updateRole` and `updateFeatures` functions\\n\\t *\\n\\t * @dev Calculated based on:\\n\\t *      1) operator's own permission set read from userRoles[operator]\\n\\t *      2) target permission set - what is already set on the target\\n\\t *      3) desired permission set - what do we want set target to\\n\\t *\\n\\t * @dev Corner cases:\\n\\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\\n\\t *        `desired` bitset is returned regardless of the `target` permission set value\\n\\t *        (what operator sets is what they get)\\n\\t *      2) Operator with no permissions (zero bitset):\\n\\t *        `target` bitset is returned regardless of the `desired` value\\n\\t *        (operator has no authority and cannot modify anything)\\n\\t *\\n\\t * @dev Example:\\n\\t *      Consider an operator with the permissions bitmask     00001111\\n\\t *      is about to modify the target permission set          01010101\\n\\t *      Operator wants to set that permission set to          00110011\\n\\t *      Based on their role, an operator has the permissions\\n\\t *      to update only lowest 4 bits on the target, meaning that\\n\\t *      high 4 bits of the target set in this example is left\\n\\t *      unchanged and low 4 bits get changed as desired:      01010011\\n\\t *\\n\\t * @param operator address of the contract operator which is about to set the permissions\\n\\t * @param target input set of permissions to operator is going to modify\\n\\t * @param desired desired set of permissions operator would like to set\\n\\t * @return resulting set of permissions given operator will set\\n\\t */\\n\\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns (uint256) {\\n\\t\\t// read operator's permissions\\n\\t\\tuint256 p = userRoles[operator];\\n\\n\\t\\t// taking into account operator's permissions,\\n\\t\\t// 1) enable the permissions desired on the `target`\\n\\t\\ttarget |= p & desired;\\n\\t\\t// 2) disable the permissions desired on the `target`\\n\\t\\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\\n\\n\\t\\t// return calculated result\\n\\t\\treturn target;\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if requested set of features is enabled globally on the contract\\n\\t *\\n\\t * @param required set of features to check against\\n\\t * @return true if all the features requested are enabled, false otherwise\\n\\t */\\n\\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\\n\\t\\t// delegate call to `__hasRole`, passing `features` property\\n\\t\\treturn __hasRole(features(), required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\\n\\t *\\n\\t * @param required set of permissions (role) to check against\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isSenderInRole(uint256 required) public view returns (bool) {\\n\\t\\t// delegate call to `isOperatorInRole`, passing transaction sender\\n\\t\\treturn isOperatorInRole(msg.sender, required);\\n\\t}\\n\\n\\t/**\\n\\t * @notice Checks if operator has all the permissions (role) required\\n\\t *\\n\\t * @param operator address of the user to check role for\\n\\t * @param required set of permissions (role) to check\\n\\t * @return true if all the permissions requested are enabled, false otherwise\\n\\t */\\n\\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\\n\\t\\t// delegate call to `__hasRole`, passing operator's permissions (role)\\n\\t\\treturn __hasRole(userRoles[operator], required);\\n\\t}\\n\\n\\t/**\\n\\t * @dev Checks if role `actual` contains all the permissions required `required`\\n\\t *\\n\\t * @param actual existent role\\n\\t * @param required required role\\n\\t * @return true if actual has required role (all permissions), false otherwise\\n\\t */\\n\\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\\n\\t\\t// check the bitmask for the role required and return the result\\n\\t\\treturn actual & required == required;\\n\\t}\\n\\n\\t/**\\n\\t * @inheritdoc UUPSUpgradeable\\n\\t */\\n\\tfunction _authorizeUpgrade(address) internal virtual override {\\n\\t\\t// caller must have a permission to upgrade the contract\\n\\t\\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \\\"access denied\\\");\\n\\t}\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_patchFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_requested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_actual\",\"type\":\"uint256\"}],\"name\":\"RoleUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ROLE_ACCESS_MANAGER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_CONFIG_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ROLE_PATCH_REGISTERY_MANAGER\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"target\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"desired\",\"type\":\"uint256\"}],\"name\":\"evaluateBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"features\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isFeatureEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isOperatorInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"isSenderInRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"patchFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_patchName\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_patchDetailURI\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_treePlantedArea\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_plantedTreeVolume\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_initialOwner\",\"type\":\"address\"},{\"internalType\":\"uint256[][]\",\"name\":\"_patchGeoFenseDetails\",\"type\":\"uint256[][]\"}],\"name\":\"registerPatch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_mask\",\"type\":\"uint256\"}],\"name\":\"updateFeatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPatchFactory\",\"type\":\"address\"}],\"name\":\"updatePatchFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"role\",\"type\":\"uint256\"}],\"name\":\"updateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userRoles\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "PatchFactoryHelper", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c9a699994c315ffe2a21d0adda7cb7f7b38de8aa", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}