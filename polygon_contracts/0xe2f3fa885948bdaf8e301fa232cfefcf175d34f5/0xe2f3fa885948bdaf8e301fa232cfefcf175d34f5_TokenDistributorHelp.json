{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"contracts/interfaces/ERC20Spec.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\n/**\\r\\n * @title EIP-20: ERC-20 Token Standard\\r\\n *\\r\\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\\r\\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\\r\\n *\\r\\n * @notice It provides functionalities like to transfer tokens from one account to another,\\r\\n *      to get the current token balance of an account and also the total supply of the token available on the network.\\r\\n *      Besides these it also has some other functionalities like to approve that an amount of\\r\\n *      token from an account can be spent by a third party account.\\r\\n *\\r\\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\\r\\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\\r\\n *\\r\\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\\r\\n * @notice See https://eips.ethereum.org/EIPS/eip-20\\r\\n */\\r\\ninterface ERC20 {\\r\\n\\t/**\\r\\n\\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\\r\\n\\t *\\r\\n\\t * @param from an address tokens were consumed from\\r\\n\\t * @param to an address tokens were sent to\\r\\n\\t * @param value number of tokens transferred\\r\\n\\t */\\r\\n\\tevent Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Fired in approve() to indicate an approval event happened\\r\\n\\t *\\r\\n\\t * @param owner an address which granted a permission to transfer\\r\\n\\t *      tokens on its behalf\\r\\n\\t * @param spender an address which received a permission to transfer\\r\\n\\t *      tokens on behalf of the owner `_owner`\\r\\n\\t * @param value amount of tokens granted to transfer on behalf\\r\\n\\t */\\r\\n\\tevent Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return name of the token (ex.: USD Coin)\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function name() external view returns (string memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return symbol of the token (ex.: USDC)\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function symbol() external view returns (string memory);\\r\\n\\r\\n\\t/**\\r\\n\\t * @dev Returns the number of decimals used to get its user representation.\\r\\n\\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\\r\\n\\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\\r\\n\\t *\\r\\n\\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\\r\\n\\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\\r\\n\\t *      overridden;\\r\\n\\t *\\r\\n\\t * @dev NOTE: This information is only used for _display_ purposes: it in\\r\\n\\t *      no way affects any of the arithmetic of the contract, including\\r\\n\\t *      {IERC20-balanceOf} and {IERC20-transfer}.\\r\\n\\t *\\r\\n\\t * @return token decimals\\r\\n\\t */\\r\\n\\t// OPTIONAL - This method can be used to improve usability,\\r\\n\\t// but interfaces and other contracts MUST NOT expect these values to be present.\\r\\n\\t// function decimals() external view returns (uint8);\\r\\n\\r\\n\\t/**\\r\\n\\t * @return the amount of tokens in existence\\r\\n\\t */\\r\\n\\tfunction totalSupply() external view returns (uint256);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Gets the balance of a particular address\\r\\n\\t *\\r\\n\\t * @param _owner the address to query the the balance for\\r\\n\\t * @return balance an amount of tokens owned by the address specified\\r\\n\\t */\\r\\n\\tfunction balanceOf(address _owner) external view returns (uint256 balance);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens to an external address or a smart contract\\r\\n\\t *\\r\\n\\t * @dev Called by token owner (an address which has a\\r\\n\\t *      positive token balance tracked by this smart contract)\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * self address or\\r\\n\\t *          * smart contract which doesn't support ERC20\\r\\n\\t *\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      compliant with the ERC20 standard\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction transfer(address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\\r\\n\\t *      to some other address `_to`\\r\\n\\t *\\r\\n\\t * @dev Called by token owner on his own or approved address,\\r\\n\\t *      an address approved earlier by token owner to\\r\\n\\t *      transfer some amount of tokens on its behalf\\r\\n\\t * @dev Throws on any error like\\r\\n\\t *      * insufficient token balance or\\r\\n\\t *      * incorrect `_to` address:\\r\\n\\t *          * zero address or\\r\\n\\t *          * same as `_from` address (self transfer)\\r\\n\\t *          * smart contract which doesn't support ERC20\\r\\n\\t *\\r\\n\\t * @param _from token owner which approved caller (transaction sender)\\r\\n\\t *      to transfer `_value` of tokens on its behalf\\r\\n\\t * @param _to an address to transfer tokens to,\\r\\n\\t *      must be either an external address or a smart contract,\\r\\n\\t *      compliant with the ERC20 standard\\r\\n\\t * @param _value amount of tokens to be transferred,, zero\\r\\n\\t *      value is allowed\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Approves address called `_spender` to transfer some amount\\r\\n\\t *      of tokens on behalf of the owner (transaction sender)\\r\\n\\t *\\r\\n\\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\\r\\n\\t *\\r\\n\\t * @param _spender an address approved by the caller (token owner)\\r\\n\\t *      to spend some tokens on its behalf\\r\\n\\t * @param _value an amount of tokens spender `_spender` is allowed to\\r\\n\\t *      transfer on behalf of the token owner\\r\\n\\t * @return success true on success, throws otherwise\\r\\n\\t */\\r\\n\\tfunction approve(address _spender, uint256 _value) external returns (bool success);\\r\\n\\r\\n\\t/**\\r\\n\\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\\r\\n\\t *\\r\\n\\t * @dev A function to check an amount of tokens owner approved\\r\\n\\t *      to transfer on its behalf by some other address called \\\"spender\\\"\\r\\n\\t *\\r\\n\\t * @param _owner an address which approves transferring some tokens on its behalf\\r\\n\\t * @param _spender an address approved to transfer some tokens on behalf\\r\\n\\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\\r\\n\\t *      of token owner `_owner`\\r\\n\\t */\\r\\n\\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/TokenDistributorHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.7;\\r\\n\\r\\nimport \\\"../interfaces/ERC20Spec.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Error that occurs when transferring ether has failed.\\r\\n * @param emitter The contract that emits the error.\\r\\n */\\r\\nerror EtherTransferFail(address emitter);\\r\\n\\r\\n/**\\r\\n * @title Native and XCC Token Batch Distributor\\r\\n * @notice Helper smart contract for batch sending both\\r\\n * native and ERC-20 tokens.\\r\\n * @dev Since we use nested struct objects, we rely on the ABI coder v2.\\r\\n * The ABI coder v2 is activated by default since Solidity `v0.8.0`.\\r\\n */\\r\\ncontract TokenDistributorHelper {\\r\\n\\r\\n    /**\\r\\n     * @dev You can cut out 10 opcodes in the creation-time EVM bytecode\\r\\n     * if you declare a constructor `payable`.\\r\\n     *\\r\\n     * For more in-depth information see here:\\r\\n     * https://forum.openzeppelin.com/t/a-collection-of-gas-optimisation-tricks/19966/5.\\r\\n     */\\r\\n    constructor() payable {}\\r\\n\\r\\n    /**\\r\\n     * @dev Distributes ether, denominated in wei, to a predefined batch\\r\\n     * of recipient addresses.\\r\\n     * @notice In the event that excessive ether is sent, the residual\\r\\n     * amount is returned back to the `msg.sender`.\\r\\n     * @param _recipient argument that contains an array of address that\\r\\n     * contain each a recipient address & ether amount in wei.\\r\\n     * @param _amount argument that contains an array of uint256 that\\r\\n     * contain each a recipient ether amount in wei.\\r\\n     */\\r\\n    function distributeEther(address[] calldata _recipient, uint256[] calldata _amount) external payable {\\r\\n        require(_recipient.length == _amount.length, \\r\\n                        \\\"Invalid Input Data!!\\\");\\r\\n        /**\\r\\n         * @dev Caching the length in for loops saves 3 additional gas\\r\\n         * for a `calldata` array for each iteration except for the first.\\r\\n         */\\r\\n        uint256 length = _amount.length;\\r\\n\\r\\n        /**\\r\\n         * @dev If a variable is not set/initialised, it is assumed to have\\r\\n         * the default value. The default value for the `uint` types is 0.\\r\\n         */\\r\\n        for (uint256 i; i < length; i = _uncheckedInc(i)) {\\r\\n            // solhint-disable-next-line avoid-low-level-calls\\r\\n            (bool sent, ) = payable(_recipient[i]).call{\\r\\n                value: _amount[i]\\r\\n            }(\\\"\\\");\\r\\n            if (!sent) revert EtherTransferFail(address(this));\\r\\n        }\\r\\n\\r\\n        uint256 balance = address(this).balance;\\r\\n        if (balance != 0) {\\r\\n            /**\\r\\n             * @dev Any wei amount previously forced into this contract (e.g. by\\r\\n             * using the `SELFDESTRUCT` opcode) will be part of the refund transaction.\\r\\n             */\\r\\n            // solhint-disable-next-line avoid-low-level-calls\\r\\n            (bool refunded, ) = payable(msg.sender).call{value: balance}(\\\"\\\");\\r\\n            if (!refunded) revert EtherTransferFail(address(this));\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Distributes ERC-20 tokens, denominated in their corresponding\\r\\n     * lowest unit, to a predefined batch of recipient addresses.\\r\\n     * @notice To deal with (potentially) non-compliant ERC-20 tokens that\\r\\n     * do have no return value.\\r\\n     * Note: Since we cast the token address into the official ERC-20 interface,\\r\\n     * the use of non-compliant ERC-20 tokens is prevented by design. Nevertheless,\\r\\n     * we keep this guardrail for security reasons.\\r\\n     * @param _token ERC-20 token contract address.\\r\\n     * @param _recipient argument that contains an array of address that\\r\\n     * contain each a recipient address.\\r\\n     * @param _amount argument that contains an array of uint256 that\\r\\n     * contain each a recipient token amount in wei.\\r\\n     */\\r\\n    function distributeToken(ERC20 _token, address[] calldata _recipient, uint256[] calldata _amount) external {\\r\\n        require(_recipient.length == _amount.length, \\r\\n                        \\\"Invalid Input Data!!\\\");\\r\\n\\r\\n        /**\\r\\n         * @dev Caching the length in for loops saves 3 additional gas\\r\\n         * for a `calldata` array for each iteration except for the first.\\r\\n         */\\r\\n        uint256 length = _amount.length;\\r\\n\\r\\n        /**\\r\\n         * @dev If a variable is not set/initialised, it is assumed to have\\r\\n         * the default value. The default value for the `uint` types is 0.\\r\\n         */\\r\\n        uint256 total;\\r\\n        for (uint256 i; i < length; i = _uncheckedInc(i)) {\\r\\n            total += _amount[i];\\r\\n        }\\r\\n\\r\\n        /**\\r\\n         * @dev By combining a `transferFrom` call to itself and then\\r\\n         * distributing the tokens from its own address using `transfer`,\\r\\n         * 5'000 gas is saved on each transfer as `allowance` is only\\r\\n         * touched once.\\r\\n         */\\r\\n        _token.transferFrom(msg.sender, address(this), total);\\r\\n\\r\\n        for (uint256 i; i < length; i = _uncheckedInc(i)) {\\r\\n            _token.transfer(_recipient[i], _amount[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Performs an unchecked incrementation by 1 to save gas.\\r\\n     * @param i The 32-byte increment parameter `i`.\\r\\n     * @return The unchecked increment of the parameter `i`.\\r\\n     */\\r\\n    function _uncheckedInc(uint256 i) private pure returns (uint256) {\\r\\n        /**\\r\\n         * @dev An array can't have a total length\\r\\n         * larger than the max uint256 value.\\r\\n         */\\r\\n        unchecked {\\r\\n            return i + 1;\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emitter\",\"type\":\"address\"}],\"name\":\"EtherTransferFail\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipient\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"distributeEther\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_recipient\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"distributeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TokenDistributorHelper", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}