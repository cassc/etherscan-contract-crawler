{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\nimport { LibDiamond } from \\\"LibDiamond.sol\\\";\\nimport { LibEnvironmentConfig } from \\\"LibEnvironmentConfig.sol\\\";\\nimport { IDiamondCut } from \\\"IDiamondCut.sol\\\";\\n\\ncontract Diamond {\\n\\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\\n        LibDiamond.setContractOwner(_contractOwner);\\n\\n        //  Testnet configurations can be called from DebugFacet\\n        LibEnvironmentConfig.configureForPolygonMainnet();\\n\\n        // Add the diamondCut external function from the diamondCutFacet\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({\\n            facetAddress: _diamondCutFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        // get diamond storage\\n        assembly {\\n            ds.slot := position\\n        }\\n        // get facet from function selector\\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n        require(facet != address(0), \\\"Diamond: Function does not exist\\\");\\n        // Execute external function from facet using delegatecall and return any value.\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n                case 0 {\\n                    revert(0, returndatasize())\\n                }\\n                default {\\n                    return(0, returndatasize())\\n                }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\nimport { IDiamondCut } from \\\"IDiamondCut.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n    }\\n\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address contractOwner_) {\\n        contractOwner_ = diamondStorage().contractOwner;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\n    }\\n\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress == address(0), \\\"LibDiamondCut: Can't add function that already exists\\\");\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            require(oldFacetAddress != _facetAddress, \\\"LibDiamondCut: Can't replace function with same function\\\");\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(_facetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: New facet has no code\\\");\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }\\n\\n\\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Can't remove function that doesn't exist\\\");\\n        // an immutable function is a function defined directly in a diamond\\n        require(_facetAddress != address(this), \\\"LibDiamondCut: Can't remove immutable function\\\");\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            require(_calldata.length == 0, \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\");\\n        } else {\\n            require(_calldata.length > 0, \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\");\\n            if (_init != address(this)) {\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\"\r\n    },\r\n    \"LibEnvironmentConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IDiamondCut } from \\\"IDiamondCut.sol\\\";\\nimport {LibShadowcorn} from \\\"LibShadowcorn.sol\\\";\\nimport {LibShadowcornDNA} from \\\"LibShadowcornDNA.sol\\\";\\nimport {LibRNG} from \\\"LibRNG.sol\\\";\\nimport {LibERC721} from \\\"LibERC721.sol\\\";\\nimport {LibHatching} from \\\"LibHatching.sol\\\";\\nimport {LibNames} from \\\"LibNames.sol\\\";\\n\\n\\nlibrary LibEnvironmentConfig {\\n\\n    uint256 private constant POLYGON_CHAINID = 137;\\n\\n    function configureForPolygonMainnet() internal {\\n        LibERC721.erc721Storage().name = \\\"Crypto Unicorns: Shadowcorns\\\";\\n        LibERC721.erc721Storage().symbol = \\\"SHADOWCORN\\\";\\n        LibERC721.erc721Storage().contractURI = \\\"https://arweave.net/HNvtS6fber4NC80_sEd0MAiUr7UyA3R4GpEFFqyRZAk\\\";\\n        LibERC721.erc721Storage().licenseURI = \\\"https://arweave.net/520gStGJ4Fla9GeG0U9UIm1vYnei8dOnDfznCaJy0IY\\\";\\n\\n        LibHatching.setHatchingCosts(\\n            100000000000000000000,      //  100 RBW\\n            10000000000000000000000     //  10,000 UNIM\\n        );\\n\\n        LibShadowcorn.shadowcornStorage().gameBank = 0x94f557dDdb245b11d031F57BA7F2C4f28C4A203e;\\n        LibShadowcorn.shadowcornStorage().UNIMAddress = 0x64060aB139Feaae7f06Ca4E63189D86aDEb51691;\\n        LibShadowcorn.shadowcornStorage().RBWAddress = 0x431CD3C9AC9Fc73644BF68bF5691f4B83F9E104f;\\n        LibShadowcorn.shadowcornStorage().targetDNAVersion = 1;\\n        LibShadowcorn.shadowcornStorage().terminusAddress = 0x99A558BDBdE247C2B2716f0D4cFb0E246DFB697D;\\n        LibShadowcorn.shadowcornStorage().commonEggPoolId = 1;\\n        LibShadowcorn.shadowcornStorage().rareEggPoolId = 2;\\n        LibShadowcorn.shadowcornStorage().mythicEggPoolId = 3;\\n\\n        LibRNG.rngStorage().vrfBlocksToRespond = 100;\\n        LibRNG.rngStorage().chainlinkVRFKeyhash = 0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;\\n        LibRNG.rngStorage().chainlinkVRFFee = 100000000000000;  // 0.0001\\n        LibRNG.rngStorage().vrfCoordinator = 0x3d2341ADb2D31f1c5530cDC622016af293177AE0;\\n        LibRNG.rngStorage().rngNonce = block.number;\\n        LibRNG.rngStorage().linkTokenAddress = 0xb0897686c545045aFc77CF20eC7A532E3120E0F1;\\n    }\\n\\n    function configureForMumbaiTestnet() internal {\\n        require(block.chainid != POLYGON_CHAINID, \\\"This configuration cannot be loaded on mainnet!\\\");\\n\\n        LibERC721.erc721Storage().name = \\\"Crypto Unicorns: Shadowcorns\\\";\\n        LibERC721.erc721Storage().symbol = \\\"SHADOWCORN\\\";\\n        LibERC721.erc721Storage().contractURI = \\\"https://arweave.net/HNvtS6fber4NC80_sEd0MAiUr7UyA3R4GpEFFqyRZAk\\\";\\n        LibERC721.erc721Storage().licenseURI = \\\"https://arweave.net/520gStGJ4Fla9GeG0U9UIm1vYnei8dOnDfznCaJy0IY\\\";\\n\\n        LibHatching.setHatchingCosts(\\n            100000000000000000000,      //  100 RBW\\n            10000000000000000000000     //  10,000 UNIM\\n        );\\n\\n        LibShadowcorn.shadowcornStorage().gameBank = 0x762aF8cbE298bbFE568BBB6709f854A01c07333D;\\n        LibShadowcorn.shadowcornStorage().UNIMAddress = 0x47d0f0BD94188e3f8c6fF2C0B1Bf7D6D8BED7534;\\n        LibShadowcorn.shadowcornStorage().RBWAddress = 0x4Df452487E6c9d0C3Dc5EB4936244F8572b3F0b6;\\n        LibShadowcorn.shadowcornStorage().targetDNAVersion = 1;\\n        LibShadowcorn.shadowcornStorage().terminusAddress = 0x19e812EdB24B68A8F3AbF5e4C82d10AfEf1641Db;\\n        LibShadowcorn.shadowcornStorage().commonEggPoolId = 5;\\n        LibShadowcorn.shadowcornStorage().rareEggPoolId = 4;\\n        LibShadowcorn.shadowcornStorage().mythicEggPoolId = 3;\\n\\n        LibRNG.rngStorage().vrfBlocksToRespond = 500;\\n        LibRNG.rngStorage().chainlinkVRFKeyhash = 0x6e75b569a01ef56d18cab6a8e71e6600d6ce853834d4a5748b720d06f878b3a4;\\n        LibRNG.rngStorage().chainlinkVRFFee = 100000000000000;  // 0.0001 LINK\\n        LibRNG.rngStorage().vrfCoordinator = 0x8C7382F9D8f56b33781fE506E897a4F1e2d17255;\\n        LibRNG.rngStorage().rngNonce = block.number;\\n        LibRNG.rngStorage().linkTokenAddress = 0x326C977E6efc84E512bB9C30f76E30c160eD06FB;\\n    }\\n\\n    // MISSING THIS PARAMS\\n    // address gameBank, address unim, address rbw, address terminus, address vrfCoordinator, address link\\n    // TODO: Delete initalizers and pass this parameters here.\\n    function configureForLocalhost() internal {\\n        require(block.chainid != POLYGON_CHAINID, \\\"This configuration cannot be loaded on mainnet!\\\");\\n        configureForMumbaiTestnet();    //  for now, copy testnet\\n    }\\n\\n    function loadContent() internal {\\n        configureNFTImages();\\n        loadFirstNames();\\n        loadLastNames();\\n    }\\n\\n\\n    function configureNFTImages() internal {\\n        //  Fire\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[1][1] = \\\"https://arweave.net/k0YZHFW0K1MIBTRFHC-Y-CYJHMV8tngrJSL4lXhvNgA\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[1][2] = \\\"https://arweave.net/EHtorB5YKBuARjE_cEtHTbGsjLDorXobbTHh9hpMNyI\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[1][3] = \\\"https://arweave.net/H75TfJyT-poVsx0fxJmSxRyOVIcoJQFErLz-qJdsv7I\\\";\\n\\n        //  Slime\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[2][1] = \\\"https://arweave.net/eGk_PrhDsErxkxjsREDInRYgPLwIGuZCeYhFnKOIKJw\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[2][2] = \\\"https://arweave.net/KJwypo7T3FX6G9xAnkV1paQJslj7g2cNcL8pwrSxHhQ\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[2][3] = \\\"https://arweave.net/vKVSHaaEWzU82fVjORTH-EOpU7szcNr5-rX0DiKKlM4\\\";\\n\\n        //  Volt\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[3][1] = \\\"https://arweave.net/16zaHmtg1-P3WVMwUbVzcrO7tKnInIXPDkFJtQPU2ik\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[3][2] = \\\"https://arweave.net/GjQgAbekiVZWPHWVfhLrI3EQxHavEhYYZiSUuVUzpGQ\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[3][3] = \\\"https://arweave.net/0Ei7Pjp-f6eeBEOaZPCNoyBgg4T89qfIX0VcseiAh_4\\\";\\n\\n        //  Soul\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[4][1] = \\\"https://arweave.net/sTcwcrlzrHBOh2QY9dHo2MNev1mEuycJeBLs-6yP-iI\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[4][2] = \\\"https://arweave.net/o-O6U7r86A0FTk1N-5E9Eb1P0ErsiH7zIe3_HrsZ-j0\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[4][3] = \\\"https://arweave.net/8k-dupLqRauWoE_Kj5NH0dsyJHN3N5mzKjESl7dql1o\\\";\\n\\n        //  Nebula\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[5][1] = \\\"https://arweave.net/FkMyMACA8qaJe8ZE7r007s14vhtoA4XD30zPtr7PDj0\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[5][2] = \\\"https://arweave.net/50OgI8izh3plQtZSfGdH4Ajg2Jra02shNdOnJ2W0oX4\\\";\\n        LibShadowcorn.shadowcornStorage().shadowcornImage[5][3] = \\\"https://arweave.net/iRbNewXcfFmDPccCJ1sqPjECNoPOAdKSieFV6phubO0\\\";\\n    }\\n\\n    function loadFirstNames() internal {\\n        LibNames.NamesStorage storage ns = LibNames.namesStorage();\\n        ns.firstNamesList[1] = \\\"Ageless\\\";\\n        ns.firstNamesList[2] = \\\"Anthracite\\\";\\n        ns.firstNamesList[3] = \\\"Asbestos\\\";\\n        ns.firstNamesList[4] = \\\"Awful\\\";\\n        ns.firstNamesList[5] = \\\"Babyface\\\";\\n        ns.firstNamesList[6] = \\\"Baleful\\\";\\n        ns.firstNamesList[7] = \\\"Barbed Foot\\\";\\n        ns.firstNamesList[8] = \\\"Battleborn\\\";\\n        ns.firstNamesList[9] = \\\"BBEG\\\";\\n        ns.firstNamesList[10] = \\\"Bear Market\\\";\\n        ns.firstNamesList[11] = \\\"Bellicose\\\";\\n        ns.firstNamesList[12] = \\\"Bizarro\\\";\\n        ns.firstNamesList[13] = \\\"Black Fire\\\";\\n        ns.firstNamesList[14] = \\\"Black Magic\\\";\\n        ns.firstNamesList[15] = \\\"Black Maw\\\";\\n        ns.firstNamesList[16] = \\\"Blackhearted\\\";\\n        ns.firstNamesList[17] = \\\"Blister Eyed\\\";\\n        ns.firstNamesList[18] = \\\"Blood Moon\\\";\\n        ns.firstNamesList[19] = \\\"Bulldozer\\\";\\n        ns.firstNamesList[20] = \\\"Cassanova\\\";\\n        ns.firstNamesList[21] = \\\"Chill\\\";\\n        ns.firstNamesList[22] = \\\"Crass\\\";\\n        ns.firstNamesList[23] = \\\"Creeping\\\";\\n        ns.firstNamesList[24] = \\\"Crimson\\\";\\n        ns.firstNamesList[25] = \\\"Cruel\\\";\\n        ns.firstNamesList[26] = \\\"Cursed\\\";\\n        ns.firstNamesList[27] = \\\"Dark\\\";\\n        ns.firstNamesList[28] = \\\"Darth\\\";\\n        ns.firstNamesList[29] = \\\"Delinquent\\\";\\n        ns.firstNamesList[30] = \\\"Derelict\\\";\\n        ns.firstNamesList[31] = \\\"Dismal\\\";\\n        ns.firstNamesList[32] = \\\"Doubting\\\";\\n        ns.firstNamesList[33] = \\\"Dread\\\";\\n        ns.firstNamesList[34] = \\\"Dreadlord\\\";\\n        ns.firstNamesList[35] = \\\"Dusk\\\";\\n        ns.firstNamesList[36] = \\\"Eldritch\\\";\\n        ns.firstNamesList[37] = \\\"Eternal\\\";\\n        ns.firstNamesList[38] = \\\"Fallen\\\";\\n        ns.firstNamesList[39] = \\\"Fearful\\\";\\n        ns.firstNamesList[40] = \\\"Fetid\\\";\\n        ns.firstNamesList[41] = \\\"Fiendish\\\";\\n        ns.firstNamesList[42] = \\\"Footloose\\\";\\n        ns.firstNamesList[43] = \\\"Forgotten\\\";\\n        ns.firstNamesList[44] = \\\"Forsaken\\\";\\n        ns.firstNamesList[45] = \\\"Foul\\\";\\n        ns.firstNamesList[46] = \\\"Ghastly\\\";\\n        ns.firstNamesList[47] = \\\"Ghoulish\\\";\\n        ns.firstNamesList[48] = \\\"Gnarles\\\";\\n        ns.firstNamesList[49] = \\\"Gothic\\\";\\n        ns.firstNamesList[50] = \\\"Grape Flavored\\\";\\n        ns.firstNamesList[51] = \\\"Grim\\\";\\n        ns.firstNamesList[52] = \\\"Grizzlejaw\\\";\\n        ns.firstNamesList[53] = \\\"Grizzly\\\";\\n        ns.firstNamesList[54] = \\\"Grouchy\\\";\\n        ns.firstNamesList[55] = \\\"Gunmetal\\\";\\n        ns.firstNamesList[56] = \\\"Hidden\\\";\\n        ns.firstNamesList[57] = \\\"Hidebehind\\\";\\n        ns.firstNamesList[58] = \\\"Hipster\\\";\\n        ns.firstNamesList[59] = \\\"Impermanent\\\";\\n        ns.firstNamesList[60] = \\\"Impermanent Loss\\\";\\n        ns.firstNamesList[61] = \\\"Inky\\\";\\n        ns.firstNamesList[62] = \\\"Inside Out\\\";\\n        ns.firstNamesList[63] = \\\"Irredeemable\\\";\\n        ns.firstNamesList[64] = \\\"Lurking\\\";\\n        ns.firstNamesList[65] = \\\"Macabre\\\";\\n        ns.firstNamesList[66] = \\\"Malformed\\\";\\n        ns.firstNamesList[67] = \\\"Malicious\\\";\\n        ns.firstNamesList[68] = \\\"Malodorous\\\";\\n        ns.firstNamesList[69] = \\\"Menacing\\\";\\n        ns.firstNamesList[70] = \\\"Mournful\\\";\\n        ns.firstNamesList[71] = \\\"Nocturnal\\\";\\n        ns.firstNamesList[72] = \\\"Oil Claw\\\";\\n        ns.firstNamesList[73] = \\\"Ominous\\\";\\n        ns.firstNamesList[74] = \\\"Onyx\\\";\\n        ns.firstNamesList[75] = \\\"Paper Handed\\\";\\n        ns.firstNamesList[76] = \\\"Phantom\\\";\\n        ns.firstNamesList[77] = \\\"Proof of Evil\\\";\\n        ns.firstNamesList[78] = \\\"Protean\\\";\\n        ns.firstNamesList[79] = \\\"Razor Knees\\\";\\n        ns.firstNamesList[80] = \\\"Rotten\\\";\\n        ns.firstNamesList[81] = \\\"Rouge\\\";\\n        ns.firstNamesList[82] = \\\"Scarred\\\";\\n        ns.firstNamesList[83] = \\\"Scathing\\\";\\n        ns.firstNamesList[84] = \\\"Shrouded\\\";\\n        ns.firstNamesList[85] = \\\"Sinister\\\";\\n        ns.firstNamesList[86] = \\\"Smoke Mane\\\";\\n        ns.firstNamesList[87] = \\\"Snake Tongue\\\";\\n        ns.firstNamesList[88] = \\\"Soulless\\\";\\n        ns.firstNamesList[89] = \\\"Spider Eyes\\\";\\n        ns.firstNamesList[90] = \\\"Tentacle Prince\\\";\\n        ns.firstNamesList[91] = \\\"Twisted\\\";\\n        ns.firstNamesList[92] = \\\"Umbral\\\";\\n        ns.firstNamesList[93] = \\\"Uncertain\\\";\\n        ns.firstNamesList[94] = \\\"Uncouth\\\";\\n        ns.firstNamesList[95] = \\\"Undead\\\";\\n        ns.firstNamesList[96] = \\\"Undying\\\";\\n        ns.firstNamesList[97] = \\\"Unkempt\\\";\\n        ns.firstNamesList[98] = \\\"Unknown\\\";\\n        ns.firstNamesList[99] = \\\"Unpleasant\\\";\\n        ns.firstNamesList[100] = \\\"Unstoppable\\\";\\n        ns.firstNamesList[101] = \\\"Unwilling\\\";\\n        ns.firstNamesList[102] = \\\"Vengeful\\\";\\n        ns.firstNamesList[103] = \\\"Venomous\\\";\\n        ns.firstNamesList[104] = \\\"Viewtiful\\\";\\n        ns.firstNamesList[105] = \\\"Visceral\\\";\\n        ns.firstNamesList[106] = \\\"Viscous\\\";\\n        ns.firstNamesList[107] = \\\"Widdershins\\\";\\n        ns.firstNamesList[108] = \\\"Wild Eye\\\";\\n        ns.firstNamesList[109] = \\\"Wisp Light\\\";\\n        ns.firstNamesList[110] = \\\"Wraith Form\\\";\\n        ns.firstNamesList[111] = \\\"Wretched\\\";\\n        ns.firstNamesList[112] = \\\"Wry\\\";\\n\\n        for(uint256 i = 1; i < 112; ++i) {\\n            ns.validFirstNames.push(i);\\n        }\\n    }\\n\\n    function loadLastNames() internal {\\n        LibNames.NamesStorage storage ns = LibNames.namesStorage();\\n        ns.lastNamesList[1] = \\\"Agonizer\\\";\\n        ns.lastNamesList[2] = \\\"Ankle Licker\\\";\\n        ns.lastNamesList[3] = \\\"Arsonist\\\";\\n        ns.lastNamesList[4] = \\\"Bad-Horse\\\";\\n        ns.lastNamesList[5] = \\\"Baddie\\\";\\n        ns.lastNamesList[6] = \\\"Bandwidth Hog\\\";\\n        ns.lastNamesList[7] = \\\"Battery Licker\\\";\\n        ns.lastNamesList[8] = \\\"Betrayer\\\";\\n        ns.lastNamesList[9] = \\\"Blight Bringer\\\";\\n        ns.lastNamesList[10] = \\\"Bone Masher\\\";\\n        ns.lastNamesList[11] = \\\"Brain Freezer\\\";\\n        ns.lastNamesList[12] = \\\"Chaos Blaster\\\";\\n        ns.lastNamesList[13] = \\\"Chestburster\\\";\\n        ns.lastNamesList[14] = \\\"Cloud Thief\\\";\\n        ns.lastNamesList[15] = \\\"Con Artist\\\";\\n        ns.lastNamesList[16] = \\\"Cornivore\\\";\\n        ns.lastNamesList[17] = \\\"Crawler\\\";\\n        ns.lastNamesList[18] = \\\"Creeper\\\";\\n        ns.lastNamesList[19] = \\\"Crow\\\";\\n        ns.lastNamesList[20] = \\\"Death Shroud\\\";\\n        ns.lastNamesList[21] = \\\"DeFiler\\\";\\n        ns.lastNamesList[22] = \\\"Destructor\\\";\\n        ns.lastNamesList[23] = \\\"Doomweaver\\\";\\n        ns.lastNamesList[24] = \\\"Draco\\\";\\n        ns.lastNamesList[25] = \\\"Dream Burner\\\";\\n        ns.lastNamesList[26] = \\\"Edgar\\\";\\n        ns.lastNamesList[27] = \\\"Egg Snatcher\\\";\\n        ns.lastNamesList[28] = \\\"Fade\\\";\\n        ns.lastNamesList[29] = \\\"Fate Twister\\\";\\n        ns.lastNamesList[30] = \\\"Force Pusher\\\";\\n        ns.lastNamesList[31] = \\\"Franken\\\";\\n        ns.lastNamesList[32] = \\\"Frankenstein\\\";\\n        ns.lastNamesList[33] = \\\"Frownikins\\\";\\n        ns.lastNamesList[34] = \\\"FUD Monger\\\";\\n        ns.lastNamesList[35] = \\\"Fun Police\\\";\\n        ns.lastNamesList[36] = \\\"Genestealer\\\";\\n        ns.lastNamesList[37] = \\\"Glitterthief\\\";\\n        ns.lastNamesList[38] = \\\"Gloomspinner\\\";\\n        ns.lastNamesList[39] = \\\"Gnasher\\\";\\n        ns.lastNamesList[40] = \\\"Grave Robber\\\";\\n        ns.lastNamesList[41] = \\\"Grendal\\\";\\n        ns.lastNamesList[42] = \\\"Grief Connoisseur\\\";\\n        ns.lastNamesList[43] = \\\"Gristle Breath\\\";\\n        ns.lastNamesList[44] = \\\"Grotesk\\\";\\n        ns.lastNamesList[45] = \\\"Groucho\\\";\\n        ns.lastNamesList[46] = \\\"Henchman\\\";\\n        ns.lastNamesList[47] = \\\"Hoof Boiler\\\";\\n        ns.lastNamesList[48] = \\\"Hoof Grabber\\\";\\n        ns.lastNamesList[49] = \\\"Hooligan\\\";\\n        ns.lastNamesList[50] = \\\"Horn Collector\\\";\\n        ns.lastNamesList[51] = \\\"Influencer\\\";\\n        ns.lastNamesList[52] = \\\"Joy Melter\\\";\\n        ns.lastNamesList[53] = \\\"Joy Skinner\\\";\\n        ns.lastNamesList[54] = \\\"Kill Stealer\\\";\\n        ns.lastNamesList[55] = \\\"Knuckle Cracker\\\";\\n        ns.lastNamesList[56] = \\\"Loin Rustler\\\";\\n        ns.lastNamesList[57] = \\\"LP Drainer\\\";\\n        ns.lastNamesList[58] = \\\"Maniac\\\";\\n        ns.lastNamesList[59] = \\\"Mario\\\";\\n        ns.lastNamesList[60] = \\\"Market Breaker\\\";\\n        ns.lastNamesList[61] = \\\"Marshmallow Impaler\\\";\\n        ns.lastNamesList[62] = \\\"Masher\\\";\\n        ns.lastNamesList[63] = \\\"Meme Deleter\\\";\\n        ns.lastNamesList[64] = \\\"Milk Curdler\\\";\\n        ns.lastNamesList[65] = \\\"Mind Stinger\\\";\\n        ns.lastNamesList[66] = \\\"Mindthief\\\";\\n        ns.lastNamesList[67] = \\\"Miscreant\\\";\\n        ns.lastNamesList[68] = \\\"Muzzle Twister\\\";\\n        ns.lastNamesList[69] = \\\"Necromancer\\\";\\n        ns.lastNamesList[70] = \\\"NFT Forger\\\";\\n        ns.lastNamesList[71] = \\\"Nightmare\\\";\\n        ns.lastNamesList[72] = \\\"Nocturne\\\";\\n        ns.lastNamesList[73] = \\\"Nyx\\\";\\n        ns.lastNamesList[74] = \\\"Oberon\\\";\\n        ns.lastNamesList[75] = \\\"Osiris\\\";\\n        ns.lastNamesList[76] = \\\"Ozul\\\";\\n        ns.lastNamesList[77] = \\\"Party Crasher\\\";\\n        ns.lastNamesList[78] = \\\"Peg Horn\\\";\\n        ns.lastNamesList[79] = \\\"Pestilence\\\";\\n        ns.lastNamesList[80] = \\\"Predator\\\";\\n        ns.lastNamesList[81] = \\\"Rabobi\\\";\\n        ns.lastNamesList[82] = \\\"Rager\\\";\\n        ns.lastNamesList[83] = \\\"Ramsey\\\";\\n        ns.lastNamesList[84] = \\\"Rarity Sniper\\\";\\n        ns.lastNamesList[85] = \\\"Rascal\\\";\\n        ns.lastNamesList[86] = \\\"Ravager\\\";\\n        ns.lastNamesList[87] = \\\"Raven\\\";\\n        ns.lastNamesList[88] = \\\"Reaper\\\";\\n        ns.lastNamesList[89] = \\\"Reckoning\\\";\\n        ns.lastNamesList[90] = \\\"Rib Poker\\\";\\n        ns.lastNamesList[91] = \\\"Rift Ambusher\\\";\\n        ns.lastNamesList[92] = \\\"Rug Puller\\\";\\n        ns.lastNamesList[93] = \\\"Sand Chewer\\\";\\n        ns.lastNamesList[94] = \\\"Scallywag\\\";\\n        ns.lastNamesList[95] = \\\"Screen Toucher\\\";\\n        ns.lastNamesList[96] = \\\"Serpent\\\";\\n        ns.lastNamesList[97] = \\\"Shade Strider\\\";\\n        ns.lastNamesList[98] = \\\"Sight Blinder\\\";\\n        ns.lastNamesList[99] = \\\"Sinatra\\\";\\n        ns.lastNamesList[100] = \\\"Skelecorn\\\";\\n        ns.lastNamesList[101] = \\\"Skin Tickler\\\";\\n        ns.lastNamesList[102] = \\\"Smile Inverter\\\";\\n        ns.lastNamesList[103] = \\\"Sneakthief\\\";\\n        ns.lastNamesList[104] = \\\"Sparkle Annihilator\\\";\\n        ns.lastNamesList[105] = \\\"Spectre\\\";\\n        ns.lastNamesList[106] = \\\"Spice Miser\\\";\\n        ns.lastNamesList[107] = \\\"Spine Stealer\\\";\\n        ns.lastNamesList[108] = \\\"Steven\\\";\\n        ns.lastNamesList[109] = \\\"Sun Gobbler\\\";\\n        ns.lastNamesList[110] = \\\"Sysadmin\\\";\\n        ns.lastNamesList[111] = \\\"Tail Puller\\\";\\n        ns.lastNamesList[112] = \\\"Time Bender\\\";\\n        ns.lastNamesList[113] = \\\"Tokoloshe\\\";\\n        ns.lastNamesList[114] = \\\"Tooth Cruncher\\\";\\n        ns.lastNamesList[115] = \\\"Troll\\\";\\n        ns.lastNamesList[116] = \\\"Tyrant\\\";\\n        ns.lastNamesList[117] = \\\"Umbra\\\";\\n        ns.lastNamesList[118] = \\\"Unicorn Conqueror\\\";\\n        ns.lastNamesList[119] = \\\"Void Caster\\\";\\n        ns.lastNamesList[120] = \\\"Warlock\\\";\\n        ns.lastNamesList[121] = \\\"Watcher\\\";\\n        ns.lastNamesList[122] = \\\"World Ender\\\";\\n        ns.lastNamesList[123] = \\\"Wrathmonger\\\";\\n        ns.lastNamesList[124] = \\\"Wren\\\";\\n\\n        for(uint256 i = 1; i < 124; ++i) {\\n            ns.validLastNames.push(i);\\n        }\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"LibShadowcorn.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\n\\nlibrary LibShadowcorn {\\n    bytes32 private constant SHADOWCORN_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.ShadowCorn.storage\\\");\\n\\n    struct ShadowcornStorage {\\n        address gameBank;\\n        address UNIMAddress;\\n        address RBWAddress;\\n        // DNA version\\n        uint256 targetDNAVersion;\\n        // mapping from shadowcorn tokenId to shadowcorn DNA\\n        mapping(uint256 => uint256) shadowcornDNA;\\n        //classId => rarityId => shadowcorn image URI\\n        mapping(uint256 => mapping(uint256 => string)) shadowcornImage;\\n        mapping(uint256 => uint256) shadowcornBirthnight;\\n        // Address of the terminus contract that holds the ERC1155 Shadowcorn Egg. \\n        address terminusAddress;\\n        uint256 commonEggPoolId;\\n        uint256 rareEggPoolId;\\n        uint256 mythicEggPoolId;\\n    }\\n\\n    function shadowcornStorage() internal pure returns (ShadowcornStorage storage scs) {\\n        bytes32 position = SHADOWCORN_STORAGE_POSITION;\\n        assembly {\\n            scs.slot := position\\n        }\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        LibDiamond.enforceIsContractOwner();\\n    }\\n\\n    function setGameBank(address newGameBank) internal {\\n        // We enforce contract ownership directly here because this functionality needs to be highly\\n        // protected.\\n        enforceIsContractOwner();\\n        shadowcornStorage().gameBank = newGameBank;\\n    }\\n\\n    function gameBank() internal view returns (address) {\\n        return shadowcornStorage().gameBank;\\n    }\\n\\n    function setUNIMAddress(address newUNIMAddress) internal {\\n        // We enforce contract ownership directly here because this functionality needs to be highly\\n        // protected.\\n        enforceIsContractOwner();\\n        shadowcornStorage().UNIMAddress = newUNIMAddress;\\n    }\\n\\n    function unimAddress() internal view returns (address) {\\n        return shadowcornStorage().UNIMAddress;\\n    }\\n\\n    function setRBWAddress(address newRBWAddress) internal {\\n        // We enforce contract ownership directly here because this functionality needs to be highly\\n        // protected.\\n        enforceIsContractOwner();\\n        shadowcornStorage().RBWAddress = newRBWAddress;\\n    }\\n\\n    function rbwAddress() internal view returns (address) {\\n        return shadowcornStorage().RBWAddress;\\n    }\\n\\n    function setTargetDNAVersion(uint256 newTargetDNAVersion) internal {\\n        // We enforce contract ownership directly here because this functionality needs to be highly\\n        // protected.\\n        enforceIsContractOwner();\\n        ShadowcornStorage storage scs = shadowcornStorage();\\n        require(newTargetDNAVersion > scs.targetDNAVersion, \\\"LibShadowcorn: new version must be greater than current\\\");\\n        require(newTargetDNAVersion < 256, \\\"LibShadowcorn: version cannot be greater than 8 bits\\\");\\n        scs.targetDNAVersion = newTargetDNAVersion;\\n    }\\n\\n    function targetDNAVersion() internal view returns (uint256) {\\n        return shadowcornStorage().targetDNAVersion;\\n    }\\n\\n    function setShadowcornDNA(uint256 tokenId, uint256 newDNA) internal {\\n        ShadowcornStorage storage scs = shadowcornStorage();\\n        scs.shadowcornDNA[tokenId] = newDNA;\\n    }\\n\\n    function shadowcornDNA(uint256 tokenId) internal view returns (uint256) {\\n        return shadowcornStorage().shadowcornDNA[tokenId];\\n    }\\n\\n    function setShadowcornImage(string[15] memory newShadowcornImage) internal {\\n        ShadowcornStorage storage scs = shadowcornStorage();\\n\\n        scs.shadowcornImage[1][1] = newShadowcornImage[0];\\n        scs.shadowcornImage[2][1] = newShadowcornImage[1];\\n        scs.shadowcornImage[3][1] = newShadowcornImage[2];\\n        scs.shadowcornImage[4][1] = newShadowcornImage[3];\\n        scs.shadowcornImage[5][1] = newShadowcornImage[4];\\n        \\n        scs.shadowcornImage[1][2] = newShadowcornImage[5];\\n        scs.shadowcornImage[2][2] = newShadowcornImage[6];\\n        scs.shadowcornImage[3][2] = newShadowcornImage[7];\\n        scs.shadowcornImage[4][2] = newShadowcornImage[8];\\n        scs.shadowcornImage[5][2] = newShadowcornImage[9];\\n        \\n        scs.shadowcornImage[1][3] = newShadowcornImage[10];\\n        scs.shadowcornImage[2][3] = newShadowcornImage[11];\\n        scs.shadowcornImage[3][3] = newShadowcornImage[12];\\n        scs.shadowcornImage[4][3] = newShadowcornImage[13];\\n        scs.shadowcornImage[5][3] = newShadowcornImage[14];\\n    }\\n\\n    function shadowcornImage(uint256 classId, uint256 rarityId) internal view returns(string memory) {\\n        return shadowcornStorage().shadowcornImage[classId][rarityId];\\n    }\\n\\n    function setTerminusAddress(address newTerminusAddress) internal {\\n        enforceIsContractOwner();\\n        shadowcornStorage().terminusAddress = newTerminusAddress;\\n    }\\n\\n    function terminusAddress() internal view returns(address){\\n        return shadowcornStorage().terminusAddress;\\n    }\\n\\n    function setCommonEggPoolId(uint256 newCommonEggPoolId) internal {\\n        enforceIsContractOwner();\\n        shadowcornStorage().commonEggPoolId = newCommonEggPoolId;\\n    }\\n\\n    function commonEggPoolId() internal view returns(uint256){\\n        return shadowcornStorage().commonEggPoolId;\\n    }\\n\\n    function setRareEggPoolId(uint256 newRareEggPoolId) internal {\\n        enforceIsContractOwner();\\n        shadowcornStorage().rareEggPoolId = newRareEggPoolId;\\n    }\\n\\n    function rareEggPoolId() internal view returns(uint256){\\n        return shadowcornStorage().rareEggPoolId;\\n    }\\n\\n    function setMythicEggPoolId(uint256 newMythicEggPoolId) internal {\\n        enforceIsContractOwner();\\n        shadowcornStorage().mythicEggPoolId = newMythicEggPoolId;\\n    }\\n\\n    function mythicEggPoolId() internal view returns(uint256){\\n        return shadowcornStorage().mythicEggPoolId;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibShadowcornDNA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibBin} from \\\"LibBin.sol\\\";\\nimport {LibShadowcorn} from \\\"LibShadowcorn.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\n\\nlibrary LibShadowcornDNA {\\n\\n    uint256 internal constant MAX =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    //  version is in bits 0-7 = 0b11111111\\n    uint internal constant DNA_VERSION_MASK = 0xFF;\\n    //  locked is in bit 8 = 0b100000000\\n    uint internal constant DNA_LOCKED_MASK = 0x100;\\n    //  limitedEdition is in bit 9 = 0b1000000000\\n    uint internal constant DNA_LIMITEDEDITION_MASK = 0x200;\\n    //  class is in bits 10-12 = 0b1110000000000\\n    uint internal constant DNA_CLASS_MASK = 0x1C00;\\n    //  rarity is in bits 13-14 = 0b110000000000000\\n    uint internal constant DNA_RARITY_MASK = 0x6000;\\n    //  tier is in bits 15-22 = 0b11111111000000000000000\\n    uint internal constant DNA_TIER_MASK = 0x7F8000;\\n    //  might is in bits 23-32 = 0b111111111100000000000000000000000\\n    uint internal constant DNA_MIGHT_MASK = 0x1FF800000;\\n    //  wickedness is in bits 33-42 = 0b1111111111000000000000000000000000000000000\\n    uint internal constant DNA_WICKEDNESS_MASK = 0x7FE00000000;\\n    //  tenacity is in bits 43-52 = 0b11111111110000000000000000000000000000000000000000000\\n    uint internal constant DNA_TENACITY_MASK = 0x1FF80000000000;\\n    //  cunning is in bits 53-62 = 0b111111111100000000000000000000000000000000000000000000000000000\\n    uint internal constant DNA_CUNNING_MASK = 0x7FE0000000000000;\\n    //  arcana is in bits 63-72 = 0b1111111111000000000000000000000000000000000000000000000000000000000000000\\n    uint internal constant DNA_ARCANA_MASK = 0x1FF8000000000000000;\\n    //  firstName is in bits 73-82 = 0b11111111110000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint internal constant DNA_FIRSTNAME_MASK = 0x7FE000000000000000000;\\n    //  lastName is in bits 83-92 = 0b111111111100000000000000000000000000000000000000000000000000000000000000000000000000000000000\\n    uint internal constant DNA_LASTNAME_MASK = 0x1FF800000000000000000000;\\n\\n    function getDNA(uint256 _tokenId) internal view returns (uint256) {\\n        return LibShadowcorn.shadowcornDNA(_tokenId);\\n    }\\n\\n    function setDNA(uint256 _tokenId, uint256 _dna)\\n        internal\\n        returns (uint256)\\n    {\\n        require(_dna > 0, \\\"LibShadowcornDNA: cannot set 0 DNA\\\");\\n        LibShadowcorn.setShadowcornDNA(_tokenId, _dna);\\n        emit LibEvents.DNAUpdated(_tokenId, _dna);\\n        return _dna;\\n    }\\n\\n    //  The currently supported DNA version - all DNA should be at this number,\\n    //  or lower if migrating...\\n    function targetDNAVersion() internal view returns (uint256) {\\n        return LibShadowcorn.targetDNAVersion();\\n    }\\n\\n    function enforceDNAVersionMatch(uint256 _dna) internal view {\\n        require(\\n            getVersion(_dna) == targetDNAVersion(),\\n            \\\"LibShadowcornDNA: Invalid DNA version\\\"\\n        );\\n    }\\n\\n    function setVersion(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_VERSION_MASK);\\n    }\\n\\n    function getVersion(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_VERSION_MASK);\\n    }\\n    \\n    function setLocked(uint256 _dna, bool _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_LOCKED_MASK);\\n    }\\n\\n    function getLocked(uint256 _dna) internal pure returns(bool) {\\n        return LibBin.extractBool(_dna, DNA_LOCKED_MASK);\\n    }\\n    \\n    function setLimitedEdition(uint256 _dna, bool _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_LIMITEDEDITION_MASK);\\n    }\\n\\n    function getLimitedEdition(uint256 _dna) internal pure returns(bool) {\\n        return LibBin.extractBool(_dna, DNA_LIMITEDEDITION_MASK);\\n    }\\n\\n    function setClass(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_CLASS_MASK);\\n    }\\n\\n    function getClass(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_CLASS_MASK);\\n    }\\n\\n    function setRarity(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_RARITY_MASK);\\n    }\\n\\n    function getRarity(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_RARITY_MASK);\\n    }\\n\\n    function setTier(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_TIER_MASK);\\n    }\\n\\n    function getTier(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_TIER_MASK);\\n    }\\n\\n    function setMight(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_MIGHT_MASK);\\n    }\\n\\n    function getMight(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_MIGHT_MASK);\\n    }\\n\\n    function setWickedness(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_WICKEDNESS_MASK);\\n    }\\n\\n    function getWickedness(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_WICKEDNESS_MASK);\\n    }\\n\\n    function setTenacity(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_TENACITY_MASK);\\n    }\\n\\n    function getTenacity(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_TENACITY_MASK);\\n    }\\n\\n    function setCunning(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_CUNNING_MASK);\\n    }\\n\\n    function getCunning(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_CUNNING_MASK);\\n    }\\n\\n    function setArcana(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_ARCANA_MASK);\\n    }\\n\\n    function getArcana(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_ARCANA_MASK);\\n    }\\n\\n    function setFirstName(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_FIRSTNAME_MASK);\\n    }\\n\\n    function getFirstName(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_FIRSTNAME_MASK);\\n    }\\n\\n    function setLastName(uint256 _dna, uint256 _val) internal pure returns(uint256) {\\n        return LibBin.splice(_dna, _val, DNA_LASTNAME_MASK);\\n    }\\n\\n    function getLastName(uint256 _dna) internal pure returns(uint256) {\\n        return LibBin.extract(_dna, DNA_LASTNAME_MASK);\\n    }\\n}\\n\"\r\n    },\r\n    \"LibBin.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary LibBin {\\n\\n    uint256 internal constant MAX =\\n        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n\\n    // Using the mask, determine how many bits we need to shift to extract the desired value\\n    //  @param _mask A bitstring with right-padding zeroes\\n    //  @return The number of right-padding zeroes on the _mask\\n    function getShiftAmount(uint256 _mask) internal pure returns (uint256) {\\n        uint256 count = 0;\\n        while (_mask & 0x1 == 0) {\\n            _mask >>= 1;\\n            ++count;\\n        }\\n        return count;\\n    }\\n\\n    //  Insert _insertion data into the _bitArray bitstring\\n    //  @param _bitArray The base dna to manipulate\\n    //  @param _insertion Data to insert (no right-padding zeroes)\\n    //  @param _mask The location in the _bitArray where the insertion will take place\\n    //  @return The combined _bitArray bitstring\\n    function splice(\\n        uint256 _bitArray,\\n        uint256 _insertion,\\n        uint256 _mask\\n    ) internal pure returns (uint256) {\\n        uint256 offset = getShiftAmount(_mask);\\n        uint256 passthroughMask = MAX ^ _mask;\\n        //  remove old value,  shift new value to correct spot,  mask new value\\n        return (_bitArray & passthroughMask) | ((_insertion << offset) & _mask);\\n    }\\n\\n    //  Alternate function signature for boolean insertion\\n    function splice(\\n        uint256 _bitArray,\\n        bool _insertion,\\n        uint256 _mask\\n    ) internal pure returns (uint256) {\\n        return splice(_bitArray, _insertion ? 1 : 0, _mask);\\n    }\\n\\n    //  Retrieves a segment from the _bitArray bitstring\\n    //  @param _bitArray The dna to parse\\n    //  @param _mask The location in teh _bitArray to isolate\\n    //  @return The data from _bitArray that was isolated in the _mask (no right-padding zeroes)\\n    function extract(uint256 _bitArray, uint256 _mask)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 offset = getShiftAmount(_mask);\\n        return (_bitArray & _mask) >> offset;\\n    }\\n\\n    //  Alternate function signature for boolean retrieval\\n    function extractBool(uint256 _bitArray, uint256 _mask)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return (_bitArray & _mask) != 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary LibEvents {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event DNAUpdated(uint256 tokenId, uint256 dna);\\n\\n    event HatchingShadowcornRNGRequested(uint256 indexed tokenId, address indexed playerWallet, uint256 indexed blockDeadline);\\n    event HatchingShadowcornCompleted(uint256 indexed tokenId, address indexed playerWallet);\\n}\"\r\n    },\r\n    \"LibRNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LinkTokenInterface} from \\\"LinkTokenInterface.sol\\\";\\n\\nlibrary LibRNG {\\n    bytes32 private constant RNG_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.RNG.storage\\\");\\n\\n    uint256 internal constant RNG_HATCHING = 1;\\n\\n    struct RNGStorage {\\n        // blocks we give Chainlink to respond before we fail.\\n        uint256 vrfBlocksToRespond;\\n        bytes32 chainlinkVRFKeyhash;\\n        uint256 chainlinkVRFFee;\\n        address vrfCoordinator;\\n        mapping(bytes32 => uint256) mechanicIdByVRFRequestId;\\n        // requestId => randomness provided by ChainLink\\n        mapping(bytes32 => uint256) randomness;\\n        // Nonce used to create randomness.\\n        uint256 rngNonce;\\n        // Nonces for each VRF key from which randomness has been requested.\\n        // Must stay in sync with VRFCoordinator[_keyHash][this]\\n        // keyHash => nonce\\n        mapping(bytes32 => uint256) vrfNonces;\\n\\n        address linkTokenAddress;\\n    }\\n\\n    function rngStorage() internal pure returns (RNGStorage storage rs) {\\n        bytes32 position = RNG_STORAGE_POSITION;\\n        assembly {\\n            rs.slot := position\\n        }\\n    }\\n\\n    function requestRandomnessFor(uint256 mechanicId) internal returns(bytes32) {\\n\\t\\tRNGStorage storage ds = rngStorage();\\n\\t\\tbytes32 requestId = requestRandomness(\\n\\t\\t\\tds.chainlinkVRFKeyhash,\\n\\t\\t\\tds.chainlinkVRFFee\\n\\t\\t);\\n\\t\\tds.mechanicIdByVRFRequestId[requestId] = mechanicId;\\n\\t\\treturn requestId;\\n\\t}\\n\\n\\tfunction makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n    }\\n\\tfunction makeVRFInputSeed(\\n        bytes32 _keyHash,\\n        uint256 _userSeed,\\n        address _requester,\\n        uint256 _nonce\\n    ) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n    }\\n\\n\\tfunction requestRandomness(\\n        bytes32 _keyHash,\\n        uint256 _fee\\n    ) internal returns (bytes32 requestId) {\\n        RNGStorage storage ds = rngStorage();\\n\\t\\tLinkTokenInterface(ds.linkTokenAddress).transferAndCall(ds.vrfCoordinator, _fee, abi.encode(_keyHash, 0));\\n        // This is the seed passed to VRFCoordinator. The oracle will mix this with\\n        // the hash of the block containing this request to obtain the seed/input\\n        // which is finally passed to the VRF cryptographic machinery.\\n        // So the seed doesn't actually do anything and is left over from an old API.\\n        uint256 vrfSeed = makeVRFInputSeed(_keyHash, 0, address(this), ds.vrfNonces[_keyHash]);\\n        // vrfNonces[_keyHash] must stay in sync with\\n        // VRFCoordinator.vrfNonces[_keyHash][this], which was incremented by the above\\n        // successful Link.transferAndCall (in VRFCoordinator.randomnessRequest).\\n        // This provides protection against the user repeating their input\\n        // seed, which would result in a predictable/duplicate output.\\n        ds.vrfNonces[_keyHash]++;\\n        return makeRequestId(_keyHash, vrfSeed);\\n    }\\n\\n    function expand(uint256 _modulus, uint256 _seed, uint256 _salt) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(_seed, _salt))) % _modulus;\\n    }\\n\\n    function getRuntimeRNG() internal returns (uint256) {\\n        return getRuntimeRNG(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    }\\n\\n    function getRuntimeRNG(uint _modulus) internal returns (uint256) {\\n        require(msg.sender != block.coinbase, \\\"RNG: Validators are not allowed to generate their own RNG\\\");\\n        RNGStorage storage ds = rngStorage();\\n        return uint256(keccak256(abi.encodePacked(block.coinbase, gasleft(), block.number, ++ds.rngNonce))) % _modulus;\\n    }\\n}\"\r\n    },\r\n    \"LinkTokenInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface LinkTokenInterface {\\n\\n  function allowance(\\n    address owner,\\n    address spender\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 remaining\\n    );\\n\\n  function approve(\\n    address spender,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function balanceOf(\\n    address owner\\n  )\\n    external\\n    view\\n    returns (\\n      uint256 balance\\n    );\\n\\n  function decimals()\\n    external\\n    view\\n    returns (\\n      uint8 decimalPlaces\\n    );\\n\\n  function decreaseApproval(\\n    address spender,\\n    uint256 addedValue\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function increaseApproval(\\n    address spender,\\n    uint256 subtractedValue\\n  ) external;\\n\\n  function name()\\n    external\\n    view\\n    returns (\\n      string memory tokenName\\n    );\\n\\n  function symbol()\\n    external\\n    view\\n    returns (\\n      string memory tokenSymbol\\n    );\\n\\n  function totalSupply()\\n    external\\n    view\\n    returns (\\n      uint256 totalTokensIssued\\n    );\\n\\n  function transfer(\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferAndCall(\\n    address to,\\n    uint256 value,\\n    bytes calldata data\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n  function transferFrom(\\n    address from,\\n    address to,\\n    uint256 value\\n  )\\n    external\\n    returns (\\n      bool success\\n    );\\n\\n}\\n\"\r\n    },\r\n    \"LibERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC721Receiver.sol\\\";\\nimport \\\"Address.sol\\\";\\n\\nimport {LibShadowcornDNA} from \\\"LibShadowcornDNA.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\n\\nlibrary LibERC721 {\\n    using Address for address;\\n\\n    bytes32 private constant ERC721_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.ERC721.storage\\\");\\n\\n    struct ERC721Storage {\\n        // Mapping from token ID to owner address\\n        mapping(uint256 => address) owners;\\n        // Mapping owner address to token count\\n        mapping(address => uint256) balances;\\n        // Mapping of owners to owned token IDs\\n        mapping(address => mapping(uint256 => uint256)) ownedTokens;\\n        // Mapping of tokens to their index in their owners ownedTokens array.\\n        mapping(uint256 => uint256) ownedTokensIndex;\\n        // Array with all token ids, used for enumeration\\n        uint256[] allTokens;\\n        // Mapping from token id to position in the allTokens array\\n        mapping(uint256 => uint256) allTokensIndex;\\n        // Mapping from token ID to approved address\\n        mapping(uint256 => address) tokenApprovals;\\n        // Mapping from owner to operator approvals\\n        mapping(address => mapping(address => bool)) operatorApprovals;\\n        string name;\\n        // Token symbol\\n        string symbol;\\n        // Token contractURI - permaweb location of the contract json file\\n        string contractURI;\\n        // Token licenseURI - permaweb location of the license.txt file\\n        string licenseURI;\\n        mapping(uint256 => string) tokenURIs;\\n        uint256 curentTokenId;\\n    }\\n\\n    function erc721Storage() internal pure returns (ERC721Storage storage es) {\\n        bytes32 position = ERC721_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal {\\n        transfer(from, to, tokenId);\\n        require(\\n            checkOnERC721Received(from, to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`mint`),\\n     * and stop existing when they are burned (`burn`).\\n     */\\n    function exists(uint256 tokenId) internal view returns (bool) {\\n        return erc721Storage().owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        require(\\n            exists(tokenId),\\n            \\\"ERC721: operator query for nonexistent token\\\"\\n        );\\n        address owner = ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeMint(address to, uint256 tokenId) internal {\\n        safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-safeMint-address-uint256-}[`safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal {\\n        mint(to, tokenId);\\n        require(\\n            checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        beforeTokenTransfer(address(0), to, tokenId);\\n        ERC721Storage storage ds = erc721Storage();\\n        ds.balances[to] += 1;\\n        ds.owners[tokenId] = to;\\n\\n        emit LibEvents.Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function burn(uint256 tokenId) internal {\\n        enforceUnicornIsTransferable(tokenId);\\n        address owner = ownerOf(tokenId);\\n\\n        beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        approve(address(0), tokenId);\\n        ERC721Storage storage ds = erc721Storage();\\n        ds.balances[owner] -= 1;\\n        delete ds.owners[tokenId];\\n\\n        if (bytes(ds.tokenURIs[tokenId]).length != 0) {\\n            delete ds.tokenURIs[tokenId];\\n        }\\n\\n        emit LibEvents.Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        require(\\n            ownerOf(tokenId) == from,\\n            \\\"ERC721: transfer of token that is not own\\\"\\n        );\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        enforceUnicornIsTransferable(tokenId);\\n\\n        beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        approve(address(0), tokenId);\\n        ERC721Storage storage ds = erc721Storage();\\n        ds.balances[from] -= 1;\\n        ds.balances[to] += 1;\\n        ds.owners[tokenId] = to;\\n\\n        emit LibEvents.Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) internal {\\n        ERC721Storage storage ds = erc721Storage();\\n        ds.tokenApprovals[tokenId] = to;\\n        emit LibEvents.Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal {\\n        require(owner != operator, \\\"ERC721: approve to caller\\\");\\n        ERC721Storage storage ds = erc721Storage();\\n        ds.operatorApprovals[owner][operator] = approved;\\n        emit LibEvents.ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal returns (bool) {\\n        if (to.isContract()) {\\n            try\\n                IERC721Receiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    tokenId,\\n                    _data\\n                )\\n            returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\n                        \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n                    );\\n                } else {\\n                    // solhint-disable-next-line no-inline-assembly\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal {\\n        if (from == address(0)) {\\n            addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function addTokenToOwnerEnumeration(address to, uint256 tokenId) internal {\\n        ERC721Storage storage ds = erc721Storage();\\n        uint256 length = balanceOf(to);\\n        ds.ownedTokens[to][length] = tokenId;\\n        ds.ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function removeTokenFromOwnerEnumeration(address from, uint256 tokenId)\\n        internal\\n    {\\n        ERC721Storage storage ds = erc721Storage();\\n\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n        uint256 lastTokenIndex = balanceOf(from) - 1;\\n        uint256 tokenIndex = ds.ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = ds.ownedTokens[from][lastTokenIndex];\\n\\n            ds.ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            ds.ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete ds.ownedTokensIndex[tokenId];\\n        delete ds.ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function addTokenToAllTokensEnumeration(uint256 tokenId) internal {\\n        ERC721Storage storage ds = erc721Storage();\\n\\n        ds.allTokensIndex[tokenId] = ds.allTokens.length;\\n        ds.allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function removeTokenFromAllTokensEnumeration(uint256 tokenId) internal {\\n        ERC721Storage storage ds = erc721Storage();\\n\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ds.allTokens.length - 1;\\n        uint256 tokenIndex = ds.allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = ds.allTokens[lastTokenIndex];\\n\\n        ds.allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        ds.allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete ds.allTokensIndex[tokenId];\\n        ds.allTokens.pop();\\n    }\\n\\n    function ownerOf(uint256 tokenId) internal view returns(address) {\\n        address owner = erc721Storage().owners[tokenId];\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: owner query for nonexistent token\\\"\\n        );\\n        return owner;\\n    }\\n\\n    function getApproved(uint256 tokenId) internal view returns(address) {\\n        require(\\n            exists(tokenId),\\n            \\\"ERC721: approved query for nonexistent token\\\"\\n        );\\n\\n        return erc721Storage().tokenApprovals[tokenId];\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) internal view returns(bool) {\\n        return erc721Storage().operatorApprovals[owner][operator];\\n    }\\n\\n    function balanceOf(address owner) internal view returns(uint256) {\\n        require(\\n            owner != address(0),\\n            \\\"ERC721: balance query for the zero address\\\"\\n        );\\n        return erc721Storage().balances[owner];\\n    }\\n\\n    function enforceUnicornIsTransferable(uint256 tokenId) internal view {\\n        require(!LibShadowcornDNA.getLocked(LibShadowcornDNA.getDNA(tokenId)), \\\"ERC721: Shadowcorn is locked.\\\");\\n    }\\n\\n    function enforceCallerOwnsNFT(uint256 tokenId) internal view {\\n        require(\\n            ownerOf(tokenId) == msg.sender,\\n            \\\"ERC721: Caller must own NFT\\\"\\n        );\\n    }\\n\\n    function mintNextToken(address _to)\\n        internal\\n        returns (uint256 nextTokenId)\\n    {\\n        ERC721Storage storage ds = erc721Storage();\\n        nextTokenId = ds.curentTokenId + 1;\\n        mint(_to, nextTokenId);\\n        ds.curentTokenId = nextTokenId;\\n        return nextTokenId;\\n    }\\n\\n}\"\r\n    },\r\n    \"IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"LibHatching.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibRNG} from \\\"LibRNG.sol\\\";\\nimport {LibShadowcorn} from \\\"LibShadowcorn.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\nimport {LibERC721} from \\\"LibERC721.sol\\\";\\nimport {LibShadowcornDNA} from \\\"LibShadowcornDNA.sol\\\";\\nimport {IERC20} from \\\"IERC20.sol\\\";\\nimport \\\"TerminusFacet.sol\\\";\\nimport {LibStats} from \\\"LibStats.sol\\\";\\nimport {LibNames} from \\\"LibNames.sol\\\";\\n\\nlibrary LibHatching {\\n    bytes32 private constant HATHCING_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.Hatching.storage\\\");\\n    \\n    uint256 constant MAX_COMMON_CORNS_PER_CLASS = 400;\\n    uint256 constant MAX_RARE_CORNS_PER_CLASS = 190;\\n    uint256 constant MAX_MYTHIC_CORNS_PER_CLASS = 10;\\n\\n    uint256 constant MAX_UINT = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\\n    uint256 constant SALT_1 = 1;\\n    uint256 constant SALT_2 = 2;\\n    uint256 constant SALT_3 = 3;\\n\\n    struct HatchingStorage {\\n        uint256 RBWCost;\\n        uint256 UNIMCost;\\n        // class => rarity => amount of unicorns of that class of that rarity.\\n        mapping(uint256 => mapping(uint256 => uint256)) rarityTotalsByClass;\\n        mapping(bytes32 => uint256) blockDeadlineByVRFRequestId;\\n        mapping(uint256 => bytes32) vrfRequestIdByTokenId;\\n        mapping(bytes32 => uint256) tokenIdByVRFRequestId;\\n        mapping(bytes32 => address) playerWalletByVRFRequestId;\\n        mapping(address => uint256[]) tokenIdsByOwner;\\n    }\\n\\n    function maxCornsPerClass(uint256 rarity) internal view returns(uint256) {\\n        if(rarity == 1) {\\n            return MAX_COMMON_CORNS_PER_CLASS;\\n        }\\n        if(rarity == 2) {\\n            return MAX_RARE_CORNS_PER_CLASS;\\n        }\\n        if(rarity == 3) {\\n            return MAX_MYTHIC_CORNS_PER_CLASS;\\n        }\\n    }\\n\\n    function hatchingStorage() internal pure returns (HatchingStorage storage hs) {\\n        bytes32 position = HATHCING_STORAGE_POSITION;\\n        assembly {\\n            hs.slot := position\\n        }\\n    }\\n\\n    function setHatchingCosts(uint256 rbwCost, uint256 unimCost) internal {\\n        HatchingStorage storage hs = hatchingStorage();\\n        hs.RBWCost = rbwCost;\\n        hs.UNIMCost = unimCost;\\n    }\\n\\n    function beginHatching(uint256 terminusPoolId) internal {\\n        require(terminusPoolId == LibShadowcorn.commonEggPoolId() \\n                || terminusPoolId == LibShadowcorn.rareEggPoolId() \\n                || terminusPoolId == LibShadowcorn.mythicEggPoolId(), \\n                \\\"Hatching: terminusPoolId must be a valid Terminus pool id of a Shadowcorn egg\\\");\\n        \\n        spendTokens(terminusPoolId);        \\n        uint256 tokenId = mintAndSetBasicDNAForShadowcorn(terminusPoolId);\\n        hatchingStorage().tokenIdsByOwner[msg.sender].push(tokenId);\\n        tryVRFRequest(tokenId);\\n    }\\n\\n    function spendTokens(uint256 terminusPoolId) internal {\\n        HatchingStorage storage hs = hatchingStorage();\\n        //Burn terminus token (shadowcorn egg)\\n        TerminusFacet(LibShadowcorn.terminusAddress()).burn(msg.sender, terminusPoolId, 1);\\n\\n        IERC20(LibShadowcorn.rbwAddress()).transferFrom(\\n            msg.sender,\\n            LibShadowcorn.gameBank(),\\n            hs.RBWCost\\n        );\\n\\n        IERC20(LibShadowcorn.unimAddress()).transferFrom(\\n            msg.sender,\\n            LibShadowcorn.gameBank(),\\n            hs.UNIMCost\\n        );\\n    }\\n\\n    function tryVRFRequest(uint256 tokenId) internal {\\n        bytes32 vrfRequestId = LibRNG.requestRandomnessFor(\\n            LibRNG.RNG_HATCHING\\n        );\\n        uint256 blockDeadline = block.number + LibRNG.rngStorage().vrfBlocksToRespond;\\n        \\n        saveHatchingData(vrfRequestId, tokenId, blockDeadline);\\n\\n        emit LibEvents.HatchingShadowcornRNGRequested(tokenId, msg.sender, blockDeadline);\\n    }\\n\\n    function retryHatching(uint256 tokenId) internal {\\n        HatchingStorage storage hs = hatchingStorage();\\n        require(tokenId != 0, \\\"Hatching: cannot retry a hatch for tokenId = 0\\\");        \\n        require(hatchIsInProgress(tokenId), \\\"Hatching: cannot retry a hatch that is not in progress\\\");\\n        bytes32 failedVrfRequestId = hs.vrfRequestIdByTokenId[tokenId];\\n        require(block.number > hs.blockDeadlineByVRFRequestId[failedVrfRequestId], \\\"Hatching: cannot retry a hatch with blockDeadline that is not expired\\\");\\n        require(hs.playerWalletByVRFRequestId[failedVrfRequestId] == msg.sender, \\\"Hatching: cannot retry for a hatch process that you didn't start\\\");\\n        //dna version?\\n\\n        cleanVRFData(tokenId, failedVrfRequestId);\\n        tryVRFRequest(tokenId);\\n    }\\n\\n    function saveHatchingData(bytes32 vrfRequestId, uint256 tokenId, uint256 blockDeadline) internal {\\n        HatchingStorage storage hs = hatchingStorage();\\n        hs.vrfRequestIdByTokenId[tokenId] = vrfRequestId;\\n        hs.tokenIdByVRFRequestId[vrfRequestId] = tokenId;\\n        hs.playerWalletByVRFRequestId[vrfRequestId] = msg.sender;\\n        hs.blockDeadlineByVRFRequestId[vrfRequestId] = blockDeadline;\\n    }\\n\\n    function mintAndSetBasicDNAForShadowcorn(uint256 terminusPoolId) internal returns(uint256 tokenId) {\\n        tokenId = LibERC721.mintNextToken(address(this));\\n        uint256 dna = 0;\\n        dna = LibShadowcornDNA.setVersion(dna, LibShadowcornDNA.targetDNAVersion());\\n        dna = LibShadowcornDNA.setRarity(dna, getRarityByPoolId(terminusPoolId));\\n        dna = LibShadowcornDNA.setTier(dna, 1);\\n        LibShadowcornDNA.setDNA(tokenId, dna);\\n    }\\n\\n    function getHatchesInProgress(address playerWallet) internal view returns(uint256[] memory, bool[] memory) {\\n        HatchingStorage storage hs = hatchingStorage();\\n        LibERC721.ERC721Storage storage es = LibERC721.erc721Storage();\\n        uint256 tokenBalance = hs.tokenIdsByOwner[playerWallet].length;\\n        uint256[] memory inProgress = new uint256[](tokenBalance);\\n        uint256 resultLength = 0;\\n        for(uint256 tokenIndex = 0; tokenIndex < tokenBalance; tokenIndex++) {\\n            uint256 tokenId = hs.tokenIdsByOwner[playerWallet][tokenIndex];\\n            if(hatchIsInProgress(tokenId)) {\\n                inProgress[resultLength] = tokenId;\\n                resultLength++;\\n            }\\n        }\\n\\n        uint256[] memory tokenIds = new uint256[](resultLength); \\n        bool[] memory needsRetry = new bool[](resultLength);\\n        \\n        for(uint256 inProgressIndex = 0; inProgressIndex < resultLength; inProgressIndex++) {\\n            uint256 tokenId = inProgress[inProgressIndex];\\n            bytes32 vrfRequestId = hs.vrfRequestIdByTokenId[tokenId];\\n            tokenIds[inProgressIndex] = tokenId;\\n            needsRetry[inProgressIndex] = block.number > hs.blockDeadlineByVRFRequestId[vrfRequestId];\\n        }\\n\\n        return (tokenIds, needsRetry);\\n    }\\n\\n    function getHatchesStatus(address playerWallet) internal view returns(uint256[] memory, string[] memory) {\\n        HatchingStorage storage hs = hatchingStorage();\\n        LibERC721.ERC721Storage storage es = LibERC721.erc721Storage();\\n        uint256 tokenBalance = hs.tokenIdsByOwner[playerWallet].length;\\n        uint256[] memory tokenIds = new uint256[](tokenBalance);\\n        string[] memory statuses = new string[](tokenBalance);\\n        uint256 resultLength = 0;\\n        for(uint256 tokenIndex = 0; tokenIndex < tokenBalance; tokenIndex++) {\\n            uint256 tokenId = hs.tokenIdsByOwner[playerWallet][tokenIndex];\\n            tokenIds[tokenIndex] = tokenId;\\n\\n            statuses[tokenIndex] = \\\"success\\\";\\n            if(hatchIsInProgress(tokenId)) {\\n                bytes32 vrfRequestId = hs.vrfRequestIdByTokenId[tokenId];\\n                statuses[tokenIndex] = \\\"pending\\\";\\n                if(block.number > hs.blockDeadlineByVRFRequestId[vrfRequestId]) {\\n                    statuses[tokenIndex] = \\\"needs_retry\\\";\\n                }\\n            }\\n        }\\n\\n        return (tokenIds, statuses);\\n    }\\n\\n    function hatchIsInProgress(uint256 tokenId) internal view returns(bool) {\\n        return hatchingStorage().vrfRequestIdByTokenId[tokenId] != 0;\\n    }\\n\\n    function hatchingFulfillRandomness(bytes32 vrfRequestId) internal {\\n        HatchingStorage storage hs = hatchingStorage();\\n        require(block.number <= hs.blockDeadlineByVRFRequestId[vrfRequestId], \\\"Hatching: blockDeadline has expired.\\\");\\n        uint256 tokenId = hs.tokenIdByVRFRequestId[vrfRequestId];\\n        // require(tokenId != 0, \\\"Hatching: Hatch is not in progress\\\");\\n        require(hatchIsInProgress(tokenId), \\\"Hatching: Hatch is not in progress\\\");\\n        address playerWallet = hs.playerWalletByVRFRequestId[vrfRequestId];\\n        LibERC721.safeTransfer(address(this), playerWallet, tokenId, \\\"\\\");\\n\\n        setShadowcornDNA(LibRNG.rngStorage().randomness[vrfRequestId], tokenId);\\n        LibShadowcorn.shadowcornStorage().shadowcornBirthnight[tokenId] = block.timestamp;\\n\\n        emit LibEvents.HatchingShadowcornCompleted(tokenId, playerWallet);\\n        cleanVRFData(tokenId, vrfRequestId);\\n    }\\n\\n    function cleanVRFData(uint256 tokenId, bytes32 vrfRequestId) internal {\\n        HatchingStorage storage hs = hatchingStorage();\\n        delete hs.tokenIdByVRFRequestId[vrfRequestId];\\n        delete hs.vrfRequestIdByTokenId[tokenId];\\n        delete hs.playerWalletByVRFRequestId[vrfRequestId];\\n        delete hs.blockDeadlineByVRFRequestId[vrfRequestId];\\n    }\\n\\n    function setShadowcornDNA(uint256 randomness, uint256 tokenId) internal {\\n        HatchingStorage storage hs = hatchingStorage();\\n        uint256 dna = LibShadowcornDNA.getDNA(tokenId);\\n        uint256 rarity = LibShadowcornDNA.getRarity(dna);\\n        //first 3 bits are used for class\\n        uint256 class = LibRNG.expand(5, randomness, SALT_1) + 1;\\n        while(hs.rarityTotalsByClass[class][rarity] >= maxCornsPerClass(rarity)) {\\n            //re-roll class because max corns for that class have been minted.\\n            class = (class % 5) + 1;\\n        }\\n        \\n        dna = LibShadowcornDNA.setClass(dna, class);\\n        hs.rarityTotalsByClass[class][rarity]++;\\n        \\n        //might\\n        dna = LibShadowcornDNA.setMight(dna, LibStats.rollRandomMight(class, rarity, randomness));\\n        // //wickedness \\n        dna = LibShadowcornDNA.setWickedness(dna, LibStats.rollRandomWickedness(class, rarity, randomness));\\n        // //tenacity\\n        dna = LibShadowcornDNA.setTenacity(dna, LibStats.rollRandomTenacity(class, rarity, randomness));\\n        // //cunning\\n        dna = LibShadowcornDNA.setCunning(dna, LibStats.rollRandomCunning(class, rarity, randomness));\\n        // //arcana\\n        dna = LibShadowcornDNA.setArcana(dna, LibStats.rollRandomArcana(class, rarity, randomness));\\n        \\n        //firstName\\n        dna = LibShadowcornDNA.setFirstName(dna, LibNames.getRandomFirstName(LibRNG.expand(MAX_UINT, randomness, SALT_2)));\\n        //lastName\\n        dna = LibShadowcornDNA.setLastName(dna, LibNames.getRandomLastName(LibRNG.expand(MAX_UINT, randomness, SALT_3)));\\n\\n        LibShadowcornDNA.setDNA(tokenId, dna);\\n    }\\n\\n    function getRarityByPoolId(uint256 terminusPoolId) internal view returns(uint256) {\\n        if(terminusPoolId == LibShadowcorn.commonEggPoolId()) {\\n            return 1;\\n        }\\n        if(terminusPoolId == LibShadowcorn.rareEggPoolId()) {\\n            return 2;\\n        }\\n        if(terminusPoolId == LibShadowcorn.mythicEggPoolId()) {\\n            return 3;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"TerminusFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/**\\n * Authors: Moonstream Engineering (engineering@moonstream.to)\\n * GitHub: https://github.com/bugout-dev/dao\\n *\\n * This is an implementation of the Terminus decentralized authorization contract.\\n *\\n * Terminus users can create authorization pools. Each authorization pool has the following properties:\\n * 1. Controller: The address that controls the pool. Initially set to be the address of the pool creator.\\n * 2. Pool URI: Metadata URI for the authorization pool.\\n * 3. Pool capacity: The total number of tokens that can be minted in that authorization pool.\\n * 4. Pool supply: The number of tokens that have actually been minted in that authorization pool.\\n * 5. Transferable: A boolean value which denotes whether or not tokens from that pool can be transfered\\n *    between addresses. (Note: Implemented by TerminusStorage.poolNotTransferable since we expect most\\n *    pools to be transferable. This negation is better for storage + gas since false is default value\\n *    in map to bool.)\\n * 6. Burnable: A boolean value which denotes whether or not tokens from that pool can be burned.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"ERC1155WithTerminusStorage.sol\\\";\\nimport \\\"LibTerminus.sol\\\";\\nimport \\\"LibDiamond.sol\\\";\\n\\ncontract TerminusFacet is ERC1155WithTerminusStorage {\\n    constructor() {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.controller = msg.sender;\\n    }\\n\\n    event PoolMintBatch(\\n        uint256 indexed id,\\n        address indexed operator,\\n        address from,\\n        address[] toAddresses,\\n        uint256[] amounts\\n    );\\n\\n    function poolMintBatch(\\n        uint256 id,\\n        address[] memory toAddresses,\\n        uint256[] memory amounts\\n    ) public {\\n        address operator = _msgSender();\\n        LibTerminus.enforcePoolIsController(id, operator);\\n        require(\\n            toAddresses.length == amounts.length,\\n            \\\"TerminusFacet: _poolMintBatch -- toAddresses and amounts length mismatch\\\"\\n        );\\n\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n\\n        uint256 i = 0;\\n        uint256 totalAmount = 0;\\n\\n        for (i = 0; i < toAddresses.length; i++) {\\n            address to = toAddresses[i];\\n            uint256 amount = amounts[i];\\n            require(\\n                to != address(0),\\n                \\\"TerminusFacet: _poolMintBatch -- cannot mint to zero address\\\"\\n            );\\n            totalAmount += amount;\\n            ts.poolBalances[id][to] += amount;\\n            emit TransferSingle(operator, address(0), to, id, amount);\\n        }\\n\\n        require(\\n            ts.poolSupply[id] + totalAmount <= ts.poolCapacity[id],\\n            \\\"TerminusFacet: _poolMintBatch -- Minted tokens would exceed pool capacity\\\"\\n        );\\n        ts.poolSupply[id] += totalAmount;\\n\\n        emit PoolMintBatch(id, operator, address(0), toAddresses, amounts);\\n    }\\n\\n    function terminusController() external view returns (address) {\\n        return LibTerminus.terminusStorage().controller;\\n    }\\n\\n    function paymentToken() external view returns (address) {\\n        return LibTerminus.terminusStorage().paymentToken;\\n    }\\n\\n    function setPaymentToken(address newPaymentToken) external {\\n        LibTerminus.enforceIsController();\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.paymentToken = newPaymentToken;\\n    }\\n\\n    function poolBasePrice() external view returns (uint256) {\\n        return LibTerminus.terminusStorage().poolBasePrice;\\n    }\\n\\n    function setPoolBasePrice(uint256 newBasePrice) external {\\n        LibTerminus.enforceIsController();\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.poolBasePrice = newBasePrice;\\n    }\\n\\n    function _paymentTokenContract() internal view returns (IERC20) {\\n        address paymentTokenAddress = LibTerminus\\n            .terminusStorage()\\n            .paymentToken;\\n        require(\\n            paymentTokenAddress != address(0),\\n            \\\"TerminusFacet: Payment token has not been set\\\"\\n        );\\n        return IERC20(paymentTokenAddress);\\n    }\\n\\n    function withdrawPayments(address toAddress, uint256 amount) external {\\n        LibTerminus.enforceIsController();\\n        require(\\n            _msgSender() == toAddress,\\n            \\\"TerminusFacet: withdrawPayments -- Controller can only withdraw to self\\\"\\n        );\\n        IERC20 paymentTokenContract = _paymentTokenContract();\\n        paymentTokenContract.transfer(toAddress, amount);\\n    }\\n\\n    function setURI(uint256 poolID, string memory poolURI) external {\\n        LibTerminus.enforcePoolIsController(poolID, _msgSender());\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.poolURI[poolID] = poolURI;\\n    }\\n\\n    function totalPools() external view returns (uint256) {\\n        return LibTerminus.terminusStorage().currentPoolID;\\n    }\\n\\n    function setPoolController(uint256 poolID, address newController) external {\\n        LibTerminus.enforcePoolIsController(poolID, msg.sender);\\n        LibTerminus.setPoolController(poolID, newController);\\n    }\\n\\n    function terminusPoolController(uint256 poolID)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return LibTerminus.terminusStorage().poolController[poolID];\\n    }\\n\\n    function terminusPoolCapacity(uint256 poolID)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return LibTerminus.terminusStorage().poolCapacity[poolID];\\n    }\\n\\n    function terminusPoolSupply(uint256 poolID)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return LibTerminus.terminusStorage().poolSupply[poolID];\\n    }\\n\\n    function createSimplePool(uint256 _capacity) external returns (uint256) {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        uint256 requiredPayment = ts.poolBasePrice;\\n        IERC20 paymentTokenContract = _paymentTokenContract();\\n        require(\\n            paymentTokenContract.allowance(_msgSender(), address(this)) >=\\n                requiredPayment,\\n            \\\"TerminusFacet: createSimplePool -- Insufficient allowance on payment token\\\"\\n        );\\n        paymentTokenContract.transferFrom(\\n            msg.sender,\\n            address(this),\\n            requiredPayment\\n        );\\n        return LibTerminus.createSimplePool(_capacity);\\n    }\\n\\n    function createPoolV1(\\n        uint256 _capacity,\\n        bool _transferable,\\n        bool _burnable\\n    ) external returns (uint256) {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        // TODO(zomglings): Implement requiredPayment update based on pool features.\\n        uint256 requiredPayment = ts.poolBasePrice;\\n        IERC20 paymentTokenContract = _paymentTokenContract();\\n        require(\\n            paymentTokenContract.allowance(_msgSender(), address(this)) >=\\n                requiredPayment,\\n            \\\"TerminusFacet: createPoolV1 -- Insufficient allowance on payment token\\\"\\n        );\\n        paymentTokenContract.transferFrom(\\n            msg.sender,\\n            address(this),\\n            requiredPayment\\n        );\\n        uint256 poolID = LibTerminus.createSimplePool(_capacity);\\n        if (!_transferable) {\\n            ts.poolNotTransferable[poolID] = true;\\n        }\\n        if (_burnable) {\\n            ts.poolBurnable[poolID] = true;\\n        }\\n        return poolID;\\n    }\\n\\n    function mint(\\n        address to,\\n        uint256 poolID,\\n        uint256 amount,\\n        bytes memory data\\n    ) external {\\n        LibTerminus.enforcePoolIsController(poolID, msg.sender);\\n        _mint(to, poolID, amount, data);\\n    }\\n\\n    function mintBatch(\\n        address to,\\n        uint256[] memory poolIDs,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external {\\n        for (uint256 i = 0; i < poolIDs.length; i++) {\\n            LibTerminus.enforcePoolIsController(poolIDs[i], _msgSender());\\n        }\\n        _mintBatch(to, poolIDs, amounts, data);\\n    }\\n\\n    function burn(\\n        address from,\\n        uint256 poolID,\\n        uint256 amount\\n    ) external {\\n        address operator = _msgSender();\\n        require(\\n            operator == from || isApprovedForPool(poolID, operator),\\n            \\\"TerminusFacet: burn -- caller is neither owner nor approved\\\"\\n        );\\n        _burn(from, poolID, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC1155WithTerminusStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/**\\n * Authors: Moonstream Engineering (engineering@moonstream.to)\\n * GitHub: https://github.com/bugout-dev/dao\\n *\\n * An ERC1155 implementation which uses the Moonstream DAO common storage structure for proxies.\\n * EIP1155: https://eips.ethereum.org/EIPS/eip-1155\\n *\\n * The Moonstream contract is used to delegate calls from an EIP2535 Diamond proxy.\\n *\\n * This implementation is adapted from the OpenZeppelin ERC1155 implementation:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/tree/6bd6b76d1156e20e45d1016f355d154141c7e5b9/contracts/token/ERC1155\\n */\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"IERC1155.sol\\\";\\nimport \\\"IERC1155Receiver.sol\\\";\\nimport \\\"IERC1155MetadataURI.sol\\\";\\nimport \\\"Address.sol\\\";\\nimport \\\"Context.sol\\\";\\nimport \\\"ERC165.sol\\\";\\nimport \\\"LibTerminus.sol\\\";\\n\\ncontract ERC1155WithTerminusStorage is\\n    Context,\\n    ERC165,\\n    IERC1155,\\n    IERC1155MetadataURI\\n{\\n    using Address for address;\\n\\n    constructor() {}\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC165, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function uri(uint256 poolID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        return LibTerminus.terminusStorage().poolURI[poolID];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        require(\\n            account != address(0),\\n            \\\"ERC1155WithTerminusStorage: balance query for the zero address\\\"\\n        );\\n        return LibTerminus.terminusStorage().poolBalances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(\\n            accounts.length == ids.length,\\n            \\\"ERC1155WithTerminusStorage: accounts and ids length mismatch\\\"\\n        );\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            LibTerminus.terminusStorage().globalOperatorApprovals[account][\\n                operator\\n            ];\\n    }\\n\\n    function isApprovedForPool(uint256 poolID, address operator)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return LibTerminus._isApprovedForPool(poolID, operator);\\n    }\\n\\n    function approveForPool(uint256 poolID, address operator) external {\\n        LibTerminus.enforcePoolIsController(poolID, _msgSender());\\n        LibTerminus._approveForPool(poolID, operator);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() ||\\n                isApprovedForAll(from, _msgSender()) ||\\n                isApprovedForPool(id, _msgSender()),\\n            \\\"ERC1155WithTerminusStorage: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155WithTerminusStorage: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            to != address(0),\\n            \\\"ERC1155WithTerminusStorage: transfer to the zero address\\\"\\n        );\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        require(\\n            !ts.poolNotTransferable[id],\\n            \\\"ERC1155WithTerminusStorage: _safeTransferFrom -- pool is not transferable\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            from,\\n            to,\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            data\\n        );\\n\\n        uint256 fromBalance = ts.poolBalances[id][from];\\n        require(\\n            fromBalance >= amount,\\n            \\\"ERC1155WithTerminusStorage: insufficient balance for transfer\\\"\\n        );\\n        unchecked {\\n            ts.poolBalances[id][from] = fromBalance - amount;\\n        }\\n        ts.poolBalances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155WithTerminusStorage: ids and amounts length mismatch\\\"\\n        );\\n        require(\\n            to != address(0),\\n            \\\"ERC1155WithTerminusStorage: transfer to the zero address\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = ts.poolBalances[id][from];\\n            require(\\n                fromBalance >= amount,\\n                \\\"ERC1155WithTerminusStorage: insufficient balance for transfer\\\"\\n            );\\n            unchecked {\\n                ts.poolBalances[id][from] = fromBalance - amount;\\n            }\\n            ts.poolBalances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            operator,\\n            from,\\n            to,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            to != address(0),\\n            \\\"ERC1155WithTerminusStorage: mint to the zero address\\\"\\n        );\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        require(\\n            ts.poolSupply[id] + amount <= ts.poolCapacity[id],\\n            \\\"ERC1155WithTerminusStorage: _mint -- Minted tokens would exceed pool capacity\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            address(0),\\n            to,\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            data\\n        );\\n\\n        ts.poolSupply[id] += amount;\\n        ts.poolBalances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(\\n            operator,\\n            address(0),\\n            to,\\n            id,\\n            amount,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            to != address(0),\\n            \\\"ERC1155WithTerminusStorage: mint to the zero address\\\"\\n        );\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155WithTerminusStorage: ids and amounts length mismatch\\\"\\n        );\\n\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            require(\\n                ts.poolSupply[ids[i]] + amounts[i] <= ts.poolCapacity[ids[i]],\\n                \\\"ERC1155WithTerminusStorage: _mintBatch -- Minted tokens would exceed pool capacity\\\"\\n            );\\n        }\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            ts.poolSupply[ids[i]] += amounts[i];\\n            ts.poolBalances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            operator,\\n            address(0),\\n            to,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(\\n            from != address(0),\\n            \\\"ERC1155WithTerminusStorage: burn from the zero address\\\"\\n        );\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        require(\\n            ts.poolBurnable[id],\\n            \\\"ERC1155WithTerminusStorage: _burn -- pool is not burnable\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            from,\\n            address(0),\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            \\\"\\\"\\n        );\\n\\n        uint256 fromBalance = ts.poolBalances[id][from];\\n        require(\\n            fromBalance >= amount,\\n            \\\"ERC1155WithTerminusStorage: burn amount exceeds balance\\\"\\n        );\\n        unchecked {\\n            ts.poolBalances[id][from] = fromBalance - amount;\\n            ts.poolSupply[id] -= amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(\\n            from != address(0),\\n            \\\"ERC1155WithTerminusStorage: burn from the zero address\\\"\\n        );\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155WithTerminusStorage: ids and amounts length mismatch\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            require(\\n                ts.poolBurnable[ids[i]],\\n                \\\"ERC1155WithTerminusStorage: _burnBatch -- pool is not burnable\\\"\\n            );\\n        }\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = ts.poolBalances[id][from];\\n            require(\\n                fromBalance >= amount,\\n                \\\"ERC1155WithTerminusStorage: burn amount exceeds balance\\\"\\n            );\\n            unchecked {\\n                ts.poolBalances[id][from] = fromBalance - amount;\\n                ts.poolSupply[id] -= amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(\\n            owner != operator,\\n            \\\"ERC1155WithTerminusStorage: setting approval status for self\\\"\\n        );\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.globalOperatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155Received(\\n                    operator,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\n                        \\\"ERC1155WithTerminusStorage: ERC1155Receiver rejected tokens\\\"\\n                    );\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\n                    \\\"ERC1155WithTerminusStorage: transfer to non ERC1155Receiver implementer\\\"\\n                );\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155BatchReceived(\\n                    operator,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\\n                ) {\\n                    revert(\\n                        \\\"ERC1155WithTerminusStorage: ERC1155Receiver rejected tokens\\\"\\n                    );\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\n                    \\\"ERC1155WithTerminusStorage: transfer to non ERC1155Receiver implementer\\\"\\n                );\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element)\\n        private\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibTerminus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/**\\n * Authors: Moonstream Engineering (engineering@moonstream.to)\\n * GitHub: https://github.com/bugout-dev/dao\\n *\\n * Common storage structure and internal methods for Moonstream DAO Terminus contracts.\\n * As Terminus is an extension of ERC1155, this library can also be used to implement bare ERC1155 contracts\\n * using the common storage pattern (e.g. for use in diamond proxies).\\n */\\n\\n// TODO(zomglings): Should we support EIP1761 in addition to ERC1155 or roll our own scopes and feature flags?\\n// https://eips.ethereum.org/EIPS/eip-1761\\n\\npragma solidity ^0.8.9;\\n\\nlibrary LibTerminus {\\n    bytes32 constant TERMINUS_STORAGE_POSITION =\\n        keccak256(\\\"moonstreamdao.eth.storage.terminus\\\");\\n\\n    struct TerminusStorage {\\n        // Terminus administration\\n        address controller;\\n        bool isTerminusActive;\\n        uint256 currentPoolID;\\n        address paymentToken;\\n        uint256 poolBasePrice;\\n        // Terminus pools\\n        mapping(uint256 => address) poolController;\\n        mapping(uint256 => string) poolURI;\\n        mapping(uint256 => uint256) poolCapacity;\\n        mapping(uint256 => uint256) poolSupply;\\n        mapping(uint256 => mapping(address => uint256)) poolBalances;\\n        mapping(uint256 => bool) poolNotTransferable;\\n        mapping(uint256 => bool) poolBurnable;\\n        mapping(address => mapping(address => bool)) globalOperatorApprovals;\\n        mapping(uint256 => mapping(address => bool)) globalPoolOperatorApprovals;\\n    }\\n\\n    function terminusStorage()\\n        internal\\n        pure\\n        returns (TerminusStorage storage es)\\n    {\\n        bytes32 position = TERMINUS_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n\\n    event ControlTransferred(\\n        address indexed previousController,\\n        address indexed newController\\n    );\\n\\n    event PoolControlTransferred(\\n        uint256 indexed poolID,\\n        address indexed previousController,\\n        address indexed newController\\n    );\\n\\n    function setController(address newController) internal {\\n        TerminusStorage storage ts = terminusStorage();\\n        address previousController = ts.controller;\\n        ts.controller = newController;\\n        emit ControlTransferred(previousController, newController);\\n    }\\n\\n    function enforceIsController() internal view {\\n        TerminusStorage storage ts = terminusStorage();\\n        require(msg.sender == ts.controller, \\\"LibTerminus: Must be controller\\\");\\n    }\\n\\n    function setTerminusActive(bool active) internal {\\n        TerminusStorage storage ts = terminusStorage();\\n        ts.isTerminusActive = active;\\n    }\\n\\n    function setPoolController(uint256 poolID, address newController) internal {\\n        TerminusStorage storage ts = terminusStorage();\\n        address previousController = ts.poolController[poolID];\\n        ts.poolController[poolID] = newController;\\n        emit PoolControlTransferred(poolID, previousController, newController);\\n    }\\n\\n    function createSimplePool(uint256 _capacity) internal returns (uint256) {\\n        TerminusStorage storage ts = terminusStorage();\\n        uint256 poolID = ts.currentPoolID + 1;\\n        setPoolController(poolID, msg.sender);\\n        ts.poolCapacity[poolID] = _capacity;\\n        ts.currentPoolID++;\\n        return poolID;\\n    }\\n\\n    function enforcePoolIsController(uint256 poolID, address maybeController)\\n        internal\\n        view\\n    {\\n        TerminusStorage storage ts = terminusStorage();\\n        require(\\n            ts.poolController[poolID] == maybeController,\\n            \\\"LibTerminus: Must be pool controller\\\"\\n        );\\n    }\\n\\n    function _isApprovedForPool(uint256 poolID, address operator)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        if (operator == ts.poolController[poolID]) {\\n            return true;\\n        } else if (ts.globalPoolOperatorApprovals[poolID][operator]) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _approveForPool(uint256 poolID, address operator) internal {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.globalPoolOperatorApprovals[poolID][operator] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibStats.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibRNG} from \\\"LibRNG.sol\\\";\\n\\n\\nlibrary LibStats {\\n\\n    uint256 constant MIGHT = 1;\\n    uint256 constant WICKEDNESS = 2;\\n    uint256 constant TENACITY = 3;\\n    uint256 constant CUNNING = 4;\\n    uint256 constant ARCANA = 5;\\n\\n    //  These should move somewhere better\\n    uint256 constant FIRE = 1;\\n    uint256 constant SLIME = 2;\\n    uint256 constant VOLT = 3;\\n    uint256 constant SOUL = 4;\\n    uint256 constant NEBULA = 5;\\n\\n    //  These should move somewhere better\\n    uint256 constant COMMON = 1;\\n    uint256 constant RARE = 2;\\n    uint256 constant MYTHIC = 3;\\n\\n    uint256 private constant SALT_1 = 1;\\n    uint256 private constant SALT_2 = 2;\\n    uint256 private constant SALT_3 = 3;\\n    uint256 private constant SALT_4 = 4;\\n    uint256 private constant SALT_5 = 5;\\n\\n    bytes32 private constant STATS_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.Stats.storage\\\");\\n\\n    struct StatsStorage {\\n        //  [class][stat] => floor\\n        mapping(uint256 => mapping(uint256 => uint256)) statFloorByClass;\\n\\n        //  [class][stat] => range\\n        mapping(uint256 => mapping(uint256 => uint256)) statRangeByClass;\\n\\n        //  [rarity] => scalar\\n        mapping(uint256 => uint256) rarityScalar;\\n    }\\n\\n    function statsStorage() internal pure returns (StatsStorage storage ss) {\\n        bytes32 position = STATS_STORAGE_POSITION;\\n        assembly {\\n            ss.slot := position\\n        }\\n    }\\n\\n    function rollRandomMight(uint256 class, uint256 rarity, uint256 randomness) internal returns (uint256) {\\n        StatsStorage storage ss = statsStorage();\\n        return (ss.rarityScalar[rarity] * (\\n            ss.statFloorByClass[class][MIGHT] + LibRNG.expand(ss.statRangeByClass[class][MIGHT], randomness, SALT_1)\\n        )) / 100;\\n    }\\n\\n    function rollRandomWickedness(uint256 class, uint256 rarity, uint256 randomness) internal returns (uint256) {\\n        StatsStorage storage ss = statsStorage();\\n        return (ss.rarityScalar[rarity] * (\\n            ss.statFloorByClass[class][WICKEDNESS] + LibRNG.expand(ss.statRangeByClass[class][WICKEDNESS], randomness, SALT_2)\\n        )) / 100;\\n    }\\n\\n    function rollRandomTenacity(uint256 class, uint256 rarity, uint256 randomness) internal returns (uint256) {\\n        StatsStorage storage ss = statsStorage();\\n        return (ss.rarityScalar[rarity] * (\\n            ss.statFloorByClass[class][TENACITY] + LibRNG.expand(ss.statRangeByClass[class][TENACITY], randomness, SALT_3)\\n        )) / 100;\\n    }\\n\\n    function rollRandomCunning(uint256 class, uint256 rarity, uint256 randomness) internal returns (uint256) {\\n        StatsStorage storage ss = statsStorage();\\n        return (ss.rarityScalar[rarity] * (\\n            ss.statFloorByClass[class][CUNNING] + LibRNG.expand(ss.statRangeByClass[class][CUNNING], randomness, SALT_4)\\n        )) / 100;\\n    }\\n\\n    function rollRandomArcana(uint256 class, uint256 rarity, uint256 randomness) internal returns (uint256) {\\n        StatsStorage storage ss = statsStorage();\\n        return (ss.rarityScalar[rarity] * (\\n            ss.statFloorByClass[class][ARCANA] + LibRNG.expand(ss.statRangeByClass[class][ARCANA], randomness, SALT_5)\\n        )) / 100;\\n    }\\n\\n    function initializeData() internal {\\n        StatsStorage storage ss = statsStorage();\\n\\n        ss.rarityScalar[COMMON] = 110;  //  Pre-multiplied by 100 (ie. 110% == 1.1)\\n        ss.rarityScalar[RARE] = 130;\\n        ss.rarityScalar[MYTHIC] = 160;\\n\\n        ss.statFloorByClass[FIRE][MIGHT] = 30;\\n        ss.statFloorByClass[FIRE][WICKEDNESS] = 20;\\n        ss.statFloorByClass[FIRE][TENACITY] = 10;\\n        ss.statFloorByClass[FIRE][CUNNING] = 10;\\n        ss.statFloorByClass[FIRE][ARCANA] = 20;\\n        ss.statRangeByClass[FIRE][MIGHT] = 30;\\n        ss.statRangeByClass[FIRE][WICKEDNESS] = 20;\\n        ss.statRangeByClass[FIRE][TENACITY] = 20;\\n        ss.statRangeByClass[FIRE][CUNNING] = 20;\\n        ss.statRangeByClass[FIRE][ARCANA] = 20;\\n\\n        ss.statFloorByClass[SLIME][MIGHT] = 20;\\n        ss.statFloorByClass[SLIME][WICKEDNESS] = 30;\\n        ss.statFloorByClass[SLIME][TENACITY] = 20;\\n        ss.statFloorByClass[SLIME][CUNNING] = 10;\\n        ss.statFloorByClass[SLIME][ARCANA] = 10;\\n        ss.statRangeByClass[SLIME][MIGHT] = 20;\\n        ss.statRangeByClass[SLIME][WICKEDNESS] = 30;\\n        ss.statRangeByClass[SLIME][TENACITY] = 20;\\n        ss.statRangeByClass[SLIME][CUNNING] = 20;\\n        ss.statRangeByClass[SLIME][ARCANA] = 20;\\n\\n        ss.statFloorByClass[VOLT][MIGHT] = 10;\\n        ss.statFloorByClass[VOLT][WICKEDNESS] = 20;\\n        ss.statFloorByClass[VOLT][TENACITY] = 30;\\n        ss.statFloorByClass[VOLT][CUNNING] = 20;\\n        ss.statFloorByClass[VOLT][ARCANA] = 10;\\n        ss.statRangeByClass[VOLT][MIGHT] = 20;\\n        ss.statRangeByClass[VOLT][WICKEDNESS] = 20;\\n        ss.statRangeByClass[VOLT][TENACITY] = 30;\\n        ss.statRangeByClass[VOLT][CUNNING] = 20;\\n        ss.statRangeByClass[VOLT][ARCANA] = 20;\\n\\n        ss.statFloorByClass[SOUL][MIGHT] = 10;\\n        ss.statFloorByClass[SOUL][WICKEDNESS] = 10;\\n        ss.statFloorByClass[SOUL][TENACITY] = 20;\\n        ss.statFloorByClass[SOUL][CUNNING] = 30;\\n        ss.statFloorByClass[SOUL][ARCANA] = 20;\\n        ss.statRangeByClass[SOUL][MIGHT] = 20;\\n        ss.statRangeByClass[SOUL][WICKEDNESS] = 20;\\n        ss.statRangeByClass[SOUL][TENACITY] = 20;\\n        ss.statRangeByClass[SOUL][CUNNING] = 30;\\n        ss.statRangeByClass[SOUL][ARCANA] = 20;\\n\\n        ss.statFloorByClass[NEBULA][MIGHT] = 20;\\n        ss.statFloorByClass[NEBULA][WICKEDNESS] = 10;\\n        ss.statFloorByClass[NEBULA][TENACITY] = 10;\\n        ss.statFloorByClass[NEBULA][CUNNING] = 20;\\n        ss.statFloorByClass[NEBULA][ARCANA] = 30;\\n        ss.statRangeByClass[NEBULA][MIGHT] = 20;\\n        ss.statRangeByClass[NEBULA][WICKEDNESS] = 20;\\n        ss.statRangeByClass[NEBULA][TENACITY] = 20;\\n        ss.statRangeByClass[NEBULA][CUNNING] = 20;\\n        ss.statRangeByClass[NEBULA][ARCANA] = 30;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"LibNames.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibShadowcornDNA} from \\\"LibShadowcornDNA.sol\\\";\\n\\n\\nlibrary LibNames {\\n    bytes32 private constant NAMES_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.Names.storage\\\");\\n\\n    struct NamesStorage {\\n         // nameIndex -> name string\\n        mapping(uint256 => string) firstNamesList;\\n        mapping(uint256 => string) lastNamesList;\\n\\n        // Names which can be chosen by RNG for new lands (unordered)\\n        uint256[] validFirstNames;\\n        uint256[] validLastNames;\\n    }\\n\\n    function namesStorage() internal pure returns (NamesStorage storage ns) {\\n        bytes32 position = NAMES_STORAGE_POSITION;\\n        assembly {\\n            ns.slot := position\\n        }\\n    }\\n\\n    function resetFirstNamesList() internal {\\n        NamesStorage storage ns = namesStorage();\\n        delete ns.validFirstNames;\\n        for(uint16 i = 0; i < 1024; ++i){\\n            delete ns.firstNamesList[i];\\n        }\\n    }\\n\\n    function resetLastNamesList() internal {\\n        NamesStorage storage ns = namesStorage();\\n        delete ns.validLastNames;\\n        for(uint16 i = 0; i < 1024; ++i){\\n            delete ns.lastNamesList[i];\\n        }\\n    }\\n\\n    //  New names are automatically added as valid options for the RNG\\n    function registerFirstNames(uint256[] memory _ids, string[] memory _names) internal {\\n        require(_names.length == _ids.length, \\\"NameLoader: Mismatched id and name array lengths\\\");\\n        NamesStorage storage ns = namesStorage();\\n        uint256 len = _ids.length;\\n        for(uint256 i = 0; i < len; ++i) {\\n            ns.firstNamesList[_ids[i]] = _names[i];\\n            ns.validFirstNames.push(_ids[i]);\\n        }\\n    }\\n\\n    //  New names are automatically added as valid options for the RNG\\n    function registerLastNames(uint256[] memory _ids, string[] memory _names) internal {\\n        require(_names.length == _ids.length, \\\"NameLoader: Mismatched id and name array lengths\\\");\\n        NamesStorage storage ns = namesStorage();\\n        uint256 len = _ids.length;\\n        for(uint256 i = 0; i < len; ++i) {\\n            ns.lastNamesList[_ids[i]] = _names[i];\\n            ns.validLastNames.push(_ids[i]);\\n        }\\n    }\\n\\n    //  If _delete is TRUE, the name will no longer be retrievable, and\\n    //  any legacy DNA using that name will point to (undefined -> \\\"\\\").\\n    //  If FALSE, the name will continue to work for existing DNA,\\n    //  but the RNG will not assign the name to any new tokens.\\n    function retireFirstName(uint256 _id, bool _delete) internal returns (bool) {\\n        NamesStorage storage ns = namesStorage();\\n        uint256 len = ns.validFirstNames.length;\\n        if(len == 0) return true;\\n        for(uint256 i = 0; i < len; ++i) {\\n            if(ns.validFirstNames[i] == _id) {\\n                ns.validFirstNames[i] = ns.validFirstNames[len - 1];\\n                ns.validFirstNames.pop();\\n                if(_delete) {\\n                    delete ns.firstNamesList[_id];\\n                }\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    //  If _delete is TRUE, the name will no longer be retrievable, and\\n    //  any legacy DNA using that name will point to (undefined -> \\\"\\\").\\n    //  If FALSE, the name will continue to work for existing DNA,\\n    //  but the RNG will not assign the name to any new tokens.\\n    function retireLastName(uint256 _id, bool _delete) internal returns (bool) {\\n        NamesStorage storage ns = namesStorage();\\n        uint256 len = ns.validLastNames.length;\\n        if(len == 0) return true;\\n        for(uint256 i = 0; i < len; ++i) {\\n            if(ns.validLastNames[i] == _id) {\\n                ns.validLastNames[i] = ns.validLastNames[len - 1];\\n                ns.validLastNames.pop();\\n                if(_delete) {\\n                    delete ns.lastNamesList[_id];\\n                }\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function lookupFirstName(uint256 _nameId) internal view returns (string memory) {\\n        return namesStorage().firstNamesList[_nameId];\\n    }\\n\\n    function lookupLastName(uint256 _nameId) internal view returns (string memory) {\\n        return namesStorage().lastNamesList[_nameId];\\n    }\\n\\n    function getFullName(uint256 _tokenId) internal view returns (string memory) {\\n        return getFullNameFromDNA(LibShadowcornDNA.getDNA(_tokenId));\\n    }\\n\\n    function getFullNameFromDNA(uint256 _dna) internal view returns (string memory) {\\n        LibShadowcornDNA.enforceDNAVersionMatch(_dna);\\n        NamesStorage storage ns = namesStorage();\\n        return string(\\n            abi.encodePacked(\\n                ns.firstNamesList[LibShadowcornDNA.getFirstName(_dna)], ' ',\\n                ns.lastNamesList[LibShadowcornDNA.getLastName(_dna)]\\n            )\\n        );\\n    }\\n\\n    function getRandomFirstName(uint256 randomnessFirstName) internal view returns (uint256) {\\n        NamesStorage storage ns = namesStorage();\\n        require(ns.validFirstNames.length > 0, \\\"Names: First-name list is empty\\\");\\n        return ns.validFirstNames[(randomnessFirstName % ns.validFirstNames.length)];\\n    }\\n\\n    function getRandomLastName(uint256 randomnessLastName) internal view returns (uint256) {\\n        NamesStorage storage ns = namesStorage();\\n        require(ns.validLastNames.length > 0, \\\"Names: Last-name list is empty\\\");\\n        return ns.validLastNames[(randomnessLastName % ns.validLastNames.length)];\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"Diamond.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000453d39960a9fd2c652987f64e00feba43f348393000000000000000000000000acd689ab67c34254fbfdb3bb2b0806370d327c46", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0xa26d862130599300a7086056cbce5653f01abc37", "SwarmSource": ""}