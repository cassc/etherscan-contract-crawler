{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/access/Governable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ncontract Governable {\\r\\n    address public gov;\\r\\n\\r\\n    constructor() {\\r\\n        gov = msg.sender;\\r\\n    }\\r\\n\\r\\n    modifier onlyGov() {\\r\\n        require(msg.sender == gov, \\\"Governable: forbidden\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setGov(address _gov) external onlyGov {\\r\\n        gov = _gov;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IPositionRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IPositionRouter {\\r\\n    function increasePositionRequestKeysStart() external returns (uint256);\\r\\n    function decreasePositionRequestKeysStart() external returns (uint256);\\r\\n    function executeIncreasePositions(uint256 _count, address payable _executionFeeReceiver) external;\\r\\n    function executeDecreasePositions(uint256 _count, address payable _executionFeeReceiver) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/core/interfaces/IVaultPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IVaultPriceFeed {\\r\\n    function adjustmentBasisPoints(address _token) external view returns (uint256);\\r\\n    function isAdjustmentAdditive(address _token) external view returns (bool);\\r\\n    function setAdjustment(address _token, bool _isAdditive, uint256 _adjustmentBps) external;\\r\\n    function setUseV2Pricing(bool _useV2Pricing) external;\\r\\n    function setIsAmmEnabled(bool _isEnabled) external;\\r\\n    function setIsSecondaryPriceEnabled(bool _isEnabled) external;\\r\\n    function setSpreadBasisPoints(address _token, uint256 _spreadBasisPoints) external;\\r\\n    function setSpreadThresholdBasisPoints(uint256 _spreadThresholdBasisPoints) external;\\r\\n    function setFavorPrimaryPrice(bool _favorPrimaryPrice) external;\\r\\n    function setPriceSampleSpace(uint256 _priceSampleSpace) external;\\r\\n    function setMaxStrictPriceDeviation(uint256 _maxStrictPriceDeviation) external;\\r\\n    function getPrice(address _token, bool _maximise, bool _includeAmmPrice, bool _useSwapPricing) external view returns (uint256);\\r\\n    function getAmmPrice(address _token) external view returns (uint256);\\r\\n    function getLatestPrimaryPrice(address _token) external view returns (uint256);\\r\\n    function getPrimaryPrice(address _token, bool _maximise) external view returns (uint256);\\r\\n    function setTokenConfig(\\r\\n        address _token,\\r\\n        address _priceFeed,\\r\\n        uint256 _priceDecimals,\\r\\n        bool _isStrictStable\\r\\n    ) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oracle/FastPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\r\\n\\r\\nimport \\\"./interfaces/ISecondaryPriceFeed.sol\\\";\\r\\nimport \\\"./interfaces/IFastPriceFeed.sol\\\";\\r\\nimport \\\"./interfaces/IFastPriceEvents.sol\\\";\\r\\nimport \\\"../core/interfaces/IVaultPriceFeed.sol\\\";\\r\\nimport \\\"../core/interfaces/IPositionRouter.sol\\\";\\r\\nimport \\\"../access/Governable.sol\\\";\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ncontract FastPriceFeed is ISecondaryPriceFeed, IFastPriceFeed, Governable {\\r\\n    using SafeMath for uint256;\\r\\n\\r\\n    // fit data in a uint256 slot to save gas costs\\r\\n    struct PriceDataItem {\\r\\n        uint160 refPrice; // Chainlink price\\r\\n        uint32 refTime; // last updated at time\\r\\n        uint32 cumulativeRefDelta; // cumulative Chainlink price delta\\r\\n        uint32 cumulativeFastDelta; // cumulative fast price delta\\r\\n    }\\r\\n\\r\\n    uint256 public constant PRICE_PRECISION = 10 ** 30;\\r\\n\\r\\n    uint256 public constant CUMULATIVE_DELTA_PRECISION = 10 * 1000 * 1000;\\r\\n\\r\\n    uint256 public constant MAX_REF_PRICE = type(uint160).max;\\r\\n    uint256 public constant MAX_CUMULATIVE_REF_DELTA = type(uint32).max;\\r\\n    uint256 public constant MAX_CUMULATIVE_FAST_DELTA = type(uint32).max;\\r\\n\\r\\n    // uint256(~0) is 256 bits of 1s\\r\\n    // shift the 1s by (256 - 32) to get (256 - 32) 0s followed by 32 1s\\r\\n    uint256 constant public BITMASK_32 = type(uint256).max >> (256 - 32);\\r\\n\\r\\n    uint256 public constant BASIS_POINTS_DIVISOR = 10000;\\r\\n\\r\\n    uint256 public constant MAX_PRICE_DURATION = 30 minutes;\\r\\n\\r\\n    bool public isInitialized;\\r\\n    bool public isSpreadEnabled = false;\\r\\n\\r\\n    address public vaultPriceFeed;\\r\\n    address public fastPriceEvents;\\r\\n\\r\\n    address public tokenManager;\\r\\n\\r\\n    address public positionRouter;\\r\\n\\r\\n    uint256 public override lastUpdatedAt;\\r\\n    uint256 public override lastUpdatedBlock;\\r\\n\\r\\n    uint256 public priceDuration;\\r\\n    uint256 public maxPriceUpdateDelay;\\r\\n    uint256 public spreadBasisPointsIfInactive;\\r\\n    uint256 public spreadBasisPointsIfChainError;\\r\\n    uint256 public minBlockInterval;\\r\\n    uint256 public maxTimeDeviation;\\r\\n\\r\\n    uint256 public priceDataInterval;\\r\\n\\r\\n    // allowed deviation from primary price\\r\\n    uint256 public maxDeviationBasisPoints;\\r\\n\\r\\n    uint256 public minAuthorizations;\\r\\n    uint256 public disableFastPriceVoteCount = 0;\\r\\n\\r\\n    mapping (address => bool) public isUpdater;\\r\\n\\r\\n    mapping (address => uint256) public prices;\\r\\n    mapping (address => PriceDataItem) public priceData;\\r\\n    mapping (address => uint256) public maxCumulativeDeltaDiffs;\\r\\n\\r\\n    mapping (address => bool) public isSigner;\\r\\n    mapping (address => bool) public disableFastPriceVotes;\\r\\n\\r\\n    // array of tokens used in setCompactedPrices, saves L1 calldata gas costs\\r\\n    address[] public tokens;\\r\\n    // array of tokenPrecisions used in setCompactedPrices, saves L1 calldata gas costs\\r\\n    // if the token price will be sent with 3 decimals, then tokenPrecision for that token\\r\\n    // should be 10 ** 3\\r\\n    uint256[] public tokenPrecisions;\\r\\n\\r\\n    event DisableFastPrice(address signer);\\r\\n    event EnableFastPrice(address signer);\\r\\n    event PriceData(address token, uint256 refPrice, uint256 fastPrice, uint256 cumulativeRefDelta, uint256 cumulativeFastDelta);\\r\\n    event MaxCumulativeDeltaDiffExceeded(address token, uint256 refPrice, uint256 fastPrice, uint256 cumulativeRefDelta, uint256 cumulativeFastDelta);\\r\\n\\r\\n    modifier onlySigner() {\\r\\n        require(isSigner[msg.sender], \\\"FastPriceFeed: forbidden\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyUpdater() {\\r\\n        require(isUpdater[msg.sender], \\\"FastPriceFeed: forbidden\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyTokenManager() {\\r\\n        require(msg.sender == tokenManager, \\\"FastPriceFeed: forbidden\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    struct initParams {\\r\\n        uint256 _priceDuration;\\r\\n        uint256 _maxPriceUpdateDelay;\\r\\n        uint256 _minBlockInterval;\\r\\n        uint256 _maxDeviationBasisPoints;\\r\\n        address _fastPriceEvents;\\r\\n        address _tokenManager;\\r\\n        address _positionRouter;\\r\\n    }\\r\\n\\r\\n    constructor(initParams memory params) {\\r\\n        require(params._priceDuration <= MAX_PRICE_DURATION, \\\"FastPriceFeed: invalid _priceDuration\\\");\\r\\n        priceDuration = params._priceDuration;\\r\\n        maxPriceUpdateDelay = params._maxPriceUpdateDelay;\\r\\n        minBlockInterval = params._minBlockInterval;\\r\\n        maxDeviationBasisPoints = params._maxDeviationBasisPoints;\\r\\n        fastPriceEvents = params._fastPriceEvents;\\r\\n        tokenManager = params._tokenManager;\\r\\n        positionRouter = params._positionRouter;\\r\\n    }\\r\\n\\r\\n    function initialize(uint256 _minAuthorizations, address[] memory _signers, address[] memory _updaters) public onlyGov {\\r\\n        require(!isInitialized, \\\"FastPriceFeed: already initialized\\\");\\r\\n        isInitialized = true;\\r\\n\\r\\n        minAuthorizations = _minAuthorizations;\\r\\n\\r\\n        for (uint256 i = 0; i < _signers.length; i++) {\\r\\n            address signer = _signers[i];\\r\\n            isSigner[signer] = true;\\r\\n        }\\r\\n\\r\\n        for (uint256 i = 0; i < _updaters.length; i++) {\\r\\n            address updater = _updaters[i];\\r\\n            isUpdater[updater] = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setSigner(address _account, bool _isActive) external override onlyGov {\\r\\n        isSigner[_account] = _isActive;\\r\\n    }\\r\\n\\r\\n    function setUpdater(address _account, bool _isActive) external override onlyGov {\\r\\n        isUpdater[_account] = _isActive;\\r\\n    }\\r\\n\\r\\n    function setFastPriceEvents(address _fastPriceEvents) external onlyGov {\\r\\n      fastPriceEvents = _fastPriceEvents;\\r\\n    }\\r\\n\\r\\n    function setVaultPriceFeed(address _vaultPriceFeed) external override onlyGov {\\r\\n      vaultPriceFeed = _vaultPriceFeed;\\r\\n    }\\r\\n\\r\\n    function setMaxTimeDeviation(uint256 _maxTimeDeviation) external onlyGov {\\r\\n        maxTimeDeviation = _maxTimeDeviation;\\r\\n    }\\r\\n\\r\\n    function setPriceDuration(uint256 _priceDuration) external override onlyGov {\\r\\n        require(_priceDuration <= MAX_PRICE_DURATION, \\\"FastPriceFeed: invalid _priceDuration\\\");\\r\\n        priceDuration = _priceDuration;\\r\\n    }\\r\\n\\r\\n    function setMaxPriceUpdateDelay(uint256 _maxPriceUpdateDelay) external override onlyGov {\\r\\n        maxPriceUpdateDelay = _maxPriceUpdateDelay;\\r\\n    }\\r\\n\\r\\n    function setSpreadBasisPointsIfInactive(uint256 _spreadBasisPointsIfInactive) external override onlyGov {\\r\\n        spreadBasisPointsIfInactive = _spreadBasisPointsIfInactive;\\r\\n    }\\r\\n\\r\\n    function setSpreadBasisPointsIfChainError(uint256 _spreadBasisPointsIfChainError) external override onlyGov {\\r\\n        spreadBasisPointsIfChainError = _spreadBasisPointsIfChainError;\\r\\n    }\\r\\n\\r\\n    function setMinBlockInterval(uint256 _minBlockInterval) external override onlyGov {\\r\\n        minBlockInterval = _minBlockInterval;\\r\\n    }\\r\\n\\r\\n    function setIsSpreadEnabled(bool _isSpreadEnabled) external override onlyGov {\\r\\n        isSpreadEnabled = _isSpreadEnabled;\\r\\n    }\\r\\n\\r\\n    function setLastUpdatedAt(uint256 _lastUpdatedAt) external onlyGov {\\r\\n        lastUpdatedAt = _lastUpdatedAt;\\r\\n    }\\r\\n\\r\\n    function setTokenManager(address _tokenManager) external onlyTokenManager {\\r\\n        tokenManager = _tokenManager;\\r\\n    }\\r\\n\\r\\n    function setMaxDeviationBasisPoints(uint256 _maxDeviationBasisPoints) external override onlyTokenManager {\\r\\n        maxDeviationBasisPoints = _maxDeviationBasisPoints;\\r\\n    }\\r\\n\\r\\n    function setMaxCumulativeDeltaDiffs(address[] memory _tokens,  uint256[] memory _maxCumulativeDeltaDiffs) external override onlyTokenManager {\\r\\n        for (uint256 i = 0; i < _tokens.length; i++) {\\r\\n            address token = _tokens[i];\\r\\n            maxCumulativeDeltaDiffs[token] = _maxCumulativeDeltaDiffs[i];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setPriceDataInterval(uint256 _priceDataInterval) external override onlyTokenManager {\\r\\n        priceDataInterval = _priceDataInterval;\\r\\n    }\\r\\n\\r\\n    function setMinAuthorizations(uint256 _minAuthorizations) external onlyTokenManager {\\r\\n        minAuthorizations = _minAuthorizations;\\r\\n    }\\r\\n\\r\\n    function setTokens(address[] memory _tokens, uint256[] memory _tokenPrecisions) external onlyGov {\\r\\n        require(_tokens.length == _tokenPrecisions.length, \\\"FastPriceFeed: invalid lengths\\\");\\r\\n        tokens = _tokens;\\r\\n        tokenPrecisions = _tokenPrecisions;\\r\\n    }\\r\\n\\r\\n    function setPrices(address[] memory _tokens, uint256[] memory _prices, uint256 _timestamp) external onlyUpdater {\\r\\n        bool shouldUpdate = _setLastUpdatedValues(_timestamp);\\r\\n\\r\\n        if (shouldUpdate) {\\r\\n            address _fastPriceEvents = fastPriceEvents;\\r\\n            address _vaultPriceFeed = vaultPriceFeed;\\r\\n\\r\\n            for (uint256 i = 0; i < _tokens.length; i++) {\\r\\n                address token = _tokens[i];\\r\\n                _setPrice(token, _prices[i], _vaultPriceFeed, _fastPriceEvents);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setCompactedPrices(uint256[] memory _priceBitArray, uint256 _timestamp) external onlyUpdater {\\r\\n        bool shouldUpdate = _setLastUpdatedValues(_timestamp);\\r\\n\\r\\n        if (shouldUpdate) {\\r\\n            address _fastPriceEvents = fastPriceEvents;\\r\\n            address _vaultPriceFeed = vaultPriceFeed;\\r\\n\\r\\n            for (uint256 i = 0; i < _priceBitArray.length; i++) {\\r\\n                uint256 priceBits = _priceBitArray[i];\\r\\n\\r\\n                for (uint256 j = 0; j < 8; j++) {\\r\\n                    uint256 index = i * 8 + j;\\r\\n                    if (index >= tokens.length) { return; }\\r\\n\\r\\n                    uint256 startBit = 32 * j;\\r\\n                    uint256 price = (priceBits >> startBit) & BITMASK_32;\\r\\n\\r\\n                    address token = tokens[i * 8 + j];\\r\\n                    uint256 tokenPrecision = tokenPrecisions[i * 8 + j];\\r\\n                    uint256 adjustedPrice = price.mul(PRICE_PRECISION).div(tokenPrecision);\\r\\n\\r\\n                    _setPrice(token, adjustedPrice, _vaultPriceFeed, _fastPriceEvents);\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function setPricesWithBits(uint256 _priceBits, uint256 _timestamp) external onlyUpdater {\\r\\n        _setPricesWithBits(_priceBits, _timestamp);\\r\\n    }\\r\\n\\r\\n    function setPricesWithBitsAndExecute(\\r\\n        uint256 _priceBits,\\r\\n        uint256 _timestamp,\\r\\n        uint256 _endIndexForIncreasePositions,\\r\\n        uint256 _endIndexForDecreasePositions,\\r\\n        uint256 _maxIncreasePositions,\\r\\n        uint256 _maxDecreasePositions\\r\\n    ) external onlyUpdater {\\r\\n        _setPricesWithBits(_priceBits, _timestamp);\\r\\n\\r\\n        IPositionRouter _positionRouter = IPositionRouter(positionRouter);\\r\\n        uint256 maxEndIndexForIncrease = _positionRouter.increasePositionRequestKeysStart().add(_maxIncreasePositions);\\r\\n        uint256 maxEndIndexForDecrease = _positionRouter.increasePositionRequestKeysStart().add(_maxDecreasePositions);\\r\\n\\r\\n        if (_endIndexForIncreasePositions > maxEndIndexForIncrease) {\\r\\n            _endIndexForIncreasePositions = maxEndIndexForIncrease;\\r\\n        }\\r\\n\\r\\n        if (_endIndexForDecreasePositions > maxEndIndexForDecrease) {\\r\\n            _endIndexForDecreasePositions = maxEndIndexForDecrease;\\r\\n        }\\r\\n\\r\\n        _positionRouter.executeIncreasePositions(_endIndexForIncreasePositions, payable(msg.sender));\\r\\n        _positionRouter.executeDecreasePositions(_endIndexForDecreasePositions, payable(msg.sender));\\r\\n    }\\r\\n\\r\\n    function disableFastPrice() external onlySigner {\\r\\n        require(!disableFastPriceVotes[msg.sender], \\\"FastPriceFeed: already voted\\\");\\r\\n        disableFastPriceVotes[msg.sender] = true;\\r\\n        disableFastPriceVoteCount = disableFastPriceVoteCount.add(1);\\r\\n\\r\\n        emit DisableFastPrice(msg.sender);\\r\\n    }\\r\\n\\r\\n    function enableFastPrice() external onlySigner {\\r\\n        require(disableFastPriceVotes[msg.sender], \\\"FastPriceFeed: already enabled\\\");\\r\\n        disableFastPriceVotes[msg.sender] = false;\\r\\n        disableFastPriceVoteCount = disableFastPriceVoteCount.sub(1);\\r\\n\\r\\n        emit EnableFastPrice(msg.sender);\\r\\n    }\\r\\n\\r\\n    // under regular operation, the fastPrice (prices[token]) is returned and there is no spread returned from this function,\\r\\n    // though VaultPriceFeed might apply its own spread\\r\\n    //\\r\\n    // if the fastPrice has not been updated within priceDuration then it is ignored and only _refPrice with a spread is used (spread: spreadBasisPointsIfInactive)\\r\\n    // in case the fastPrice has not been updated for maxPriceUpdateDelay then the _refPrice with a larger spread is used (spread: spreadBasisPointsIfChainError)\\r\\n    //\\r\\n    // there will be a spread from the _refPrice to the fastPrice in the following cases:\\r\\n    // - in case isSpreadEnabled is set to true\\r\\n    // - in case the maxDeviationBasisPoints between _refPrice and fastPrice is exceeded\\r\\n    // - in case watchers flag an issue\\r\\n    // - in case the cumulativeFastDelta exceeds the cumulativeRefDelta by the maxCumulativeDeltaDiff\\r\\n    function getPrice(address _token, uint256 _refPrice, bool _maximise) external override view returns (uint256) {\\r\\n        if (block.timestamp > lastUpdatedAt.add(maxPriceUpdateDelay)) {\\r\\n            if (_maximise) {\\r\\n                return _refPrice.mul(BASIS_POINTS_DIVISOR.add(spreadBasisPointsIfChainError)).div(BASIS_POINTS_DIVISOR);\\r\\n            }\\r\\n\\r\\n            return _refPrice.mul(BASIS_POINTS_DIVISOR.sub(spreadBasisPointsIfChainError)).div(BASIS_POINTS_DIVISOR);\\r\\n        }\\r\\n\\r\\n        if (block.timestamp > lastUpdatedAt.add(priceDuration)) {\\r\\n            if (_maximise) {\\r\\n                return _refPrice.mul(BASIS_POINTS_DIVISOR.add(spreadBasisPointsIfInactive)).div(BASIS_POINTS_DIVISOR);\\r\\n            }\\r\\n\\r\\n            return _refPrice.mul(BASIS_POINTS_DIVISOR.sub(spreadBasisPointsIfInactive)).div(BASIS_POINTS_DIVISOR);\\r\\n        }\\r\\n\\r\\n        uint256 fastPrice = prices[_token];\\r\\n        if (fastPrice == 0) { return _refPrice; }\\r\\n\\r\\n        uint256 diffBasisPoints = _refPrice > fastPrice ? _refPrice.sub(fastPrice) : fastPrice.sub(_refPrice);\\r\\n        diffBasisPoints = diffBasisPoints.mul(BASIS_POINTS_DIVISOR).div(_refPrice);\\r\\n\\r\\n        // create a spread between the _refPrice and the fastPrice if the maxDeviationBasisPoints is exceeded\\r\\n        // or if watchers have flagged an issue with the fast price\\r\\n        bool hasSpread = !favorFastPrice(_token) || diffBasisPoints > maxDeviationBasisPoints;\\r\\n\\r\\n        if (hasSpread) {\\r\\n            // return the higher of the two prices\\r\\n            if (_maximise) {\\r\\n                return _refPrice > fastPrice ? _refPrice : fastPrice;\\r\\n            }\\r\\n\\r\\n            // return the lower of the two prices\\r\\n            return _refPrice < fastPrice ? _refPrice : fastPrice;\\r\\n        }\\r\\n\\r\\n        return fastPrice;\\r\\n    }\\r\\n\\r\\n    function favorFastPrice(address _token) public view returns (bool) {\\r\\n        if (isSpreadEnabled) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        if (disableFastPriceVoteCount >= minAuthorizations) {\\r\\n            // force a spread if watchers have flagged an issue with the fast price\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        (/* uint256 prevRefPrice */, /* uint256 refTime */, uint256 cumulativeRefDelta, uint256 cumulativeFastDelta) = getPriceData(_token);\\r\\n        if (cumulativeFastDelta > cumulativeRefDelta && cumulativeFastDelta.sub(cumulativeRefDelta) > maxCumulativeDeltaDiffs[_token]) {\\r\\n            // force a spread if the cumulative delta for the fast price feed exceeds the cumulative delta\\r\\n            // for the Chainlink price feed by the maxCumulativeDeltaDiff allowed\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    function getPriceData(address _token) public view returns (uint256, uint256, uint256, uint256) {\\r\\n        PriceDataItem memory data = priceData[_token];\\r\\n        return (uint256(data.refPrice), uint256(data.refTime), uint256(data.cumulativeRefDelta), uint256(data.cumulativeFastDelta));\\r\\n    }\\r\\n\\r\\n    function _setPricesWithBits(uint256 _priceBits, uint256 _timestamp) private {\\r\\n        bool shouldUpdate = _setLastUpdatedValues(_timestamp);\\r\\n\\r\\n        if (shouldUpdate) {\\r\\n            address _fastPriceEvents = fastPriceEvents;\\r\\n            address _vaultPriceFeed = vaultPriceFeed;\\r\\n\\r\\n            for (uint256 j = 0; j < 8; j++) {\\r\\n                uint256 index = j;\\r\\n                if (index >= tokens.length) { return; }\\r\\n\\r\\n                uint256 startBit = 32 * j;\\r\\n                uint256 price = (_priceBits >> startBit) & BITMASK_32;\\r\\n\\r\\n                address token = tokens[j];\\r\\n                uint256 tokenPrecision = tokenPrecisions[j];\\r\\n                uint256 adjustedPrice = price.mul(PRICE_PRECISION).div(tokenPrecision);\\r\\n\\r\\n                _setPrice(token, adjustedPrice, _vaultPriceFeed, _fastPriceEvents);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setPrice(address _token, uint256 _price, address _vaultPriceFeed, address _fastPriceEvents) private {\\r\\n        if (_vaultPriceFeed != address(0)) {\\r\\n            uint256 refPrice = IVaultPriceFeed(_vaultPriceFeed).getLatestPrimaryPrice(_token);\\r\\n            uint256 fastPrice = prices[_token];\\r\\n\\r\\n            (uint256 prevRefPrice, uint256 refTime, uint256 cumulativeRefDelta, uint256 cumulativeFastDelta) = getPriceData(_token);\\r\\n\\r\\n            if (prevRefPrice > 0) {\\r\\n                uint256 refDeltaAmount = refPrice > prevRefPrice ? refPrice.sub(prevRefPrice) : prevRefPrice.sub(refPrice);\\r\\n                uint256 fastDeltaAmount = fastPrice > _price ? fastPrice.sub(_price) : _price.sub(fastPrice);\\r\\n\\r\\n                // reset cumulative delta values if it is a new time window\\r\\n                if (refTime.div(priceDataInterval) != block.timestamp.div(priceDataInterval)) {\\r\\n                    cumulativeRefDelta = 0;\\r\\n                    cumulativeFastDelta = 0;\\r\\n                }\\r\\n\\r\\n                cumulativeRefDelta = cumulativeRefDelta.add(refDeltaAmount.mul(CUMULATIVE_DELTA_PRECISION).div(prevRefPrice));\\r\\n                cumulativeFastDelta = cumulativeFastDelta.add(fastDeltaAmount.mul(CUMULATIVE_DELTA_PRECISION).div(fastPrice));\\r\\n            }\\r\\n\\r\\n            if (cumulativeFastDelta > cumulativeRefDelta && cumulativeFastDelta.sub(cumulativeRefDelta) > maxCumulativeDeltaDiffs[_token]) {\\r\\n                emit MaxCumulativeDeltaDiffExceeded(_token, refPrice, fastPrice, cumulativeRefDelta, cumulativeFastDelta);\\r\\n            }\\r\\n\\r\\n            _setPriceData(_token, refPrice, cumulativeRefDelta, cumulativeFastDelta);\\r\\n            emit PriceData(_token, refPrice, fastPrice, cumulativeRefDelta, cumulativeFastDelta);\\r\\n        }\\r\\n\\r\\n        prices[_token] = _price;\\r\\n        _emitPriceEvent(_fastPriceEvents, _token, _price);\\r\\n    }\\r\\n\\r\\n    function _setPriceData(address _token, uint256 _refPrice, uint256 _cumulativeRefDelta, uint256 _cumulativeFastDelta) private {\\r\\n        require(_refPrice < MAX_REF_PRICE, \\\"FastPriceFeed: invalid refPrice\\\");\\r\\n        // skip validation of block.timestamp, it should only be out of range after the year 2100\\r\\n        require(_cumulativeRefDelta < MAX_CUMULATIVE_REF_DELTA, \\\"FastPriceFeed: invalid cumulativeRefDelta\\\");\\r\\n        require(_cumulativeFastDelta < MAX_CUMULATIVE_FAST_DELTA, \\\"FastPriceFeed: invalid cumulativeFastDelta\\\");\\r\\n\\r\\n        priceData[_token] = PriceDataItem(\\r\\n            uint160(_refPrice),\\r\\n            uint32(block.timestamp),\\r\\n            uint32(_cumulativeRefDelta),\\r\\n            uint32(_cumulativeFastDelta)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _emitPriceEvent(address _fastPriceEvents, address _token, uint256 _price) private {\\r\\n        if (_fastPriceEvents == address(0)) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        IFastPriceEvents(_fastPriceEvents).emitPriceEvent(_token, _price);\\r\\n    }\\r\\n\\r\\n    function _setLastUpdatedValues(uint256 _timestamp) private returns (bool) {\\r\\n        if (minBlockInterval > 0) {\\r\\n            require(block.number.sub(lastUpdatedBlock) >= minBlockInterval, \\\"FastPriceFeed: minBlockInterval not yet passed\\\");\\r\\n        }\\r\\n\\r\\n        uint256 _maxTimeDeviation = maxTimeDeviation;\\r\\n        require(_timestamp > block.timestamp.sub(_maxTimeDeviation), \\\"FastPriceFeed: _timestamp below allowed range\\\");\\r\\n        require(_timestamp < block.timestamp.add(_maxTimeDeviation), \\\"FastPriceFeed: _timestamp exceeds allowed range\\\");\\r\\n\\r\\n        // do not update prices if _timestamp is before the current lastUpdatedAt value\\r\\n        if (_timestamp < lastUpdatedAt) {\\r\\n            return false;\\r\\n        }\\r\\n\\r\\n        lastUpdatedAt = _timestamp;\\r\\n        lastUpdatedBlock = block.number;\\r\\n\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/IFastPriceEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IFastPriceEvents {\\r\\n    function emitPriceEvent(address _token, uint256 _price) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/IFastPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface IFastPriceFeed {\\r\\n    function lastUpdatedAt() external view returns (uint256);\\r\\n    function lastUpdatedBlock() external view returns (uint256);\\r\\n    function setSigner(address _account, bool _isActive) external;\\r\\n    function setUpdater(address _account, bool _isActive) external;\\r\\n    function setPriceDuration(uint256 _priceDuration) external;\\r\\n    function setMaxPriceUpdateDelay(uint256 _maxPriceUpdateDelay) external;\\r\\n    function setSpreadBasisPointsIfInactive(uint256 _spreadBasisPointsIfInactive) external;\\r\\n    function setSpreadBasisPointsIfChainError(uint256 _spreadBasisPointsIfChainError) external;\\r\\n    function setMinBlockInterval(uint256 _minBlockInterval) external;\\r\\n    function setIsSpreadEnabled(bool _isSpreadEnabled) external;\\r\\n    function setMaxDeviationBasisPoints(uint256 _maxDeviationBasisPoints) external;\\r\\n    function setMaxCumulativeDeltaDiffs(address[] memory _tokens,  uint256[] memory _maxCumulativeDeltaDiffs) external;\\r\\n    function setPriceDataInterval(uint256 _priceDataInterval) external;\\r\\n    function setVaultPriceFeed(address _vaultPriceFeed) external;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/oracle/interfaces/ISecondaryPriceFeed.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ISecondaryPriceFeed {\\r\\n    function getPrice(address _token, uint256 _referencePrice, bool _maximise) external view returns (uint256);\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"_priceDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxPriceUpdateDelay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_minBlockInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDeviationBasisPoints\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_fastPriceEvents\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_positionRouter\",\"type\":\"address\"}],\"internalType\":\"struct FastPriceFeed.initParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"DisableFastPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"EnableFastPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fastPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cumulativeRefDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cumulativeFastDelta\",\"type\":\"uint256\"}],\"name\":\"MaxCumulativeDeltaDiffExceeded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"refPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fastPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cumulativeRefDelta\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cumulativeFastDelta\",\"type\":\"uint256\"}],\"name\":\"PriceData\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BASIS_POINTS_DIVISOR\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BITMASK_32\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CUMULATIVE_DELTA_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CUMULATIVE_FAST_DELTA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CUMULATIVE_REF_DELTA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_PRICE_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REF_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableFastPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disableFastPriceVoteCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"disableFastPriceVotes\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"enableFastPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fastPriceEvents\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"favorFastPrice\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_refPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_maximise\",\"type\":\"bool\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getPriceData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gov\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAuthorizations\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_updaters\",\"type\":\"address[]\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSpreadEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isUpdater\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdatedAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastUpdatedBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"maxCumulativeDeltaDiffs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxDeviationBasisPoints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPriceUpdateDelay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTimeDeviation\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minAuthorizations\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minBlockInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"positionRouter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"priceData\",\"outputs\":[{\"internalType\":\"uint160\",\"name\":\"refPrice\",\"type\":\"uint160\"},{\"internalType\":\"uint32\",\"name\":\"refTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cumulativeRefDelta\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"cumulativeFastDelta\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceDataInterval\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"priceDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"prices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_priceBitArray\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"setCompactedPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fastPriceEvents\",\"type\":\"address\"}],\"name\":\"setFastPriceEvents\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gov\",\"type\":\"address\"}],\"name\":\"setGov\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isSpreadEnabled\",\"type\":\"bool\"}],\"name\":\"setIsSpreadEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lastUpdatedAt\",\"type\":\"uint256\"}],\"name\":\"setLastUpdatedAt\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_maxCumulativeDeltaDiffs\",\"type\":\"uint256[]\"}],\"name\":\"setMaxCumulativeDeltaDiffs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxDeviationBasisPoints\",\"type\":\"uint256\"}],\"name\":\"setMaxDeviationBasisPoints\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxPriceUpdateDelay\",\"type\":\"uint256\"}],\"name\":\"setMaxPriceUpdateDelay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxTimeDeviation\",\"type\":\"uint256\"}],\"name\":\"setMaxTimeDeviation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAuthorizations\",\"type\":\"uint256\"}],\"name\":\"setMinAuthorizations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minBlockInterval\",\"type\":\"uint256\"}],\"name\":\"setMinBlockInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceDataInterval\",\"type\":\"uint256\"}],\"name\":\"setPriceDataInterval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceDuration\",\"type\":\"uint256\"}],\"name\":\"setPriceDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceBits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"setPricesWithBits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_priceBits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndexForIncreasePositions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endIndexForDecreasePositions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxIncreasePositions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxDecreasePositions\",\"type\":\"uint256\"}],\"name\":\"setPricesWithBitsAndExecute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setSigner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_spreadBasisPointsIfChainError\",\"type\":\"uint256\"}],\"name\":\"setSpreadBasisPointsIfChainError\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_spreadBasisPointsIfInactive\",\"type\":\"uint256\"}],\"name\":\"setSpreadBasisPointsIfInactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenManager\",\"type\":\"address\"}],\"name\":\"setTokenManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenPrecisions\",\"type\":\"uint256[]\"}],\"name\":\"setTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"setUpdater\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vaultPriceFeed\",\"type\":\"address\"}],\"name\":\"setVaultPriceFeed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spreadBasisPointsIfChainError\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spreadBasisPointsIfInactive\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPrecisions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vaultPriceFeed\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FastPriceFeed", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000000000000000000000000000000000000000000e10000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000fa000000000000000000000000d3d6c1bbcf60c25e75dbb4a2571d04c5b2300ec0000000000000000000000000d588327161d81013db67257d2f8a65b255f526c70000000000000000000000002be48e386b146109d974c06e5444c5b9724401c9", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}