{"SourceCode": "# @version 0.2.16\r\n\"\"\"\r\n@title Curve Sidechain/L2 Factory\r\n@license MIT\r\n@author Curve.Fi\r\n@notice Permissionless pool deployer and registry\r\n\"\"\"\r\n\r\nstruct PoolArray:\r\n    base_pool: address\r\n    implementation: address\r\n    liquidity_gauge: address\r\n    coins: address[MAX_PLAIN_COINS]\r\n    decimals: uint256[MAX_PLAIN_COINS]\r\n    n_coins: uint256\r\n    asset_type: uint256\r\n\r\nstruct BasePoolArray:\r\n    implementations: address[10]\r\n    lp_token: address\r\n    fee_receiver: address\r\n    coins: address[MAX_COINS]\r\n    decimals: uint256\r\n    n_coins: uint256\r\n    asset_type: uint256\r\n\r\n\r\ninterface AddressProvider:\r\n    def admin() -> address: view\r\n    def get_registry() -> address: view\r\n\r\ninterface Registry:\r\n    def get_lp_token(pool: address) -> address: view\r\n    def get_n_coins(pool: address) -> uint256: view\r\n    def get_coins(pool: address) -> address[MAX_COINS]: view\r\n    def get_pool_from_lp_token(lp_token: address) -> address: view\r\n\r\ninterface ERC20:\r\n    def balanceOf(_addr: address) -> uint256: view\r\n    def decimals() -> uint256: view\r\n    def totalSupply() -> uint256: view\r\n    def approve(_spender: address, _amount: uint256): nonpayable\r\n\r\ninterface CurvePlainPool:\r\n    def initialize(\r\n        _name: String[32],\r\n        _symbol: String[10],\r\n        _coins: address[4],\r\n        _rate_multipliers: uint256[4],\r\n        _A: uint256,\r\n        _fee: uint256,\r\n    ): nonpayable\r\n\r\ninterface CurvePool:\r\n    def A() -> uint256: view\r\n    def fee() -> uint256: view\r\n    def admin_fee() -> uint256: view\r\n    def balances(i: uint256) -> uint256: view\r\n    def admin_balances(i: uint256) -> uint256: view\r\n    def get_virtual_price() -> uint256: view\r\n    def initialize(\r\n        _name: String[32],\r\n        _symbol: String[10],\r\n        _coin: address,\r\n        _rate_multiplier: uint256,\r\n        _A: uint256,\r\n        _fee: uint256,\r\n    ): nonpayable\r\n    def exchange(\r\n        i: int128,\r\n        j: int128,\r\n        dx: uint256,\r\n        min_dy: uint256,\r\n        _receiver: address,\r\n    ) -> uint256: nonpayable\r\n\r\ninterface CurveFactoryMetapool:\r\n    def coins(i :uint256) -> address: view\r\n    def decimals() -> uint256: view\r\n\r\ninterface OldFactory:\r\n    def get_coins(_pool: address) -> address[2]: view\r\n\r\ninterface LiquidityGauge:\r\n    def initialize(_lp_token: address): nonpayable\r\n\r\n\r\nevent BasePoolAdded:\r\n    base_pool: address\r\n\r\nevent PlainPoolDeployed:\r\n    coins: address[MAX_PLAIN_COINS]\r\n    A: uint256\r\n    fee: uint256\r\n    deployer: address\r\n\r\nevent MetaPoolDeployed:\r\n    coin: address\r\n    base_pool: address\r\n    A: uint256\r\n    fee: uint256\r\n    deployer: address\r\n\r\nevent LiquidityGaugeDeployed:\r\n    pool: address\r\n    gauge: address\r\n\r\n\r\nMAX_COINS: constant(int128) = 8\r\nMAX_PLAIN_COINS: constant(int128) = 4  # max coins in a plain pool\r\nADDRESS_PROVIDER: constant(address) = 0x0000000022D53366457F9d5E68Ec105046FC4383\r\n\r\nadmin: public(address)\r\nfuture_admin: public(address)\r\nmanager: public(address)\r\n\r\npool_list: public(address[4294967296])   # master list of pools\r\npool_count: public(uint256)              # actual length of pool_list\r\npool_data: HashMap[address, PoolArray]\r\n\r\nbase_pool_list: public(address[4294967296])   # master list of pools\r\nbase_pool_count: public(uint256)         # actual length of pool_list\r\nbase_pool_data: HashMap[address, BasePoolArray]\r\n\r\n# number of coins -> implementation addresses\r\n# for \"plain pools\" (as opposed to metapools), implementation contracts\r\n# are organized according to the number of coins in the pool\r\nplain_implementations: public(HashMap[uint256, address[10]])\r\n\r\n# fee receiver for plain pools\r\nfee_receiver: public(address)\r\n\r\ngauge_implementation: public(address)\r\n\r\n# mapping of coins -> pools for trading\r\n# a mapping key is generated for each pair of addresses via\r\n# `bitwise_xor(convert(a, uint256), convert(b, uint256))`\r\nmarkets: HashMap[uint256, address[4294967296]]\r\nmarket_counts: HashMap[uint256, uint256]\r\n\r\n\r\n@external\r\ndef __init__(_fee_receiver: address):\r\n    self.admin = msg.sender\r\n    self.manager = msg.sender\r\n    self.fee_receiver = _fee_receiver\r\n\r\n\r\n# <--- Factory Getters --->\r\n\r\n@view\r\n@external\r\ndef metapool_implementations(_base_pool: address) -> address[10]:\r\n    \"\"\"\r\n    @notice Get a list of implementation contracts for metapools targetting the given base pool\r\n    @dev A base pool is the pool for the LP token contained within the metapool\r\n    @param _base_pool Address of the base pool\r\n    @return List of implementation contract addresses\r\n    \"\"\"\r\n    return self.base_pool_data[_base_pool].implementations\r\n\r\n\r\n@view\r\n@external\r\ndef find_pool_for_coins(_from: address, _to: address, i: uint256 = 0) -> address:\r\n    \"\"\"\r\n    @notice Find an available pool for exchanging two coins\r\n    @param _from Address of coin to be sent\r\n    @param _to Address of coin to be received\r\n    @param i Index value. When multiple pools are available\r\n            this value is used to return the n'th address.\r\n    @return Pool address\r\n    \"\"\"\r\n    key: uint256 = bitwise_xor(convert(_from, uint256), convert(_to, uint256))\r\n    return self.markets[key][i]\r\n\r\n\r\n# <--- Pool Getters --->\r\n\r\n@view\r\n@external\r\ndef get_base_pool(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Get the base pool for a given factory metapool\r\n    @param _pool Metapool address\r\n    @return Address of base pool\r\n    \"\"\"\r\n    return self.pool_data[_pool].base_pool\r\n\r\n\r\n@view\r\n@external\r\ndef get_n_coins(_pool: address) -> (uint256):\r\n    \"\"\"\r\n    @notice Get the number of coins in a pool\r\n    @param _pool Pool address\r\n    @return Number of coins\r\n    \"\"\"\r\n    return self.pool_data[_pool].n_coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_meta_n_coins(_pool: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the number of coins in a metapool\r\n    @param _pool Pool address\r\n    @return Number of wrapped coins, number of underlying coins\r\n    \"\"\"\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    return 2, self.base_pool_data[base_pool].n_coins + 1\r\n\r\n\r\n@view\r\n@external\r\ndef get_coins(_pool: address) -> address[MAX_PLAIN_COINS]:\r\n    \"\"\"\r\n    @notice Get the coins within a pool\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    return self.pool_data[_pool].coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_coins(_pool: address) -> address[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get the underlying coins within a pool\r\n    @dev Reverts if a pool does not exist or is not a metapool\r\n    @param _pool Pool address\r\n    @return List of coin addresses\r\n    \"\"\"\r\n    coins: address[MAX_COINS] = empty(address[MAX_COINS])\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    assert base_pool != ZERO_ADDRESS  # dev: pool is not metapool\r\n    coins[0] = self.pool_data[_pool].coins[0]\r\n    for i in range(1, MAX_COINS):\r\n        coins[i] = self.base_pool_data[base_pool].coins[i - 1]\r\n        if coins[i] == ZERO_ADDRESS:\r\n            break\r\n\r\n    return coins\r\n\r\n\r\n@view\r\n@external\r\ndef get_decimals(_pool: address) -> uint256[MAX_PLAIN_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each coin within a pool\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    if self.pool_data[_pool].base_pool != ZERO_ADDRESS:\r\n        decimals: uint256[MAX_PLAIN_COINS] = empty(uint256[MAX_PLAIN_COINS])\r\n        decimals = self.pool_data[_pool].decimals\r\n        decimals[1] = 18\r\n        return decimals\r\n    return self.pool_data[_pool].decimals\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_decimals(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get decimal places for each underlying coin within a pool\r\n    @param _pool Pool address\r\n    @return uint256 list of decimals\r\n    \"\"\"\r\n    # decimals are tightly packed as a series of uint8 within a little-endian bytes32\r\n    # the packed value is stored as uint256 to simplify unpacking via shift and modulo\r\n    pool_decimals: uint256[MAX_PLAIN_COINS] = empty(uint256[MAX_PLAIN_COINS])\r\n    pool_decimals = self.pool_data[_pool].decimals\r\n    decimals: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    decimals[0] = pool_decimals[0]\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    packed_decimals: uint256 = self.base_pool_data[base_pool].decimals\r\n    for i in range(MAX_COINS):\r\n        unpacked: uint256 = shift(packed_decimals, -8 * i) % 256\r\n        if unpacked == 0:\r\n            break\r\n        decimals[i+1] = unpacked\r\n\r\n    return decimals\r\n\r\n\r\n@view\r\n@external\r\ndef get_metapool_rates(_pool: address) -> uint256[2]:\r\n    \"\"\"\r\n    @notice Get rates for coins within a metapool\r\n    @param _pool Pool address\r\n    @return Rates for each coin, precision normalized to 10**18\r\n    \"\"\"\r\n    rates: uint256[2] = [10**18, 0]\r\n    rates[1] = CurvePool(self.pool_data[_pool].base_pool).get_virtual_price()\r\n    return rates\r\n\r\n\r\n@view\r\n@external\r\ndef get_balances(_pool: address) -> uint256[MAX_PLAIN_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each coin within a pool\r\n    @dev For pools using lending, these are the wrapped coin balances\r\n    @param _pool Pool address\r\n    @return uint256 list of balances\r\n    \"\"\"\r\n    if self.pool_data[_pool].base_pool != ZERO_ADDRESS:\r\n        return [CurvePool(_pool).balances(0), CurvePool(_pool).balances(1), 0, 0]\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins\r\n    balances: uint256[MAX_PLAIN_COINS] = empty(uint256[MAX_PLAIN_COINS])\r\n    for i in range(MAX_PLAIN_COINS):\r\n        if i < n_coins:\r\n            balances[i] = CurvePool(_pool).balances(i)\r\n        else:\r\n            balances[i] = 0\r\n    return balances\r\n\r\n\r\n@view\r\n@external\r\ndef get_underlying_balances(_pool: address) -> uint256[MAX_COINS]:\r\n    \"\"\"\r\n    @notice Get balances for each underlying coin within a metapool\r\n    @param _pool Metapool address\r\n    @return uint256 list of underlying balances\r\n    \"\"\"\r\n\r\n    underlying_balances: uint256[MAX_COINS] = empty(uint256[MAX_COINS])\r\n    underlying_balances[0] = CurvePool(_pool).balances(0)\r\n\r\n    base_total_supply: uint256 = ERC20(self.pool_data[_pool].coins[1]).totalSupply()\r\n    if base_total_supply > 0:\r\n        underlying_pct: uint256 = CurvePool(_pool).balances(1) * 10**36 / base_total_supply\r\n        base_pool: address = self.pool_data[_pool].base_pool\r\n        assert base_pool != ZERO_ADDRESS  # dev: pool is not a metapool\r\n        n_coins: uint256 = self.base_pool_data[base_pool].n_coins\r\n        for i in range(MAX_COINS):\r\n            if i == n_coins:\r\n                break\r\n            underlying_balances[i + 1] = CurvePool(base_pool).balances(i) * underlying_pct / 10**36\r\n\r\n    return underlying_balances\r\n\r\n\r\n@view\r\n@external\r\ndef get_A(_pool: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the amplfication co-efficient for a pool\r\n    @param _pool Pool address\r\n    @return uint256 A\r\n    \"\"\"\r\n    return CurvePool(_pool).A()\r\n\r\n\r\n@view\r\n@external\r\ndef get_fees(_pool: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Get the fees for a pool\r\n    @dev Fees are expressed as integers\r\n    @return Pool fee and admin fee as uint256 with 1e10 precision\r\n    \"\"\"\r\n    return CurvePool(_pool).fee(), CurvePool(_pool).admin_fee()\r\n\r\n\r\n@view\r\n@external\r\ndef get_admin_balances(_pool: address) -> uint256[MAX_PLAIN_COINS]:\r\n    \"\"\"\r\n    @notice Get the current admin balances (uncollected fees) for a pool\r\n    @param _pool Pool address\r\n    @return List of uint256 admin balances\r\n    \"\"\"\r\n    n_coins: uint256 = self.pool_data[_pool].n_coins\r\n    admin_balances: uint256[MAX_PLAIN_COINS] = empty(uint256[MAX_PLAIN_COINS])\r\n    for i in range(MAX_PLAIN_COINS):\r\n        if i == n_coins:\r\n            break\r\n        admin_balances[i] = CurvePool(_pool).admin_balances(i)\r\n    return admin_balances\r\n\r\n\r\n@view\r\n@external\r\ndef get_coin_indices(\r\n    _pool: address,\r\n    _from: address,\r\n    _to: address\r\n) -> (int128, int128, bool):\r\n    \"\"\"\r\n    @notice Convert coin addresses to indices for use with pool methods\r\n    @param _pool Pool address\r\n    @param _from Coin address to be used as `i` within a pool\r\n    @param _to Coin address to be used as `j` within a pool\r\n    @return int128 `i`, int128 `j`, boolean indicating if `i` and `j` are underlying coins\r\n    \"\"\"\r\n    coin: address = self.pool_data[_pool].coins[0]\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    if coin in [_from, _to] and base_pool != ZERO_ADDRESS:\r\n        base_lp_token: address = self.pool_data[_pool].coins[1]\r\n        if base_lp_token in [_from, _to]:\r\n            # True and False convert to 1 and 0 - a bit of voodoo that\r\n            # works because we only ever have 2 non-underlying coins if base pool is ZERO_ADDRESS\r\n            return convert(_to == coin, int128), convert(_from == coin, int128), False\r\n\r\n    found_market: bool = False\r\n    i: int128 = 0\r\n    j: int128 = 0\r\n    for x in range(MAX_COINS):\r\n        if base_pool == ZERO_ADDRESS:\r\n            if x >= MAX_PLAIN_COINS:\r\n                raise \"No available market\"\r\n            if x != 0:\r\n                coin = self.pool_data[_pool].coins[x]\r\n        else:\r\n            if x != 0:\r\n                coin = self.base_pool_data[base_pool].coins[x-1]\r\n        if coin == ZERO_ADDRESS:\r\n            raise \"No available market\"\r\n        if coin == _from:\r\n            i = x\r\n        elif coin == _to:\r\n            j = x\r\n        else:\r\n            continue\r\n        if found_market:\r\n            # the second time we find a match, break out of the loop\r\n            break\r\n        # the first time we find a match, set `found_market` to True\r\n        found_market = True\r\n\r\n    return i, j, base_pool != ZERO_ADDRESS\r\n\r\n\r\n@view\r\n@external\r\ndef get_gauge(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Get the address of the liquidity gauge contract for a factory pool\r\n    @dev Returns `ZERO_ADDRESS` if a gauge has not been deployed\r\n    @param _pool Pool address\r\n    @return Implementation contract address\r\n    \"\"\"\r\n    return self.pool_data[_pool].liquidity_gauge\r\n\r\n\r\n@view\r\n@external\r\ndef get_implementation_address(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Get the address of the implementation contract used for a factory pool\r\n    @param _pool Pool address\r\n    @return Implementation contract address\r\n    \"\"\"\r\n    return self.pool_data[_pool].implementation\r\n\r\n\r\n@view\r\n@external\r\ndef is_meta(_pool: address) -> bool:\r\n    \"\"\"\r\n    @notice Verify `_pool` is a metapool\r\n    @param _pool Pool address\r\n    @return True if `_pool` is a metapool\r\n    \"\"\"\r\n    return self.pool_data[_pool].base_pool != ZERO_ADDRESS\r\n\r\n\r\n@view\r\n@external\r\ndef get_pool_asset_type(_pool: address) -> uint256:\r\n    \"\"\"\r\n    @notice Query the asset type of `_pool`\r\n    @dev 0 = USD, 1 = ETH, 2 = BTC, 3 = Other\r\n    @param _pool Pool Address\r\n    @return Integer indicating the pool asset type\r\n    \"\"\"\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    if base_pool == ZERO_ADDRESS:\r\n        return self.pool_data[_pool].asset_type\r\n    else:\r\n        return self.base_pool_data[base_pool].asset_type\r\n\r\n\r\n@view\r\n@external\r\ndef get_fee_receiver(_pool: address) -> address:\r\n    base_pool: address = self.pool_data[_pool].base_pool\r\n    if base_pool == ZERO_ADDRESS:\r\n        return self.fee_receiver\r\n    else:\r\n        return self.base_pool_data[base_pool].fee_receiver\r\n\r\n\r\n# <--- Pool Deployers --->\r\n\r\n@external\r\ndef deploy_plain_pool(\r\n    _name: String[32],\r\n    _symbol: String[10],\r\n    _coins: address[MAX_PLAIN_COINS],\r\n    _A: uint256,\r\n    _fee: uint256,\r\n    _asset_type: uint256 = 0,\r\n    _implementation_idx: uint256 = 0,\r\n) -> address:\r\n    \"\"\"\r\n    @notice Deploy a new plain pool\r\n    @param _name Name of the new plain pool\r\n    @param _symbol Symbol for the new plain pool - will be\r\n                   concatenated with factory symbol\r\n    @param _coins List of addresses of the coins being used in the pool.\r\n    @param _A Amplification co-efficient - a lower value here means\r\n              less tolerance for imbalance within the pool's assets.\r\n              Suggested values include:\r\n               * Uncollateralized algorithmic stablecoins: 5-10\r\n               * Non-redeemable, collateralized assets: 100\r\n               * Redeemable assets: 200-400\r\n    @param _fee Trade fee, given as an integer with 1e10 precision. The\r\n                minimum fee is 0.04% (4000000), the maximum is 1% (100000000).\r\n                50% of the fee is distributed to veCRV holders.\r\n    @param _asset_type Asset type for pool, as an integer\r\n                       0 = USD, 1 = ETH, 2 = BTC, 3 = Other\r\n    @param _implementation_idx Index of the implementation to use. All possible\r\n                implementations for a pool of N_COINS can be publicly accessed\r\n                via `plain_implementations(N_COINS)`\r\n    @return Address of the deployed pool\r\n    \"\"\"\r\n    # fee must be between 0.04% and 1%\r\n    assert _fee >= 4000000 and _fee <= 100000000, \"Invalid fee\"\r\n\r\n    n_coins: uint256 = MAX_PLAIN_COINS\r\n    rate_multipliers: uint256[MAX_PLAIN_COINS] = empty(uint256[MAX_PLAIN_COINS])\r\n    decimals: uint256[MAX_PLAIN_COINS] = empty(uint256[MAX_PLAIN_COINS])\r\n\r\n    for i in range(MAX_PLAIN_COINS):\r\n        coin: address = _coins[i]\r\n        if coin == ZERO_ADDRESS:\r\n            assert i > 1, \"Insufficient coins\"\r\n            n_coins = i\r\n            break\r\n\r\n        if _coins[i] == 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE:\r\n            assert i == 0, \"ETH must be first coin\"\r\n            decimals[0] = 18\r\n        else:\r\n            decimals[i] = ERC20(coin).decimals()\r\n            assert decimals[i] < 19, \"Max 18 decimals for coins\"\r\n\r\n        rate_multipliers[i] = 10 ** (36 - decimals[i])\r\n\r\n        for x in range(i, i+MAX_PLAIN_COINS):\r\n            if x+1 == MAX_PLAIN_COINS:\r\n                break\r\n            if _coins[x+1] == ZERO_ADDRESS:\r\n                break\r\n            assert coin != _coins[x+1], \"Duplicate coins\"\r\n\r\n    implementation: address = self.plain_implementations[n_coins][_implementation_idx]\r\n    assert implementation != ZERO_ADDRESS, \"Invalid implementation index\"\r\n    pool: address = create_forwarder_to(implementation)\r\n    CurvePlainPool(pool).initialize(_name, _symbol, _coins, rate_multipliers, _A, _fee)\r\n\r\n    length: uint256 = self.pool_count\r\n    self.pool_list[length] = pool\r\n    self.pool_count = length + 1\r\n    self.pool_data[pool].decimals = decimals\r\n    self.pool_data[pool].n_coins = n_coins\r\n    self.pool_data[pool].base_pool = ZERO_ADDRESS\r\n    self.pool_data[pool].implementation = implementation\r\n    if _asset_type != 0:\r\n        self.pool_data[pool].asset_type = _asset_type\r\n\r\n    for i in range(MAX_PLAIN_COINS):\r\n        coin: address = _coins[i]\r\n        if coin == ZERO_ADDRESS:\r\n            break\r\n        self.pool_data[pool].coins[i] = coin\r\n        raw_call(\r\n            coin,\r\n            concat(\r\n                method_id(\"approve(address,uint256)\"),\r\n                convert(pool, bytes32),\r\n                convert(MAX_UINT256, bytes32)\r\n            )\r\n        )\r\n        for j in range(MAX_PLAIN_COINS):\r\n            if i < j:\r\n                swappable_coin: address = _coins[j]\r\n                key: uint256 = bitwise_xor(convert(coin, uint256), convert(swappable_coin, uint256))\r\n                length = self.market_counts[key]\r\n                self.markets[key][length] = pool\r\n                self.market_counts[key] = length + 1\r\n\r\n    log PlainPoolDeployed(_coins, _A, _fee, msg.sender)\r\n    return pool\r\n\r\n\r\n@external\r\ndef deploy_metapool(\r\n    _base_pool: address,\r\n    _name: String[32],\r\n    _symbol: String[10],\r\n    _coin: address,\r\n    _A: uint256,\r\n    _fee: uint256,\r\n    _implementation_idx: uint256 = 0,\r\n) -> address:\r\n    \"\"\"\r\n    @notice Deploy a new metapool\r\n    @param _base_pool Address of the base pool to use\r\n                      within the metapool\r\n    @param _name Name of the new metapool\r\n    @param _symbol Symbol for the new metapool - will be\r\n                   concatenated with the base pool symbol\r\n    @param _coin Address of the coin being used in the metapool\r\n    @param _A Amplification co-efficient - a higher value here means\r\n              less tolerance for imbalance within the pool's assets.\r\n              Suggested values include:\r\n               * Uncollateralized algorithmic stablecoins: 5-10\r\n               * Non-redeemable, collateralized assets: 100\r\n               * Redeemable assets: 200-400\r\n    @param _fee Trade fee, given as an integer with 1e10 precision. The\r\n                minimum fee is 0.04% (4000000), the maximum is 1% (100000000).\r\n                50% of the fee is distributed to veCRV holders.\r\n    @param _implementation_idx Index of the implementation to use. All possible\r\n                implementations for a BASE_POOL can be publicly accessed\r\n                via `metapool_implementations(BASE_POOL)`\r\n    @return Address of the deployed pool\r\n    \"\"\"\r\n    # fee must be between 0.04% and 1%\r\n    assert _fee >= 4000000 and _fee <= 100000000, \"Invalid fee\"\r\n\r\n    implementation: address = self.base_pool_data[_base_pool].implementations[_implementation_idx]\r\n    assert implementation != ZERO_ADDRESS, \"Invalid implementation index\"\r\n\r\n    # things break if a token has >18 decimals\r\n    decimals: uint256 = ERC20(_coin).decimals()\r\n    assert decimals < 19, \"Max 18 decimals for coins\"\r\n\r\n    pool: address = create_forwarder_to(implementation)\r\n    CurvePool(pool).initialize(_name, _symbol, _coin, 10 ** (36 - decimals), _A, _fee)\r\n    ERC20(_coin).approve(pool, MAX_UINT256)\r\n\r\n    # add pool to pool_list\r\n    length: uint256 = self.pool_count\r\n    self.pool_list[length] = pool\r\n    self.pool_count = length + 1\r\n\r\n    base_lp_token: address = self.base_pool_data[_base_pool].lp_token\r\n\r\n    self.pool_data[pool].decimals = [decimals, 0, 0, 0]\r\n    self.pool_data[pool].n_coins = 2\r\n    self.pool_data[pool].base_pool = _base_pool\r\n    self.pool_data[pool].coins[0] = _coin\r\n    self.pool_data[pool].coins[1] = self.base_pool_data[_base_pool].lp_token\r\n    self.pool_data[pool].implementation = implementation\r\n\r\n    is_finished: bool = False\r\n    for i in range(MAX_COINS):\r\n        swappable_coin: address = self.base_pool_data[_base_pool].coins[i]\r\n        if swappable_coin == ZERO_ADDRESS:\r\n            is_finished = True\r\n            swappable_coin = base_lp_token\r\n\r\n        key: uint256 = bitwise_xor(convert(_coin, uint256), convert(swappable_coin, uint256))\r\n        length = self.market_counts[key]\r\n        self.markets[key][length] = pool\r\n        self.market_counts[key] = length + 1\r\n        if is_finished:\r\n            break\r\n\r\n    log MetaPoolDeployed(_coin, _base_pool, _A, _fee, msg.sender)\r\n    return pool\r\n\r\n\r\n@external\r\ndef deploy_gauge(_pool: address) -> address:\r\n    \"\"\"\r\n    @notice Deploy a liquidity gauge for a factory pool\r\n    @param _pool Factory pool address to deploy a gauge for\r\n    @return Address of the deployed gauge\r\n    \"\"\"\r\n    assert self.pool_data[_pool].coins[0] != ZERO_ADDRESS, \"Unknown pool\"\r\n    assert self.pool_data[_pool].liquidity_gauge == ZERO_ADDRESS, \"Gauge already deployed\"\r\n    implementation: address = self.gauge_implementation\r\n    assert implementation != ZERO_ADDRESS, \"Gauge implementation not set\"\r\n\r\n    gauge: address = create_forwarder_to(implementation)\r\n    LiquidityGauge(gauge).initialize(_pool)\r\n    self.pool_data[_pool].liquidity_gauge = gauge\r\n\r\n    log LiquidityGaugeDeployed(_pool, gauge)\r\n    return gauge\r\n\r\n\r\n# <--- Admin / Guarded Functionality --->\r\n\r\n@external\r\ndef add_base_pool(\r\n    _base_pool: address,\r\n    _fee_receiver: address,\r\n    _asset_type: uint256,\r\n    _implementations: address[10],\r\n):\r\n    \"\"\"\r\n    @notice Add a base pool to the registry, which may be used in factory metapools\r\n    @dev Only callable by admin\r\n    @param _base_pool Pool address to add\r\n    @param _fee_receiver Admin fee receiver address for metapools using this base pool\r\n    @param _asset_type Asset type for pool, as an integer  0 = USD, 1 = ETH, 2 = BTC, 3 = Other\r\n    @param _implementations List of implementation addresses that can be used with this base pool\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.base_pool_data[_base_pool].coins[0] == ZERO_ADDRESS  # dev: pool exists\r\n\r\n    registry: address = AddressProvider(ADDRESS_PROVIDER).get_registry()\r\n    n_coins: uint256 = Registry(registry).get_n_coins(_base_pool)\r\n    assert n_coins > 0  # dev: pool not in registry\r\n\r\n    # add pool to pool_list\r\n    length: uint256 = self.base_pool_count\r\n    self.base_pool_list[length] = _base_pool\r\n    self.base_pool_count = length + 1\r\n    self.base_pool_data[_base_pool].lp_token = Registry(registry).get_lp_token(_base_pool)\r\n    self.base_pool_data[_base_pool].n_coins = n_coins\r\n    self.base_pool_data[_base_pool].fee_receiver = _fee_receiver\r\n    if _asset_type != 0:\r\n        self.base_pool_data[_base_pool].asset_type = _asset_type\r\n\r\n    for i in range(10):\r\n        implementation: address = _implementations[i]\r\n        if implementation == ZERO_ADDRESS:\r\n            break\r\n        self.base_pool_data[_base_pool].implementations[i] = implementation\r\n\r\n    decimals: uint256 = 0\r\n    coins: address[MAX_COINS] = Registry(registry).get_coins(_base_pool)\r\n    for i in range(MAX_COINS):\r\n        if i == n_coins:\r\n            break\r\n        coin: address = coins[i]\r\n        self.base_pool_data[_base_pool].coins[i] = coin\r\n        decimals += shift(ERC20(coin).decimals(), convert(i*8, int128))\r\n    self.base_pool_data[_base_pool].decimals = decimals\r\n\r\n    log BasePoolAdded(_base_pool)\r\n\r\n\r\n@external\r\ndef set_metapool_implementations(\r\n    _base_pool: address,\r\n    _implementations: address[10],\r\n):\r\n    \"\"\"\r\n    @notice Set implementation contracts for a metapool\r\n    @dev Only callable by admin\r\n    @param _base_pool Pool address to add\r\n    @param _implementations Implementation address to use when deploying metapools\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.base_pool_data[_base_pool].coins[0] != ZERO_ADDRESS  # dev: base pool does not exist\r\n\r\n    for i in range(10):\r\n        new_imp: address = _implementations[i]\r\n        current_imp: address = self.base_pool_data[_base_pool].implementations[i]\r\n        if new_imp == current_imp:\r\n            if new_imp == ZERO_ADDRESS:\r\n                break\r\n        else:\r\n            self.base_pool_data[_base_pool].implementations[i] = new_imp\r\n\r\n\r\n@external\r\ndef set_plain_implementations(\r\n    _n_coins: uint256,\r\n    _implementations: address[10],\r\n):\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    for i in range(10):\r\n        new_imp: address = _implementations[i]\r\n        current_imp: address = self.plain_implementations[_n_coins][i]\r\n        if new_imp == current_imp:\r\n            if new_imp == ZERO_ADDRESS:\r\n                break\r\n        else:\r\n            self.plain_implementations[_n_coins][i] = new_imp\r\n\r\n\r\n@external\r\ndef set_gauge_implementation(_gauge_implementation: address):\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n\r\n    self.gauge_implementation = _gauge_implementation\r\n\r\n\r\n@external\r\ndef set_gauge(_pool: address, _gauge: address):\r\n    assert msg.sender == self.admin  # dev: admin-only function\r\n    assert self.pool_data[_pool].coins[0] != ZERO_ADDRESS, \"Unknown pool\"\r\n\r\n    self.pool_data[_pool].liquidity_gauge = _gauge\r\n    log LiquidityGaugeDeployed(_pool, _gauge)\r\n\r\n\r\n@external\r\ndef batch_set_pool_asset_type(_pools: address[32], _asset_types: uint256[32]):\r\n    \"\"\"\r\n    @notice Batch set the asset type for factory pools\r\n    @dev Used to modify asset types that were set incorrectly at deployment\r\n    \"\"\"\r\n    assert msg.sender in [self.manager, self.admin]  # dev: admin-only function\r\n\r\n    for i in range(32):\r\n        if _pools[i] == ZERO_ADDRESS:\r\n            break\r\n        self.pool_data[_pools[i]].asset_type = _asset_types[i]\r\n\r\n\r\n@external\r\ndef commit_transfer_ownership(_addr: address):\r\n    \"\"\"\r\n    @notice Transfer ownership of this contract to `addr`\r\n    @param _addr Address of the new owner\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n\r\n    self.future_admin = _addr\r\n\r\n\r\n@external\r\ndef accept_transfer_ownership():\r\n    \"\"\"\r\n    @notice Accept a pending ownership transfer\r\n    @dev Only callable by the new owner\r\n    \"\"\"\r\n    _admin: address = self.future_admin\r\n    assert msg.sender == _admin  # dev: future admin only\r\n\r\n    self.admin = _admin\r\n    self.future_admin = ZERO_ADDRESS\r\n\r\n\r\n@external\r\ndef set_manager(_manager: address):\r\n    \"\"\"\r\n    @notice Set the manager\r\n    @dev Callable by the admin or existing manager\r\n    @param _manager Manager address\r\n    \"\"\"\r\n    assert msg.sender in [self.manager, self.admin]  # dev: admin-only function\r\n\r\n    self.manager = _manager\r\n\r\n\r\n@external\r\ndef set_fee_receiver(_base_pool: address, _fee_receiver: address):\r\n    \"\"\"\r\n    @notice Set fee receiver for base and plain pools\r\n    @param _base_pool Address of base pool to set fee receiver for.\r\n                      For plain pools, leave as `ZERO_ADDRESS`.\r\n    @param _fee_receiver Address that fees are sent to\r\n    \"\"\"\r\n    assert msg.sender == self.admin  # dev: admin only\r\n    if _base_pool == ZERO_ADDRESS:\r\n        self.fee_receiver = _fee_receiver\r\n    else:\r\n        self.base_pool_data[_base_pool].fee_receiver = _fee_receiver\r\n\r\n\r\n@external\r\ndef convert_metapool_fees() -> bool:\r\n    \"\"\"\r\n    @notice Convert the fees of a metapool and transfer to\r\n            the metapool's fee receiver\r\n    @dev All fees are converted to LP token of base pool\r\n    \"\"\"\r\n    base_pool: address = self.pool_data[msg.sender].base_pool\r\n    assert base_pool != ZERO_ADDRESS  # dev: sender must be metapool\r\n    coin: address = self.pool_data[msg.sender].coins[0]\r\n\r\n    amount: uint256 = ERC20(coin).balanceOf(self)\r\n    receiver: address = self.base_pool_data[base_pool].fee_receiver\r\n\r\n    CurvePool(msg.sender).exchange(0, 1, amount, 0, receiver)\r\n    return True", "ABI": "[{\"name\":\"BasePoolAdded\",\"inputs\":[{\"name\":\"base_pool\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"PlainPoolDeployed\",\"inputs\":[{\"name\":\"coins\",\"type\":\"address[4]\",\"indexed\":false},{\"name\":\"A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"deployer\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"MetaPoolDeployed\",\"inputs\":[{\"name\":\"coin\",\"type\":\"address\",\"indexed\":false},{\"name\":\"base_pool\",\"type\":\"address\",\"indexed\":false},{\"name\":\"A\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"fee\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"deployer\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"LiquidityGaugeDeployed\",\"inputs\":[{\"name\":\"pool\",\"type\":\"address\",\"indexed\":false},{\"name\":\"gauge\",\"type\":\"address\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_fee_receiver\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"metapool_implementations\",\"inputs\":[{\"name\":\"_base_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[10]\"}],\"gas\":21716},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"find_pool_for_coins\",\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_base_pool\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":2663},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_n_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":2699},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_meta_n_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5201},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[4]\"}],\"gas\":9164},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_coins\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address[8]\"}],\"gas\":21345},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_decimals\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"gas\":20185},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_decimals\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":19730},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_metapool_rates\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[2]\"}],\"gas\":5281},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"gas\":20435},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_underlying_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[8]\"}],\"gas\":39733},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_A\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3135},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_fees\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5821},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_admin_balances\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"gas\":13535},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_coin_indices\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"int128\"},{\"name\":\"\",\"type\":\"int128\"},{\"name\":\"\",\"type\":\"bool\"}],\"gas\":33243},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_gauge\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3089},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_implementation_address\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3119},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"is_meta\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":3152},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_pool_asset_type\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":5450},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_fee_receiver\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":5480},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_plain_pool\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coins\",\"type\":\"address[4]\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_plain_pool\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coins\",\"type\":\"address[4]\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_asset_type\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_plain_pool\",\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coins\",\"type\":\"address[4]\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_asset_type\",\"type\":\"uint256\"},{\"name\":\"_implementation_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_metapool\",\"inputs\":[{\"name\":\"_base_pool\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coin\",\"type\":\"address\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_metapool\",\"inputs\":[{\"name\":\"_base_pool\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_coin\",\"type\":\"address\"},{\"name\":\"_A\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_implementation_idx\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deploy_gauge\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":93401},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_base_pool\",\"inputs\":[{\"name\":\"_base_pool\",\"type\":\"address\"},{\"name\":\"_fee_receiver\",\"type\":\"address\"},{\"name\":\"_asset_type\",\"type\":\"uint256\"},{\"name\":\"_implementations\",\"type\":\"address[10]\"}],\"outputs\":[],\"gas\":925811},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_metapool_implementations\",\"inputs\":[{\"name\":\"_base_pool\",\"type\":\"address\"},{\"name\":\"_implementations\",\"type\":\"address[10]\"}],\"outputs\":[],\"gas\":382072},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_plain_implementations\",\"inputs\":[{\"name\":\"_n_coins\",\"type\":\"uint256\"},{\"name\":\"_implementations\",\"type\":\"address[10]\"}],\"outputs\":[],\"gas\":379687},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_gauge_implementation\",\"inputs\":[{\"name\":\"_gauge_implementation\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38355},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_gauge\",\"inputs\":[{\"name\":\"_pool\",\"type\":\"address\"},{\"name\":\"_gauge\",\"type\":\"address\"}],\"outputs\":[],\"gas\":43210},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"batch_set_pool_asset_type\",\"inputs\":[{\"name\":\"_pools\",\"type\":\"address[32]\"},{\"name\":\"_asset_types\",\"type\":\"uint256[32]\"}],\"outputs\":[],\"gas\":1139575},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"commit_transfer_ownership\",\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38445},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_transfer_ownership\",\"inputs\":[],\"outputs\":[],\"gas\":58396},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_manager\",\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"outputs\":[],\"gas\":41026},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_fee_receiver\",\"inputs\":[{\"name\":\"_base_pool\",\"type\":\"address\"},{\"name\":\"_fee_receiver\",\"type\":\"address\"}],\"outputs\":[],\"gas\":38800},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"convert_metapool_fees\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"gas\":12910},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3438},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_admin\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3468},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"manager\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3498},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_list\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3573},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pool_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3558},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"base_pool_list\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3633},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"base_pool_count\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"gas\":3618},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"plain_implementations\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"},{\"name\":\"arg1\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3808},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fee_receiver\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3678},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"gauge_implementation\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"gas\":3708}]", "ContractName": "Vyper_contract", "CompilerVersion": "vyper:0.2.16", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000007eeac6cddbd1d0b8af061742d41877d7f707289a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}