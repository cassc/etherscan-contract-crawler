{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\\n * proxy whose upgrades are fully controlled by the current implementation.\\n */\\ninterface IERC1822ProxiableUpgradeable {\\n    /**\\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\\n     * address.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy.\\n     */\\n    function proxiableUUID() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/interfaces/IERC1967Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\\n *\\n * _Available since v4.8.3._\\n */\\ninterface IERC1967Upgradeable {\\n    /**\\n     * @dev Emitted when the implementation is upgraded.\\n     */\\n    event Upgraded(address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when the admin account has changed.\\n     */\\n    event AdminChanged(address previousAdmin, address newAdmin);\\n\\n    /**\\n     * @dev Emitted when the beacon is changed.\\n     */\\n    event BeaconUpgraded(address indexed beacon);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeaconUpgradeable {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../beacon/IBeaconUpgradeable.sol\\\";\\nimport \\\"../../interfaces/IERC1967Upgradeable.sol\\\";\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\nimport \\\"../../utils/StorageSlotUpgradeable.sol\\\";\\nimport \\\"../utils/Initializable.sol\\\";\\n\\n/**\\n * @dev This abstract contract provides getters and event emitting update functions for\\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract ERC1967UpgradeUpgradeable is Initializable, IERC1967Upgradeable {\\n    function __ERC1967Upgrade_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\\n    }\\n    // This is the keccak-256 hash of \\\"eip1967.proxy.rollback\\\" subtracted by 1\\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\\n\\n    /**\\n     * @dev Storage slot with the address of the current implementation.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.implementation\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n\\n    /**\\n     * @dev Returns the current implementation address.\\n     */\\n    function _getImplementation() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 implementation slot.\\n     */\\n    function _setImplementation(address newImplementation) private {\\n        require(AddressUpgradeable.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeTo(address newImplementation) internal {\\n        _setImplementation(newImplementation);\\n        emit Upgraded(newImplementation);\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\\n        _upgradeTo(newImplementation);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(newImplementation, data);\\n        }\\n    }\\n\\n    /**\\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\\n     *\\n     * Emits an {Upgraded} event.\\n     */\\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\\n            _setImplementation(newImplementation);\\n        } else {\\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\\n                require(slot == _IMPLEMENTATION_SLOT, \\\"ERC1967Upgrade: unsupported proxiableUUID\\\");\\n            } catch {\\n                revert(\\\"ERC1967Upgrade: new implementation is not UUPS\\\");\\n            }\\n            _upgradeToAndCall(newImplementation, data, forceCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Storage slot with the admin of the contract.\\n     * This is the keccak-256 hash of \\\"eip1967.proxy.admin\\\" subtracted by 1, and is\\n     * validated in the constructor.\\n     */\\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\\n\\n    /**\\n     * @dev Returns the current admin.\\n     */\\n    function _getAdmin() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new address in the EIP1967 admin slot.\\n     */\\n    function _setAdmin(address newAdmin) private {\\n        require(newAdmin != address(0), \\\"ERC1967: new admin is the zero address\\\");\\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\\n    }\\n\\n    /**\\n     * @dev Changes the admin of the proxy.\\n     *\\n     * Emits an {AdminChanged} event.\\n     */\\n    function _changeAdmin(address newAdmin) internal {\\n        emit AdminChanged(_getAdmin(), newAdmin);\\n        _setAdmin(newAdmin);\\n    }\\n\\n    /**\\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\\n     */\\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\\n\\n    /**\\n     * @dev Returns the current beacon.\\n     */\\n    function _getBeacon() internal view returns (address) {\\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\\n    }\\n\\n    /**\\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\\n     */\\n    function _setBeacon(address newBeacon) private {\\n        require(AddressUpgradeable.isContract(newBeacon), \\\"ERC1967: new beacon is not a contract\\\");\\n        require(\\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\\n            \\\"ERC1967: beacon implementation is not a contract\\\"\\n        );\\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\\n    }\\n\\n    /**\\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\\n     *\\n     * Emits a {BeaconUpgraded} event.\\n     */\\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\\n        _setBeacon(newBeacon);\\n        emit BeaconUpgraded(newBeacon);\\n        if (data.length > 0 || forceCall) {\\n            AddressUpgradeable.functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\\n        }\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../interfaces/draft-IERC1822Upgradeable.sol\\\";\\nimport \\\"../ERC1967/ERC1967UpgradeUpgradeable.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/**\\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\\n *\\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\\n * `UUPSUpgradeable` with a custom implementation of upgrades.\\n *\\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\\n    function __UUPSUpgradeable_init() internal onlyInitializing {\\n    }\\n\\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\\n    }\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\\n    address private immutable __self = address(this);\\n\\n    /**\\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\\n     * fail.\\n     */\\n    modifier onlyProxy() {\\n        require(address(this) != __self, \\\"Function must be called through delegatecall\\\");\\n        require(_getImplementation() == __self, \\\"Function must be called through active proxy\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\\n     * callable on the implementing contract but not through proxies.\\n     */\\n    modifier notDelegated() {\\n        require(address(this) == __self, \\\"UUPSUpgradeable: must not be called through delegatecall\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\\n     *\\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\\n     */\\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\\n        return _IMPLEMENTATION_SLOT;\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\\n    }\\n\\n    /**\\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\\n     * encoded in `data`.\\n     *\\n     * Calls {_authorizeUpgrade}.\\n     *\\n     * Emits an {Upgraded} event.\\n     *\\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\\n     */\\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\\n        _authorizeUpgrade(newImplementation);\\n        _upgradeToAndCallUUPS(newImplementation, data, true);\\n    }\\n\\n    /**\\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\\n     * {upgradeTo} and {upgradeToAndCall}.\\n     *\\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\\n     *\\n     * ```solidity\\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\\n     * ```\\n     */\\n    function _authorizeUpgrade(address newImplementation) internal virtual;\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    function __Pausable_init() internal onlyInitializing {\\n        __Pausable_init_unchained();\\n    }\\n\\n    function __Pausable_init_unchained() internal onlyInitializing {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/utils/ERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"../../../utils/introspection/ERC165Upgradeable.sol\\\";\\nimport \\\"../../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\nabstract contract ERC1155ReceiverUpgradeable is Initializable, ERC165Upgradeable, IERC1155ReceiverUpgradeable {\\n    function __ERC1155Receiver_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC1155Receiver_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\nimport \\\"../../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\\n    function __ERC165_init() internal onlyInitializing {\\n    }\\n\\n    function __ERC165_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for reading and writing primitive types to specific storage slots.\\n *\\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\\n * This library helps with reading and writing to such slots without the need for inline assembly.\\n *\\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\\n *\\n * Example usage to set ERC1967 implementation slot:\\n * ```solidity\\n * contract ERC1967 {\\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\n *\\n *     function _getImplementation() internal view returns (address) {\\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\\n *     }\\n *\\n *     function _setImplementation(address newImplementation) internal {\\n *         require(Address.isContract(newImplementation), \\\"ERC1967: new implementation is not a contract\\\");\\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\\n *     }\\n * }\\n * ```\\n *\\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\\n * _Available since v4.9 for `string`, `bytes`._\\n */\\nlibrary StorageSlotUpgradeable {\\n    struct AddressSlot {\\n        address value;\\n    }\\n\\n    struct BooleanSlot {\\n        bool value;\\n    }\\n\\n    struct Bytes32Slot {\\n        bytes32 value;\\n    }\\n\\n    struct Uint256Slot {\\n        uint256 value;\\n    }\\n\\n    struct StringSlot {\\n        string value;\\n    }\\n\\n    struct BytesSlot {\\n        bytes value;\\n    }\\n\\n    /**\\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\\n     */\\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\\n     */\\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\\n     */\\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\\n     */\\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\\n     */\\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\\n     */\\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\\n     */\\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := slot\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\\n     */\\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            r.slot := store.slot\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(\\n        address[] calldata accounts,\\n        uint256[] calldata ids\\n    ) external view returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```solidity\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/RCAXAvatarSwap.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.9;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC1155/utils/ERC1155ReceiverUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"libraries/AvatarContracts.sol\\\";\\n\\n// Users can swap their Aww/Drip/Meme/Singu and paid avatars instantly with an avatar in from the same pool.\\n// First swap is free, then it will cost a RCAX fee per swap.\\n// Half of the fee will go to the liquidity provider.\\n// Other half of the fees will go to the contract owner.\\n\\n/// @custom:oz-upgrades-unsafe-allow external-library-linking\\ncontract RCAXAvatarSwap is Initializable, PausableUpgradeable, OwnableUpgradeable, ERC1155ReceiverUpgradeable, UUPSUpgradeable {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    struct AvatarToken {\\n        address owner;\\n        address tokenAddress;\\n        uint256 tokenId;\\n    }\\n\\n    address public constant RCAX_TOKEN_ADDRESS = 0x875f123220024368968d9f1aB1f3F9C2f3fd190d;\\n    address public constant RCAX_DEV_FUND_WALLET = 0xB5C42f30cEAE2032F22d364E33A5BaEfA1A043FF;\\n    string public constant AWW_DRIP_MEME_SINGU_POOL_IDENTIFIER = \\\"awwdripmemesingu\\\";\\n    string public constant GEN_1_POOL_IDENTIFIER = \\\"gen1\\\";\\n    string public constant GEN_2_POOL_IDENTIFIER = \\\"gen2\\\";\\n    string public constant GEN_3_POOL_IDENTIFIER = \\\"gen3\\\";\\n    uint256 public constant AWW_DRIP_MEME_SINGU_POOL_FEE = 20 * 10**18;\\n    uint256 public constant GEN_1_POOL_FEE = 80 * 10**18;\\n    uint256 public constant GEN_2_POOL_FEE = 40 * 10**18;\\n    uint256 public constant GEN_3_POOL_FEE = 20 * 10**18;\\n\\n    mapping(address => bool) private _freeDemoUsed;\\n    mapping(address => bool) private _isLiquidityProvider;\\n    mapping(string => AvatarToken[]) _avatarPools;\\n\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\n    constructor() {\\n        _disableInitializers();\\n    }\\n\\n    function initialize() initializer public {\\n        __Pausable_init();\\n        __Ownable_init();\\n        __UUPSUpgradeable_init();\\n    }\\n\\n    function pause() public onlyOwner {\\n        _pause();\\n    }\\n\\n    function unpause() public onlyOwner {\\n        _unpause();\\n    }\\n\\n    function _authorizeUpgrade(address newImplementation)\\n    internal\\n    onlyOwner\\n    override\\n    {}\\n\\n    // Get the pool identifier for an avatar contract address\\n    function getPoolIdentifier(address tokenAddress) public pure returns (string memory) {\\n        if (AvatarContracts.isAvatarAwwDripMemeSingu(tokenAddress)) {\\n            return AWW_DRIP_MEME_SINGU_POOL_IDENTIFIER;\\n        } else if (AvatarContracts.isAvatarGen1(tokenAddress)) {\\n            return GEN_1_POOL_IDENTIFIER;\\n        } else if (AvatarContracts.isAvatarGen2(tokenAddress)) {\\n            return GEN_2_POOL_IDENTIFIER;\\n        } else if (AvatarContracts.isAvatarGen3(tokenAddress)) {\\n            return GEN_3_POOL_IDENTIFIER;\\n        } else {\\n            revert(\\\"RCA is not eligible for a swap\\\");\\n        }\\n    }\\n\\n    function getPoolFeeForToken(address tokenAddress) public pure returns (uint256) {\\n        if (AvatarContracts.isAvatarAwwDripMemeSingu(tokenAddress)) {\\n            return AWW_DRIP_MEME_SINGU_POOL_FEE;\\n        } else if (AvatarContracts.isAvatarGen1(tokenAddress)) {\\n            return GEN_1_POOL_FEE;\\n        } else if (AvatarContracts.isAvatarGen2(tokenAddress)) {\\n            return GEN_2_POOL_FEE;\\n        } else if (AvatarContracts.isAvatarGen3(tokenAddress)) {\\n            return GEN_3_POOL_FEE;\\n        } else {\\n            revert(\\\"RCA is not eligible for a swap\\\");\\n        }\\n    }\\n\\n    // Check if there is enough avatars in the pool\\n    // Perform a swap if so\\n    function _checkDoSwap(address initiator, AvatarToken memory initiatorAvatar) internal {\\n        string memory poolIdentifier = getPoolIdentifier(initiatorAvatar.tokenAddress);\\n\\n        require(_avatarPools[poolIdentifier].length >= 1, \\\"Pool size is too small for a swap\\\");\\n\\n        _performSwap(initiator, initiatorAvatar);\\n    }\\n\\n    // Generate a pseudo-random index based on block information\\n    function _getRandomIndex(uint256 maxIndex) internal view returns (uint256) {\\n        uint256 blockValue = uint256(blockhash(block.number - 1));\\n        return blockValue % maxIndex;\\n    }\\n\\n    // Send avatar to recipient\\n    function _sendAvatar(address recipient, address tokenAddress, uint256 tokenId) internal {\\n        require(IERC1155(tokenAddress).balanceOf(address(this), tokenId) == 1, \\\"Avatar is not owned by the contract\\\");\\n\\n        try IERC1155(tokenAddress).safeTransferFrom(address(this), recipient, tokenId, 1, \\\"\\\") {\\n            // Successful transfer\\n        } catch (bytes memory revertReason) {\\n            // Handle the revert reason, e.g., by emitting an event or reverting with an error message\\n            revert(string(revertReason));\\n        }\\n    }\\n\\n    function setLiquidityProviderStatus(bool status) external {\\n        require(status != _isLiquidityProvider[msg.sender], \\\"Liquidity provider status is already set\\\");\\n\\n        _isLiquidityProvider[msg.sender] = status;\\n    }\\n\\n    function getLiquidityProviderStatus(address wallet) external view returns (bool) {\\n        return _isLiquidityProvider[wallet];\\n    }\\n\\n    function getFreeDemoUsedStatus(address wallet) external view returns (bool) {\\n        return _freeDemoUsed[wallet];\\n    }\\n\\n    function withdrawAllAvatars() external {\\n        _withdrawAllAvatarsFromPool(AWW_DRIP_MEME_SINGU_POOL_IDENTIFIER);\\n        _withdrawAllAvatarsFromPool(GEN_1_POOL_IDENTIFIER);\\n        _withdrawAllAvatarsFromPool(GEN_2_POOL_IDENTIFIER);\\n        _withdrawAllAvatarsFromPool(GEN_3_POOL_IDENTIFIER);\\n    }\\n\\n    function _withdrawAllAvatarsFromPool(string memory poolIdentifier) internal {\\n        AvatarToken[] memory poolAvatars = getAllAvatarsInPoolForOwner(msg.sender, poolIdentifier);\\n\\n        for (uint256 i = 0; i < poolAvatars.length; i++) {\\n            _withdrawAvatar(poolAvatars[i]);\\n        }\\n    }\\n\\n    function getAllAvatarsInPoolForOwner(address owner, string memory poolIdentifer) public view returns (AvatarToken[] memory) {\\n        uint256 ownedAvatarsAmount = 0;\\n\\n        for (uint256 i = 0; i < _avatarPools[poolIdentifer].length; i++) {\\n            if (_avatarPools[poolIdentifer][i].owner == owner) {\\n                ownedAvatarsAmount += 1;\\n            }\\n        }\\n\\n        uint256 foundOwnedAvatarsAmount = 0;\\n        AvatarToken[] memory ownedAvatars = new AvatarToken[](ownedAvatarsAmount);\\n\\n        for (uint256 i = 0; i < _avatarPools[poolIdentifer].length; i++) {\\n            if (_avatarPools[poolIdentifer][i].owner == owner) {\\n                ownedAvatars[foundOwnedAvatarsAmount] = AvatarToken({\\n                owner: _avatarPools[poolIdentifer][i].owner,\\n                tokenAddress: _avatarPools[poolIdentifer][i].tokenAddress,\\n                tokenId: _avatarPools[poolIdentifer][i].tokenId\\n                });\\n\\n                foundOwnedAvatarsAmount += 1;\\n            }\\n        }\\n\\n        return ownedAvatars;\\n    }\\n\\n    function _withdrawAvatar(AvatarToken memory avatar) internal {\\n        require(avatar.owner == msg.sender, \\\"Only the owner can withdraw their avatars\\\");\\n\\n        string memory poolIdentifier = getPoolIdentifier(avatar.tokenAddress);\\n\\n        bool avatarFound = false;\\n\\n        // Remove the avatar from the pool\\n        for (uint256 i = 0; i < _avatarPools[poolIdentifier].length; i++) {\\n            if (_avatarPools[poolIdentifier][i].tokenAddress == avatar.tokenAddress && _avatarPools[poolIdentifier][i].tokenId == avatar.tokenId) {\\n                _avatarPools[poolIdentifier][i] = _avatarPools[poolIdentifier][_avatarPools[poolIdentifier].length - 1];\\n                avatarFound = true;\\n                break;\\n            }\\n        }\\n\\n        require(avatarFound, \\\"Could not find to be withdrawn avatar\\\");\\n\\n        _avatarPools[poolIdentifier].pop();\\n\\n        _sendAvatar(msg.sender, avatar.tokenAddress, avatar.tokenId);\\n    }\\n\\n    function _sendRCAXTokens(address from, address to, uint256 amount) internal {\\n        require(IERC20(RCAX_TOKEN_ADDRESS).balanceOf(from) >= amount, \\\"Wallet does not have enough RCAX tokens\\\");\\n\\n        if (from != address(this)) {\\n            require(IERC20(RCAX_TOKEN_ADDRESS).allowance(from, address(this)) >= amount, \\\"Contract is not allowed to spend enough tokens\\\");\\n        }\\n\\n        try IERC20(RCAX_TOKEN_ADDRESS).transferFrom(from, to, amount) {\\n            // Successful transfer\\n        } catch (bytes memory revertReason) {\\n            // Handle the revert reason, e.g., by emitting an event or reverting with an error message\\n            revert(string(revertReason));\\n        }\\n    }\\n\\n    function _processServiceFee(address liquidityProvider, address initiator, uint256 amount) internal {\\n        uint256 contractOwnerFee = amount / 2;\\n\\n        _sendRCAXTokens(initiator, liquidityProvider, amount - contractOwnerFee);\\n        _sendRCAXTokens(initiator, RCAX_DEV_FUND_WALLET, contractOwnerFee);\\n    }\\n\\n    // Swap avatars between owners until no more swaps are available\\n    function _performSwap(address initiator, AvatarToken memory initiatorAvatar) internal {\\n        string memory poolIdentifier = getPoolIdentifier(initiatorAvatar.tokenAddress);\\n\\n        uint256 randomPoolAvatarIndex = _getRandomIndex(_avatarPools[poolIdentifier].length);\\n\\n        AvatarToken memory randomPoolAvatar = AvatarToken({\\n        owner: _avatarPools[poolIdentifier][randomPoolAvatarIndex].owner,\\n        tokenAddress: _avatarPools[poolIdentifier][randomPoolAvatarIndex].tokenAddress,\\n        tokenId: _avatarPools[poolIdentifier][randomPoolAvatarIndex].tokenId\\n        });\\n\\n        if (!_freeDemoUsed[initiator]) {\\n            _freeDemoUsed[initiator] = true;\\n        } else {\\n            // todo: get dynamic service fee\\n\\n            uint256 serviceFee = getPoolFeeForToken(initiatorAvatar.tokenAddress);\\n\\n            _processServiceFee(randomPoolAvatar.owner, initiator, serviceFee);\\n        }\\n\\n        initiatorAvatar.owner = randomPoolAvatar.owner;\\n\\n        _avatarPools[poolIdentifier][randomPoolAvatarIndex] = initiatorAvatar;\\n\\n        _sendAvatar(initiator, randomPoolAvatar.tokenAddress, randomPoolAvatar.tokenId);\\n    }\\n\\n    function _addAvatarToPool(AvatarToken memory avatar) internal {\\n        string memory poolIdentifier = getPoolIdentifier(avatar.tokenAddress);\\n        _avatarPools[poolIdentifier].push(avatar);\\n    }\\n\\n    function _handleReceivedAvatar(address from, address tokenAddress, uint256 tokenId) internal whenNotPaused() {\\n        AvatarToken memory avatar = AvatarToken ({\\n        owner: from,\\n        tokenAddress: tokenAddress,\\n        tokenId: tokenId\\n        });\\n\\n        // If liquidity provider sends an RCA, add it to the pool directly\\n        // Else try and do a swap\\n        if (_isLiquidityProvider[from]) {\\n            _addAvatarToPool(avatar);\\n        } else {\\n            _checkDoSwap(from, avatar);\\n        }\\n    }\\n\\n    function onERC1155Received(\\n        address,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata\\n    ) public override returns (bytes4) {\\n        require(value == 1, \\\"Value must be 1\\\");\\n\\n        _handleReceivedAvatar(from, msg.sender, id);\\n\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata\\n    ) public override returns (bytes4) {\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            require(values[i] == 1, \\\"Every value must be 1\\\");\\n        }\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _handleReceivedAvatar(from, msg.sender, ids[i]);\\n        }\\n\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    function getAllAvatarsInPool(string memory poolIdentifer) external view returns (AvatarToken[] memory) {\\n        return _avatarPools[poolIdentifer];\\n    }\\n}\\n\"\r\n    },\r\n    \"libraries/AvatarContracts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary AvatarContracts {\\n    function getAwwDripMemeSinguContracts() public pure returns (address[4] memory) {\\n        address[4] memory AWW_DRIP_MEME_SINGU_CONTRACTS = [\\n        0x6acB8fb82880d39c2B8446F8778A14d34Ee6cFb7,\\n        0xbfd670667053e517a97AFE56C91e4f83f1160Bd3,\\n        0xb9C042c3275BC49799688EEA1A29b1405D02946B,\\n        0x466a330887bDF62D53f968EA824793150f07762e\\n        ];\\n\\n        return AWW_DRIP_MEME_SINGU_CONTRACTS;\\n    }\\n\\n    function getAvatarGen1Contracts() public pure returns (address[29] memory) {\\n        address[29] memory GEN_1_CONTRACTS = [\\n        0x8D0501d85becDA92B89E56177dDfcEA5Fc1f0AF2,\\n        0x5846728730366d686CdC95dae80a70b44Ec9eAb2,\\n        0xfbEd9640e37666fe2AC78e1d263670976354Cb69,\\n        0xe0743141DF04a6B9f3dF890429cC994e46DB03D9,\\n        0x97439Ee4c93Ff9f76417696cE648aa6f35AB3B25,\\n        0xf43bc3f4F1edb7d4C373C8510A2888d69d83cEB7,\\n        0x425bf054Ef7bAD65B7BDd8E6587B1c3500E4F4CA,\\n        0x2956409293da98603025Cc0121C06A4244752039,\\n        0xa7Bb50d90B43752199c45Be04053641C3cb5f53f,\\n        0x47749C5B970e63F3a0ed57Cd6ceF773E74FaFe9d,\\n        0x838c1CD42929543daF9C3ef294Fee8c1b3224B37,\\n        0xC5Aa1F91b0d52e26D2847f8e51f505d6e2ECe795,\\n        0xeE1Ee80338958fA596471CEb70F0177DafF80323,\\n        0x4670e4890Bc1b76F3aE5c7660aA98E0B6668C6F3,\\n        0x2D58a44d6c0A355de25761fB33A1f6269A97e2C5,\\n        0xD8cF23bF309DE778609d234BD2410B0156118c26,\\n        0x91E51B92a2EfEA89bF1B6f66ad719737264724bE,\\n        0xd6261320F49d38c137f6e229a2EA4Ab0F4Fae6DE,\\n        0xFC190440E8f357fFE8A75940e7D8A291E165d019,\\n        0x808ED3E23aac685126524aA4416d8eaeB2E767B9,\\n        0x65a83530Ca8abc27969907913Fe5E641a5DA2e9f,\\n        0x6d1c3646e8Cce8537E6ec9eCAb26762bfAf1f891,\\n        0x63e2f0C058Ce9A194eC68F04320b7Eb8cA555BD3,\\n        0x45308788743bBDAe5DE7ba9e565c0502d0EBb81F,\\n        0x907808732079863886443057C65827a0F1c64357,\\n        0x6ad08588568E258b2BdF065e7769FCE398F68A1C,\\n        0x946aD8E53db653053E8ef7C02DFCA83ce8bA8022,\\n        0x27B37E4Befacc50B02102d1E2117c4EA8A54bEFf,\\n        0x71DC46607F31f30510f0ccc670B0963F431b212A\\n        ];\\n\\n        return GEN_1_CONTRACTS;\\n    }\\n\\n    function getAvatarGen2Contracts() public pure returns (address[27] memory) {\\n        address[27] memory GEN_2_CONTRACTS = [\\n        0xE4989961ebFDAc3E65Fcf0059c916452C77D8503,\\n        0x621CE7e7E44d43A428A183D5390c4F4572C9ff9d,\\n        0x04F7a676Af597F847053B6c02ED42D02fa4046Aa,\\n        0xE1b5E23FdBC003Aec16E6E79726A0b5f75ff93f5,\\n        0x8264E2bad3d2f7aFD72a00233b9f841Fe4b388Cd,\\n        0x334Ad326A787dD332f26CbE8B4d7ADfA8bD25F92,\\n        0xD5ae5A16fBAf964f96E242645a4a6F10b98fD0C4,\\n        0x04f087e3191d7a050800A2e04cb20046D2633E35,\\n        0x37dB2523D221d19838632Eb62d1af911e52632C3,\\n        0x21d426e2B88Fbf8b93adf0591A2D5B08d58F089f,\\n        0x91aC106090fE2b0Fa7d01efdf4487a5bfAfAd7FA,\\n        0xBC096988fa38c78D65C0637453fd3D3C38B1CfD4,\\n        0x150AfA2DfCaAadA471472dFA6Ad4b79E718A197c,\\n        0x5Fd4D6fEF3b87B91c7DF8658727b5Edd7210cF5a,\\n        0x2E90e8AF4C319095942C84cFA446E1f206795517,\\n        0x3e4627665Bf2E52c69bE03788e664Ab545F2be71,\\n        0x45EE1CAeD83525673843321107bccaDecb9065D7,\\n        0xdAA6e4bA2D4022ED820460BB501B9E061D9614fB,\\n        0x83fEEA011BAEB1C6d1df7D23903efaD83d3C781F,\\n        0x81BA34b90876F42F34a4f232CfC0FE4b6ec949a3,\\n        0xdDbDB65138131DBf2d01b4a5140E1979680c90Bb,\\n        0xFeC90bc707Fc93AeFeb0C18c2Eb56bc79d32163e,\\n        0x04125a97a0F2583CD485BE2C34b651cC13c38A27,\\n        0x7E680862c572e4B945CF45912130C8D884109b59,\\n        0x3458161f2Dc5D7eAfA48E7c8d9Acd7f415CF6dA6,\\n        0x0985cb10C5d57dbF44AA473F33839eD38d80F111,\\n        0xC70A7496716B3e25546901fE88215531ABbD5a10\\n        ];\\n\\n        return GEN_2_CONTRACTS;\\n    }\\n\\n    function getAvatarGen3Contracts() public pure returns (address[100] memory) {\\n        address[100] memory GEN_3_CONTRACTS = [\\n        0x12ACf83f5e855bE05dBc24b9Fee087049DeDfBf8,\\n        0x96E55659845cA96dEbA2b8748D8987A7d2d94f4A,\\n        0x6a73da4e3d49baA2485d975Af1AE71CeE638ebBf,\\n        0xc3127DC36f1333f3a34FFcc21c0920ba9A6Dd837,\\n        0x7c035E6DE5e6B80307747BF9C23E74CC65A3B763,\\n        0x07ad84Fd47727A2733dC2043373Af7295E267374,\\n        0xEeA14F2a8cfaf73736397832aB890Bb28CE263bC,\\n        0x4dB1E32Bdb33D6B76AE6e5d7fA7f18bcd9f4B905,\\n        0xe2A98Ba4f46FA47D938BE8dfc82C82C35700C5F0,\\n        0x06607F8c97ca2AAB4CE17F91ACEA50f2261F1E1d,\\n        0xC374e996A79Fe8f91b9d78c4Ec29F6219e5Bd57f,\\n        0xC2148d2DB71D7B8CEbabc896ee4D62133D6bC42B,\\n        0xa7CE4385C0293e95A909b42091dA2186b8d49C2C,\\n        0x8CdaA0BEe4C5742ed8196b3FC1f2E3d91E6cf869,\\n        0xcbE4e48e6C883B313C06a002009289501178339D,\\n        0x27931513a87B62889992A76c3D975B6C712D909d,\\n        0x80bE35056D9467841a74dcd80253729C508cad32,\\n        0x248E6D478578216822635B95C7A1970A16223836,\\n        0x5FD0102E00EC829ef34aC4f0056a1698DFE210d9,\\n        0x6F7164b378FDbEED629806c9bbCBBbaE318Dc87C,\\n        0x2400FC8417A12C1A483d8923F61019f4bD86dB30,\\n        0x7F8cbA17511Ac40270BB4EF13EBa47165E577cc8,\\n        0x3E249Ae5a200230A1F25b3dEE35755463156b382,\\n        0xfDe389b3E688f12c8EfD5548b93540c3f06BfbB0,\\n        0x9C11774f5813CaB12318Ee6D23FB7768f95AE906,\\n        0x0b73e49a7F0fB6533A33e0bAE2dC30130604FB0c,\\n        0xEf90F515cEb7c02f112b277553Fa0Ee774bCa7eA,\\n        0x495A0E16eAC093f2FBF99b3F8da1aa5fAfa4A4fe,\\n        0x4Dc89CE97d15361bCa0BA357ea3daC6044B9Fd1F,\\n        0xa123d85f522a55A556ccba1E15cffc67c7aFdCD8,\\n        0xA7570feD5eeb2516302E1b0fdBcB8C25ec539191,\\n        0xf4d215A4E75BeDa4Bc99609b2af2702e7D2D1111,\\n        0x5BbaE18120A52755DEBa69dD1fF2628FBA229D33,\\n        0x750314B875E8cFF5baa385Db3E172686Ca1fcE40,\\n        0x7F44bcE8c31386500B30e02F371E797ad3410349,\\n        0x0F4Ea45F6B9828Ba6ac7400504A66D93f4C93C25,\\n        0xD854adD818Cc7c1225624e5c6b61BA81f656ba62,\\n        0xe7484F96D20Ee75e146C1917d094aC64F59699cD,\\n        0x8dA1DA24Ef2c0E39aaF9c89aF6CbF966CF0Dcd0C,\\n        0xd56c6a3B189AEA44993F2EeC9B3baf721BA9B5ab,\\n        0x2218e323ab826775e9Fd026098a200606D4dd32c,\\n        0xfFD17d9dd02c6bB3096528f36D0c2cB9335Fac9D,\\n        0x155bAB02984Bcaf25c60ca643688b0E4339c3bC8,\\n        0x9F5dcd096e85aCceCf7F2b2EC0a132CF44fe7996,\\n        0x6B6bA11ffBCbdc0f22517B972278fA40650AC00f,\\n        0x1a5DEC5283A686a7EFeAD3F25e407e7dA7fB4b5f,\\n        0xfFe99A2604ae1B606490675475B4Db1Aa0b9917B,\\n        0xA32e8ef4b15820Cee80FA0573A957F11CaeC6007,\\n        0x139F7693cB689922D04831c339f5AE7ea3EeFb79,\\n        0x02a898554A3122a07764Ef1B4ceDb123Cbb1D075,\\n        0x2F2E8B6B0Bb62598753621CEb7c1025212E6267b,\\n        0xBf5450A58e660740CB9EeD444BC3658f2a1B7bB3,\\n        0x86B7C641eFe718ec7d8d4972fDFbeDa3669587B6,\\n        0x4b5504E8619cD65692c6bBBedc54E6d7aFe5BFF5,\\n        0x7D4CAAf1D9291071452A4f11A3D0DA7AA881AAAd,\\n        0x91028695E1C266f02DFF4C481669b1a48bA96D64,\\n        0xf3f1798eE4D40b78d32A2fE321d045a591E7103a,\\n        0xfdba313e9d2E52299Ec317a6Fa05a141767E61b4,\\n        0x2C2C60f114ae3c857Bf301D1a1b6c3069D5308Dc,\\n        0x9172d60b2475060f3671E07028340c4cBaA4E263,\\n        0xdc61b17587975317Fb621b725C6D5Be51Ac9A55B,\\n        0x517CEdc05f38211113e58663eD4EAbed854c0F77,\\n        0x44f62B14382c764364D35eB98B31Afe5299A76F2,\\n        0x3c7a63bc43943322970770f932133d0dDd4f3D60,\\n        0xDC1CDd1196B3f44C69D49548f5f70b96F04B3fEc,\\n        0xC807ce5F1FD6515cBBe9dEF35e086E60E720b60B,\\n        0x932f05045a01e679Ab95A29bA383D9c0954502bf,\\n        0xBe418B221Bf5b2d570066160DA2676Bb51D9B254,\\n        0xEfDed257Ca71b9E3BbC9C0959A1Ef4Ad494C8897,\\n        0x4be1E01C4068C731A218C496EEe56Fcc8D1D2C19,\\n        0xC229a141d49dfb08F06bc2F03Cd912b0cfC7A29f,\\n        0x021a832F2aA9826BdF1a07bC41274bA4B4Fef68c,\\n        0x16c309B6B01402eC196e4aE9a05946f5a0f4d6c4,\\n        0xc1894ded8F0b81fD174b23d510f08Ed722CE63ef,\\n        0xcBe6cBD8C3E73d0A3e2cd4F24e4C0Dbb61299643,\\n        0x255e01E07A279449486dB6F236b9fE09ee6B67d3,\\n        0xf897E2Cd445Bdc5ac02A8D116caA2c2FB767FDf1,\\n        0x9d8542Ef1237933BadBe867291F6c0434b8D315C,\\n        0xF6775aD730637420C6D63FA948B564189D3a456d,\\n        0xdbBDbd48e2a66B95DC44b4376C06D147421EeD3E,\\n        0xBA01c17942F63fcb6f67513e5B0646b4dDf7C8c7,\\n        0xBd8437ca41B43BdAE92D1Fb68bd8B36225e78F62,\\n        0x5B9C3Ef22C4f8C5308552d6E595C04Ed4CBC7aa2,\\n        0xe2559f4B2f78e139cA3128b5F32D0b7D4D2Bd234,\\n        0xe83a546513CC1dC8F9D3d3dDAB898B54e6153cfE,\\n        0xa5c875A893b082edcbDF70a23b01cb10e4768865,\\n        0x96C0EB1D1c7E0fdF7ECebA3474f1E681A3BF854c,\\n        0xBA6a05ef46AeDD91960E7E4f7D7258fc35a9A15b,\\n        0x6A1C801Ec142596046B0327d50b1fa6DCFD368Bf,\\n        0x7044A182EB235A86713e05F25eE44531f838a9eB,\\n        0x9254b70b68f5b695dCdc62447dA0Aa2969f96a12,\\n        0x7eE1c07be8Bf6c16C1Cb3075aEa488309f48b12e,\\n        0x698Be66243d4431AF18C377b1DB82Fc09af85db6,\\n        0x352a956fec11a743f739cD5C30a54090DEec45f2,\\n        0xf16AB2D54E95CF9d8922a244C1c09107c3B96888,\\n        0x5669e294dCc7a0cEaE4BFBb00a68C1dbca2d45c0,\\n        0xDb65b48446DC4fc383D7E91fFa64c812A1b36a4E,\\n        0x2147C822EEe346c137c6903CCC5e32522310fAa3,\\n        0x50D724067402543a16162A51F545A5A596Cf2705,\\n        0x3372a12009195d912C0b8F0D275806777824f90F\\n        ];\\n\\n        return GEN_3_CONTRACTS;\\n    }\\n\\n    function getAvatarGen4Contracts() public pure returns (address[136] memory) {\\n        address[136] memory GEN_4_CONTRACTS = [\\n        0xf9B3dF29971FE3F930db52C9C47FFC0AEe8d4913,\\n        0x8ED11AE32aE005CC9F66d4cC3f01467D14bD8142,\\n        0x81759E5c953D9050cB48739fbbFeD99E740Bc5CC,\\n        0x0f9CC0F240d0E51faF6fa5277D80988fC91d62a6,\\n        0xECdE8eaf42A8c993c7d15545ff2125AEfb1764c0,\\n        0x5D31A466019Da42412072789DCDC7Dd60FF4ea6c,\\n        0x61aa617FFAf11A8da9255C59638F165e5ffbC823,\\n        0xC317dF945115d5e8e136c7E83a18f7eCEe4D26B7,\\n        0x8A469152E2C775668F5De8fae1B56B36fB97E0B8,\\n        0xeF77d5D816d48477ba7DAe61Cad9884e32CCc1fB,\\n        0x6C52020e476eb31C2E1EE3b59EaCfd1f4d643Da9,\\n        0xE901f71EF6ddc85a28F369B46d026241a8d46080,\\n        0xF77335cD36385022Df7A9192C8fA0dF0E9268bf9,\\n        0x49d97D6431bb8b67073ef7e0eb457af52D8394BA,\\n        0x9e8848C10Db66921810A63d9fC4a5A04459ad74a,\\n        0x13447Bfa0c11730EDe1C6FA02d42BfE6220Db7d5,\\n        0x6Bd01ea6F1f2d2a8F885A9f9f17eC5Cfe89A9e19,\\n        0xAec2D59Cc3cDd7d272163C1C41Ba1d68561006D8,\\n        0xfed0157409C984a58b2E0b950D3574709BA02EB7,\\n        0xE0281DD3Be8C48Fd61745C660D2E74Ff0B29892e,\\n        0xbc1916b49693a3D64330fA6d7A30cA628e4B8dCA,\\n        0xb1B4b38Ae1129f8275974f642E0F7E8C1f86E26c,\\n        0xA687660f9c9fcF7370210D358f1279088e851e58,\\n        0x4672448A48c561010F4aa7E327820C803D991625,\\n        0xb57DEb6d2Bc19cc78A756131eee87d16FB0bD21E,\\n        0x315738E9Ce1A4F39EB4ba881d7B50B24cD4b8519,\\n        0xa11a4582425F0dbE27B05Fb74123f36D46b857e8,\\n        0xF2A6f2B02Cee70F81B5B8FD8e695b12e0583ac7e,\\n        0xf6d634527c6454CecF242E43AEc59C50f8e79b73,\\n        0xdc203b920aBC823051E5D28EaCf565E9Cb59c769,\\n        0xB804Ca814e4C7722ADeF25e96Bd727432D66eFb1,\\n        0xE28f8EDe789985e07458a668b1c3270f8F0e0525,\\n        0x5b630a89cA2073E203a2117860E3a011Cb97731C,\\n        0x2eE6263359EAbB57CB2748E4F044005478499883,\\n        0x5F624882213Dd5bdC93216476ee0eBcE0fE20bdC,\\n        0xC94e1bE3AE0200BE6D55da9473b127F7C0D9beeB,\\n        0xCdd59c6791Ae4505375F06443ef72750C58235f9,\\n        0xEA0084a4971656630267E6e6981Df565172cA64B,\\n        0x0e9FdC46a211a875eb6a0a7dAb378d7D1860C466,\\n        0x07F5437Ff648A0554C4faE110aDE5adcCB6Bd36b,\\n        0x14227Ba7f8D09fda4e91D410B7b834A2855783E1,\\n        0xA58E0F0CC71a98690bF2158793cAbcc133f485f4,\\n        0xa4ecC9afB7fE29022aA586350832eE471392E71F,\\n        0x83D323489bb0C071d47d4Ba30faf4EeD30296623,\\n        0xb1e99FF98a9fa3E260bCa609e5aFdD6d0e2aC976,\\n        0xC58dBD531E3945Fd19d404B03Fa7c278a3bd6c5f,\\n        0x2128c27d9D5095CE730465636F0ADecD32FC886e,\\n        0x7e23b270502F555F0F0Be9a73de846A5D9692a29,\\n        0x0717D3C79ccB5EDC650344498f18076493B63989,\\n        0x1c576E0728f11F348292337FBa129D3f933312f8,\\n        0x19cb47f2251a54E1101a8095597F7B63Cb959bb3,\\n        0x0705Da3199fEf10dcaa3655Fc48751fD4dbcf057,\\n        0x72681818D657a28aE5e02a23b82373BB45E2998b,\\n        0xec974f5cC666752F81A9c8107212C45dD5cbD9B1,\\n        0xFcc6A9a8C25ece89cF222944B313fF140d26894F,\\n        0xc342405BB48E9a98fe574A9Ca19e03915c62Adb8,\\n        0x4b1E7dcdbb33F9e3008Fec99a440da6374854efc,\\n        0x797d776Ec236B4118fe34c41fD9d27541ad54D65,\\n        0x3e72cfC26e23d00130DA802a29fC7F421C5Bf847,\\n        0x064F977FFF4385Bb757702cCD62Bd576D24990df,\\n        0xA5118B39815650b52f6C1E191d0Cd06398A2b542,\\n        0xe1B6D0E8CE5b75d73A6FA5F05b6BD24Bfb1fAD7a,\\n        0x16fB660268Fbe681F4A5cef5DF86577C6213689A,\\n        0xbb1Da48e7229aE3775542577c2FfB688b622BD5C,\\n        0x6393E0b603A5A7C7101B25Fe7fe9772Bc916E614,\\n        0xFEB47Aad920b537F3f00913528ab13551BAB7C18,\\n        0x37a63D92Fd6e1e2ECBb71E9B606F1DF02bDFc3f3,\\n        0x9C71842Ad0d3DFD949F8EAf893517f58a24c8Cbc,\\n        0xe48CD867A1B7A330eca95f7b1381A86799F238f1,\\n        0xdE28135fe07F061Df1668E5fF8b3d874F7cd4fa7,\\n        0x0EB70F7b62Ae057C89F32d2ad92471645436eDA0,\\n        0x332457058168533fB2738BbcA58Fa2507e0eee8c,\\n        0x934a07F559D4e637158d2D01F62eEF97573f89eC,\\n        0xF5bC11CfAF45DA13415d3DC810B09B2CEfF8BCe4,\\n        0x8C80ad1979Fe5af75687576Bc428E3a16c09e947,\\n        0x1043C9eC3197d9bFDB2F9F872e7F69b249249e04,\\n        0x9A0033a4e986bDAe539d4F588FE5028F8B6fEC9D,\\n        0xc78C419382702A70B40FA6F7D67c845a19FA676e,\\n        0x6D5c332cB8BD3D601116e7a017EDf364ad239E78,\\n        0xa58D3152Ec0318A5bD53ab47385CD71eedEE5230,\\n        0xc82c481D47D446d21385d07A79d60619E7201b96,\\n        0xDd25E3BB8Ca0fB96d37f3a199DA434d98E33C36a,\\n        0x53c24125f68BD49bA79Afe95A4B23F5e419d89B9,\\n        0x2f3180730e1ebfD4761dC9F646443A1e693A5E86,\\n        0x9097F8594e4609Bb1487749a3dA9DffD479d4b13,\\n        0x7fa1a6A92AA12176Cb10e9D63DBD8BcB06De7563,\\n        0xF74586214e227f13ad990Ea46A506Bd2d50619B3,\\n        0x36F60A6F2EAdECbFD580C91174D2F7c081633137,\\n        0x79F6Bd4a2FeDc686E11d15756C477d5167B717D1,\\n        0x23d10918dc081665EbCe46dD135e6A19069D9c7e,\\n        0x4993047f73fCbbd9C9801f5757eB810724e1494a,\\n        0x1Ef6F9379AA228E08507F53E70c109979a35e512,\\n        0x71e2ee123cFFb75501CBEc943C0710B55f0e6750,\\n        0xD2c92b0d773EE0e9D4E2Ad4038f38feB66AdCD56,\\n        0x2d113F9820D17b193934DA6A664FaBa9B8D7F7A7,\\n        0xb998E8a4687ED17869dB6238432BdDE79197ad77,\\n        0x097A4A948806B760A8070C998839EB015E2EBbD1,\\n        0xbE3750E8a8CA69476B41751C8c13b14f308a76e5,\\n        0x33bc69E1df9c05350F27f806528787b2FBE74Fb5,\\n        0x13bEF354789314b2E70af1DcA78BF17bcC3D5334,\\n        0xf3f9d7878358023aAD1E130a7F403bFfd671a843,\\n        0x84B385fBb95dbf724351Cadd8a196D4C40758C29,\\n        0x3Cb7A1D4880e1d5479d3a708880cf4dD2BC7D2d0,\\n        0x9560f1DE72D40b05815Ea3FAB54297D83aC80cf6,\\n        0x5dE96Ca330A72E09435dB2452e80f4Cb1b714e8c,\\n        0xD2530f4296FbFfa508ac3C02E065d389c6F0447C,\\n        0xB1b2df907f774B4aD6C6385a19d86EF12f0D9163,\\n        0xf5CDEFf8AAe05ceC289Aa008d23233E83F10B71B,\\n        0x5bF284Ee3E1287AF74C2A68A5C36eaD1bE3Ae642,\\n        0x70869238783Dc6ABf94ebE0527CF964f40a39A0c,\\n        0xf14B813cFa39baf6321eD8bB110fCCf6FCBe4a50,\\n        0x46039626c743f0A7f8ea9E95366695FE82DFa997,\\n        0x0B0F05f544F6730aD06fEe8F40f4A774D662350b,\\n        0x0E79B9a6b12357e62E38812D0424f604546Fe88A,\\n        0x75Eb7B323328F750C9bDfaee22b49fE728B0209a,\\n        0xB15f2c10acccD1b72D7C2187131F4f2F8Ea370C5,\\n        0xd4B308Aa4b383136aFA69332cD169703Fad86496,\\n        0x2FE1c430a14128CA36B7B893A8098d7b5581739c,\\n        0x26295aD1a65465676c38ccb2aA29dbeBcE5a7923,\\n        0xE582C9cA50f5A7351d0ADdDAE0451ADF2774a9f1,\\n        0xc6801a4dd08035156fdb2557D938307F52B99138,\\n        0x5a7E0981eDE6134795cF4eC5665A1635a2477722,\\n        0x67dC90a90d3787670636B1Be8Cb19B3a508280cb,\\n        0x6Dc402c0a881F668eEf0728B0928c179BefaD3b3,\\n        0xB1D806F73387b0c958a3D066219e70b9833C99c4,\\n        0x8a3E73dDB3837E8f3c133f6dFCB142b90571bce5,\\n        0x2Da0157eEC166AB588Da5234149cFaACD1F828Da,\\n        0xFd760795De07685919132c134c5DC4C047C6cD3D,\\n        0x662Abf91256B03DE73D36C88eB4D3090b1e745C2,\\n        0xA481B99bE3581d90d47946e7000Eb426087f4d69,\\n        0x75fBddD1F61E8Ff0A02AEC580C10F612aaBBE5ff,\\n        0x2E30a06065c49a31fbF49118a7a9F4Df7EE47488,\\n        0xD400058Ec5658D6199F13B86376192657f84A0f9,\\n        0xe87c6634276C46Db809B825645CF040C51E888FE,\\n        0x7FcFf37f8dde57bbEb6A5D66608190a0962ccD0F,\\n        0xe7c5C26Aa8A9B8918E7EED14DC4E4241f6e471FA\\n        ];\\n\\n        return GEN_4_CONTRACTS;\\n    }\\n\\n    function isAvatarAwwDripMemeSingu(address targetAddress) external pure returns (bool) {\\n        address[4] memory contracts = getAwwDripMemeSinguContracts();\\n\\n        for (uint256 i = 0; i < contracts.length; i++) {\\n            if (contracts[i] == targetAddress) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function isAvatarGen1(address targetAddress) external pure returns (bool) {\\n        address[29] memory contracts = getAvatarGen1Contracts();\\n\\n        for (uint256 i = 0; i < contracts.length; i++) {\\n            if (contracts[i] == targetAddress) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function isAvatarGen2(address targetAddress) external pure returns (bool) {\\n        address[27] memory contracts = getAvatarGen2Contracts();\\n\\n        for (uint256 i = 0; i < contracts.length; i++) {\\n            if (contracts[i] == targetAddress) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function isAvatarGen3(address targetAddress) external pure returns (bool) {\\n        address[100] memory contracts = getAvatarGen3Contracts();\\n\\n        for (uint256 i = 0; i < contracts.length; i++) {\\n            if (contracts[i] == targetAddress) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function isAvatarGen4(address targetAddress) external pure returns (bool) {\\n        address[136] memory contracts = getAvatarGen4Contracts();\\n\\n        for (uint256 i = 0; i < contracts.length; i++) {\\n            if (contracts[i] == targetAddress) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function isAvatarRC2022(address targetAddress) external pure returns (bool) {\\n        return targetAddress == 0x622d8FeA4603BA9EdAF1084B407052D8b0A9bed7;\\n    }\\n\\n    function isAvatarSBLVII(address targetAddress) external pure returns (bool) {\\n        return targetAddress == 0x3b477A6B1bE236628B08839E1e8Cf8Ba8D93589a;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"libraries/AvatarContracts.sol\": {\r\n        \"AvatarContracts\": \"0xf2fc84c8229c810020b7199321ea65833ccc43e1\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousAdmin\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beacon\",\"type\":\"address\"}],\"name\":\"BeaconUpgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"AWW_DRIP_MEME_SINGU_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AWW_DRIP_MEME_SINGU_POOL_IDENTIFIER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_1_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_1_POOL_IDENTIFIER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_2_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_2_POOL_IDENTIFIER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_3_POOL_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GEN_3_POOL_IDENTIFIER\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RCAX_DEV_FUND_WALLET\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RCAX_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"poolIdentifer\",\"type\":\"string\"}],\"name\":\"getAllAvatarsInPool\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct RCAXAvatarSwap.AvatarToken[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"poolIdentifer\",\"type\":\"string\"}],\"name\":\"getAllAvatarsInPoolForOwner\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct RCAXAvatarSwap.AvatarToken[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getFreeDemoUsedStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"getLiquidityProviderStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getPoolFeeForToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"getPoolIdentifier\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxiableUUID\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setLiquidityProviderStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"}],\"name\":\"upgradeTo\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeToAndCall\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllAvatars\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RCAXAvatarSwap", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}