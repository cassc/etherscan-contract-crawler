{"SourceCode": "{\"Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\n/**\\r\\n * @dev Provides information about the current execution context, including the\\r\\n * sender of the transaction and its data. While these are generally available\\r\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\r\\n * manner, since when dealing with meta-transactions the account sending and\\r\\n * paying for execution may not be the actual sender (as far as an application\\r\\n * is concerned).\\r\\n *\\r\\n * This contract is only required for intermediate, library-like contracts.\\r\\n */\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\"},\"FarmBooster.sol\":{\"content\":\"/**\\r\\nplaxswap.io\\r\\n*/\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"./Ownable.sol\\\";\\r\\nimport \\\"./IBEP20.sol\\\";\\r\\nimport \\\"./ICakePool.sol\\\";\\r\\nimport \\\"./IMasterChefV2.sol\\\";\\r\\nimport \\\"./IterateMapping.sol\\\";\\r\\n\\r\\ncontract FarmBooster is Ownable {\\r\\n    using IterableMapping for ItMap;\\r\\n\\r\\n    /// @notice cake token.\\r\\n    address public immutable CAKE;\\r\\n    /// @notice cake pool.\\r\\n    address public immutable CAKE_POOL;\\r\\n    /// @notice MCV2 contract.\\r\\n    address public immutable MASTER_CHEF;\\r\\n    /// @notice boost proxy factory.\\r\\n    address public BOOSTER_FACTORY;\\r\\n\\r\\n    /// @notice Maximum allowed boosted pool numbers\\r\\n    uint256 public MAX_BOOST_POOL;\\r\\n    /// @notice limit max boost\\r\\n    uint256 public cA;\\r\\n    /// @notice include 1e4\\r\\n    uint256 public constant MIN_CA = 1e4;\\r\\n    /// @notice include 1e5\\r\\n    uint256 public constant MAX_CA = 1e5;\\r\\n    /// @notice cA precision\\r\\n    uint256 public constant CA_PRECISION = 1e5;\\r\\n    /// @notice controls difficulties\\r\\n    uint256 public cB;\\r\\n    /// @notice not include 0\\r\\n    uint256 public constant MIN_CB = 0;\\r\\n    /// @notice include 50\\r\\n    uint256 public constant MAX_CB = 50;\\r\\n    /// @notice MCV2 basic boost factor, none boosted user\\u0027s boost factor\\r\\n    uint256 public constant BOOST_PRECISION = 100 * 1e10;\\r\\n    /// @notice MCV2 Hard limit for maxmium boost factor\\r\\n    uint256 public constant MAX_BOOST_PRECISION = 200 * 1e10;\\r\\n    /// @notice Average boost ratio precion\\r\\n    uint256 public constant BOOST_RATIO_PRECISION = 1e5;\\r\\n    /// @notice Cake pool BOOST_WEIGHT precision\\r\\n    uint256 public constant BOOST_WEIGHT_PRECISION = 100 * 1e10; // 100%\\r\\n\\r\\n    /// @notice The whitelist of pools allowed for farm boosting.\\r\\n    mapping(uint256 =\\u003e bool) public whiteList;\\r\\n    /// @notice The boost proxy contract mapping(user =\\u003e proxy).\\r\\n    mapping(address =\\u003e address) public proxyContract;\\r\\n    /// @notice Info of each pool user.\\r\\n    mapping(address =\\u003e ItMap) public userInfo;\\r\\n\\r\\n    event UpdateMaxBoostPool(uint256 factory);\\r\\n    event UpdateBoostFactory(address factory);\\r\\n    event UpdateCA(uint256 oldCA, uint256 newCA);\\r\\n    event UpdateCB(uint256 oldCB, uint256 newCB);\\r\\n    event Refresh(address indexed user, address proxy, uint256 pid);\\r\\n    event UpdateBoostFarms(uint256 pid, bool status);\\r\\n    event ActiveFarmPool(address indexed user, address proxy, uint256 pid);\\r\\n    event DeactiveFarmPool(address indexed user, address proxy, uint256 pid);\\r\\n    event UpdateBoostProxy(address indexed user, address proxy);\\r\\n    event UpdatePoolBoostMultiplier(address indexed user, uint256 pid, uint256 oldMultiplier, uint256 newMultiplier);\\r\\n    event UpdateCakePool(\\r\\n        address indexed user,\\r\\n        uint256 lockedAmount,\\r\\n        uint256 lockedDuration,\\r\\n        uint256 totalLockedAmount,\\r\\n        uint256 maxLockDuration\\r\\n    );\\r\\n\\r\\n    /// @param _cake CAKE token contract address.\\r\\n    /// @param _cakePool Cake Pool contract address.\\r\\n    /// @param _v2 MasterChefV2 contract address.\\r\\n    /// @param _max Maximum allowed boosted farm  quantity\\r\\n    /// @param _cA Limit max boost\\r\\n    /// @param _cB Controls difficulties\\r\\n    constructor(\\r\\n        address _cake,\\r\\n        address _cakePool,\\r\\n        address _v2,\\r\\n        uint256 _max,\\r\\n        uint256 _cA,\\r\\n        uint256 _cB\\r\\n    ) {\\r\\n        require(\\r\\n            _max \\u003e 0 \\u0026\\u0026 _cA \\u003e= MIN_CA \\u0026\\u0026 _cA \\u003c= MAX_CA \\u0026\\u0026 _cB \\u003e MIN_CB \\u0026\\u0026 _cB \\u003c= MAX_CB,\\r\\n            \\\"constructor: Invalid parameter\\\"\\r\\n        );\\r\\n        CAKE = _cake;\\r\\n        CAKE_POOL = _cakePool;\\r\\n        MASTER_CHEF = _v2;\\r\\n        MAX_BOOST_POOL = _max;\\r\\n        cA = _cA;\\r\\n        cB = _cB;\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if the msg.sender is a contract or a proxy\\r\\n    modifier notContract() {\\r\\n        require(!_isContract(msg.sender), \\\"contract not allowed\\\");\\r\\n        require(msg.sender == tx.origin, \\\"proxy contract not allowed\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if the msg.sender is the FarmBooster Factory.\\r\\n    modifier onlyFactory() {\\r\\n        require(msg.sender == BOOSTER_FACTORY, \\\"onlyFactory: Not factory\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if the msg.sender is the FarmBooster Proxy.\\r\\n    modifier onlyProxy(address _user) {\\r\\n        require(msg.sender == proxyContract[_user], \\\"onlyProxy: Not proxy\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if the msg.sender is the cake pool.\\r\\n    modifier onlyCakePool() {\\r\\n        require(msg.sender == CAKE_POOL, \\\"onlyCakePool: Not cake pool\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @notice set maximum allowed boosted pool numbers.\\r\\n    function setMaxBoostPool(uint256 _max) external onlyOwner {\\r\\n        require(_max \\u003e 0, \\\"setMaxBoostPool: Maximum boost pool should greater than 0\\\");\\r\\n        MAX_BOOST_POOL = _max;\\r\\n        emit UpdateMaxBoostPool(_max);\\r\\n    }\\r\\n\\r\\n    /// @notice set boost factory contract.\\r\\n    function setBoostFactory(address _factory) external onlyOwner {\\r\\n        require(_factory != address(0), \\\"setBoostFactory: Invalid factory\\\");\\r\\n        BOOSTER_FACTORY = _factory;\\r\\n\\r\\n        emit UpdateBoostFactory(_factory);\\r\\n    }\\r\\n\\r\\n    /// @notice Set user boost proxy contract, can only invoked by boost contract.\\r\\n    /// @param _user boost user address.\\r\\n    /// @param _proxy boost proxy contract.\\r\\n    function setProxy(address _user, address _proxy) external onlyFactory {\\r\\n        require(_proxy != address(0), \\\"setProxy: Invalid proxy address\\\");\\r\\n        require(proxyContract[_user] == address(0), \\\"setProxy: User has already set proxy\\\");\\r\\n\\r\\n        proxyContract[_user] = _proxy;\\r\\n\\r\\n        emit UpdateBoostProxy(_user, _proxy);\\r\\n    }\\r\\n\\r\\n    /// @notice Only allow whitelisted pids for farm boosting\\r\\n    /// @param _pid pool id(MasterchefV2 pool).\\r\\n    /// @param _status farm pool allowed boosted or not\\r\\n    function setBoosterFarms(uint256 _pid, bool _status) external onlyOwner {\\r\\n        whiteList[_pid] = _status;\\r\\n        emit UpdateBoostFarms(_pid, _status);\\r\\n    }\\r\\n\\r\\n    /// @notice limit max boost\\r\\n    /// @param _cA max boost\\r\\n    function setCA(uint256 _cA) external onlyOwner {\\r\\n        require(_cA \\u003e= MIN_CA \\u0026\\u0026 _cA \\u003c= MAX_CA, \\\"setCA: Invalid cA\\\");\\r\\n        uint256 temp = cA;\\r\\n        cA = _cA;\\r\\n        emit UpdateCA(temp, cA);\\r\\n    }\\r\\n\\r\\n    /// @notice controls difficulties\\r\\n    /// @param _cB difficulties\\r\\n    function setCB(uint256 _cB) external onlyOwner {\\r\\n        require(_cB \\u003e MIN_CB \\u0026\\u0026 _cB \\u003c= MAX_CB, \\\"setCB: Invalid cB\\\");\\r\\n        uint256 temp = cB;\\r\\n        cB = _cB;\\r\\n        emit UpdateCB(temp, cB);\\r\\n    }\\r\\n\\r\\n    /// @notice Cakepool operation(deposit/withdraw) automatically call this function.\\r\\n    /// @param _user user address.\\r\\n    /// @param _lockedAmount user locked amount in cake pool.\\r\\n    /// @param _lockedDuration user locked duration in cake pool.\\r\\n    /// @param _totalLockedAmount Total locked cake amount in cake pool.\\r\\n    /// @param _maxLockDuration maximum locked duration in cake pool.\\r\\n    function onCakePoolUpdate(\\r\\n        address _user,\\r\\n        uint256 _lockedAmount,\\r\\n        uint256 _lockedDuration,\\r\\n        uint256 _totalLockedAmount,\\r\\n        uint256 _maxLockDuration\\r\\n    ) external onlyCakePool {\\r\\n        address proxy = proxyContract[_user];\\r\\n        ItMap storage itmap = userInfo[proxy];\\r\\n        uint256 avgDuration;\\r\\n        bool flag;\\r\\n        for (uint256 i = 0; i \\u003c itmap.keys.length; i++) {\\r\\n            uint256 pid = itmap.keys[i];\\r\\n            if (!flag) {\\r\\n                avgDuration = avgLockDuration();\\r\\n                flag = true;\\r\\n            }\\r\\n            _updateBoostMultiplier(_user, proxy, pid, avgDuration);\\r\\n        }\\r\\n\\r\\n        emit UpdateCakePool(_user, _lockedAmount, _lockedDuration, _totalLockedAmount, _maxLockDuration);\\r\\n    }\\r\\n\\r\\n    /// @notice Update user boost multiplier in V2 pool,only for proxy.\\r\\n    /// @param _user user address.\\r\\n    /// @param _pid pool id in MasterchefV2 pool.\\r\\n    function updatePoolBoostMultiplier(address _user, uint256 _pid) public onlyProxy(_user) {\\r\\n        // if user not actived this farm, just return.\\r\\n        if (!userInfo[msg.sender].contains(_pid)) return;\\r\\n        _updateBoostMultiplier(_user, msg.sender, _pid, avgLockDuration());\\r\\n    }\\r\\n\\r\\n    /// @notice Active user farm pool.\\r\\n    /// @param _pid pool id(MasterchefV2 pool).\\r\\n    function activate(uint256 _pid) external {\\r\\n        address proxy = proxyContract[msg.sender];\\r\\n        require(whiteList[_pid] \\u0026\\u0026 proxy != address(0), \\\"activate: Not boosted farm pool\\\");\\r\\n\\r\\n        ItMap storage itmap = userInfo[proxy];\\r\\n        require(itmap.keys.length \\u003c MAX_BOOST_POOL, \\\"activate: Boosted farms reach to MAX\\\");\\r\\n\\r\\n        _updateBoostMultiplier(msg.sender, proxy, _pid, avgLockDuration());\\r\\n\\r\\n        emit ActiveFarmPool(msg.sender, proxy, _pid);\\r\\n    }\\r\\n\\r\\n    /// @notice Deactive user farm pool.\\r\\n    /// @param _pid pool id(MasterchefV2 pool).\\r\\n    function deactive(uint256 _pid) external {\\r\\n        address proxy = proxyContract[msg.sender];\\r\\n        ItMap storage itmap = userInfo[proxy];\\r\\n        require(itmap.contains(_pid), \\\"deactive: None boost user\\\");\\r\\n\\r\\n        if (itmap.data[_pid] \\u003e BOOST_PRECISION) {\\r\\n            IMasterChefV2(MASTER_CHEF).updateBoostMultiplier(proxy, _pid, BOOST_PRECISION);\\r\\n        }\\r\\n        itmap.remove(_pid);\\r\\n\\r\\n        emit DeactiveFarmPool(msg.sender, proxy, _pid);\\r\\n    }\\r\\n\\r\\n    /// @notice Anyone can refesh sepecific user boost multiplier\\r\\n    /// @param _user user address.\\r\\n    /// @param _pid pool id(MasterchefV2 pool).\\r\\n    function refresh(address _user, uint256 _pid) external notContract {\\r\\n        address proxy = proxyContract[_user];\\r\\n        ItMap storage itmap = userInfo[proxy];\\r\\n        require(itmap.contains(_pid), \\\"refresh: None boost user\\\");\\r\\n\\r\\n        _updateBoostMultiplier(_user, proxy, _pid, avgLockDuration());\\r\\n\\r\\n        emit Refresh(_user, proxy, _pid);\\r\\n    }\\r\\n\\r\\n    /// @notice Whether user boosted specific farm pool.\\r\\n    /// @param _user user address.\\r\\n    /// @param _pid pool id(MasterchefV2 pool).\\r\\n    function isBoostedPool(address _user, uint256 _pid) external view returns (bool) {\\r\\n        return userInfo[proxyContract[_user]].contains(_pid);\\r\\n    }\\r\\n\\r\\n    /// @notice Actived farm pool list.\\r\\n    /// @param _user user address.\\r\\n    function activedPools(address _user) external view returns (uint256[] memory pools) {\\r\\n        ItMap storage itmap = userInfo[proxyContract[_user]];\\r\\n        if (itmap.keys.length == 0) return pools;\\r\\n\\r\\n        pools = new uint256[](itmap.keys.length);\\r\\n        // solidity for-loop not support multiple variables initializae by \\u0027,\\u0027 separate.\\r\\n        uint256 i;\\r\\n        for (uint256 index = 0; index \\u003c itmap.keys.length; index++) {\\r\\n            uint256 pid = itmap.keys[index];\\r\\n            pools[i] = pid;\\r\\n            i++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Anyone can call this function, if you find some guys effectived multiplier is not fair\\r\\n    /// for other users, just call \\u0027refresh\\u0027 function.\\r\\n    /// @param _user user address.\\r\\n    /// @param _pid pool id(MasterchefV2 pool).\\r\\n    /// @dev If return value not in range [BOOST_PRECISION, MAX_BOOST_PRECISION]\\r\\n    /// the actual effectived multiplier will be the close to side boundry value.\\r\\n    function getUserMultiplier(address _user, uint256 _pid) external view returns (uint256) {\\r\\n        return _boostCalculate(_user, proxyContract[_user], _pid, avgLockDuration());\\r\\n    }\\r\\n\\r\\n    /// @notice cake pool average locked duration calculator.\\r\\n    function avgLockDuration() public view returns (uint256) {\\r\\n        uint256 totalStakedAmount = IBEP20(CAKE).balanceOf(CAKE_POOL);\\r\\n\\r\\n        uint256 totalLockedAmount = ICakePool(CAKE_POOL).totalLockedAmount();\\r\\n\\r\\n        uint256 pricePerFullShare = ICakePool(CAKE_POOL).getPricePerFullShare();\\r\\n\\r\\n        uint256 flexibleShares = ((totalStakedAmount - totalLockedAmount) * 1e18) / pricePerFullShare;\\r\\n        if (flexibleShares == 0) return 0;\\r\\n\\r\\n        uint256 originalShares = (totalLockedAmount * 1e18) / pricePerFullShare;\\r\\n        if (originalShares == 0) return 0;\\r\\n\\r\\n        uint256 boostedRatio = ((ICakePool(CAKE_POOL).totalShares() - flexibleShares) * BOOST_RATIO_PRECISION) /\\r\\n            originalShares;\\r\\n        if (boostedRatio \\u003c= BOOST_RATIO_PRECISION) return 0;\\r\\n\\r\\n        uint256 boostWeight = ICakePool(CAKE_POOL).BOOST_WEIGHT();\\r\\n        uint256 maxLockDuration = ICakePool(CAKE_POOL).MAX_LOCK_DURATION() * BOOST_RATIO_PRECISION;\\r\\n\\r\\n        uint256 duration = ((boostedRatio - BOOST_RATIO_PRECISION) * 365 * BOOST_WEIGHT_PRECISION) / boostWeight;\\r\\n        return duration \\u003c= maxLockDuration ? duration : maxLockDuration;\\r\\n    }\\r\\n\\r\\n    /// @param _user user address.\\r\\n    /// @param _proxy proxy address corresponding to the user.\\r\\n    /// @param _pid pool id.\\r\\n    /// @param _duration cake pool average locked duration.\\r\\n    function _updateBoostMultiplier(\\r\\n        address _user,\\r\\n        address _proxy,\\r\\n        uint256 _pid,\\r\\n        uint256 _duration\\r\\n    ) internal {\\r\\n        ItMap storage itmap = userInfo[_proxy];\\r\\n\\r\\n        // Used to be boost farm pool and current is not, remove from mapping\\r\\n        if (!whiteList[_pid]) {\\r\\n            if (itmap.data[_pid] \\u003e BOOST_PRECISION) {\\r\\n                // reset to BOOST_PRECISION\\r\\n                IMasterChefV2(MASTER_CHEF).updateBoostMultiplier(_proxy, _pid, BOOST_PRECISION);\\r\\n            }\\r\\n            itmap.remove(_pid);\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        uint256 prevMultiplier = IMasterChefV2(MASTER_CHEF).getBoostMultiplier(_proxy, _pid);\\r\\n        uint256 multiplier = _boostCalculate(_user, _proxy, _pid, _duration);\\r\\n\\r\\n        if (multiplier \\u003c BOOST_PRECISION) {\\r\\n            multiplier = BOOST_PRECISION;\\r\\n        } else if (multiplier \\u003e MAX_BOOST_PRECISION) {\\r\\n            multiplier = MAX_BOOST_PRECISION;\\r\\n        }\\r\\n\\r\\n        // Update multiplier to MCV2\\r\\n        if (multiplier != prevMultiplier) {\\r\\n            IMasterChefV2(MASTER_CHEF).updateBoostMultiplier(_proxy, _pid, multiplier);\\r\\n        }\\r\\n        itmap.insert(_pid, multiplier);\\r\\n\\r\\n        emit UpdatePoolBoostMultiplier(_user, _pid, prevMultiplier, multiplier);\\r\\n    }\\r\\n\\r\\n    /// @param _user user address.\\r\\n    /// @param _proxy proxy address corresponding to the user.\\r\\n    /// @param _pid pool id(MasterchefV2 pool).\\r\\n    /// @param _duration cake pool average locked duration.\\r\\n    function _boostCalculate(\\r\\n        address _user,\\r\\n        address _proxy,\\r\\n        uint256 _pid,\\r\\n        uint256 _duration\\r\\n    ) internal view returns (uint256) {\\r\\n        if (_duration == 0) return BOOST_PRECISION;\\r\\n\\r\\n        (uint256 lpBalance, , ) = IMasterChefV2(MASTER_CHEF).userInfo(_pid, _proxy);\\r\\n        uint256 dB = (cA * lpBalance) / CA_PRECISION;\\r\\n        // dB == 0 means lpBalance close to 0\\r\\n        if (lpBalance == 0 || dB == 0) return BOOST_PRECISION;\\r\\n\\r\\n        (, , , , uint256 lockStartTime, uint256 lockEndTime, , , uint256 userLockedAmount) = ICakePool(CAKE_POOL)\\r\\n            .userInfo(_user);\\r\\n        if (userLockedAmount == 0 || block.timestamp \\u003e= lockEndTime) return BOOST_PRECISION;\\r\\n\\r\\n        // userLockedAmount \\u003e 0 means totalLockedAmount \\u003e 0\\r\\n        uint256 totalLockedAmount = ICakePool(CAKE_POOL).totalLockedAmount();\\r\\n\\r\\n        IBEP20 lp = IBEP20(IMasterChefV2(MASTER_CHEF).lpToken(_pid));\\r\\n        uint256 userLockedDuration = (lockEndTime - lockStartTime) / (3600 * 24); // days\\r\\n\\r\\n        uint256 aB = (((lp.balanceOf(MASTER_CHEF) * userLockedAmount * userLockedDuration) * BOOST_RATIO_PRECISION) /\\r\\n            cB) / (totalLockedAmount * _duration);\\r\\n\\r\\n        // should \\u0027*\\u0027 BOOST_PRECISION\\r\\n        return ((lpBalance \\u003c (dB + aB) ? lpBalance : (dB + aB)) * BOOST_PRECISION) / dB;\\r\\n    }\\r\\n\\r\\n    /// @notice Checks if address is a contract\\r\\n    /// @dev It prevents contract from being targetted\\r\\n    function _isContract(address addr) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(addr)\\r\\n        }\\r\\n        return size \\u003e 0;\\r\\n    }\\r\\n}\"},\"IBEP20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n\\r\\npragma solidity \\u003e=0.4.0;\\r\\n\\r\\ninterface IBEP20 {\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens in existence.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token decimals.\\r\\n   */\\r\\n  function decimals() external view returns (uint8);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token symbol.\\r\\n   */\\r\\n  function symbol() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token name.\\r\\n   */\\r\\n  function name() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the bep token owner.\\r\\n   */\\r\\n  function getOwner() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens owned by `account`.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from the caller\\u0027s account to `recipient`.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remaining number of tokens that `spender` will be\\r\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n   * zero by default.\\r\\n   *\\r\\n   * This value changes when {approve} or {transferFrom} are called.\\r\\n   */\\r\\n  function allowance(address _owner, address spender)\\r\\n    external\\r\\n    view\\r\\n    returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the caller\\u0027s tokens.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n   * that someone may use both the old and the new allowance by unfortunate\\r\\n   * transaction ordering. One possible solution to mitigate this race\\r\\n   * condition is to first reduce the spender\\u0027s allowance to 0 and set the\\r\\n   * desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n   * allowance mechanism. `amount` is then deducted from the caller\\u0027s\\r\\n   * allowance.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    uint256 amount\\r\\n  ) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n   * another (`to`).\\r\\n   *\\r\\n   * Note that `value` may be zero.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n   * a call to {approve}. `value` is the new allowance.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\"},\"ICakePool.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\ninterface ICakePool {\\r\\n    function userInfo(address _user)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256,\\r\\n            bool,\\r\\n            uint256\\r\\n        );\\r\\n\\r\\n    function getPricePerFullShare() external view returns (uint256);\\r\\n\\r\\n    function totalLockedAmount() external view returns (uint256);\\r\\n\\r\\n    function totalShares() external view returns (uint256);\\r\\n\\r\\n    function BOOST_WEIGHT() external view returns (uint256);\\r\\n\\r\\n    function MAX_LOCK_DURATION() external view returns (uint256);\\r\\n}\"},\"IMasterChefV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IMasterChefV2 {\\r\\n    function deposit(uint256 _pid, uint256 _amount) external;\\r\\n\\r\\n    function withdraw(uint256 _pid, uint256 _amount) external;\\r\\n\\r\\n    function pendingCake(uint256 _pid, address _user) external view returns (uint256);\\r\\n\\r\\n    function userInfo(uint256 _pid, address _user)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256,\\r\\n            uint256,\\r\\n            uint256\\r\\n        );\\r\\n\\r\\n    function emergencyWithdraw(uint256 _pid) external;\\r\\n\\r\\n    function lpToken(uint256 _pid) external view returns (address);\\r\\n\\r\\n    function poolLength() external view returns (uint256 pools);\\r\\n\\r\\n    function getBoostMultiplier(address _user, uint256 _pid) external view returns (uint256);\\r\\n\\r\\n    function updateBoostMultiplier(\\r\\n        address _user,\\r\\n        uint256 _pid,\\r\\n        uint256 _newMultiplier\\r\\n    ) external;\\r\\n}\"},\"IterateMapping.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nstruct ItMap {\\r\\n    // pid =\\u003e boost\\r\\n    mapping(uint256 =\\u003e uint256) data;\\r\\n    // pid =\\u003e index\\r\\n    mapping(uint256 =\\u003e uint256) indexs;\\r\\n    // array of pid\\r\\n    uint256[] keys;\\r\\n    // never use it, just for keep compile success.\\r\\n    uint256 size;\\r\\n}\\r\\n\\r\\nlibrary IterableMapping {\\r\\n    function insert(\\r\\n        ItMap storage self,\\r\\n        uint256 key,\\r\\n        uint256 value\\r\\n    ) internal {\\r\\n        uint256 keyIndex = self.indexs[key];\\r\\n        self.data[key] = value;\\r\\n        if (keyIndex \\u003e 0) return;\\r\\n        else {\\r\\n            self.indexs[key] = self.keys.length + 1;\\r\\n            self.keys.push(key);\\r\\n            return;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function remove(ItMap storage self, uint256 key) internal {\\r\\n        uint256 index = self.indexs[key];\\r\\n        if (index == 0) return;\\r\\n        uint256 lastKey = self.keys[self.keys.length - 1];\\r\\n        if (key != lastKey) {\\r\\n            self.keys[index - 1] = lastKey;\\r\\n            self.indexs[lastKey] = index;\\r\\n        }\\r\\n        delete self.data[key];\\r\\n        delete self.indexs[key];\\r\\n        self.keys.pop();\\r\\n    }\\r\\n\\r\\n    function contains(ItMap storage self, uint256 key) internal view returns (bool) {\\r\\n        return self.indexs[key] \\u003e 0;\\r\\n    }\\r\\n}\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\r\\n\\r\\npragma solidity ^0.8.0;\\r\\n\\r\\nimport \\\"./Context.sol\\\";\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\nabstract contract Ownable is Context {\\r\\n    address private _owner;\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /**\\r\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n     */\\r\\n    constructor() {\\r\\n        _transferOwnership(_msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the address of the current owner.\\r\\n     */\\r\\n    function owner() public view virtual returns (address) {\\r\\n        return _owner;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Throws if called by any account other than the owner.\\r\\n     */\\r\\n    modifier onlyOwner() {\\r\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Leaves the contract without owner. It will not be possible to call\\r\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\r\\n     *\\r\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\r\\n     * thereby removing any functionality that is only available to the owner.\\r\\n     */\\r\\n    function renounceOwnership() public virtual onlyOwner {\\r\\n        _transferOwnership(address(0));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Can only be called by the current owner.\\r\\n     */\\r\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\r\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n        _transferOwnership(newOwner);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n     * Internal function without access restriction.\\r\\n     */\\r\\n    function _transferOwnership(address newOwner) internal virtual {\\r\\n        address oldOwner = _owner;\\r\\n        _owner = newOwner;\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n}\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_cake\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cakePool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_v2\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cB\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"ActiveFarmPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"DeactiveFarmPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"}],\"name\":\"Refresh\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"}],\"name\":\"UpdateBoostFactory\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"UpdateBoostFarms\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"UpdateBoostProxy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCA\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCA\",\"type\":\"uint256\"}],\"name\":\"UpdateCA\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldCB\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCB\",\"type\":\"uint256\"}],\"name\":\"UpdateCB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lockedDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalLockedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxLockDuration\",\"type\":\"uint256\"}],\"name\":\"UpdateCakePool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"factory\",\"type\":\"uint256\"}],\"name\":\"UpdateMaxBoostPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldMultiplier\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMultiplier\",\"type\":\"uint256\"}],\"name\":\"UpdatePoolBoostMultiplier\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BOOSTER_FACTORY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_RATIO_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"BOOST_WEIGHT_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAKE\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CAKE_POOL\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CA_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MASTER_CHEF\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOOST_POOL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_BOOST_PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_CB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_CB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"activedPools\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"pools\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"avgLockDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cA\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cB\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"deactive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"getUserMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"isBoostedPool\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_lockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lockedDuration\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalLockedAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxLockDuration\",\"type\":\"uint256\"}],\"name\":\"onCakePoolUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxyContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"refresh\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"name\":\"setBoostFactory\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setBoosterFarms\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cA\",\"type\":\"uint256\"}],\"name\":\"setCA\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cB\",\"type\":\"uint256\"}],\"name\":\"setCB\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_max\",\"type\":\"uint256\"}],\"name\":\"setMaxBoostPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"}],\"name\":\"setProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePoolBoostMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"size\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"whiteList\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "FarmBooster", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "000000000000000000000000328801b0b580eadd83ea841638865ea41dc6fb25000000000000000000000000f508a363ae60213cdc360fa232bc781ed39daf7b00000000000000000000000040747e35d159829bb26e4651a75c779b557bd3050000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000c350000000000000000000000000000000000000000000000000000000000000000a", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bb0c9a2cce51d2798b4f4387cba020e95234c0de957aad49266fa3129780a4e7"}