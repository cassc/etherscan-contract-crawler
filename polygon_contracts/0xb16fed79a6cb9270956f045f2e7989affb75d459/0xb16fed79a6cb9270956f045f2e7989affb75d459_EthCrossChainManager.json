{"SourceCode": "pragma solidity ^0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\ncontract Context {\r\n    // Empty internal constructor, to prevent people from mistakenly deploying\r\n    // an instance of this contract, which should be used via inheritance.\r\n    constructor () internal { }\r\n    // solhint-disable-previous-line no-empty-blocks\r\n\r\n    function _msgSender() internal view returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view returns (bytes memory) {\r\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\r\n        return msg.data;\r\n    }\r\n}\r\n\r\ncontract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor () internal {\r\n        address msgSender = _msgSender();\r\n        _owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return _msgSender() == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public  onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by a pauser (`account`).\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by a pauser (`account`).\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor () internal {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!_paused, \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(_paused, \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called to pause, triggers stopped state.\r\n     */\r\n    function _pause() internal whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Called to unpause, returns to normal state.\r\n     */\r\n    function _unpause() internal whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\nlibrary ZeroCopySink {\r\n    /* @notice          Convert boolean value into bytes\r\n    *  @param b         The boolean value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteBool(bool b) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            mstore(buff, 1)\r\n            switch iszero(b)\r\n            case 1 {\r\n                mstore(add(buff, 0x20), shl(248, 0x00))\r\n                // mstore8(add(buff, 0x20), 0x00)\r\n            }\r\n            default {\r\n                mstore(add(buff, 0x20), shl(248, 0x01))\r\n                // mstore8(add(buff, 0x20), 0x01)\r\n            }\r\n            mstore(0x40, add(buff, 0x21))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert byte value into bytes\r\n    *  @param b         The byte value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteByte(byte b) internal pure returns (bytes memory) {\r\n        return WriteUint8(uint8(b));\r\n    }\r\n\r\n    /* @notice          Convert uint8 value into bytes\r\n    *  @param v         The uint8 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint8(uint8 v) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            mstore(buff, 1)\r\n            mstore(add(buff, 0x20), shl(248, v))\r\n            // mstore(add(buff, 0x20), byte(0x1f, v))\r\n            mstore(0x40, add(buff, 0x21))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint16 value into bytes\r\n    *  @param v         The uint16 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint16(uint16 v) internal pure returns (bytes memory) {\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x02\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x22))\r\n        }\r\n        return buff;\r\n    }\r\n    \r\n    /* @notice          Convert uint32 value into bytes\r\n    *  @param v         The uint32 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint32(uint32 v) internal pure returns(bytes memory) {\r\n        bytes memory buff;\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x04\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x24))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert uint64 value into bytes\r\n    *  @param v         The uint64 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint64(uint64 v) internal pure returns(bytes memory) {\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x08\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x28))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Convert limited uint256 value into bytes\r\n    *  @param v         The uint256 value\r\n    *  @return          Converted bytes array\r\n    */\r\n    function WriteUint255(uint256 v) internal pure returns (bytes memory) {\r\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds uint255 range\");\r\n        bytes memory buff;\r\n\r\n        assembly{\r\n            buff := mload(0x40)\r\n            let byteLen := 0x20\r\n            mstore(buff, byteLen)\r\n            for {\r\n                let mindex := 0x00\r\n                let vindex := 0x1f\r\n            } lt(mindex, byteLen) {\r\n                mindex := add(mindex, 0x01)\r\n                vindex := sub(vindex, 0x01)\r\n            }{\r\n                mstore8(add(add(buff, 0x20), mindex), byte(vindex, v))\r\n            }\r\n            mstore(0x40, add(buff, 0x40))\r\n        }\r\n        return buff;\r\n    }\r\n\r\n    /* @notice          Encode bytes format data into bytes\r\n    *  @param data      The bytes array data\r\n    *  @return          Encoded bytes array\r\n    */\r\n    function WriteVarBytes(bytes memory data) internal pure returns (bytes memory) {\r\n        uint64 l = uint64(data.length);\r\n        return abi.encodePacked(WriteVarUint(l), data);\r\n    }\r\n\r\n    function WriteVarUint(uint64 v) internal pure returns (bytes memory) {\r\n        if (v < 0xFD){\r\n    \t\treturn WriteUint8(uint8(v));\r\n    \t} else if (v <= 0xFFFF) {\r\n    \t\treturn abi.encodePacked(WriteByte(0xFD), WriteUint16(uint16(v)));\r\n    \t} else if (v <= 0xFFFFFFFF) {\r\n            return abi.encodePacked(WriteByte(0xFE), WriteUint32(uint32(v)));\r\n    \t} else {\r\n    \t\treturn abi.encodePacked(WriteByte(0xFF), WriteUint64(uint64(v)));\r\n    \t}\r\n    }\r\n}\r\n\r\nlibrary ZeroCopySource {\r\n    /* @notice              Read next byte as boolean type starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the boolean value\r\n    *  @return              The the read boolean value and new offset\r\n    */\r\n    function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"Offset exceeds limit\");\r\n        // byte === bytes1\r\n        byte v;\r\n        assembly{\r\n            v := mload(add(add(buff, 0x20), offset))\r\n        }\r\n        bool value;\r\n        if (v == 0x01) {\r\n\t\t    value = true;\r\n    \t} else if (v == 0x00) {\r\n            value = false;\r\n        } else {\r\n            revert(\"NextBool value error\");\r\n        }\r\n        return (value, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next byte starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the byte value\r\n    *  @return              The read byte value and new offset\r\n    */\r\n    function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextByte, Offset exceeds maximum\");\r\n        byte v;\r\n        assembly{\r\n            v := mload(add(add(buff, 0x20), offset))\r\n        }\r\n        return (v, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next byte as uint8 starting at offset from buff\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the byte value\r\n    *  @return              The read uint8 value and new offset\r\n    */\r\n    function NextUint8(bytes memory buff, uint256 offset) internal pure returns (uint8, uint256) {\r\n        require(offset + 1 <= buff.length && offset < offset + 1, \"NextUint8, Offset exceeds maximum\");\r\n        uint8 v;\r\n        assembly{\r\n            let tmpbytes := mload(0x40)\r\n            let bvalue := mload(add(add(buff, 0x20), offset))\r\n            mstore8(tmpbytes, byte(0, bvalue))\r\n            mstore(0x40, add(tmpbytes, 0x01))\r\n            v := mload(sub(tmpbytes, 0x1f))\r\n        }\r\n        return (v, offset + 1);\r\n    }\r\n\r\n    /* @notice              Read next two bytes as uint16 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint16 value\r\n    *  @return              The read uint16 value and updated offset\r\n    */\r\n    function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\r\n        require(offset + 2 <= buff.length && offset < offset + 2, \"NextUint16, offset exceeds maximum\");\r\n        \r\n        uint16 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let bvalue := mload(add(add(buff, 0x20), offset))\r\n            mstore8(tmpbytes, byte(0x01, bvalue))\r\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\r\n            mstore(0x40, add(tmpbytes, 0x02))\r\n            v := mload(sub(tmpbytes, 0x1e))\r\n        }\r\n        return (v, offset + 2);\r\n    }\r\n\r\n\r\n    /* @notice              Read next four bytes as uint32 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint32 value\r\n    *  @return              The read uint32 value and updated offset\r\n    */\r\n    function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\r\n        require(offset + 4 <= buff.length && offset < offset + 4, \"NextUint32, offset exceeds maximum\");\r\n        uint32 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x04\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\r\n        }\r\n        return (v, offset + 4);\r\n    }\r\n\r\n    /* @notice              Read next eight bytes as uint64 type starting from offset\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint64 value\r\n    *  @return              The read uint64 value and updated offset\r\n    */\r\n    function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\r\n        require(offset + 8 <= buff.length && offset < offset + 8, \"NextUint64, offset exceeds maximum\");\r\n        uint64 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x08\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\r\n        }\r\n        return (v, offset + 8);\r\n    }\r\n\r\n    /* @notice              Read next 32 bytes as uint256 type starting from offset,\r\n                            there are limits considering the numerical limits in multi-chain\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the uint256 value\r\n    *  @return              The read uint256 value and updated offset\r\n    */\r\n    function NextUint255(bytes memory buff, uint256 offset) internal pure returns (uint256, uint256) {\r\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextUint255, offset exceeds maximum\");\r\n        uint256 v;\r\n        assembly {\r\n            let tmpbytes := mload(0x40)\r\n            let byteLen := 0x20\r\n            for {\r\n                let tindex := 0x00\r\n                let bindex := sub(byteLen, 0x01)\r\n                let bvalue := mload(add(add(buff, 0x20), offset))\r\n            } lt(tindex, byteLen) {\r\n                tindex := add(tindex, 0x01)\r\n                bindex := sub(bindex, 0x01)\r\n            }{\r\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\r\n            }\r\n            mstore(0x40, add(tmpbytes, byteLen))\r\n            v := mload(tmpbytes)\r\n        }\r\n        require(v <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n        return (v, offset + 32);\r\n    }\r\n    /* @notice              Read next variable bytes starting from offset,\r\n                            the decoding rule coming from multi-chain\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read variable bytes array value and updated offset\r\n    */\r\n    function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\r\n        uint len;\r\n        (len, offset) = NextVarUint(buff, offset);\r\n        require(offset + len <= buff.length && offset < offset + len, \"NextVarBytes, offset exceeds maximum\");\r\n        bytes memory tempBytes;\r\n        assembly{\r\n            switch iszero(len)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(len, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, len)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, len)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return (tempBytes, offset + len);\r\n    }\r\n    /* @notice              Read next 32 bytes starting from offset,\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read bytes32 value and updated offset\r\n    */\r\n    function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\r\n        require(offset + 32 <= buff.length && offset < offset + 32, \"NextHash, offset exceeds maximum\");\r\n        bytes32 v;\r\n        assembly {\r\n            v := mload(add(buff, add(offset, 0x20)))\r\n        }\r\n        return (v, offset + 32);\r\n    }\r\n\r\n    /* @notice              Read next 20 bytes starting from offset,\r\n    *  @param buff          Source bytes array\r\n    *  @param offset        The position from where we read the bytes value\r\n    *  @return              The read bytes20 value and updated offset\r\n    */\r\n    function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\r\n        require(offset + 20 <= buff.length && offset < offset + 20, \"NextBytes20, offset exceeds maximum\");\r\n        bytes20 v;\r\n        assembly {\r\n            v := mload(add(buff, add(offset, 0x20)))\r\n        }\r\n        return (v, offset + 20);\r\n    }\r\n    \r\n    function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\r\n        byte v;\r\n        (v, offset) = NextByte(buff, offset);\r\n\r\n        uint value;\r\n        if (v == 0xFD) {\r\n            // return NextUint16(buff, offset);\r\n            (value, offset) = NextUint16(buff, offset);\r\n            require(value >= 0xFD && value <= 0xFFFF, \"NextUint16, value outside range\");\r\n            return (value, offset);\r\n        } else if (v == 0xFE) {\r\n            // return NextUint32(buff, offset);\r\n            (value, offset) = NextUint32(buff, offset);\r\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        } else if (v == 0xFF) {\r\n            // return NextUint64(buff, offset);\r\n            (value, offset) = NextUint64(buff, offset);\r\n            require(value > 0xFFFFFFFF, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        } else{\r\n            // return (uint8(v), offset);\r\n            value = uint8(v);\r\n            require(value < 0xFD, \"NextVarUint, value outside range\");\r\n            return (value, offset);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return sub(a, b, \"SafeMath: subtraction overflow\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity's `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b <= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity's `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return div(a, b, \"SafeMath: division by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b != 0, errorMessage);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return mod(a, b, \"SafeMath: modulo by zero\");\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts with custom message when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b != 0, errorMessage);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\nlibrary Utils {\r\n\r\n    /* @notice      Convert the bytes array to bytes32 type, the bytes array length must be 32\r\n    *  @param _bs   Source bytes array\r\n    *  @return      bytes32\r\n    */\r\n    function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\r\n        require(_bs.length == 32, \"bytes length is not 32.\");\r\n        assembly {\r\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\r\n            value := mload(add(_bs, 0x20))\r\n        }\r\n    }\r\n\r\n    /* @notice      Convert bytes to uint256\r\n    *  @param _b    Source bytes should have length of 32\r\n    *  @return      uint256\r\n    */\r\n    function bytesToUint256(bytes memory _bs) internal pure returns (uint256 value) {\r\n        require(_bs.length == 32, \"bytes length is not 32.\");\r\n        assembly {\r\n            // load 32 bytes from memory starting from position _bs + 32\r\n            value := mload(add(_bs, 0x20))\r\n        }\r\n        require(value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n    }\r\n\r\n    /* @notice      Convert uint256 to bytes\r\n    *  @param _b    uint256 that needs to be converted\r\n    *  @return      bytes\r\n    */\r\n    function uint256ToBytes(uint256 _value) internal pure returns (bytes memory bs) {\r\n        require(_value <= 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff, \"Value exceeds the range\");\r\n        assembly {\r\n            // Get a location of some free memory and store it in result as\r\n            // Solidity does for memory variables.\r\n            bs := mload(0x40)\r\n            // Put 0x20 at the first word, the length of bytes for uint256 value\r\n            mstore(bs, 0x20)\r\n            //In the next word, put value in bytes format to the next 32 bytes\r\n            mstore(add(bs, 0x20), _value)\r\n            // Update the free-memory pointer by padding our last write location to 32 bytes\r\n            mstore(0x40, add(bs, 0x40))\r\n        }\r\n    }\r\n\r\n    /* @notice      Convert bytes to address\r\n    *  @param _bs   Source bytes: bytes length must be 20\r\n    *  @return      Converted address from source bytes\r\n    */\r\n    function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\r\n    {\r\n        require(_bs.length == 20, \"bytes length does not match address\");\r\n        assembly {\r\n            // for _bs, first word store _bs.length, second word store _bs.value\r\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\r\n            addr := mload(add(_bs, 0x14))\r\n        }\r\n\r\n    }\r\n    \r\n    /* @notice      Convert address to bytes\r\n    *  @param _addr Address need to be converted\r\n    *  @return      Converted bytes from address\r\n    */\r\n    function addressToBytes(address _addr) internal pure returns (bytes memory bs){\r\n        assembly {\r\n            // Get a location of some free memory and store it in result as\r\n            // Solidity does for memory variables.\r\n            bs := mload(0x40)\r\n            // Put 20 (address byte length) at the first word, the length of bytes for uint256 value\r\n            mstore(bs, 0x14)\r\n            // logical shift left _a by 12 bytes, change _a from right-aligned to left-aligned\r\n            mstore(add(bs, 0x20), shl(96, _addr))\r\n            // Update the free-memory pointer by padding our last write location to 32 bytes\r\n            mstore(0x40, add(bs, 0x40))\r\n       }\r\n    }\r\n\r\n    /* @notice          Do hash leaf as the multi-chain does\r\n    *  @param _data     Data in bytes format\r\n    *  @return          Hashed value in bytes32 format\r\n    */\r\n    function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\r\n        result = sha256(abi.encodePacked(byte(0x0), _data));\r\n    }\r\n\r\n    /* @notice          Do hash children as the multi-chain does\r\n    *  @param _l        Left node\r\n    *  @param _r        Right node\r\n    *  @return          Hashed value in bytes32 format\r\n    */\r\n    function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\r\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\r\n    }\r\n\r\n    /* @notice              Compare if two bytes are equal, which are in storage and memory, seperately\r\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L368\r\n    *  @param _preBytes     The bytes stored in storage\r\n    *  @param _postBytes    The bytes stored in memory\r\n    *  @return              Bool type indicating if they are equal\r\n    */\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // fslot can contain both the length and contents of the array\r\n                // if slength < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                // slength != 0\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    /* @notice              Slice the _bytes from _start index till the result has length of _length\r\n                            Refer from https://github.com/summa-tx/bitcoin-spv/blob/master/solidity/contracts/BytesLib.sol#L246\r\n    *  @param _bytes        The original bytes needs to be sliced\r\n    *  @param _start        The index of _bytes for the start of sliced bytes\r\n    *  @param _length       The index of _bytes for the end of sliced bytes\r\n    *  @return              The sliced bytes\r\n    */\r\n    function slice(\r\n        bytes memory _bytes,\r\n        uint _start,\r\n        uint _length\r\n    )\r\n        internal\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                // lengthmod <= _length % 32\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n    /* @notice              Check if the elements number of _signers within _keepers array is no less than _m\r\n    *  @param _keepers      The array consists of serveral address\r\n    *  @param _signers      Some specific addresses to be looked into\r\n    *  @param _m            The number requirement paramter\r\n    *  @return              True means containment, false meansdo do not contain.\r\n    */\r\n    function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\r\n        uint m = 0;\r\n        for(uint i = 0; i < _signers.length; i++){\r\n            for (uint j = 0; j < _keepers.length; j++) {\r\n                if (_signers[i] == _keepers[j]) {\r\n                    m++;\r\n                    delete _keepers[j];\r\n                }\r\n            }\r\n        }\r\n        return m >= _m;\r\n    }\r\n\r\n    /* @notice              TODO\r\n    *  @param key\r\n    *  @return\r\n    */\r\n    function compressMCPubKey(bytes memory key) internal pure returns (bytes memory newkey) {\r\n         require(key.length >= 67, \"key lenggh is too short\");\r\n         newkey = slice(key, 0, 35);\r\n         if (uint8(key[66]) % 2 == 0){\r\n             newkey[2] = byte(0x02);\r\n         } else {\r\n             newkey[2] = byte(0x03);\r\n         }\r\n         return newkey;\r\n    }\r\n    \r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *      Refer from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Address.sol#L18\r\n     *\r\n     * This test is non-exhaustive, and there may be false-negatives: during the\r\n     * execution of a contract's constructor, its address will be reported as\r\n     * not containing a contract.\r\n     *\r\n     * IMPORTANT: It is unsafe to assume that an address for which this\r\n     * function returns false is an externally-owned account (EOA) and not a\r\n     * contract.\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies in extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != 0x0 && codehash != accountHash);\r\n    }\r\n}\r\n\r\nlibrary ECCUtils {\r\n    using SafeMath for uint256;\r\n    \r\n    struct Header {\r\n        uint32 version;\r\n        uint64 chainId;\r\n        uint32 timestamp;\r\n        uint32 height;\r\n        uint64 consensusData;\r\n        bytes32 prevBlockHash;\r\n        bytes32 transactionsRoot;\r\n        bytes32 crossStatesRoot;\r\n        bytes32 blockRoot;\r\n        bytes consensusPayload;\r\n        bytes20 nextBookkeeper;\r\n    }\r\n\r\n    struct ToMerkleValue {\r\n        bytes  txHash;  // cross chain txhash\r\n        uint64 fromChainID;\r\n        TxParam makeTxParam;\r\n    }\r\n\r\n    struct TxParam {\r\n        bytes txHash; //  source chain txhash\r\n        bytes crossChainId;\r\n        bytes fromContract;\r\n        uint64 toChainId;\r\n        bytes toContract;\r\n        bytes method;\r\n        bytes args;\r\n    }\r\n\r\n    uint constant POLYCHAIN_PUBKEY_LEN = 67;\r\n    uint constant POLYCHAIN_SIGNATURE_LEN = 65;\r\n\r\n    /* @notice                  Verify Poly chain transaction whether exist or not\r\n    *  @param _auditPath        Poly chain merkle proof\r\n    *  @param _root             Poly chain root\r\n    *  @return                  The verified value included in _auditPath\r\n    */\r\n    function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\r\n        uint256 off = 0;\r\n        bytes memory value;\r\n        (value, off)  = ZeroCopySource.NextVarBytes(_auditPath, off);\r\n\r\n        bytes32 hash = Utils.hashLeaf(value);\r\n        uint size = _auditPath.length.sub(off).div(33);\r\n        bytes32 nodeHash;\r\n        byte pos;\r\n        for (uint i = 0; i < size; i++) {\r\n            (pos, off) = ZeroCopySource.NextByte(_auditPath, off);\r\n            (nodeHash, off) = ZeroCopySource.NextHash(_auditPath, off);\r\n            if (pos == 0x00) {\r\n                hash = Utils.hashChildren(nodeHash, hash);\r\n            } else if (pos == 0x01) {\r\n                hash = Utils.hashChildren(hash, nodeHash);\r\n            } else {\r\n                revert(\"merkleProve, NextByte for position info failed\");\r\n            }\r\n        }\r\n        require(hash == _root, \"merkleProve, expect root is not equal actual root\");\r\n        return value;\r\n    }\r\n\r\n    /* @notice              calculate next book keeper according to public key list\r\n    *  @param _keyLen       consensus node number\r\n    *  @param _m            minimum signature number\r\n    *  @param _pubKeyList   consensus node public key list\r\n    *  @return              two element: next book keeper, consensus node signer addresses\r\n    */\r\n    function _getBookKeeper(uint _keyLen, uint _m, bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory){\r\n         bytes memory buff;\r\n         buff = ZeroCopySink.WriteUint16(uint16(_keyLen));\r\n         address[] memory keepers = new address[](_keyLen);\r\n         bytes32 hash;\r\n         bytes memory publicKey;\r\n         for(uint i = 0; i < _keyLen; i++){\r\n             publicKey = Utils.slice(_pubKeyList, i*POLYCHAIN_PUBKEY_LEN, POLYCHAIN_PUBKEY_LEN);\r\n             buff =  abi.encodePacked(buff, ZeroCopySink.WriteVarBytes(Utils.compressMCPubKey(publicKey)));\r\n             hash = keccak256(Utils.slice(publicKey, 3, 64));\r\n             keepers[i] = address(uint160(uint256(hash)));\r\n         }\r\n\r\n         buff = abi.encodePacked(buff, ZeroCopySink.WriteUint16(uint16(_m)));\r\n         bytes20  nextBookKeeper = ripemd160(abi.encodePacked(sha256(buff)));\r\n         return (nextBookKeeper, keepers);\r\n    }\r\n\r\n    /* @notice              Verify public key derived from Poly chain\r\n    *  @param _pubKeyList   serialized consensus node public key list\r\n    *  @param _sigList      consensus node signature list\r\n    *  @return              return two element: next book keeper, consensus node signer addresses\r\n    */\r\n    function verifyPubkey(bytes memory _pubKeyList) internal pure returns (bytes20, address[] memory) {\r\n        require(_pubKeyList.length % POLYCHAIN_PUBKEY_LEN == 0, \"_pubKeyList length illegal!\");\r\n        uint n = _pubKeyList.length / POLYCHAIN_PUBKEY_LEN;\r\n        require(n >= 1, \"too short _pubKeyList!\");\r\n        return _getBookKeeper(n, n - (n - 1) / 3, _pubKeyList);\r\n    }\r\n\r\n    /* @notice              Verify Poly chain consensus node signature\r\n    *  @param _rawHeader    Poly chain block header raw bytes\r\n    *  @param _sigList      consensus node signature list\r\n    *  @param _keepers      addresses corresponding with Poly chain book keepers' public keys\r\n    *  @param _m            minimum signature number\r\n    *  @return              true or false\r\n    */\r\n    function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\r\n        bytes32 hash = getHeaderHash(_rawHeader);\r\n\r\n        uint sigCount = _sigList.length.div(POLYCHAIN_SIGNATURE_LEN);\r\n        address[] memory signers = new address[](sigCount);\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        for(uint j = 0; j  < sigCount; j++){\r\n            r = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN, 32));\r\n            s =  Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN + 32, 32));\r\n            v =  uint8(_sigList[j*POLYCHAIN_SIGNATURE_LEN + 64]) + 27;\r\n            signers[j] =  ecrecover(sha256(abi.encodePacked(hash)), v, r, s);\r\n            if (signers[j] == address(0)) return false;\r\n        }\r\n        return Utils.containMAddresses(_keepers, signers, _m);\r\n    }\r\n    \r\n\r\n    /* @notice               Serialize Poly chain book keepers' info in Ethereum addresses format into raw bytes\r\n    *  @param keepersBytes   The serialized addresses\r\n    *  @return               serialized bytes result\r\n    */\r\n    function serializeKeepers(address[] memory keepers) internal pure returns (bytes memory) {\r\n        uint256 keeperLen = keepers.length;\r\n        bytes memory keepersBytes = ZeroCopySink.WriteUint64(uint64(keeperLen));\r\n        for(uint i = 0; i < keeperLen; i++) {\r\n            keepersBytes = abi.encodePacked(keepersBytes, ZeroCopySink.WriteVarBytes(Utils.addressToBytes(keepers[i])));\r\n        }\r\n        return keepersBytes;\r\n    }\r\n\r\n    /* @notice               Deserialize bytes into Ethereum addresses\r\n    *  @param keepersBytes   The serialized addresses derived from Poly chain book keepers in bytes format\r\n    *  @return               addresses\r\n    */\r\n    function deserializeKeepers(bytes memory keepersBytes) internal pure returns (address[] memory) {\r\n        uint256 off = 0;\r\n        uint64 keeperLen;\r\n        (keeperLen, off) = ZeroCopySource.NextUint64(keepersBytes, off);\r\n        address[] memory keepers = new address[](keeperLen);\r\n        bytes memory keeperBytes;\r\n        for(uint i = 0; i < keeperLen; i++) {\r\n            (keeperBytes, off) = ZeroCopySource.NextVarBytes(keepersBytes, off);\r\n            keepers[i] = Utils.bytesToAddress(keeperBytes);\r\n        }\r\n        return keepers;\r\n    }\r\n\r\n    /* @notice               Deserialize Poly chain transaction raw value\r\n    *  @param _valueBs       Poly chain transaction raw bytes\r\n    *  @return               ToMerkleValue struct\r\n    */\r\n    function deserializeMerkleValue(bytes memory _valueBs) internal pure returns (ToMerkleValue memory) {\r\n        ToMerkleValue memory toMerkleValue;\r\n        uint256 off = 0;\r\n\r\n        (toMerkleValue.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\r\n\r\n        (toMerkleValue.fromChainID, off) = ZeroCopySource.NextUint64(_valueBs, off);\r\n\r\n        TxParam memory txParam;\r\n\r\n        (txParam.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\r\n        \r\n        (txParam.crossChainId, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\r\n\r\n        (txParam.fromContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\r\n\r\n        (txParam.toChainId, off) = ZeroCopySource.NextUint64(_valueBs, off);\r\n\r\n        (txParam.toContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\r\n\r\n        (txParam.method, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\r\n\r\n        (txParam.args, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\r\n        toMerkleValue.makeTxParam = txParam;\r\n\r\n        return toMerkleValue;\r\n    }\r\n\r\n    /* @notice            Deserialize Poly chain block header raw bytes\r\n    *  @param _valueBs    Poly chain block header raw bytes\r\n    *  @return            Header struct\r\n    */\r\n    function deserializeHeader(bytes memory _headerBs) internal pure returns (Header memory) {\r\n        Header memory header;\r\n        uint256 off = 0;\r\n        (header.version, off)  = ZeroCopySource.NextUint32(_headerBs, off);\r\n\r\n        (header.chainId, off) = ZeroCopySource.NextUint64(_headerBs, off);\r\n\r\n        (header.prevBlockHash, off) = ZeroCopySource.NextHash(_headerBs, off);\r\n\r\n        (header.transactionsRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\r\n\r\n        (header.crossStatesRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\r\n\r\n        (header.blockRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\r\n\r\n        (header.timestamp, off) = ZeroCopySource.NextUint32(_headerBs, off);\r\n\r\n        (header.height, off) = ZeroCopySource.NextUint32(_headerBs, off);\r\n\r\n        (header.consensusData, off) = ZeroCopySource.NextUint64(_headerBs, off);\r\n\r\n        (header.consensusPayload, off) = ZeroCopySource.NextVarBytes(_headerBs, off);\r\n\r\n        (header.nextBookkeeper, off) = ZeroCopySource.NextBytes20(_headerBs, off);\r\n\r\n        return header;\r\n    }\r\n\r\n    /* @notice            Deserialize Poly chain block header raw bytes\r\n    *  @param rawHeader   Poly chain block header raw bytes\r\n    *  @return            header hash same as Poly chain\r\n    */\r\n    function getHeaderHash(bytes memory rawHeader) internal pure returns (bytes32) {\r\n        return sha256(abi.encodePacked(sha256(rawHeader)));\r\n    }\r\n}\r\n\r\ninterface IEthCrossChainData {\r\n    function putCurEpochStartHeight(uint32 curEpochStartHeight) external returns (bool);\r\n    function getCurEpochStartHeight() external view returns (uint32);\r\n    function putCurEpochConPubKeyBytes(bytes calldata curEpochPkBytes) external returns (bool);\r\n    function getCurEpochConPubKeyBytes() external view returns (bytes memory);\r\n    function markFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) external returns (bool);\r\n    function checkIfFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) external view returns (bool);\r\n    function getEthTxHashIndex() external view returns (uint256);\r\n    function putEthTxHash(bytes32 ethTxHash) external returns (bool);\r\n    function putExtraData(bytes32 key1, bytes32 key2, bytes calldata value) external returns (bool);\r\n    function getExtraData(bytes32 key1, bytes32 key2) external view returns (bytes memory);\r\n    function transferOwnership(address newOwner) external;\r\n    function pause() external returns (bool);\r\n    function unpause() external returns (bool);\r\n    function paused() external view returns (bool);\r\n    // Not used currently by ECCM\r\n    function getEthTxHash(uint256 ethTxHashIndex) external view returns (bytes32);\r\n}\r\n\r\ninterface IUpgradableECCM {\r\n    function pause() external returns (bool);\r\n    function unpause() external returns (bool);\r\n    function paused() external view returns (bool);\r\n    function upgradeToNew(address) external returns (bool);\r\n    function isOwner() external view returns (bool);\r\n    function setChainId(uint64 _newChainId) external returns (bool);\r\n}\r\n\r\n\r\ninterface IEthCrossChainManager {\r\n    function crossChain(uint64 _toChainId, bytes calldata _toContract, bytes calldata _method, bytes calldata _txData) external returns (bool);\r\n}\r\n\r\ncontract UpgradableECCM is IUpgradableECCM, Ownable, Pausable {\r\n    address public EthCrossChainDataAddress;\r\n    uint64 public chainId;  \r\n    \r\n    constructor (address ethCrossChainDataAddr, uint64 _chainId) Pausable() Ownable()  public {\r\n        EthCrossChainDataAddress = ethCrossChainDataAddr;\r\n        chainId = _chainId;\r\n    }\r\n    function pause() onlyOwner public returns (bool) {\r\n        if (!paused()) {\r\n            _pause();\r\n        }\r\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\r\n        if (!eccd.paused()) {\r\n            require(eccd.pause(), \"pause EthCrossChainData contract failed\");\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function unpause() onlyOwner public returns (bool) {\r\n        if (paused()) {\r\n            _unpause();\r\n        }\r\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\r\n        if (eccd.paused()) {\r\n            require(eccd.unpause(), \"unpause EthCrossChainData contract failed\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    // if we want to upgrade this contract, we need to invoke this method \r\n    function upgradeToNew(address newEthCrossChainManagerAddress) whenPaused onlyOwner public returns (bool) {\r\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\r\n        eccd.transferOwnership(newEthCrossChainManagerAddress);\r\n        return true;\r\n    }\r\n    \r\n    function setChainId(uint64 _newChainId) whenPaused onlyOwner public returns (bool) {\r\n        chainId = _newChainId;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract EthCrossChainManager is IEthCrossChainManager, UpgradableECCM {\r\n    using SafeMath for uint256;\r\n    \r\n    address public whiteLister;\r\n    mapping(address => bool) public whiteListFromContract;\r\n    mapping(address => mapping(bytes => bool)) public whiteListContractMethodMap;\r\n\r\n    event InitGenesisBlockEvent(uint256 height, bytes rawHeader);\r\n    event ChangeBookKeeperEvent(uint256 height, bytes rawHeader);\r\n    event CrossChainEvent(address indexed sender, bytes txId, address proxyOrAssetContract, uint64 toChainId, bytes toContract, bytes rawdata);\r\n    event VerifyHeaderAndExecuteTxEvent(uint64 fromChainID, bytes toContract, bytes crossChainTxHash, bytes fromChainTxHash);\r\n    constructor(\r\n        address _eccd, \r\n        uint64 _chainId, \r\n        address[] memory fromContractWhiteList, \r\n        bytes[] memory contractMethodWhiteList\r\n    ) UpgradableECCM(_eccd,_chainId) public {\r\n        whiteLister = msg.sender;\r\n        for (uint i=0;i<fromContractWhiteList.length;i++) {\r\n            whiteListFromContract[fromContractWhiteList[i]] = true;\r\n        }\r\n        for (uint i=0;i<contractMethodWhiteList.length;i++) {\r\n            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));\r\n            for (uint j=0;j<methods.length;j++) {\r\n                whiteListContractMethodMap[toContract][methods[j]] = true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    modifier onlyWhiteLister() {\r\n        require(msg.sender == whiteLister, \"Not whiteLister\");\r\n        _;\r\n    }\r\n\r\n    function setWhiteLister(address newWL) public onlyWhiteLister {\r\n        require(newWL!=address(0), \"Can not transfer to address(0)\");\r\n        whiteLister = newWL;\r\n    }\r\n    \r\n    function setFromContractWhiteList(address[] memory fromContractWhiteList) public onlyWhiteLister {\r\n        for (uint i=0;i<fromContractWhiteList.length;i++) {\r\n            whiteListFromContract[fromContractWhiteList[i]] = true;\r\n        }\r\n    }\r\n    \r\n    function removeFromContractWhiteList(address[] memory fromContractWhiteList) public onlyWhiteLister {\r\n        for (uint i=0;i<fromContractWhiteList.length;i++) {\r\n            whiteListFromContract[fromContractWhiteList[i]] = false;\r\n        }\r\n    }\r\n    \r\n    function setContractMethodWhiteList(bytes[] memory contractMethodWhiteList) public onlyWhiteLister {\r\n        for (uint i=0;i<contractMethodWhiteList.length;i++) {\r\n            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));\r\n            for (uint j=0;j<methods.length;j++) {\r\n                whiteListContractMethodMap[toContract][methods[j]] = true;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function removeContractMethodWhiteList(bytes[] memory contractMethodWhiteList) public onlyWhiteLister {\r\n        for (uint i=0;i<contractMethodWhiteList.length;i++) {\r\n            (address toContract,bytes[] memory methods) = abi.decode(contractMethodWhiteList[i],(address,bytes[]));\r\n            for (uint j=0;j<methods.length;j++) {\r\n                whiteListContractMethodMap[toContract][methods[j]] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /* @notice              sync Poly chain genesis block header to smart contrat\r\n    *  @dev                 this function can only be called once, nextbookkeeper of rawHeader can't be empty\r\n    *  @param rawHeader     Poly chain genesis block raw header or raw Header including switching consensus peers info\r\n    *  @return              true or false\r\n    */\r\n    function initGenesisBlock(bytes memory rawHeader, bytes memory pubKeyList) whenNotPaused public returns(bool) {\r\n        // Load Ethereum cross chain data contract\r\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\r\n        \r\n        // Make sure the contract has not been initialized before\r\n        require(eccd.getCurEpochConPubKeyBytes().length == 0, \"EthCrossChainData contract has already been initialized!\");\r\n        \r\n        // Parse header and convit the public keys into nextBookKeeper and compare it with header.nextBookKeeper to verify the validity of signature\r\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\r\n        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);\r\n        require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\r\n        \r\n        // Record current epoch start height and public keys (by storing them in address format)\r\n        require(eccd.putCurEpochStartHeight(header.height), \"Save Poly chain current epoch start height to Data contract failed!\");\r\n        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain current epoch book keepers to Data contract failed!\");\r\n        \r\n        // Fire the event\r\n        emit InitGenesisBlockEvent(header.height, rawHeader);\r\n        return true;\r\n    }\r\n    \r\n    /* @notice              change Poly chain consensus book keeper\r\n    *  @param rawHeader     Poly chain change book keeper block raw header\r\n    *  @param pubKeyList    Poly chain consensus nodes public key list\r\n    *  @param sigList       Poly chain consensus nodes signature list\r\n    *  @return              true or false\r\n    */\r\n    function changeBookKeeper(bytes memory rawHeader, bytes memory pubKeyList, bytes memory sigList) whenNotPaused public returns(bool) {\r\n        // Load Ethereum cross chain data contract\r\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\r\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\r\n        \r\n        // Make sure rawHeader.height is higher than recorded current epoch start height\r\n        uint64 curEpochStartHeight = eccd.getCurEpochStartHeight();\r\n        require(header.height > curEpochStartHeight, \"The height of header is lower than current epoch start height!\");\r\n        \r\n        // Ensure the rawHeader is the key header including info of switching consensus peers by containing non-empty nextBookKeeper field\r\n        require(header.nextBookkeeper != bytes20(0), \"The nextBookKeeper of header is empty\");\r\n        \r\n        // Verify signature of rawHeader comes from pubKeyList\r\n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\r\n        uint n = polyChainBKs.length;\r\n        require(ECCUtils.verifySig(rawHeader, sigList, polyChainBKs, n - (n - 1) / 3), \"Verify signature failed!\");\r\n        \r\n        // Convert pubKeyList into ethereum address format and make sure the compound address from the converted ethereum addresses\r\n        // equals passed in header.nextBooker\r\n        (bytes20 nextBookKeeper, address[] memory keepers) = ECCUtils.verifyPubkey(pubKeyList);\r\n        require(header.nextBookkeeper == nextBookKeeper, \"NextBookers illegal\");\r\n        \r\n        // update current epoch start height of Poly chain and current epoch consensus peers book keepers addresses\r\n        require(eccd.putCurEpochStartHeight(header.height), \"Save MC LatestHeight to Data contract failed!\");\r\n        require(eccd.putCurEpochConPubKeyBytes(ECCUtils.serializeKeepers(keepers)), \"Save Poly chain book keepers bytes to Data contract failed!\");\r\n        \r\n        // Fire the change book keeper event\r\n        emit ChangeBookKeeperEvent(header.height, rawHeader);\r\n        return true;\r\n    }\r\n\r\n\r\n    /* @notice              ERC20 token cross chain to other blockchain.\r\n    *                       this function push tx event to blockchain\r\n    *  @param toChainId     Target chain id\r\n    *  @param toContract    Target smart contract address in target block chain\r\n    *  @param txData        Transaction data for target chain, include to_address, amount\r\n    *  @return              true or false\r\n    */\r\n    function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) {\r\n        // Only allow whitelist contract to call\r\n        require(whiteListFromContract[msg.sender],\"Invalid from contract\");\r\n        \r\n        // Load Ethereum cross chain data contract\r\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\r\n        \r\n        // To help differentiate two txs, the ethTxHashIndex is increasing automatically\r\n        uint256 txHashIndex = eccd.getEthTxHashIndex();\r\n        \r\n        // Convert the uint256 into bytes\r\n        bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex);\r\n        \r\n        // Construct the makeTxParam, and put the hash info storage, to help provide proof of tx existence\r\n        bytes memory rawParam = abi.encodePacked(ZeroCopySink.WriteVarBytes(paramTxHash),\r\n            ZeroCopySink.WriteVarBytes(abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)))),\r\n            ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)),\r\n            ZeroCopySink.WriteUint64(toChainId),\r\n            ZeroCopySink.WriteVarBytes(toContract),\r\n            ZeroCopySink.WriteVarBytes(method),\r\n            ZeroCopySink.WriteVarBytes(txData)\r\n        );\r\n        \r\n        // Must save it in the storage to be included in the proof to be verified.\r\n        require(eccd.putEthTxHash(keccak256(rawParam)), \"Save ethTxHash by index to Data contract failed!\");\r\n        \r\n        // Fire the cross chain event denoting there is a cross chain request from Ethereum network to other public chains through Poly chain network\r\n        emit CrossChainEvent(tx.origin, paramTxHash, msg.sender, toChainId, toContract, rawParam);\r\n        return true;\r\n    }\r\n    /* @notice              Verify Poly chain header and proof, execute the cross chain tx from Poly chain to Ethereum\r\n    *  @param proof         Poly chain tx merkle proof\r\n    *  @param rawHeader     The header containing crossStateRoot to verify the above tx merkle proof\r\n    *  @param headerProof   The header merkle proof used to verify rawHeader\r\n    *  @param curRawHeader  Any header in current epoch consensus of Poly chain\r\n    *  @param headerSig     The coverted signature veriable for solidity derived from Poly chain consensus nodes' signature\r\n    *                       used to verify the validity of curRawHeader\r\n    *  @return              true or false\r\n    */\r\n    function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\r\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\r\n        // Load ehereum cross chain data contract\r\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\r\n        \r\n        // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[]\r\n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\r\n\r\n        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\r\n\r\n        uint n = polyChainBKs.length;\r\n        if (header.height >= curEpochStartHeight) {\r\n            // It's enough to verify rawHeader signature\r\n            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain header signature failed!\");\r\n        } else {\r\n            // We need to verify the signature of curHeader \r\n            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \"Verify poly chain current epoch header signature failed!\");\r\n\r\n            // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot\r\n            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\r\n            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\r\n            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \"verify header proof failed!\");\r\n        }\r\n        \r\n        // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof\r\n        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\r\n        \r\n        // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed\r\n        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\r\n        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"the transaction has been executed!\");\r\n        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \"Save crosschain tx exist failed!\");\r\n        \r\n        // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network\r\n        require(toMerkleValue.makeTxParam.toChainId == chainId, \"This Tx is not aiming at this network!\");\r\n        \r\n        // Obtain the targeting contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side\r\n        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\r\n        \r\n        // only invoke PreWhiteListed Contract and method For Now\r\n        require(whiteListContractMethodMap[toContract][toMerkleValue.makeTxParam.method],\"Invalid to contract or method\");\r\n\r\n        //TODO: check this part to make sure we commit the next line when doing local net UT test\r\n        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \"Execute CrossChain Tx failed!\");\r\n\r\n        // Fire the cross chain event denoting the executation of cross chain tx is successful,\r\n        // and this tx is coming from other public chains to current Ethereum network\r\n        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\r\n\r\n        return true;\r\n    }\r\n    \r\n    /* @notice                  Dynamically invoke the targeting contract, and trigger executation of cross chain tx on Ethereum side\r\n    *  @param _toContract       The targeting contract that will be invoked by the Ethereum Cross Chain Manager contract\r\n    *  @param _method           At which method will be invoked within the targeting contract\r\n    *  @param _args             The parameter that will be passed into the targeting contract\r\n    *  @param _fromContractAddr From chain smart contract address\r\n    *  @param _fromChainId      Indicate from which chain current cross chain tx comes \r\n    *  @return                  true or false\r\n    */\r\n    function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){\r\n        // Ensure the targeting contract gonna be invoked is indeed a contract rather than a normal account address\r\n        require(Utils.isContract(_toContract), \"The passed in address is not a contract!\");\r\n        bytes memory returnData;\r\n        bool success;\r\n        \r\n        // The returnData will be bytes32, the last byte must be 01;\r\n        (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \"(bytes,bytes,uint64)\"))), abi.encode(_args, _fromContractAddr, _fromChainId)));\r\n        \r\n        // Ensure the executation is successful\r\n        require(success == true, \"EthCrossChain call business contract failed\");\r\n        \r\n        // Ensure the returned value is true\r\n        require(returnData.length != 0, \"No return value from business contract!\");\r\n        (bool res,) = ZeroCopySource.NextBool(returnData, 31);\r\n        require(res == true, \"EthCrossChain call business contract return is not true\");\r\n        \r\n        return true;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_eccd\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_chainId\",\"type\":\"uint64\"},{\"internalType\":\"address[]\",\"name\":\"fromContractWhiteList\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"contractMethodWhiteList\",\"type\":\"bytes[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"rawHeader\",\"type\":\"bytes\"}],\"name\":\"ChangeBookKeeperEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"txId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"proxyOrAssetContract\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toContract\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"rawdata\",\"type\":\"bytes\"}],\"name\":\"CrossChainEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"height\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"rawHeader\",\"type\":\"bytes\"}],\"name\":\"InitGenesisBlockEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"fromChainID\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"toContract\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"crossChainTxHash\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"fromChainTxHash\",\"type\":\"bytes\"}],\"name\":\"VerifyHeaderAndExecuteTxEvent\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"EthCrossChainDataAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chainId\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rawHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"pubKeyList\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sigList\",\"type\":\"bytes\"}],\"name\":\"changeBookKeeper\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"toChainId\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"toContract\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"method\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"txData\",\"type\":\"bytes\"}],\"name\":\"crossChain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"rawHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"pubKeyList\",\"type\":\"bytes\"}],\"name\":\"initGenesisBlock\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"contractMethodWhiteList\",\"type\":\"bytes[]\"}],\"name\":\"removeContractMethodWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"fromContractWhiteList\",\"type\":\"address[]\"}],\"name\":\"removeFromContractWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"_newChainId\",\"type\":\"uint64\"}],\"name\":\"setChainId\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"contractMethodWhiteList\",\"type\":\"bytes[]\"}],\"name\":\"setContractMethodWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"fromContractWhiteList\",\"type\":\"address[]\"}],\"name\":\"setFromContractWhiteList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWL\",\"type\":\"address\"}],\"name\":\"setWhiteLister\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newEthCrossChainManagerAddress\",\"type\":\"address\"}],\"name\":\"upgradeToNew\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"proof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"rawHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"headerProof\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"curRawHeader\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"headerSig\",\"type\":\"bytes\"}],\"name\":\"verifyHeaderAndExecuteTx\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"whiteListContractMethodMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whiteListFromContract\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteLister\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "EthCrossChainManager", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000007cea671dabfba880af6723bddd6b9f4caa15c87b0000000000000000000000000000000000000000000000000000000000000011000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000002c0000000000000000000000000000000000000000000000000000000000000001100000000000000000000000028ff66a1b95d7cacf8eded2e658f768f44841212000000000000000000000000ac57280b3a657a2e8d1180493c519a476d208f61000000000000000000000000f14a7d43bedac1c17da9c22cf3d8c900aa8deca90000000000000000000000009800c0eb44ccb5423bb95205921fcb5ffa066a62000000000000000000000000a61e289c29c47a2eea7092355602de8a0dcb16e20000000000000000000000003803e2a56f657922b76211ab22eafe6c0aa4f95f000000000000000000000000303e57962d735a8dfc7ca5d30676d48a63af73380000000000000000000000005601d189d5751e4f9dde2e598999228b4a5db9e2000000000000000000000000aca1227d3526d78a7df361df3495aa2a64042808000000000000000000000000de8b716f43dcd94e4d4afe73d040825b2e990e6d00000000000000000000000035b161f6f1aa5787045505bd2e8307195485725d0000000000000000000000002d7fe908524180d17c058e6c5388738c1b30d198000000000000000000000000487fd5c13f5764b798d4aecaea79b2e0df5d39520000000000000000000000001b49485342c38c83f5376eff64800b52ee35787f0000000000000000000000006e4475b49f5b2d0f06d6b7218c80c2a588252889000000000000000000000000039db2fc6377b20a30ac9f05eb6477ce7461cb0b00000000000000000000000032caf282bdb48147c157285e0eb715fbfa07826a0000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000002e000000000000000000000000000000000000000000000000000000000000003c000000000000000000000000000000000000000000000000000000000000004a00000000000000000000000000000000000000000000000000000000000000580000000000000000000000000000000000000000000000000000000000000066000000000000000000000000000000000000000000000000000000000000007400000000000000000000000000000000000000000000000000000000000000820000000000000000000000000000000000000000000000000000000000000090000000000000000000000000000000000000000000000000000000000000009e00000000000000000000000000000000000000000000000000000000000000ac00000000000000000000000000000000000000000000000000000000000000ba00000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000000d600000000000000000000000000000000000000000000000000000000000000e400000000000000000000000000000000000000000000000000000000000000f2000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000028ff66a1b95d7cacf8eded2e658f768f448412120000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000006756e6c6f636b000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000f14a7d43bedac1c17da9c22cf3d8c900aa8deca9000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000009800c0eb44ccb5423bb95205921fcb5ffa066a62000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000a61e289c29c47a2eea7092355602de8a0dcb16e2000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000003803e2a56f657922b76211ab22eafe6c0aa4f95f000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000303e57962d735a8dfc7ca5d30676d48a63af7338000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000005601d189d5751e4f9dde2e598999228b4a5db9e2000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000aca1227d3526d78a7df361df3495aa2a64042808000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000de8b716f43dcd94e4d4afe73d040825b2e990e6d000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000035b161f6f1aa5787045505bd2e8307195485725d000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000002d7fe908524180d17c058e6c5388738c1b30d198000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000487fd5c13f5764b798d4aecaea79b2e0df5d3952000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000001b49485342c38c83f5376eff64800b52ee35787f000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000006e4475b49f5b2d0f06d6b7218c80c2a588252889000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000039db2fc6377b20a30ac9f05eb6477ce7461cb0b000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e73666572000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c000000000000000000000000032caf282bdb48147c157285e0eb715fbfa07826a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000f6f6e43726f73735472616e736665720000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://b95be34f8d27a791a7640ee656771bd241a4a5b83063cb97d397ae46fbcd0de6"}