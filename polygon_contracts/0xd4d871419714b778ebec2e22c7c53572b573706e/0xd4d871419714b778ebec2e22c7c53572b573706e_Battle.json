{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Battle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\r\\nimport \\\"./interfaces/IBattleToken.sol\\\";\\r\\nimport \\\"./interfaces/IBattleDice.sol\\\";\\r\\n\\r\\nenum PieceType {\\r\\n    PLAYER,\\r\\n    WEAPON\\r\\n}\\r\\n\\r\\nstruct Piece {\\r\\n    uint32 id; // tokenId of player, or ID of weapon\\r\\n    uint32 data; // id of weapon if held by player\\r\\n    uint8 data2; // kills\\r\\n    uint16 game; // game that this piece belongs to\\r\\n    uint16 lastMove; // last move if it a player\\r\\n    PieceType pieceType; // PLAYER, WEAPON\\r\\n    int8 x; // x pos\\r\\n    int8 y; // y pos\\r\\n    int8[7] stats; // array of weapon or player stats\\r\\n}\\r\\n\\r\\nstruct Game {\\r\\n    uint32 startTime; // timestamp of beginning of game\\r\\n    uint16 lastBattle; // turn number of the last battle\\r\\n    uint8 players; // number of players\\r\\n    uint8 remaining; // number of remaining players\\r\\n    mapping(int8 => mapping(int8 => uint32)) board; // board game\\r\\n}\\r\\n\\r\\nuint256 constant FEE_ENTRY = 0 ether;\\r\\nuint256 constant STALEMATE_TURNS = 6;\\r\\nuint256 constant PERCENT_OWNER = 51;\\r\\nuint32 constant TOKEN_MAX = 800;\\r\\n\\r\\n/// @author AnAllergyToAnalogy\\r\\n/// @title Big Head Club Doomies Main Contract\\r\\n/// @notice Main Doomies contract, it has all the externally-facing battle and mint functions (not ERC721 stuff tho)\\r\\ncontract Battle is Ownable {\\r\\n\\r\\n    event NewGame(uint16 indexed game);\\r\\n\\r\\n    event Move(\\r\\n        uint32 indexed tokenId,\\r\\n        int8 x,\\r\\n        int8 y,\\r\\n        uint16 indexed game,\\r\\n        uint16 turn,\\r\\n        uint32 data\\r\\n    );\\r\\n    event BattleLog(\\r\\n        uint32 indexed player1,\\r\\n        uint32 indexed player2,\\r\\n        int256[8] rolls1,\\r\\n        int256[8] rolls2,\\r\\n        uint32 winner,\\r\\n        uint16 indexed game,\\r\\n        uint16 turn\\r\\n    );\\r\\n    event Mint(\\r\\n        uint32 indexed tokenId,\\r\\n        int8[7] stats\\r\\n    );\\r\\n    event NewWeapon(\\r\\n        uint32 indexed pieceId,\\r\\n        int8[7] stats,\\r\\n        uint16 indexed game\\r\\n    );\\r\\n    event WithdrawWinnings(\\r\\n        uint32 tokenId,\\r\\n        uint16 indexed game,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    uint256 public turnTime = 1 days;\\r\\n    address token;\\r\\n    address dice;\\r\\n    uint32 ownerWithdrawn;\\r\\n    uint32 public lastTokenId;\\r\\n    uint32 lastWeaponId = TOKEN_MAX;\\r\\n\\r\\n    //This exposes a public method like this:\\r\\n    // function game() public view returns(uint);\\r\\n    //  returns the current game number\\r\\n    uint16 public game;\\r\\n\\r\\n    //This exposes a public method like this:\\r\\n    // function games(uint _game) public view returns(Game);\\r\\n    //  it will return the Game struct for the given game number, not including the board\\r\\n    mapping(uint256 => Game) public games;\\r\\n\\r\\n    //This exposes a public method like this:\\r\\n    // function pieces(uint _pieceId) public view returns(Piece);\\r\\n    //  it will return the Piece struct for the given id, not including the stats array\\r\\n    mapping(uint32 => Piece) public pieces;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n    constructor(address _token, address _dice) {\\r\\n        token = _token;\\r\\n        dice = _dice;\\r\\n    }\\r\\n\\r\\n    // Enters token into game\\r\\n    //  takes the following params:\\r\\n    //      tokenId: id of token\\r\\n    //      startX:  x coord to start form\\r\\n    //      startY:  y coord to start form\\r\\n\\r\\n    //  player must own the token\\r\\n    //  token can't have been entered into this or a previous game\\r\\n    //  game has to be active,\\r\\n    //  has to be entry time of the game (ie, turn = 0)\\r\\n    //  has to be on the edge of map, only on every second space\\r\\n    //  has to be on an empty tile\\r\\n\\r\\n    //Emits the following events\\r\\n    // from main contract\\r\\n    //   event Move(tokenId, startX, startY, game number, turn number, type(uint32).max - 1);\\r\\n    //    you can infer that a Move event is an 'enter game' event by either lookin at turn number == 0\\r\\n    //                                                          or the data property = type(uint32).max - 1\\r\\n    function enterGame(\\r\\n        uint32 tokenId,\\r\\n        int8 startX,\\r\\n        int8 startY\\r\\n    ) public {\\r\\n        require(IBattleToken(token).ownerOf(tokenId) == msg.sender, \\\"owner\\\");\\r\\n\\r\\n        require(pieces[tokenId].game == 0, \\\"entered\\\");\\r\\n\\r\\n        require(gameIsActive(), \\\"game not active\\\");\\r\\n        require(turnNumber() == 0, \\\"not entry time\\\");\\r\\n\\r\\n        require(\\r\\n            startX == 0 || startY == 0 || startX == 8 || startY == 8,\\r\\n            \\\"edge\\\"\\r\\n        );\\r\\n        require(startX % 2 == 0 && startY % 2 == 0, \\\"position\\\");\\r\\n        require(games[game].board[startX][startY] == 0, \\\"occupied\\\");\\r\\n\\r\\n        games[game].board[startX][startY] = tokenId;\\r\\n        ++games[game].players;\\r\\n        ++games[game].remaining;\\r\\n\\r\\n        pieces[tokenId].game = game;\\r\\n        pieces[tokenId].x = startX;\\r\\n        pieces[tokenId].y = startY;\\r\\n\\r\\n        emit Move(\\r\\n            tokenId,\\r\\n            startX,\\r\\n            startY,\\r\\n            game,\\r\\n            turnNumber(),\\r\\n            type(uint32).max - 1\\r\\n        );\\r\\n\\r\\n        if (games[game].players == 16) {\\r\\n            games[game].startTime = uint32(block.timestamp - turnTime);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    //Mints token,\\r\\n    // Requires msg value of FEE_ENTRY\\r\\n    //  will fail if token max has been reached\\r\\n    //  this rolls the stats of the token\\r\\n\\r\\n    //Emits the following events\\r\\n    // from Token contract:\\r\\n    //      Transfer( 0x0, msg.sender, tokenId)\\r\\n    // from main contract\\r\\n    //      event Mint(tokenId, int8[7] stats );\\r\\n    function mint() public payable {\\r\\n        require(gasleft() > 200000, \\\"gas failsafe\\\");\\r\\n\\r\\n        require(msg.sender == tx.origin, \\\"no contracts\\\");\\r\\n        require(msg.value == FEE_ENTRY, \\\"FEE_ENTRY\\\");\\r\\n        require(lastTokenId < TOKEN_MAX, \\\"supply limit\\\");\\r\\n\\r\\n        IBattleToken(token).mint(msg.sender, ++lastTokenId);\\r\\n\\r\\n        pieces[lastTokenId] = Piece(\\r\\n            lastTokenId,\\r\\n            0,\\r\\n            0,\\r\\n            0,\\r\\n            0,\\r\\n            PieceType.PLAYER,\\r\\n            0,\\r\\n            0,\\r\\n            IBattleDice(dice).rollPlayerStats()\\r\\n        );\\r\\n\\r\\n        emit Mint(lastTokenId, pieces[lastTokenId].stats);\\r\\n    }\\r\\n\\r\\n    //Moves a token\\r\\n    //  takes the following params:\\r\\n    //      tokenId: id of the token\\r\\n    //      dx: how far to move in x direction\\r\\n    //      dy: how far to move in y direction\\r\\n\\r\\n    //  player must own the token\\r\\n    //  game must be active\\r\\n    //  can't be in entry time (ie turnNumber = 0)\\r\\n    //  can't have moved this turn\\r\\n    //  can't do it if token has died\\r\\n    //  can't do it if not in this game\\r\\n    //  can't do it if sender is a contract\\r\\n    //  can't do it trying to move more than 1 square away\\r\\n    //  can't not move at all in tx\\r\\n    //  can't move off map\\r\\n\\r\\n    //Emits the following events\\r\\n    // from main contract\\r\\n\\r\\n    // if the player moves to an empty square, a weapon square, or an occupied square and then succeeds at the battle:\\r\\n    //  emit Move(tokenId, toX, toY, game number, turn number, 0);\\r\\n\\r\\n    // if there is a battle, it will emit the following event BEFORE the Move event\\r\\n    //  emit BattleLog(player id, opponent id, player's rolls,  opponent's rolls, id of victor, turn number, game number);\\r\\n    //   where rolls are arrays of the dice rolls for each player for each stat.\\r\\n    //      in the case where it's a draw, the winner will have a 1 in their final slot. otherwise that's unused.\\r\\n\\r\\n    function move(\\r\\n        uint32 tokenId,\\r\\n        int8 dx,\\r\\n        int8 dy\\r\\n    ) public {\\r\\n        require(gasleft() > 200000, \\\"gas failsafe\\\");\\r\\n        require(IBattleToken(token).ownerOf(tokenId) == msg.sender, \\\"owner\\\");\\r\\n\\r\\n        require(gameIsActive(), \\\"game not active\\\");\\r\\n        require(turnNumber() != 0, \\\"still entry time\\\");\\r\\n        require(pieces[tokenId].lastMove < turnNumber(), \\\"already moved\\\");\\r\\n        require(pieces[tokenId].game == game, \\\"not in game\\\");\\r\\n        require(pieces[tokenId].data != type(uint32).max, \\\"token dead\\\");\\r\\n\\r\\n        require(msg.sender == tx.origin, \\\"no contracts\\\");\\r\\n        require(dx >= -1 && dx <= 1 && dy >= -1 && dy <= 1, \\\"range\\\");\\r\\n        require(!(dx == 0 && dy == 0), \\\"stationary\\\");\\r\\n\\r\\n        Piece memory piece = pieces[tokenId];\\r\\n\\r\\n        int8 toX = piece.x + dx;\\r\\n        int8 toY = piece.y + dy;\\r\\n\\r\\n        require(toX >= 0 && toX <= 8 && toY >= 0 && toY <= 8, \\\"bounds\\\");\\r\\n\\r\\n        delete games[game].board[piece.x][piece.y];\\r\\n\\r\\n        uint32 target = games[game].board[toX][toY];\\r\\n\\r\\n        if (target == 0) {\\r\\n            //space empty, Just move\\r\\n            games[game].board[toX][toY] = tokenId;\\r\\n            pieces[tokenId].x = toX;\\r\\n            pieces[tokenId].y = toY;\\r\\n            pieces[tokenId].lastMove = turnNumber();\\r\\n\\r\\n            emit Move(tokenId, toX, toY, game, turnNumber(), 0);\\r\\n        } else if (pieces[target].pieceType == PieceType.WEAPON) {\\r\\n            //Weapon, pickup\\r\\n            if (piece.data != 0) {\\r\\n                //kill the current weapon\\r\\n                delete pieces[piece.data];\\r\\n            }\\r\\n            pieces[tokenId].data = target;\\r\\n\\r\\n            games[game].board[toX][toY] = tokenId;\\r\\n            pieces[tokenId].x = toX;\\r\\n            pieces[tokenId].y = toY;\\r\\n            pieces[tokenId].lastMove = turnNumber();\\r\\n\\r\\n            emit Move(tokenId, toX, toY, game, turnNumber(), target);\\r\\n        } else {\\r\\n            //Player, battle\\r\\n\\r\\n            games[game].lastBattle = turnNumber();\\r\\n\\r\\n            uint32 victor = _battle(tokenId, target);\\r\\n\\r\\n            if (tokenId == victor) {\\r\\n                //player wins\\r\\n\\r\\n                //flag enemy token as dead\\r\\n                pieces[target].data = type(uint32).max;\\r\\n\\r\\n                games[game].board[toX][toY] = tokenId;\\r\\n                pieces[tokenId].x = toX;\\r\\n                pieces[tokenId].y = toY;\\r\\n                pieces[tokenId].lastMove = turnNumber();\\r\\n\\r\\n                ++pieces[tokenId].data2;\\r\\n\\r\\n                emit Move(tokenId, toX, toY, game, turnNumber(), 0);\\r\\n            } else {\\r\\n                //enemy wins\\r\\n                pieces[tokenId].data = type(uint32).max;\\r\\n\\r\\n                ++pieces[target].data2;\\r\\n            }\\r\\n            --games[game].remaining;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawWinnings(uint32 tokenId) public {\\r\\n        require(IBattleToken(token).ownerOf(tokenId) == msg.sender, \\\"owner\\\");\\r\\n\\r\\n        Piece memory piece = pieces[tokenId];\\r\\n\\r\\n        require(piece.game < game || !gameIsActive(), \\\"not yet winner\\\");\\r\\n        require(pieces[tokenId].data < type(uint32).max, \\\"no winnings\\\");\\r\\n\\r\\n        uint256 toWithdraw;\\r\\n\\r\\n        if (games[piece.game].remaining == 1) {\\r\\n            //Single Winner\\r\\n            toWithdraw =\\r\\n            (games[piece.game].players *\\r\\n            FEE_ENTRY *\\r\\n            (100 - PERCENT_OWNER)) /\\r\\n            100;\\r\\n        } else {\\r\\n            uint256 eliminated = games[piece.game].players -\\r\\n            games[piece.game].remaining;\\r\\n            if (eliminated > 0) {\\r\\n                toWithdraw =\\r\\n                (((uint256(piece.data2) *\\r\\n                games[piece.game].players *\\r\\n                FEE_ENTRY) / eliminated) * (100 - PERCENT_OWNER)) /\\r\\n                100;\\r\\n            } else {\\r\\n                toWithdraw =\\r\\n                (games[piece.game].players *\\r\\n                FEE_ENTRY *\\r\\n                (100 - PERCENT_OWNER)) /\\r\\n                100;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        pieces[tokenId].data = type(uint32).max;\\r\\n\\r\\n        emit WithdrawWinnings(tokenId, piece.game, toWithdraw);\\r\\n\\r\\n        payable(msg.sender).transfer(toWithdraw);\\r\\n    }\\r\\n\\r\\n    function ownerWithdraw() public onlyOwner {\\r\\n        require(ownerWithdrawn < lastTokenId, \\\"withdrawn\\\");\\r\\n\\r\\n        uint256 toWithdraw = (uint256(lastTokenId - ownerWithdrawn) *\\r\\n        FEE_ENTRY *\\r\\n        PERCENT_OWNER) / 100;\\r\\n\\r\\n        ownerWithdrawn = lastTokenId;\\r\\n\\r\\n        payable(msg.sender).transfer(toWithdraw);\\r\\n    }\\r\\n\\r\\n    function updateTurnTime(uint256 _turnTime) public onlyOwner {\\r\\n        require(!gameIsActive(), \\\"game active\\\");\\r\\n        turnTime = _turnTime;\\r\\n    }\\r\\n\\r\\n    // call this to start the game\\r\\n    //  can't be called by non contract owner\\r\\n    //  cant be called if game in progress\\r\\n    function startGame() public {\\r\\n        require(gasleft() > 1250000, \\\"gas failsafe\\\");\\r\\n\\r\\n        require(!gameIsActive(), \\\"game active\\\");\\r\\n        game++;\\r\\n\\r\\n        games[game].startTime = uint32(block.timestamp);\\r\\n\\r\\n        for (int8 x = 3; x <= 5; x++) {\\r\\n            for (int8 y = 3; y <= 5; y++) {\\r\\n                if (x == 4 && y == 4) continue;\\r\\n\\r\\n                games[game].board[x][y] = ++lastWeaponId;\\r\\n                games[game].lastBattle = 1;\\r\\n\\r\\n                pieces[lastWeaponId] = Piece(\\r\\n                    lastWeaponId,\\r\\n                    0,\\r\\n                    0,\\r\\n                    game,\\r\\n                    0,\\r\\n                    PieceType.WEAPON,\\r\\n                    x,\\r\\n                    y,\\r\\n                    IBattleDice(dice).rollWeaponStats(lastWeaponId)\\r\\n                );\\r\\n\\r\\n                emit NewWeapon(lastWeaponId, pieces[lastWeaponId].stats, game);\\r\\n            }\\r\\n        }\\r\\n        emit NewGame(game);\\r\\n    }\\r\\n\\r\\n    // returns true if game is currently active\\r\\n    function gameIsActive() public view returns (bool) {\\r\\n        return\\r\\n        game != 0 &&\\r\\n        (turnNumber() == 0 ||\\r\\n        !(turnNumber() > games[game].lastBattle + STALEMATE_TURNS ||\\r\\n        games[game].remaining < 2));\\r\\n    }\\r\\n\\r\\n    // returns a 9x9 array of current board, with ids of pieces\\r\\n    function getTile(int8 x, int8 y) public view returns (uint32) {\\r\\n        return games[game].board[x][y];\\r\\n\\r\\n    }\\r\\n\\r\\n    // return stats array of a given piece\\r\\n    function getStats(uint32 pieceId) public view returns (int8[7] memory) {\\r\\n        return pieces[pieceId].stats;\\r\\n    }\\r\\n\\r\\n    // returns true if a token hasnt been put in a game\\r\\n    function tokenIsUnused(uint32 tokenId) public view returns (bool) {\\r\\n        return pieces[tokenId].game == 0;\\r\\n    }\\r\\n\\r\\n    function _battle(uint32 player1, uint32 player2) internal returns (uint32) {\\r\\n        (\\r\\n            uint32 victor,\\r\\n            int256[8] memory rolls1,\\r\\n            int256[8] memory rolls2\\r\\n        ) = IBattleDice(dice).battle(\\r\\n                player1,\\r\\n                player2,\\r\\n                pieces[player1].stats,\\r\\n                pieces[pieces[player1].data].stats,\\r\\n                pieces[player2].stats,\\r\\n                pieces[pieces[player2].data].stats\\r\\n            );\\r\\n        emit BattleLog(\\r\\n            player1,\\r\\n            player2,\\r\\n            rolls1,\\r\\n            rolls2,\\r\\n            victor,\\r\\n            turnNumber(),\\r\\n            game\\r\\n        );\\r\\n\\r\\n        return victor;\\r\\n    }\\r\\n\\r\\n    // returns the current turn number of the current game\\r\\n    function turnNumber() private view returns (uint16) {\\r\\n        return\\r\\n            uint16(\\r\\n                (block.timestamp - uint256(games[game].startTime)) / turnTime\\r\\n            );\\r\\n    }\\r\\n\\r\\n\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBattleDice.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IBattleDice {\\r\\n    function rollPlayerStats() external view returns (int8[7] memory stats);\\r\\n\\r\\n    function rollWeaponStats(uint32 salt)\\r\\n        external\\r\\n        view\\r\\n        returns (int8[7] memory stats);\\r\\n\\r\\n    function battle(\\r\\n        uint32 player1,\\r\\n        uint32 player2,\\r\\n        int8[7] memory stats1,\\r\\n        int8[7] memory weapon1,\\r\\n        int8[7] memory stats2,\\r\\n        int8[7] memory weapon2\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint32 victor,\\r\\n            int256[8] memory rolls1,\\r\\n            int256[8] memory rolls2\\r\\n        );\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IBattleToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.9;\\r\\n\\r\\ninterface IBattleToken {\\r\\n    function mint(address to, uint256 tokenId) external;\\r\\n\\r\\n    function burn(uint256 tokenId) external;\\r\\n\\r\\n    function ownerOf(uint256 tokenId) external view returns (address);\\r\\n}\\r\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_dice\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"player1\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"player2\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int256[8]\",\"name\":\"rolls1\",\"type\":\"int256[8]\"},{\"indexed\":false,\"internalType\":\"int256[8]\",\"name\":\"rolls2\",\"type\":\"int256[8]\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"winner\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"turn\",\"type\":\"uint16\"}],\"name\":\"BattleLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int8[7]\",\"name\":\"stats\",\"type\":\"int8[7]\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"x\",\"type\":\"int8\"},{\"indexed\":false,\"internalType\":\"int8\",\"name\":\"y\",\"type\":\"int8\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"turn\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"data\",\"type\":\"uint32\"}],\"name\":\"Move\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"}],\"name\":\"NewGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint32\",\"name\":\"pieceId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"int8[7]\",\"name\":\"stats\",\"type\":\"int8[7]\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"}],\"name\":\"NewWeapon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawWinnings\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"int8\",\"name\":\"startX\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"startY\",\"type\":\"int8\"}],\"name\":\"enterGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"game\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameIsActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"lastBattle\",\"type\":\"uint16\"},{\"internalType\":\"uint8\",\"name\":\"players\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"remaining\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"pieceId\",\"type\":\"uint32\"}],\"name\":\"getStats\",\"outputs\":[{\"internalType\":\"int8[7]\",\"name\":\"\",\"type\":\"int8[7]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int8\",\"name\":\"x\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"y\",\"type\":\"int8\"}],\"name\":\"getTile\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastTokenId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"},{\"internalType\":\"int8\",\"name\":\"dx\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"dy\",\"type\":\"int8\"}],\"name\":\"move\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ownerWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"pieces\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"id\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"data\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"data2\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"game\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"lastMove\",\"type\":\"uint16\"},{\"internalType\":\"enum PieceType\",\"name\":\"pieceType\",\"type\":\"uint8\"},{\"internalType\":\"int8\",\"name\":\"x\",\"type\":\"int8\"},{\"internalType\":\"int8\",\"name\":\"y\",\"type\":\"int8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"tokenIsUnused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"turnTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_turnTime\",\"type\":\"uint256\"}],\"name\":\"updateTurnTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"withdrawWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Battle", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000000ad3bf0033bbf43e758dda0000ba3c49c1613f0f000000000000000000000000f56d8be50c3b133c860ce8d2eef974654d574bb8", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}