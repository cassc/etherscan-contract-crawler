{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/core/CollectNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {ICollectNFT} from '../interfaces/ICollectNFT.sol';\\nimport {ILensHub} from '../interfaces/ILensHub.sol';\\nimport {Errors} from '../libraries/Errors.sol';\\nimport {Events} from '../libraries/Events.sol';\\nimport {LensNFTBase} from './base/LensNFTBase.sol';\\n\\n/**\\n * @title CollectNFT\\n * @author Lens Protocol\\n *\\n * @notice This is the NFT contract that is minted upon collecting a given publication. It is cloned upon\\n * the first collect for a given publication, and the token URI points to the original publication's contentURI.\\n */\\ncontract CollectNFT is LensNFTBase, ICollectNFT {\\n    address public immutable HUB;\\n\\n    uint256 internal _profileId;\\n    uint256 internal _pubId;\\n    uint256 internal _tokenIdCounter;\\n\\n    bool private _initialized;\\n\\n    // We create the CollectNFT with the pre-computed HUB address before deploying the hub proxy in order\\n    // to initialize the hub proxy at construction.\\n    constructor(address hub) {\\n        if (hub == address(0)) revert Errors.InitParamsInvalid();\\n        HUB = hub;\\n        _initialized = true;\\n    }\\n\\n    /// @inheritdoc ICollectNFT\\n    function initialize(\\n        uint256 profileId,\\n        uint256 pubId,\\n        string calldata name,\\n        string calldata symbol\\n    ) external override {\\n        if (_initialized) revert Errors.Initialized();\\n        _initialized = true;\\n        _profileId = profileId;\\n        _pubId = pubId;\\n        super._initialize(name, symbol);\\n        emit Events.CollectNFTInitialized(profileId, pubId, block.timestamp);\\n    }\\n\\n    /// @inheritdoc ICollectNFT\\n    function mint(address to) external override returns (uint256) {\\n        if (msg.sender != HUB) revert Errors.NotHub();\\n        unchecked {\\n            uint256 tokenId = ++_tokenIdCounter;\\n            _mint(to, tokenId);\\n            return tokenId;\\n        }\\n    }\\n\\n    /// @inheritdoc ICollectNFT\\n    function getSourcePublicationPointer() external view override returns (uint256, uint256) {\\n        return (_profileId, _pubId);\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        if (!_exists(tokenId)) revert Errors.TokenDoesNotExist();\\n        return ILensHub(HUB).getContentURI(_profileId, _pubId);\\n    }\\n\\n    /**\\n     * @dev Upon transfers, we emit the transfer event in the hub.\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n        ILensHub(HUB).emitCollectNFTTransferEvent(_profileId, _pubId, tokenId, from, to);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICollectNFT.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title ICollectNFT\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the CollectNFT contract. Which is cloned upon the first collect for any given\\n * publication.\\n */\\ninterface ICollectNFT {\\n    /**\\n     * @notice Initializes the collect NFT, setting the feed as the privileged minter, storing the collected publication pointer\\n     * and initializing the name and symbol in the LensNFTBase contract.\\n     *\\n     * @param profileId The token ID of the profile in the hub that this collectNFT points to.\\n     * @param pubId The profile publication ID in the hub that this collectNFT points to.\\n     * @param name The name to set for this NFT.\\n     * @param symbol The symbol to set for this NFT.\\n     */\\n    function initialize(\\n        uint256 profileId,\\n        uint256 pubId,\\n        string calldata name,\\n        string calldata symbol\\n    ) external;\\n\\n    /**\\n     * @notice Mints a collect NFT to the specified address. This can only be called by the hub, and is called\\n     * upon collection.\\n     *\\n     * @param to The address to mint the NFT to.\\n     *\\n     * @return uint256 An interger representing the minted token ID.\\n     */\\n    function mint(address to) external returns (uint256);\\n\\n    /**\\n     * @notice Returns the source publication pointer mapped to this collect NFT.\\n     *\\n     * @return tuple First the profile ID uint256, and second the pubId uint256.\\n     */\\n    function getSourcePublicationPointer() external view returns (uint256, uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {DataTypes} from '../libraries/DataTypes.sol';\\n\\n/**\\n * @title ILensHub\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the LensHub contract, the main entry point for the Lens Protocol.\\n * You'll find all the events and external functions, as well as the reasoning behind them here.\\n */\\ninterface ILensHub {\\n    /**\\n     * @notice Initializes the LensHub NFT, setting the initial governance address as well as the name and symbol in\\n     * the LensNFTBase contract.\\n     *\\n     * @param name The name to set for the hub NFT.\\n     * @param symbol The symbol to set for the hub NFT.\\n     * @param newGovernance The governance address to set.\\n     */\\n    function initialize(\\n        string calldata name,\\n        string calldata symbol,\\n        address newGovernance\\n    ) external;\\n\\n    /**\\n     * @notice Sets the privileged governance role. This function can only be called by the current governance\\n     * address.\\n     *\\n     * @param newGovernance The new governance address to set.\\n     */\\n    function setGovernance(address newGovernance) external;\\n\\n    /**\\n     * @notice Sets the emergency admin, which is a permissioned role able to set the protocol state. This function\\n     * can only be called by the governance address.\\n     *\\n     * @param newEmergencyAdmin The new emergency admin address to set.\\n     */\\n    function setEmergencyAdmin(address newEmergencyAdmin) external;\\n\\n    /**\\n     * @notice Sets the protocol state to either a global pause, a publishing pause or an unpaused state. This function\\n     * can only be called by the governance address or the emergency admin address.\\n     *\\n     * Note that this reverts if the emergency admin calls it if:\\n     *      1. The emergency admin is attempting to unpause.\\n     *      2. The emergency admin is calling while the protocol is already paused.\\n     *\\n     * @param newState The state to set, as a member of the ProtocolState enum.\\n     */\\n    function setState(DataTypes.ProtocolState newState) external;\\n\\n    /**\\n     * @notice Adds or removes a profile creator from the whitelist. This function can only be called by the current\\n     * governance address.\\n     *\\n     * @param profileCreator The profile creator address to add or remove from the whitelist.\\n     * @param whitelist Whether or not the profile creator should be whitelisted.\\n     */\\n    function whitelistProfileCreator(address profileCreator, bool whitelist) external;\\n\\n    /**\\n     * @notice Adds or removes a follow module from the whitelist. This function can only be called by the current\\n     * governance address.\\n     *\\n     * @param followModule The follow module contract address to add or remove from the whitelist.\\n     * @param whitelist Whether or not the follow module should be whitelisted.\\n     */\\n    function whitelistFollowModule(address followModule, bool whitelist) external;\\n\\n    /**\\n     * @notice Adds or removes a reference module from the whitelist. This function can only be called by the current\\n     * governance address.\\n     *\\n     * @param referenceModule The reference module contract to add or remove from the whitelist.\\n     * @param whitelist Whether or not the reference module should be whitelisted.\\n     */\\n    function whitelistReferenceModule(address referenceModule, bool whitelist) external;\\n\\n    /**\\n     * @notice Adds or removes a collect module from the whitelist. This function can only be called by the current\\n     * governance address.\\n     *\\n     * @param collectModule The collect module contract address to add or remove from the whitelist.\\n     * @param whitelist Whether or not the collect module should be whitelisted.\\n     */\\n    function whitelistCollectModule(address collectModule, bool whitelist) external;\\n\\n    /**\\n     * @notice Creates a profile with the specified parameters, minting a profile NFT to the given recipient. This\\n     * function must be called by a whitelisted profile creator.\\n     *\\n     * @param vars A CreateProfileData struct containing the following params:\\n     *      to: The address receiving the profile.\\n     *      handle: The handle to set for the profile, must be unique and non-empty.\\n     *      imageURI: The URI to set for the profile image.\\n     *      followModule: The follow module to use, can be the zero address.\\n     *      followModuleInitData: The follow module initialization data, if any.\\n     */\\n    function createProfile(DataTypes.CreateProfileData calldata vars) external returns (uint256);\\n\\n    /**\\n     * @notice Sets the mapping between wallet and its main profile identity.\\n     *\\n     * @param profileId The token ID of the profile to set as the main profile identity.\\n     */\\n    function setDefaultProfile(uint256 profileId) external;\\n\\n    /**\\n     * @notice Sets the mapping between wallet and its main profile identity via signature with the specified parameters.\\n     *\\n     * @param vars A SetDefaultProfileWithSigData struct, including the regular parameters and an EIP712Signature struct.\\n     */\\n    function setDefaultProfileWithSig(DataTypes.SetDefaultProfileWithSigData calldata vars)\\n        external;\\n\\n    /**\\n     * @notice Sets a profile's follow module, must be called by the profile owner.\\n     *\\n     * @param profileId The token ID of the profile to set the follow module for.\\n     * @param followModule The follow module to set for the given profile, must be whitelisted.\\n     * @param followModuleInitData The data to be passed to the follow module for initialization.\\n     */\\n    function setFollowModule(\\n        uint256 profileId,\\n        address followModule,\\n        bytes calldata followModuleInitData\\n    ) external;\\n\\n    /**\\n     * @notice Sets a profile's follow module via signature with the specified parameters.\\n     *\\n     * @param vars A SetFollowModuleWithSigData struct, including the regular parameters and an EIP712Signature struct.\\n     */\\n    function setFollowModuleWithSig(DataTypes.SetFollowModuleWithSigData calldata vars) external;\\n\\n    /**\\n     * @notice Sets a profile's dispatcher, giving that dispatcher rights to publish to that profile.\\n     *\\n     * @param profileId The token ID of the profile of the profile to set the dispatcher for.\\n     * @param dispatcher The dispatcher address to set for the given profile ID.\\n     */\\n    function setDispatcher(uint256 profileId, address dispatcher) external;\\n\\n    /**\\n     * @notice Sets a profile's dispatcher via signature with the specified parameters.\\n     *\\n     * @param vars A SetDispatcherWithSigData struct, including the regular parameters and an EIP712Signature struct.\\n     */\\n    function setDispatcherWithSig(DataTypes.SetDispatcherWithSigData calldata vars) external;\\n\\n    /**\\n     * @notice Sets a profile's URI, which is reflected in the `tokenURI()` function.\\n     *\\n     * @param profileId The token ID of the profile of the profile to set the URI for.\\n     * @param imageURI The URI to set for the given profile.\\n     */\\n    function setProfileImageURI(uint256 profileId, string calldata imageURI) external;\\n\\n    /**\\n     * @notice Sets a profile's URI via signature with the specified parameters.\\n     *\\n     * @param vars A SetProfileImageURIWithSigData struct, including the regular parameters and an EIP712Signature struct.\\n     */\\n    function setProfileImageURIWithSig(DataTypes.SetProfileImageURIWithSigData calldata vars)\\n        external;\\n\\n    /**\\n     * @notice Sets a followNFT URI for a given profile's follow NFT.\\n     *\\n     * @param profileId The token ID of the profile for which to set the followNFT URI.\\n     * @param followNFTURI The follow NFT URI to set.\\n     */\\n    function setFollowNFTURI(uint256 profileId, string calldata followNFTURI) external;\\n\\n    /**\\n     * @notice Sets a followNFT URI via signature with the specified parameters.\\n     *\\n     * @param vars A SetFollowNFTURIWithSigData struct, including the regular parameters and an EIP712Signature struct.\\n     */\\n    function setFollowNFTURIWithSig(DataTypes.SetFollowNFTURIWithSigData calldata vars) external;\\n\\n    /**\\n     * @notice Publishes a post to a given profile, must be called by the profile owner.\\n     *\\n     * @param vars A PostData struct containing the needed parameters.\\n     *\\n     * @return uint256 An integer representing the post's publication ID.\\n     */\\n    function post(DataTypes.PostData calldata vars) external returns (uint256);\\n\\n    /**\\n     * @notice Publishes a post to a given profile via signature with the specified parameters.\\n     *\\n     * @param vars A PostWithSigData struct containing the regular parameters and an EIP712Signature struct.\\n     *\\n     * @return uint256 An integer representing the post's publication ID.\\n     */\\n    function postWithSig(DataTypes.PostWithSigData calldata vars) external returns (uint256);\\n\\n    /**\\n     * @notice Publishes a comment to a given profile, must be called by the profile owner.\\n     *\\n     * @param vars A CommentData struct containing the needed parameters.\\n     *\\n     * @return uint256 An integer representing the comment's publication ID.\\n     */\\n    function comment(DataTypes.CommentData calldata vars) external returns (uint256);\\n\\n    /**\\n     * @notice Publishes a comment to a given profile via signature with the specified parameters.\\n     *\\n     * @param vars A CommentWithSigData struct containing the regular parameters and an EIP712Signature struct.\\n     *\\n     * @return uint256 An integer representing the comment's publication ID.\\n     */\\n    function commentWithSig(DataTypes.CommentWithSigData calldata vars) external returns (uint256);\\n\\n    /**\\n     * @notice Publishes a mirror to a given profile, must be called by the profile owner.\\n     *\\n     * @param vars A MirrorData struct containing the necessary parameters.\\n     *\\n     * @return uint256 An integer representing the mirror's publication ID.\\n     */\\n    function mirror(DataTypes.MirrorData calldata vars) external returns (uint256);\\n\\n    /**\\n     * @notice Publishes a mirror to a given profile via signature with the specified parameters.\\n     *\\n     * @param vars A MirrorWithSigData struct containing the regular parameters and an EIP712Signature struct.\\n     *\\n     * @return uint256 An integer representing the mirror's publication ID.\\n     */\\n    function mirrorWithSig(DataTypes.MirrorWithSigData calldata vars) external returns (uint256);\\n\\n    /**\\n     * @notice Follows the given profiles, executing each profile's follow module logic (if any) and minting followNFTs to the caller.\\n     *\\n     * NOTE: Both the `profileIds` and `datas` arrays must be of the same length, regardless if the profiles do not have a follow module set.\\n     *\\n     * @param profileIds The token ID array of the profiles to follow.\\n     * @param datas The arbitrary data array to pass to the follow module for each profile if needed.\\n     *\\n     * @return uint256[] An array of integers representing the minted follow NFTs token IDs.\\n     */\\n    function follow(uint256[] calldata profileIds, bytes[] calldata datas)\\n        external\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @notice Follows a given profile via signature with the specified parameters.\\n     *\\n     * @param vars A FollowWithSigData struct containing the regular parameters as well as the signing follower's address\\n     * and an EIP712Signature struct.\\n     *\\n     * @return uint256[] An array of integers representing the minted follow NFTs token IDs.\\n     */\\n    function followWithSig(DataTypes.FollowWithSigData calldata vars)\\n        external\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @notice Collects a given publication, executing collect module logic and minting a collectNFT to the caller.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to collect.\\n     * @param pubId The publication to collect's publication ID.\\n     * @param data The arbitrary data to pass to the collect module if needed.\\n     *\\n     * @return uint256 An integer representing the minted token ID.\\n     */\\n    function collect(\\n        uint256 profileId,\\n        uint256 pubId,\\n        bytes calldata data\\n    ) external returns (uint256);\\n\\n    /**\\n     * @notice Collects a given publication via signature with the specified parameters.\\n     *\\n     * @param vars A CollectWithSigData struct containing the regular parameters as well as the collector's address and\\n     * an EIP712Signature struct.\\n     *\\n     * @return uint256 An integer representing the minted token ID.\\n     */\\n    function collectWithSig(DataTypes.CollectWithSigData calldata vars) external returns (uint256);\\n\\n    /**\\n     * @dev Helper function to emit a detailed followNFT transfer event from the hub, to be consumed by frontends to track\\n     * followNFT transfers.\\n     *\\n     * @param profileId The token ID of the profile associated with the followNFT being transferred.\\n     * @param followNFTId The followNFT being transferred's token ID.\\n     * @param from The address the followNFT is being transferred from.\\n     * @param to The address the followNFT is being transferred to.\\n     */\\n    function emitFollowNFTTransferEvent(\\n        uint256 profileId,\\n        uint256 followNFTId,\\n        address from,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @dev Helper function to emit a detailed collectNFT transfer event from the hub, to be consumed by frontends to track\\n     * collectNFT transfers.\\n     *\\n     * @param profileId The token ID of the profile associated with the collect NFT being transferred.\\n     * @param pubId The publication ID associated with the collect NFT being transferred.\\n     * @param collectNFTId The collectNFT being transferred's token ID.\\n     * @param from The address the collectNFT is being transferred from.\\n     * @param to The address the collectNFT is being transferred to.\\n     */\\n    function emitCollectNFTTransferEvent(\\n        uint256 profileId,\\n        uint256 pubId,\\n        uint256 collectNFTId,\\n        address from,\\n        address to\\n    ) external;\\n\\n    /// ************************\\n    /// *****VIEW FUNCTIONS*****\\n    /// ************************\\n\\n    /**\\n     * @notice Returns whether or not a profile creator is whitelisted.\\n     *\\n     * @param profileCreator The address of the profile creator to check.\\n     *\\n     * @return bool True if the profile creator is whitelisted, false otherwise.\\n     */\\n    function isProfileCreatorWhitelisted(address profileCreator) external view returns (bool);\\n\\n    /**\\n     * @notice Returns default profile for a given wallet address\\n     *\\n     * @param wallet The address to find the default mapping\\n     *\\n     * @return uint256 The default profile id, which will be 0 if not mapped.\\n     */\\n    function defaultProfile(address wallet) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns whether or not a follow module is whitelisted.\\n     *\\n     * @param followModule The address of the follow module to check.\\n     *\\n     * @return bool True if the the follow module is whitelisted, false otherwise.\\n     */\\n    function isFollowModuleWhitelisted(address followModule) external view returns (bool);\\n\\n    /**\\n     * @notice Returns whether or not a reference module is whitelisted.\\n     *\\n     * @param referenceModule The address of the reference module to check.\\n     *\\n     * @return bool True if the the reference module is whitelisted, false otherwise.\\n     */\\n    function isReferenceModuleWhitelisted(address referenceModule) external view returns (bool);\\n\\n    /**\\n     * @notice Returns whether or not a collect module is whitelisted.\\n     *\\n     * @param collectModule The address of the collect module to check.\\n     *\\n     * @return bool True if the the collect module is whitelisted, false otherwise.\\n     */\\n    function isCollectModuleWhitelisted(address collectModule) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the currently configured governance address.\\n     *\\n     * @return address The address of the currently configured governance.\\n     */\\n    function getGovernance() external view returns (address);\\n\\n    /**\\n     * @notice Returns the dispatcher associated with a profile.\\n     *\\n     * @param profileId The token ID of the profile to query the dispatcher for.\\n     *\\n     * @return address The dispatcher address associated with the profile.\\n     */\\n    function getDispatcher(uint256 profileId) external view returns (address);\\n\\n    /**\\n     * @notice Returns the publication count for a given profile.\\n     *\\n     * @param profileId The token ID of the profile to query.\\n     *\\n     * @return uint256 The number of publications associated with the queried profile.\\n     */\\n    function getPubCount(uint256 profileId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the followNFT associated with a given profile, if any.\\n     *\\n     * @param profileId The token ID of the profile to query the followNFT for.\\n     *\\n     * @return address The followNFT associated with the given profile.\\n     */\\n    function getFollowNFT(uint256 profileId) external view returns (address);\\n\\n    /**\\n     * @notice Returns the followNFT URI associated with a given profile.\\n     *\\n     * @param profileId The token ID of the profile to query the followNFT URI for.\\n     *\\n     * @return string The followNFT URI associated with the given profile.\\n     */\\n    function getFollowNFTURI(uint256 profileId) external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the collectNFT associated with a given publication, if any.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     *\\n     * @return address The address of the collectNFT associated with the queried publication.\\n     */\\n    function getCollectNFT(uint256 profileId, uint256 pubId) external view returns (address);\\n\\n    /**\\n     * @notice Returns the follow module associated witha  given profile, if any.\\n     *\\n     * @param profileId The token ID of the profile to query the follow module for.\\n     *\\n     * @return address The address of the follow module associated with the given profile.\\n     */\\n    function getFollowModule(uint256 profileId) external view returns (address);\\n\\n    /**\\n     * @notice Returns the collect module associated with a given publication.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     *\\n     * @return address The address of the collect module associated with the queried publication.\\n     */\\n    function getCollectModule(uint256 profileId, uint256 pubId) external view returns (address);\\n\\n    /**\\n     * @notice Returns the reference module associated witha  given profile, if any.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to querythe reference module for.\\n     * @param pubId The publication ID of the publication to query the reference module for.\\n     *\\n     * @return address The address of the reference module associated with the given profile.\\n     */\\n    function getReferenceModule(uint256 profileId, uint256 pubId) external view returns (address);\\n\\n    /**\\n     * @notice Returns the handle associated with a profile.\\n     *\\n     * @param profileId The token ID of the profile to query the handle for.\\n     *\\n     * @return string The handle associated with the profile.\\n     */\\n    function getHandle(uint256 profileId) external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the publication pointer (profileId & pubId) associated with a given publication.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query the pointer for.\\n     * @param pubId The publication ID of the publication to query the pointer for.\\n     *\\n     * @return tuple First, the profile ID of the profile the current publication is pointing to, second, the\\n     * publication ID of the publication the current publication is pointing to.\\n     */\\n    function getPubPointer(uint256 profileId, uint256 pubId)\\n        external\\n        view\\n        returns (uint256, uint256);\\n\\n    /**\\n     * @notice Returns the URI associated with a given publication.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     *\\n     * @return string The URI associated with a given publication.\\n     */\\n    function getContentURI(uint256 profileId, uint256 pubId) external view returns (string memory);\\n\\n    /**\\n     * @notice Returns the profile token ID according to a given handle.\\n     *\\n     * @param handle The handle to resolve the profile token ID with.\\n     *\\n     * @return uint256 The profile ID the passed handle points to.\\n     */\\n    function getProfileIdByHandle(string calldata handle) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the full profile struct associated with a given profile token ID.\\n     *\\n     * @param profileId The token ID of the profile to query.\\n     *\\n     * @return ProfileStruct The profile struct of the given profile.\\n     */\\n    function getProfile(uint256 profileId) external view returns (DataTypes.ProfileStruct memory);\\n\\n    /**\\n     * @notice Returns the full publication struct for a given publication.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     *\\n     * @return PublicationStruct The publication struct associated with the queried publication.\\n     */\\n    function getPub(uint256 profileId, uint256 pubId)\\n        external\\n        view\\n        returns (DataTypes.PublicationStruct memory);\\n\\n    /**\\n     * @notice Returns the publication type associated with a given publication.\\n     *\\n     * @param profileId The token ID of the profile that published the publication to query.\\n     * @param pubId The publication ID of the publication to query.\\n     *\\n     * @return PubType The publication type, as a member of an enum (either \\\"post,\\\" \\\"comment\\\" or \\\"mirror\\\").\\n     */\\n    function getPubType(uint256 profileId, uint256 pubId) external view returns (DataTypes.PubType);\\n\\n    /**\\n     * @notice Returns the follow NFT implementation address.\\n     *\\n     * @return address The follow NFT implementation address.\\n     */\\n    function getFollowNFTImpl() external view returns (address);\\n\\n    /**\\n     * @notice Returns the collect NFT implementation address.\\n     *\\n     * @return address The collect NFT implementation address.\\n     */\\n    function getCollectNFTImpl() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nlibrary Errors {\\n    error CannotInitImplementation();\\n    error Initialized();\\n    error SignatureExpired();\\n    error ZeroSpender();\\n    error SignatureInvalid();\\n    error NotOwnerOrApproved();\\n    error NotHub();\\n    error TokenDoesNotExist();\\n    error NotGovernance();\\n    error NotGovernanceOrEmergencyAdmin();\\n    error EmergencyAdminCannotUnpause();\\n    error CallerNotWhitelistedModule();\\n    error CollectModuleNotWhitelisted();\\n    error FollowModuleNotWhitelisted();\\n    error ReferenceModuleNotWhitelisted();\\n    error ProfileCreatorNotWhitelisted();\\n    error NotProfileOwner();\\n    error NotProfileOwnerOrDispatcher();\\n    error NotDispatcher();\\n    error PublicationDoesNotExist();\\n    error HandleTaken();\\n    error HandleLengthInvalid();\\n    error HandleContainsInvalidCharacters();\\n    error HandleFirstCharInvalid();\\n    error ProfileImageURILengthInvalid();\\n    error CallerNotFollowNFT();\\n    error CallerNotCollectNFT();\\n    error BlockNumberInvalid();\\n    error ArrayMismatch();\\n    error CannotCommentOnSelf();\\n    error NotWhitelisted();\\n\\n    // Module Errors\\n    error InitParamsInvalid();\\n    error CollectExpired();\\n    error FollowInvalid();\\n    error ModuleDataMismatch();\\n    error FollowNotApproved();\\n    error MintLimitExceeded();\\n    error CollectNotAllowed();\\n\\n    // MultiState Errors\\n    error Paused();\\n    error PublishingPaused();\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Events.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {DataTypes} from './DataTypes.sol';\\n\\nlibrary Events {\\n    /**\\n     * @dev Emitted when the NFT contract's name and symbol are set at initialization.\\n     *\\n     * @param name The NFT name set.\\n     * @param symbol The NFT symbol set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event BaseInitialized(string name, string symbol, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when the hub state is set.\\n     *\\n     * @param caller The caller who set the state.\\n     * @param prevState The previous protocol state, an enum of either `Paused`, `PublishingPaused` or `Unpaused`.\\n     * @param newState The newly set state, an enum of either `Paused`, `PublishingPaused` or `Unpaused`.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event StateSet(\\n        address indexed caller,\\n        DataTypes.ProtocolState indexed prevState,\\n        DataTypes.ProtocolState indexed newState,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when the governance address is changed. We emit the caller even though it should be the previous\\n     * governance address, as we cannot guarantee this will always be the case due to upgradeability.\\n     *\\n     * @param caller The caller who set the governance address.\\n     * @param prevGovernance The previous governance address.\\n     * @param newGovernance The new governance address set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event GovernanceSet(\\n        address indexed caller,\\n        address indexed prevGovernance,\\n        address indexed newGovernance,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when the emergency admin is changed. We emit the caller even though it should be the previous\\n     * governance address, as we cannot guarantee this will always be the case due to upgradeability.\\n     *\\n     * @param caller The caller who set the emergency admin address.\\n     * @param oldEmergencyAdmin The previous emergency admin address.\\n     * @param newEmergencyAdmin The new emergency admin address set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event EmergencyAdminSet(\\n        address indexed caller,\\n        address indexed oldEmergencyAdmin,\\n        address indexed newEmergencyAdmin,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a profile creator is added to or removed from the whitelist.\\n     *\\n     * @param profileCreator The address of the profile creator.\\n     * @param whitelisted Whether or not the profile creator is being added to the whitelist.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ProfileCreatorWhitelisted(\\n        address indexed profileCreator,\\n        bool indexed whitelisted,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a follow module is added to or removed from the whitelist.\\n     *\\n     * @param followModule The address of the follow module.\\n     * @param whitelisted Whether or not the follow module is being added to the whitelist.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowModuleWhitelisted(\\n        address indexed followModule,\\n        bool indexed whitelisted,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a reference module is added to or removed from the whitelist.\\n     *\\n     * @param referenceModule The address of the reference module.\\n     * @param whitelisted Whether or not the reference module is being added to the whitelist.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ReferenceModuleWhitelisted(\\n        address indexed referenceModule,\\n        bool indexed whitelisted,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a collect module is added to or removed from the whitelist.\\n     *\\n     * @param collectModule The address of the collect module.\\n     * @param whitelisted Whether or not the collect module is being added to the whitelist.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event CollectModuleWhitelisted(\\n        address indexed collectModule,\\n        bool indexed whitelisted,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a profile is created.\\n     *\\n     * @param profileId The newly created profile's token ID.\\n     * @param creator The profile creator, who created the token with the given profile ID.\\n     * @param to The address receiving the profile with the given profile ID.\\n     * @param handle The handle set for the profile.\\n     * @param imageURI The image uri set for the profile.\\n     * @param followModule The profile's newly set follow module. This CAN be the zero address.\\n     * @param followModuleReturnData The data returned from the follow module's initialization. This is abi encoded\\n     * and totally depends on the follow module chosen.\\n     * @param followNFTURI The URI set for the profile's follow NFT.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ProfileCreated(\\n        uint256 indexed profileId,\\n        address indexed creator,\\n        address indexed to,\\n        string handle,\\n        string imageURI,\\n        address followModule,\\n        bytes followModuleReturnData,\\n        string followNFTURI,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a a default profile is set for a wallet as its main identity\\n     *\\n     * @param wallet The wallet which set or unset its default profile.\\n     * @param profileId The token ID of the profile being set as default, or zero.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event DefaultProfileSet(address indexed wallet, uint256 indexed profileId, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when a dispatcher is set for a specific profile.\\n     *\\n     * @param profileId The token ID of the profile for which the dispatcher is set.\\n     * @param dispatcher The dispatcher set for the given profile.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event DispatcherSet(uint256 indexed profileId, address indexed dispatcher, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when a profile's URI is set.\\n     *\\n     * @param profileId The token ID of the profile for which the URI is set.\\n     * @param imageURI The URI set for the given profile.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ProfileImageURISet(uint256 indexed profileId, string imageURI, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when a follow NFT's URI is set.\\n     *\\n     * @param profileId The token ID of the profile for which the followNFT URI is set.\\n     * @param followNFTURI The follow NFT URI set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowNFTURISet(uint256 indexed profileId, string followNFTURI, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when a profile's follow module is set.\\n     *\\n     * @param profileId The profile's token ID.\\n     * @param followModule The profile's newly set follow module. This CAN be the zero address.\\n     * @param followModuleReturnData The data returned from the follow module's initialization. This is abi encoded\\n     * and totally depends on the follow module chosen.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowModuleSet(\\n        uint256 indexed profileId,\\n        address followModule,\\n        bytes followModuleReturnData,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a \\\"post\\\" is published.\\n     *\\n     * @param profileId The profile's token ID.\\n     * @param pubId The new publication's ID.\\n     * @param contentURI The URI mapped to this new publication.\\n     * @param collectModule The collect module mapped to this new publication. This CANNOT be the zero address.\\n     * @param collectModuleReturnData The data returned from the collect module's initialization for this given\\n     * publication. This is abi encoded and totally depends on the collect module chosen.\\n     * @param referenceModule The reference module set for this publication.\\n     * @param referenceModuleReturnData The data returned from the reference module at initialization. This is abi\\n     * encoded and totally depends on the reference module chosen.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event PostCreated(\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        string contentURI,\\n        address collectModule,\\n        bytes collectModuleReturnData,\\n        address referenceModule,\\n        bytes referenceModuleReturnData,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a \\\"comment\\\" is published.\\n     *\\n     * @param profileId The profile's token ID.\\n     * @param pubId The new publication's ID.\\n     * @param contentURI The URI mapped to this new publication.\\n     * @param profileIdPointed The profile token ID that this comment points to.\\n     * @param pubIdPointed The publication ID that this comment points to.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param collectModule The collect module mapped to this new publication. This CANNOT be the zero address.\\n     * @param collectModuleReturnData The data returned from the collect module's initialization for this given\\n     * publication. This is abi encoded and totally depends on the collect module chosen.\\n     * @param referenceModule The reference module set for this publication.\\n     * @param referenceModuleReturnData The data returned from the reference module at initialization. This is abi\\n     * encoded and totally depends on the reference module chosen.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event CommentCreated(\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        string contentURI,\\n        uint256 profileIdPointed,\\n        uint256 pubIdPointed,\\n        bytes referenceModuleData,\\n        address collectModule,\\n        bytes collectModuleReturnData,\\n        address referenceModule,\\n        bytes referenceModuleReturnData,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a \\\"mirror\\\" is published.\\n     *\\n     * @param profileId The profile's token ID.\\n     * @param pubId The new publication's ID.\\n     * @param profileIdPointed The profile token ID that this mirror points to.\\n     * @param pubIdPointed The publication ID that this mirror points to.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param referenceModule The reference module set for this publication.\\n     * @param referenceModuleReturnData The data returned from the reference module at initialization. This is abi\\n     * encoded and totally depends on the reference module chosen.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event MirrorCreated(\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        uint256 profileIdPointed,\\n        uint256 pubIdPointed,\\n        bytes referenceModuleData,\\n        address referenceModule,\\n        bytes referenceModuleReturnData,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a followNFT clone is deployed using a lazy deployment pattern.\\n     *\\n     * @param profileId The token ID of the profile to which this followNFT is associated.\\n     * @param followNFT The address of the newly deployed followNFT clone.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowNFTDeployed(\\n        uint256 indexed profileId,\\n        address indexed followNFT,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a collectNFT clone is deployed using a lazy deployment pattern.\\n     *\\n     * @param profileId The publisher's profile token ID.\\n     * @param pubId The publication associated with the newly deployed collectNFT clone's ID.\\n     * @param collectNFT The address of the newly deployed collectNFT clone.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event CollectNFTDeployed(\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        address indexed collectNFT,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted upon a successful collect action.\\n     *\\n     * @param collector The address collecting the publication.\\n     * @param profileId The token ID of the profile that the collect was initiated towards, useful to differentiate mirrors.\\n     * @param pubId The publication ID that the collect was initiated towards, useful to differentiate mirrors.\\n     * @param rootProfileId The profile token ID of the profile whose publication is being collected.\\n     * @param rootPubId The publication ID of the publication being collected.\\n     * @param collectModuleData The data passed to the collect module.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event Collected(\\n        address indexed collector,\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        uint256 rootProfileId,\\n        uint256 rootPubId,\\n        bytes collectModuleData,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted upon a successful follow action.\\n     *\\n     * @param follower The address following the given profiles.\\n     * @param profileIds The token ID array of the profiles being followed.\\n     * @param followModuleDatas The array of data parameters passed to each follow module.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event Followed(\\n        address indexed follower,\\n        uint256[] profileIds,\\n        bytes[] followModuleDatas,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted via callback when a followNFT is transferred.\\n     *\\n     * @param profileId The token ID of the profile associated with the followNFT being transferred.\\n     * @param followNFTId The followNFT being transferred's token ID.\\n     * @param from The address the followNFT is being transferred from.\\n     * @param to The address the followNFT is being transferred to.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowNFTTransferred(\\n        uint256 indexed profileId,\\n        uint256 indexed followNFTId,\\n        address from,\\n        address to,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted via callback when a collectNFT is transferred.\\n     *\\n     * @param profileId The token ID of the profile associated with the collectNFT being transferred.\\n     * @param pubId The publication ID associated with the collectNFT being transferred.\\n     * @param collectNFTId The collectNFT being transferred's token ID.\\n     * @param from The address the collectNFT is being transferred from.\\n     * @param to The address the collectNFT is being transferred to.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event CollectNFTTransferred(\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        uint256 indexed collectNFTId,\\n        address from,\\n        address to,\\n        uint256 timestamp\\n    );\\n\\n    // Collect/Follow NFT-Specific\\n\\n    /**\\n     * @dev Emitted when a newly deployed follow NFT is initialized.\\n     *\\n     * @param profileId The token ID of the profile connected to this follow NFT.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowNFTInitialized(uint256 indexed profileId, uint256 timestamp);\\n\\n    /**\\n     * @dev Emitted when delegation power in a FollowNFT is changed.\\n     *\\n     * @param delegate The delegate whose power has been changed.\\n     * @param newPower The new governance power mapped to the delegate.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowNFTDelegatedPowerChanged(\\n        address indexed delegate,\\n        uint256 indexed newPower,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when a newly deployed collect NFT is initialized.\\n     *\\n     * @param profileId The token ID of the profile connected to the publication mapped to this collect NFT.\\n     * @param pubId The publication ID connected to the publication mapped to this collect NFT.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event CollectNFTInitialized(\\n        uint256 indexed profileId,\\n        uint256 indexed pubId,\\n        uint256 timestamp\\n    );\\n\\n    // Module-Specific\\n\\n    /**\\n     * @notice Emitted when the ModuleGlobals governance address is set.\\n     *\\n     * @param prevGovernance The previous governance address.\\n     * @param newGovernance The new governance address set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ModuleGlobalsGovernanceSet(\\n        address indexed prevGovernance,\\n        address indexed newGovernance,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Emitted when the ModuleGlobals treasury address is set.\\n     *\\n     * @param prevTreasury The previous treasury address.\\n     * @param newTreasury The new treasury address set.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ModuleGlobalsTreasurySet(\\n        address indexed prevTreasury,\\n        address indexed newTreasury,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Emitted when the ModuleGlobals treasury fee is set.\\n     *\\n     * @param prevTreasuryFee The previous treasury fee in BPS.\\n     * @param newTreasuryFee The new treasury fee in BPS.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ModuleGlobalsTreasuryFeeSet(\\n        uint16 indexed prevTreasuryFee,\\n        uint16 indexed newTreasuryFee,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Emitted when a currency is added to or removed from the ModuleGlobals whitelist.\\n     *\\n     * @param currency The currency address.\\n     * @param prevWhitelisted Whether or not the currency was previously whitelisted.\\n     * @param whitelisted Whether or not the currency is whitelisted.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ModuleGlobalsCurrencyWhitelisted(\\n        address indexed currency,\\n        bool indexed prevWhitelisted,\\n        bool indexed whitelisted,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @notice Emitted when a module inheriting from the `FeeModuleBase` is constructed.\\n     *\\n     * @param moduleGlobals The ModuleGlobals contract address used.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FeeModuleBaseConstructed(address indexed moduleGlobals, uint256 timestamp);\\n\\n    /**\\n     * @notice Emitted when a module inheriting from the `ModuleBase` is constructed.\\n     *\\n     * @param hub The LensHub contract address used.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ModuleBaseConstructed(address indexed hub, uint256 timestamp);\\n\\n    /**\\n     * @notice Emitted when one or multiple addresses are approved (or disapproved) for following in\\n     * the `ApprovalFollowModule`.\\n     *\\n     * @param owner The profile owner who executed the approval.\\n     * @param profileId The profile ID that the follow approvals are granted/revoked for.\\n     * @param addresses The addresses that have had the follow approvals grnated/revoked.\\n     * @param approved Whether each corresponding address is now approved or disapproved.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowsApproved(\\n        address indexed owner,\\n        uint256 indexed profileId,\\n        address[] addresses,\\n        bool[] approved,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when the user wants to enable or disable follows in the `LensPeriphery`.\\n     *\\n     * @param owner The profile owner who executed the toggle.\\n     * @param profileIds The array of token IDs of the profiles each followNFT is associated with.\\n     * @param enabled The array of whether each FollowNFT's follow is enabled/disabled.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event FollowsToggled(\\n        address indexed owner,\\n        uint256[] profileIds,\\n        bool[] enabled,\\n        uint256 timestamp\\n    );\\n\\n    /**\\n     * @dev Emitted when the metadata associated with a profile is set in the `LensPeriphery`.\\n     *\\n     * @param profileId The profile ID the metadata is set for.\\n     * @param metadata The metadata set for the profile and user.\\n     * @param timestamp The current block timestamp.\\n     */\\n    event ProfileMetadataSet(uint256 indexed profileId, string metadata, uint256 timestamp);\\n}\\n\"\r\n    },\r\n    \"contracts/core/base/LensNFTBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {ILensNFTBase} from '../../interfaces/ILensNFTBase.sol';\\nimport {Errors} from '../../libraries/Errors.sol';\\nimport {DataTypes} from '../../libraries/DataTypes.sol';\\nimport {Events} from '../../libraries/Events.sol';\\nimport {ERC721Time} from './ERC721Time.sol';\\nimport {ERC721Enumerable} from './ERC721Enumerable.sol';\\n\\n/**\\n * @title LensNFTBase\\n * @author Lens Protocol\\n *\\n * @notice This is an abstract base contract to be inherited by other Lens Protocol NFTs, it includes\\n * the slightly modified ERC721Enumerable, which itself inherits from the ERC721Time-- which adds an\\n * internal operator approval setter, stores the mint timestamp for each token, and replaces the\\n * constructor with an initializer.\\n */\\nabstract contract LensNFTBase is ERC721Enumerable, ILensNFTBase {\\n    bytes32 internal constant EIP712_REVISION_HASH = keccak256('1');\\n    bytes32 internal constant PERMIT_TYPEHASH =\\n        keccak256('Permit(address spender,uint256 tokenId,uint256 nonce,uint256 deadline)');\\n    bytes32 internal constant PERMIT_FOR_ALL_TYPEHASH =\\n        keccak256(\\n            'PermitForAll(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)'\\n        );\\n    bytes32 internal constant BURN_WITH_SIG_TYPEHASH =\\n        keccak256('BurnWithSig(uint256 tokenId,uint256 nonce,uint256 deadline)');\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\\n        keccak256(\\n            'EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'\\n        );\\n\\n    mapping(address => uint256) public sigNonces;\\n\\n    /**\\n     * @notice Initializer sets the name, symbol and the cached domain separator.\\n     *\\n     * NOTE: Inheritor contracts *must* call this function to initialize the name & symbol in the\\n     * inherited ERC721 contract.\\n     *\\n     * @param name The name to set in the ERC721 contract.\\n     * @param symbol The symbol to set in the ERC721 contract.\\n     */\\n    function _initialize(string calldata name, string calldata symbol) internal {\\n        ERC721Time.__ERC721_Init(name, symbol);\\n\\n        emit Events.BaseInitialized(name, symbol, block.timestamp);\\n    }\\n\\n    /// @inheritdoc ILensNFTBase\\n    function permit(\\n        address spender,\\n        uint256 tokenId,\\n        DataTypes.EIP712Signature calldata sig\\n    ) external override {\\n        if (spender == address(0)) revert Errors.ZeroSpender();\\n        address owner = ownerOf(tokenId);\\n        unchecked {\\n            _validateRecoveredAddress(\\n                _calculateDigest(\\n                    keccak256(\\n                        abi.encode(\\n                            PERMIT_TYPEHASH,\\n                            spender,\\n                            tokenId,\\n                            sigNonces[owner]++,\\n                            sig.deadline\\n                        )\\n                    )\\n                ),\\n                owner,\\n                sig\\n            );\\n        }\\n        _approve(spender, tokenId);\\n    }\\n\\n    /// @inheritdoc ILensNFTBase\\n    function permitForAll(\\n        address owner,\\n        address operator,\\n        bool approved,\\n        DataTypes.EIP712Signature calldata sig\\n    ) external override {\\n        if (operator == address(0)) revert Errors.ZeroSpender();\\n        unchecked {\\n            _validateRecoveredAddress(\\n                _calculateDigest(\\n                    keccak256(\\n                        abi.encode(\\n                            PERMIT_FOR_ALL_TYPEHASH,\\n                            owner,\\n                            operator,\\n                            approved,\\n                            sigNonces[owner]++,\\n                            sig.deadline\\n                        )\\n                    )\\n                ),\\n                owner,\\n                sig\\n            );\\n        }\\n        _setOperatorApproval(owner, operator, approved);\\n    }\\n\\n    /// @inheritdoc ILensNFTBase\\n    function getDomainSeparator() external view override returns (bytes32) {\\n        return _calculateDomainSeparator();\\n    }\\n\\n    /// @inheritdoc ILensNFTBase\\n    function burn(uint256 tokenId) public virtual override {\\n        if (!_isApprovedOrOwner(msg.sender, tokenId)) revert Errors.NotOwnerOrApproved();\\n        _burn(tokenId);\\n    }\\n\\n    /// @inheritdoc ILensNFTBase\\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig)\\n        public\\n        virtual\\n        override\\n    {\\n        address owner = ownerOf(tokenId);\\n        unchecked {\\n            _validateRecoveredAddress(\\n                _calculateDigest(\\n                    keccak256(\\n                        abi.encode(\\n                            BURN_WITH_SIG_TYPEHASH,\\n                            tokenId,\\n                            sigNonces[owner]++,\\n                            sig.deadline\\n                        )\\n                    )\\n                ),\\n                owner,\\n                sig\\n            );\\n        }\\n        _burn(tokenId);\\n    }\\n\\n    /**\\n     * @dev Wrapper for ecrecover to reduce code size, used in meta-tx specific functions.\\n     */\\n    function _validateRecoveredAddress(\\n        bytes32 digest,\\n        address expectedAddress,\\n        DataTypes.EIP712Signature calldata sig\\n    ) internal view {\\n        if (sig.deadline < block.timestamp) revert Errors.SignatureExpired();\\n        address recoveredAddress = ecrecover(digest, sig.v, sig.r, sig.s);\\n        if (recoveredAddress == address(0) || recoveredAddress != expectedAddress)\\n            revert Errors.SignatureInvalid();\\n    }\\n\\n    /**\\n     * @dev Calculates EIP712 DOMAIN_SEPARATOR based on the current contract and chain ID.\\n     */\\n    function _calculateDomainSeparator() internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    EIP712_DOMAIN_TYPEHASH,\\n                    keccak256(bytes(name())),\\n                    EIP712_REVISION_HASH,\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /**\\n     * @dev Calculates EIP712 digest based on the current DOMAIN_SEPARATOR.\\n     *\\n     * @param hashedMessage The message hash from which the digest should be calculated.\\n     *\\n     * @return bytes32 A 32-byte output representing the EIP712 digest.\\n     */\\n    function _calculateDigest(bytes32 hashedMessage) internal view returns (bytes32) {\\n        bytes32 digest;\\n        unchecked {\\n            digest = keccak256(\\n                abi.encodePacked('\\\\x19\\\\x01', _calculateDomainSeparator(), hashedMessage)\\n            );\\n        }\\n        return digest;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/DataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\n/**\\n * @title DataTypes\\n * @author Lens Protocol\\n *\\n * @notice A standard library of data types used throughout the Lens Protocol.\\n */\\nlibrary DataTypes {\\n    /**\\n     * @notice An enum containing the different states the protocol can be in, limiting certain actions.\\n     *\\n     * @param Unpaused The fully unpaused state.\\n     * @param PublishingPaused The state where only publication creation functions are paused.\\n     * @param Paused The fully paused state.\\n     */\\n    enum ProtocolState {\\n        Unpaused,\\n        PublishingPaused,\\n        Paused\\n    }\\n\\n    /**\\n     * @notice An enum specifically used in a helper function to easily retrieve the publication type for integrations.\\n     *\\n     * @param Post A standard post, having a URI, a collect module but no pointer to another publication.\\n     * @param Comment A comment, having a URI, a collect module and a pointer to another publication.\\n     * @param Mirror A mirror, having a pointer to another publication, but no URI or collect module.\\n     * @param Nonexistent An indicator showing the queried publication does not exist.\\n     */\\n    enum PubType {\\n        Post,\\n        Comment,\\n        Mirror,\\n        Nonexistent\\n    }\\n\\n    /**\\n     * @notice A struct containing the necessary information to reconstruct an EIP-712 typed data signature.\\n     *\\n     * @param v The signature's recovery parameter.\\n     * @param r The signature's r parameter.\\n     * @param s The signature's s parameter\\n     * @param deadline The signature's deadline\\n     */\\n    struct EIP712Signature {\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n        uint256 deadline;\\n    }\\n\\n    /**\\n     * @notice A struct containing profile data.\\n     *\\n     * @param pubCount The number of publications made to this profile.\\n     * @param followModule The address of the current follow module in use by this profile, can be empty.\\n     * @param followNFT The address of the followNFT associated with this profile, can be empty..\\n     * @param handle The profile's associated handle.\\n     * @param imageURI The URI to be used for the profile's image.\\n     * @param followNFTURI The URI to be used for the follow NFT.\\n     */\\n    struct ProfileStruct {\\n        uint256 pubCount;\\n        address followModule;\\n        address followNFT;\\n        string handle;\\n        string imageURI;\\n        string followNFTURI;\\n    }\\n\\n    /**\\n     * @notice A struct containing data associated with each new publication.\\n     *\\n     * @param profileIdPointed The profile token ID this publication points to, for mirrors and comments.\\n     * @param pubIdPointed The publication ID this publication points to, for mirrors and comments.\\n     * @param contentURI The URI associated with this publication.\\n     * @param referenceModule The address of the current reference module in use by this profile, can be empty.\\n     * @param collectModule The address of the collect module associated with this publication, this exists for all publication.\\n     * @param collectNFT The address of the collectNFT associated with this publication, if any.\\n     */\\n    struct PublicationStruct {\\n        uint256 profileIdPointed;\\n        uint256 pubIdPointed;\\n        string contentURI;\\n        address referenceModule;\\n        address collectModule;\\n        address collectNFT;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `createProfile()` function.\\n     *\\n     * @param to The address receiving the profile.\\n     * @param handle The handle to set for the profile, must be unique and non-empty.\\n     * @param imageURI The URI to set for the profile image.\\n     * @param followModule The follow module to use, can be the zero address.\\n     * @param followModuleInitData The follow module initialization data, if any.\\n     * @param followNFTURI The URI to use for the follow NFT.\\n     */\\n    struct CreateProfileData {\\n        address to;\\n        string handle;\\n        string imageURI;\\n        address followModule;\\n        bytes followModuleInitData;\\n        string followNFTURI;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `setDefaultProfileWithSig()` function. Parameters are\\n     * the same as the regular `setDefaultProfile()` function, with an added EIP712Signature.\\n     *\\n     * @param wallet The address of the wallet setting the default profile.\\n     * @param profileId The token ID of the profile which will be set as default, or zero.\\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\\n     */\\n    struct SetDefaultProfileWithSigData {\\n        address wallet;\\n        uint256 profileId;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `setFollowModuleWithSig()` function. Parameters are\\n     * the same as the regular `setFollowModule()` function, with an added EIP712Signature.\\n     *\\n     * @param profileId The token ID of the profile to change the followModule for.\\n     * @param followModule The followModule to set for the given profile, must be whitelisted.\\n     * @param followModuleInitData The data to be passed to the followModule for initialization.\\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\\n     */\\n    struct SetFollowModuleWithSigData {\\n        uint256 profileId;\\n        address followModule;\\n        bytes followModuleInitData;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `setDispatcherWithSig()` function. Parameters are the same\\n     * as the regular `setDispatcher()` function, with an added EIP712Signature.\\n     *\\n     * @param profileId The token ID of the profile to set the dispatcher for.\\n     * @param dispatcher The dispatcher address to set for the profile.\\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\\n     */\\n    struct SetDispatcherWithSigData {\\n        uint256 profileId;\\n        address dispatcher;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `setProfileImageURIWithSig()` function. Parameters are the same\\n     * as the regular `setProfileImageURI()` function, with an added EIP712Signature.\\n     *\\n     * @param profileId The token ID of the profile to set the URI for.\\n     * @param imageURI The URI to set for the given profile image.\\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\\n     */\\n    struct SetProfileImageURIWithSigData {\\n        uint256 profileId;\\n        string imageURI;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `setFollowNFTURIWithSig()` function. Parameters are the same\\n     * as the regular `setFollowNFTURI()` function, with an added EIP712Signature.\\n     *\\n     * @param profileId The token ID of the profile for which to set the followNFT URI.\\n     * @param followNFTURI The follow NFT URI to set.\\n     * @param sig The EIP712Signature struct containing the followNFT's associated profile owner's signature.\\n     */\\n    struct SetFollowNFTURIWithSigData {\\n        uint256 profileId;\\n        string followNFTURI;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `post()` function.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param contentURI The URI to set for this new publication.\\n     * @param collectModule The collect module to set for this new publication.\\n     * @param collectModuleInitData The data to pass to the collect module's initialization.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     */\\n    struct PostData {\\n        uint256 profileId;\\n        string contentURI;\\n        address collectModule;\\n        bytes collectModuleInitData;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `postWithSig()` function. Parameters are the same as\\n     * the regular `post()` function, with an added EIP712Signature.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param contentURI The URI to set for this new publication.\\n     * @param collectModule The collectModule to set for this new publication.\\n     * @param collectModuleInitData The data to pass to the collectModule's initialization.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\\n     */\\n    struct PostWithSigData {\\n        uint256 profileId;\\n        string contentURI;\\n        address collectModule;\\n        bytes collectModuleInitData;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `comment()` function.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param contentURI The URI to set for this new publication.\\n     * @param profileIdPointed The profile token ID to point the comment to.\\n     * @param pubIdPointed The publication ID to point the comment to.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param collectModule The collect module to set for this new publication.\\n     * @param collectModuleInitData The data to pass to the collect module's initialization.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     */\\n    struct CommentData {\\n        uint256 profileId;\\n        string contentURI;\\n        uint256 profileIdPointed;\\n        uint256 pubIdPointed;\\n        bytes referenceModuleData;\\n        address collectModule;\\n        bytes collectModuleInitData;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `commentWithSig()` function. Parameters are the same as\\n     * the regular `comment()` function, with an added EIP712Signature.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param contentURI The URI to set for this new publication.\\n     * @param profileIdPointed The profile token ID to point the comment to.\\n     * @param pubIdPointed The publication ID to point the comment to.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param collectModule The collectModule to set for this new publication.\\n     * @param collectModuleInitData The data to pass to the collectModule's initialization.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\\n     */\\n    struct CommentWithSigData {\\n        uint256 profileId;\\n        string contentURI;\\n        uint256 profileIdPointed;\\n        uint256 pubIdPointed;\\n        bytes referenceModuleData;\\n        address collectModule;\\n        bytes collectModuleInitData;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `mirror()` function.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param profileIdPointed The profile token ID to point the mirror to.\\n     * @param pubIdPointed The publication ID to point the mirror to.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     */\\n    struct MirrorData {\\n        uint256 profileId;\\n        uint256 profileIdPointed;\\n        uint256 pubIdPointed;\\n        bytes referenceModuleData;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `mirrorWithSig()` function. Parameters are the same as\\n     * the regular `mirror()` function, with an added EIP712Signature.\\n     *\\n     * @param profileId The token ID of the profile to publish to.\\n     * @param profileIdPointed The profile token ID to point the mirror to.\\n     * @param pubIdPointed The publication ID to point the mirror to.\\n     * @param referenceModuleData The data passed to the reference module.\\n     * @param referenceModule The reference module to set for the given publication, must be whitelisted.\\n     * @param referenceModuleInitData The data to be passed to the reference module for initialization.\\n     * @param sig The EIP712Signature struct containing the profile owner's signature.\\n     */\\n    struct MirrorWithSigData {\\n        uint256 profileId;\\n        uint256 profileIdPointed;\\n        uint256 pubIdPointed;\\n        bytes referenceModuleData;\\n        address referenceModule;\\n        bytes referenceModuleInitData;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `followWithSig()` function. Parameters are the same\\n     * as the regular `follow()` function, with the follower's (signer) address and an EIP712Signature added.\\n     *\\n     * @param follower The follower which is the message signer.\\n     * @param profileIds The array of token IDs of the profiles to follow.\\n     * @param datas The array of arbitrary data to pass to the followModules if needed.\\n     * @param sig The EIP712Signature struct containing the follower's signature.\\n     */\\n    struct FollowWithSigData {\\n        address follower;\\n        uint256[] profileIds;\\n        bytes[] datas;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `collectWithSig()` function. Parameters are the same as\\n     * the regular `collect()` function, with the collector's (signer) address and an EIP712Signature added.\\n     *\\n     * @param collector The collector which is the message signer.\\n     * @param profileId The token ID of the profile that published the publication to collect.\\n     * @param pubId The publication to collect's publication ID.\\n     * @param data The arbitrary data to pass to the collectModule if needed.\\n     * @param sig The EIP712Signature struct containing the collector's signature.\\n     */\\n    struct CollectWithSigData {\\n        address collector;\\n        uint256 profileId;\\n        uint256 pubId;\\n        bytes data;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `setProfileMetadataWithSig()` function.\\n     *\\n     * @param profileId The profile ID for which to set the metadata.\\n     * @param metadata The metadata string to set for the profile and user.\\n     * @param sig The EIP712Signature struct containing the user's signature.\\n     */\\n    struct SetProfileMetadataWithSigData {\\n        uint256 profileId;\\n        string metadata;\\n        EIP712Signature sig;\\n    }\\n\\n    /**\\n     * @notice A struct containing the parameters required for the `toggleFollowWithSig()` function.\\n     *\\n     * @param follower The follower which is the message signer.\\n     * @param profileIds The token ID array of the profiles.\\n     * @param enables The array of booleans to enable/disable follows.\\n     * @param sig The EIP712Signature struct containing the follower's signature.\\n     */\\n    struct ToggleFollowWithSigData {\\n        address follower;\\n        uint256[] profileIds;\\n        bool[] enables;\\n        EIP712Signature sig;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILensNFTBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.10;\\n\\nimport {DataTypes} from '../libraries/DataTypes.sol';\\n\\n/**\\n * @title ILensNFTBase\\n * @author Lens Protocol\\n *\\n * @notice This is the interface for the LensNFTBase contract, from which all Lens NFTs inherit.\\n * It is an expansion of a very slightly modified ERC721Enumerable contract, which allows expanded\\n * meta-transaction functionality.\\n */\\ninterface ILensNFTBase {\\n    /**\\n     * @notice Implementation of an EIP-712 permit function for an ERC-721 NFT. We don't need to check\\n     * if the tokenId exists, since the function calls ownerOf(tokenId), which reverts if the tokenId does\\n     * not exist.\\n     *\\n     * @param spender The NFT spender.\\n     * @param tokenId The NFT token ID to approve.\\n     * @param sig The EIP712 signature struct.\\n     */\\n    function permit(\\n        address spender,\\n        uint256 tokenId,\\n        DataTypes.EIP712Signature calldata sig\\n    ) external;\\n\\n    /**\\n     * @notice Implementation of an EIP-712 permit-style function for ERC-721 operator approvals. Allows\\n     * an operator address to control all NFTs a given owner owns.\\n     *\\n     * @param owner The owner to set operator approvals for.\\n     * @param operator The operator to approve.\\n     * @param approved Whether to approve or revoke approval from the operator.\\n     * @param sig The EIP712 signature struct.\\n     */\\n    function permitForAll(\\n        address owner,\\n        address operator,\\n        bool approved,\\n        DataTypes.EIP712Signature calldata sig\\n    ) external;\\n\\n    /**\\n     * @notice Burns an NFT, removing it from circulation and essentially destroying it. This function can only\\n     * be called by the NFT to burn's owner.\\n     *\\n     * @param tokenId The token ID of the token to burn.\\n     */\\n    function burn(uint256 tokenId) external;\\n\\n    /**\\n     * @notice Implementation of an EIP-712 permit-style function for token burning. Allows anyone to burn\\n     * a token on behalf of the owner with a signature.\\n     *\\n     * @param tokenId The token ID of the token to burn.\\n     * @param sig The EIP712 signature struct.\\n     */\\n    function burnWithSig(uint256 tokenId, DataTypes.EIP712Signature calldata sig) external;\\n\\n    /**\\n     * @notice Returns the domain separator for this NFT contract.\\n     *\\n     * @return bytes32 The domain separator.\\n     */\\n    function getDomainSeparator() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/core/base/ERC721Time.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport './IERC721Time.sol';\\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\nimport '@openzeppelin/contracts/utils/Address.sol';\\nimport '@openzeppelin/contracts/utils/Context.sol';\\nimport '@openzeppelin/contracts/utils/Strings.sol';\\nimport '@openzeppelin/contracts/utils/introspection/ERC165.sol';\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n *\\n * Modifications:\\n * 1. Refactored _operatorApprovals setter into an internal function to allow meta-transactions.\\n * 2. Constructor replaced with an initializer.\\n * 3. Mint timestamp is now stored in a TokenData struct alongside the owner address.\\n */\\nabstract contract ERC721Time is Context, ERC165, IERC721Time, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to token Data (owner address and mint timestamp uint96), this\\n    // replaces the original mapping(uint256 => address) private _owners;\\n    mapping(uint256 => IERC721Time.TokenData) private _tokenData;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the ERC721 name and symbol.\\n     *\\n     * @param name The name to set.\\n     * @param symbol The symbol to set.\\n     */\\n    function __ERC721_Init(string calldata name, string calldata symbol) internal {\\n        _name = name;\\n        _symbol = symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC165, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), 'ERC721: balance query for the zero address');\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _tokenData[tokenId].owner;\\n        require(owner != address(0), 'ERC721: owner query for nonexistent token');\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Time-mintTimestampOf}\\n     */\\n    function mintTimestampOf(uint256 tokenId) public view virtual override returns (uint256) {\\n        uint96 mintTimestamp = _tokenData[tokenId].mintTimestamp;\\n        require(mintTimestamp != 0, 'ERC721: mint timestamp query for nonexistent token');\\n        return mintTimestamp;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Time-mintTimestampOf}\\n     */\\n    function tokenDataOf(uint256 tokenId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (IERC721Time.TokenData memory)\\n    {\\n        require(_exists(tokenId), 'ERC721: token data query for nonexistent token');\\n        return _tokenData[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Time-exists}\\n     */\\n    function exists(uint256 tokenId) public view virtual override returns (bool) {\\n        return _exists(tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), 'ERC721Metadata: URI query for nonexistent token');\\n\\n        string memory baseURI = _baseURI();\\n        return\\n            bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : '';\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return '';\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721Time.ownerOf(tokenId);\\n        require(to != owner, 'ERC721: approval to current owner');\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            'ERC721: approve caller is not owner nor approved for all'\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), 'ERC721: approved query for nonexistent token');\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), 'ERC721: approve to caller');\\n\\n        _setOperatorApproval(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(\\n            _isApprovedOrOwner(_msgSender(), tokenId),\\n            'ERC721: transfer caller is not owner nor approved'\\n        );\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(\\n            _isApprovedOrOwner(_msgSender(), tokenId),\\n            'ERC721: transfer caller is not owner nor approved'\\n        );\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(\\n            _checkOnERC721Received(from, to, tokenId, _data),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _tokenData[tokenId].owner != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId)\\n        internal\\n        view\\n        virtual\\n        returns (bool)\\n    {\\n        require(_exists(tokenId), 'ERC721: operator query for nonexistent token');\\n        address owner = ERC721Time.ownerOf(tokenId);\\n        return (spender == owner ||\\n            getApproved(tokenId) == spender ||\\n            isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, '');\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            'ERC721: transfer to non ERC721Receiver implementer'\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), 'ERC721: mint to the zero address');\\n        require(!_exists(tokenId), 'ERC721: token already minted');\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _tokenData[tokenId].owner = to;\\n        _tokenData[tokenId].mintTimestamp = uint96(block.timestamp);\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721Time.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _tokenData[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721Time.ownerOf(tokenId) == from, 'ERC721: transfer of token that is not own');\\n        require(to != address(0), 'ERC721: transfer to the zero address');\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _tokenData[tokenId].owner = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721Time.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Refactored from the original OZ ERC721 implementation: approve or revoke approval from\\n     * `operator` to operate on all tokens owned by `owner`.\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setOperatorApproval(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (\\n                bytes4 retval\\n            ) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert('ERC721: transfer to non ERC721Receiver implementer');\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"contracts/core/base/ERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport './ERC721Time.sol';\\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\\n\\n/**\\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\\n * enumerability of all the token ids in the contract as well as all token ids owned by each\\n * account.\\n *\\n * NOTE: Modified from Openzeppelin to inherit from a modified ERC721 contract.\\n */\\nabstract contract ERC721Enumerable is ERC721Time, IERC721Enumerable {\\n    // Mapping from owner to list of owned token IDs\\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\\n\\n    // Mapping from token ID to index of the owner tokens list\\n    mapping(uint256 => uint256) private _ownedTokensIndex;\\n\\n    // Array with all token ids, used for enumeration\\n    uint256[] private _allTokens;\\n\\n    // Mapping from token id to position in the allTokens array\\n    mapping(uint256 => uint256) private _allTokensIndex;\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(IERC165, ERC721Time)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC721Enumerable).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        require(index < ERC721Time.balanceOf(owner), 'ERC721Enumerable: owner index out of bounds');\\n        return _ownedTokens[owner][index];\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _allTokens.length;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Enumerable-tokenByIndex}.\\n     */\\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\\n        require(\\n            index < ERC721Enumerable.totalSupply(),\\n            'ERC721Enumerable: global index out of bounds'\\n        );\\n        return _allTokens[index];\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual override {\\n        super._beforeTokenTransfer(from, to, tokenId);\\n\\n        if (from == address(0)) {\\n            _addTokenToAllTokensEnumeration(tokenId);\\n        } else if (from != to) {\\n            _removeTokenFromOwnerEnumeration(from, tokenId);\\n        }\\n        if (to == address(0)) {\\n            _removeTokenFromAllTokensEnumeration(tokenId);\\n        } else if (to != from) {\\n            _addTokenToOwnerEnumeration(to, tokenId);\\n        }\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\\n     * @param to address representing the new owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\\n     */\\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\\n        uint256 length = ERC721Time.balanceOf(to);\\n        _ownedTokens[to][length] = tokenId;\\n        _ownedTokensIndex[tokenId] = length;\\n    }\\n\\n    /**\\n     * @dev Private function to add a token to this extension's token tracking data structures.\\n     * @param tokenId uint256 ID of the token to be added to the tokens list\\n     */\\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\\n        _allTokensIndex[tokenId] = _allTokens.length;\\n        _allTokens.push(tokenId);\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\\n     * @param from address representing the previous owner of the given token ID\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\\n     */\\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = ERC721Time.balanceOf(from) - 1;\\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary\\n        if (tokenIndex != lastTokenIndex) {\\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\\n\\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n        }\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _ownedTokensIndex[tokenId];\\n        delete _ownedTokens[from][lastTokenIndex];\\n    }\\n\\n    /**\\n     * @dev Private function to remove a token from this extension's token tracking data structures.\\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\\n     */\\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\\n        // then delete the last slot (swap and pop).\\n\\n        uint256 lastTokenIndex = _allTokens.length - 1;\\n        uint256 tokenIndex = _allTokensIndex[tokenId];\\n\\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\\n\\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\\n\\n        // This also deletes the contents at the last position of the array\\n        delete _allTokensIndex[tokenId];\\n        _allTokens.pop();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/core/base/IERC721Time.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\n\\n/**\\n * @title IERC721Time\\n * @author Lens Protocol\\n *\\n * @notice This is an expansion of the IERC721 interface that includes a struct for token data,\\n * which contains the token owner and the mint timestamp as well as associated getters.\\n */\\ninterface IERC721Time is IERC721 {\\n    /**\\n     * @notice Contains the owner address and the mint timestamp for every NFT.\\n     *\\n     * Note: Instead of the owner address in the _tokenOwners private mapping, we now store it in the\\n     * _tokenData mapping, alongside the unchanging mintTimestamp.\\n     *\\n     * @param owner The token owner.\\n     * @param mintTimestamp The mint timestamp.\\n     */\\n    struct TokenData {\\n        address owner;\\n        uint96 mintTimestamp;\\n    }\\n\\n    /**\\n     * @notice Returns the mint timestamp associated with a given NFT, stored only once upon initial mint.\\n     *\\n     * @param tokenId The token ID of the NFT to query the mint timestamp for.\\n     *\\n     * @return uint256 mint timestamp, this is stored as a uint96 but returned as a uint256 to reduce unnecessary\\n     * padding.\\n     */\\n    function mintTimestampOf(uint256 tokenId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the token data associated with a given NFT. This allows fetching the token owner and\\n     * mint timestamp in a single call.\\n     *\\n     * @param tokenId The token ID of the NFT to query the token data for.\\n     *\\n     * @return TokenData token data struct containing both the owner address and the mint timestamp.\\n     */\\n    function tokenDataOf(uint256 tokenId) external view returns (TokenData memory);\\n\\n    /**\\n     * @notice Returns whether a token with the given token ID exists.\\n     *\\n     * @param tokenId The token ID of the NFT to check existence for.\\n     *\\n     * @return bool True if the token exists.\\n     */\\n    function exists(uint256 tokenId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Enumerable is IERC721 {\\n    /**\\n     * @dev Returns the total amount of tokens stored by the contract.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\\n     */\\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\\n     * Use along with {totalSupply} to enumerate all tokens.\\n     */\\n    function tokenByIndex(uint256 index) external view returns (uint256);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": true\r\n      }\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"hub\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InitParamsInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Initialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotHub\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwnerOrApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SignatureInvalid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroSpender\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HUB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.EIP712Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"burnWithSig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDomainSeparator\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSourcePublicationPointer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"profileId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pubId\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mintTimestampOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.EIP712Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct DataTypes.EIP712Signature\",\"name\":\"sig\",\"type\":\"tuple\"}],\"name\":\"permitForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sigNonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenDataOf\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"mintTimestamp\",\"type\":\"uint96\"}],\"internalType\":\"struct IERC721Time.TokenData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CollectNFT", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000db46d1dc155634fbc732f92e853b10b288ad5a1d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}