{"SourceCode": "{\"AccessController.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG----\\n\\npragma solidity ^0.8.19;\\n\\ncontract AccessController {\\n\\n    address public ceoAddress;\\n    mapping (address =\\u003e bool) public isWorker;\\n\\n    event CEOSet(\\n        address newCEO\\n    );\\n\\n    event WorkerAdded(\\n        address newWorker\\n    );\\n\\n    event WorkerRemoved(\\n        address existingWorker\\n    );\\n\\n    constructor() {\\n\\n        address creator = msg.sender;\\n        ceoAddress = creator;\\n        isWorker[creator] = true;\\n\\n        emit CEOSet(\\n            creator\\n        );\\n\\n        emit WorkerAdded(\\n            creator\\n        );\\n    }\\n\\n    modifier onlyCEO() {\\n        require(\\n            msg.sender == ceoAddress,\\n            \\\"AccessControl: CEO_DENIED\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyWorker() {\\n        require(\\n            isWorker[msg.sender] == true,\\n            \\\"AccessControl: WORKER_DENIED\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier nonZeroAddress(\\n        address checkingAddress\\n    ) {\\n        require(\\n            checkingAddress != address(0x0),\\n            \\\"AccessControl: INVALID_ADDRESS\\\"\\n        );\\n        _;\\n    }\\n\\n    function setCEO(\\n        address _newCEO\\n    )\\n        external\\n        nonZeroAddress(_newCEO)\\n        onlyCEO\\n    {\\n        ceoAddress = _newCEO;\\n\\n        emit CEOSet(\\n            ceoAddress\\n        );\\n    }\\n\\n    function addWorker(\\n        address _newWorker\\n    )\\n        external\\n        onlyCEO\\n    {\\n        _addWorker(\\n            _newWorker\\n        );\\n    }\\n\\n    function addWorkerBulk(\\n        address[] calldata _newWorkers\\n    )\\n        external\\n        onlyCEO\\n    {\\n        for (uint8 index = 0; index \\u003c _newWorkers.length; index++) {\\n            _addWorker(_newWorkers[index]);\\n        }\\n    }\\n\\n    function _addWorker(\\n        address _newWorker\\n    )\\n        internal\\n        nonZeroAddress(_newWorker)\\n    {\\n        require(\\n            isWorker[_newWorker] == false,\\n            \\u0027AccessControl: worker already exist\\u0027\\n        );\\n\\n        isWorker[_newWorker] = true;\\n\\n        emit WorkerAdded(\\n            _newWorker\\n        );\\n    }\\n\\n    function removeWorker(\\n        address _existingWorker\\n    )\\n        external\\n        onlyCEO\\n    {\\n        _removeWorker(\\n            _existingWorker\\n        );\\n    }\\n\\n    function removeWorkerBulk(\\n        address[] calldata _workerArray\\n    )\\n        external\\n        onlyCEO\\n    {\\n        for (uint8 index = 0; index \\u003c _workerArray.length; index++) {\\n            _removeWorker(_workerArray[index]);\\n        }\\n    }\\n\\n    function _removeWorker(\\n        address _existingWorker\\n    )\\n        internal\\n        nonZeroAddress(_existingWorker)\\n    {\\n        require(\\n            isWorker[_existingWorker] == true,\\n            \\\"AccessControl: worker not detected\\\"\\n        );\\n\\n        isWorker[_existingWorker] = false;\\n\\n        emit WorkerRemoved(\\n            _existingWorker\\n        );\\n    }\\n}\\n\"},\"EIP712Base.sol\":{\"content\":\"// SPDX-License-Identifier: -- vitally.eth --\\n\\npragma solidity ^0.8.19;\\n\\ncontract EIP712Base {\\n\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        uint256 chainId;\\n        address verifyingContract;\\n    }\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(\\n        bytes(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        )\\n    );\\n\\n    bytes32 internal domainSeperator;\\n\\n    constructor(\\n        string memory _name,\\n        string memory _version\\n    ) {\\n        domainSeperator = keccak256(abi.encode(\\n\\t\\t\\tEIP712_DOMAIN_TYPEHASH,\\n\\t\\t\\tkeccak256(bytes(_name)),\\n\\t\\t\\tkeccak256(bytes(_version)),\\n\\t\\t\\tgetChainID(),\\n\\t\\t\\taddress(this)\\n\\t\\t));\\n    }\\n\\n    function getChainID()\\n        internal\\n        pure\\n        returns (uint256 id)\\n    {\\n\\t\\tassembly {\\n\\t\\t\\tid := 1\\n\\t\\t}\\n\\t}\\n\\n    function getDomainSeperator()\\n        private\\n        view\\n        returns(bytes32)\\n    {\\n\\t\\treturn domainSeperator;\\n\\t}\\n\\n    function toTypedMessageHash(\\n        bytes32 _messageHash\\n    )\\n        internal\\n        view\\n        returns(bytes32)\\n    {\\n        return keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                getDomainSeperator(),\\n                _messageHash\\n            )\\n        );\\n    }\\n}\\n\"},\"EIP712MetaTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: -- vitally.eth --\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./EIP712Base.sol\\\";\\n\\nabstract contract EIP712MetaTransaction is EIP712Base {\\n\\n    bytes32 private constant META_TRANSACTION_TYPEHASH = keccak256(\\n        bytes(\\n            \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\n        )\\n    );\\n\\n    event MetaTransactionExecuted(\\n        address userAddress,\\n        address payable relayerAddress,\\n        bytes functionSignature\\n    );\\n\\n    mapping(address =\\u003e uint256) internal nonces;\\n\\n    struct MetaTransaction {\\n\\t\\tuint256 nonce;\\n\\t\\taddress from;\\n        bytes functionSignature;\\n\\t}\\n\\n    function executeMetaTransaction(\\n        address _userAddress,\\n        bytes memory _functionSignature,\\n        bytes32 _sigR,\\n        bytes32 _sigS,\\n        uint8 _sigV\\n    )\\n        public\\n        payable\\n        returns(bytes memory)\\n    {\\n        MetaTransaction memory metaTx = MetaTransaction(\\n            {\\n                nonce: nonces[_userAddress],\\n                from: _userAddress,\\n                functionSignature: _functionSignature\\n            }\\n        );\\n\\n        require(\\n            verify(\\n                _userAddress,\\n                metaTx,\\n                _sigR,\\n                _sigS,\\n                _sigV\\n            ), \\\"EIP712MetaTransaction: INVALID_SIGNATURE\\\"\\n        );\\n\\n\\t    nonces[_userAddress] =\\n\\t    nonces[_userAddress] + 1;\\n\\n        (bool success, bytes memory returnData) = address(this).call(\\n            abi.encodePacked(\\n                _functionSignature,\\n                _userAddress\\n            )\\n        );\\n\\n        require(\\n            success,\\n            \\\"EIP712MetaTransaction: INVALID_CALL\\\"\\n        );\\n\\n        emit MetaTransactionExecuted(\\n            _userAddress,\\n            payable(msg.sender),\\n            _functionSignature\\n        );\\n\\n        return returnData;\\n    }\\n\\n    function hashMetaTransaction(\\n        MetaTransaction memory _metaTx\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n\\t\\treturn keccak256(\\n\\t\\t    abi.encode(\\n                META_TRANSACTION_TYPEHASH,\\n                _metaTx.nonce,\\n                _metaTx.from,\\n                keccak256(_metaTx.functionSignature)\\n            )\\n        );\\n\\t}\\n\\n    function verify(\\n        address _user,\\n        MetaTransaction memory _metaTx,\\n        bytes32 _sigR,\\n        bytes32 _sigS,\\n        uint8 _sigV\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        address signer = ecrecover(\\n            toTypedMessageHash(\\n                hashMetaTransaction(_metaTx)\\n            ),\\n            _sigV,\\n            _sigR,\\n            _sigS\\n        );\\n\\n        require(\\n            signer != address(0x0),\\n            \\\"EIP712MetaTransaction: INVALID_SIGNATURE\\\"\\n        );\\n\\n\\t\\treturn signer == _user;\\n\\t}\\n\\n    function msgSender()\\n        internal\\n        view\\n        returns(address sender)\\n    {\\n        if (msg.sender == address(this)) {\\n\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender = msg.sender;\\n        }\\n\\n        return sender;\\n    }\\n\\n    function getNonce(\\n        address _user\\n    )\\n        external\\n        view\\n        returns(uint256 nonce)\\n    {\\n        nonce = nonces[_user];\\n    }\\n}\\n\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG----\\n\\npragma solidity ^0.8.19;\\n\\ninterface ERC721 {\\n\\n    function ownerOf(\\n        uint256 _tokenId\\n    )\\n        external\\n        view\\n        returns (address);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    )\\n        external;\\n}\\n\\ninterface ERC20 {\\n\\n    function burn(\\n        uint256 _amount\\n    )\\n        external;\\n}\\n\\ninterface DGAccessories  {\\n\\n    function issueTokens(\\n        address[] calldata _beneficiaries,\\n        uint256[] calldata _itemIds\\n    )\\n        external;\\n\\n    function encodeTokenId(\\n        uint256 _itemId,\\n        uint256 _issuedId\\n    )\\n        external\\n        pure\\n        returns (uint256 id);\\n\\n    function decodeTokenId(\\n        uint256 _tokenId\\n    )\\n        external\\n        pure\\n        returns (\\n            uint256 itemId,\\n            uint256 issuedId\\n        );\\n\\n    function items(\\n        uint256 _id\\n    )\\n        external\\n        view\\n        returns (\\n            string memory rarity,\\n            uint256 maxSupply,\\n            uint256 totalSupply,\\n            uint256 price,\\n            address beneficiary,\\n            string memory metadata,\\n            string memory contentHash\\n        );\\n\\n    function itemsCount()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"},\"TokenHub.sol\":{\"content\":\"// SPDX-License-Identifier: -- DG --\\n\\npragma solidity =0.8.19;\\n\\nimport \\\"./Interfaces.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport \\\"./AccessController.sol\\\";\\nimport \\\"./EIP712MetaTransaction.sol\\\";\\n\\ncontract TokenHub is\\n    AccessController,\\n    TransferHelper,\\n    EIP712MetaTransaction\\n{\\n    uint256 public forwardFrame;\\n    address public forwardAddress;\\n\\n    mapping(address =\\u003e bool) public supportedTokens;\\n    mapping(address =\\u003e uint256) public forwardFrames;\\n\\n    event Forward(\\n        address indexed depositorAddress,\\n        address indexed paymentTokenAddress,\\n        uint256 indexed paymentTokenAmount\\n    );\\n\\n    constructor(\\n        address _defaultToken,\\n        uint256 _defaultFrame,\\n        address _defaultAddress\\n    )\\n        EIP712Base(\\n            \\\"TokenHub\\\",\\n            \\\"v2.0\\\"\\n        )\\n    {\\n        forwardFrame = _defaultFrame;\\n        forwardAddress = _defaultAddress;\\n        supportedTokens[_defaultToken] = true;\\n    }\\n\\n    function forwardTokens(\\n        address _depositorAddress,\\n        address _paymentTokenAddress,\\n        uint256 _paymentTokenAmount\\n    )\\n        external\\n        onlyWorker\\n    {\\n        require(\\n            canDepositAgain(_depositorAddress),\\n            \\\"TokenHub: DEPOSIT_COOLDOWN\\\"\\n        );\\n\\n        forwardFrames[_depositorAddress] = block.number;\\n\\n        require(\\n            supportedTokens[_paymentTokenAddress],\\n            \\\"TokenHub: UNSUPPORTED_TOKEN\\\"\\n        );\\n\\n        safeTransferFrom(\\n            _paymentTokenAddress,\\n            _depositorAddress,\\n            forwardAddress,\\n            _paymentTokenAmount\\n        );\\n\\n        emit Forward(\\n            _depositorAddress,\\n            _paymentTokenAddress,\\n            _paymentTokenAmount\\n        );\\n    }\\n\\n    function changeForwardFrame(\\n        uint256 _newDepositFrame\\n    )\\n        external\\n        onlyCEO\\n    {\\n        forwardFrame = _newDepositFrame;\\n    }\\n\\n    function changeForwardAddress(\\n        address _newForwardAddress\\n    )\\n        external\\n        onlyCEO\\n    {\\n        forwardAddress = _newForwardAddress;\\n    }\\n\\n    function changeSupportedToken(\\n        address _tokenAddress,\\n        bool _supportStatus\\n    )\\n        external\\n        onlyCEO\\n    {\\n        supportedTokens[_tokenAddress] = _supportStatus;\\n    }\\n\\n    function canDepositAgain(\\n        address _depositorAddress\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return block.number - forwardFrames[_depositorAddress] \\u003e= forwardFrame;\\n    }\\n}\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG----\\n\\npragma solidity ^0.8.19;\\n\\ncontract TransferHelper {\\n\\n    bytes4 private constant TRANSFER = bytes4(\\n        keccak256(\\n            bytes(\\n                \\\"transfer(address,uint256)\\\" // 0xa9059cbb\\n            )\\n        )\\n    );\\n\\n    bytes4 private constant TRANSFER_FROM = bytes4(\\n        keccak256(\\n            bytes(\\n                \\\"transferFrom(address,address,uint256)\\\" // 0x23b872dd\\n            )\\n        )\\n    );\\n\\n    function safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER, // 0xa9059cbb\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"TransferHelper: TRANSFER_FAILED\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER_FROM,\\n                _from,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\\"TransferHelper: TRANSFER_FROM_FAILED\\\"\\n        );\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_defaultFrame\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_defaultAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCEO\",\"type\":\"address\"}],\"name\":\"CEOSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositorAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"paymentTokenAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"paymentTokenAmount\",\"type\":\"uint256\"}],\"name\":\"Forward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWorker\",\"type\":\"address\"}],\"name\":\"WorkerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"existingWorker\",\"type\":\"address\"}],\"name\":\"WorkerRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWorker\",\"type\":\"address\"}],\"name\":\"addWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newWorkers\",\"type\":\"address[]\"}],\"name\":\"addWorkerBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositorAddress\",\"type\":\"address\"}],\"name\":\"canDepositAgain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newForwardAddress\",\"type\":\"address\"}],\"name\":\"changeForwardAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newDepositFrame\",\"type\":\"uint256\"}],\"name\":\"changeForwardFrame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_supportStatus\",\"type\":\"bool\"}],\"name\":\"changeSupportedToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"_sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"_sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forwardFrame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"forwardFrames\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_depositorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_paymentTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_paymentTokenAmount\",\"type\":\"uint256\"}],\"name\":\"forwardTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWorker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_existingWorker\",\"type\":\"address\"}],\"name\":\"removeWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_workerArray\",\"type\":\"address[]\"}],\"name\":\"removeWorkerBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"supportedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenHub", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c6c855ad634dcdad23e64da71ba85b8c51e5ad7c0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000641ad78baca220c5bd28b51ce8e0f495e85fe689", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://2813ef466fef7309ba4a7bd30a195abcdc67ac0c4d7e2ce7df53e7418845ec37"}