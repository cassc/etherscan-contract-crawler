{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/LayerrProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {StringValue} from \\\"./lib/StorageTypes.sol\\\";\\r\\nimport {AddressValue} from \\\"./lib/StorageTypes.sol\\\";\\r\\nimport {ILayerrMinter} from \\\"./interfaces/ILayerrMinter.sol\\\";\\r\\nimport {LAYERROWNABLE_OWNER_SLOT, LAYERRTOKEN_NAME_SLOT, LAYERRTOKEN_SYMBOL_SLOT, LAYERRTOKEN_RENDERER_SLOT} from \\\"./common/LayerrStorage.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LayerrProxy\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice A proxy contract that serves as an interface for interacting with \\r\\n *         Layerr tokens. At deployment it sets token properties and contract \\r\\n *         ownership, initializes signers and mint extensions, and configures \\r\\n *         royalties.\\r\\n */\\r\\ncontract LayerrProxy {\\r\\n\\r\\n    /// @dev the implementation address for the proxy contract\\r\\n    address immutable proxy;\\r\\n\\r\\n    /// @dev this is included as a hint for block explorers\\r\\n    bytes32 private constant PROXY_IMPLEMENTATION_REFERENCE = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\\r\\n\\r\\n    /// @dev Thrown when a required initialization call fails\\r\\n    error DeploymentFailed();\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the proxy contract\\r\\n     * @param _proxy implementation address for the proxy contract\\r\\n     * @param _name token contract name\\r\\n     * @param _symbol token contract symbol\\r\\n     * @param royaltyPct default royalty percentage in BPS\\r\\n     * @param royaltyReceiver default royalty receiver\\r\\n     * @param operatorFilterRegistry address of the operator filter registry to subscribe to\\r\\n     * @param _extension minting extension to use with the token contract\\r\\n     * @param _renderer renderer to use with the token contract\\r\\n     * @param _signers array of allowed signers for the mint extension\\r\\n     */\\r\\n    constructor(\\r\\n        address _proxy, \\r\\n        string memory _name, \\r\\n        string memory _symbol, \\r\\n        uint96 royaltyPct, \\r\\n        address royaltyReceiver, \\r\\n        address operatorFilterRegistry, \\r\\n        address _extension, \\r\\n        address _renderer, \\r\\n        address[] memory _signers\\r\\n    ) {\\r\\n        proxy = _proxy; \\r\\n\\r\\n        StringValue storage name;\\r\\n        StringValue storage symbol;\\r\\n        AddressValue storage renderer;\\r\\n        AddressValue storage owner;\\r\\n        AddressValue storage explorerProxy;\\r\\n        /// @solidity memory-safe-assembly\\r\\n        assembly {\\r\\n            name.slot := LAYERRTOKEN_NAME_SLOT\\r\\n            symbol.slot := LAYERRTOKEN_SYMBOL_SLOT\\r\\n            renderer.slot := LAYERRTOKEN_RENDERER_SLOT\\r\\n            owner.slot := LAYERROWNABLE_OWNER_SLOT\\r\\n            explorerProxy.slot := PROXY_IMPLEMENTATION_REFERENCE\\r\\n        } \\r\\n        name.value = _name;\\r\\n        symbol.value = _symbol;\\r\\n        renderer.value = _renderer;\\r\\n        owner.value = tx.origin;\\r\\n        explorerProxy.value = _proxy;\\r\\n\\r\\n        uint256 signersLength = _signers.length;\\r\\n        for(uint256 signerIndex;signerIndex < signersLength;) {\\r\\n            ILayerrMinter(_extension).setContractAllowedSigner(_signers[signerIndex], true);\\r\\n            unchecked {\\r\\n                ++signerIndex;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        (bool success, ) = _proxy.delegatecall(abi.encodeWithSignature(\\\"setRoyalty(uint96,address)\\\", royaltyPct, royaltyReceiver));\\r\\n        if(!success) revert DeploymentFailed();\\r\\n\\r\\n        (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\\\"setOperatorFilter(address)\\\", operatorFilterRegistry));\\r\\n        //this item may fail if deploying a contract that does not use an operator filter\\r\\n\\r\\n        (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\\\"setMintExtension(address,bool)\\\", _extension, true));\\r\\n        if(!success) revert DeploymentFailed();\\r\\n\\r\\n        (success, ) = _proxy.delegatecall(abi.encodeWithSignature(\\\"initialize()\\\"));\\r\\n        if(!success) revert DeploymentFailed();\\r\\n    }\\r\\n\\r\\n    fallback() external payable {\\r\\n        address _proxy = proxy;\\r\\n        assembly {\\r\\n            calldatacopy(0x0, 0x0, calldatasize())\\r\\n            let result := delegatecall(gas(), _proxy, 0x0, calldatasize(), 0x0, 0)\\r\\n            returndatacopy(0x0, 0x0, returndatasize())\\r\\n            switch result case 0 {revert(0, 0)} default {return (0, returndatasize())}\\r\\n        }\\r\\n    }\\r\\n}\"\r\n    },\r\n    \"contracts/common/LayerrStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/// @dev Storage slot for current owner calculated from keccak256('Layerr.LayerrOwnable.owner')\\r\\nbytes32 constant LAYERROWNABLE_OWNER_SLOT = 0xedc628ad38a73ae7d50600532f1bf21da1bfb1390b4f8174f361aca54d4c6b66;\\r\\n\\r\\n/// @dev Storage slot for pending ownership transfer calculated from keccak256('Layerr.LayerrOwnable.newOwner')\\r\\nbytes32 constant LAYERROWNABLE_NEW_OWNER_SLOT = 0x15c115ab76de082272ae65126522082d4aad634b6478097549f84086af3b84bc;\\r\\n\\r\\n/// @dev Storage slot for token name calculated from keccak256('Layerr.LayerrToken.name')\\r\\nbytes32 constant LAYERRTOKEN_NAME_SLOT = 0x7f84c61ed30727f282b62cab23f49ac7f4d263f04a4948416b7b9ba7f34a20dc;\\r\\n\\r\\n/// @dev Storage slot for token symbol calculated from keccak256('Layerr.LayerrToken.symbol')\\r\\nbytes32 constant LAYERRTOKEN_SYMBOL_SLOT = 0xdc0f2363b26c589c72caecd2357dae5fee235863060295a057e8d69d61a96d8a;\\r\\n\\r\\n/// @dev Storage slot for URI renderer calculated from keccak256('Layerr.LayerrToken.renderer')\\r\\nbytes32 constant LAYERRTOKEN_RENDERER_SLOT = 0x395b7021d979c3dbed0f5d530785632316942232113ba3dbe325dc167550e320;\"\r\n    },\r\n    \"contracts/interfaces/ILayerrMinter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\nimport {MintOrder, MintParameters, MintToken, BurnToken, PaymentToken} from \\\"../lib/MinterStructs.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ILayerrMinter\\r\\n * @author 0xth0mas (Layerr)\\r\\n * @notice ILayerrMinter interface defines functions required in the LayerrMinter to be callable by token contracts\\r\\n */\\r\\ninterface ILayerrMinter {\\r\\n\\r\\n    /// @dev Event emitted when a mint order is fulfilled\\r\\n    event MintOrderFulfilled(\\r\\n        bytes32 indexed mintParametersDigest,\\r\\n        address indexed minter,\\r\\n        uint256 indexed quantity\\r\\n    );\\r\\n\\r\\n    /// @dev Event emitted when a token contract updates an allowed signer for EIP712 signatures\\r\\n    event ContractAllowedSignerUpdate(\\r\\n        address indexed _contract,\\r\\n        address indexed _signer,\\r\\n        bool indexed _allowed\\r\\n    );\\r\\n\\r\\n    /// @dev Event emitted when a token contract updates an allowed oracle signer for offchain authorization of a wallet to use a signature\\r\\n    event ContractOracleUpdated(\\r\\n        address indexed _contract,\\r\\n        address indexed _oracle,\\r\\n        bool indexed _allowed\\r\\n    );\\r\\n\\r\\n    /// @dev Event emitted when a signer updates their nonce with LayerrMinter. Updating a nonce invalidates all previously signed EIP712 signatures.\\r\\n    event SignerNonceIncremented(\\r\\n        address indexed _signer,\\r\\n        uint256 indexed _nonce\\r\\n    );\\r\\n\\r\\n    /// @dev Event emitted when a specific signature's validity is updated with the LayerrMinter contract.\\r\\n    event SignatureValidityUpdated(\\r\\n        address indexed _contract,\\r\\n        bool indexed invalid,\\r\\n        bytes32 mintParametersDigests\\r\\n    );\\r\\n\\r\\n    /// @dev Thrown when the amount of native tokens supplied in msg.value is insufficient for the mint order\\r\\n    error InsufficientPayment();\\r\\n\\r\\n    /// @dev Thrown when a payment fails to be forwarded to the intended recipient\\r\\n    error PaymentFailed();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters payment token uses a token type value other than native or ERC20\\r\\n    error InvalidPaymentTokenType();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters burn token uses a token type value other than ERC20, ERC721 or ERC1155\\r\\n    error InvalidBurnTokenType();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters mint token uses a token type value other than ERC20, ERC721 or ERC1155\\r\\n    error InvalidMintTokenType();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters burn token uses a burn type value other than contract burn or send to dead\\r\\n    error InvalidBurnType();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters burn token requires a specific burn token id and the tokenId supplied does not match\\r\\n    error InvalidBurnTokenId();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters burn token requires a specific ERC721 token and the burn amount is greater than 1\\r\\n    error CannotBurnMultipleERC721WithSameId();\\r\\n\\r\\n    /// @dev Thrown when attempting to mint with MintParameters that have a start time greater than the current block time\\r\\n    error MintHasNotStarted();\\r\\n\\r\\n    /// @dev Thrown when attempting to mint with MintParameters that have an end time less than the current block time\\r\\n    error MintHasEnded();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters has a merkleroot set but the supplied merkle proof is invalid\\r\\n    error InvalidMerkleProof();\\r\\n\\r\\n    /// @dev Thrown when a MintOrder will cause a token's minted supply to exceed the defined maximum supply in MintParameters\\r\\n    error MintExceedsMaxSupply();\\r\\n\\r\\n    /// @dev Thrown when a MintOrder will cause a minter's minted amount to exceed the defined max per wallet in MintParameters\\r\\n    error MintExceedsMaxPerWallet();\\r\\n\\r\\n    /// @dev Thrown when a MintParameters mint token has a specific ERC721 token and the mint amount is greater than 1\\r\\n    error CannotMintMultipleERC721WithSameId();\\r\\n\\r\\n    /// @dev Thrown when the recovered signer for the MintParameters is not an allowed signer for the mint token\\r\\n    error NotAllowedSigner();\\r\\n\\r\\n    /// @dev Thrown when the recovered signer's nonce does not match the current nonce in LayerrMinter\\r\\n    error SignerNonceInvalid();\\r\\n\\r\\n    /// @dev Thrown when a signature has been marked as invalid for a mint token contract\\r\\n    error SignatureInvalid();\\r\\n\\r\\n    /// @dev Thrown when MintParameters requires an oracle signature and the recovered signer is not an allowed oracle for the contract\\r\\n    error InvalidOracleSignature();\\r\\n\\r\\n    /// @dev Thrown when MintParameters has a max signature use set and the MintOrder will exceed the maximum uses\\r\\n    error ExceedsMaxSignatureUsage();\\r\\n\\r\\n    /// @dev Thrown when attempting to increment nonce on behalf of another account and the signature is invalid\\r\\n    error InvalidSignatureToIncrementNonce();\\r\\n\\r\\n    /**\\r\\n     * @notice This function is called by token contracts to update allowed signers for minting\\r\\n     * @param _signer address of the EIP712 signer\\r\\n     * @param _allowed if the `_signer` is allowed to sign for minting\\r\\n     */\\r\\n    function setContractAllowedSigner(address _signer, bool _allowed) external;\\r\\n\\r\\n    /**\\r\\n     * @notice This function is called by token contracts to update allowed oracles for offchain authorizations\\r\\n     * @param _oracle address of the oracle\\r\\n     * @param _allowed if the `_oracle` is allowed to sign offchain authorizations\\r\\n     */\\r\\n    function setContractAllowedOracle(address _oracle, bool _allowed) external;\\r\\n\\r\\n    /**\\r\\n     * @notice This function is called by token contracts to update validity of signatures for the LayerrMinter contract\\r\\n     * @dev `invalid` should be true to invalidate signatures, the default state of `invalid` being false means \\r\\n     *      a signature is valid for a contract assuming all other conditions are met\\r\\n     * @param mintParametersDigests an array of message digests for MintParameters to update validity of\\r\\n     * @param invalid if the supplied digests will be marked as valid or invalid\\r\\n     */\\r\\n    function setSignatureValidity(\\r\\n        bytes32[] calldata mintParametersDigests,\\r\\n        bool invalid\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Increments the nonce for a signer to invalidate all previous signed MintParameters\\r\\n     */\\r\\n    function incrementSignerNonce() external;\\r\\n\\r\\n    /**\\r\\n     * @notice Increments the nonce on behalf of another account by validating a signature from that account\\r\\n     * @dev The signature is an eth personal sign message of the current signer nonce plus the chain id\\r\\n     *      ex. current nonce 0 on chain 5 would be a signature of \\\\x19Ethereum Signed Message:\\\\n15\\r\\n     *          current nonce 50 on chain 1 would be a signature of \\\\x19Ethereum Signed Message:\\\\n251\\r\\n     * @param signer account to increment nonce for\\r\\n     * @param signature signature proof that the request is coming from the account\\r\\n     */\\r\\n    function incrementNonceFor(address signer, bytes calldata signature) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and processes a single MintOrder, tokens are minted to msg.sender\\r\\n     * @param mintOrder struct containing the details of the mint order\\r\\n     */\\r\\n    function mint(\\r\\n        MintOrder calldata mintOrder\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and processes an array of MintOrders, tokens are minted to msg.sender\\r\\n     * @param mintOrders array of structs containing the details of the mint orders\\r\\n     */\\r\\n    function mintBatch(\\r\\n        MintOrder[] calldata mintOrders\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and processes a single MintOrder, tokens are minted to `mintToWallet`\\r\\n     * @param mintToWallet the address tokens will be minted to\\r\\n     * @param mintOrder struct containing the details of the mint order\\r\\n     * @param paymentContext Contextual information related to the payment process\\r\\n     *                     (Note: This parameter is required for integration with \\r\\n     *                     the payment processor and does not impact the behavior \\r\\n     *                     of the function)\\r\\n     */\\r\\n    function mintTo(\\r\\n        address mintToWallet,\\r\\n        MintOrder calldata mintOrder,\\r\\n        uint256 paymentContext\\r\\n    ) external payable;\\r\\n\\r\\n    /**\\r\\n     * @notice Validates and processes an array of MintOrders, tokens are minted to `mintToWallet`\\r\\n     * @param mintToWallet the address tokens will be minted to\\r\\n     * @param mintOrders array of structs containing the details of the mint orders\\r\\n     * @param paymentContext Contextual information related to the payment process\\r\\n     *                     (Note: This parameter is required for integration with \\r\\n     *                     the payment processor and does not impact the behavior \\r\\n     *                     of the function)\\r\\n     */\\r\\n    function mintBatchTo(\\r\\n        address mintToWallet,\\r\\n        MintOrder[] calldata mintOrders,\\r\\n        uint256 paymentContext\\r\\n    ) external payable;\\r\\n}\"\r\n    },\r\n    \"contracts/lib/MinterStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/**\\r\\n * @dev EIP712 Domain for signature verification\\r\\n */\\r\\nstruct EIP712Domain {\\r\\n    string name;\\r\\n    string version;\\r\\n    uint256 chainId;\\r\\n    address verifyingContract;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev MintOrders contain MintParameters as defined by a token creator\\r\\n *      along with proofs required to validate the MintParameters and \\r\\n *      parameters specific to the mint being performed.\\r\\n * \\r\\n *      `mintParameters` are the parameters signed by the token creator\\r\\n *      `quantity` is a multiplier for mintTokens, burnTokens and paymentTokens\\r\\n *          defined in mintParameters\\r\\n *      `mintParametersSignature` is the signature from the token creator\\r\\n *      `oracleSignature` is a signature of the hash of the mintParameters digest \\r\\n *          and msg.sender. The recovered signer must be an allowed oracle for \\r\\n *          the token contract if oracleSignatureRequired is true for mintParameters.\\r\\n *      `merkleProof` is the proof that is checked if merkleRoot is not bytes(0) in\\r\\n *          mintParameters\\r\\n *      `suppliedBurnTokenIds` is an array of tokenIds to be used when processing\\r\\n *          burnTokens. There must be one item in the array for each ERC1155 burnToken\\r\\n *          regardless of `quantity` and `quantity` items in the array for each ERC721\\r\\n *          burnToken.\\r\\n *      `referrer` is the address that will receive a portion of a paymentToken if\\r\\n *          not address(0) and paymentToken's referralBPS is greater than 0\\r\\n *      `vaultWallet` is used for allowlist mints if the msg.sender address it not on\\r\\n *          the allowlist but their delegate.cash vault wallet is.\\r\\n *      \\r\\n */\\r\\nstruct MintOrder {\\r\\n    MintParameters mintParameters;\\r\\n    uint256 quantity;\\r\\n    bytes mintParametersSignature;\\r\\n    bytes oracleSignature;\\r\\n    bytes32[] merkleProof;\\r\\n    uint256[] suppliedBurnTokenIds;\\r\\n    address referrer;\\r\\n    address vaultWallet;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev MintParameters define the tokens to be minted and conditions that must be met\\r\\n *      for the mint to be successfully processed.\\r\\n * \\r\\n *      `mintTokens` is an array of tokens that will be minted\\r\\n *      `burnTokens` is an array of tokens required to be burned\\r\\n *      `paymentTokens` is an array of tokens required as payment\\r\\n *      `startTime` is the UTC timestamp of when the mint will start\\r\\n *      `endTime` is the UTC timestamp of when the mint will end\\r\\n *      `signatureMaxUses` limits the number of mints that can be performed with the\\r\\n *          specific mintParameters/signature\\r\\n *      `merkleRoot` is the root of the merkletree for allowlist minting\\r\\n *      `nonce` is the signer nonce that can be incremented on the LayerrMinter \\r\\n *          contract to invalidate all previous signatures\\r\\n *      `oracleSignatureRequired` if true requires a secondary signature to process the mint\\r\\n */\\r\\nstruct MintParameters {\\r\\n    MintToken[] mintTokens;\\r\\n    BurnToken[] burnTokens;\\r\\n    PaymentToken[] paymentTokens;\\r\\n    uint256 startTime;\\r\\n    uint256 endTime;\\r\\n    uint256 signatureMaxUses;\\r\\n    bytes32 merkleRoot;\\r\\n    uint256 nonce;\\r\\n    bool oracleSignatureRequired;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Defines the token that will be minted\\r\\n *      \\r\\n *      `contractAddress` address of contract to mint tokens from\\r\\n *      `specificTokenId` used for ERC721 - \\r\\n *          if true, mint is non-sequential ERC721\\r\\n *          if false, mint is sequential ERC721A\\r\\n *      `tokenType` is the type of token being minted defined in TokenTypes.sol\\r\\n *      `tokenId` the tokenId to mint if specificTokenId is true\\r\\n *      `mintAmount` is the quantity to be minted\\r\\n *      `maxSupply` is checked against the total minted amount at time of mint\\r\\n *          minting reverts if `mintAmount` * `quantity` will cause total minted to \\r\\n *          exceed `maxSupply`\\r\\n *      `maxMintPerWallet` is checked against the number minted for the wallet\\r\\n *          minting reverts if `mintAmount` * `quantity` will cause wallet minted to \\r\\n *          exceed `maxMintPerWallet`\\r\\n */\\r\\nstruct MintToken {\\r\\n    address contractAddress;\\r\\n    bool specificTokenId;\\r\\n    uint256 tokenType;\\r\\n    uint256 tokenId;\\r\\n    uint256 mintAmount;\\r\\n    uint256 maxSupply;\\r\\n    uint256 maxMintPerWallet;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Defines the token that will be burned\\r\\n *      \\r\\n *      `contractAddress` address of contract to burn tokens from\\r\\n *      `specificTokenId` specifies if the user has the option of choosing any token\\r\\n *          from the contract or if they must burn a specific token\\r\\n *      `tokenType` is the type of token being burned, defined in TokenTypes.sol\\r\\n *      `burnType` is the type of burn to perform, burn function call or transfer to \\r\\n *          dead address, defined in BurnType.sol\\r\\n *      `tokenId` the tokenId to burn if specificTokenId is true\\r\\n *      `burnAmount` is the quantity to be burned\\r\\n */\\r\\nstruct BurnToken {\\r\\n    address contractAddress;\\r\\n    bool specificTokenId;\\r\\n    uint256 tokenType;\\r\\n    uint256 burnType;\\r\\n    uint256 tokenId;\\r\\n    uint256 burnAmount;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @dev Defines the token that will be used for payment\\r\\n *      \\r\\n *      `contractAddress` address of contract to for payment if ERC20\\r\\n *          if tokenType is native token then this should be set to 0x000...000\\r\\n *          to save calldata gas units\\r\\n *      `tokenType` is the type of token being used for payment, defined in TokenTypes.sol\\r\\n *      `payTo` the address that will receive the payment\\r\\n *      `paymentAmount` the amount for the payment in base units for the token\\r\\n *          ex. a native payment on Ethereum for 1 ETH would be specified in wei\\r\\n *          which would be 1**18 wei\\r\\n *      `referralBPS` is the percentage of the payment in BPS that will be sent to the \\r\\n *          `referrer` on the MintOrder if `referralBPS` is greater than 0 and `referrer`\\r\\n *          is not address(0)\\r\\n */\\r\\nstruct PaymentToken {\\r\\n    address contractAddress;\\r\\n    uint256 tokenType;\\r\\n    address payTo;\\r\\n    uint256 paymentAmount;\\r\\n    uint256 referralBPS;\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/StorageTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity ^0.8.20;\\r\\n\\r\\n/// @dev Simple struct to store a string value in a custom storage slot\\r\\nstruct StringValue {\\r\\n    string value;\\r\\n}\\r\\n\\r\\n/// @dev Simple struct to store an address value in a custom storage slot\\r\\nstruct AddressValue {\\r\\n    address value;\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 33333\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_proxy\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint96\",\"name\":\"royaltyPct\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"royaltyReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operatorFilterRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_extension\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_renderer\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_signers\",\"type\":\"address[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"DeploymentFailed\",\"type\":\"error\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "LayerrProxy", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "33333", "ConstructorArguments": "0000000000000000000000000000000000c480563ccbc2832fb38ea65438792200000000000000000000000000000000000000000000000000000000000001200000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000012c00000000000000000000000016d133548892ab1aa6505c40f560f582ba5a6e200000000000000000000000003cc6cdda760b79bafa08df41ecfa224f810dceb6000000000000000000000000000000000000d58696577347f78259bd376f1bec00000000000000000000000000000000000d351e7df55d1a7e8045daf6c998e200000000000000000000000000000000000000000000000000000000000001a0000000000000000000000000000000000000000000000000000000000000001454796c657220466f7573742078204c617965727200000000000000000000000000000000000000000000000000000000000000000000000000000000000000044c5952520000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000010000000000000000000000001602b3707a9213a313bc21337ae93c947b4929b4", "EVMVersion": "paris", "Library": "", "LicenseType": "BSL 1.1", "Proxy": "1", "Implementation": "0x0000000000c480563ccbc2832fb38ea654387922", "SwarmSource": "ipfs://fd5afa91e5ef53d78f21df2cfa554a17e52607624d10edcca268d264a28ce407"}