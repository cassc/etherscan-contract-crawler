{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/interface/IIdentity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.17;\\n\\ninterface IIdentity {\\n    event OwnershipTransferred(\\n        address indexed oldOwner,\\n        address indexed newOwner\\n    );\\n\\n    event ModuleManagerSwitched(\\n        address indexed oldModuleManager,\\n        address indexed newModuleManager\\n    );\\n\\n    event Executed(\\n        address indexed module,\\n        address indexed to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    function owner() external view returns (address);\\n\\n    function setOwner(address newOwner) external;\\n\\n    function moduleManager() external view returns (address);\\n\\n    function setModuleManager(address newModuleManager) external;\\n\\n    function isModuleEnabled(address module) external view returns (bool);\\n\\n    function getDelegate(bytes4 methodID) external view returns (address);\\n\\n    function execute(\\n        address to,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes memory);\\n}\\n\"\r\n    },\r\n    \"contracts/interface/ILockManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.17;\\n\\ninterface ILockManager {\\n    event IdentityLocked(\\n        address indexed identity,\\n        address indexed locker,\\n        uint64 expireAt\\n    );\\n\\n    event IdentityUnlocked(address indexed identity);\\n\\n    function isIdentityLocked(address identity) external view returns (bool);\\n\\n    function getIdentityLockExpireAt(address identity)\\n        external\\n        view\\n        returns (uint64);\\n\\n    function lockIdentity(address identity) external;\\n\\n    function unlockIdentity(address identity) external;\\n}\\n\"\r\n    },\r\n    \"contracts/module/subject/BaseModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: PolyForm-Noncommercial-1.0.0\\npragma solidity 0.8.17;\\n\\nimport \\\"../../interface/ILockManager.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\ncontract BaseModule {\\n    using Address for address;\\n\\n    ILockManager internal immutable _lockManager;\\n\\n    constructor(address lockManager) {\\n        require(\\n            lockManager.isContract(),\\n            \\\"BM: lock manager must be an existing contract address\\\"\\n        );\\n\\n        _lockManager = ILockManager(lockManager);\\n    }\\n\\n    modifier onlySelf() {\\n        require(_isSelf(msg.sender), \\\"BM: caller must be myself\\\");\\n        _;\\n    }\\n\\n    modifier onlyWhenIdentityUnlocked(address identity) {\\n        require(!_isIdentityLocked(identity), \\\"BM: identity must be unlocked\\\");\\n        _;\\n    }\\n\\n    function _isSelf(address addr) internal view returns (bool) {\\n        return addr == address(this);\\n    }\\n\\n    function _isIdentityLocked(address identity) internal view returns (bool) {\\n        return _lockManager.isIdentityLocked(identity);\\n    }\\n\\n    function ping() external view onlySelf {}\\n}\\n\"\r\n    },\r\n    \"contracts/module/subject/RelayerModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: PolyForm-Noncommercial-1.0.0\\npragma solidity 0.8.17;\\n\\nimport \\\"./BaseModule.sol\\\";\\nimport \\\"../../interface/IIdentity.sol\\\";\\nimport \\\"../../utils/ECDSA.sol\\\";\\nimport \\\"../../utils/Math.sol\\\";\\n\\ncontract RelayerModule is BaseModule {\\n    using ECDSA for bytes32;\\n\\n    uint256 internal immutable _minGas;\\n    uint256 internal immutable _refundGas;\\n\\n    mapping(address => uint256) internal _nonces;\\n\\n    event Executed(\\n        address indexed identity,\\n        bool indexed success,\\n        bytes result,\\n        bytes32 txHash\\n    );\\n\\n    event Refunded(\\n        address indexed identity,\\n        address indexed receiver,\\n        address token,\\n        uint256 amount\\n    );\\n\\n    constructor(\\n        address lockManager,\\n        uint256 minGas,\\n        uint256 refundGas\\n    ) BaseModule(lockManager) {\\n        _minGas = minGas;\\n        _refundGas = refundGas;\\n    }\\n\\n    function getNonce(address identity) external view returns (uint256) {\\n        return _nonces[identity];\\n    }\\n\\n    function execute(\\n        address identity,\\n        bytes calldata data,\\n        uint256 gasPrice,\\n        uint256 gasLimit,\\n        address refundTo,\\n        bytes calldata sig\\n    ) external returns (bool) {\\n        uint256 gasInit = gasleft() + _minGas + msg.data.length * 8;\\n\\n        bytes32 txHash = _getTxHash(\\n            identity,\\n            data,\\n            gasPrice,\\n            gasLimit,\\n            address(0),\\n            refundTo\\n        );\\n\\n        address signer = txHash.toEthSignedMessageHash().recover(sig);\\n\\n        require(signer == IIdentity(identity).owner(), \\\"RM: invalid signer\\\");\\n\\n        _nonces[identity]++;\\n\\n        (bool success, bytes memory result) = address(this).call(data);\\n\\n        emit Executed(identity, success, result, txHash);\\n\\n        if (gasPrice > 0) {\\n            _refund(\\n                identity,\\n                refundTo,\\n                gasInit,\\n                gasPrice,\\n                gasLimit,\\n                address(0)\\n            );\\n        }\\n\\n        return success;\\n    }\\n\\n    function executeThroughIdentity(\\n        address identity,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    )\\n        external\\n        onlySelf\\n        onlyWhenIdentityUnlocked(identity)\\n        returns (bytes memory)\\n    {\\n        return _executeThroughIdentity(identity, to, value, data);\\n    }\\n\\n    function _getTxHash(\\n        address identity,\\n        bytes memory data,\\n        uint256 gasPrice,\\n        uint256 gasLimit,\\n        address gasToken,\\n        address refundTo\\n    ) internal view returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\n                    bytes1(0x19),\\n                    bytes1(0x0),\\n                    block.chainid,\\n                    address(this),\\n                    address(identity),\\n                    _nonces[identity],\\n                    data,\\n                    gasPrice,\\n                    gasLimit,\\n                    gasToken,\\n                    refundTo\\n                )\\n            );\\n    }\\n\\n    function _refund(\\n        address identity,\\n        address to,\\n        uint256 gasInit,\\n        uint256 gasPrice,\\n        uint256 gasLimit,\\n        address gasToken\\n    ) internal {\\n        require(\\n            gasToken == address(0),\\n            \\\"RM: gas token must be the zero address\\\"\\n        );\\n\\n        to = to == address(0) ? msg.sender : to;\\n\\n        uint256 gasConsumed = gasInit - gasleft() + _refundGas;\\n        uint256 refundAmount = Math.min(gasConsumed, gasLimit) *\\n            Math.min(tx.gasprice, gasPrice);\\n\\n        _executeThroughIdentity(identity, to, refundAmount, \\\"\\\");\\n\\n        emit Refunded(identity, to, gasToken, refundAmount);\\n    }\\n\\n    function _executeThroughIdentity(\\n        address identity,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal returns (bytes memory) {\\n        return IIdentity(identity).execute(to, value, data);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.17;\\n\\nlibrary Address {\\n    function isContract(address addr) internal view returns (bool) {\\n        uint256 size;\\n\\n        assembly {\\n            size := extcodesize(addr)\\n        }\\n\\n        return size > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.17;\\n\\nlibrary ECDSA {\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        // ref. https://ethereum.github.io/yellowpaper/paper.pdf (301) (302)\\n        require(\\n            uint256(s) <=\\n                0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\\n            \\\"ECDSA: invalid s value in signature\\\"\\n        );\\n        require(v == 27 || v == 28, \\\"ECDSA: invalid v value in signature\\\");\\n\\n        address signer = ecrecover(hash, v, r, s);\\n\\n        require(signer != address(0), \\\"ECDSA: invalid signature\\\");\\n\\n        return signer;\\n    }\\n\\n    function recover(bytes32 hash, bytes memory sig)\\n        internal\\n        pure\\n        returns (address)\\n    {\\n        require(sig.length == 65, \\\"ECDSA: invalid signature length\\\");\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(sig, 0x20))\\n            s := mload(add(sig, 0x40))\\n            v := byte(0, mload(add(sig, 0x60)))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    function recover(\\n        bytes32 hash,\\n        bytes memory sig,\\n        uint256 index\\n    ) internal pure returns (address) {\\n        require(sig.length % 65 == 0, \\\"ECDSA: invalid signature length\\\");\\n        require(index < sig.length / 65, \\\"ECDSA: invalid signature index\\\");\\n\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n\\n        assembly {\\n            r := mload(add(add(sig, 0x20), mul(0x41, index)))\\n            s := mload(add(add(sig, 0x40), mul(0x41, index)))\\n            v := byte(0, mload(add(add(sig, 0x60), mul(0x41, index))))\\n        }\\n\\n        return recover(hash, v, r, s);\\n    }\\n\\n    function toEthSignedMessageHash(bytes32 hash)\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        return\\n            keccak256(\\n                abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash)\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/Math.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity 0.8.17;\\n\\nlibrary Math {\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b + (a % b == 0 ? 0 : 1);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lockManager\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"refundGas\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"result\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"txHash\",\"type\":\"bytes32\"}],\"name\":\"Executed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"gasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"refundTo\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"executeThroughIdentity\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"identity\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ping\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "RelayerModule", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000009dea56dc6ba9ad73c99eaacc81da0082c89cbd3f000000000000000000000000000000000000000000000000000000000000520800000000000000000000000000000000000000000000000000000000000055f0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}