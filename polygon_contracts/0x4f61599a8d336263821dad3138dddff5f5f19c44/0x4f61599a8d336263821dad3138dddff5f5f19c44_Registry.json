{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/operational/Registry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\nimport \\\"../interfaces/SignerOwnable.sol\\\";\\nimport \\\"../interfaces/IGateway.sol\\\";\\nimport \\\"./RegistryGateway.sol\\\";\\nimport \\\"./RegistryWorkflow.sol\\\";\\nimport \\\"./RegistryBalance.sol\\\";\\n\\n// TODO: 1. Charge user for the workflow registration and cancellation in order to perform the internal workflow.\\n//          Charged amount to the reward distribution pool.\\n// TODO: 2. Reward distribution on mainchain and sidechain logic.\\n//          Mainchain: send to the reward distribution pool.\\n\\n// Registry is the internal smart contract needed to secure the network and support important features of Nerif.\\ncontract Registry is Initializable, SignerOwnable, RegistryGateway, RegistryWorkflow, RegistryBalance {\\n    // Config contains the configuration options\\n    struct Config {\\n        // performanceOverhead is the cost of the performance transaction excluding the client contract call.\\n        uint256 performanceOverhead;\\n        // performancePremiumThreshold is the network premium threshold in percents.\\n        uint8 performancePremiumThreshold;\\n        // registrationOverhead is the cost of the workflow registration.\\n        uint256 registrationOverhead;\\n        // cancellationOverhead is the cost of the workflow cancellation.\\n        uint256 cancellationOverhead;\\n        // maxWorkflowsPerAccount is the maximum number of workflows per user.\\n        // 0 value means there is no limit.\\n        uint16 maxWorkflowsPerAccount;\\n    }\\n\\n    uint256 internal constant PERFORM_GAS_CUSHION = 5_000;\\n    string internal constant GATEWAY_PERFORM_FUNC_SIGNATURE = \\\"perform(uint256,address,bytes)\\\";\\n\\n    bool public isMainChain;\\n    Config public config;\\n    uint256 public networkRewards;\\n\\n    event BalanceFunded(address addr, uint256 amount);\\n    event BalanceWithdrawn(address addr, uint256 amount);\\n    event RewardsWithdrawn(address addr, uint256 amount);\\n    event GatewaySet(address owner, address gateway);\\n    event WorkflowRegistered(address owner, uint256 id, bytes hash);\\n    event WorkflowStatusChanged(uint256 id, WorkflowStatus status);\\n    event Performance(uint256 id, uint256 gasUsed, bool success);\\n\\n    // onlyMainchain permits transactions on the mainchain only\\n    modifier onlyMainchain() {\\n        require(isMainChain, \\\"Registry: operation is not permitted\\\");\\n        _;\\n    }\\n\\n    // onlyMsgSender checks that the given address is the transaction sender one.\\n    modifier onlyMsgSender(address addr) {\\n        require(addr == msg.sender, \\\"Registry: operation is not permitted\\\");\\n        _;\\n    }\\n\\n    // onlyMsgSenderOrSigner modifier for message sender or collective address only\\n    modifier onlyMsgSenderOrSigner(address addr) {\\n        if (isMainChain) {\\n            require(addr == msg.sender, \\\"Registry: operation is not permitted\\\");\\n            _;\\n        } else {\\n            require(signerGetter.getSignerAddress() == msg.sender, \\\"Registry: operation is not permitted\\\");\\n            _;\\n        }\\n    }\\n\\n    // onlyWorkflowOwnerOrSigner permits operation for the workflow owner if it is mainnet\\n    // or for the network collective address.\\n    modifier onlyWorkflowOwnerOrSigner(uint256 id) {\\n        if (isMainChain) {\\n            Workflow memory workflow = getWorkflow(id);\\n            require(workflow.owner == msg.sender, \\\"Registry: operation is not permitted\\\");\\n            _;\\n        } else {\\n            // Only network can execute the function on the sidechain.\\n            // The transaction must come from the network after reaching consensus.\\n            // Basically, the transaction must come from the registry contract itself,\\n            // namely from the perform function after passing all checks.\\n            require(signerGetter.getSignerAddress() == msg.sender, \\\"Registry: operation is not permitted\\\");\\n            _;\\n        }\\n    }\\n\\n    function initialize(\\n        bool _isMainChain,\\n        address _signerGetterAddress,\\n        Config calldata _config\\n    ) external initializer {\\n        isMainChain = _isMainChain;\\n        _setSignerGetter(_signerGetterAddress);\\n        config = _config;\\n    }\\n\\n    // fundBalance funds the balance of the sender's address with the given amount.\\n    function fundBalance() external payable {\\n        uint256 currentBalance = getBalance(msg.sender);\\n        _setBalance(msg.sender, currentBalance + msg.value);\\n        emit BalanceFunded(msg.sender, msg.value);\\n    }\\n\\n    // setConfig sets the given configuration\\n    function setConfig(Config calldata _config) external onlySigner {\\n        config = _config;\\n    }\\n\\n    // withdrawBalance withdraws the remaining balance of the sender's public key.\\n    // Permissions:\\n    //  - Only balance owner can withdraw its balance.\\n    // TODO: Handle cases when the withdrawal happens during the workflow execution. Introduce withdrawal request.\\n    function withdrawBalance() external {\\n        address payable sender = payable(msg.sender);\\n        uint256 balance = getBalance(sender);\\n\\n        // Ensure the sender has a positive balance\\n        require(balance > 0, \\\"Registry: no balance to withdraw\\\");\\n\\n        // Update the sender's balance\\n        _setBalance(sender, 0);\\n\\n        // Transfer the balance to the sender\\n        sender.transfer(balance);\\n\\n        // Emit an event to log the withdrawal transaction\\n        emit BalanceWithdrawn(sender, balance);\\n    }\\n\\n    // withdrawRewards sends network rewards to the rewards withdrawal address\\n    function withdrawRewards() external {\\n        require(networkRewards > 0, \\\"Registry: nothing to withdraw\\\");\\n        require(address(signerGetter) != address(0x0), \\\"Registry: signer storage address is not specified\\\");\\n\\n        address payable addr = payable(signerGetter.getSignerAddress());\\n        require(addr != address(0x0), \\\"Registry: withdrawal address is not specified\\\");\\n\\n        // Transfer rewards\\n        addr.transfer(networkRewards);\\n        networkRewards = 0;\\n\\n        // Emit an event to log the withdrawal transaction\\n        emit RewardsWithdrawn(addr, networkRewards);\\n    }\\n\\n    // setGateway sets gateway for the given owner address.\\n    function setGateway(address gateway) external {\\n        _setGateway(msg.sender, IGateway(gateway));\\n        emit GatewaySet(msg.sender, gateway);\\n    }\\n\\n    // pauseWorkflow pauses an existing active workflow.\\n    // Arguments:\\n    //  - \\\"id\\\" is the workflow identifier.\\n    // Permissions:\\n    //  - Permitted on MAINCHAIN only.\\n    //  - Only workflow owner can pause an existing active workflow.\\n    function pauseWorkflow(uint256 id) external onlyMainchain onlyExistingWorkflow(id) onlyWorkflowOwner(id) {\\n        // Find the workflow in the list\\n        Workflow memory workflow = getWorkflow(id);\\n\\n        // Check current workflow status\\n        require(workflow.status == WorkflowStatus.ACTIVE, \\\"Registry: only active workflows could be paused\\\");\\n\\n        // Update status\\n        workflow.status = WorkflowStatus.PAUSED;\\n        require(_updateWorkflow(workflow), \\\"Registry: failed to update workflow\\\");\\n\\n        emit WorkflowStatusChanged(id, WorkflowStatus.PAUSED);\\n    }\\n\\n    // resumeWorkflow resumes an existing paused workflow.\\n    // Arguments:\\n    //  - \\\"id\\\" is the workflow identifier.\\n    // Permissions:\\n    //  - Permitted on MAINCHAIN only.\\n    //  - Only workflow owner can resume an existing active workflow.\\n    function resumeWorkflow(uint256 id) external onlyMainchain onlyExistingWorkflow(id) onlyWorkflowOwner(id) {\\n        // Find the workflow in the list\\n        Workflow memory workflow = getWorkflow(id);\\n\\n        // Check current workflow status\\n        require(workflow.status == WorkflowStatus.PAUSED, \\\"Registry: only paused workflows could be resumed\\\");\\n\\n        // Update status\\n        workflow.status = WorkflowStatus.ACTIVE;\\n        require(_updateWorkflow(workflow), \\\"Registry: failed to update workflow\\\");\\n\\n        emit WorkflowStatusChanged(id, WorkflowStatus.ACTIVE);\\n    }\\n\\n    // perform performs the contract execution defined in the registered workflow.\\n    // The function checks that the given performance transaction was signed by the majority\\n    // of the network so the workflow owner could be charged and the transaction\\n    // with the given payload could be passed to the customer's contract.\\n    // Arguments:\\n    //  - \\\"workflowId\\\" is the workflow ID\\n    //  - \\\"gasAmount\\\" is the maximum number of gas used to execute the transaction\\n    //  - \\\"data\\\" is the contract call data\\n    //  - \\\"target\\\" is the client contract address\\n    // Permissions:\\n    //  - Only network can execute this function.\\n    function perform(\\n        uint256 workflowId,\\n        uint256 gasAmount,\\n        bytes calldata data,\\n        address target\\n    ) external onlySigner onlyExistingWorkflow(workflowId) {\\n        uint256 gasUsed = gasleft();\\n\\n        // Get a workflow by ID\\n        Workflow memory workflow = getWorkflow(workflowId);\\n        require(workflow.id > 0, \\\"Registry: workflow not found\\\");\\n\\n        // Make sure the workflow is not paused\\n        require(workflow.status == WorkflowStatus.ACTIVE, \\\"Registry: workflow must be active\\\");\\n\\n        // Get current balance of workflow owner\\n        uint256 currentBalance = getBalance(workflow.owner);\\n\\n        // Make sure workflow owner has enough funds\\n        require(currentBalance > 0, \\\"Registry: not enough funds on balance\\\");\\n\\n        // Cannot self-execute if not internal\\n        require(address(this) != target, \\\"Registry: operation is not permitted\\\");\\n\\n        // TODO: Make sure the given transaction was not performed yet\\n\\n        // Execute client's contract through gateway\\n        // Get workflow owner's gateway\\n        IGateway existingGateway = getGateway(workflow.owner); // TODO: Make sure it is not zero address\\n\\n        // Execute customer contract through its gateway\\n        bool success = _callWithExactGas(\\n            gasAmount,\\n            address(existingGateway),\\n            abi.encodeWithSignature(GATEWAY_PERFORM_FUNC_SIGNATURE, workflowId, target, data)\\n        );\\n\\n        gasUsed -= gasleft();\\n\\n        // Adding performance overhead if exists\\n        gasUsed += config.performanceOverhead;\\n\\n        // Adding performance premium\\n        if (config.performancePremiumThreshold > 0) {\\n            gasUsed += gasUsed / uint256(config.performancePremiumThreshold);\\n        }\\n\\n        // Calculate amount to charge\\n        uint256 amountToCharge = gasUsed * tx.gasprice;\\n\\n        // Make sure owner has enough funds\\n        require(currentBalance >= amountToCharge, \\\"Registry: not enough funds on balance\\\");\\n\\n        // Charge workflow owner balance\\n        _setBalance(workflow.owner, currentBalance - amountToCharge);\\n\\n        // Move amount to the network rewards balance\\n        networkRewards += amountToCharge;\\n\\n        // Update total spent amount of the current workflow\\n        workflow.totalSpent += amountToCharge;\\n        require(_updateWorkflow(workflow), \\\"Registry: failed to update workflow\\\");\\n\\n        // Emit performance event\\n        emit Performance(workflowId, gasUsed, success);\\n    }\\n\\n    // registerWorkflow registers a new workflow metadata.\\n    // Arguments:\\n    //  - \\\"id\\\" is the workflow identifier.\\n    //  - \\\"owner\\\" is the workflow owner address.\\n    //  - \\\"hash\\\" is the workflow hash.\\n    // The given signature must correspond to the given hash and created by the transaction sender.\\n    // Permissions:\\n    //  - Only workflow owner can register a workflow on MAINCHAIN.\\n    //  - Only network can register a workflow on SIDECHAIN throught the regular performance process.\\n    function registerWorkflow(\\n        uint256 id,\\n        address owner,\\n        bytes calldata hash,\\n        bool requireGateway\\n    ) external onlyMsgSenderOrSigner(owner) {\\n        // Check if the given workflow owner has a gateway registered.\\n        if (requireGateway) {\\n            IGateway existingGateway = getGateway(owner);\\n            require(address(existingGateway) != address(0x0), \\\"Registry: gateway not found\\\");\\n        }\\n\\n        // Check if the given sender has capacity to create one more workflow\\n        if (isMainChain && config.maxWorkflowsPerAccount > 0) {\\n            require(\\n                _workflowsPerAddress(msg.sender) < config.maxWorkflowsPerAccount,\\n                \\\"Registry: reached max workflows capacity\\\"\\n            );\\n        }\\n\\n        // Use ACTIVE workflow status by default for sidechains\\n        WorkflowStatus workflowStatus = WorkflowStatus.ACTIVE;\\n\\n        // Or set the PENDING one for the mainchain\\n        if (isMainChain) {\\n            workflowStatus = WorkflowStatus.PENDING;\\n        }\\n\\n        // Store a new workflow\\n        require(_addWorkflow(Workflow(id, owner, hash, workflowStatus, 0)), \\\"Registry: failed to add workflow\\\");\\n\\n        // Emmit the event\\n        emit WorkflowRegistered(msg.sender, id, hash);\\n    }\\n\\n    // activateWorkflow updates the workflow state from PENDING to ACTIVE.\\n    // Arguments:\\n    //  - \\\"id\\\" is the workflow identifier.\\n    //  - \\\"status\\\" is the workflow status.\\n    // Permissions:\\n    //  - Permitted on MAINCHAIN only.\\n    //  - Only network can execute it through the regular performance process.\\n    function activateWorkflow(uint256 id) external onlyMainchain onlySigner onlyExistingWorkflow(id) {\\n        // Find the workflow in the list\\n        Workflow memory workflow = getWorkflow(id);\\n\\n        // Must be PENDING\\n        require(workflow.status == WorkflowStatus.PENDING, \\\"Registry: workflow must be pending\\\");\\n\\n        // Update status\\n        workflow.status = WorkflowStatus.ACTIVE;\\n        require(_updateWorkflow(workflow), \\\"Registry: failed to update workflow\\\");\\n\\n        emit WorkflowStatusChanged(id, WorkflowStatus.ACTIVE);\\n    }\\n\\n    // cancelWorkflow cancels an existing workflow.\\n    // Arguments:\\n    //  - \\\"id\\\" is the workflow identifier.\\n    // Permissions:\\n    //  - Only workflow owner can cancel an existing active workflow on MAINCHAIN.\\n    //  - Only network can cancel a workflow on SIDECHAIN through the regular performance process.\\n    function cancelWorkflow(uint256 id) external onlyExistingWorkflow(id) onlyWorkflowOwnerOrSigner(id) {\\n        // Find the workflow in the list\\n        Workflow memory workflow = getWorkflow(id);\\n\\n        // Check current workflow status\\n        require(workflow.status != WorkflowStatus.CANCELLED, \\\"Registry: workflow is already cancelled\\\");\\n\\n        // Update status\\n        workflow.status = WorkflowStatus.CANCELLED;\\n        require(_updateWorkflow(workflow), \\\"Registry: failed to update workflow\\\");\\n\\n        emit WorkflowStatusChanged(id, WorkflowStatus.CANCELLED);\\n    }\\n\\n    // getWorkflowOwnerBalance returns the current balance of the given workflow ID.\\n    function getWorkflowOwnerBalance(uint256 id) public view returns (uint256) {\\n        // Find the workflow in the list\\n        Workflow memory workflow = getWorkflow(id);\\n        require(workflow.owner != address(0x0), \\\"Registry: workflow does not exist\\\");\\n\\n        // Return owner's balance\\n        return getBalance(workflow.owner);\\n    }\\n\\n    // _callWithExactGas calls target address with exactly gasAmount gas and data as calldata\\n    // or reverts if at least gasAmount gas is not available\\n    function _callWithExactGas(\\n        uint256 gasAmount,\\n        address target,\\n        bytes memory data\\n    ) private returns (bool success) {\\n        assembly {\\n            let g := gas()\\n\\n            // Compute g -= PERFORM_GAS_CUSHION and check for underflow\\n            if lt(g, PERFORM_GAS_CUSHION) {\\n                revert(0, 0)\\n            }\\n\\n            g := sub(g, PERFORM_GAS_CUSHION)\\n\\n            // if g - g//64 <= gasAmount, revert\\n            // (we subtract g//64 because of EIP-150)\\n            if iszero(gt(sub(g, div(g, 64)), gasAmount)) {\\n                revert(0, 0)\\n            }\\n\\n            // solidity calls check that a contract actually exists at the destination, so we do the same\\n            if iszero(extcodesize(target)) {\\n                revert(0, 0)\\n            }\\n\\n            // call and return whether we succeeded. ignore return data\\n            success := call(gasAmount, target, 0, add(data, 0x20), mload(data), 0, 0)\\n        }\\n        return success;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = _setInitializedVersion(1);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\\n     * initialization.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        bool isTopLevelCall = _setInitializedVersion(version);\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(version);\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     */\\n    function _disableInitializers() internal virtual {\\n        _setInitializedVersion(type(uint8).max);\\n    }\\n\\n    function _setInitializedVersion(uint8 version) private returns (bool) {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\\n        // of initializers, because in other contexts the contract may have been reentered.\\n        if (_initializing) {\\n            require(\\n                version == 1 && !AddressUpgradeable.isContract(address(this)),\\n                \\\"Initializable: contract is already initialized\\\"\\n            );\\n            return false;\\n        } else {\\n            require(_initialized < version, \\\"Initializable: contract is already initialized\\\");\\n            _initialized = version;\\n            return true;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/SignerOwnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ISignerAddress.sol\\\";\\n\\nabstract contract SignerOwnable {\\n    ISignerAddress public signerGetter;\\n\\n    modifier onlySigner() {\\n        require(signerGetter.getSignerAddress() == msg.sender, \\\"SignerOwnable: only signer\\\");\\n        _;\\n    }\\n\\n    function _setSignerGetter(address _signerGetterAddress) internal virtual {\\n        signerGetter = ISignerAddress(_signerGetterAddress);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n// IGateway represents the customer gateway contract behaviour.\\ninterface IGateway {\\n    // perform is the entrypoint function of all customer contracts.\\n    // This function accepts the workflow ID and the end customer contract\\n    // execution payload.\\n    // The function checks that the given transaction is permitted and can be forwarded\\n    // next to the end customer contract.\\n    function perform(\\n        uint256 id,\\n        address target,\\n        bytes calldata payload\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/operational/RegistryGateway.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IGateway.sol\\\";\\n\\nabstract contract RegistryGateway {\\n    struct Gateway {\\n        IGateway gateway;\\n        address owner;\\n    }\\n\\n    mapping(address => uint256) private indexMap;\\n    Gateway[] private gateways;\\n\\n    function getGateways() external view returns (Gateway[] memory) {\\n        return gateways;\\n    }\\n\\n    function getGateway(address owner) public view returns (IGateway) {\\n        if (!_hasGateway(owner)) {\\n            return IGateway(address(0x0));\\n        }\\n\\n        return gateways[indexMap[owner] - 1].gateway;\\n    }\\n\\n    function _setGateway(address owner, IGateway gateway) internal {\\n        if (_hasGateway(owner)) {\\n            gateways[indexMap[owner] - 1] = Gateway(gateway, owner);\\n        } else {\\n            gateways.push(Gateway(gateway, owner));\\n            indexMap[owner] = gateways.length;\\n        }\\n\\n        _checkGatewayEntry(owner);\\n    }\\n\\n    function _checkGatewayEntry(address owner) private view {\\n        uint256 index = indexMap[owner];\\n        assert(index <= gateways.length);\\n\\n        if (_hasGateway(owner)) {\\n            assert(index > 0);\\n        } else {\\n            assert(index == 0);\\n        }\\n    }\\n\\n    function _hasGateway(address owner) private view returns (bool) {\\n        return indexMap[owner] > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/operational/RegistryWorkflow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nenum WorkflowStatus {\\n    PENDING,\\n    ACTIVE,\\n    PAUSED,\\n    CANCELLED\\n}\\n\\nstruct Workflow {\\n    uint256 id;\\n    address owner;\\n    bytes hash;\\n    WorkflowStatus status;\\n    uint256 totalSpent;\\n}\\n\\nabstract contract RegistryWorkflow {\\n    mapping(uint256 => uint256) private indexMap;\\n    Workflow[] private workflows;\\n    mapping(address => uint64) private perAddress;\\n\\n    modifier onlyExistingWorkflow(uint256 id) {\\n        Workflow memory workflow = getWorkflow(id);\\n        require(workflow.id > 0, \\\"Registry: workflow does not exist\\\");\\n        _;\\n    }\\n\\n    modifier onlyWorkflowOwner(uint256 id) {\\n        Workflow memory workflow = getWorkflow(id);\\n        require(workflow.owner == msg.sender, \\\"Registry: operation not permitted\\\");\\n        _;\\n    }\\n\\n    function getWorkflow(uint256 id) public view returns (Workflow memory) {\\n        require(_hasWorkflow(id), \\\"Registry: workflow does not exist\\\");\\n        return workflows[indexMap[id] - 1];\\n    }\\n\\n    function getWorkflows() public view returns (Workflow[] memory) {\\n        return workflows;\\n    }\\n\\n    function _addWorkflow(Workflow memory _workflow) internal returns (bool) {\\n        if (_hasWorkflow(_workflow.id)) {\\n            return false;\\n        }\\n\\n        workflows.push(_workflow);\\n        indexMap[_workflow.id] = workflows.length;\\n        perAddress[_workflow.owner]++;\\n\\n        _checkWorkflowEntry(_workflow.id);\\n\\n        return true;\\n    }\\n\\n    function _updateWorkflow(Workflow memory _workflow) internal returns (bool) {\\n        if (!_hasWorkflow(_workflow.id)) {\\n            return false;\\n        }\\n\\n        workflows[indexMap[_workflow.id] - 1] = _workflow;\\n\\n        _checkWorkflowEntry(_workflow.id);\\n\\n        return true;\\n    }\\n\\n    function _workflowsPerAddress(address owner) internal view returns (uint256) {\\n        return perAddress[owner];\\n    }\\n\\n    function _checkWorkflowEntry(uint256 id) private view {\\n        uint256 index = indexMap[id];\\n        assert(index <= workflows.length);\\n\\n        if (_hasWorkflow(id)) {\\n            assert(index > 0);\\n        } else {\\n            assert(index == 0);\\n        }\\n    }\\n\\n    function _hasWorkflow(uint256 id) private view returns (bool) {\\n        return indexMap[id] > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/operational/RegistryBalance.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nabstract contract RegistryBalance {\\n    struct Balance {\\n        address user;\\n        uint256 balance;\\n    }\\n\\n    mapping(address => uint256) private indexMap;\\n    Balance[] private balances;\\n\\n    function getBalances() external view returns (Balance[] memory) {\\n        return balances;\\n    }\\n\\n    function getBalance(address user) public view returns (uint256) {\\n        if (!_hasBalance(user)) {\\n            return 0;\\n        }\\n\\n        return balances[indexMap[user] - 1].balance;\\n    }\\n\\n    function _setBalance(address user, uint256 balance) internal {\\n        if (_hasBalance(user)) {\\n            balances[indexMap[user] - 1] = Balance(user, balance);\\n        } else {\\n            balances.push(Balance(user, balance));\\n            indexMap[user] = balances.length;\\n        }\\n\\n        _checkBalanceEntry(user);\\n    }\\n\\n    function _checkBalanceEntry(address user) private view {\\n        uint256 index = indexMap[user];\\n        assert(index <= balances.length);\\n\\n        if (_hasBalance(user)) {\\n            assert(index > 0);\\n        } else {\\n            assert(index == 0);\\n        }\\n    }\\n\\n    function _hasBalance(address user) private view returns (bool) {\\n        return indexMap[user] > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISignerAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\n\\n// ISignerAddress represents the behavior of the contract that holds the network collective address\\n// generated during DKG process.\\ninterface ISignerAddress {\\n    // getSignerAddress returns the current signer address\\n    function getSignerAddress() external view returns (address);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BalanceFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BalanceWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gateway\",\"type\":\"address\"}],\"name\":\"GatewaySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"name\":\"Performance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"}],\"name\":\"WorkflowRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum WorkflowStatus\",\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"WorkflowStatusChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"activateWorkflow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelWorkflow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"performanceOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"performancePremiumThreshold\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"registrationOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cancellationOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxWorkflowsPerAccount\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fundBalance\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"internalType\":\"struct RegistryBalance.Balance[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getGateway\",\"outputs\":[{\"internalType\":\"contract IGateway\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGateways\",\"outputs\":[{\"components\":[{\"internalType\":\"contract IGateway\",\"name\":\"gateway\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"internalType\":\"struct RegistryGateway.Gateway[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getWorkflow\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"},{\"internalType\":\"enum WorkflowStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalSpent\",\"type\":\"uint256\"}],\"internalType\":\"struct Workflow\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getWorkflowOwnerBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getWorkflows\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"},{\"internalType\":\"enum WorkflowStatus\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"totalSpent\",\"type\":\"uint256\"}],\"internalType\":\"struct Workflow[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isMainChain\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"_signerGetterAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"performanceOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"performancePremiumThreshold\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"registrationOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cancellationOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxWorkflowsPerAccount\",\"type\":\"uint16\"}],\"internalType\":\"struct Registry.Config\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isMainChain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"networkRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"pauseWorkflow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"workflowId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"perform\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"hash\",\"type\":\"bytes\"},{\"internalType\":\"bool\",\"name\":\"requireGateway\",\"type\":\"bool\"}],\"name\":\"registerWorkflow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"resumeWorkflow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"performanceOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"performancePremiumThreshold\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"registrationOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cancellationOverhead\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"maxWorkflowsPerAccount\",\"type\":\"uint16\"}],\"internalType\":\"struct Registry.Config\",\"name\":\"_config\",\"type\":\"tuple\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gateway\",\"type\":\"address\"}],\"name\":\"setGateway\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"signerGetter\",\"outputs\":[{\"internalType\":\"contract ISignerAddress\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Registry", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}