{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-or-later\r\n\r\n/// ProxyRegistry.sol\r\n\r\n// Copyright (C) 2018-2021 Dai Foundation\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU Affero General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU Affero General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU Affero General Public License\r\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\r\n\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.4.23;\r\n\r\ncontract DSTest {\r\n    event log                    (string);\r\n    event logs                   (bytes);\r\n\r\n    event log_address            (address);\r\n    event log_bytes32            (bytes32);\r\n    event log_int                (int);\r\n    event log_uint               (uint);\r\n    event log_bytes              (bytes);\r\n    event log_string             (string);\r\n\r\n    event log_named_address      (string key, address val);\r\n    event log_named_bytes32      (string key, bytes32 val);\r\n    event log_named_decimal_int  (string key, int val, uint decimals);\r\n    event log_named_decimal_uint (string key, uint val, uint decimals);\r\n    event log_named_int          (string key, int val);\r\n    event log_named_uint         (string key, uint val);\r\n    event log_named_bytes        (string key, bytes val);\r\n    event log_named_string       (string key, string val);\r\n\r\n    bool public IS_TEST = true;\r\n    bool public failed;\r\n\r\n    address constant HEVM_ADDRESS =\r\n        address(bytes20(uint160(uint256(keccak256('hevm cheat code')))));\r\n\r\n    modifier mayRevert() { _; }\r\n    modifier testopts(string memory) { _; }\r\n\r\n    function fail() internal {\r\n        failed = true;\r\n    }\r\n\r\n    modifier logs_gas() {\r\n        uint startGas = gasleft();\r\n        _;\r\n        uint endGas = gasleft();\r\n        emit log_named_uint(\"gas\", startGas - endGas);\r\n    }\r\n\r\n    function assertTrue(bool condition) internal {\r\n        if (!condition) {\r\n            emit log(\"Error: Assertion Failed\");\r\n            fail();\r\n        }\r\n    }\r\n\r\n    function assertTrue(bool condition, string memory err) internal {\r\n        if (!condition) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertTrue(condition);\r\n        }\r\n    }\r\n\r\n    function assertEq(address a, address b) internal {\r\n        if (a != b) {\r\n            emit log(\"Error: a == b not satisfied [address]\");\r\n            emit log_named_address(\"  Expected\", b);\r\n            emit log_named_address(\"    Actual\", a);\r\n            fail();\r\n        }\r\n    }\r\n    function assertEq(address a, address b, string memory err) internal {\r\n        if (a != b) {\r\n            emit log_named_string (\"Error\", err);\r\n            assertEq(a, b);\r\n        }\r\n    }\r\n\r\n    function assertEq(bytes32 a, bytes32 b) internal {\r\n        if (a != b) {\r\n            emit log(\"Error: a == b not satisfied [bytes32]\");\r\n            emit log_named_bytes32(\"  Expected\", b);\r\n            emit log_named_bytes32(\"    Actual\", a);\r\n            fail();\r\n        }\r\n    }\r\n    function assertEq(bytes32 a, bytes32 b, string memory err) internal {\r\n        if (a != b) {\r\n            emit log_named_string (\"Error\", err);\r\n            assertEq(a, b);\r\n        }\r\n    }\r\n    function assertEq32(bytes32 a, bytes32 b) internal {\r\n        assertEq(a, b);\r\n    }\r\n    function assertEq32(bytes32 a, bytes32 b, string memory err) internal {\r\n        assertEq(a, b, err);\r\n    }\r\n\r\n    function assertEq(int a, int b) internal {\r\n        if (a != b) {\r\n            emit log(\"Error: a == b not satisfied [int]\");\r\n            emit log_named_int(\"  Expected\", b);\r\n            emit log_named_int(\"    Actual\", a);\r\n            fail();\r\n        }\r\n    }\r\n    function assertEq(int a, int b, string memory err) internal {\r\n        if (a != b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertEq(a, b);\r\n        }\r\n    }\r\n    function assertEq(uint a, uint b) internal {\r\n        if (a != b) {\r\n            emit log(\"Error: a == b not satisfied [uint]\");\r\n            emit log_named_uint(\"  Expected\", b);\r\n            emit log_named_uint(\"    Actual\", a);\r\n            fail();\r\n        }\r\n    }\r\n    function assertEq(uint a, uint b, string memory err) internal {\r\n        if (a != b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertEq(a, b);\r\n        }\r\n    }\r\n    function assertEqDecimal(int a, int b, uint decimals) internal {\r\n        if (a != b) {\r\n            emit log(\"Error: a == b not satisfied [decimal int]\");\r\n            emit log_named_decimal_int(\"  Expected\", b, decimals);\r\n            emit log_named_decimal_int(\"    Actual\", a, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertEqDecimal(int a, int b, uint decimals, string memory err) internal {\r\n        if (a != b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertEqDecimal(a, b, decimals);\r\n        }\r\n    }\r\n    function assertEqDecimal(uint a, uint b, uint decimals) internal {\r\n        if (a != b) {\r\n            emit log(\"Error: a == b not satisfied [decimal uint]\");\r\n            emit log_named_decimal_uint(\"  Expected\", b, decimals);\r\n            emit log_named_decimal_uint(\"    Actual\", a, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertEqDecimal(uint a, uint b, uint decimals, string memory err) internal {\r\n        if (a != b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertEqDecimal(a, b, decimals);\r\n        }\r\n    }\r\n\r\n    function assertGt(uint a, uint b) internal {\r\n        if (a <= b) {\r\n            emit log(\"Error: a > b not satisfied [uint]\");\r\n            emit log_named_uint(\"  Value a\", a);\r\n            emit log_named_uint(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertGt(uint a, uint b, string memory err) internal {\r\n        if (a <= b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGt(a, b);\r\n        }\r\n    }\r\n    function assertGt(int a, int b) internal {\r\n        if (a <= b) {\r\n            emit log(\"Error: a > b not satisfied [int]\");\r\n            emit log_named_int(\"  Value a\", a);\r\n            emit log_named_int(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertGt(int a, int b, string memory err) internal {\r\n        if (a <= b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGt(a, b);\r\n        }\r\n    }\r\n    function assertGtDecimal(int a, int b, uint decimals) internal {\r\n        if (a <= b) {\r\n            emit log(\"Error: a > b not satisfied [decimal int]\");\r\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\r\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertGtDecimal(int a, int b, uint decimals, string memory err) internal {\r\n        if (a <= b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGtDecimal(a, b, decimals);\r\n        }\r\n    }\r\n    function assertGtDecimal(uint a, uint b, uint decimals) internal {\r\n        if (a <= b) {\r\n            emit log(\"Error: a > b not satisfied [decimal uint]\");\r\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\r\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertGtDecimal(uint a, uint b, uint decimals, string memory err) internal {\r\n        if (a <= b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGtDecimal(a, b, decimals);\r\n        }\r\n    }\r\n\r\n    function assertGe(uint a, uint b) internal {\r\n        if (a < b) {\r\n            emit log(\"Error: a >= b not satisfied [uint]\");\r\n            emit log_named_uint(\"  Value a\", a);\r\n            emit log_named_uint(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertGe(uint a, uint b, string memory err) internal {\r\n        if (a < b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGe(a, b);\r\n        }\r\n    }\r\n    function assertGe(int a, int b) internal {\r\n        if (a < b) {\r\n            emit log(\"Error: a >= b not satisfied [int]\");\r\n            emit log_named_int(\"  Value a\", a);\r\n            emit log_named_int(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertGe(int a, int b, string memory err) internal {\r\n        if (a < b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGe(a, b);\r\n        }\r\n    }\r\n    function assertGeDecimal(int a, int b, uint decimals) internal {\r\n        if (a < b) {\r\n            emit log(\"Error: a >= b not satisfied [decimal int]\");\r\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\r\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertGeDecimal(int a, int b, uint decimals, string memory err) internal {\r\n        if (a < b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGeDecimal(a, b, decimals);\r\n        }\r\n    }\r\n    function assertGeDecimal(uint a, uint b, uint decimals) internal {\r\n        if (a < b) {\r\n            emit log(\"Error: a >= b not satisfied [decimal uint]\");\r\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\r\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertGeDecimal(uint a, uint b, uint decimals, string memory err) internal {\r\n        if (a < b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGeDecimal(a, b, decimals);\r\n        }\r\n    }\r\n\r\n    function assertLt(uint a, uint b) internal {\r\n        if (a >= b) {\r\n            emit log(\"Error: a < b not satisfied [uint]\");\r\n            emit log_named_uint(\"  Value a\", a);\r\n            emit log_named_uint(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertLt(uint a, uint b, string memory err) internal {\r\n        if (a >= b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertLt(a, b);\r\n        }\r\n    }\r\n    function assertLt(int a, int b) internal {\r\n        if (a >= b) {\r\n            emit log(\"Error: a < b not satisfied [int]\");\r\n            emit log_named_int(\"  Value a\", a);\r\n            emit log_named_int(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertLt(int a, int b, string memory err) internal {\r\n        if (a >= b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertLt(a, b);\r\n        }\r\n    }\r\n    function assertLtDecimal(int a, int b, uint decimals) internal {\r\n        if (a >= b) {\r\n            emit log(\"Error: a < b not satisfied [decimal int]\");\r\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\r\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertLtDecimal(int a, int b, uint decimals, string memory err) internal {\r\n        if (a >= b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertLtDecimal(a, b, decimals);\r\n        }\r\n    }\r\n    function assertLtDecimal(uint a, uint b, uint decimals) internal {\r\n        if (a >= b) {\r\n            emit log(\"Error: a < b not satisfied [decimal uint]\");\r\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\r\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertLtDecimal(uint a, uint b, uint decimals, string memory err) internal {\r\n        if (a >= b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertLtDecimal(a, b, decimals);\r\n        }\r\n    }\r\n\r\n    function assertLe(uint a, uint b) internal {\r\n        if (a > b) {\r\n            emit log(\"Error: a <= b not satisfied [uint]\");\r\n            emit log_named_uint(\"  Value a\", a);\r\n            emit log_named_uint(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertLe(uint a, uint b, string memory err) internal {\r\n        if (a > b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertLe(a, b);\r\n        }\r\n    }\r\n    function assertLe(int a, int b) internal {\r\n        if (a > b) {\r\n            emit log(\"Error: a <= b not satisfied [int]\");\r\n            emit log_named_int(\"  Value a\", a);\r\n            emit log_named_int(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertLe(int a, int b, string memory err) internal {\r\n        if (a > b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertLe(a, b);\r\n        }\r\n    }\r\n    function assertLeDecimal(int a, int b, uint decimals) internal {\r\n        if (a > b) {\r\n            emit log(\"Error: a <= b not satisfied [decimal int]\");\r\n            emit log_named_decimal_int(\"  Value a\", a, decimals);\r\n            emit log_named_decimal_int(\"  Value b\", b, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertLeDecimal(int a, int b, uint decimals, string memory err) internal {\r\n        if (a > b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertLeDecimal(a, b, decimals);\r\n        }\r\n    }\r\n    function assertLeDecimal(uint a, uint b, uint decimals) internal {\r\n        if (a > b) {\r\n            emit log(\"Error: a <= b not satisfied [decimal uint]\");\r\n            emit log_named_decimal_uint(\"  Value a\", a, decimals);\r\n            emit log_named_decimal_uint(\"  Value b\", b, decimals);\r\n            fail();\r\n        }\r\n    }\r\n    function assertLeDecimal(uint a, uint b, uint decimals, string memory err) internal {\r\n        if (a > b) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertGeDecimal(a, b, decimals);\r\n        }\r\n    }\r\n\r\n    function assertEq(string memory a, string memory b) internal {\r\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\r\n            emit log(\"Error: a == b not satisfied [string]\");\r\n            emit log_named_string(\"  Value a\", a);\r\n            emit log_named_string(\"  Value b\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertEq(string memory a, string memory b, string memory err) internal {\r\n        if (keccak256(abi.encodePacked(a)) != keccak256(abi.encodePacked(b))) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertEq(a, b);\r\n        }\r\n    }\r\n\r\n    function checkEq0(bytes memory a, bytes memory b) internal pure returns (bool ok) {\r\n        ok = true;\r\n        if (a.length == b.length) {\r\n            for (uint i = 0; i < a.length; i++) {\r\n                if (a[i] != b[i]) {\r\n                    ok = false;\r\n                }\r\n            }\r\n        } else {\r\n            ok = false;\r\n        }\r\n    }\r\n    function assertEq0(bytes memory a, bytes memory b) internal {\r\n        if (!checkEq0(a, b)) {\r\n            emit log(\"Error: a == b not satisfied [bytes]\");\r\n            emit log_named_bytes(\"  Expected\", a);\r\n            emit log_named_bytes(\"    Actual\", b);\r\n            fail();\r\n        }\r\n    }\r\n    function assertEq0(bytes memory a, bytes memory b, string memory err) internal {\r\n        if (!checkEq0(a, b)) {\r\n            emit log_named_string(\"Error\", err);\r\n            assertEq0(a, b);\r\n        }\r\n    }\r\n}\r\n\r\n/// note.sol -- the `note' modifier, for logging calls as events\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.4.23;\r\n\r\ncontract DSNote {\r\n    event LogNote(\r\n        bytes4   indexed  sig,\r\n        address  indexed  guy,\r\n        bytes32  indexed  foo,\r\n        bytes32  indexed  bar,\r\n        uint256           wad,\r\n        bytes             fax\r\n    ) anonymous;\r\n\r\n    modifier note {\r\n        bytes32 foo;\r\n        bytes32 bar;\r\n        uint256 wad;\r\n\r\n        assembly {\r\n            foo := calldataload(4)\r\n            bar := calldataload(36)\r\n            wad := callvalue()\r\n        }\r\n\r\n        _;\r\n\r\n        emit LogNote(msg.sig, msg.sender, foo, bar, wad, msg.data);\r\n    }\r\n}\r\n\r\n\r\n// SPDX-License-Identifier: GNU-3\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.4.23;\r\n\r\ninterface DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) external view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(address(authority));\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig), \"ds-auth-unauthorized\");\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(address(0))) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, address(this), sig);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// proxy.sol - execute actions atomically through the proxy's identity\r\n\r\n// Copyright (C) 2017  DappHub, LLC\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.5.0 <0.6.0;\r\n\r\n// import \"ds-auth/auth.sol\";\r\n// import \"ds-note/note.sol\";\r\n\r\n// DSProxy\r\n// Allows code execution using a persistant identity This can be very\r\n// useful to execute a sequence of atomic actions. Since the owner of\r\n// the proxy can be changed, this allows for dynamic ownership models\r\n// i.e. a multisig\r\ncontract DSProxy is DSAuth, DSNote {\r\n    DSProxyCache public cache;  // global cache for contracts\r\n\r\n    constructor(address _cacheAddr) public {\r\n        setCache(_cacheAddr);\r\n    }\r\n\r\n    function() external payable {\r\n    }\r\n\r\n    // use the proxy to execute calldata _data on contract _code\r\n    function execute(bytes memory _code, bytes memory _data)\r\n        public\r\n        payable\r\n        returns (address target, bytes memory response)\r\n    {\r\n        target = cache.read(_code);\r\n        if (target == address(0)) {\r\n            // deploy contract & store its address in cache\r\n            target = cache.write(_code);\r\n        }\r\n\r\n        response = execute(target, _data);\r\n    }\r\n\r\n    function execute(address _target, bytes memory _data)\r\n        public\r\n        auth\r\n        note\r\n        payable\r\n        returns (bytes memory response)\r\n    {\r\n        require(_target != address(0), \"ds-proxy-target-address-required\");\r\n\r\n        // call contract in current context\r\n        assembly {\r\n            let succeeded := delegatecall(sub(gas, 5000), _target, add(_data, 0x20), mload(_data), 0, 0)\r\n            let size := returndatasize\r\n\r\n            response := mload(0x40)\r\n            mstore(0x40, add(response, and(add(add(size, 0x20), 0x1f), not(0x1f))))\r\n            mstore(response, size)\r\n            returndatacopy(add(response, 0x20), 0, size)\r\n\r\n            switch iszero(succeeded)\r\n            case 1 {\r\n                // throw if delegatecall failed\r\n                revert(add(response, 0x20), size)\r\n            }\r\n        }\r\n    }\r\n\r\n    //set new cache\r\n    function setCache(address _cacheAddr)\r\n        public\r\n        auth\r\n        note\r\n        returns (bool)\r\n    {\r\n        require(_cacheAddr != address(0), \"ds-proxy-cache-address-required\");\r\n        cache = DSProxyCache(_cacheAddr);  // overwrite cache\r\n        return true;\r\n    }\r\n}\r\n\r\n// DSProxyFactory\r\n// This factory deploys new proxy instances through build()\r\n// Deployed proxy addresses are logged\r\ncontract DSProxyFactory {\r\n    event Created(address indexed sender, address indexed owner, address proxy, address cache);\r\n    mapping(address=>bool) public isProxy;\r\n    DSProxyCache public cache;\r\n\r\n    constructor() public {\r\n        cache = new DSProxyCache();\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets owner of proxy to caller\r\n    function build() public returns (address payable proxy) {\r\n        proxy = build(msg.sender);\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets custom owner of proxy\r\n    function build(address owner) public returns (address payable proxy) {\r\n        proxy = address(new DSProxy(address(cache)));\r\n        emit Created(msg.sender, owner, address(proxy), address(cache));\r\n        DSProxy(proxy).setOwner(owner);\r\n        isProxy[proxy] = true;\r\n    }\r\n}\r\n\r\n// DSProxyCache\r\n// This global cache stores addresses of contracts previously deployed\r\n// by a proxy. This saves gas from repeat deployment of the same\r\n// contracts and eliminates blockchain bloat.\r\n\r\n// By default, all proxies deployed from the same factory store\r\n// contracts in the same cache. The cache a proxy instance uses can be\r\n// changed.  The cache uses the sha3 hash of a contract's bytecode to\r\n// lookup the address\r\ncontract DSProxyCache {\r\n    mapping(bytes32 => address) cache;\r\n\r\n    function read(bytes memory _code) public view returns (address) {\r\n        bytes32 hash = keccak256(_code);\r\n        return cache[hash];\r\n    }\r\n\r\n    function write(bytes memory _code) public returns (address target) {\r\n        assembly {\r\n            target := create(0, add(_code, 0x20), mload(_code))\r\n            switch iszero(extcodesize(target))\r\n            case 1 {\r\n                // throw if contract failed to deploy\r\n                revert(0, 0)\r\n            }\r\n        }\r\n        bytes32 hash = keccak256(_code);\r\n        cache[hash] = target;\r\n    }\r\n}\r\n\r\npragma solidity >=0.5.0;\r\n\r\n\r\n// This Registry deploys new proxy instances through DSProxyFactory.build(address) and keeps a registry of owner => proxy\r\ncontract ProxyRegistry {\r\n    mapping(address => DSProxy) public proxies;\r\n    DSProxyFactory factory;\r\n\r\n    constructor(address factory_) public {\r\n        factory = DSProxyFactory(factory_);\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets owner of proxy to caller\r\n    function build() public returns (address payable proxy) {\r\n        proxy = build(msg.sender);\r\n    }\r\n\r\n    // deploys a new proxy instance\r\n    // sets custom owner of proxy\r\n    function build(address owner) public returns (address payable proxy) {\r\n        require(proxies[owner] == DSProxy(0) || proxies[owner].owner() != owner); // Not allow new proxy if the user already has one and remains being the owner\r\n        proxy = factory.build(owner);\r\n        proxies[owner] = DSProxy(proxy);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"factory_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"constant\":false,\"inputs\":[],\"name\":\"build\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"build\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"proxy\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"proxies\",\"outputs\":[{\"internalType\":\"contract DSProxy\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ProxyRegistry", "CompilerVersion": "v0.5.17+commit.d19bba13", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000a95ab9c8a859138762e9b7e3228d37f7ada17d76", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://f37c985b2664d0027057fbbbd599160beafee9fa9a49809cfdb4b918343bfaf9"}