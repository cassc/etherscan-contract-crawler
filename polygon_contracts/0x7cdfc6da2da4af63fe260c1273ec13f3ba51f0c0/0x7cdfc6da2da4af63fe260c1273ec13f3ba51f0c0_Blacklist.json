{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts-verify/Blacklist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {Errors} from \\\"./libraries/Errors.sol\\\";\\nimport {IAccessControl} from \\\"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\nimport {IBlacklist} from \\\"./interfaces/IBlacklist.sol\\\";\\nimport {Roles} from \\\"./libraries/Roles.sol\\\";\\n\\n/**\\n * @title MCAG Blacklist\\n * @author MIMO Labs\\n * @notice This contract stores the blacklist for MCAG\\n */\\ncontract Blacklist is IBlacklist {\\n    IAccessControl public immutable accessController;\\n\\n    mapping(address => bool) private _blacklisted;\\n\\n    /**\\n     * @dev Throws if called by any account other than the blacklister\\n     */\\n    modifier onlyBlacklister() {\\n        if (!accessController.hasRole(Roles.MCAG_BLACKLIST_ROLE, msg.sender)) {\\n            revert Errors.BLACKLIST_CALLER_IS_NOT_BLACKLISTER();\\n        }\\n        _;\\n    }\\n\\n    constructor(IAccessControl _accessController) {\\n        if (address(_accessController) == address(0)) {\\n            revert Errors.CANNOT_SET_TO_ADDRESS_ZERO();\\n        }\\n        accessController = _accessController;\\n\\n        emit AccessControllerSet(address(_accessController));\\n    }\\n\\n    /**\\n     * @dev Adds account to blacklist\\n     * @dev Caller must have MCAG_BLACKLIST_ROLE\\n     * @param account The address to blacklist\\n     */\\n    function blacklist(address account) external onlyBlacklister {\\n        if (_blacklisted[account]) {\\n            revert Errors.BLACKLIST_ACCOUNT_IS_BLACKLISTED(account);\\n        }\\n        _blacklisted[account] = true;\\n        emit Blacklisted(account);\\n    }\\n\\n    /**\\n     * @dev Removes account from blacklist\\n     * @dev Caller must have MCAG_BLACKLIST_ROLE\\n     * @param account The address to remove from the blacklist\\n     */\\n    function unBlacklist(address account) external onlyBlacklister {\\n        if (!_blacklisted[account]) {\\n            revert Errors.BLACKLIST_ACCOUNT_IS_NOT_BLACKLISTED(account);\\n        }\\n        _blacklisted[account] = false;\\n        emit UnBlacklisted(account);\\n    }\\n\\n    /**\\n     * @dev Checks if account is blacklisted\\n     * @param account The address to check\\n     * @return True if the given account is blacklisted, false otherwise\\n     */\\n    function isBlacklisted(address account) external view returns (bool) {\\n        return _blacklisted[account];\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts-verify/interfaces/IBlacklist.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport {IAccessControl} from \\\"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\\\";\\n\\ninterface IBlacklist {\\n    event AccessControllerSet(address accesController);\\n    event Blacklisted(address indexed account);\\n    event UnBlacklisted(address indexed account);\\n\\n    function blacklist(address account) external;\\n\\n    function unBlacklist(address account) external;\\n\\n    function accessController() external view returns (IAccessControl);\\n\\n    function isBlacklisted(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts-verify/libraries/Errors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary Errors {\\n    error CANNOT_SET_TO_ADDRESS_ZERO();\\n    error ERC721_APPROVAL_TO_CURRENT_OWNER();\\n    error ERC721_APPROVE_CALLER_IS_NOT_TOKEN_OWNER_OR_APPROVED_FOR_ALL();\\n    error ERC721_INVALID_TOKEN_ID();\\n    error ERC721_CALLER_IS_NOT_TOKEN_OWNER();\\n    error ACCESS_CONTROL_ACCOUNT_IS_MISSING_ROLE(address account, bytes32 role);\\n    error BLACKLIST_CALLER_IS_NOT_BLACKLISTER();\\n    error BLACKLIST_ACCOUNT_IS_NOT_BLACKLISTED(address account);\\n    error BLACKLIST_ACCOUNT_IS_BLACKLISTED(address account);\\n    error TRANSMITTED_ANSWER_TOO_HIGH(int256 answer, int256 maxAnswer);\\n    error TRANSMITTED_ANSWER_TOO_LOW(int256 answer, int256 minAnswer);\\n    error TOKEN_IS_NOT_TRANSFERABLE();\\n    error KYC_DATA_OWNER_MISMATCH(address to, address owner);\\n    error RATE_TOO_VOLATILE(uint256 absoluteRateChange, uint256 volatilityThreshold);\\n    error INVALID_VOLATILITY_THRESHOLD();\\n    error TERMS_AND_CONDITIONS_URL_DOES_NOT_EXIST(uint256 tncId);\\n    error TERM_TOO_LOW(uint256 term, uint256 minTerm);\\n    error RISK_CATEGORY_MISMATCH(bytes4 currency, bytes32 name, uint64 term, bytes32 riskCategory);\\n    error MATURITY_LESS_THAN_ISSUANCE(uint64 maturity, uint64 issuance);\\n    error INVALID_RISK_CATEGORY();\\n    error EMPTY_CUSIP_AND_ISIN();\\n    error INVALID_MAX_COUPON();\\n    error INVALID_COUPON(uint256 coupon, uint256 minCoupon, uint256 maxCoupon);\\n    error ANSWER_VARIATION_TOO_HIGH();\\n    error CANNOT_SET_NEGATIVE_MAX_ANSWER();\\n    error MAX_ANSWER_TOO_LOW(int256 maxAnswer, int256 minAnswer);\\n}\\n\"\r\n    },\r\n    \"contracts-verify/libraries/Roles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary Roles {\\n    bytes32 public constant MCAG_MINT_ROLE = keccak256(\\\"MCAG_MINT_ROLE\\\");\\n    bytes32 public constant MCAG_BURN_ROLE = keccak256(\\\"MCAG_BURN_ROLE\\\");\\n    bytes32 public constant MCAG_BLACKLIST_ROLE = keccak256(\\\"MCAG_BLACKLIST_ROLE\\\");\\n    bytes32 public constant MCAG_PAUSE_ROLE = keccak256(\\\"MCAG_PAUSE_ROLE\\\");\\n    bytes32 public constant MCAG_UNPAUSE_ROLE = keccak256(\\\"MCAG_UNPAUSE_ROLE\\\");\\n    bytes32 public constant MCAG_TRANSMITTER_ROLE = keccak256(\\\"MCAG_TRANSMITTER_ROLE\\\");\\n    bytes32 public constant MCAG_MANAGER_ROLE = keccak256(\\\"MCAG_MANAGER_ROLE\\\");\\n    bytes32 public constant MCAG_SET_URI_ROLE = keccak256(\\\"MCAG_SET_URI_ROLE\\\");\\n    bytes32 public constant MCAG_SET_TNC_ROLE = keccak256(\\\"MCAG_SET_TNC_ROLE\\\");\\n    bytes32 public constant MCAG_SET_MAX_COUPON_ROLE = keccak256(\\\"MCAG_SET_MAX_COUPON_ROLE\\\");\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IAccessControl\",\"name\":\"_accessController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BLACKLIST_ACCOUNT_IS_BLACKLISTED\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"BLACKLIST_ACCOUNT_IS_NOT_BLACKLISTED\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"BLACKLIST_CALLER_IS_NOT_BLACKLISTER\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CANNOT_SET_TO_ADDRESS_ZERO\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"accesController\",\"type\":\"address\"}],\"name\":\"AccessControllerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Blacklisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"UnBlacklisted\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"accessController\",\"outputs\":[{\"internalType\":\"contract IAccessControl\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"blacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"unBlacklist\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Blacklist", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c7b973a97f171e964eb3a0949caafbfd1ed77c0d", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}