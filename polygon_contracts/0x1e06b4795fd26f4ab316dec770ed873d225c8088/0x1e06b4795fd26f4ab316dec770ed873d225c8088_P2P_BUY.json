{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/P2P/core/P2P-Buy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\ninterface IP2PManagement {\\n    function isAdmin(address) external view returns (bool);\\n\\n    function isBlacklisted(address) external view returns (bool);\\n\\n    function isOfficialDealer(address) external view returns (bool);\\n}\\n\\ninterface ICommissionsAddressRouter {\\n    function getAddress() external view returns (address);\\n}\\n\\ninterface ICommissionsRouter {\\n    function receiveFees(uint256, bytes32) external;\\n}\\n\\ninterface IP2PTokenList {\\n    function getTokenAddressById(uint id) external view returns (address);\\n\\n    function validateTokenById(uint id) external view;\\n}\\n\\ncontract P2P_BUY {\\n    struct Ad {\\n        address exchangerAddress;\\n        bool isActive;\\n        uint id;\\n        uint balance;\\n        string price;\\n        string description;\\n        string currency;\\n        uint initialBalance;\\n        uint min;\\n        uint max;\\n        uint frozenTokens;\\n        uint createDate;\\n        uint32 tokenType;\\n        string[] paymentMethods;\\n    }\\n\\n    struct ExchangerData {\\n        address exchangerAddress;\\n        bool exists;\\n        bool isSelling;\\n        uint activeAdCount;\\n        Ad[] ads;\\n    }\\n\\n    struct Order {\\n        address client;\\n        uint freezeAmount;\\n        uint createdAt;\\n        bool completed;\\n    }\\n    using Counters for Counters.Counter;\\n    uint public BRINGOLD_FEE = 4 ether;\\n    address[] exchangers;\\n    Counters.Counter private adsCount;\\n    mapping(address => ExchangerData) exchangerInfo;\\n    mapping(address => mapping(bytes => Order)) orders;\\n    ICommissionsAddressRouter commissionsAddressRouter;\\n    address public subscriptionContract;\\n    IP2PManagement p2pManagement;\\n    IERC20 BRIN;\\n    ICommissionsRouter commissionsRouter;\\n    IP2PTokenList p2pTokenList;\\n\\n    uint public UNFREEZE_LOCK_DURATION = 86400;\\n    uint public MAX_AD_COUNT = 5;\\n    address public owner;\\n\\n    constructor(\\n        address _subscriptionContract,\\n        address managementAddress,\\n        address p2pTokenListContract,\\n        address _brin,\\n        address _commissionsAddressRouter\\n    ) {\\n        subscriptionContract = _subscriptionContract;\\n        p2pManagement = IP2PManagement(managementAddress);\\n        p2pTokenList = IP2PTokenList(p2pTokenListContract);\\n        commissionsAddressRouter = ICommissionsAddressRouter(\\n            _commissionsAddressRouter\\n        );\\n        owner = msg.sender;\\n        BRIN = IERC20(_brin);\\n    }\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner);\\n        _;\\n    }\\n\\n    function setFee(uint fee) external onlyOwner {\\n        require(fee > 0, \\\"zero\\\");\\n        BRINGOLD_FEE = fee;\\n    }\\n\\n    function setUnfreezeLockDuration(\\n        uint durationInSeconds\\n    ) external ownerOrAdmin {\\n        UNFREEZE_LOCK_DURATION = durationInSeconds;\\n    }\\n\\n    function setMaxAdCount(uint count) external ownerOrAdmin {\\n        MAX_AD_COUNT = count;\\n    }\\n\\n    function _exchangerOrAdmin() private view {\\n        require(\\n            exchangerInfo[msg.sender].exchangerAddress == msg.sender ||\\n                p2pManagement.isAdmin(msg.sender),\\n            \\\"notexchangerOrAdmin\\\"\\n        );\\n    }\\n\\n    function _ownerOrAdmin() private view {\\n        require(msg.sender == owner || p2pManagement.isAdmin(msg.sender));\\n    }\\n\\n    function _notBlacklisted() private view {\\n        require(!p2pManagement.isBlacklisted(msg.sender), \\\"bListed\\\");\\n    }\\n\\n    function _validateAd(address exchanger, uint adId) private view {\\n        require(\\n            exchangerInfo[exchanger].ads[adId].isActive == true,\\n            \\\"notExist\\\"\\n        );\\n    }\\n\\n    function _isExistAd(address exchanger, uint adId) private view {\\n        require(\\n            exchangerInfo[exchanger].ads[adId].exchangerAddress != address(0),\\n            \\\"notExist\\\"\\n        );\\n    }\\n\\n    function _validateNativeAmount(uint amount) private view {\\n        require(msg.value == amount);\\n    }\\n\\n    function _clientOrAdmin(\\n        address exchanger,\\n        bytes memory orderId\\n    ) internal view {\\n        require(\\n            p2pManagement.isAdmin(msg.sender) ||\\n                orders[exchanger][orderId].client == msg.sender,\\n            \\\"Unauthorized\\\"\\n        );\\n    }\\n\\n    modifier exchangerOrAdmin() {\\n        _exchangerOrAdmin();\\n        _;\\n    }\\n    modifier notBlacklisted() {\\n        _notBlacklisted();\\n        _;\\n    }\\n    modifier ownerOrAdmin() {\\n        _ownerOrAdmin();\\n        _;\\n    }\\n\\n    function isCrystalMember(address account) internal view returns (bool) {\\n        (bool success, bytes memory returnBytes) = subscriptionContract\\n            .staticcall(\\n                abi.encodeWithSignature(\\n                    \\\"getSubscriptionNameOfAccount(address)\\\",\\n                    account\\n                )\\n            );\\n        if (success) {\\n            bytes32 subscriptionType = abi.decode(returnBytes, (bytes32));\\n            if (bytes32(\\\"CRYSTAL\\\") == subscriptionType) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function _validateAccount() internal view {\\n        require(\\n            p2pManagement.isOfficialDealer(msg.sender) ||\\n                isCrystalMember(msg.sender),\\n            \\\"unauthothorized\\\"\\n        );\\n    }\\n\\n    function _transfer(address receiver, uint amount, uint tokenType) internal {\\n        if (tokenType == 1) {\\n            (bool sent, bytes memory data) = payable(receiver).call{\\n                value: amount\\n            }(\\\"\\\");\\n            require(sent, \\\"Failed to send Ether\\\");\\n        } else {\\n            address token = p2pTokenList.getTokenAddressById(tokenType);\\n            IERC20(token).transfer(receiver, amount);\\n        }\\n    }\\n\\n    /**\\n    @dev Creates and ad with given parameters\\n    @param amount Amount of tokens to be funded to Ad(in wei)\\n    @param price Price of one token in given currency\\n    @param description Description of ad\\n    @param currency Accepted currency for payments for ad\\n    @param tokenType Must be 0 or 1, 0=Brin, 1=MATIC\\n    @param min minimum limit to buy tokens in given currency\\n    @param max maximum limit to buy tokens in given currency\\n    */\\n    function createAd(\\n        uint amount,\\n        string memory price,\\n        string memory description,\\n        string memory currency,\\n        uint min,\\n        uint max,\\n        uint32 tokenType,\\n        string[] memory paymentMethods\\n    ) public notBlacklisted {\\n        _validateAccount();\\n        if (tokenType != 1) {\\n            p2pTokenList.validateTokenById(tokenType);\\n        }\\n        if (!exchangerInfo[msg.sender].exists) {\\n            exchangers.push(msg.sender);\\n        }\\n\\n        require(exchangerInfo[msg.sender].activeAdCount < MAX_AD_COUNT, \\\"max\\\");\\n\\n        exchangerInfo[msg.sender].isSelling = true;\\n        exchangerInfo[msg.sender].exchangerAddress = msg.sender;\\n        exchangerInfo[msg.sender].exists = true;\\n        exchangerInfo[msg.sender].activeAdCount++;\\n        exchangerInfo[msg.sender].ads.push(\\n            Ad(\\n                msg.sender,\\n                true,\\n                exchangerInfo[msg.sender].ads.length,\\n                amount,\\n                price,\\n                description,\\n                currency,\\n                amount,\\n                min,\\n                max,\\n                0,\\n                block.timestamp,\\n                tokenType,\\n                paymentMethods\\n            )\\n        );\\n        adsCount.increment();\\n        BRIN.transferFrom(msg.sender, address(this), BRINGOLD_FEE);\\n        transferFees();\\n    }\\n\\n    function transferFees() internal {\\n        address commissionsAddress = commissionsAddressRouter.getAddress();\\n        BRIN.approve(commissionsAddress, BRINGOLD_FEE);\\n        ICommissionsRouter(commissionsAddress).receiveFees(\\n            BRINGOLD_FEE,\\n            bytes32(\\\"TX\\\")\\n        );\\n    }\\n\\n    /**\\n    @dev Returns ads of caller of this function\\n    */\\n    function getMyAds() public view returns (Ad[] memory) {\\n        return exchangerInfo[msg.sender].ads;\\n    }\\n\\n    /**\\n    @dev Returns order of given exchanger with given orderId\\n    @param exchanger Wallet address of exchanger\\n    @param orderId Id of order\\n    */\\n    function getOrder(\\n        address exchanger,\\n        bytes memory orderId\\n    ) external view returns (Order memory) {\\n        //add require to get error\\n        return orders[exchanger][orderId];\\n    }\\n\\n    /**\\n    @dev Returns ads of given exchanger\\n    @param exchanger Wallet address of exchanger\\n    */\\n    function getAdsByAddress(\\n        address exchanger\\n    ) public view returns (Ad[] memory) {\\n        return exchangerInfo[exchanger].ads;\\n    }\\n\\n    /**\\n    @dev Returns an ad with given exchanger and adId\\n    @param exchanger Wallet address of exchanger\\n    @param id Id of ad\\n    */\\n    function getAd(address exchanger, uint id) public view returns (Ad memory) {\\n        return exchangerInfo[exchanger].ads[id];\\n    }\\n\\n    /**\\n    @dev Freezes tokens from ad's balance upon order\\n    @param exchanger Wallet address of exchanger\\n    @param adId Id of ad\\n    @param orderId Id of order\\n    @param freezeAmount Amount of tokens to be frozen\\n    */\\n    function freezeTokens(\\n        address exchanger,\\n        uint adId,\\n        bytes memory orderId,\\n        uint freezeAmount\\n    ) external payable notBlacklisted {\\n        _validateAd(exchanger, adId);\\n        require(\\n            orders[exchanger][orderId].client == address(0),\\n            \\\"duplicatedOrders\\\"\\n        );\\n        require(exchanger != msg.sender, \\\"cannot be exchanger\\\");\\n        uint32 tokenType = exchangerInfo[exchanger].ads[adId].tokenType;\\n        exchangerInfo[exchanger].ads[adId].frozenTokens += freezeAmount;\\n        exchangerInfo[exchanger].ads[adId].balance -= freezeAmount;\\n\\n        if (tokenType == 1) {\\n            _validateNativeAmount(freezeAmount);\\n        } else {\\n            IERC20 token = IERC20(p2pTokenList.getTokenAddressById(tokenType));\\n            token.transferFrom(msg.sender, address(this), freezeAmount);\\n        }\\n        if (!isCrystalMember(msg.sender)) {\\n            BRIN.transferFrom(msg.sender, address(this), BRINGOLD_FEE);\\n            transferFees();\\n        }\\n\\n        orders[exchanger][orderId] = Order(\\n            msg.sender,\\n            freezeAmount,\\n            block.timestamp,\\n            false\\n        );\\n    }\\n\\n    /**\\n    @dev Unfreezes tokens that were frozen upon order\\n    @param exchanger Wallet address of exchanger\\n    @param adId Id of ad\\n    @param orderId Id of order\\n    */\\n    function unFreezeTokens(\\n        address exchanger,\\n        bytes memory orderId,\\n        uint adId\\n    ) external {\\n        _isExistAd(exchanger, adId);\\n        _clientOrAdmin(exchanger, orderId);\\n        Order storage order = orders[exchanger][orderId];\\n        if (!p2pManagement.isAdmin(msg.sender)) {\\n            require(\\n                order.createdAt + UNFREEZE_LOCK_DURATION <= block.timestamp,\\n                \\\"cannot unfreeze now\\\"\\n            );\\n        }\\n        require(!order.completed, \\\"No frozen tokens\\\");\\n        exchangerInfo[exchanger].ads[adId].frozenTokens -= order.freezeAmount;\\n        exchangerInfo[exchanger].ads[adId].balance += order.freezeAmount;\\n        _transfer(\\n            order.client,\\n            order.freezeAmount,\\n            exchangerInfo[exchanger].ads[adId].tokenType\\n        );\\n        order.freezeAmount = 0;\\n        order.completed = true;\\n    }\\n\\n    /**\\n    @dev Removes an ad and returns tokens in ad to exchanger\\n    @param exchanger Wallet address of exchanger\\n    @param adId Id of ad\\n    */\\n    function endAd(address exchanger, uint adId) public exchangerOrAdmin {\\n        _validateAd(exchanger, adId);\\n        if (!p2pManagement.isAdmin(msg.sender)) {\\n            require(\\n                exchangerInfo[exchanger].ads[adId].frozenTokens == 0,\\n                \\\"orderActive\\\"\\n            );\\n        }\\n        exchangerInfo[exchanger].ads[adId].isActive = false;\\n        exchangerInfo[exchanger].ads[adId].balance = 0;\\n        exchangerInfo[exchanger].activeAdCount--;\\n        adsCount.decrement();\\n    }\\n\\n    /**\\n    @dev Pays the order amount to buyer using already frozen tokens\\n    @param exchanger Wallet address of exchanger\\n    @param adId Id of ad\\n    @param orderId Id of order\\n    */\\n    function ReturnPayment(\\n        address exchanger,\\n        uint adId,\\n        bytes memory orderId\\n    ) public {\\n        _validateAd(exchanger, adId);\\n        _clientOrAdmin(exchanger, orderId);\\n        Order storage order = orders[exchanger][orderId];\\n        require(order.freezeAmount > 0 && !order.completed, \\\"completed\\\");\\n\\n        uint freezeAmount = order.freezeAmount;\\n        exchangerInfo[exchanger].ads[adId].frozenTokens -= freezeAmount;\\n        order.freezeAmount = 0;\\n        order.completed = true;\\n        _transfer(\\n            exchanger,\\n            freezeAmount,\\n            exchangerInfo[exchanger].ads[adId].tokenType\\n        );\\n        if (\\n            exchangerInfo[exchanger].ads[adId].balance == 0 &&\\n            exchangerInfo[exchanger].ads[adId].frozenTokens == 0\\n        ) {\\n            exchangerInfo[exchanger].ads[adId].isActive = false;\\n            exchangerInfo[exchanger].activeAdCount--;\\n            adsCount.decrement();\\n        }\\n    }\\n\\n    /**\\n    @dev Returns all active ads in market\\n    */\\n    function getAllActiveAds() public view returns (Ad[] memory) {\\n        uint count = adsCount.current();\\n        Ad[] memory ads = new Ad[](count);\\n        uint currentIndex = 0;\\n        for (uint i = 0; i < exchangers.length; i++) {\\n            if (exchangerInfo[exchangers[i]].ads.length > 0) {\\n                for (\\n                    uint k = 0;\\n                    k < exchangerInfo[exchangers[i]].ads.length;\\n                    k++\\n                ) {\\n                    if (exchangerInfo[exchangers[i]].ads[k].isActive) {\\n                        ads[currentIndex] = exchangerInfo[exchangers[i]].ads[k];\\n                        currentIndex++;\\n                    }\\n                }\\n            }\\n        }\\n        return ads;\\n    }\\n\\n    /**\\n    @dev Returns If account is eligible to create ads or not.\\n    */\\n    function canCreateAds() external view returns (bool) {\\n        if (\\n            p2pManagement.isOfficialDealer(msg.sender) ||\\n            isCrystalMember(msg.sender)\\n        ) {\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_subscriptionContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"managementAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"p2pTokenListContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_brin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_commissionsAddressRouter\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BRINGOLD_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_AD_COUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchanger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"adId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"orderId\",\"type\":\"bytes\"}],\"name\":\"ReturnPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNFREEZE_LOCK_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"canCreateAds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"price\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenType\",\"type\":\"uint32\"},{\"internalType\":\"string[]\",\"name\":\"paymentMethods\",\"type\":\"string[]\"}],\"name\":\"createAd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchanger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"adId\",\"type\":\"uint256\"}],\"name\":\"endAd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchanger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"adId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"orderId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"freezeAmount\",\"type\":\"uint256\"}],\"name\":\"freezeTokens\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchanger\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAd\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"exchangerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"price\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frozenTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createDate\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenType\",\"type\":\"uint32\"},{\"internalType\":\"string[]\",\"name\":\"paymentMethods\",\"type\":\"string[]\"}],\"internalType\":\"struct P2P_BUY.Ad\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchanger\",\"type\":\"address\"}],\"name\":\"getAdsByAddress\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"exchangerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"price\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frozenTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createDate\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenType\",\"type\":\"uint32\"},{\"internalType\":\"string[]\",\"name\":\"paymentMethods\",\"type\":\"string[]\"}],\"internalType\":\"struct P2P_BUY.Ad[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllActiveAds\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"exchangerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"price\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frozenTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createDate\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenType\",\"type\":\"uint32\"},{\"internalType\":\"string[]\",\"name\":\"paymentMethods\",\"type\":\"string[]\"}],\"internalType\":\"struct P2P_BUY.Ad[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMyAds\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"exchangerAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isActive\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"price\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"currency\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"initialBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"max\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"frozenTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createDate\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"tokenType\",\"type\":\"uint32\"},{\"internalType\":\"string[]\",\"name\":\"paymentMethods\",\"type\":\"string[]\"}],\"internalType\":\"struct P2P_BUY.Ad[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchanger\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"orderId\",\"type\":\"bytes\"}],\"name\":\"getOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"client\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"freezeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"createdAt\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"}],\"internalType\":\"struct P2P_BUY.Order\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"setMaxAdCount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"durationInSeconds\",\"type\":\"uint256\"}],\"name\":\"setUnfreezeLockDuration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionContract\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"exchanger\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"orderId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"adId\",\"type\":\"uint256\"}],\"name\":\"unFreezeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "P2P_BUY", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000001924e39142f48525dd0d269002d0474cc41205d00000000000000000000000060ae54a6d4bb890a875ee163fa27a8c57693df4100000000000000000000000013d8fddec3a698699b6cbce4c3f30511540684c9000000000000000000000000bc0b7de316f4e57c677370ccd3a36697d6fc5de200000000000000000000000083e92ce0965ab1b6e4c02fb2746c13daaa1fe69e", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}