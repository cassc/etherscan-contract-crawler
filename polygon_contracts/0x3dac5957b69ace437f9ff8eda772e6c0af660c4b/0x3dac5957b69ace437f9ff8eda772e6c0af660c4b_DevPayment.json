{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/DevPayment.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\nimport \\\"./IDao.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport \\\"./KATBEP20.sol\\\";\\r\\n\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ncontract DevPayment {\\r\\n    address public admin;\\r\\n    address public projectManager;\\r\\n    address public contractor;\\r\\n    IDao public daoAddress;\\r\\n    BEP20Token public usdtAddress;\\r\\n    BEP20Token public katAddress;\\r\\n    uint256 public totalPayment;\\r\\n    uint256 public totalMilestones;\\r\\n    uint256 public completedMilestones;\\r\\n\\r\\n\\r\\n   \\r\\n\\r\\n    struct Milestone {\\r\\n        uint256 amount;\\r\\n        bool completed;\\r\\n    }\\r\\n\\r\\n    //uint256 _payableAmount = 0;\\r\\n    mapping(uint256 => Milestone) public milestones;\\r\\n\\r\\n    event MilestoneSet(uint256 indexed milestoneIndex, uint256 amount);\\r\\n    event MilestoneCompleted(uint256 indexed milestoneIndex);\\r\\n    event PaymentReleased(uint256 indexed milestoneIndex, uint256 amount);\\r\\n    event ContractorWithdrawal(address indexed contractor, uint256 amount);\\r\\n\\r\\n    constructor(\\r\\n        address _admin,\\r\\n        address _projectManager,\\r\\n        address _contractor,\\r\\n        IDao _daoAddress,\\r\\n        BEP20Token _usdtAddress,\\r\\n        BEP20Token _katAddress\\r\\n    ) {\\r\\n        // Check that none of the provided addresses are zero addresses.\\r\\n        require(_admin != address(0x00), \\\"Admin address cannot be zero\\\");\\r\\n        require(\\r\\n            _projectManager != address(0x00),\\r\\n            \\\"Project Manager address cannot be zero\\\"\\r\\n        );\\r\\n        require(\\r\\n            _contractor != address(0x00),\\r\\n            \\\"Contractor address cannot be zero\\\"\\r\\n        );\\r\\n        require(\\r\\n            address(_daoAddress) != address(0x00),\\r\\n            \\\"DAO address cannot be zero\\\"\\r\\n        );\\r\\n        require(\\r\\n            address(_usdtAddress) != address(0x00),\\r\\n            \\\"USDT address cannot be zero\\\"\\r\\n        );\\r\\n        require(\\r\\n            address(_katAddress) != address(0x00),\\r\\n            \\\"KAT address cannot be zero\\\"\\r\\n        );\\r\\n\\r\\n        // Check that the provided addresses for DAO, USDT, and KAT are valid contract addresses.\\r\\n\\r\\n        require(\\r\\n            checkValidAddress(address(_daoAddress)),\\r\\n            \\\"DAO address is not a valid contract address\\\"\\r\\n        );\\r\\n        require(\\r\\n            checkValidAddress(address(_usdtAddress)),\\r\\n            \\\"USDT address is not a valid contract address\\\"\\r\\n        );\\r\\n        require(\\r\\n            checkValidAddress(address(_katAddress)),\\r\\n            \\\"KAT address is not a valid contract address\\\"\\r\\n        );\\r\\n\\r\\n        admin = _admin;\\r\\n        projectManager = _projectManager;\\r\\n        contractor = _contractor;\\r\\n        daoAddress = _daoAddress;\\r\\n        usdtAddress = _usdtAddress;\\r\\n        katAddress = _katAddress;\\r\\n    }\\r\\n\\r\\n    function checkValidAddress(\\r\\n        address checkedAddress\\r\\n    ) private view returns (bool) {\\r\\n        uint256 codeSize;\\r\\n        assembly {\\r\\n            codeSize := extcodesize(checkedAddress)\\r\\n        }\\r\\n        return codeSize > 0;\\r\\n    }\\r\\n\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, \\\"Only admin can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyProjectManager() {\\r\\n        require(\\r\\n            msg.sender == projectManager,\\r\\n            \\\"Only project manager can call this function\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier onlyContractor() {\\r\\n        require(\\r\\n            msg.sender == contractor,\\r\\n            \\\"Only contractor can call this function\\\"\\r\\n        );\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    function setMilestone(\\r\\n        uint256 _milestoneIndex,\\r\\n        uint256 _amount\\r\\n    ) public onlyProjectManager {\\r\\n        require(_milestoneIndex < totalMilestones, \\\"Invalid milestone index\\\");\\r\\n        require(\\r\\n            !milestones[_milestoneIndex].completed,\\r\\n            \\\"Milestone has already been completed\\\"\\r\\n        );\\r\\n\\r\\n        // T\u00ednh t\u1ed5ng amount c\u1ee7a c\u00e1c milestone hi\u1ec7n t\u1ea1i\\r\\n        uint256 totalMilestoneAmount;\\r\\n        uint256 totalMilestones_ = totalMilestones;\\r\\n        for (uint256 i; i < totalMilestones_; ) {\\r\\n            totalMilestoneAmount += milestones[i].amount;\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Ki\u1ec3m tra t\u1ed5ng milestone amount c\u00f3 v\u01b0\u1ee3t qu\u00e1 total amount kh\u00f4ng\\r\\n        if (_milestoneIndex < totalMilestones - 1) {\\r\\n            require(\\r\\n                totalMilestoneAmount + _amount <= totalPayment,\\r\\n                \\\"Total milestone amount exceeds total payment\\\"\\r\\n            );\\r\\n        } else {\\r\\n            require(\\r\\n                totalMilestoneAmount + _amount == totalPayment,\\r\\n                \\\"Total milestone amount should be equal to total payment\\\"\\r\\n            );\\r\\n        }\\r\\n\\r\\n        milestones[_milestoneIndex] = Milestone(_amount, false);\\r\\n        emit MilestoneSet(_milestoneIndex, _amount);\\r\\n    }\\r\\n\\r\\n    function completeMilestone(\\r\\n        uint256 _milestoneIndex,\\r\\n        uint256 _USDTAmount,\\r\\n        uint256 _EquivalentKATPerUSDT\\r\\n    ) public onlyAdmin() {\\r\\n        require(_milestoneIndex < totalMilestones, \\\"Invalid milestone index\\\");\\r\\n        require(\\r\\n            !milestones[_milestoneIndex].completed,\\r\\n            \\\"Milestone has already been completed\\\"\\r\\n        );\\r\\n\\r\\n        milestones[_milestoneIndex].completed = true;\\r\\n        completedMilestones++;\\r\\n        emit MilestoneCompleted(_milestoneIndex);\\r\\n\\r\\n        uint8 katDecimals = BEP20Token(katAddress).decimals();\\r\\n        uint8 usdtDecimals = BEP20Token(usdtAddress).decimals();\\r\\n\\r\\n        uint256 katBalanceOnUSDTWei =\\r\\n            ((BEP20Token(katAddress).balanceOf(address(daoAddress)) *\\r\\n                _USDTAmount) *(10**usdtDecimals)/\\r\\n            ((10**katDecimals)*_EquivalentKATPerUSDT));\\r\\n            \\r\\n        uint256 usdtWeiBalance = BEP20Token(usdtAddress).balanceOf(address(daoAddress));\\r\\n        uint256 totalBalanceOnUSDTWei = usdtWeiBalance + katBalanceOnUSDTWei;\\r\\n\\r\\n        uint256 milestoneAmount = milestones[_milestoneIndex].amount;\\r\\n\\r\\n        // Calculate Kat amount of the milestone based on DAO's KAT balance\\r\\n        uint256 katAmount = (milestoneAmount *\\r\\n            katBalanceOnUSDTWei *\\r\\n            _EquivalentKATPerUSDT * (10 ** katDecimals)) /\\r\\n            (_USDTAmount *totalBalanceOnUSDTWei* (10**usdtDecimals));\\r\\n\\r\\n        // Calculate USDT amount of the milestone based on DAO's USDT balance\\r\\n        uint256 usdtAmount = (milestoneAmount * usdtWeiBalance) /\\r\\n            totalBalanceOnUSDTWei;\\r\\n\\r\\n        require(\\r\\n            usdtAddress.balanceOf(address(daoAddress)) >= usdtAmount,\\r\\n            \\\"Not enough USDT Amount\\\"\\r\\n        );\\r\\n        require(\\r\\n            katAddress.balanceOf(address(daoAddress)) >= katAmount,\\r\\n            \\\"Not enough KAT Amount\\\"\\r\\n        );\\r\\n        // // Transfer the converted KAT amount to the contractor\\r\\n\\r\\n        IDao(daoAddress).executePermitted(\\r\\n            address(katAddress),\\r\\n            abi.encodeWithSignature(\\r\\n                \\\"transfer(address,uint256)\\\",\\r\\n                contractor,\\r\\n                katAmount\\r\\n            ),\\r\\n            0\\r\\n        );\\r\\n        // // Transfer the USDT amount to the contractor\\r\\n        IDao(daoAddress).executePermitted(\\r\\n            address(usdtAddress),\\r\\n            abi.encodeWithSignature(\\r\\n                \\\"transfer(address,uint256)\\\",\\r\\n                contractor,\\r\\n                usdtAmount\\r\\n            ),\\r\\n            0\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function setTotalPayment(uint256 _totalPayment) public onlyProjectManager {\\r\\n        require(_totalPayment > 0, \\\"Total payment must be greater than 0\\\");\\r\\n        require(totalPayment == 0, \\\"Total payment has already been set\\\");\\r\\n\\r\\n        totalPayment = _totalPayment;\\r\\n    }\\r\\n\\r\\n    function setTotalMilestones(\\r\\n        uint256 _totalMilestones\\r\\n    ) public onlyProjectManager {\\r\\n        require(\\r\\n            _totalMilestones > 0,\\r\\n            \\\"Total milestones must be greater than 0\\\"\\r\\n        );\\r\\n        require(totalMilestones == 0, \\\"Total milestones have already been set\\\");\\r\\n\\r\\n        totalMilestones = _totalMilestones;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/IDao.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ninterface IDao {\\r\\n    function name() external view returns (string memory);\\r\\n\\r\\n    function symbol() external view returns (string memory);\\r\\n\\r\\n    function lp() external view returns (address);\\r\\n\\r\\n    function burnLp(\\r\\n        address _recipient,\\r\\n        uint256 _share,\\r\\n        address[] memory _tokens,\\r\\n        address[] memory _adapters,\\r\\n        address[] memory _pools\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function setLp(address _lp) external returns (bool);\\r\\n\\r\\n    function quorum() external view returns (uint8);\\r\\n\\r\\n    function executedTx(bytes32 _txHash) external view returns (bool);\\r\\n\\r\\n    function mintable() external view returns (bool);\\r\\n\\r\\n    function burnable() external view returns (bool);\\r\\n\\r\\n    function numberOfPermitted() external view returns (uint256);\\r\\n\\r\\n    function numberOfAdapters() external view returns (uint256);\\r\\n\\r\\n    function executePermitted(address _target,  bytes calldata _data, uint256 _value ) external returns (bool) ;\\r\\n}\"\r\n    },\r\n    \"contracts/KATBEP20.sol\": {\r\n      \"content\": \"/**\\r\\n *Submitted for verification at BscScan.com on 2023-01-09\\r\\n*/\\r\\n\\r\\n// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ninterface IBEP20 {\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens in existence.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token decimals.\\r\\n   */\\r\\n  function decimals() external view returns (uint8);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token symbol.\\r\\n   */\\r\\n  function symbol() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n  * @dev Returns the token name.\\r\\n  */\\r\\n  function name() external view returns (string memory);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the bep token owner.\\r\\n   */\\r\\n  function getOwner() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the amount of tokens owned by `account`.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the remaining number of tokens that `spender` will be\\r\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n   * zero by default.\\r\\n   *\\r\\n   * This value changes when {approve} or {transferFrom} are called.\\r\\n   */\\r\\n  function allowance(address _owner, address spender) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n   * that someone may use both the old and the new allowance by unfortunate\\r\\n   * transaction ordering. One possible solution to mitigate this race\\r\\n   * condition is to first reduce the spender's allowance to 0 and set the\\r\\n   * desired value afterwards:\\r\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\r\\n   * allowance mechanism. `amount` is then deducted from the caller's\\r\\n   * allowance.\\r\\n   *\\r\\n   * Returns a boolean value indicating whether the operation succeeded.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   */\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n   * another (`to`).\\r\\n   *\\r\\n   * Note that `value` may be zero.\\r\\n   */\\r\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n  /**\\r\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n   * a call to {approve}. `value` is the new allowance.\\r\\n   */\\r\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n}\\r\\ninterface IERC165 {\\r\\n    /**\\r\\n     * @dev Returns true if this contract implements the interface defined by\\r\\n     * `interfaceId`. See the corresponding\\r\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n     * to learn more about how these ids are created.\\r\\n     *\\r\\n     * This function call must use less than 30 000 gas.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\nabstract contract ERC165 is IERC165 {\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IERC165).interfaceId;\\r\\n    }\\r\\n}\\r\\nlibrary Strings {\\r\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\r\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\r\\n     */\\r\\n    function toString(uint256 value) internal pure returns (string memory) {\\r\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\r\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\r\\n\\r\\n        if (value == 0) {\\r\\n            return \\\"0\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 digits;\\r\\n        while (temp != 0) {\\r\\n            digits++;\\r\\n            temp /= 10;\\r\\n        }\\r\\n        bytes memory buffer = new bytes(digits);\\r\\n        while (value != 0) {\\r\\n            digits -= 1;\\r\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\r\\n            value /= 10;\\r\\n        }\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\r\\n        if (value == 0) {\\r\\n            return \\\"0x00\\\";\\r\\n        }\\r\\n        uint256 temp = value;\\r\\n        uint256 length = 0;\\r\\n        while (temp != 0) {\\r\\n            length++;\\r\\n            temp >>= 8;\\r\\n        }\\r\\n        return toHexString(value, length);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\r\\n     */\\r\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\r\\n        bytes memory buffer = new bytes(2 * length + 2);\\r\\n        buffer[0] = \\\"0\\\";\\r\\n        buffer[1] = \\\"x\\\";\\r\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\r\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\r\\n            value >>= 4;\\r\\n        }\\r\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\r\\n        return string(buffer);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\r\\n     */\\r\\n    function toHexString(address addr) internal pure returns (string memory) {\\r\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IAccessControl {\\r\\n    /**\\r\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\r\\n     *\\r\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\r\\n     * {RoleAdminChanged} not being emitted signaling this.\\r\\n     *\\r\\n     * _Available since v3.1._\\r\\n     */\\r\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is granted `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call, an admin role\\r\\n     * bearer except when using {AccessControl-_setupRole}.\\r\\n     */\\r\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when `account` is revoked `role`.\\r\\n     *\\r\\n     * `sender` is the account that originated the contract call:\\r\\n     *   - if using `revokeRole`, it is the admin role bearer\\r\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\r\\n     */\\r\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) external;\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) external;\\r\\n}\\r\\n\\r\\nabstract contract Context {\\r\\n    function _msgSender() internal view virtual returns (address) {\\r\\n        return msg.sender;\\r\\n    }\\r\\n\\r\\n    function _msgData() internal view virtual returns (bytes calldata) {\\r\\n        return msg.data;\\r\\n    }\\r\\n}\\r\\n\\r\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\r\\n    struct RoleData {\\r\\n        mapping(address => bool) members;\\r\\n        bytes32 adminRole;\\r\\n    }\\r\\n\\r\\n    mapping(bytes32 => RoleData) private _roles;\\r\\n\\r\\n    //bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\r\\n\\r\\n    /**\\r\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\r\\n     * with a standardized message including the required role.\\r\\n     *\\r\\n     * The format of the revert reason is given by the following regular expression:\\r\\n     *\\r\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\r\\n     *\\r\\n     * _Available since v4.1._\\r\\n     */\\r\\n    modifier onlyRole(bytes32 role) {\\r\\n        _checkRole(role);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev See {IERC165-supportsInterface}.\\r\\n     */\\r\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\r\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns `true` if `account` has been granted `role`.\\r\\n     */\\r\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\r\\n        return _roles[role].members[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\r\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\r\\n     *\\r\\n     * Format of the revert message is described in {_checkRole}.\\r\\n     *\\r\\n     * _Available since v4.6._\\r\\n     */\\r\\n    function _checkRole(bytes32 role) internal view virtual {\\r\\n        _checkRole(role, _msgSender());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revert with a standard message if `account` is missing `role`.\\r\\n     *\\r\\n     * The format of the revert reason is given by the following regular expression:\\r\\n     *\\r\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\r\\n     */\\r\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\r\\n        if (!hasRole(role, account)) {\\r\\n            revert(\\r\\n                string(\\r\\n                    abi.encodePacked(\\r\\n                        \\\"AccessControl: account \\\",\\r\\n                        Strings.toHexString(uint160(account), 20),\\r\\n                        \\\" is missing role \\\",\\r\\n                        Strings.toHexString(uint256(role), 32)\\r\\n                    )\\r\\n                )\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\r\\n     * {revokeRole}.\\r\\n     *\\r\\n     * To change a role's admin, use {_setRoleAdmin}.\\r\\n     */\\r\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\r\\n        return _roles[role].adminRole;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     *\\r\\n     * May emit a {RoleGranted} event.\\r\\n     */\\r\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must have ``role``'s admin role.\\r\\n     *\\r\\n     * May emit a {RoleRevoked} event.\\r\\n     */\\r\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from the calling account.\\r\\n     *\\r\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\r\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\r\\n     * if they are compromised (such as when a trusted device is misplaced).\\r\\n     *\\r\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\r\\n     * event.\\r\\n     *\\r\\n     * Requirements:\\r\\n     *\\r\\n     * - the caller must be `account`.\\r\\n     *\\r\\n     * May emit a {RoleRevoked} event.\\r\\n     */\\r\\n    function renounceRole(bytes32 role, address account) public virtual override {\\r\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\r\\n\\r\\n        _revokeRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\r\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\r\\n     * checks on the calling account.\\r\\n     *\\r\\n     * May emit a {RoleGranted} event.\\r\\n     *\\r\\n     * [WARNING]\\r\\n     * ====\\r\\n     * This function should only be called from the constructor when setting\\r\\n     * up the initial roles for the system.\\r\\n     *\\r\\n     * Using this function in any other way is effectively circumventing the admin\\r\\n     * system imposed by {AccessControl}.\\r\\n     * ====\\r\\n     *\\r\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\r\\n     */\\r\\n    function _setupRole(bytes32 role, address account) internal virtual {\\r\\n        _grantRole(role, account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\r\\n     *\\r\\n     * Emits a {RoleAdminChanged} event.\\r\\n     */\\r\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\r\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\r\\n        _roles[role].adminRole = adminRole;\\r\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Grants `role` to `account`.\\r\\n     *\\r\\n     * Internal function without access restriction.\\r\\n     *\\r\\n     * May emit a {RoleGranted} event.\\r\\n     */\\r\\n    function _grantRole(bytes32 role, address account) internal virtual {\\r\\n        if (!hasRole(role, account)) {\\r\\n            _roles[role].members[account] = true;\\r\\n            emit RoleGranted(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Revokes `role` from `account`.\\r\\n     *\\r\\n     * Internal function without access restriction.\\r\\n     *\\r\\n     * May emit a {RoleRevoked} event.\\r\\n     */\\r\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\r\\n        if (hasRole(role, account)) {\\r\\n            _roles[role].members[account] = false;\\r\\n            emit RoleRevoked(role, account, _msgSender());\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n\\r\\n/**\\r\\n * @dev Contract module which provides a basic access control mechanism, where\\r\\n * there is an account (an owner) that can be granted exclusive access to\\r\\n * specific functions.\\r\\n *\\r\\n * By default, the owner account will be the one that deploys the contract. This\\r\\n * can later be changed with {transferOwnership}.\\r\\n *\\r\\n * This module is used through inheritance. It will make available the modifier\\r\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\r\\n * the owner.\\r\\n */\\r\\ncontract Ownable is Context {\\r\\n  address private _owner;\\r\\n\\r\\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n  /**\\r\\n   * @dev Initializes the contract setting the deployer as the initial owner.\\r\\n   */\\r\\n  constructor () {\\r\\n    address msgSender = _msgSender();\\r\\n    _owner = msgSender;\\r\\n    emit OwnershipTransferred(address(0), msgSender);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the address of the current owner.\\r\\n   */\\r\\n  function owner() public view returns (address) {\\r\\n    return _owner;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Throws if called by any account other than the owner.\\r\\n   */\\r\\n  modifier onlyOwner() {\\r\\n    require(_owner == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\r\\n    _;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n   * Can only be called by the current owner.\\r\\n   */\\r\\n  function transferOwnership(address newOwner) public onlyOwner {\\r\\n    _transferOwnership(newOwner);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Transfers ownership of the contract to a new account (`newOwner`).\\r\\n   */\\r\\n  function _transferOwnership(address newOwner) internal {\\r\\n    require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\r\\n    emit OwnershipTransferred(_owner, newOwner);\\r\\n    _owner = newOwner;\\r\\n  }\\r\\n}\\r\\n\\r\\n\\r\\ncontract BEP20Token is Context, IBEP20, Ownable, AccessControl {\\r\\n\\r\\n  mapping (address => uint256) private _balances;\\r\\n\\r\\n  mapping (address => mapping (address => uint256)) private _allowances;\\r\\n\\r\\n  uint256 private _totalSupply ;\\r\\n  uint8 private constant _decimals =18;\\r\\n  string private constant _symbol= 'KAT';\\r\\n  string private constant _name = 'Kambria Token';\\r\\n  bytes32 public constant ADMIN_ROLE = keccak256(\\\"ADMIN_ROLE\\\");\\r\\n  bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\r\\n\\r\\n  constructor() {\\r\\n  \\r\\n    _balances[msg.sender] = _totalSupply;\\r\\n\\r\\n    emit Transfer(address(0), msg.sender, _totalSupply);\\r\\n    _grantRole(MINTER_ROLE, msg.sender);\\r\\n    _grantRole(ADMIN_ROLE, msg.sender);\\r\\n    _setRoleAdmin(MINTER_ROLE,ADMIN_ROLE);\\r\\n  }\\r\\n\\r\\n  function grantRole(bytes32 role, address account) public virtual override onlyOwner {\\r\\n       _grantRole(role, account);\\r\\n  }\\r\\n\\r\\n  function revokeRole(bytes32 role, address account) public virtual override onlyOwner{\\r\\n    _revokeRole(role, account);\\r\\n  }\\r\\n\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the bep token owner.\\r\\n   */\\r\\n  function getOwner() external view returns (address) {\\r\\n    return owner();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token decimals.\\r\\n   */\\r\\n  function decimals() external view returns (uint8) {\\r\\n    return _decimals;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Returns the token symbol.\\r\\n   */\\r\\n  function symbol() external view returns (string memory) {\\r\\n    return _symbol;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n  * @dev Returns the token name.\\r\\n  */\\r\\n  function name() external view returns (string memory) {\\r\\n    return _name;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-totalSupply}.\\r\\n   */\\r\\n  function totalSupply() external view returns (uint256) {\\r\\n    return _totalSupply;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-balanceOf}.\\r\\n   */\\r\\n  function balanceOf(address account) external view returns (uint256) {\\r\\n    return _balances[account];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-transfer}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `recipient` cannot be the zero address.\\r\\n   * - the caller must have a balance of at least `amount`.\\r\\n   */\\r\\n  function transfer(address recipient, uint256 amount) external returns (bool) {\\r\\n    _transfer(_msgSender(), recipient, amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-allowance}.\\r\\n   */\\r\\n  function allowance(address owner, address spender) external view returns (uint256) {\\r\\n    return _allowances[owner][spender];\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-approve}.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function approve(address spender, uint256 amount) external {\\r\\n   revert(\\\"The approve function is disabled, use the increaseAllowance and decreaseAllowance\\\");\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev See {BEP20-transferFrom}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance. This is not\\r\\n   * required by the EIP. See the note at the beginning of {BEP20};\\r\\n   *\\r\\n   * Requirements:\\r\\n   * - `sender` and `recipient` cannot be the zero address.\\r\\n   * - `sender` must have a balance of at least `amount`.\\r\\n   * - the caller must have allowance for `sender`'s tokens of at least\\r\\n   * `amount`.\\r\\n   */\\r\\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool) {\\r\\n    _transfer(sender, recipient, amount);\\r\\n    _approve(sender, _msgSender(), _allowances[sender][_msgSender()]- amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\\r\\n   *\\r\\n   * This is an alternative to {approve} that can be used as a mitigation for\\r\\n   * problems described in {BEP20-approve}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\r\\n   \\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender]+addedValue);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\\r\\n   *\\r\\n   * This is an alternative to {approve} that can be used as a mitigation for\\r\\n   * problems described in {BEP20-approve}.\\r\\n   *\\r\\n   * Emits an {Approval} event indicating the updated allowance.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `spender` cannot be the zero address.\\r\\n   * - `spender` must have allowance for the caller of at least\\r\\n   * `subtractedValue`.\\r\\n   */\\r\\n  function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\r\\n    _approve(_msgSender(), spender, _allowances[_msgSender()][spender]-subtractedValue);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Creates `amount` tokens and assigns them to `msg.sender`, increasing\\r\\n   * the total supply.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `msg.sender` must be the token owner\\r\\n   */\\r\\n  function mint(uint256 amount) public onlyRole(MINTER_ROLE) returns (bool) {\\r\\n    require(_totalSupply+amount<=5*1e27, \\\"Max total supply is 5 bilion\\\");\\r\\n    _mint(_msgSender(), amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  function mintTo(address receiver,uint256 amount) public onlyRole(MINTER_ROLE) returns (bool) {\\r\\n    require(_totalSupply+amount<=5*1e27, \\\"Max total supply is 5 bilion\\\");\\r\\n    _mint(receiver, amount);\\r\\n    return true;\\r\\n  }\\r\\n  /**\\r\\n   * @dev Removes `amount` tokens and assigns them to `msg.sender`, decreasing\\r\\n   * the total supply.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `msg.sender` must be the token owner\\r\\n   */\\r\\n  function burn(uint256 amount) public returns (bool) {\\r\\n    _burn(_msgSender(), amount);\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Moves tokens `amount` from `sender` to `recipient`.\\r\\n   *\\r\\n   * This is internal function is equivalent to {transfer}, and can be used to\\r\\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\\r\\n   *\\r\\n   * Emits a {Transfer} event.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `sender` cannot be the zero address.\\r\\n   * - `recipient` cannot be the zero address.\\r\\n   * - `sender` must have a balance of at least `amount`.\\r\\n   */\\r\\n  function _transfer(address sender, address recipient, uint256 amount) internal {\\r\\n    require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\r\\n    require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\r\\n\\r\\n    _balances[sender] = _balances[sender]-amount;\\r\\n    _balances[recipient] = _balances[recipient]+amount;\\r\\n    emit Transfer(sender, recipient, amount);\\r\\n  }\\r\\n\\r\\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\r\\n   * the total supply.\\r\\n   *\\r\\n   * Emits a {Transfer} event with `from` set to the zero address.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `to` cannot be the zero address.\\r\\n   */\\r\\n  function _mint(address account, uint256 amount) internal {\\r\\n    require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\r\\n\\r\\n    _totalSupply = _totalSupply+amount;\\r\\n    _balances[account] = _balances[account]+amount;\\r\\n    emit Transfer(address(0), account, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Destroys `amount` tokens from `account`, reducing the\\r\\n   * total supply.\\r\\n   *\\r\\n   * Emits a {Transfer} event with `to` set to the zero address.\\r\\n   *\\r\\n   * Requirements\\r\\n   *\\r\\n   * - `account` cannot be the zero address.\\r\\n   * - `account` must have at least `amount` tokens.\\r\\n   */\\r\\n  function _burn(address account, uint256 amount) internal {\\r\\n    require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\r\\n\\r\\n    _balances[account] = _balances[account] - amount;\\r\\n    _totalSupply = _totalSupply-amount;\\r\\n    emit Transfer(account, address(0), amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\r\\n   *\\r\\n   * This is internal function is equivalent to `approve`, and can be used to\\r\\n   * e.g. set automatic allowances for certain subsystems, etc.\\r\\n   *\\r\\n   * Emits an {Approval} event.\\r\\n   *\\r\\n   * Requirements:\\r\\n   *\\r\\n   * - `owner` cannot be the zero address.\\r\\n   * - `spender` cannot be the zero address.\\r\\n   */\\r\\n  function _approve(address owner, address spender, uint256 amount) internal {\\r\\n    require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\r\\n    require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\r\\n\\r\\n    _allowances[owner][spender] = amount;\\r\\n    emit Approval(owner, spender, amount);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\r\\n   * from the caller's allowance.\\r\\n   *\\r\\n   * See {_burn} and {_approve}.\\r\\n   */\\r\\n  function _burnFrom(address account, uint256 amount) internal {\\r\\n    _burn(account, amount);\\r\\n    _approve(account, _msgSender(), _allowances[account][_msgSender()]-amount);\\r\\n  }\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_projectManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_contractor\",\"type\":\"address\"},{\"internalType\":\"contract IDao\",\"name\":\"_daoAddress\",\"type\":\"address\"},{\"internalType\":\"contract BEP20Token\",\"name\":\"_usdtAddress\",\"type\":\"address\"},{\"internalType\":\"contract BEP20Token\",\"name\":\"_katAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"contractor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ContractorWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"milestoneIndex\",\"type\":\"uint256\"}],\"name\":\"MilestoneCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"milestoneIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MilestoneSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"milestoneIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_milestoneIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_USDTAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_EquivalentKATPerUSDT\",\"type\":\"uint256\"}],\"name\":\"completeMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"completedMilestones\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daoAddress\",\"outputs\":[{\"internalType\":\"contract IDao\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"katAddress\",\"outputs\":[{\"internalType\":\"contract BEP20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"milestones\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"projectManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_milestoneIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setMilestone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalMilestones\",\"type\":\"uint256\"}],\"name\":\"setTotalMilestones\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalPayment\",\"type\":\"uint256\"}],\"name\":\"setTotalPayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalMilestones\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalPayment\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdtAddress\",\"outputs\":[{\"internalType\":\"contract BEP20Token\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DevPayment", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000009159b7487d15ef71a7c592121dd7d7332aa931a80000000000000000000000009159b7487d15ef71a7c592121dd7d7332aa931a80000000000000000000000009159b7487d15ef71a7c592121dd7d7332aa931a800000000000000000000000036f780d2e7ea51f05f26bc107d9838c484418100000000000000000000000000982305b4ff805df00633f355981fa06bc8d50283000000000000000000000000c4cbed4773661f848d0efbc12198d5550a6a1079", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}