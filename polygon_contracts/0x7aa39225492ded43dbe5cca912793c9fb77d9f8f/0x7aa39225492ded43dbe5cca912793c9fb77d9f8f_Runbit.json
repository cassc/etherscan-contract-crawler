{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/Runbit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/access/AccessControl.sol\\\";\\nimport \\\"./IRunbit.sol\\\";\\n\\ncontract Runbit is AccessControl {\\n    bytes32 public constant MANAGE_ROLE = keccak256(\\\"MANAGE_ROLE\\\");\\n\\n    constructor(address admin) {\\n        _grantRole(DEFAULT_ADMIN_ROLE, admin);\\n        _grantRole(MANAGE_ROLE, admin);\\n    }\\n    // \u7cbe\u5ea6\u4e3a1e18\\n    struct RewardRate {\\n        uint64 trackDecay;\\n        uint64 stepDecay;\\n        uint64 jamDecay;\\n        uint64 comfortBuff;\\n        uint64 trackCapacity;\\n        uint64 trackLimit;\\n        uint128 specialty;\\n        uint112 aesthetic;\\n        uint112 comfort;\\n        uint32 minSteps;\\n    }\\n\\n    struct StepCount {\\n        uint64 count; \\n        uint64 equipType; \\n        uint64 trackId; \\n    }\\n\\n    struct EquipInfo {\\n        address owner; \\n        uint64 emptyId; \\n        uint32 latestDay; \\n    }\\n\\n    struct CardInfo {\\n        uint192 equipId; \\n        uint64 idx; \\n    }\\n\\n    struct UserState {\\n        uint8 status; \\n        uint8 lottery; \\n        uint16 trackId; \\n        uint32 cardCount; \\n        uint64 lastSteps; \\n        uint128 RBReward; \\n    }\\n\\n    struct DailyInfo {\\n        uint64 track0; \\n        uint64 track1;\\n        uint64 track2;\\n        uint64 userCount;\\n        uint64 totalSpecialty;\\n        uint64 totalComfort;\\n        uint64 totalAesthetic;\\n    }\\n    \\n    struct TrackInfo {\\n        uint64 latest;\\n        uint64 prev;\\n        uint64 updateDay;\\n    }\\n\\n    struct LotteryInfo {\\n        uint128 RBRate;\\n        uint64 ETRate;\\n        uint64 CTRate;\\n        uint64 RBNum;\\n        uint64 ETNum;\\n        uint64 CTNum;\\n    }\\n\\n    uint256 paused = 1;\\n\\n    uint256 epoch = 86400;\\n\\n    address committee;\\n\\n    address techFound;\\n\\n    address bonusFound;\\n    // 1e8\\n    uint256 commitRate;\\n    // 1e8\\n    uint256 techRate;\\n    // 1e8\\n    uint256 bonusRate;\\n    IRefStore refs;\\n    IERC20Burnable RB;\\n    IRunbitRand randFactory;\\n    // can exchange card\\n    IERC20Burnable cardToken;\\n    // can exchange equipment\\n    IERC20Burnable equipToken;\\n    IRunbitCard NFTCard;\\n    IRunbitEquip NFTEquip;\\n    // step check contract\\n    IStepCheck stepCheck;\\n    RewardRate rewardRate;\\n    LotteryInfo baseLottery;\\n    mapping(address => uint256) RBReward;\\n    // userEquips[user][equipType] = equipTokenId\\n    mapping(address => mapping(uint256 => uint256)) userEquips;\\n    // equipCards[equipTokenId][index] = cardTokenId\\n    mapping(uint256 => mapping(uint256 => uint256)) equipCards;\\n    // cardConsume[cardTokenId] = days\\n    mapping(uint256 => uint256) cardConsume;\\n    // cardStepCount[cardTokenId][day] = count\\n    mapping(uint256 => mapping(uint256 => StepCount)) cardStepCount;\\n    // userCards[user][day][index] = cardId\\n    mapping(address => mapping(uint256 => mapping(uint256 => uint256))) userCards;\\n    // equipInfo[equipId] = info\\n    mapping(uint256 => EquipInfo) equipInfo;\\n    // cardInfo[cardId] = info\\n    mapping(uint256 => CardInfo) cardInfo;\\n    // userState[user][day] = state\\n    mapping(address => mapping(uint256 => UserState)) userState;\\n    // dailyInfo[day] = info\\n    mapping(uint256 => DailyInfo) dailyInfo;\\n    // userTrack[user] = TrackInfo\\n    mapping(address => TrackInfo) userTrack;\\n    // lotteryInfo[day] = LotteryInfo\\n    mapping(uint256 => LotteryInfo) lotterInfo;\\n    // lotteryRand[day] = rand\\n    mapping(uint256 => uint256) lotteryRand;\\n    // dailyBonus[day] = bonus\\n    mapping(uint256 => uint256) dailyBonus;\\n    // dailyCommit[day] = bonus\\n    mapping(uint256 => uint256) dailyCommit;\\n    // dailyTech[day] = bonus\\n    mapping(uint256 => uint256) dailyTech;\\n\\n\\n    modifier onlyReferral {\\n        require(paused == 0 && refs.referrer(msg.sender) != address(0), \\\"Not available!\\\");\\n        _;\\n    }\\n    \\n    function setRand() external onlyRole(MANAGE_ROLE) {\\n        uint256 day = _day() - 1;\\n        uint256 rand = randFactory.getRand(day);\\n        require(rand != 0, \\\"not start!\\\");\\n        lotterInfo[day] = baseLottery;\\n        lotteryRand[day] = rand;\\n        emit RandSet(day, rand);\\n    }\\n    \\n    function lottery(uint256 day) external {\\n        require(lotteryRand[day] != 0, \\\"E01: not start!\\\");\\n        UserState storage us = userState[msg.sender][day];\\n        require(us.lottery == 0 && us.cardCount > 0, \\\"E02: no chance!\\\");\\n        (uint256 RBAmount, uint256 CTAmount, uint256 ETAmount) = _calcLottery(msg.sender, day);\\n\\n        us.lottery = 1;\\n        if (RBAmount > 0) {\\n            RB.mint(msg.sender, RBAmount);\\n            emit LotteryRB(msg.sender, day, RBAmount);\\n        }\\n        if (CTAmount > 0) {\\n            cardToken.mint(msg.sender, CTAmount);\\n            emit LotteryCT(msg.sender, day, CTAmount);\\n        }\\n\\n        if (ETAmount > 0) {\\n            equipToken.mint(msg.sender, ETAmount);\\n            emit LotteryET(msg.sender, day, ETAmount);\\n        }\\n    }\\n    \\n    function bindEquip(uint256 tokenId) external {\\n        EquipInfo memory ei = equipInfo[tokenId];\\n        address equipOwner = NFTEquip.ownerOf(tokenId);\\n        require(equipOwner != address(0), \\\"E03: burned!\\\");\\n        if (ei.latestDay == _day()) {\\n            require(ei.owner == msg.sender, \\\"E01: owner check failed!\\\");\\n        } else {\\n            require(equipOwner == msg.sender, \\\"E02: owner check failed!\\\");\\n        }\\n        IRunbitEquip.MetaData memory meta = NFTEquip.tokenMetaData(tokenId);\\n        userEquips[msg.sender][meta.equipType] = tokenId;\\n        emit EquipBind(tokenId, msg.sender);\\n    }\\n    \\n\\n    function unbindEquip(uint256 equipType) external {\\n        userEquips[msg.sender][equipType] = 0;\\n        emit EquipUnbind(msg.sender, equipType);\\n    }\\n\\n    // update steps\\n    function updateSteps(uint256 steps) external onlyReferral {\\n        steps = stepCheck.stepCheck(steps, msg.sender);\\n        uint256 today = _day();\\n        uint256 trackId = _trackId();\\n        UserState storage us = userState[msg.sender][today];\\n        DailyInfo storage dinf = dailyInfo[today];\\n        require(steps > us.lastSteps, \\\"E01: no need to update!\\\");\\n\\n        unchecked {\\n            if(us.lastSteps == 0) {\\n                dinf.userCount += 1;\\n                us.trackId = uint16(trackId);\\n            }\\n            steps -= us.lastSteps;\\n            us.lastSteps += uint64(steps);\\n\\n            for(uint i = 0; i < 3; ++i) {\\n                uint256 eid = userEquips[msg.sender][i];\\n                if (eid != 0) {\\n                    EquipInfo storage info = equipInfo[eid];\\n                    address equipOwner = NFTEquip.ownerOf(eid);\\n\\n                    if (equipOwner == address(0)) {\\n                        userEquips[msg.sender][i] = 0;\\n                        continue;\\n                    }\\n\\n                    if (info.latestDay != today) {\\n                        if (equipOwner == msg.sender) {\\n                            info.owner = msg.sender;\\n                            info.latestDay = uint32(today);\\n                        } else {\\n\\n                            userEquips[msg.sender][i] = 0;\\n                            continue;\\n                        }\\n                    }\\n                    IRunbitEquip.MetaData memory meta = NFTEquip.tokenMetaData(eid);\\n                    for(uint j = 0; j < meta.capacity; ++j) {\\n                        uint256 cid = equipCards[eid][j];\\n                        if (cid != 0) {\\n                            StepCount storage sc = cardStepCount[cid][today];\\n                            IRunbitCard.MetaData memory cm = NFTCard.tokenMetaData(cid);\\n                            // update card\\n                            if (sc.count == 0) {\\n\\n                                if (cardConsume[cid] >= cm.durability) {\\n                                    continue;\\n                                }\\n                                if (NFTCard.ownerOf(cid) != msg.sender) {\\n\\n                                    equipCards[eid][j] = 0;\\n\\n                                    continue;\\n                                }\\n\\n                                dinf.totalAesthetic += cm.aesthetic;\\n                                dinf.totalSpecialty += cm.specialty;\\n                                dinf.totalComfort += cm.comfort;\\n                                if (trackId == 0) {\\n                                    dinf.track0 += cm.level;\\n                                } else if (trackId == 1) {\\n                                    dinf.track1 += cm.level;\\n                                } else {\\n                                    dinf.track2 += cm.level;\\n                                }\\n                                \\n                                cardConsume[cid] += 100 * epoch / 86400;\\n                                sc.equipType = uint64(i);\\n                                sc.trackId = uint64(trackId);\\n                                userCards[msg.sender][today][us.cardCount] = cid;\\n                                us.cardCount += 1;\\n                                emit CardUse(cid, msg.sender);\\n                            }\\n                            sc.count += uint64(steps);\\n                        }\\n                    }\\n                }\\n            }            \\n        }\\n    }\\n    \\n\\n    function bindCard(uint256 equipId, uint256 cardId, uint256 index) external {\\n        require(equipInfo[equipId].latestDay != _day(), \\\"Try it tomorrow!\\\");\\n        require(NFTEquip.ownerOf(equipId) == msg.sender, \\\"Not owner!\\\");\\n        require(NFTCard.ownerOf(cardId) == msg.sender, \\\"Not owner!\\\");\\n        IRunbitEquip.MetaData memory equip = NFTEquip.tokenMetaData(equipId);\\n        IRunbitCard.MetaData memory card = NFTCard.tokenMetaData(cardId);\\n        require(index < equip.capacity, \\\"invalid index!\\\");\\n        require(card.level <= equip.level, \\\"invalid level!\\\");\\n        delete cardInfo[equipCards[equipId][index]];\\n        CardInfo storage info = cardInfo[cardId];\\n        if(info.equipId > 0) {\\n            equipCards[info.equipId][info.idx] = 0;\\n        }\\n        equipCards[equipId][index] = cardId;\\n        info.equipId = uint192(equipId);\\n        info.idx = uint64(index);\\n        emit CardBind(cardId, msg.sender, equipId, index);\\n    }\\n    \\n    function unbindCard(uint256 equipId, uint256 index) external {\\n        require(equipInfo[equipId].latestDay != _day(), \\\"Try it tomorrow!\\\");\\n        require(NFTEquip.ownerOf(equipId) == msg.sender, \\\"Not owner!\\\");\\n        emit CardUnbind(equipCards[equipId][index], msg.sender, equipId, index);\\n        delete cardInfo[equipCards[equipId][index]];\\n        equipCards[equipId][index] = 0;\\n    }\\n    \\n    function updateTrack(uint256 trackId) external {\\n        require(userEquips[msg.sender][trackId] != 0, \\\"no equip!\\\");\\n        TrackInfo storage ut = userTrack[msg.sender];\\n        uint256 today = _day();\\n        if (today == ut.updateDay) {\\n            ut.latest = uint64(trackId);\\n        } else {\\n            ut.updateDay = uint64(today); \\n            ut.prev = ut.latest;\\n            ut.latest = uint64(trackId);\\n        }\\n        emit TrackChange(msg.sender, trackId);\\n    }\\n    \\n    function harvest(uint256 startDay, uint256 endDay) external {\\n        require(endDay <= _day(), \\\"invalid endDay\\\");\\n        unchecked {\\n            for (uint day = startDay; day < endDay; ++day) {\\n                uint256 reward = _calcReward(msg.sender, day);\\n                if (reward > 0) {\\n                    UserState storage us = userState[msg.sender][day];\\n                    us.RBReward = uint128(reward);\\n                    us.status = 1;\\n                    RBReward[msg.sender] += reward;\\n                    emit RBHarvest(msg.sender, reward, day);\\n                }\\n            }            \\n        }\\n    }\\n\\n    function claimBonus(uint256 day) external onlyRole(MANAGE_ROLE) {\\n        require(day < _day(), \\\"too early!\\\");\\n        require(dailyBonus[day] == 0 && dailyCommit[day] == 0 && dailyTech[day] == 0, \\\"claimed!\\\");\\n        (uint256 commitAmount, uint256 techAmount, uint256 bonusAmount) = _calcBonus(day);\\n        dailyBonus[day] = bonusAmount;\\n        dailyCommit[day] = commitAmount;\\n        dailyTech[day] = techAmount;\\n        RB.mint(committee, commitAmount);\\n        RB.mint(techFound, techAmount);\\n        RB.mint(bonusFound, bonusAmount);\\n        emit BonusClaim(day, commitAmount, techAmount, bonusAmount);\\n    }\\n\\n    function claim(uint256 amount, address to) external {\\n        require(amount <= RBReward[msg.sender], \\\"E01: insufficient amount!\\\");\\n        unchecked {\\n            RBReward[msg.sender] -= amount;    \\n        }\\n        RB.mint(to, amount);\\n        emit RBClaim(msg.sender, to, amount);\\n    }\\n    \\n    // commit tech bonus\\n    function _calcBonus(uint256 day) private view returns (uint256, uint256, uint256) {\\n        uint256 totalReward = 0;\\n        unchecked {\\n            totalReward += uint256(dailyInfo[day].totalAesthetic) * rewardRate.aesthetic;\\n            totalReward += uint256(dailyInfo[day].totalSpecialty) * rewardRate.specialty;\\n            totalReward += uint256(dailyInfo[day].totalComfort) * rewardRate.comfort;    \\n        }\\n        return (totalReward * commitRate / 100000000, totalReward * techRate / 100000000, totalReward * bonusRate / 100000000);\\n    }\\n\\n    function _calcReward(address user, uint256 day) private view returns (uint256) {\\n        uint256 reward = 0;\\n        UserState memory us = userState[user][day];\\n        //\\n        if (us.status == 0) {\\n            unchecked {\\n                for(uint i = 0; i < us.cardCount; ++i) {\\n                    uint256 cid = userCards[user][day][i];\\n                    reward += _calcCardReward(cid, day);\\n                }    \\n            }\\n        }\\n        return reward;\\n    }\\n\\n    function _calcCardReward(uint256 cid, uint256 day) private view returns (uint256 baseReward) {\\n        IRunbitCard.MetaData memory meta = NFTCard.tokenMetaData(cid);\\n        StepCount memory sc = cardStepCount[cid][day];\\n        uint256 trackCount;\\n        uint256 baseReward2;\\n        if (sc.trackId == 0) {\\n            trackCount = dailyInfo[day].track0;\\n        } else if (sc.trackId == 1) {\\n            trackCount = dailyInfo[day].track1;\\n        } else {\\n            trackCount = dailyInfo[day].track2;\\n        }\\n        unchecked {\\n            baseReward = uint256(rewardRate.specialty) * meta.specialty;\\n            baseReward += uint256(rewardRate.aesthetic) * meta.aesthetic;\\n            baseReward2 = uint256(rewardRate.comfort) * meta.comfort;   \\n        }\\n\\n        if (trackCount > rewardRate.trackCapacity) {\\n            if (trackCount > rewardRate.trackLimit) {\\n                trackCount = rewardRate.trackLimit;\\n            }\\n            baseReward -= baseReward * (trackCount - rewardRate.trackCapacity) * rewardRate.jamDecay / 1000000000000000000;\\n\\n            baseReward2 -= baseReward2 * (trackCount - rewardRate.trackCapacity) * (rewardRate.jamDecay - rewardRate.comfortBuff) / 1000000000000000000;\\n        }\\n        unchecked {\\n            baseReward += baseReward2;\\n        }\\n\\n        if (sc.equipType != sc.trackId) {\\n            baseReward -= baseReward * rewardRate.trackDecay / 1000000000000000000;\\n        }\\n\\n        if(sc.count < rewardRate.minSteps) {\\n            baseReward -= baseReward * (rewardRate.minSteps - sc.count) * rewardRate.stepDecay / 1000000000000000000;\\n        }\\n    }\\n\\n    function _calcLottery(address user, uint256 day) private view returns (uint256 RBAmount, uint256 CTAmount, uint256 ETAmount) {\\n        uint256 totalAesthetic = dailyInfo[day].totalAesthetic;\\n        if(totalAesthetic == 0) {\\n            return (0, 0, 0);\\n        }\\n        uint256 aesthetic = 0;\\n        UserState memory us = userState[user][day];\\n        unchecked {\\n            for(uint i = 0; i < us.cardCount; ++i) {\\n                uint256 cid = userCards[user][day][i];\\n                IRunbitCard.MetaData memory meta = NFTCard.tokenMetaData(cid);\\n                aesthetic += meta.aesthetic;\\n            }\\n            LotteryInfo memory li = lotterInfo[day];\\n            //RB\\n            uint256 rand = uint256(keccak256(abi.encodePacked(user, lotteryRand[day])));\\n            uint256 chance = rand % totalAesthetic;\\n            if (chance < li.RBNum * aesthetic) {\\n                RBAmount = totalAesthetic * li.RBRate;\\n            }\\n\\n            rand = uint256(keccak256(abi.encodePacked(user, rand)));\\n            chance = rand % totalAesthetic;\\n            if (chance < li.RBNum * aesthetic) {\\n                CTAmount = totalAesthetic * li.CTRate / 100000000;\\n            }\\n\\n            rand = uint256(keccak256(abi.encodePacked(user, rand)));\\n            chance = rand % totalAesthetic;\\n            if (chance < li.RBNum * aesthetic) {\\n                ETAmount = totalAesthetic * li.ETRate / 100000000;\\n            }    \\n        }\\n    }\\n\\n    function setFound(address _commit, address _tech, address _bonus) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        (techFound, committee, bonusFound) = (_tech, _commit, _bonus);\\n    }\\n    // 1e8\\n    function setRate(uint256 _commit, uint256 _tech, uint256 _bonus) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        (techRate, commitRate, bonusRate) = (_tech, _commit, _bonus);\\n    }\\n    \\n    function setFactorys(address _refs, address _rand, address _stepCheck) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        refs = IRefStore(_refs);\\n        randFactory = IRunbitRand(_rand);\\n        stepCheck = IStepCheck(_stepCheck);\\n    }\\n\\n    function setTokens(address _rb, address _cardToken, address _equipToken) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        RB = IERC20Burnable(_rb);\\n        cardToken = IERC20Burnable(_cardToken);\\n        equipToken = IERC20Burnable(_equipToken);\\n    }\\n\\n    function setNFTs(address _card, address _equip) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        NFTCard = IRunbitCard(_card);\\n        NFTEquip = IRunbitEquip(_equip);\\n    }\\n\\n    function setRewardRate(RewardRate memory rate) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        rewardRate = rate;\\n    }\\n\\n    function setBaseLottery(LotteryInfo memory _baseLottery) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        baseLottery = _baseLottery;\\n    }\\n\\n    function setEpoch(uint256 _epoch) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        epoch = _epoch;\\n    }\\n    \\n    // 1: pause\uff0c0\uff1astart\\n    function pause(uint256 _v) external onlyRole(DEFAULT_ADMIN_ROLE) {\\n        paused = _v;\\n    }\\n\\n    function _day() private view returns (uint256) {\\n        return (block.timestamp + 28800) / epoch;\\n    }\\n    \\n    function _trackId() private view returns (uint256) {\\n        TrackInfo memory ut = userTrack[msg.sender];\\n        if (_day() == ut.updateDay) {\\n            return ut.prev;\\n        } else {\\n            return ut.latest;\\n        }\\n    }\\n    \\n    function getTrackId() external view returns (uint256, uint256) {\\n        return (_trackId(), userTrack[msg.sender].latest);\\n    }\\n\\n    function getUserState(address user, uint256 day) external view returns (UserState memory us) {\\n        us = userState[user][day];\\n    }\\n    \\n    function getUnharvestReward(address user, uint256 day) external view returns (uint256) {\\n        UserState memory us = userState[user][day];\\n        if (us.status == 1) {\\n            return us.RBReward;\\n        } else {\\n            return _calcReward(user, day);\\n        }\\n    }\\n    \\n    function getUnclaimReward(address user) external view returns (uint256) {\\n        return RBReward[user];\\n    }\\n    \\n    function getBindEquip(address user, uint256 equipType) external view returns (uint256) {\\n        return userEquips[user][equipType];\\n    }\\n    \\n    function getBindCard(uint256 equipId, uint256 index) external view returns (uint256) {\\n        return equipCards[equipId][index];\\n    }\\n    \\n    function getCardConsume(uint256 cardId) external view returns (uint256) {\\n        return cardConsume[cardId];\\n    }\\n    \\n    function getCardStepCount(uint256 cardId, uint256 day) external view returns (StepCount memory count) {\\n        count = cardStepCount[cardId][day];\\n    }\\n    \\n    function getEquipInfo(uint256 equipId) external view returns (EquipInfo memory info) {\\n        info = equipInfo[equipId];\\n    }\\n    \\n    function getCardInfo(uint256 cardId) external view returns (CardInfo memory info) {\\n        info = cardInfo[cardId];\\n    }\\n    \\n    function getDailyInfo(uint256 day) external view returns (DailyInfo memory info) {\\n        info = dailyInfo[day];\\n    }\\n    \\n    function getLotteryRand(uint256 day) external view returns (uint256) {\\n        return lotteryRand[day];\\n    }\\n    \\n    function getDailyBonus(uint256 day) external view returns (uint256, uint256, uint256) {\\n        return (dailyCommit[day], dailyTech[day], dailyBonus[day]);\\n    }\\n\\n    function isLucky(address user, uint256 day) external view returns (uint256, uint256, uint256) {\\n        if(lotteryRand[day] == 0) {\\n            return (0, 0, 0);\\n        }\\n        return _calcLottery(user, day);\\n    }\\n    \\n    function getUserCards(address user, uint256 day, uint256 index) external view returns (uint256) {\\n        return userCards[user][day][index];\\n    }\\n\\n    function getCardsReward(uint256 cid, uint256 day) external view returns (uint256) {\\n        return  _calcCardReward(cid, day);\\n    }\\n\\n    function getRewardRate() external view returns (RewardRate memory) {\\n        return rewardRate;\\n    }\\n    \\n    event EquipBind(uint256 indexed tokenId, address indexed user);\\n    event EquipUnbind(address indexed user, uint256 equipType);\\n    event CardUse(uint256 indexed tokenId, address indexed user);\\n    event CardBind(uint256 indexed cardId, address indexed user, uint256 equipId, uint256 index);\\n    event CardUnbind(uint256 indexed cardId, address indexed user, uint256 equipId, uint256 index);\\n    event TrackChange(address indexed user, uint256 trackId);\\n    event LotteryRB(address indexed user, uint256 day, uint256 amount);\\n    event LotteryCT(address indexed user, uint256 day, uint256 amount);\\n    event LotteryET(address indexed user, uint256 day, uint256 amount);\\n    event RBClaim(address indexed owner, address to, uint256 amount);\\n    event RBHarvest(address indexed user, uint256 amount, uint256 day);\\n    event RandSet(uint256 indexed day, uint256 rand);\\n    event BonusClaim(uint256 indexed day, uint256 commitAmount, uint256 techAmount, uint256 bonusAmount);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/AccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IAccessControl.sol\\\";\\nimport \\\"../utils/Context.sol\\\";\\nimport \\\"../utils/Strings.sol\\\";\\nimport \\\"../utils/introspection/ERC165.sol\\\";\\n\\n/**\\n * @dev Contract module that allows children to implement role-based access\\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\\n * members except through off-chain means by accessing the contract event logs. Some\\n * applications may benefit from on-chain enumerability, for those cases see\\n * {AccessControlEnumerable}.\\n *\\n * Roles are referred to by their `bytes32` identifier. These should be exposed\\n * in the external API and be unique. The best way to achieve this is by\\n * using `public constant` hash digests:\\n *\\n * ```\\n * bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\");\\n * ```\\n *\\n * Roles can be used to represent a set of permissions. To restrict access to a\\n * function call, use {hasRole}:\\n *\\n * ```\\n * function foo() public {\\n *     require(hasRole(MY_ROLE, msg.sender));\\n *     ...\\n * }\\n * ```\\n *\\n * Roles can be granted and revoked dynamically via the {grantRole} and\\n * {revokeRole} functions. Each role has an associated admin role, and only\\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\\n *\\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\\n * that only accounts with this role will be able to grant or revoke other\\n * roles. More complex role relationships can be created by using\\n * {_setRoleAdmin}.\\n *\\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\\n * grant and revoke this role. Extra precautions should be taken to secure\\n * accounts that have been granted it.\\n */\\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\\n    struct RoleData {\\n        mapping(address => bool) members;\\n        bytes32 adminRole;\\n    }\\n\\n    mapping(bytes32 => RoleData) private _roles;\\n\\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\\n\\n    /**\\n     * @dev Modifier that checks that an account has a specific role. Reverts\\n     * with a standardized message including the required role.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     *\\n     * _Available since v4.1._\\n     */\\n    modifier onlyRole(bytes32 role) {\\n        _checkRole(role);\\n        _;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\\n        return _roles[role].members[account];\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\\n     *\\n     * Format of the revert message is described in {_checkRole}.\\n     *\\n     * _Available since v4.6._\\n     */\\n    function _checkRole(bytes32 role) internal view virtual {\\n        _checkRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Revert with a standard message if `account` is missing `role`.\\n     *\\n     * The format of the revert reason is given by the following regular expression:\\n     *\\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\\n     */\\n    function _checkRole(bytes32 role, address account) internal view virtual {\\n        if (!hasRole(role, account)) {\\n            revert(\\n                string(\\n                    abi.encodePacked(\\n                        \\\"AccessControl: account \\\",\\n                        Strings.toHexString(uint160(account), 20),\\n                        \\\" is missing role \\\",\\n                        Strings.toHexString(uint256(role), 32)\\n                    )\\n                )\\n            );\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\\n        return _roles[role].adminRole;\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function renounceRole(bytes32 role, address account) public virtual override {\\n        require(account == _msgSender(), \\\"AccessControl: can only renounce roles for self\\\");\\n\\n        _revokeRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event. Note that unlike {grantRole}, this function doesn't perform any\\n     * checks on the calling account.\\n     *\\n     * May emit a {RoleGranted} event.\\n     *\\n     * [WARNING]\\n     * ====\\n     * This function should only be called from the constructor when setting\\n     * up the initial roles for the system.\\n     *\\n     * Using this function in any other way is effectively circumventing the admin\\n     * system imposed by {AccessControl}.\\n     * ====\\n     *\\n     * NOTE: This function is deprecated in favor of {_grantRole}.\\n     */\\n    function _setupRole(bytes32 role, address account) internal virtual {\\n        _grantRole(role, account);\\n    }\\n\\n    /**\\n     * @dev Sets `adminRole` as ``role``'s admin role.\\n     *\\n     * Emits a {RoleAdminChanged} event.\\n     */\\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\\n        bytes32 previousAdminRole = getRoleAdmin(role);\\n        _roles[role].adminRole = adminRole;\\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\\n    }\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleGranted} event.\\n     */\\n    function _grantRole(bytes32 role, address account) internal virtual {\\n        if (!hasRole(role, account)) {\\n            _roles[role].members[account] = true;\\n            emit RoleGranted(role, account, _msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * Internal function without access restriction.\\n     *\\n     * May emit a {RoleRevoked} event.\\n     */\\n    function _revokeRole(bytes32 role, address account) internal virtual {\\n        if (hasRole(role, account)) {\\n            _roles[role].members[account] = false;\\n            emit RoleRevoked(role, account, _msgSender());\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/IRunbit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\";\\npragma solidity ^0.8.14;\\n\\ninterface IRefStore {\\n    /// referrer\\n    function referrer(address from) external view returns (address);\\n    /// add referrer\\n    function addReferrer(address from, address to) external;\\n    /// referrer added\\n    event ReferrerAdded(address indexed to, address from);\\n}\\n\\ninterface IERC20Burnable is IERC20 {\\n    function burn(uint256 amount) external;\\n    function burnFrom(address account, uint256 amount) external;\\n    function mint(address to, uint256 amount) external;\\n}\\n\\ninterface IDataFeed {\\n    function latestAnswer()  external view returns (int256);\\n    function latestTimestamp() external view returns (uint256);\\n}\\n\\ninterface IRunbitRand {\\n    function getRand(uint256 round) external view returns (uint256);\\n    function genNormalRand() external view returns (uint256);\\n}\\n\\ninterface IRunbitCard is IERC721 {\\n    struct MetaData {\\n        uint64 specialty;\\n        uint64 comfort;\\n        uint64 aesthetic;\\n        uint32 durability;\\n        uint32 level;\\n    }\\n\\n    function safeMint(address to, uint256 tokenId, string memory uri, MetaData memory metaData) external;\\n    function tokenMetaData(uint256 tokenId) external view returns (MetaData memory);\\n    function burn(uint256 tokenId) external;\\n}\\n\\ninterface IRunbitEquip is IERC721 {\\n    struct MetaData {\\n        uint32 equipType;\\n        uint32 upgradeable;\\n        uint64 level;\\n        uint64 capacity;\\n        uint64 quality;\\n    }\\n\\n    function safeMint(address to, uint256 tokenId, string memory uri, MetaData memory metaData) external;\\n    function tokenMetaData(uint256 tokenId) external view returns (MetaData memory);\\n    function burn(uint256 tokenId) external;\\n}\\n\\ninterface IStepCheck {\\n    function stepCheck(uint256 checkSum, address user) external view returns (uint256);\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 2000000\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commitAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"techAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusAmount\",\"type\":\"uint256\"}],\"name\":\"BonusClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"equipId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CardBind\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"equipId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"CardUnbind\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"CardUse\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"EquipBind\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"equipType\",\"type\":\"uint256\"}],\"name\":\"EquipUnbind\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LotteryCT\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LotteryET\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LotteryRB\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RBClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"RBHarvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rand\",\"type\":\"uint256\"}],\"name\":\"RandSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"trackId\",\"type\":\"uint256\"}],\"name\":\"TrackChange\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MANAGE_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"equipId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"bindCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"bindEquip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"claimBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"equipId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getBindCard\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"equipType\",\"type\":\"uint256\"}],\"name\":\"getBindEquip\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"getCardConsume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"}],\"name\":\"getCardInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint192\",\"name\":\"equipId\",\"type\":\"uint192\"},{\"internalType\":\"uint64\",\"name\":\"idx\",\"type\":\"uint64\"}],\"internalType\":\"struct Runbit.CardInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cardId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getCardStepCount\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"count\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"equipType\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trackId\",\"type\":\"uint64\"}],\"internalType\":\"struct Runbit.StepCount\",\"name\":\"count\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getCardsReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getDailyBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getDailyInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"track0\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"track1\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"track2\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"userCount\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalSpecialty\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalComfort\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"totalAesthetic\",\"type\":\"uint64\"}],\"internalType\":\"struct Runbit.DailyInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"equipId\",\"type\":\"uint256\"}],\"name\":\"getEquipInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"emptyId\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"latestDay\",\"type\":\"uint32\"}],\"internalType\":\"struct Runbit.EquipInfo\",\"name\":\"info\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getLotteryRand\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardRate\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"trackDecay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"stepDecay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"jamDecay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"comfortBuff\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trackCapacity\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trackLimit\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"specialty\",\"type\":\"uint128\"},{\"internalType\":\"uint112\",\"name\":\"aesthetic\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"comfort\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"minSteps\",\"type\":\"uint32\"}],\"internalType\":\"struct Runbit.RewardRate\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTrackId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUnclaimReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getUnharvestReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserCards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"getUserState\",\"outputs\":[{\"components\":[{\"internalType\":\"uint8\",\"name\":\"status\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"lottery\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"trackId\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"cardCount\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"lastSteps\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"RBReward\",\"type\":\"uint128\"}],\"internalType\":\"struct Runbit.UserState\",\"name\":\"us\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startDay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endDay\",\"type\":\"uint256\"}],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"isLucky\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"}],\"name\":\"lottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_v\",\"type\":\"uint256\"}],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint128\",\"name\":\"RBRate\",\"type\":\"uint128\"},{\"internalType\":\"uint64\",\"name\":\"ETRate\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"CTRate\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"RBNum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"ETNum\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"CTNum\",\"type\":\"uint64\"}],\"internalType\":\"struct Runbit.LotteryInfo\",\"name\":\"_baseLottery\",\"type\":\"tuple\"}],\"name\":\"setBaseLottery\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_epoch\",\"type\":\"uint256\"}],\"name\":\"setEpoch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_refs\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rand\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_stepCheck\",\"type\":\"address\"}],\"name\":\"setFactorys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_commit\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tech\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_bonus\",\"type\":\"address\"}],\"name\":\"setFound\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_card\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_equip\",\"type\":\"address\"}],\"name\":\"setNFTs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"setRand\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_commit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tech\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"trackDecay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"stepDecay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"jamDecay\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"comfortBuff\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trackCapacity\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"trackLimit\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"specialty\",\"type\":\"uint128\"},{\"internalType\":\"uint112\",\"name\":\"aesthetic\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"comfort\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"minSteps\",\"type\":\"uint32\"}],\"internalType\":\"struct Runbit.RewardRate\",\"name\":\"rate\",\"type\":\"tuple\"}],\"name\":\"setRewardRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_rb\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_cardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_equipToken\",\"type\":\"address\"}],\"name\":\"setTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"equipId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"unbindCard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"equipType\",\"type\":\"uint256\"}],\"name\":\"unbindEquip\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"steps\",\"type\":\"uint256\"}],\"name\":\"updateSteps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"trackId\",\"type\":\"uint256\"}],\"name\":\"updateTrack\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Runbit", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "2000000", "ConstructorArguments": "0000000000000000000000001201699290236175810866397953576444557797", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}