{"SourceCode": "// Sources flattened with hardhat v2.4.3 https://hardhat.org\n\n// File @openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol@v4.2.0\n\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n\t/**\n\t * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n\t * given ``owner``'s signed approval.\n\t *\n\t * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n\t * ordering also apply here.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t * - `deadline` must be a timestamp in the future.\n\t * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n\t * over the EIP712-formatted function arguments.\n\t * - the signature must use ``owner``'s current nonce (see {nonces}).\n\t *\n\t * For more information on the signature format, see the\n\t * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n\t * section].\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) external;\n\n\t/**\n\t * @dev Returns the current nonce for `owner`. This value must be\n\t * included whenever a signature is generated for {permit}.\n\t *\n\t * Every successful call to {permit} increases ``owner``'s nonce by one. This\n\t * prevents a signature from being used multiple times.\n\t */\n\tfunction nonces(address owner) external view returns (uint256);\n\n\t/**\n\t * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n\t */\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\t/**\n\t * @dev Returns the amount of tokens in existence.\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @dev Returns the amount of tokens owned by `account`.\n\t */\n\tfunction balanceOf(address account) external view returns (uint256);\n\n\t/**\n\t * @dev Moves `amount` tokens from the caller's account to `recipient`.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transfer(address recipient, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Returns the remaining number of tokens that `spender` will be\n\t * allowed to spend on behalf of `owner` through {transferFrom}. This is\n\t * zero by default.\n\t *\n\t * This value changes when {approve} or {transferFrom} are called.\n\t */\n\tfunction allowance(address owner, address spender)\n\t\texternal\n\t\tview\n\t\treturns (uint256);\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * IMPORTANT: Beware that changing an allowance with this method brings the risk\n\t * that someone may use both the old and the new allowance by unfortunate\n\t * transaction ordering. One possible solution to mitigate this race\n\t * condition is to first reduce the spender's allowance to 0 and set the\n\t * desired value afterwards:\n\t * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n\t *\n\t * Emits an {Approval} event.\n\t */\n\tfunction approve(address spender, uint256 amount) external returns (bool);\n\n\t/**\n\t * @dev Moves `amount` tokens from `sender` to `recipient` using the\n\t * allowance mechanism. `amount` is then deducted from the caller's\n\t * allowance.\n\t *\n\t * Returns a boolean value indicating whether the operation succeeded.\n\t *\n\t * Emits a {Transfer} event.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) external returns (bool);\n\n\t/**\n\t * @dev Emitted when `value` tokens are moved from one account (`from`) to\n\t * another (`to`).\n\t *\n\t * Note that `value` may be zero.\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n\t * a call to {approve}. `value` is the new allowance.\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n// File @openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n\t/**\n\t * @dev Returns the name of the token.\n\t */\n\tfunction name() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the symbol of the token.\n\t */\n\tfunction symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the decimals places of the token.\n\t */\n\tfunction decimals() external view returns (uint8);\n}\n\n// File @openzeppelin/contracts/utils/Context.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n\tfunction _msgSender() internal view virtual returns (address) {\n\t\treturn msg.sender;\n\t}\n\n\tfunction _msgData() internal view virtual returns (bytes calldata) {\n\t\treturn msg.data;\n\t}\n}\n\n// File @openzeppelin/contracts/token/ERC20/ERC20.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n\tmapping(address => uint256) private _balances;\n\n\tmapping(address => mapping(address => uint256)) private _allowances;\n\n\tuint256 private _totalSupply;\n\n\tstring private _name;\n\tstring private _symbol;\n\n\t/**\n\t * @dev Sets the values for {name} and {symbol}.\n\t *\n\t * The default value of {decimals} is 18. To select a different value for\n\t * {decimals} you should overload it.\n\t *\n\t * All two of these values are immutable: they can only be set once during\n\t * construction.\n\t */\n\tconstructor(string memory name_, string memory symbol_) {\n\t\t_name = name_;\n\t\t_symbol = symbol_;\n\t}\n\n\t/**\n\t * @dev Returns the name of the token.\n\t */\n\tfunction name() public view virtual override returns (string memory) {\n\t\treturn _name;\n\t}\n\n\t/**\n\t * @dev Returns the symbol of the token, usually a shorter version of the\n\t * name.\n\t */\n\tfunction symbol() public view virtual override returns (string memory) {\n\t\treturn _symbol;\n\t}\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t * For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * Tokens usually opt for a value of 18, imitating the relationship between\n\t * Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t * overridden;\n\t *\n\t * NOTE: This information is only used for _display_ purposes: it in\n\t * no way affects any of the arithmetic of the contract, including\n\t * {IERC20-balanceOf} and {IERC20-transfer}.\n\t */\n\tfunction decimals() public view virtual override returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @dev See {IERC20-totalSupply}.\n\t */\n\tfunction totalSupply() public view virtual override returns (uint256) {\n\t\treturn _totalSupply;\n\t}\n\n\t/**\n\t * @dev See {IERC20-balanceOf}.\n\t */\n\tfunction balanceOf(address account)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _balances[account];\n\t}\n\n\t/**\n\t * @dev See {IERC20-transfer}.\n\t *\n\t * Requirements:\n\t *\n\t * - `recipient` cannot be the zero address.\n\t * - the caller must have a balance of at least `amount`.\n\t */\n\tfunction transfer(address recipient, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_transfer(_msgSender(), recipient, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-allowance}.\n\t */\n\tfunction allowance(address owner, address spender)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _allowances[owner][spender];\n\t}\n\n\t/**\n\t * @dev See {IERC20-approve}.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction approve(address spender, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\t_approve(_msgSender(), spender, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev See {IERC20-transferFrom}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance. This is not\n\t * required by the EIP. See the note at the beginning of {ERC20}.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` and `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t * - the caller must have allowance for ``sender``'s tokens of at least\n\t * `amount`.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) public virtual override returns (bool) {\n\t\t_transfer(sender, recipient, amount);\n\n\t\tuint256 currentAllowance = _allowances[sender][_msgSender()];\n\t\trequire(\n\t\t\tcurrentAllowance >= amount,\n\t\t\t\"ERC20: transfer amount exceeds allowance\"\n\t\t);\n\t\tunchecked {\n\t\t\t_approve(sender, _msgSender(), currentAllowance - amount);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Atomically increases the allowance granted to `spender` by the caller.\n\t *\n\t * This is an alternative to {approve} that can be used as a mitigation for\n\t * problems described in {IERC20-approve}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction increaseAllowance(address spender, uint256 addedValue)\n\t\tpublic\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\t_approve(\n\t\t\t_msgSender(),\n\t\t\tspender,\n\t\t\t_allowances[_msgSender()][spender] + addedValue\n\t\t);\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Atomically decreases the allowance granted to `spender` by the caller.\n\t *\n\t * This is an alternative to {approve} that can be used as a mitigation for\n\t * problems described in {IERC20-approve}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance.\n\t *\n\t * Requirements:\n\t *\n\t * - `spender` cannot be the zero address.\n\t * - `spender` must have allowance for the caller of at least\n\t * `subtractedValue`.\n\t */\n\tfunction decreaseAllowance(address spender, uint256 subtractedValue)\n\t\tpublic\n\t\tvirtual\n\t\treturns (bool)\n\t{\n\t\tuint256 currentAllowance = _allowances[_msgSender()][spender];\n\t\trequire(\n\t\t\tcurrentAllowance >= subtractedValue,\n\t\t\t\"ERC20: decreased allowance below zero\"\n\t\t);\n\t\tunchecked {\n\t\t\t_approve(_msgSender(), spender, currentAllowance - subtractedValue);\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @dev Moves `amount` of tokens from `sender` to `recipient`.\n\t *\n\t * This internal function is equivalent to {transfer}, and can be used to\n\t * e.g. implement automatic token fees, slashing mechanisms, etc.\n\t *\n\t * Emits a {Transfer} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` cannot be the zero address.\n\t * - `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t */\n\tfunction _transfer(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(sender != address(0), \"ERC20: transfer from the zero address\");\n\t\trequire(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n\t\t_beforeTokenTransfer(sender, recipient, amount);\n\n\t\tuint256 senderBalance = _balances[sender];\n\t\trequire(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\t\tunchecked {\n\t\t\t_balances[sender] = senderBalance - amount;\n\t\t}\n\t\t_balances[recipient] += amount;\n\n\t\temit Transfer(sender, recipient, amount);\n\n\t\t_afterTokenTransfer(sender, recipient, amount);\n\t}\n\n\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\t * the total supply.\n\t *\n\t * Emits a {Transfer} event with `from` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `account` cannot be the zero address.\n\t */\n\tfunction _mint(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: mint to the zero address\");\n\n\t\t_beforeTokenTransfer(address(0), account, amount);\n\n\t\t_totalSupply += amount;\n\t\t_balances[account] += amount;\n\t\temit Transfer(address(0), account, amount);\n\n\t\t_afterTokenTransfer(address(0), account, amount);\n\t}\n\n\t/**\n\t * @dev Destroys `amount` tokens from `account`, reducing the\n\t * total supply.\n\t *\n\t * Emits a {Transfer} event with `to` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `account` cannot be the zero address.\n\t * - `account` must have at least `amount` tokens.\n\t */\n\tfunction _burn(address account, uint256 amount) internal virtual {\n\t\trequire(account != address(0), \"ERC20: burn from the zero address\");\n\n\t\t_beforeTokenTransfer(account, address(0), amount);\n\n\t\tuint256 accountBalance = _balances[account];\n\t\trequire(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n\t\tunchecked {\n\t\t\t_balances[account] = accountBalance - amount;\n\t\t}\n\t\t_totalSupply -= amount;\n\n\t\temit Transfer(account, address(0), amount);\n\n\t\t_afterTokenTransfer(account, address(0), amount);\n\t}\n\n\t/**\n\t * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n\t *\n\t * This internal function is equivalent to `approve`, and can be used to\n\t * e.g. set automatic allowances for certain subsystems, etc.\n\t *\n\t * Emits an {Approval} event.\n\t *\n\t * Requirements:\n\t *\n\t * - `owner` cannot be the zero address.\n\t * - `spender` cannot be the zero address.\n\t */\n\tfunction _approve(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 amount\n\t) internal virtual {\n\t\trequire(owner != address(0), \"ERC20: approve from the zero address\");\n\t\trequire(spender != address(0), \"ERC20: approve to the zero address\");\n\n\t\t_allowances[owner][spender] = amount;\n\t\temit Approval(owner, spender, amount);\n\t}\n\n\t/**\n\t * @dev Hook that is called before any transfer of tokens. This includes\n\t * minting and burning.\n\t *\n\t * Calling conditions:\n\t *\n\t * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\t * will be transferred to `to`.\n\t * - when `from` is zero, `amount` tokens will be minted for `to`.\n\t * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n\t * - `from` and `to` are never both zero.\n\t *\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\t */\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual {}\n\n\t/**\n\t * @dev Hook that is called after any transfer of tokens. This includes\n\t * minting and burning.\n\t *\n\t * Calling conditions:\n\t *\n\t * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n\t * has been transferred to `to`.\n\t * - when `from` is zero, `amount` tokens have been minted for `to`.\n\t * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n\t * - `from` and `to` are never both zero.\n\t *\n\t * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n\t */\n\tfunction _afterTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual {}\n}\n\n// File @openzeppelin/contracts/utils/cryptography/ECDSA.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n\t/**\n\t * @dev Returns the address that signed a hashed message (`hash`) with\n\t * `signature`. This address can then be used for verification purposes.\n\t *\n\t * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n\t * this function rejects them by requiring the `s` value to be in the lower\n\t * half order, and the `v` value to be either 27 or 28.\n\t *\n\t * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n\t * verification to be secure: it is possible to craft signatures that\n\t * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n\t * this is by receiving a hash of the original message (which may otherwise\n\t * be too long), and then calling {toEthSignedMessageHash} on it.\n\t *\n\t * Documentation for signature generation:\n\t * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n\t * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n\t */\n\tfunction recover(bytes32 hash, bytes memory signature)\n\t\tinternal\n\t\tpure\n\t\treturns (address)\n\t{\n\t\t// Check the signature length\n\t\t// - case 65: r,s,v signature (standard)\n\t\t// - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n\t\tif (signature.length == 65) {\n\t\t\tbytes32 r;\n\t\t\tbytes32 s;\n\t\t\tuint8 v;\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\tassembly {\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\ts := mload(add(signature, 0x40))\n\t\t\t\tv := byte(0, mload(add(signature, 0x60)))\n\t\t\t}\n\t\t\treturn recover(hash, v, r, s);\n\t\t} else if (signature.length == 64) {\n\t\t\tbytes32 r;\n\t\t\tbytes32 vs;\n\t\t\t// ecrecover takes the signature parameters, and the only way to get them\n\t\t\t// currently is to use assembly.\n\t\t\tassembly {\n\t\t\t\tr := mload(add(signature, 0x20))\n\t\t\t\tvs := mload(add(signature, 0x40))\n\t\t\t}\n\t\t\treturn recover(hash, r, vs);\n\t\t} else {\n\t\t\trevert(\"ECDSA: invalid signature length\");\n\t\t}\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.\n\t *\n\t * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n\t *\n\t * _Available since v4.2._\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tbytes32 r,\n\t\tbytes32 vs\n\t) internal pure returns (address) {\n\t\tbytes32 s;\n\t\tuint8 v;\n\t\tassembly {\n\t\t\ts := and(\n\t\t\t\tvs,\n\t\t\t\t0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n\t\t\t)\n\t\t\tv := add(shr(255, vs), 27)\n\t\t}\n\t\treturn recover(hash, v, r, s);\n\t}\n\n\t/**\n\t * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.\n\t */\n\tfunction recover(\n\t\tbytes32 hash,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) internal pure returns (address) {\n\t\t// EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n\t\t// unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n\t\t// the valid range for s in (281): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (282): v \u2208 {27, 28}. Most\n\t\t// signatures from current libraries generate a unique signature with an s-value in the lower half order.\n\t\t//\n\t\t// If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n\t\t// with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n\t\t// vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n\t\t// these malleable signatures as well.\n\t\trequire(\n\t\t\tuint256(s) <=\n\t\t\t\t0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,\n\t\t\t\"ECDSA: invalid signature 's' value\"\n\t\t);\n\t\trequire(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");\n\n\t\t// If the signature is valid (and not malleable), return the signer address\n\t\taddress signer = ecrecover(hash, v, r, s);\n\t\trequire(signer != address(0), \"ECDSA: invalid signature\");\n\n\t\treturn signer;\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n\t * produces hash corresponding to the one signed with the\n\t * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n\t * JSON-RPC method as part of EIP-191.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toEthSignedMessageHash(bytes32 hash)\n\t\tinternal\n\t\tpure\n\t\treturns (bytes32)\n\t{\n\t\t// 32 is the length in bytes of hash,\n\t\t// enforced by the type signature above\n\t\treturn\n\t\t\tkeccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n\t}\n\n\t/**\n\t * @dev Returns an Ethereum Signed Typed Data, created from a\n\t * `domainSeparator` and a `structHash`. This produces hash corresponding\n\t * to the one signed with the\n\t * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n\t * JSON-RPC method as part of EIP-712.\n\t *\n\t * See {recover}.\n\t */\n\tfunction toTypedDataHash(bytes32 domainSeparator, bytes32 structHash)\n\t\tinternal\n\t\tpure\n\t\treturns (bytes32)\n\t{\n\t\treturn keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n\t}\n}\n\n// File @openzeppelin/contracts/utils/cryptography/draft-EIP712.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n\t/* solhint-disable var-name-mixedcase */\n\t// Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n\t// invalidate the cached domain separator if the chain id changes.\n\tbytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n\tuint256 private immutable _CACHED_CHAIN_ID;\n\n\tbytes32 private immutable _HASHED_NAME;\n\tbytes32 private immutable _HASHED_VERSION;\n\tbytes32 private immutable _TYPE_HASH;\n\n\t/* solhint-enable var-name-mixedcase */\n\n\t/**\n\t * @dev Initializes the domain separator and parameter caches.\n\t *\n\t * The meaning of `name` and `version` is specified in\n\t * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n\t *\n\t * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n\t * - `version`: the current major version of the signing domain.\n\t *\n\t * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n\t * contract upgrade].\n\t */\n\tconstructor(string memory name, string memory version) {\n\t\tbytes32 hashedName = keccak256(bytes(name));\n\t\tbytes32 hashedVersion = keccak256(bytes(version));\n\t\tbytes32 typeHash = keccak256(\n\t\t\t\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n\t\t);\n\t\t_HASHED_NAME = hashedName;\n\t\t_HASHED_VERSION = hashedVersion;\n\t\t_CACHED_CHAIN_ID = block.chainid;\n\t\t_CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(\n\t\t\ttypeHash,\n\t\t\thashedName,\n\t\t\thashedVersion\n\t\t);\n\t\t_TYPE_HASH = typeHash;\n\t}\n\n\t/**\n\t * @dev Returns the domain separator for the current chain.\n\t */\n\tfunction _domainSeparatorV4() internal view returns (bytes32) {\n\t\tif (block.chainid == _CACHED_CHAIN_ID) {\n\t\t\treturn _CACHED_DOMAIN_SEPARATOR;\n\t\t} else {\n\t\t\treturn _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n\t\t}\n\t}\n\n\tfunction _buildDomainSeparator(\n\t\tbytes32 typeHash,\n\t\tbytes32 nameHash,\n\t\tbytes32 versionHash\n\t) private view returns (bytes32) {\n\t\treturn\n\t\t\tkeccak256(\n\t\t\t\tabi.encode(\n\t\t\t\t\ttypeHash,\n\t\t\t\t\tnameHash,\n\t\t\t\t\tversionHash,\n\t\t\t\t\tblock.chainid,\n\t\t\t\t\taddress(this)\n\t\t\t\t)\n\t\t\t);\n\t}\n\n\t/**\n\t * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n\t * function returns the hash of the fully encoded EIP712 message for this domain.\n\t *\n\t * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n\t *\n\t * ```solidity\n\t * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n\t *     keccak256(\"Mail(address to,string contents)\"),\n\t *     mailTo,\n\t *     keccak256(bytes(mailContents))\n\t * )));\n\t * address signer = ECDSA.recover(digest, signature);\n\t * ```\n\t */\n\tfunction _hashTypedDataV4(bytes32 structHash)\n\t\tinternal\n\t\tview\n\t\tvirtual\n\t\treturns (bytes32)\n\t{\n\t\treturn ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n\t}\n}\n\n// File @openzeppelin/contracts/utils/Counters.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n\tstruct Counter {\n\t\t// This variable should never be directly accessed by users of the library: interactions must be restricted to\n\t\t// the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n\t\t// this feature: see https://github.com/ethereum/solidity/issues/4637\n\t\tuint256 _value; // default: 0\n\t}\n\n\tfunction current(Counter storage counter) internal view returns (uint256) {\n\t\treturn counter._value;\n\t}\n\n\tfunction increment(Counter storage counter) internal {\n\t\tunchecked {\n\t\t\tcounter._value += 1;\n\t\t}\n\t}\n\n\tfunction decrement(Counter storage counter) internal {\n\t\tuint256 value = counter._value;\n\t\trequire(value > 0, \"Counter: decrement overflow\");\n\t\tunchecked {\n\t\t\tcounter._value = value - 1;\n\t\t}\n\t}\n\n\tfunction reset(Counter storage counter) internal {\n\t\tcounter._value = 0;\n\t}\n}\n\n// File @openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n\tusing Counters for Counters.Counter;\n\n\tmapping(address => Counters.Counter) private _nonces;\n\n\t// solhint-disable-next-line var-name-mixedcase\n\tbytes32 private immutable _PERMIT_TYPEHASH =\n\t\tkeccak256(\n\t\t\t\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"\n\t\t);\n\n\t/**\n\t * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n\t *\n\t * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n\t */\n\tconstructor(string memory name) EIP712(name, \"1\") {}\n\n\t/**\n\t * @dev See {IERC20Permit-permit}.\n\t */\n\tfunction permit(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value,\n\t\tuint256 deadline,\n\t\tuint8 v,\n\t\tbytes32 r,\n\t\tbytes32 s\n\t) public virtual override {\n\t\trequire(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n\t\tbytes32 structHash = keccak256(\n\t\t\tabi.encode(\n\t\t\t\t_PERMIT_TYPEHASH,\n\t\t\t\towner,\n\t\t\t\tspender,\n\t\t\t\tvalue,\n\t\t\t\t_useNonce(owner),\n\t\t\t\tdeadline\n\t\t\t)\n\t\t);\n\n\t\tbytes32 hash = _hashTypedDataV4(structHash);\n\n\t\taddress signer = ECDSA.recover(hash, v, r, s);\n\t\trequire(signer == owner, \"ERC20Permit: invalid signature\");\n\n\t\t_approve(owner, spender, value);\n\t}\n\n\t/**\n\t * @dev See {IERC20Permit-nonces}.\n\t */\n\tfunction nonces(address owner)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _nonces[owner].current();\n\t}\n\n\t/**\n\t * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n\t */\n\t// solhint-disable-next-line func-name-mixedcase\n\tfunction DOMAIN_SEPARATOR() external view override returns (bytes32) {\n\t\treturn _domainSeparatorV4();\n\t}\n\n\t/**\n\t * @dev \"Consume a nonce\": return the current value and increment.\n\t *\n\t * _Available since v4.1._\n\t */\n\tfunction _useNonce(address owner) internal virtual returns (uint256 current) {\n\t\tCounters.Counter storage nonce = _nonces[owner];\n\t\tcurrent = nonce.current();\n\t\tnonce.increment();\n\t}\n}\n\n// File @openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n\t/**\n\t * @dev Destroys `amount` tokens from the caller.\n\t *\n\t * See {ERC20-_burn}.\n\t */\n\tfunction burn(uint256 amount) public virtual {\n\t\t_burn(_msgSender(), amount);\n\t}\n\n\t/**\n\t * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n\t * allowance.\n\t *\n\t * See {ERC20-_burn} and {ERC20-allowance}.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have allowance for ``accounts``'s tokens of at least\n\t * `amount`.\n\t */\n\tfunction burnFrom(address account, uint256 amount) public virtual {\n\t\tuint256 currentAllowance = allowance(account, _msgSender());\n\t\trequire(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");\n\t\tunchecked {\n\t\t\t_approve(account, _msgSender(), currentAllowance - amount);\n\t\t}\n\t\t_burn(account, amount);\n\t}\n}\n\n// File @openzeppelin/contracts/utils/Strings.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n\tbytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n\t/**\n\t * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n\t */\n\tfunction toString(uint256 value) internal pure returns (string memory) {\n\t\t// Inspired by OraclizeAPI's implementation - MIT licence\n\t\t// https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n\t\tif (value == 0) {\n\t\t\treturn \"0\";\n\t\t}\n\t\tuint256 temp = value;\n\t\tuint256 digits;\n\t\twhile (temp != 0) {\n\t\t\tdigits++;\n\t\t\ttemp /= 10;\n\t\t}\n\t\tbytes memory buffer = new bytes(digits);\n\t\twhile (value != 0) {\n\t\t\tdigits -= 1;\n\t\t\tbuffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n\t\t\tvalue /= 10;\n\t\t}\n\t\treturn string(buffer);\n\t}\n\n\t/**\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n\t */\n\tfunction toHexString(uint256 value) internal pure returns (string memory) {\n\t\tif (value == 0) {\n\t\t\treturn \"0x00\";\n\t\t}\n\t\tuint256 temp = value;\n\t\tuint256 length = 0;\n\t\twhile (temp != 0) {\n\t\t\tlength++;\n\t\t\ttemp >>= 8;\n\t\t}\n\t\treturn toHexString(value, length);\n\t}\n\n\t/**\n\t * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n\t */\n\tfunction toHexString(uint256 value, uint256 length)\n\t\tinternal\n\t\tpure\n\t\treturns (string memory)\n\t{\n\t\tbytes memory buffer = new bytes(2 * length + 2);\n\t\tbuffer[0] = \"0\";\n\t\tbuffer[1] = \"x\";\n\t\tfor (uint256 i = 2 * length + 1; i > 1; --i) {\n\t\t\tbuffer[i] = _HEX_SYMBOLS[value & 0xf];\n\t\t\tvalue >>= 4;\n\t\t}\n\t\trequire(value == 0, \"Strings: hex length insufficient\");\n\t\treturn string(buffer);\n\t}\n}\n\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n\t/**\n\t * @dev Returns true if this contract implements the interface defined by\n\t * `interfaceId`. See the corresponding\n\t * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n\t * to learn more about how these ids are created.\n\t *\n\t * This function call must use less than 30 000 gas.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n\t/**\n\t * @dev See {IERC165-supportsInterface}.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn interfaceId == type(IERC165).interfaceId;\n\t}\n}\n\n// File @openzeppelin/contracts/access/AccessControl.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n\tfunction hasRole(bytes32 role, address account) external view returns (bool);\n\n\tfunction getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n\tfunction grantRole(bytes32 role, address account) external;\n\n\tfunction revokeRole(bytes32 role, address account) external;\n\n\tfunction renounceRole(bytes32 role, address account) external;\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n\tstruct RoleData {\n\t\tmapping(address => bool) members;\n\t\tbytes32 adminRole;\n\t}\n\n\tmapping(bytes32 => RoleData) private _roles;\n\n\tbytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n\t/**\n\t * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n\t *\n\t * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n\t * {RoleAdminChanged} not being emitted signaling this.\n\t *\n\t * _Available since v3.1._\n\t */\n\tevent RoleAdminChanged(\n\t\tbytes32 indexed role,\n\t\tbytes32 indexed previousAdminRole,\n\t\tbytes32 indexed newAdminRole\n\t);\n\n\t/**\n\t * @dev Emitted when `account` is granted `role`.\n\t *\n\t * `sender` is the account that originated the contract call, an admin role\n\t * bearer except when using {_setupRole}.\n\t */\n\tevent RoleGranted(\n\t\tbytes32 indexed role,\n\t\taddress indexed account,\n\t\taddress indexed sender\n\t);\n\n\t/**\n\t * @dev Emitted when `account` is revoked `role`.\n\t *\n\t * `sender` is the account that originated the contract call:\n\t *   - if using `revokeRole`, it is the admin role bearer\n\t *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n\t */\n\tevent RoleRevoked(\n\t\tbytes32 indexed role,\n\t\taddress indexed account,\n\t\taddress indexed sender\n\t);\n\n\t/**\n\t * @dev Modifier that checks that an account has a specific role. Reverts\n\t * with a standardized message including the required role.\n\t *\n\t * The format of the revert reason is given by the following regular expression:\n\t *\n\t *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n\t *\n\t * _Available since v4.1._\n\t */\n\tmodifier onlyRole(bytes32 role) {\n\t\t_checkRole(role, _msgSender());\n\t\t_;\n\t}\n\n\t/**\n\t * @dev See {IERC165-supportsInterface}.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn\n\t\t\tinterfaceId == type(IAccessControl).interfaceId ||\n\t\t\tsuper.supportsInterface(interfaceId);\n\t}\n\n\t/**\n\t * @dev Returns `true` if `account` has been granted `role`.\n\t */\n\tfunction hasRole(bytes32 role, address account)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn _roles[role].members[account];\n\t}\n\n\t/**\n\t * @dev Revert with a standard message if `account` is missing `role`.\n\t *\n\t * The format of the revert reason is given by the following regular expression:\n\t *\n\t *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/\n\t */\n\tfunction _checkRole(bytes32 role, address account) internal view {\n\t\tif (!hasRole(role, account)) {\n\t\t\trevert(\n\t\t\t\tstring(\n\t\t\t\t\tabi.encodePacked(\n\t\t\t\t\t\t\"AccessControl: account \",\n\t\t\t\t\t\tStrings.toHexString(uint160(account), 20),\n\t\t\t\t\t\t\" is missing role \",\n\t\t\t\t\t\tStrings.toHexString(uint256(role), 32)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns the admin role that controls `role`. See {grantRole} and\n\t * {revokeRole}.\n\t *\n\t * To change a role's admin, use {_setRoleAdmin}.\n\t */\n\tfunction getRoleAdmin(bytes32 role) public view override returns (bytes32) {\n\t\treturn _roles[role].adminRole;\n\t}\n\n\t/**\n\t * @dev Grants `role` to `account`.\n\t *\n\t * If `account` had not been already granted `role`, emits a {RoleGranted}\n\t * event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have ``role``'s admin role.\n\t */\n\tfunction grantRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(getRoleAdmin(role))\n\t{\n\t\t_grantRole(role, account);\n\t}\n\n\t/**\n\t * @dev Revokes `role` from `account`.\n\t *\n\t * If `account` had been granted `role`, emits a {RoleRevoked} event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must have ``role``'s admin role.\n\t */\n\tfunction revokeRole(bytes32 role, address account)\n\t\tpublic\n\t\tvirtual\n\t\toverride\n\t\tonlyRole(getRoleAdmin(role))\n\t{\n\t\t_revokeRole(role, account);\n\t}\n\n\t/**\n\t * @dev Revokes `role` from the calling account.\n\t *\n\t * Roles are often managed via {grantRole} and {revokeRole}: this function's\n\t * purpose is to provide a mechanism for accounts to lose their privileges\n\t * if they are compromised (such as when a trusted device is misplaced).\n\t *\n\t * If the calling account had been granted `role`, emits a {RoleRevoked}\n\t * event.\n\t *\n\t * Requirements:\n\t *\n\t * - the caller must be `account`.\n\t */\n\tfunction renounceRole(bytes32 role, address account) public virtual override {\n\t\trequire(\n\t\t\taccount == _msgSender(),\n\t\t\t\"AccessControl: can only renounce roles for self\"\n\t\t);\n\n\t\t_revokeRole(role, account);\n\t}\n\n\t/**\n\t * @dev Grants `role` to `account`.\n\t *\n\t * If `account` had not been already granted `role`, emits a {RoleGranted}\n\t * event. Note that unlike {grantRole}, this function doesn't perform any\n\t * checks on the calling account.\n\t *\n\t * [WARNING]\n\t * ====\n\t * This function should only be called from the constructor when setting\n\t * up the initial roles for the system.\n\t *\n\t * Using this function in any other way is effectively circumventing the admin\n\t * system imposed by {AccessControl}.\n\t * ====\n\t */\n\tfunction _setupRole(bytes32 role, address account) internal virtual {\n\t\t_grantRole(role, account);\n\t}\n\n\t/**\n\t * @dev Sets `adminRole` as ``role``'s admin role.\n\t *\n\t * Emits a {RoleAdminChanged} event.\n\t */\n\tfunction _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n\t\temit RoleAdminChanged(role, getRoleAdmin(role), adminRole);\n\t\t_roles[role].adminRole = adminRole;\n\t}\n\n\tfunction _grantRole(bytes32 role, address account) private {\n\t\tif (!hasRole(role, account)) {\n\t\t\t_roles[role].members[account] = true;\n\t\t\temit RoleGranted(role, account, _msgSender());\n\t\t}\n\t}\n\n\tfunction _revokeRole(bytes32 role, address account) private {\n\t\tif (hasRole(role, account)) {\n\t\t\t_roles[role].members[account] = false;\n\t\t\temit RoleRevoked(role, account, _msgSender());\n\t\t}\n\t}\n}\n\n// File @openzeppelin/contracts/utils/structs/EnumerableSet.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n\t// To implement this library for multiple types with as little code\n\t// repetition as possible, we write it in terms of a generic Set type with\n\t// bytes32 values.\n\t// The Set implementation uses private functions, and user-facing\n\t// implementations (such as AddressSet) are just wrappers around the\n\t// underlying Set.\n\t// This means that we can only create new EnumerableSets for types that fit\n\t// in bytes32.\n\n\tstruct Set {\n\t\t// Storage of set values\n\t\tbytes32[] _values;\n\t\t// Position of the value in the `values` array, plus 1 because index 0\n\t\t// means a value is not in the set.\n\t\tmapping(bytes32 => uint256) _indexes;\n\t}\n\n\t/**\n\t * @dev Add a value to a set. O(1).\n\t *\n\t * Returns true if the value was added to the set, that is if it was not\n\t * already present.\n\t */\n\tfunction _add(Set storage set, bytes32 value) private returns (bool) {\n\t\tif (!_contains(set, value)) {\n\t\t\tset._values.push(value);\n\t\t\t// The value is stored at length-1, but we add 1 to all indexes\n\t\t\t// and use 0 as a sentinel value\n\t\t\tset._indexes[value] = set._values.length;\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the value was removed from the set, that is if it was\n\t * present.\n\t */\n\tfunction _remove(Set storage set, bytes32 value) private returns (bool) {\n\t\t// We read and store the value's index to prevent multiple reads from the same storage slot\n\t\tuint256 valueIndex = set._indexes[value];\n\n\t\tif (valueIndex != 0) {\n\t\t\t// Equivalent to contains(set, value)\n\t\t\t// To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n\t\t\t// the array, and then remove the last element (sometimes called as 'swap and pop').\n\t\t\t// This modifies the order of the array, as noted in {at}.\n\n\t\t\tuint256 toDeleteIndex = valueIndex - 1;\n\t\t\tuint256 lastIndex = set._values.length - 1;\n\n\t\t\tif (lastIndex != toDeleteIndex) {\n\t\t\t\tbytes32 lastvalue = set._values[lastIndex];\n\n\t\t\t\t// Move the last value to the index where the value to delete is\n\t\t\t\tset._values[toDeleteIndex] = lastvalue;\n\t\t\t\t// Update the index for the moved value\n\t\t\t\tset._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n\t\t\t}\n\n\t\t\t// Delete the slot where the moved value was stored\n\t\t\tset._values.pop();\n\n\t\t\t// Delete the index for the deleted slot\n\t\t\tdelete set._indexes[value];\n\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Returns true if the value is in the set. O(1).\n\t */\n\tfunction _contains(Set storage set, bytes32 value)\n\t\tprivate\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn set._indexes[value] != 0;\n\t}\n\n\t/**\n\t * @dev Returns the number of values on the set. O(1).\n\t */\n\tfunction _length(Set storage set) private view returns (uint256) {\n\t\treturn set._values.length;\n\t}\n\n\t/**\n\t * @dev Returns the value stored at position `index` in the set. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction _at(Set storage set, uint256 index) private view returns (bytes32) {\n\t\treturn set._values[index];\n\t}\n\n\t// Bytes32Set\n\n\tstruct Bytes32Set {\n\t\tSet _inner;\n\t}\n\n\t/**\n\t * @dev Add a value to a set. O(1).\n\t *\n\t * Returns true if the value was added to the set, that is if it was not\n\t * already present.\n\t */\n\tfunction add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n\t\treturn _add(set._inner, value);\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the value was removed from the set, that is if it was\n\t * present.\n\t */\n\tfunction remove(Bytes32Set storage set, bytes32 value)\n\t\tinternal\n\t\treturns (bool)\n\t{\n\t\treturn _remove(set._inner, value);\n\t}\n\n\t/**\n\t * @dev Returns true if the value is in the set. O(1).\n\t */\n\tfunction contains(Bytes32Set storage set, bytes32 value)\n\t\tinternal\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn _contains(set._inner, value);\n\t}\n\n\t/**\n\t * @dev Returns the number of values in the set. O(1).\n\t */\n\tfunction length(Bytes32Set storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\t/**\n\t * @dev Returns the value stored at position `index` in the set. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction at(Bytes32Set storage set, uint256 index)\n\t\tinternal\n\t\tview\n\t\treturns (bytes32)\n\t{\n\t\treturn _at(set._inner, index);\n\t}\n\n\t// AddressSet\n\n\tstruct AddressSet {\n\t\tSet _inner;\n\t}\n\n\t/**\n\t * @dev Add a value to a set. O(1).\n\t *\n\t * Returns true if the value was added to the set, that is if it was not\n\t * already present.\n\t */\n\tfunction add(AddressSet storage set, address value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the value was removed from the set, that is if it was\n\t * present.\n\t */\n\tfunction remove(AddressSet storage set, address value)\n\t\tinternal\n\t\treturns (bool)\n\t{\n\t\treturn _remove(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\t/**\n\t * @dev Returns true if the value is in the set. O(1).\n\t */\n\tfunction contains(AddressSet storage set, address value)\n\t\tinternal\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn _contains(set._inner, bytes32(uint256(uint160(value))));\n\t}\n\n\t/**\n\t * @dev Returns the number of values in the set. O(1).\n\t */\n\tfunction length(AddressSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\t/**\n\t * @dev Returns the value stored at position `index` in the set. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction at(AddressSet storage set, uint256 index)\n\t\tinternal\n\t\tview\n\t\treturns (address)\n\t{\n\t\treturn address(uint160(uint256(_at(set._inner, index))));\n\t}\n\n\t// UintSet\n\n\tstruct UintSet {\n\t\tSet _inner;\n\t}\n\n\t/**\n\t * @dev Add a value to a set. O(1).\n\t *\n\t * Returns true if the value was added to the set, that is if it was not\n\t * already present.\n\t */\n\tfunction add(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _add(set._inner, bytes32(value));\n\t}\n\n\t/**\n\t * @dev Removes a value from a set. O(1).\n\t *\n\t * Returns true if the value was removed from the set, that is if it was\n\t * present.\n\t */\n\tfunction remove(UintSet storage set, uint256 value) internal returns (bool) {\n\t\treturn _remove(set._inner, bytes32(value));\n\t}\n\n\t/**\n\t * @dev Returns true if the value is in the set. O(1).\n\t */\n\tfunction contains(UintSet storage set, uint256 value)\n\t\tinternal\n\t\tview\n\t\treturns (bool)\n\t{\n\t\treturn _contains(set._inner, bytes32(value));\n\t}\n\n\t/**\n\t * @dev Returns the number of values on the set. O(1).\n\t */\n\tfunction length(UintSet storage set) internal view returns (uint256) {\n\t\treturn _length(set._inner);\n\t}\n\n\t/**\n\t * @dev Returns the value stored at position `index` in the set. O(1).\n\t *\n\t * Note that there are no guarantees on the ordering of values inside the\n\t * array, and it may change when more values are added or removed.\n\t *\n\t * Requirements:\n\t *\n\t * - `index` must be strictly less than {length}.\n\t */\n\tfunction at(UintSet storage set, uint256 index)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\treturn uint256(_at(set._inner, index));\n\t}\n}\n\n// File @openzeppelin/contracts/access/AccessControlEnumerable.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.\n */\ninterface IAccessControlEnumerable {\n\tfunction getRoleMember(bytes32 role, uint256 index)\n\t\texternal\n\t\tview\n\t\treturns (address);\n\n\tfunction getRoleMemberCount(bytes32 role) external view returns (uint256);\n}\n\n/**\n * @dev Extension of {AccessControl} that allows enumerating the members of each role.\n */\nabstract contract AccessControlEnumerable is\n\tIAccessControlEnumerable,\n\tAccessControl\n{\n\tusing EnumerableSet for EnumerableSet.AddressSet;\n\n\tmapping(bytes32 => EnumerableSet.AddressSet) private _roleMembers;\n\n\t/**\n\t * @dev See {IERC165-supportsInterface}.\n\t */\n\tfunction supportsInterface(bytes4 interfaceId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\toverride\n\t\treturns (bool)\n\t{\n\t\treturn\n\t\t\tinterfaceId == type(IAccessControlEnumerable).interfaceId ||\n\t\t\tsuper.supportsInterface(interfaceId);\n\t}\n\n\t/**\n\t * @dev Returns one of the accounts that have `role`. `index` must be a\n\t * value between 0 and {getRoleMemberCount}, non-inclusive.\n\t *\n\t * Role bearers are not sorted in any particular way, and their ordering may\n\t * change at any point.\n\t *\n\t * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\n\t * you perform all queries on the same block. See the following\n\t * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\n\t * for more information.\n\t */\n\tfunction getRoleMember(bytes32 role, uint256 index)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (address)\n\t{\n\t\treturn _roleMembers[role].at(index);\n\t}\n\n\t/**\n\t * @dev Returns the number of accounts that have `role`. Can be used\n\t * together with {getRoleMember} to enumerate all bearers of a role.\n\t */\n\tfunction getRoleMemberCount(bytes32 role)\n\t\tpublic\n\t\tview\n\t\toverride\n\t\treturns (uint256)\n\t{\n\t\treturn _roleMembers[role].length();\n\t}\n\n\t/**\n\t * @dev Overload {grantRole} to track enumerable memberships\n\t */\n\tfunction grantRole(bytes32 role, address account) public virtual override {\n\t\tsuper.grantRole(role, account);\n\t\t_roleMembers[role].add(account);\n\t}\n\n\t/**\n\t * @dev Overload {revokeRole} to track enumerable memberships\n\t */\n\tfunction revokeRole(bytes32 role, address account) public virtual override {\n\t\tsuper.revokeRole(role, account);\n\t\t_roleMembers[role].remove(account);\n\t}\n\n\t/**\n\t * @dev Overload {renounceRole} to track enumerable memberships\n\t */\n\tfunction renounceRole(bytes32 role, address account) public virtual override {\n\t\tsuper.renounceRole(role, account);\n\t\t_roleMembers[role].remove(account);\n\t}\n\n\t/**\n\t * @dev Overload {_setupRole} to track enumerable memberships\n\t */\n\tfunction _setupRole(bytes32 role, address account) internal virtual override {\n\t\tsuper._setupRole(role, account);\n\t\t_roleMembers[role].add(account);\n\t}\n}\n\n// File @openzeppelin/contracts/utils/math/Math.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n\t/**\n\t * @dev Returns the largest of two numbers.\n\t */\n\tfunction max(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a >= b ? a : b;\n\t}\n\n\t/**\n\t * @dev Returns the smallest of two numbers.\n\t */\n\tfunction min(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\treturn a < b ? a : b;\n\t}\n\n\t/**\n\t * @dev Returns the average of two numbers. The result is rounded towards\n\t * zero.\n\t */\n\tfunction average(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// (a + b) / 2 can overflow, so we distribute.\n\t\treturn (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2);\n\t}\n\n\t/**\n\t * @dev Returns the ceiling of the division of two numbers.\n\t *\n\t * This differs from standard division with `/` in that it rounds up instead\n\t * of rounding down.\n\t */\n\tfunction ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n\t\t// (a + b - 1) / b can overflow on addition, so we distribute.\n\t\treturn a / b + (a % b == 0 ? 0 : 1);\n\t}\n}\n\n// File @openzeppelin/contracts/utils/Arrays.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to array types.\n */\nlibrary Arrays {\n\t/**\n\t * @dev Searches a sorted `array` and returns the first index that contains\n\t * a value greater or equal to `element`. If no such index exists (i.e. all\n\t * values in the array are strictly less than `element`), the array length is\n\t * returned. Time complexity O(log n).\n\t *\n\t * `array` is expected to be sorted in ascending order, and to contain no\n\t * repeated elements.\n\t */\n\tfunction findUpperBound(uint256[] storage array, uint256 element)\n\t\tinternal\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tif (array.length == 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tuint256 low = 0;\n\t\tuint256 high = array.length;\n\n\t\twhile (low < high) {\n\t\t\tuint256 mid = Math.average(low, high);\n\n\t\t\t// Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n\t\t\t// because Math.average rounds down (it does integer division with truncation).\n\t\t\tif (array[mid] > element) {\n\t\t\t\thigh = mid;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\t// At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n\t\tif (low > 0 && array[low - 1] == element) {\n\t\t\treturn low - 1;\n\t\t} else {\n\t\t\treturn low;\n\t\t}\n\t}\n}\n\n// File @openzeppelin/contracts/token/ERC20/extensions/ERC20Snapshot.sol@v4.2.0\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This contract extends an ERC20 token with a snapshot mechanism. When a snapshot is created, the balances and\n * total supply at the time are recorded for later access.\n *\n * This can be used to safely create mechanisms based on token balances such as trustless dividends or weighted voting.\n * In naive implementations it's possible to perform a \"double spend\" attack by reusing the same balance from different\n * accounts. By using snapshots to calculate dividends or voting power, those attacks no longer apply. It can also be\n * used to create an efficient ERC20 forking mechanism.\n *\n * Snapshots are created by the internal {_snapshot} function, which will emit the {Snapshot} event and return a\n * snapshot id. To get the total supply at the time of a snapshot, call the function {totalSupplyAt} with the snapshot\n * id. To get the balance of an account at the time of a snapshot, call the {balanceOfAt} function with the snapshot id\n * and the account address.\n *\n * NOTE: Snapshot policy can be customized by overriding the {_getCurrentSnapshotId} method. For example, having it\n * return `block.number` will trigger the creation of snapshot at the begining of each new block. When overridding this\n * function, be careful about the monotonicity of its result. Non-monotonic snapshot ids will break the contract.\n *\n * Implementing snapshots for every block using this method will incur significant gas costs. For a gas-efficient\n * alternative consider {ERC20Votes}.\n *\n * ==== Gas Costs\n *\n * Snapshots are efficient. Snapshot creation is _O(1)_. Retrieval of balances or total supply from a snapshot is _O(log\n * n)_ in the number of snapshots that have been created, although _n_ for a specific account will generally be much\n * smaller since identical balances in subsequent snapshots are stored as a single entry.\n *\n * There is a constant overhead for normal ERC20 transfers due to the additional snapshot bookkeeping. This overhead is\n * only significant for the first transfer that immediately follows a snapshot for a particular account. Subsequent\n * transfers will have normal cost until the next snapshot, and so on.\n */\n\nabstract contract ERC20Snapshot is ERC20 {\n\t// Inspired by Jordi Baylina's MiniMeToken to record historical balances:\n\t// https://github.com/Giveth/minimd/blob/ea04d950eea153a04c51fa510b068b9dded390cb/contracts/MiniMeToken.sol\n\n\tusing Arrays for uint256[];\n\tusing Counters for Counters.Counter;\n\n\t// Snapshotted values have arrays of ids and the value corresponding to that id. These could be an array of a\n\t// Snapshot struct, but that would impede usage of functions that work on an array.\n\tstruct Snapshots {\n\t\tuint256[] ids;\n\t\tuint256[] values;\n\t}\n\n\tmapping(address => Snapshots) private _accountBalanceSnapshots;\n\tSnapshots private _totalSupplySnapshots;\n\n\t// Snapshot ids increase monotonically, with the first value being 1. An id of 0 is invalid.\n\tCounters.Counter private _currentSnapshotId;\n\n\t/**\n\t * @dev Emitted by {_snapshot} when a snapshot identified by `id` is created.\n\t */\n\tevent Snapshot(uint256 id);\n\n\t/**\n\t * @dev Creates a new snapshot and returns its snapshot id.\n\t *\n\t * Emits a {Snapshot} event that contains the same id.\n\t *\n\t * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n\t * set of accounts, for example using {AccessControl}, or it may be open to the public.\n\t *\n\t * [WARNING]\n\t * ====\n\t * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n\t * you must consider that it can potentially be used by attackers in two ways.\n\t *\n\t * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n\t * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n\t * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n\t * section above.\n\t *\n\t * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n\t * ====\n\t */\n\tfunction _snapshot() internal virtual returns (uint256) {\n\t\t_currentSnapshotId.increment();\n\n\t\tuint256 currentId = _getCurrentSnapshotId();\n\t\temit Snapshot(currentId);\n\t\treturn currentId;\n\t}\n\n\t/**\n\t * @dev Get the current snapshotId\n\t */\n\tfunction _getCurrentSnapshotId() internal view virtual returns (uint256) {\n\t\treturn _currentSnapshotId.current();\n\t}\n\n\t/**\n\t * @dev Retrieves the balance of `account` at the time `snapshotId` was created.\n\t */\n\tfunction balanceOfAt(address account, uint256 snapshotId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\t(bool snapshotted, uint256 value) = _valueAt(\n\t\t\tsnapshotId,\n\t\t\t_accountBalanceSnapshots[account]\n\t\t);\n\n\t\treturn snapshotted ? value : balanceOf(account);\n\t}\n\n\t/**\n\t * @dev Retrieves the total supply at the time `snapshotId` was created.\n\t */\n\tfunction totalSupplyAt(uint256 snapshotId)\n\t\tpublic\n\t\tview\n\t\tvirtual\n\t\treturns (uint256)\n\t{\n\t\t(bool snapshotted, uint256 value) = _valueAt(\n\t\t\tsnapshotId,\n\t\t\t_totalSupplySnapshots\n\t\t);\n\n\t\treturn snapshotted ? value : totalSupply();\n\t}\n\n\t// Update balance and/or total supply snapshots before the values are modified. This is implemented\n\t// in the _beforeTokenTransfer hook, which is executed for _mint, _burn, and _transfer operations.\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual override {\n\t\tsuper._beforeTokenTransfer(from, to, amount);\n\n\t\tif (from == address(0)) {\n\t\t\t// mint\n\t\t\t_updateAccountSnapshot(to);\n\t\t\t_updateTotalSupplySnapshot();\n\t\t} else if (to == address(0)) {\n\t\t\t// burn\n\t\t\t_updateAccountSnapshot(from);\n\t\t\t_updateTotalSupplySnapshot();\n\t\t} else {\n\t\t\t// transfer\n\t\t\t_updateAccountSnapshot(from);\n\t\t\t_updateAccountSnapshot(to);\n\t\t}\n\t}\n\n\tfunction _valueAt(uint256 snapshotId, Snapshots storage snapshots)\n\t\tprivate\n\t\tview\n\t\treturns (bool, uint256)\n\t{\n\t\trequire(snapshotId > 0, \"ERC20Snapshot: id is 0\");\n\t\trequire(\n\t\t\tsnapshotId <= _getCurrentSnapshotId(),\n\t\t\t\"ERC20Snapshot: nonexistent id\"\n\t\t);\n\n\t\t// When a valid snapshot is queried, there are three possibilities:\n\t\t//  a) The queried value was not modified after the snapshot was taken. Therefore, a snapshot entry was never\n\t\t//  created for this id, and all stored snapshot ids are smaller than the requested one. The value that corresponds\n\t\t//  to this id is the current one.\n\t\t//  b) The queried value was modified after the snapshot was taken. Therefore, there will be an entry with the\n\t\t//  requested id, and its value is the one to return.\n\t\t//  c) More snapshots were created after the requested one, and the queried value was later modified. There will be\n\t\t//  no entry for the requested id: the value that corresponds to it is that of the smallest snapshot id that is\n\t\t//  larger than the requested one.\n\t\t//\n\t\t// In summary, we need to find an element in an array, returning the index of the smallest value that is larger if\n\t\t// it is not found, unless said value doesn't exist (e.g. when all values are smaller). Arrays.findUpperBound does\n\t\t// exactly this.\n\n\t\tuint256 index = snapshots.ids.findUpperBound(snapshotId);\n\n\t\tif (index == snapshots.ids.length) {\n\t\t\treturn (false, 0);\n\t\t} else {\n\t\t\treturn (true, snapshots.values[index]);\n\t\t}\n\t}\n\n\tfunction _updateAccountSnapshot(address account) private {\n\t\t_updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));\n\t}\n\n\tfunction _updateTotalSupplySnapshot() private {\n\t\t_updateSnapshot(_totalSupplySnapshots, totalSupply());\n\t}\n\n\tfunction _updateSnapshot(Snapshots storage snapshots, uint256 currentValue)\n\t\tprivate\n\t{\n\t\tuint256 currentId = _getCurrentSnapshotId();\n\t\tif (_lastSnapshotId(snapshots.ids) < currentId) {\n\t\t\tsnapshots.ids.push(currentId);\n\t\t\tsnapshots.values.push(currentValue);\n\t\t}\n\t}\n\n\tfunction _lastSnapshotId(uint256[] storage ids)\n\t\tprivate\n\t\tview\n\t\treturns (uint256)\n\t{\n\t\tif (ids.length == 0) {\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn ids[ids.length - 1];\n\t\t}\n\t}\n}\n\n// File contracts/interfaces/IChildToken.sol\n\npragma solidity 0.8.4;\n\ninterface IChildToken is IERC20 {\n\t/**\n\t * @notice called when token is deposited on root chain\n\t * @dev Should be callable only by ChildChainManager\n\t * Should handle deposit by minting the required amount for user, not to create new tokens,\n\t * but to move tokens previously swapped to the root chain back to the child chain\n\t * @param user user address for whom deposit is being done\n\t * @param depositData abi encoded amount\n\t */\n\tfunction deposit(address user, bytes calldata depositData) external;\n}\n\n// File contracts/token/DailyCopTokenChild.sol\n\npragma solidity 0.8.4;\n\ncontract DailyCopTokenChild is\n\tAccessControlEnumerable,\n\tERC20Burnable,\n\tERC20Snapshot,\n\tERC20Permit,\n\tIChildToken\n{\n\tuint256 private _layer1Supply;\n\n\t// Roles\n\tbytes32 public constant MINTER_ROLE = keccak256(\"MINTER_ROLE\");\n\tbytes32 public constant DEPOSITOR_ROLE = keccak256(\"DEPOSITOR_ROLE\");\n\tbytes32 public constant SNAPSHOT_ROLE = keccak256(\"SNAPSHOT_ROLE\");\n\n\tmodifier notThisAddress(address account) {\n\t\trequire(\n\t\t\taccount != address(this),\n\t\t\t\"Address can not be the token contract's address\"\n\t\t);\n\t\t_;\n\t}\n\n\tconstructor(\n\t\taddress defaultAdmin,\n\t\taddress minter,\n\t\taddress childChainManager\n\t) ERC20(\"Daily COP\", \"DLYCOP\") ERC20Permit(\"DailyCopToken\") {\n\t\t_setupRole(DEFAULT_ADMIN_ROLE, defaultAdmin);\n\t\t_setupRole(MINTER_ROLE, minter);\n\n\t\t// Only the child chain manager knows when a token is deposited on the root chain\n\t\t_setupRole(DEPOSITOR_ROLE, childChainManager);\n\t}\n\n\t/** @dev Creates `amount` tokens and assigns them to `account`, increasing\n\t * the total supply.\n\t *\n\t * Emits a {Transfer} event with `from` set to the zero address.\n\t *\n\t * Requirements:\n\t *\n\t * - `account` cannot be the zero address.\n\t * - `msg.sender` should have the minter role (MINTER_ROLE).\n\t */\n\tfunction mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {\n\t\t_mint(to, amount);\n\t}\n\n\t/**\n\t * @dev See {IERC20-transfer}.\n\t *\n\t * Requirements:\n\t *\n\t * - `recipient` cannot be the zero address.\n\t * - the caller must have a balance of at least `amount`.\n\t */\n\tfunction transfer(address recipient, uint256 amount)\n\t\tpublic\n\t\tvirtual\n\t\toverride(ERC20, IERC20)\n\t\tnotThisAddress(recipient)\n\t\treturns (bool)\n\t{\n\t\treturn super.transfer(recipient, amount);\n\t}\n\n\t/**\n\t * @dev See {IERC20-transferFrom}.\n\t *\n\t * Emits an {Approval} event indicating the updated allowance. This is not\n\t * required by the EIP. See the note at the beginning of {ERC20}.\n\t *\n\t * Requirements:\n\t *\n\t * - `sender` and `recipient` cannot be the zero address.\n\t * - `sender` must have a balance of at least `amount`.\n\t * - the caller must have allowance for ``sender``'s tokens of at least\n\t * `amount`.\n\t */\n\tfunction transferFrom(\n\t\taddress sender,\n\t\taddress recipient,\n\t\tuint256 amount\n\t)\n\t\tpublic\n\t\tvirtual\n\t\toverride(ERC20, IERC20)\n\t\tnotThisAddress(recipient)\n\t\treturns (bool)\n\t{\n\t\treturn super.transferFrom(sender, recipient, amount);\n\t}\n\n\t/**\n\t * @dev Creates a new snapshot and returns its snapshot id.\n\t *\n\t * Emits a {Snapshot} event that contains the same id.\n\t *\n\t * {_snapshot} is `internal` and you have to decide how to expose it externally. Its usage may be restricted to a\n\t * set of accounts, for example using {AccessControl}, or it may be open to the public.\n\t *\n\t * [WARNING]\n\t * ====\n\t * While an open way of calling {_snapshot} is required for certain trust minimization mechanisms such as forking,\n\t * you must consider that it can potentially be used by attackers in two ways.\n\t *\n\t * First, it can be used to increase the cost of retrieval of values from snapshots, although it will grow\n\t * logarithmically thus rendering this attack ineffective in the long term. Second, it can be used to target\n\t * specific accounts and increase the cost of ERC20 transfers for them, in the ways specified in the Gas Costs\n\t * section above.\n\t *\n\t * We haven't measured the actual numbers; if this is something you're interested in please reach out to us.\n\t * ====\n\t */\n\tfunction snapshot() public onlyRole(SNAPSHOT_ROLE) {\n\t\t_snapshot();\n\t}\n\n\t/**\n\t * @notice called when token is deposited on root chain\n\t * @dev Should be callable only by ChildChainManager\n\t * Should handle deposit by minting the required amount for user, not to create new tokens,\n\t * but to move tokens previously swapped to the root chain back to the child chain\n\t * @param user user address for whom deposit is being done\n\t * @param depositData abi encoded amount\n\t */\n\tfunction deposit(address user, bytes calldata depositData)\n\t\texternal\n\t\toverride\n\t\tonlyRole(DEPOSITOR_ROLE)\n\t{\n\t\tuint256 amount = abi.decode(depositData, (uint256));\n\t\t// Keep track of token supply on layer 1 (root chain)\n\t\t_layer1Supply -= amount;\n\t\t_mint(user, amount);\n\t}\n\n\t/**\n\t * @notice called when user wants to withdraw tokens back to root chain\n\t * @dev Should burn user's tokens. This transaction will be verified when exiting on root chain\n\t * @param amount amount of tokens to withdraw\n\t */\n\tfunction withdraw(uint256 amount) external {\n\t\t// Keep track of token supply on layer 1 (root chain)\n\t\t_layer1Supply += amount;\n\t\t_burn(_msgSender(), amount);\n\t}\n\n\t/**\n\t * @notice called when admin wants to unlock erc20 tokens owned by the contract\n\t * @param _tokenAddress the address of the tokens to unlock\n\t * @param _to the address to send the tokens to\n\t * @param _amount amount of tokens to unlock\n\t */\n\tfunction transferAnyERC20(\n\t\taddress _tokenAddress,\n\t\taddress _to,\n\t\tuint256 _amount\n\t) public onlyRole(DEFAULT_ADMIN_ROLE) {\n\t\tIERC20(_tokenAddress).transfer(_to, _amount);\n\t}\n\n\t/**\n\t * @notice Obtain the supply of tokens that were moved to layer 1 (Ethereum) through the Polygon PoS bridge.\n\t */\n\tfunction layer1Supply() public view returns (uint256) {\n\t\treturn _layer1Supply;\n\t}\n\n\tfunction _beforeTokenTransfer(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 amount\n\t) internal virtual override(ERC20, ERC20Snapshot) {\n\t\tsuper._beforeTokenTransfer(from, to, amount);\n\t}\n}\n", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defaultAdmin\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"childChainManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Snapshot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEPOSITOR_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MINTER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SNAPSHOT_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"depositData\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getRoleMember\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleMemberCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"layer1Supply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"snapshotId\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DailyCopTokenChild", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "00000000000000000000000096c2770900f4d0dd76819eca77cb3b40e119bdce00000000000000000000000056edbf72e30032d071bd09166984ccc74780334e000000000000000000000000a6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}