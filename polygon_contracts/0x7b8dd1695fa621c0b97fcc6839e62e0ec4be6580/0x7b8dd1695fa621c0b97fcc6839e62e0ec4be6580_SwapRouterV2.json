{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/v1/libraries/FullMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n/// @title Contains 512-bit math functions\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\nlibrary FullMath {\\n    /// @notice Calculates floor(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n    function mulDiv(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        // 512-bit multiply [prod1 prod0] = a * b\\n        // Compute the product mod 2**256 and mod 2**256 - 1\\n        // then use the Chinese Remainder Theorem to reconstruct\\n        // the 512 bit result. The result is stored in two 256\\n        // variables such that product = prod1 * 2**256 + prod0\\n        uint256 prod0; // Least significant 256 bits of the product\\n        uint256 prod1; // Most significant 256 bits of the product\\n\\n        // todo unchecked\\n        unchecked {\\n            assembly {\\n                let mm := mulmod(a, b, not(0))\\n                prod0 := mul(a, b)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division\\n            if (prod1 == 0) {\\n                require(denominator > 0);\\n                assembly {\\n                    result := div(prod0, denominator)\\n                }\\n                return result;\\n            }\\n\\n            // Make sure the result is less than 2**256.\\n            // Also prevents denominator == 0\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0]\\n            // Compute remainder using mulmod\\n            uint256 remainder;\\n            assembly {\\n                remainder := mulmod(a, b, denominator)\\n            }\\n            // Subtract 256 bit number from 512 bit number\\n            assembly {\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator\\n            // Compute largest power of two divisor of denominator.\\n            // Always >= 1.\\n            uint256 twos = (~denominator + 1) & denominator;\\n            // Divide denominator by power of two\\n            assembly {\\n                denominator := div(denominator, twos)\\n            }\\n\\n            // Divide [prod1 prod0] by the factors of two\\n            assembly {\\n                prod0 := div(prod0, twos)\\n            }\\n            // Shift in bits from prod1 into prod0. For this we need\\n            // to flip `twos` such that it is 2**256 / twos.\\n            // If twos is zero, then it becomes one\\n            assembly {\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2**256\\n            // Now that denominator is an odd number, it has an inverse\\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n            // Compute the inverse by starting with a seed that is correct\\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n            uint256 inv = (3 * denominator) ^ 2;\\n            // Now use Newton-Raphson iteration to improve the precision.\\n            // Thanks to Hensel's lifting lemma, this also works in modular\\n            // arithmetic, doubling the correct bits in each step.\\n\\n            inv *= 2 - denominator * inv; // inverse mod 2**8\\n            inv *= 2 - denominator * inv; // inverse mod 2**16\\n            inv *= 2 - denominator * inv; // inverse mod 2**32\\n            inv *= 2 - denominator * inv; // inverse mod 2**64\\n            inv *= 2 - denominator * inv; // inverse mod 2**128\\n            inv *= 2 - denominator * inv; // inverse mod 2**256\\n\\n            // Because the division is now exact we can divide by multiplying\\n            // with the modular inverse of denominator. This will give us the\\n            // correct result modulo 2**256. Since the precoditions guarantee\\n            // that the outcome is less than 2**256, this is the final result.\\n            // We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inv;\\n            return result;\\n        }\\n    }\\n\\n    /// @notice Calculates ceil(a\u00d7b\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n    /// @param a The multiplicand\\n    /// @param b The multiplier\\n    /// @param denominator The divisor\\n    /// @return result The 256-bit result\\n    function mulDivRoundingUp(\\n        uint256 a,\\n        uint256 b,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        result = mulDiv(a, b, denominator);\\n        if (mulmod(a, b, denominator) > 0) {\\n            require(result < type(uint256).max);\\n            result++;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v1/libraries/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\\nlibrary TransferHelper {\\n    function safeApprove(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeApprove: approve failed\\\"\\n        );\\n    }\\n\\n    function safeTransfer(\\n        address token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::safeTransfer: transfer failed\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(\\n            success && (data.length == 0 || abi.decode(data, (bool))),\\n            \\\"TransferHelper::transferFrom: transferFrom failed\\\"\\n        );\\n    }\\n\\n    function safeTransferETH(address to, uint256 value) internal {\\n        (bool success, ) = to.call{value: value}(new bytes(0));\\n        require(success, \\\"TransferHelper::safeTransferETH: ETH transfer failed\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/v2/interfaces/IBasePoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IBasePoolV2 {\\n    event Paused(address account);\\n    event Unpaused(address account);\\n\\n    function poolManager() external view returns (address);\\n    function collateralToken() external view returns (address);\\n    function collateralReserve() external view returns (uint256);\\n    function tradeFeeRate() external view returns (uint16); // 1 means 1/10000\\n    function tradeFactor() external view returns (uint8);\\n    function getReserves() external view returns (uint256[] memory);\\n    function getTradingTokenId(uint8 option) external view returns (uint256);\\n    function paused() external view returns (bool);\\n\\n    function buy(address to, uint8 option) external returns (uint256 shares);\\n    function sell(address to, uint8 option) external returns (uint256 amount);\\n    \\n    function pause() external;\\n    function unpause() external;\\n}\"\r\n    },\r\n    \"contracts/v2/interfaces/IFixedCryptoPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./IBasePoolV2.sol\\\";\\n\\ninterface IFixedCryptoPoolV2 is IBasePoolV2 {\\n    event Buy(\\n        address indexed sender, \\n        address indexed to, \\n        uint8 indexed option, \\n        uint256 amount, \\n        uint256 fee, \\n        uint256 shares, \\n        uint256 round, \\n        uint256[] reserves\\n    );\\n    event Sell(\\n        address indexed sender, \\n        address indexed to, \\n        uint8 indexed option, \\n        uint256 amount, \\n        uint256 fee, \\n        uint256 shares, \\n        uint256 round, \\n        uint256[] reserves\\n    );\\n    event Claim(address indexed sender, address indexed to, uint256[] rounds, uint256[] amounts);\\n    event StartPriceSet(address indexed sender, uint256 round, int256 startPrice, uint256 oracleRoundIdOfStartPrice);\\n    event EndPriceSet(address indexed sender, uint256 round, int256 endPrice, uint256 oracleRoundIdOfEndPrice);\\n    event LiquidityRemoved(address indexed sender, uint256 round, uint256 amount);\\n    event NewRoundStarted(uint256 round, uint256 option0TokenId, uint256 tradeStartTime, uint256 tradeEndTime, uint256 roundEndTime);\\n    event TotalRoundsUpdated(uint32 oldTotalRounds, uint32 newTotalRounds);\\n\\n    struct RoundData {\\n        uint256 option0TokenId;\\n        uint256 tradeStartTime;\\n        uint256 tradeEndTime;\\n        uint256 roundEndTime;\\n        int256 startPrice;\\n        int256 endPrice;\\n        uint256 oracleRoundIdOfStartPrice;\\n        uint256 oracleRoundIdOfEndPrice;\\n    }\\n\\n    function priceOracle() external view returns (address);\\n    function roundGap() external view returns (uint32);\\n    function tradeDuration() external view returns (uint32);\\n    function priceDuration() external view returns (uint32);\\n    function totalRounds() external view returns (uint32);\\n    function currentRound() external view returns (uint256);\\n    function totalClaimable() external view returns (uint256);\\n    function initReserve() external view returns (uint256);\\n    function getRoundData(uint256 round) external view returns (\\n        uint256 option0TokenId,\\n        uint256 tradeStartTime,\\n        uint256 tradeEndTime,\\n        uint256 roundEndTime,\\n        int256 startPrice,\\n        int256 endPrice,\\n        uint256 oracleRoundIdOfStartPrice,\\n        uint256 oracleRoundIdOfEndPrice\\n    ); \\n    function getClaimable(\\n        address user, \\n        uint256[] memory rounds\\n    ) external view returns (uint256[] memory tokenIds, uint256[] memory shares);\\n\\n    function claim(address to, uint256[] calldata rounds) external returns (uint256[] memory amounts);\\n\\n    function updateTotalRounds(uint32 newTotalRounds) external;\\n    function setStartPrice() external;\\n    function endCurrentRound() external;\\n    function startNewRound(uint256 tradeStartTime, uint256 option0TokenId) external;\\n\\n    function initialize(\\n        address collateralToken_,\\n        address priceOracle_,\\n        uint256 initReserve_,\\n        uint32 roundGap_,\\n        uint32 tradeDuration_,\\n        uint32 priceDuration_,\\n        uint32 totalRounds_,\\n        uint16 tradeFeeRate_,\\n        uint8 tradeFactor_\\n    ) external;\\n}\"\r\n    },\r\n    \"contracts/v2/interfaces/IGeneralPoolV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./IBasePoolV2.sol\\\";\\n\\ninterface IGeneralPoolV2 is IBasePoolV2 {\\n    event AddLiquidity(uint256 amount, uint256[] reserves);\\n    event RemoveLiquidity(address indexed to, uint256 amount);\\n    event Buy(\\n        address indexed sender, \\n        address indexed to, \\n        uint8 indexed option, \\n        uint256 amount, \\n        uint256 fee, \\n        uint256 shares, \\n        uint256[] reserves\\n    );\\n    event Sell(\\n        address indexed sender, \\n        address indexed to, \\n        uint8 indexed option, \\n        uint256 amount, \\n        uint256 fee, \\n        uint256 shares, \\n        uint256[] reserves\\n    );\\n    event Claim(address indexed sender, address indexed to, uint256 amount);\\n    event ClaimTimeUpdated(uint256 oldClaimTime, uint256 newClaimTime);\\n    event SubmitResult(string description, uint8 option, uint256 totalShares);\\n\\n    function collateralReserve() external view returns (uint256);\\n    function resultDescription() external view returns (string memory);\\n    function resultOption() external view returns (uint8);\\n    function resultOpened() external view returns (bool);\\n    function tradeStartTime() external view returns (uint256);\\n    function tradeEndTime() external view returns (uint256);\\n    function claimTime() external view returns (uint256);\\n    function question() external view returns (string memory);\\n    function options(uint256 index) external view returns (string memory);\\n    function getClaimable(address user) external view returns (uint256 tokenId, uint256 shares);\\n\\n    function updateClaimTime(uint256 newClaimTime) external;\\n    function submitResult(uint8 option, string calldata description) external;\\n    function initialize(\\n        address collateralToken_,\\n        uint16 tradeFeeRate_,\\n        uint8 tradeFactor_,\\n        uint256 tradeStartTime_,\\n        uint256 tradeEndTime_,\\n        uint256 claimTime_,\\n        uint256 option0TokenId_,\\n        string memory question_,\\n        string[] memory options_\\n    ) external;\\n\\n    function addLiquidity(uint256 reserve0) external;\\n    function removeLiquidity() external returns (uint256 amount);\\n    function claim(address to) external returns (uint256 amount);\\n}\"\r\n    },\r\n    \"contracts/v2/interfaces/IPoolManagerV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface IPoolManagerV2 {\\n    event PoolPaused(bytes32 poolId);\\n    event PoolUnpaused(bytes32 poolId);\\n    event GeneralPoolCreated(\\n        bytes32 poolId,\\n        address pool,\\n        uint256 option0TokenId,\\n        uint256 tradeStartTime,\\n        uint256 tradeEndTime,\\n        uint256 claimTime,\\n        string question,\\n        string[] options,\\n        string tag\\n    );\\n    event FixedCryptoPoolCreated(\\n        bytes32 poolId,\\n        address pool,\\n        address priceOracle,\\n        uint256 initReserve,\\n        uint32 roundGap,\\n        uint32 tradeDuration,\\n        uint32 priceDuration,\\n        uint32 totalRounds,\\n        string tag\\n    );\\n\\n    function collateralToken() external view returns (address);\\n    function generalPoolTemplate() external view returns (address);\\n    function fixedCryptoPoolTemplate() external view returns (address);\\n    function tradeFeeRate() external view returns (uint16);\\n    function tradeFactor() external view returns (uint8);\\n    function getPool(bytes32 poolId) external view returns (address pool, uint8 poolType);\\n    function isBuilder(address) external view returns (bool);\\n    function isKeeper(address) external view returns (bool);\\n\\n    function updateGeneralPoolTemplate(address newTemplate) external;\\n    function updateFixedCryptoPoolTemplate(address newTemplate) external;\\n    function updateTradeFeeRate(uint16 newFeeRate) external;\\n    function updateTradeFactor(uint8 newFactor) external;\\n    function setBuilder(address builder, bool state) external;\\n    function setKeeper(address keeper, bool state) external;\\n    function withdraw(address token, address to, uint256 amount) external;\\n\\n    function createAndInitializeGeneralPool(\\n        uint256 collateralAmount,\\n        uint256 reserve0,\\n        uint256 tradeStartTime,\\n        uint256 tradeEndTime,\\n        uint256 claimTime,\\n        string memory question,\\n        string[] memory options,\\n        string memory tag\\n    ) external returns (address pool);\\n    function updateClaimTimeForGeneral(bytes32 poolId, uint256 newClaimTime) external;\\n    function submitResultForGeneral(bytes32 poolId, uint8 option, string calldata description) external;\\n    function removeLiquidityForGeneral(bytes32 poolId) external;\\n\\n    function createAndInitializeFixedCryptoPool(\\n        address priceOracle,\\n        uint256 initReserve,\\n        uint256 tradeStartTime,\\n        uint32 roundGap,\\n        uint32 tradeDuration,\\n        uint32 priceDuration,\\n        uint32 totalRounds,\\n        string memory tag\\n    ) external returns (address pool);\\n    function updateTotalRounds(bytes32 poolId, uint32 newTotalRounds) external;\\n    function setStartPrice(bytes32 poolId) external;\\n    function endCurrentRound(bytes32 poolId) external;\\n    function startNewRound(bytes32 poolId, uint256 tradeStartTime) external;\\n    function endCurrentAndStartNewRound(bytes32 poolId) external;\\n    \\n    function pause(bytes32 poolId) external;\\n    function unpause(bytes32 poolId) external;\\n\\n    function mint(address to, uint256 tokenId, uint256 shares) external;\\n    function burn(uint256 tokenId, uint256 shares) external;\\n}\"\r\n    },\r\n    \"contracts/v2/interfaces/ISwapRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\ninterface ISwapRouterV2 {\\n    function poolManager() external view returns (address);\\n\\n    function buy(\\n        bytes32 poolId,  \\n        address to,\\n        uint8 option, \\n        uint256 amount,\\n        uint256 minShares,\\n        uint256 deadline\\n    ) external returns (uint256 shares);\\n\\n    function sell(\\n        bytes32 poolId, \\n        address to, \\n        uint8 option, \\n        uint256 shares,\\n        uint256 minAmount,\\n        uint256 deadline\\n    ) external returns (uint256 amount);\\n\\n    function claimGeneralPool(bytes32 poolId, address to) external returns (uint256 amount);\\n\\n    function claimFixedPool(\\n        bytes32 poolId, \\n        address to,\\n        uint256[] calldata rounds\\n    ) external returns (uint256[] memory amounts);\\n\\n    function estimateBuy(\\n        bytes32 poolId,  \\n        uint8 option, \\n        uint256 amount\\n    ) external view returns (uint256 shares, uint256[] memory newReserves);\\n\\n    function estimateSell(\\n        bytes32 poolId,  \\n        uint8 option, \\n        uint256 shares\\n    ) external view returns (uint256 amount, uint256[] memory newReserves);\\n}\"\r\n    },\r\n    \"contracts/v2/SwapRouterV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.10;\\n\\nimport \\\"./interfaces/ISwapRouterV2.sol\\\";\\nimport \\\"./interfaces/IPoolManagerV2.sol\\\";\\nimport \\\"./interfaces/IBasePoolV2.sol\\\";\\nimport \\\"./interfaces/IGeneralPoolV2.sol\\\";\\nimport \\\"./interfaces/IFixedCryptoPoolV2.sol\\\";\\nimport \\\"../v1/libraries/FullMath.sol\\\";\\nimport \\\"../v1/libraries/TransferHelper.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\n\\ncontract SwapRouterV2 is ISwapRouterV2 {\\n    using FullMath for uint256;\\n\\n    address public immutable override poolManager;\\n\\n    modifier checkDeadline(uint deadline) {\\n        require(deadline >= block.timestamp, 'expired');\\n        _;\\n    }\\n\\n    constructor(address poolManager_) {\\n        poolManager = poolManager_;\\n    }\\n\\n    function buy(\\n        bytes32 poolId,\\n        address to,\\n        uint8 option,\\n        uint256 amount,\\n        uint256 minShares,\\n        uint256 deadline\\n    ) external override checkDeadline(deadline) returns (uint256 shares) {\\n        (address pool, ) = IPoolManagerV2(poolManager).getPool(poolId);\\n        require(pool != address(0), \\\"pool not found\\\");\\n        address collateralToken = IBasePoolV2(pool).collateralToken();\\n        TransferHelper.safeTransferFrom(\\n            collateralToken,\\n            msg.sender,\\n            pool,\\n            amount\\n        );\\n        shares = IBasePoolV2(pool).buy(to, option);\\n        require(shares >= minShares, \\\"insufficient shares\\\");\\n    }\\n\\n    function sell(\\n        bytes32 poolId,\\n        address to,\\n        uint8 option,\\n        uint256 shares,\\n        uint256 minAmount,\\n        uint256 deadline\\n    ) external override checkDeadline(deadline) returns (uint256 amount) {\\n        (address pool, ) = IPoolManagerV2(poolManager).getPool(poolId);\\n        require(pool != address(0), \\\"pool not found\\\");\\n        uint256 tokenId = IBasePoolV2(pool).getTradingTokenId(option);\\n        IERC1155(poolManager).safeTransferFrom(msg.sender, pool, tokenId, shares, \\\"\\\");\\n        amount = IBasePoolV2(pool).sell(to, option);\\n        require(amount >= minAmount, \\\"insufficient amount\\\");\\n    }\\n\\n    function claimGeneralPool(bytes32 poolId, address to) external override returns (uint256 amount) {\\n        (address pool, ) = IPoolManagerV2(poolManager).getPool(poolId);\\n        require(pool != address(0), \\\"pool not found\\\");\\n        (uint256 tokenId, uint256 shares) = IGeneralPoolV2(pool).getClaimable(msg.sender);\\n        IERC1155(poolManager).safeTransferFrom(msg.sender, pool, tokenId, shares, \\\"\\\");\\n        amount = IGeneralPoolV2(pool).claim(to);\\n    }\\n\\n    function claimFixedPool(\\n        bytes32 poolId,\\n        address to,\\n        uint256[] calldata rounds\\n    ) external override returns (uint256[] memory amounts) {\\n        (address pool, ) = IPoolManagerV2(poolManager).getPool(poolId);\\n        require(pool != address(0), \\\"pool not found\\\");\\n        (uint256[] memory tokenIds, uint256[] memory shares) = IFixedCryptoPoolV2(pool).getClaimable(msg.sender, rounds);\\n        IERC1155(poolManager).safeBatchTransferFrom(msg.sender, pool, tokenIds, shares, \\\"\\\");\\n        amounts = IFixedCryptoPoolV2(pool).claim(to, rounds);\\n    }\\n\\n    function estimateBuy(\\n        bytes32 poolId,\\n        uint8 option,\\n        uint256 amount\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 shares, uint256[] memory newReserves)\\n    {\\n        (address pool, ) = IPoolManagerV2(poolManager).getPool(poolId);\\n        require(pool != address(0), \\\"pool not found\\\");\\n        require(option <= 1, \\\"wrong option\\\");\\n        uint16 tradeFeeRate = IBasePoolV2(pool).tradeFeeRate();\\n        uint8 tradeFactor = IBasePoolV2(pool).tradeFactor();\\n        uint256[] memory reserves = IBasePoolV2(pool).getReserves();\\n\\n        uint256 amountWithoutFee = amount - amount * uint256(tradeFeeRate) / 10000;\\n        newReserves = new uint256[](2);\\n        if (option == 0) {\\n            newReserves[1] = amountWithoutFee * tradeFactor + reserves[1];\\n            newReserves[0] = reserves[0].mulDiv(reserves[1], newReserves[1]);\\n            shares = amountWithoutFee.mulDiv(newReserves[0] + newReserves[1], newReserves[1]);\\n        } else {\\n            newReserves[0] = amountWithoutFee * tradeFactor + reserves[0];\\n            newReserves[1] = reserves[0].mulDiv(reserves[1], newReserves[0]);\\n            shares = amountWithoutFee.mulDiv(newReserves[0] + newReserves[1], newReserves[0]);\\n        }\\n    }\\n\\n    function estimateSell(\\n        bytes32 poolId,\\n        uint8 option,\\n        uint256 shares\\n    )\\n        external\\n        view\\n        override\\n        returns (uint256 amount, uint256[] memory newReserves)\\n    {\\n        (address pool, ) = IPoolManagerV2(poolManager).getPool(poolId);\\n        require(pool != address(0), \\\"pool not found\\\");\\n        require(option <= 1, \\\"wrong option\\\");\\n        uint256[] memory reserves = IBasePoolV2(pool).getReserves();\\n        newReserves = new uint256[](2);\\n        if (option == 0) {\\n            newReserves[0] = reserves[0] + shares;\\n            newReserves[1] = reserves[0].mulDiv(reserves[1], newReserves[0]);\\n            amount = shares.mulDiv(newReserves[1], newReserves[0] + newReserves[1]);\\n        } else {\\n            newReserves[1] = reserves[1] + shares;\\n            newReserves[0] = reserves[0].mulDiv(reserves[1], newReserves[1]);\\n            amount = shares.mulDiv(newReserves[0], newReserves[0] + newReserves[1]);\\n        }\\n        uint16 tradeFeeRate = IBasePoolV2(pool).tradeFeeRate();\\n        amount -= (amount * tradeFeeRate) / 10000;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolManager_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"option\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minShares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"rounds\",\"type\":\"uint256[]\"}],\"name\":\"claimFixedPool\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimGeneralPool\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"option\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"estimateBuy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"newReserves\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"option\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"estimateSell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"newReserves\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"poolId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"option\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SwapRouterV2", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "000000000000000000000000c16643b44e427a7c5caa0c682ec672f12b592e83", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}