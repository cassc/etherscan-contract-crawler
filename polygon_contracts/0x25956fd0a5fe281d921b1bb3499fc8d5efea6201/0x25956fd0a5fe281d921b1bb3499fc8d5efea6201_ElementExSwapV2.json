{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/swap/ElementExSwapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\\\";\\nimport \\\"./storage/LibFeatureStorage.sol\\\";\\nimport \\\"./Aggregator.sol\\\";\\nimport \\\"./libs/Ownable.sol\\\";\\n\\n\\ncontract ElementExSwapV2 is Aggregator, Ownable {\\n\\n    struct Method {\\n        bytes4 methodID;\\n        string methodName;\\n    }\\n\\n    struct Feature {\\n        address feature;\\n        string name;\\n        Method[] methods;\\n    }\\n\\n    event FeatureFunctionUpdated(\\n        bytes4 indexed methodID,\\n        address oldFeature,\\n        address newFeature\\n    );\\n\\n    function registerFeatures(Feature[] calldata features) external onlyOwner {\\n        unchecked {\\n            for (uint256 i = 0; i < features.length; ++i) {\\n                registerFeature(features[i]);\\n            }\\n        }\\n    }\\n\\n    function registerFeature(Feature calldata feature) public onlyOwner {\\n        unchecked {\\n            address impl = feature.feature;\\n            require(impl != address(0), \\\"registerFeature: invalid feature address.\\\");\\n\\n            LibFeatureStorage.Storage storage stor = LibFeatureStorage.getStorage();\\n            stor.featureNames[impl] = feature.name;\\n\\n            Method[] calldata methods = feature.methods;\\n            for (uint256 i = 0; i < methods.length; ++i) {\\n                bytes4 methodID = methods[i].methodID;\\n                address oldFeature = stor.featureImpls[methodID];\\n                if (oldFeature == address(0)) {\\n                    stor.methodIDs.push(methodID);\\n                }\\n                stor.featureImpls[methodID] = impl;\\n                stor.methodNames[methodID] = methods[i].methodName;\\n                emit FeatureFunctionUpdated(methodID, oldFeature, impl);\\n            }\\n        }\\n    }\\n\\n    function unregister(bytes4[] calldata methodIDs) external onlyOwner {\\n        unchecked {\\n            uint256 removedFeatureCount;\\n            LibFeatureStorage.Storage storage stor = LibFeatureStorage.getStorage();\\n\\n            // Update storage.featureImpls\\n            for (uint256 i = 0; i < methodIDs.length; ++i) {\\n                bytes4 methodID = methodIDs[i];\\n                address impl = stor.featureImpls[methodID];\\n                if (impl != address(0)) {\\n                    removedFeatureCount++;\\n                    stor.featureImpls[methodID] = address(0);\\n                }\\n                emit FeatureFunctionUpdated(methodID, impl, address(0));\\n            }\\n            if (removedFeatureCount == 0) {\\n                return;\\n            }\\n\\n            // Remove methodIDs from storage.methodIDs\\n            bytes4[] storage storMethodIDs = stor.methodIDs;\\n            for (uint256 i = storMethodIDs.length; i > 0; --i) {\\n                bytes4 methodID = storMethodIDs[i - 1];\\n                if (stor.featureImpls[methodID] == address(0)) {\\n                    if (i != storMethodIDs.length) {\\n                        storMethodIDs[i - 1] = storMethodIDs[storMethodIDs.length - 1];\\n                    }\\n                    delete storMethodIDs[storMethodIDs.length - 1];\\n                    storMethodIDs.pop();\\n\\n                    if (removedFeatureCount == 1) { // Finished\\n                        return;\\n                    }\\n                    --removedFeatureCount;\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Fallback for just receiving ether.\\n    receive() external payable {}\\n\\n    /// @dev Forwards calls to the appropriate implementation contract.\\n    uint256 private constant STORAGE_ID_FEATURE = 1 << 128;\\n    fallback() external payable {\\n        assembly {\\n            // Copy methodID to memory 0x00~0x04\\n            calldatacopy(0, 0, 4)\\n\\n            // Store LibFeatureStorage.slot to memory 0x20~0x3F\\n            mstore(0x20, STORAGE_ID_FEATURE)\\n\\n            // Calculate impl.slot and load impl from storage\\n            let impl := sload(keccak256(0, 0x40))\\n            if iszero(impl) {\\n                // revert(\\\"Not implemented method.\\\")\\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                mstore(0x40, 0x000000174e6f7420696d706c656d656e746564206d6574686f642e0000000000)\\n                mstore(0x60, 0)\\n                revert(0, 0x64)\\n            }\\n\\n            calldatacopy(0, 0, calldatasize())\\n            if iszero(delegatecall(gas(), impl, 0, calldatasize(), 0, 0)) {\\n                // Failed, copy the returned data and revert.\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n\\n            // Success, copy the returned data and return.\\n            returndatacopy(0, 0, returndatasize())\\n            return(0, returndatasize())\\n        }\\n    }\\n\\n    function approveERC20(IERC20 token, address operator, uint256 amount) external onlyOwner {\\n        token.approve(operator, amount);\\n    }\\n\\n    function rescueETH(address recipient) external onlyOwner {\\n        address to = (recipient != address(0)) ? recipient : msg.sender;\\n        _transferEth(to, address(this).balance);\\n    }\\n\\n    function rescueERC20(address asset, address recipient) external onlyOwner {\\n        address to = (recipient != address(0)) ? recipient : msg.sender;\\n        _transferERC20(asset, to, IERC20(asset).balanceOf(address(this)));\\n    }\\n\\n    function rescueERC721(address asset, uint256[] calldata ids , address recipient) external onlyOwner {\\n        assembly {\\n            // selector for transferFrom(address,address,uint256)\\n            mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(0x4, address())\\n\\n            switch recipient\\n            case 0 { mstore(0x24, caller()) }\\n            default { mstore(0x24, recipient) }\\n\\n            for { let offset := ids.offset } lt(offset, calldatasize()) { offset := add(offset, 0x20) } {\\n                // tokenID\\n                mstore(0x44, calldataload(offset))\\n                if iszero(call(gas(), asset, 0, 0, 0x64, 0, 0)) {\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external virtual returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(address, address, uint256[] calldata, uint256[] calldata, bytes calldata) external virtual returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n\\n    function onERC721Received(address, address, uint256, bytes calldata) external virtual returns (bytes4) {\\n        return 0x150b7a02;\\n    }\\n\\n    function onERC721Received(address, uint256, bytes calldata) external virtual returns (bytes4) {\\n        return 0xf0b9e5ba;\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId) external virtual returns (bool) {\\n        return interfaceId == this.supportsInterface.selector;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/IERC1155.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/swap/storage/LibFeatureStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\n\\nlibrary LibFeatureStorage {\\n\\n    uint256 constant STORAGE_ID_FEATURE = 1 << 128;\\n\\n    struct Storage {\\n        // Mapping of methodID -> feature implementation\\n        mapping(bytes4 => address) featureImpls;\\n        // Mapping of feature implementation -> feature name\\n        mapping(address => string) featureNames;\\n        // Record methodIDs\\n        bytes4[] methodIDs;\\n        // Mapping of methodID -> method name\\n        mapping(bytes4 => string) methodNames;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        // Dip into assembly to change the slot pointed to by the local\\n        // variable `stor`.\\n        // See https://solidity.readthedocs.io/en/v0.6.8/assembly.html?highlight=slot#access-to-external-variables-functions-and-libraries\\n        assembly { stor.slot := STORAGE_ID_FEATURE }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/Aggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/IAggregator.sol\\\";\\nimport \\\"./libs/FixinTokenSpender.sol\\\";\\nimport \\\"./libs/ReentrancyGuard.sol\\\";\\n\\n\\nabstract contract Aggregator is IAggregator, ReentrancyGuard, FixinTokenSpender {\\n\\n    address private constant ELEMENT = 0xEAF5453b329Eb38Be159a872a6ce91c9A8fb0260;\\n\\n    uint256 private constant WETH_MARKET_ID = 999;\\n    address private constant WETH = 0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270;\\n\\n    // markets.slot == 0\\n    // markets.data.slot == keccak256(markets.slot) == 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563\\n    uint256 private constant MARKETS_DATA_SLOT = 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563;\\n\\n    // 168 bits(ethValue)\\n    uint256 private constant ETH_VALUE_MASK = (1 << 168) - 1;\\n    // 160 bits(proxy)\\n    uint256 private constant PROXY_MASK = (1 << 160) - 1;\\n\\n    function batchBuyWithETH(bytes calldata tradeBytes) external override payable {\\n        uint256 ethBalanceBefore;\\n        assembly { ethBalanceBefore := sub(selfbalance(), callvalue()) }\\n\\n        // trade\\n        _trade(tradeBytes);\\n\\n        // return remaining ETH (if any)\\n        assembly {\\n            if eq(selfbalance(), ethBalanceBefore) {\\n                return(0, 0)\\n            }\\n            if gt(selfbalance(), ethBalanceBefore) {\\n                let success := call(gas(), caller(), sub(selfbalance(), ethBalanceBefore), 0, 0, 0, 0)\\n                return(0, 0)\\n            }\\n        }\\n        revert(\\\"Failed to return ETH.\\\");\\n    }\\n\\n    function batchBuyWithERC20s(\\n        ERC20Pair[] calldata erc20Pairs,\\n        bytes calldata tradeBytes,\\n        address[] calldata dustTokens\\n    ) external override payable nonReentrant {\\n        // transfer ERC20 tokens from the sender to this contract\\n        _transferERC20Pairs(erc20Pairs);\\n\\n        // trade\\n        _trade(tradeBytes);\\n\\n        // return dust tokens (if any)\\n        _returnDust(dustTokens);\\n\\n        // return remaining ETH (if any)\\n        assembly {\\n            if gt(selfbalance(), 0) {\\n                let success := call(gas(), caller(), selfbalance(), 0, 0, 0, 0)\\n            }\\n        }\\n    }\\n\\n    function _trade(bytes calldata tradeBytes) internal {\\n        assembly {\\n            let anySuccess\\n            let itemLength\\n            let end := add(tradeBytes.offset, tradeBytes.length)\\n            let ptr := mload(0x40) // free memory pointer\\n\\n            // nextOffset == offset + 28bytes[2 + 1 + 21 + 4] + itemLength\\n            for { let offset := tradeBytes.offset } lt(offset, end) { offset := add(add(offset, 28), itemLength) } {\\n                // head == [2 bytes(marketId) + 1 bytes(continueIfFailed) + 21 bytes(ethValue) + 4 bytes(itemLength) + 4 bytes(item)]\\n                // head == [16 bits(marketId) + 8 bits(continueIfFailed) + 168 bits(ethValue) + 32 bits(itemLength) + 32 bits(item)]\\n                let head := calldataload(offset)\\n\\n                // itemLength = (head >> 32) & 0xffffffff\\n                itemLength := and(shr(32, head), 0xffffffff)\\n\\n                // itemOffset == offset + 28\\n                // copy item.data to memory ptr\\n                calldatacopy(ptr, add(offset, 28), itemLength)\\n\\n                // marketId = head >> (8 + 168 + 32 + 32) = head >> 240\\n                let marketId := shr(240, head)\\n\\n                // ElementEx\\n                if iszero(marketId) {\\n                    // ethValue = (head >> 64) & ETH_VALUE_MASK\\n                    // ELEMENT.call{value: ethValue}(item)\\n                    if iszero(call(gas(), ELEMENT, and(shr(64, head), ETH_VALUE_MASK), ptr, itemLength, 0, 0)) {\\n                        _revertOrContinue(head)\\n                        continue\\n                    }\\n                    anySuccess := 1\\n                    continue\\n                }\\n\\n                // WETH\\n                if eq(marketId, WETH_MARKET_ID) {\\n                    let methodId := and(head, 0xffffffff)\\n\\n                    // WETH.deposit();\\n                    if eq(methodId, 0xd0e30db0) {\\n                        if iszero(call(gas(), WETH, and(shr(64, head), ETH_VALUE_MASK), ptr, itemLength, 0, 0)) {\\n                            _revertOrContinue(head)\\n                            continue\\n                        }\\n                        anySuccess := 1\\n                        continue\\n                    }\\n\\n                    // WETH.withdraw();\\n                    if eq(methodId, 0x2e1a7d4d) {\\n                        if iszero(call(gas(), WETH, 0, ptr, itemLength, 0, 0)) {\\n                            _revertOrContinue(head)\\n                            continue\\n                        }\\n                        anySuccess := 1\\n                        continue\\n                    }\\n\\n                    // Do not support other methods.\\n                    _revertOrContinue(head)\\n                    continue\\n                }\\n\\n                // Others\\n                // struct Market {\\n                //        address proxy;\\n                //        bool isLibrary;\\n                //        bool isActive;\\n                //  }\\n                // [80 bits(unused) + 8 bits(isActive) + 8 bits(isLibrary) + 160 bits(proxy)]\\n                // [10 bytes(unused) + 1 bytes(isActive) + 1 bytes(isLibrary) + 20 bytes(proxy)]\\n\\n                // market.slot = markets.data.slot + marketId\\n                // market = sload(market.slot)\\n                let market := sload(add(MARKETS_DATA_SLOT, marketId))\\n\\n                // if (!market.isActive)\\n                if iszero(byte(10, market)) {\\n                    // if (!continueIfFailed)\\n                    if iszero(byte(2, head)) {\\n                         // revert(\\\"Inactive market.\\\")\\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                        mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                        mstore(0x40, 0x00000010496e616374697665206d61726b65742e000000000000000000000000)\\n                        mstore(0x60, 0)\\n                        revert(0, 0x64)\\n                    }\\n                    continue\\n                }\\n\\n                // if (!market.isLibrary)\\n                if iszero(byte(11, market)) {\\n                    // ethValue = (head >> 64) & ETH_VALUE_MASK\\n                    // market.proxy.call{value: ethValue}(item)\\n                    if iszero(call(gas(), and(market, PROXY_MASK), and(shr(64, head), ETH_VALUE_MASK), ptr, itemLength, 0, 0)) {\\n                        _revertOrContinue(head)\\n                        continue\\n                    }\\n                    anySuccess := 1\\n                    continue\\n                }\\n\\n                // market.proxy.delegatecall(item)\\n                if iszero(delegatecall(gas(), and(market, PROXY_MASK), ptr, itemLength, 0, 0)) {\\n                    _revertOrContinue(head)\\n                    continue\\n                }\\n                anySuccess := 1\\n            }\\n\\n            // if (!anySuccess)\\n            if iszero(anySuccess) {\\n                if gt(tradeBytes.length, 0) {\\n                    if iszero(returndatasize()) {\\n                        // revert(\\\"No order succeeded.\\\")\\n                        mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                        mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                        mstore(0x40, 0x000000134e6f206f72646572207375636365656465642e000000000000000000)\\n                        mstore(0x60, 0)\\n                        revert(0, 0x64)\\n                    }\\n                    // revert(returnData)\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n\\n            function _revertOrContinue(head) {\\n                // head == [2 bytes(marketId) + 1 bytes(continueIfFailed) + 21 bytes(ethValue) + 4 bytes(itemLength) + 4 bytes(item)]\\n                // if (!continueIfFailed)\\n                if iszero(byte(2, head)) {\\n                    if iszero(returndatasize()) {\\n                        mstore(0, head)\\n                        revert(0, 0x20)\\n                    }\\n                    returndatacopy(0, 0, returndatasize())\\n                    revert(0, returndatasize())\\n                }\\n            }\\n        }\\n    }\\n\\n    function _transferERC20Pairs(ERC20Pair[] calldata erc20Pairs) internal {\\n        // transfer ERC20 tokens from the sender to this contract\\n        if (erc20Pairs.length > 0) {\\n            assembly {\\n                let ptr := mload(0x40)\\n                let end := add(erc20Pairs.offset, mul(erc20Pairs.length, 0x40))\\n\\n                // selector for transferFrom(address,address,uint256)\\n                mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n                mstore(add(ptr, 0x04), caller())\\n                mstore(add(ptr, 0x24), address())\\n                for { let offset := erc20Pairs.offset } lt(offset, end) { offset := add(offset, 0x40) } {\\n                    let amount := calldataload(add(offset, 0x20))\\n                    if gt(amount, 0) {\\n                        mstore(add(ptr, 0x44), amount)\\n                        let success := call(gas(), calldataload(offset), 0, ptr, 0x64, 0, 0)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    function _returnDust(address[] calldata tokens) internal {\\n        // return remaining tokens (if any)\\n        for (uint256 i; i < tokens.length; ) {\\n            _transferERC20WithoutCheck(tokens[i], msg.sender, IERC20(tokens[i]).balanceOf(address(this)));\\n            unchecked { ++i; }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/libs/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport \\\"../storage/LibOwnableStorage.sol\\\";\\n\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        if (owner() == address(0)) {\\n            _transferOwnership(msg.sender);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return LibOwnableStorage.getStorage().owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == msg.sender, \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) private {\\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\\n        address oldOwner = stor.owner;\\n        stor.owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"contracts/swap/interfaces/IAggregator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\n\\ninterface IAggregator {\\n\\n    struct ERC20Pair {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    function batchBuyWithETH(bytes calldata tradeBytes) external payable;\\n\\n    function batchBuyWithERC20s(\\n        ERC20Pair[] calldata erc20Pairs,\\n        bytes calldata tradeBytes,\\n        address[] calldata dustTokens\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/swap/libs/FixinTokenSpender.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\n\\n/// @dev Helpers for moving tokens around.\\nabstract contract FixinTokenSpender {\\n\\n    // Mask of the lower 20 bytes of a bytes32.\\n    uint256 constant private ADDRESS_MASK = (1 << 160) - 1;\\n\\n    /// @dev Transfers ERC20 tokens from `owner` to `to`.\\n    /// @param token The token to spend.\\n    /// @param owner The owner of the tokens.\\n    /// @param to The recipient of the tokens.\\n    /// @param amount The amount of `token` to transfer.\\n    function _transferERC20From(address token, address owner, address to, uint256 amount) internal {\\n        uint256 success;\\n        assembly {\\n            let ptr := mload(0x40) // free memory pointer\\n\\n            // selector for transferFrom(address,address,uint256)\\n            mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(ptr, 0x04), and(owner, ADDRESS_MASK))\\n            mstore(add(ptr, 0x24), and(to, ADDRESS_MASK))\\n            mstore(add(ptr, 0x44), amount)\\n\\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x64, ptr, 32)\\n\\n            let rdsize := returndatasize()\\n\\n            // Check for ERC20 success. ERC20 tokens should return a boolean,\\n            // but some don't. We accept 0-length return data as success, or at\\n            // least 32 bytes that starts with a 32-byte boolean true.\\n            success := and(\\n                success,                             // call itself succeeded\\n                or(\\n                    iszero(rdsize),                  // no return data, or\\n                    and(\\n                        iszero(lt(rdsize, 32)),      // at least 32 bytes\\n                        eq(mload(ptr), 1)            // starts with uint256(1)\\n                    )\\n                )\\n            )\\n        }\\n        require(success != 0, \\\"_transferERC20/TRANSFER_FAILED\\\");\\n    }\\n\\n    /// @dev Transfers ERC20 tokens from ourselves to `to`.\\n    /// @param token The token to spend.\\n    /// @param to The recipient of the tokens.\\n    /// @param amount The amount of `token` to transfer.\\n    function _transferERC20(address token, address to, uint256 amount) internal {\\n        uint256 success;\\n        assembly {\\n            let ptr := mload(0x40) // free memory pointer\\n\\n            // selector for transfer(address,uint256)\\n            mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(ptr, 0x04), and(to, ADDRESS_MASK))\\n            mstore(add(ptr, 0x24), amount)\\n\\n            success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x44, ptr, 32)\\n\\n            let rdsize := returndatasize()\\n\\n            // Check for ERC20 success. ERC20 tokens should return a boolean,\\n            // but some don't. We accept 0-length return data as success, or at\\n            // least 32 bytes that starts with a 32-byte boolean true.\\n            success := and(\\n                success,                             // call itself succeeded\\n                or(\\n                    iszero(rdsize),                  // no return data, or\\n                    and(\\n                        iszero(lt(rdsize, 32)),      // at least 32 bytes\\n                        eq(mload(ptr), 1)            // starts with uint256(1)\\n                    )\\n                )\\n            )\\n        }\\n        require(success != 0, \\\"_transferERC20/TRANSFER_FAILED\\\");\\n    }\\n\\n    function _transferERC20FromWithoutCheck(address token, address owner, address to, uint256 amount) internal {\\n        assembly {\\n            if gt(amount, 0) {\\n                let ptr := mload(0x40) // free memory pointer\\n\\n                // selector for transferFrom(address,address,uint256)\\n                mstore(ptr, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n                mstore(add(ptr, 0x04), and(owner, ADDRESS_MASK))\\n                mstore(add(ptr, 0x24), and(to, ADDRESS_MASK))\\n                mstore(add(ptr, 0x44), amount)\\n\\n                let success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x64, 0, 0)\\n            }\\n        }\\n    }\\n\\n    function _transferERC20WithoutCheck(address token, address to, uint256 amount) internal {\\n        assembly {\\n            if gt(amount, 0) {\\n                let ptr := mload(0x40) // free memory pointer\\n\\n                // selector for transfer(address,uint256)\\n                mstore(ptr, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n                mstore(add(ptr, 0x04), and(to, ADDRESS_MASK))\\n                mstore(add(ptr, 0x24), amount)\\n\\n                let success := call(gas(), and(token, ADDRESS_MASK), 0, ptr, 0x44, 0, 0)\\n            }\\n        }\\n    }\\n\\n    /// @dev Transfers some amount of ETH to the given recipient and\\n    ///      reverts if the transfer fails.\\n    /// @param recipient The recipient of the ETH.\\n    /// @param amount The amount of ETH to transfer.\\n    function _transferEth(address recipient, uint256 amount) internal {\\n        assembly {\\n            if gt(amount, 0) {\\n                if iszero(call(gas(), recipient, amount, 0, 0, 0, 0)) {\\n                    // revert(\\\"_transferEth/TRANSFER_FAILED\\\")\\n                    mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x20, 0x0000002000000000000000000000000000000000000000000000000000000000)\\n                    mstore(0x40, 0x0000001c5f7472616e736665724574682f5452414e534645525f4641494c4544)\\n                    mstore(0x60, 0)\\n                    revert(0, 0x64)\\n                }\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/libs/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\nimport \\\"../storage/LibOwnableStorage.sol\\\";\\n\\n\\nabstract contract ReentrancyGuard {\\n\\n    constructor() {\\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\\n        if (stor.reentrancyStatus == 0) {\\n            stor.reentrancyStatus = 1;\\n        }\\n    }\\n\\n    modifier nonReentrant() {\\n        LibOwnableStorage.Storage storage stor = LibOwnableStorage.getStorage();\\n        require(stor.reentrancyStatus == 1, \\\"ReentrancyGuard: reentrant call\\\");\\n        stor.reentrancyStatus = 2;\\n        _;\\n        stor.reentrancyStatus = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/swap/storage/LibOwnableStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.15;\\n\\n\\nlibrary LibOwnableStorage {\\n\\n    uint256 constant STORAGE_ID_OWNABLE = 2 << 128;\\n\\n    struct Storage {\\n        uint256 reentrancyStatus;\\n        address owner;\\n    }\\n\\n    /// @dev Get the storage bucket for this contract.\\n    function getStorage() internal pure returns (Storage storage stor) {\\n        assembly { stor.slot := STORAGE_ID_OWNABLE }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes4\",\"name\":\"methodID\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeature\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeature\",\"type\":\"address\"}],\"name\":\"FeatureFunctionUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approveERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IAggregator.ERC20Pair[]\",\"name\":\"erc20Pairs\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes\",\"name\":\"tradeBytes\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"dustTokens\",\"type\":\"address[]\"}],\"name\":\"batchBuyWithERC20s\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"tradeBytes\",\"type\":\"bytes\"}],\"name\":\"batchBuyWithETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"feature\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"methodID\",\"type\":\"bytes4\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct ElementExSwapV2.Method[]\",\"name\":\"methods\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ElementExSwapV2.Feature\",\"name\":\"feature\",\"type\":\"tuple\"}],\"name\":\"registerFeature\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"feature\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"methodID\",\"type\":\"bytes4\"},{\"internalType\":\"string\",\"name\":\"methodName\",\"type\":\"string\"}],\"internalType\":\"struct ElementExSwapV2.Method[]\",\"name\":\"methods\",\"type\":\"tuple[]\"}],\"internalType\":\"struct ElementExSwapV2.Feature[]\",\"name\":\"features\",\"type\":\"tuple[]\"}],\"name\":\"registerFeatures\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueERC721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"rescueETH\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"methodIDs\",\"type\":\"bytes4[]\"}],\"name\":\"unregister\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ElementExSwapV2", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "1", "Implementation": "0x2409b8eee2c1cf8afd178896712e517ef781d613", "SwarmSource": ""}