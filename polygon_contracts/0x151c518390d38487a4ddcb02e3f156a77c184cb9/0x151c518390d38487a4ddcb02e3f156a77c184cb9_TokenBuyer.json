{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./contracts/TokenBuyer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport { FeeDistributor } from \\\"./utils/FeeDistributor.sol\\\";\\nimport { Signatures } from \\\"./utils/Signatures.sol\\\";\\nimport { ITokenBuyer } from \\\"./interfaces/ITokenBuyer.sol\\\";\\nimport { IUniversalRouter } from \\\"./interfaces/external/IUniversalRouter.sol\\\";\\nimport { LibAddress } from \\\"./lib/LibAddress.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title A smart contract for buying any kind of tokens and taking a fee.\\ncontract TokenBuyer is ITokenBuyer, FeeDistributor, Signatures {\\n    using LibAddress for address payable;\\n\\n    address payable public immutable universalRouter;\\n    address public immutable permit2;\\n\\n    /// @param universalRouter_ The address of Uniswap's Universal router.\\n    /// @param universalRouter_ The address of the Permit2 contract.\\n    /// @param feeCollector_ The address that will receive a fee from the funds.\\n    /// @param feePercentBps_ The percentage of the fee expressed in basis points (e.g 500 for a 5% cut).\\n    constructor(\\n        address payable universalRouter_,\\n        address permit2_,\\n        address payable feeCollector_,\\n        uint96 feePercentBps_\\n    ) FeeDistributor(feeCollector_, feePercentBps_) {\\n        universalRouter = universalRouter_;\\n        permit2 = permit2_;\\n    }\\n\\n    function getAssets(\\n        uint256 guildId,\\n        PayToken calldata payToken,\\n        bytes calldata uniCommands,\\n        bytes[] calldata uniInputs\\n    ) external payable {\\n        IERC20 token = IERC20(payToken.tokenAddress);\\n\\n        // Get the tokens from the user and send the fee collector's share\\n        if (address(token) == address(0)) feeCollector.sendEther(calculateFee(address(0), msg.value));\\n        else {\\n            if (!token.transferFrom(msg.sender, address(this), payToken.amount))\\n                revert TransferFailed(msg.sender, address(this));\\n            if (!token.transfer(feeCollector, calculateFee(address(token), payToken.amount)))\\n                revert TransferFailed(address(this), feeCollector);\\n            if (token.allowance(address(this), permit2) < payToken.amount) token.approve(permit2, type(uint256).max);\\n        }\\n\\n        IUniversalRouter(universalRouter).execute{ value: address(this).balance }(uniCommands, uniInputs);\\n\\n        // Send out any remaining tokens\\n        if (address(token) != address(0) && !token.transfer(msg.sender, token.balanceOf(address(this))))\\n            revert TransferFailed(address(this), msg.sender);\\n\\n        emit TokensBought(guildId);\\n    }\\n\\n    function sweep(address token, address payable recipient, uint256 amount) external onlyFeeCollector {\\n        if (!IERC20(token).transfer(recipient, amount)) revert TransferFailed(address(this), feeCollector);\\n        emit TokensSweeped(token, recipient, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/utils/FeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport { IFeeDistributor } from \\\"../interfaces/IFeeDistributor.sol\\\";\\n\\ncontract FeeDistributor is IFeeDistributor {\\n    address payable public feeCollector;\\n    uint96 public feePercentBps;\\n\\n    mapping(address => uint256) public baseFee;\\n\\n    /// @param feeCollector_ The address that will receive a fee from the funds.\\n    /// @param feePercentBps_ The percentage of the fee expressed in basis points (e.g 500 for a 5% cut).\\n    constructor(address payable feeCollector_, uint96 feePercentBps_) {\\n        feeCollector = feeCollector_;\\n        feePercentBps = feePercentBps_;\\n    }\\n\\n    modifier onlyFeeCollector() {\\n        if (msg.sender != feeCollector) revert AccessDenied(msg.sender, feeCollector);\\n        _;\\n    }\\n\\n    function setBaseFee(address token, uint256 newFee) external onlyFeeCollector {\\n        baseFee[token] = newFee;\\n        emit BaseFeeChanged(token, newFee);\\n    }\\n\\n    function setFeeCollector(address payable newFeeCollector) external onlyFeeCollector {\\n        feeCollector = newFeeCollector;\\n        emit FeeCollectorChanged(newFeeCollector);\\n    }\\n\\n    function setFeePercentBps(uint96 newShare) external onlyFeeCollector {\\n        feePercentBps = newShare;\\n        emit FeePercentBpsChanged(newShare);\\n    }\\n\\n    /// @notice Calculate the fee from the full amount + fee\\n    function calculateFee(address token, uint256 amount) internal view returns (uint256 fee) {\\n        uint256 baseFeeAmount = baseFee[token];\\n        uint256 withoutBaseFee = amount - baseFeeAmount;\\n        return withoutBaseFee - ((withoutBaseFee / (10000 + feePercentBps)) * 10000) + baseFeeAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/interfaces/IFeeDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface IFeeDistributor {\\n    /// @notice The base fee of a swap on top of the percentual fee.\\n    /// @param token The token whose base fee is queried.\\n    /// @return baseFee The amount of the fee in wei.\\n    function baseFee(address token) external returns (uint256 baseFee);\\n\\n    /// @notice Sets the base fee for a given token.\\n    /// @dev Callable only by the current fee collector.\\n    /// @param token The token whose base fee is set.\\n    /// @param newFee The new base fee in wei.\\n    function setBaseFee(address token, uint256 newFee) external;\\n\\n    /// @notice Sets the address that receives the fee from the funds.\\n    /// @dev Callable only by the current fee collector.\\n    /// @param newFeeCollector The new address of feeCollector.\\n    function setFeeCollector(address payable newFeeCollector) external;\\n\\n    /// @notice Sets the fee's amount from the funds.\\n    /// @dev Callable only by the fee collector.\\n    /// @param newShare The percentual value expressed in basis points.\\n    function setFeePercentBps(uint96 newShare) external;\\n\\n    /// @notice Returns the address that receives the fee from the funds.\\n    function feeCollector() external view returns (address payable);\\n\\n    /// @notice Returns the percentage of the fee expressed in basis points.\\n    function feePercentBps() external view returns (uint96);\\n\\n    /// @notice Event emitted when a token's base fee is changed.\\n    /// @param token The address of the token whose fee was changed. 0 for ether.\\n    /// @param newFee The new amount of base fee in wei.\\n    event BaseFeeChanged(address token, uint256 newFee);\\n\\n    /// @notice Event emitted when the fee collector address is changed.\\n    /// @param newFeeCollector The new address of feeCollector.\\n    event FeeCollectorChanged(address newFeeCollector);\\n\\n    /// @notice Event emitted when the share of the fee collector changes.\\n    /// @param newShare The new value of feePercentBps.\\n    event FeePercentBpsChanged(uint96 newShare);\\n\\n    /// @notice Error thrown when a function is attempted to be called by the wrong address.\\n    /// @param sender The address that sent the transaction.\\n    /// @param owner The address that is allowed to call the function.\\n    error AccessDenied(address sender, address owner);\\n}\\n\"\r\n    },\r\n    \"./contracts/utils/Signatures.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.18;\\n\\nimport { ITokenBuyer } from \\\"../interfaces/ITokenBuyer.sol\\\";\\n\\ncontract Signatures {\\n    // bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\")\\n    bytes4 internal constant MAGICVALUE = 0x1626ba7e;\\n\\n    /// @notice Accepts signatures from permit2, rejects otherwise.\\n    /// @param hash Hash of the data to be signed.\\n    /// @param signature Signature byte array associated with hash.\\n    /// @return magicValue The function selector if the function passes.\\n    function isValidSignature(bytes32 hash, bytes memory signature) public view returns (bytes4 magicValue) {\\n        if (msg.sender == ITokenBuyer(address(this)).permit2()) return MAGICVALUE;\\n\\n        hash;\\n        signature;\\n        return bytes4(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"./contracts/interfaces/ITokenBuyer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport { IFeeDistributor } from \\\"./IFeeDistributor.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title A smart contract for buying any kind of tokens and taking a fee.\\ninterface ITokenBuyer is IFeeDistributor {\\n    /// @notice A token address-amount pair.\\n    struct PayToken {\\n        address tokenAddress;\\n        uint256 amount;\\n    }\\n\\n    /// @notice Executes token swaps and takes a fee.\\n    /// @param guildId The id of the guild where the payment was made. Used only for analytics.\\n    /// @param payToken The address and the amount of the token that's used for paying. 0 for ether.\\n    /// @param uniCommands A set of concatenated commands, each 1 byte in length.\\n    /// @param uniInputs An array of byte strings containing abi encoded inputs for each command.\\n    function getAssets(\\n        uint256 guildId,\\n        PayToken calldata payToken,\\n        bytes calldata uniCommands,\\n        bytes[] calldata uniInputs\\n    ) external payable;\\n\\n    /// @notice Allows the feeCollector to withdraw any tokens stuck in the contract. Used to rescue funds.\\n    /// @param token The address of the token to sweep. 0 for ether.\\n    /// @param recipient The recipient of the tokens.\\n    /// @param amount The amount of the tokens to sweep.\\n    function sweep(address token, address payable recipient, uint256 amount) external;\\n\\n    /// @notice Returns the address of Uniswap's Universal Router.\\n    function universalRouter() external view returns (address payable);\\n\\n    /// @notice Returns the address the Permit2 contract.\\n    function permit2() external view returns (address);\\n\\n    /// @notice Event emitted when a call to {getAssets} succeeds.\\n    /// @param guildId The id of the guild where the payment was made. Used only for analytics.\\n    event TokensBought(uint256 guildId);\\n\\n    /// @notice Event emitted when tokens are sweeped from the contract.\\n    /// @dev Callable only by the current fee collector.\\n    /// @param token The address of the token sweeped. 0 for ether.\\n    /// @param recipient The recipient of the tokens.\\n    /// @param amount The amount of the tokens sweeped.\\n    event TokensSweeped(address token, address payable recipient, uint256 amount);\\n\\n    /// @notice Error thrown when an ERC20 transfer failed.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    error TransferFailed(address from, address to);\\n}\\n\"\r\n    },\r\n    \"./contracts/interfaces/external/IUniversalRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.17;\\n\\nimport { IERC721Receiver } from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport { IERC1155Receiver } from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport { IRewardsCollector } from \\\"./IRewardsCollector.sol\\\";\\n\\ninterface IUniversalRouter is IRewardsCollector, IERC721Receiver, IERC1155Receiver {\\n    /// @notice Thrown when a required command has failed\\n    error ExecutionFailed(uint256 commandIndex, bytes message);\\n\\n    /// @notice Thrown when attempting to send ETH directly to the contract\\n    error ETHNotAccepted();\\n\\n    /// @notice Thrown executing commands with an expired deadline\\n    error TransactionDeadlinePassed();\\n\\n    /// @notice Thrown executing commands with an expired deadline\\n    error LengthMismatch();\\n\\n    /// @notice Executes encoded commands along with provided inputs. Reverts if deadline has expired.\\n    /// @param commands A set of concatenated commands, each 1 byte in length\\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\\n    /// @param deadline The deadline by which the transaction must be executed\\n    function execute(bytes calldata commands, bytes[] calldata inputs, uint256 deadline) external payable;\\n\\n    /// @notice Executes encoded commands along with provided inputs.\\n    /// @param commands A set of concatenated commands, each 1 byte in length\\n    /// @param inputs An array of byte strings containing abi encoded inputs for each command\\n    function execute(bytes calldata commands, bytes[] calldata inputs) external payable;\\n}\\n\"\r\n    },\r\n    \"./contracts/interfaces/external/IRewardsCollector.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\npragma solidity ^0.8.15;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title LooksRare Rewards Collector\\n/// @notice Implements a permissionless call to fetch LooksRare rewards earned by Universal Router users\\n/// and transfers them to an external rewards distributor contract\\ninterface IRewardsCollector {\\n    /// @notice Fetches users' LooksRare rewards and sends them to the distributor contract\\n    /// @param looksRareClaim The data required by LooksRare to claim reward tokens\\n    function collectRewards(bytes calldata looksRareClaim) external;\\n}\\n\"\r\n    },\r\n    \"./contracts/lib/LibAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n/// @title Library for functions related to addresses.\\nlibrary LibAddress {\\n    /// @notice Error thrown when sending ether fails.\\n    /// @param recipient The address that could not receive the ether.\\n    error FailedToSendEther(address recipient);\\n\\n    /// @notice Send ether to an address, forwarding all available gas and reverting on errors.\\n    /// @param recipient The recipient of the ether.\\n    /// @param amount The amount of ether to send in wei.\\n    function sendEther(address payable recipient, uint256 amount) internal {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        if (!success) revert FailedToSendEther(recipient);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"universalRouter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"permit2_\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"feeCollector_\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"feePercentBps_\",\"type\":\"uint96\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"AccessDenied\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"FailedToSendEther\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"BaseFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint96\",\"name\":\"newShare\",\"type\":\"uint96\"}],\"name\":\"FeePercentBpsChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"}],\"name\":\"TokensBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensSweeped\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"baseFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentBps\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"guildId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ITokenBuyer.PayToken\",\"name\":\"payToken\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"uniCommands\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"uniInputs\",\"type\":\"bytes[]\"}],\"name\":\"getAssets\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"isValidSignature\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"magicValue\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"permit2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setBaseFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"newShare\",\"type\":\"uint96\"}],\"name\":\"setFeePercentBps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweep\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"universalRouter\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "TokenBuyer", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000004c60051384bd2d3c01bfc845cf5f4b44bcbe9de5000000000000000000000000000000000022d473030f116ddee9f6b43ac78ba30000000000000000000000001d7da3d9bc8fcff7953d91e721531d6dc69f09f60000000000000000000000000000000000000000000000000000000000000064", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://0699d5074054a67128c0b7499f7763fe82a0a3eb7d373552b4e399fb89b9379f"}