{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/Keep.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {ERC1155TokenReceiver, KeepToken} from \\\"./KeepToken.sol\\\";\\nimport {Multicallable} from \\\"./utils/Multicallable.sol\\\";\\n\\n/// @title Keep\\n/// @notice Tokenized multisig wallet.\\n/// @author z0r0z.eth\\n/// @custom:coauthor @ControlCplusControlV\\n/// @custom:coauthor boredretard.eth\\n/// @custom:coauthor vectorized.eth\\n/// @custom:coauthor horsefacts.eth\\n/// @custom:coauthor shivanshi.eth\\n/// @custom:coauthor @0xAlcibiades\\n/// @custom:coauthor LeXpunK Army\\n/// @custom:coauthor @0xmichalis\\n/// @custom:coauthor @iFrostizz\\n/// @custom:coauthor @m1guelpf\\n/// @custom:coauthor @asnared\\n/// @custom:coauthor @0xPhaze\\n/// @custom:coauthor out.eth\\n\\nenum Operation {\\n    call,\\n    delegatecall,\\n    create\\n}\\n\\nstruct Call {\\n    Operation op;\\n    address to;\\n    uint256 value;\\n    bytes data;\\n}\\n\\nstruct Signature {\\n    address user;\\n    uint8 v;\\n    bytes32 r;\\n    bytes32 s;\\n}\\n\\ncontract Keep is ERC1155TokenReceiver, KeepToken, Multicallable {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Emitted when Keep executes call.\\n    event Executed(\\n        uint256 indexed nonce,\\n        Operation op,\\n        address to,\\n        uint256 value,\\n        bytes data\\n    );\\n\\n    /// @dev Emitted when Keep relays call.\\n    event Relayed(Call call);\\n\\n    /// @dev Emitted when Keep relays calls.\\n    event Multirelayed(Call[] calls);\\n\\n    /// @dev Emitted when quorum threshold is updated.\\n    event QuorumSet(uint256 threshold);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Throws if `initialize()` is called more than once.\\n    error AlreadyInit();\\n\\n    /// @dev Throws if quorum exceeds `totalSupply(SIGN_KEY)`.\\n    error QuorumOverSupply();\\n\\n    /// @dev Throws if quorum with `threshold = 0` is set.\\n    error InvalidThreshold();\\n\\n    /// @dev Throws if `execute()` doesn't complete operation.\\n    error ExecuteFailed();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Keep Storage/Logic\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Core ID key permission.\\n    uint256 internal immutable CORE_KEY = uint32(type(KeepToken).interfaceId);\\n\\n    /// @dev Default metadata fetcher for `uri()`.\\n    Keep internal immutable uriFetcher;\\n\\n    /// @dev Record of states verifying `execute()`.\\n    uint120 public nonce;\\n\\n    /// @dev SIGN_KEY threshold to `execute()`.\\n    uint120 public quorum;\\n\\n    /// @dev Internal ID metadata mapping.\\n    mapping(uint256 => string) internal _uris;\\n\\n    /// @dev ID metadata fetcher.\\n    /// @param id ID to fetch from.\\n    /// @return tokenURI Metadata.\\n    function uri(uint256 id) public view virtual returns (string memory) {\\n        string memory tokenURI = _uris[id];\\n\\n        if (bytes(tokenURI).length > 0) return tokenURI;\\n        else return uriFetcher.uri(id);\\n    }\\n\\n    /// @dev Access control check for ID key balance holders.\\n    /// Initalizes with `address(this)` having implicit permission\\n    /// without writing to storage by checking `totalSupply()` is zero.\\n    /// Otherwise, this permission can be set to additional accounts,\\n    /// including retaining `address(this)`, via `mint()`.\\n    function _authorized() internal view virtual returns (bool) {\\n        if (\\n            (totalSupply[CORE_KEY] == 0 && msg.sender == address(this)) ||\\n            balanceOf[msg.sender][CORE_KEY] != 0 ||\\n            balanceOf[msg.sender][uint32(msg.sig)] != 0\\n        ) return true;\\n        else revert Unauthorized();\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC165 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev ERC165 interface detection.\\n    /// @param interfaceId ID to check.\\n    /// @return Fetch detection success.\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            // ERC165 Interface ID for ERC721TokenReceiver.\\n            interfaceId == this.onERC721Received.selector ||\\n            // ERC165 Interface ID for ERC1155TokenReceiver.\\n            interfaceId == type(ERC1155TokenReceiver).interfaceId ||\\n            // ERC165 interface ID for ERC1155MetadataURI.\\n            interfaceId == this.uri.selector ||\\n            // ERC165 Interface IDs for ERC1155.\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC721 Receiver Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function onERC721Received(\\n        address,\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) public payable virtual returns (bytes4) {\\n        return this.onERC721Received.selector;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Initialization Logic\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Create Keep template.\\n    /// @param _uriFetcher Metadata default.\\n    constructor(Keep _uriFetcher) payable {\\n        uriFetcher = _uriFetcher;\\n\\n        // Deploy as singleton.\\n        quorum = 1;\\n    }\\n\\n    /// @notice Initialize Keep configuration.\\n    /// @param calls Initial Keep operations.\\n    /// @param signers Initial signer set.\\n    /// @param threshold Initial quorum.\\n    function initialize(\\n        Call[] calldata calls,\\n        address[] calldata signers,\\n        uint256 threshold\\n    ) public payable virtual {\\n        if (quorum != 0) revert AlreadyInit();\\n\\n        if (threshold == 0) revert InvalidThreshold();\\n\\n        if (threshold > signers.length) revert QuorumOverSupply();\\n\\n        if (calls.length != 0) {\\n            for (uint256 i; i < calls.length; ) {\\n                _execute(\\n                    calls[i].op,\\n                    calls[i].to,\\n                    calls[i].value,\\n                    calls[i].data\\n                );\\n\\n                // An array can't have a total length\\n                // larger than the max uint256 value.\\n                unchecked {\\n                    ++i;\\n                }\\n            }\\n        }\\n\\n        address previous;\\n        address signer;\\n        uint256 supply;\\n\\n        for (uint256 i; i < signers.length; ) {\\n            signer = signers[i];\\n\\n            // Prevent zero and duplicate signers.\\n            if (previous >= signer) revert InvalidSig();\\n\\n            previous = signer;\\n\\n            emit TransferSingle(tx.origin, address(0), signer, SIGN_KEY, 1);\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++balanceOf[signer][SIGN_KEY];\\n                ++supply;\\n                ++i;\\n            }\\n        }\\n\\n        totalSupply[SIGN_KEY] = supply;\\n        quorum = uint120(threshold);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Execution Logic\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Execute operation from Keep with signatures.\\n    /// @param op Enum operation to execute.\\n    /// @param to Address to send operation to.\\n    /// @param value Amount of ETH to send in operation.\\n    /// @param data Payload to send in operation.\\n    /// @param sigs Array of Keep signatures in ascending order by addresses.\\n    function execute(\\n        Operation op,\\n        address to,\\n        uint256 value,\\n        bytes calldata data,\\n        Signature[] calldata sigs\\n    ) public payable virtual {\\n        uint120 txNonce;\\n\\n        // Unchecked because the only math done is incrementing\\n        // Keep nonce which cannot realistically overflow.\\n        unchecked {\\n            emit Executed(txNonce = nonce++, op, to, value, data);\\n        }\\n\\n        // Begin signature validation with hashed inputs.\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR(),\\n                keccak256(\\n                    abi.encode(\\n                        keccak256(\\n                            \\\"Execute(uint8 op,address to,uint256 value,bytes data,uint120 nonce)\\\"\\n                        ),\\n                        op,\\n                        to,\\n                        value,\\n                        keccak256(data),\\n                        txNonce\\n                    )\\n                )\\n            )\\n        );\\n\\n        // Start zero in loop to ensure ascending addresses.\\n        address previous;\\n\\n        // Validation is length of quorum threshold.\\n        uint256 threshold = quorum;\\n\\n        // Store outside loop for gas optimization.\\n        Signature calldata sig;\\n\\n        for (uint256 i; i < threshold; ) {\\n            // Load signature items.\\n            sig = sigs[i];\\n            address user = sig.user;\\n\\n            // Check SIGN_KEY balance.\\n            // This also confirms non-zero `user`.\\n            if (balanceOf[user][SIGN_KEY] == 0) revert InvalidSig();\\n\\n            // Check signature recovery.\\n            _recoverSig(hash, user, sig.v, sig.r, sig.s);\\n\\n            // Check against duplicates.\\n            if (previous >= user) revert InvalidSig();\\n\\n            // Memo signature for next iteration until quorum.\\n            previous = user;\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        _execute(op, to, value, data);\\n    }\\n\\n    /// @notice Relay operation from Keep via `execute()` or as ID key holder.\\n    /// @param call Keep operation as struct of `op, to, value, data`.\\n    function relay(Call calldata call) public payable virtual {\\n        _authorized();\\n\\n        _execute(call.op, call.to, call.value, call.data);\\n\\n        emit Relayed(call);\\n    }\\n\\n    /// @notice Relay operations from Keep via `execute()` or as ID key holder.\\n    /// @param calls Keep operations as struct arrays of `op, to, value, data`.\\n    function multirelay(Call[] calldata calls) public payable virtual {\\n        _authorized();\\n\\n        for (uint256 i; i < calls.length; ) {\\n            _execute(calls[i].op, calls[i].to, calls[i].value, calls[i].data);\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit Multirelayed(calls);\\n    }\\n\\n    function _execute(\\n        Operation op,\\n        address to,\\n        uint256 value,\\n        bytes memory data\\n    ) internal virtual {\\n        if (op == Operation.call) {\\n            bool success;\\n\\n            assembly {\\n                success := call(\\n                    gas(),\\n                    to,\\n                    value,\\n                    add(data, 0x20),\\n                    mload(data),\\n                    0,\\n                    0\\n                )\\n            }\\n\\n            if (!success) revert ExecuteFailed();\\n        } else if (op == Operation.delegatecall) {\\n            bool success;\\n\\n            assembly {\\n                success := delegatecall(\\n                    gas(),\\n                    to,\\n                    add(data, 0x20),\\n                    mload(data),\\n                    0,\\n                    0\\n                )\\n            }\\n\\n            if (!success) revert ExecuteFailed();\\n        } else {\\n            assembly {\\n                to := create(value, add(data, 0x20), mload(data))\\n            }\\n\\n            if (to == address(0)) revert ExecuteFailed();\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Mint/Burn Logic\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice ID minter.\\n    /// @param to Recipient of mint.\\n    /// @param id ID to mint.\\n    /// @param amount ID balance to mint.\\n    /// @param data Optional data payload.\\n    function mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public payable virtual {\\n        _authorized();\\n\\n        _mint(to, id, amount, data);\\n    }\\n\\n    /// @notice ID burner.\\n    /// @param from Account to burn from.\\n    /// @param id ID to burn.\\n    /// @param amount Balance to burn.\\n    function burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) public payable virtual {\\n        if (msg.sender != from)\\n            if (!isApprovedForAll[from][msg.sender])\\n                if (!_authorized()) revert Unauthorized();\\n\\n        _burn(from, id, amount);\\n\\n        if (id == SIGN_KEY)\\n            if (quorum > totalSupply[SIGN_KEY]) revert QuorumOverSupply();\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Threshold Setting Logic\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice Update Keep quorum threshold.\\n    /// @param threshold Signature threshold for `execute()`.\\n    function setQuorum(uint256 threshold) public payable virtual {\\n        _authorized();\\n\\n        if (threshold == 0) revert InvalidThreshold();\\n\\n        if (threshold > totalSupply[SIGN_KEY]) revert QuorumOverSupply();\\n\\n        quorum = uint120(threshold);\\n\\n        emit QuorumSet(threshold);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ID Setting Logic\\n    /// -----------------------------------------------------------------------\\n\\n    /// @notice ID transferability setting.\\n    /// @param id ID to set transferability for.\\n    /// @param on Transferability setting.\\n    function setTransferability(uint256 id, bool on) public payable virtual {\\n        _authorized();\\n\\n        _setTransferability(id, on);\\n    }\\n\\n    /// @notice ID transfer permission toggle.\\n    /// @param id ID to set permission for.\\n    /// @param on Permission setting.\\n    /// @dev This sets account-based ID restriction globally.\\n    function setPermission(uint256 id, bool on) public payable virtual {\\n        _authorized();\\n\\n        _setPermission(id, on);\\n    }\\n\\n    /// @notice ID transfer permission setting.\\n    /// @param to Account to set permission for.\\n    /// @param id ID to set permission for.\\n    /// @param on Permission setting.\\n    /// @dev This sets account-based ID restriction specifically.\\n    function setUserPermission(\\n        address to,\\n        uint256 id,\\n        bool on\\n    ) public payable virtual {\\n        _authorized();\\n\\n        _setUserPermission(to, id, on);\\n    }\\n\\n    /// @notice ID metadata setting.\\n    /// @param id ID to set metadata for.\\n    /// @param tokenURI Metadata setting.\\n    function setURI(uint256 id, string calldata tokenURI)\\n        public\\n        payable\\n        virtual\\n    {\\n        _authorized();\\n\\n        _uris[id] = tokenURI;\\n\\n        emit URI(tokenURI, id);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/KeepFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\nimport {Multicallable, Call, Keep} from \\\"./Keep.sol\\\";\\nimport {LibClone} from \\\"./utils/LibClone.sol\\\";\\n\\n/// @notice Keep Factory.\\ncontract KeepFactory is Multicallable {\\n    /// -----------------------------------------------------------------------\\n    /// Library Usage\\n    /// -----------------------------------------------------------------------\\n\\n    using LibClone for address;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event Deployed(address indexed keep, address[] signers, uint256 threshold);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Immutables\\n    /// -----------------------------------------------------------------------\\n\\n    address internal immutable keepTemplate;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Constructor\\n    /// -----------------------------------------------------------------------\\n\\n    constructor(address _keepTemplate) payable {\\n        keepTemplate = _keepTemplate;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Deployment Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function determineKeep(bytes32 name) public view virtual returns (address) {\\n        return\\n            keepTemplate.predictDeterministicAddress(\\n                abi.encodePacked(name),\\n                name,\\n                address(this)\\n            );\\n    }\\n\\n    function deployKeep(\\n        bytes32 name, // create2 salt.\\n        Call[] calldata calls,\\n        address[] calldata signers,\\n        uint256 threshold\\n    ) public payable virtual {\\n        address keep = keepTemplate.cloneDeterministic(\\n            abi.encodePacked(name),\\n            name\\n        );\\n\\n        Keep(keep).initialize{value: msg.value}(calls, signers, threshold);\\n\\n        emit Deployed(keep, signers, threshold);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/KeepToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice ERC1155 interface to receive tokens.\\n/// @author Modified from Solbase (https://github.com/Sol-DAO/solbase/blob/main/src/tokens/ERC1155/ERC1155.sol)\\nabstract contract ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address,\\n        address,\\n        uint256,\\n        uint256,\\n        bytes calldata\\n    ) public payable virtual returns (bytes4) {\\n        return this.onERC1155Received.selector;\\n    }\\n\\n    function onERC1155BatchReceived(\\n        address,\\n        address,\\n        uint256[] calldata,\\n        uint256[] calldata,\\n        bytes calldata\\n    ) public payable virtual returns (bytes4) {\\n        return this.onERC1155BatchReceived.selector;\\n    }\\n}\\n\\n/// @notice Modern, minimalist, and gas-optimized ERC1155 implementation with Compound-style voting and flexible permissioning scheme.\\n/// @author Modified from ERC1155V (https://github.com/kalidao/ERC1155V/blob/main/src/ERC1155V.sol)\\n/// @author Modified from Compound (https://github.com/compound-finance/compound-protocol/blob/master/contracts/Governance/Comp.sol)\\nabstract contract KeepToken {\\n    /// -----------------------------------------------------------------------\\n    /// Events\\n    /// -----------------------------------------------------------------------\\n\\n    event DelegateChanged(\\n        address indexed delegator,\\n        address indexed fromDelegate,\\n        address indexed toDelegate,\\n        uint256 id\\n    );\\n\\n    event DelegateVotesChanged(\\n        address indexed delegate,\\n        uint256 indexed id,\\n        uint256 previousBalance,\\n        uint256 newBalance\\n    );\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    event TransferabilitySet(\\n        address indexed operator,\\n        uint256 indexed id,\\n        bool on\\n    );\\n\\n    event PermissionSet(address indexed operator, uint256 indexed id, bool on);\\n\\n    event UserPermissionSet(\\n        address indexed operator,\\n        address indexed to,\\n        uint256 indexed id,\\n        bool on\\n    );\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    error InvalidSig();\\n\\n    error LengthMismatch();\\n\\n    error Unauthorized();\\n\\n    error NonTransferable();\\n\\n    error NotPermitted();\\n\\n    error UnsafeRecipient();\\n\\n    error InvalidRecipient();\\n\\n    error ExpiredSig();\\n\\n    error Undetermined();\\n\\n    error Overflow();\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC1155 Storage\\n    /// -----------------------------------------------------------------------\\n\\n    mapping(address => mapping(uint256 => uint256)) public balanceOf;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /// -----------------------------------------------------------------------\\n    /// EIP-712 Storage/Logic\\n    /// -----------------------------------------------------------------------\\n\\n    bytes32 internal constant MALLEABILITY_THRESHOLD =\\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    // `keccak256(\\n                    //     \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                    // )`\\n                    0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\\n                    // `keccak256(bytes(\\\"Keep\\\"))`\\n                    0x21d66785fec14e4da3d76f3866cf99a28f4da49ec8782c3cab7cf79c1b6fa66b,\\n                    // `keccak256(\\\"1\\\")`\\n                    0xc89efdaa54c0f20c7adf612882df0950f5a951637e0307cdcb4c672f298b8bc6,\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    function _recoverSig(\\n        bytes32 hash,\\n        address signer,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal view virtual {\\n        bool isValid;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Clean the upper 96 bits of `signer` in case they are dirty.\\n            for {\\n                signer := shr(96, shl(96, signer))\\n            } signer {\\n\\n            } {\\n                // Load the free memory pointer.\\n                // Simply using the free memory usually costs less if many slots are needed.\\n                let m := mload(0x40)\\n\\n                // Clean the excess bits of `v` in case they are dirty.\\n                v := and(v, 0xff)\\n                // If `s` in lower half order, such that the signature is not malleable.\\n                if iszero(gt(s, MALLEABILITY_THRESHOLD)) {\\n                    mstore(m, hash)\\n                    mstore(add(m, 0x20), v)\\n                    mstore(add(m, 0x40), r)\\n                    mstore(add(m, 0x60), s)\\n                    pop(\\n                        staticcall(\\n                            gas(), // Amount of gas left for the transaction.\\n                            0x01, // Address of `ecrecover`.\\n                            m, // Start of input.\\n                            0x80, // Size of input.\\n                            m, // Start of output.\\n                            0x20 // Size of output.\\n                        )\\n                    )\\n                    // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\\n                    if mul(eq(mload(m), signer), returndatasize()) {\\n                        isValid := 1\\n                        break\\n                    }\\n                }\\n\\n                // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                let f := shl(224, 0x1626ba7e)\\n                // Write the abi-encoded calldata into memory, beginning with the function selector.\\n                mstore(m, f) // `bytes4(keccak256(\\\"isValidSignature(bytes32,bytes)\\\"))`.\\n                mstore(add(m, 0x04), hash)\\n                mstore(add(m, 0x24), 0x40) // The offset of the `signature` in the calldata.\\n                mstore(add(m, 0x44), 65) // Store the length of the signature.\\n                mstore(add(m, 0x64), r) // Store `r` of the signature.\\n                mstore(add(m, 0x84), s) // Store `s` of the signature.\\n                mstore8(add(m, 0xa4), v) // Store `v` of the signature.\\n\\n                isValid := and(\\n                    and(\\n                        // Whether the returndata is the magic value `0x1626ba7e` (left-aligned).\\n                        eq(mload(0x00), f),\\n                        // Whether the returndata is exactly 0x20 bytes (1 word) long.\\n                        eq(returndatasize(), 0x20)\\n                    ),\\n                    // Whether the staticcall does not revert.\\n                    // This must be placed at the end of the `and` clause,\\n                    // as the arguments are evaluated from right to left.\\n                    staticcall(\\n                        gas(), // Remaining gas.\\n                        signer, // The `signer` address.\\n                        m, // Offset of calldata in memory.\\n                        0xa5, // Length of calldata in memory.\\n                        0x00, // Offset of returndata.\\n                        0x20 // Length of returndata to write.\\n                    )\\n                )\\n                break\\n            }\\n        }\\n\\n        if (!isValid) revert InvalidSig();\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ID Storage\\n    /// -----------------------------------------------------------------------\\n\\n    uint256 internal constant SIGN_KEY = uint32(0x6c4b5546); // `execute()`\\n\\n    mapping(uint256 => uint256) public totalSupply;\\n\\n    mapping(uint256 => bool) public transferable;\\n\\n    mapping(uint256 => bool) public permissioned;\\n\\n    mapping(address => mapping(uint256 => bool)) public userPermissioned;\\n\\n    /// -----------------------------------------------------------------------\\n    /// Checkpoint Storage\\n    /// -----------------------------------------------------------------------\\n\\n    mapping(address => mapping(uint256 => address)) internal _delegates;\\n\\n    mapping(address => mapping(uint256 => uint256)) public numCheckpoints;\\n\\n    mapping(address => mapping(uint256 => mapping(uint256 => Checkpoint)))\\n        public checkpoints;\\n\\n    struct Checkpoint {\\n        uint40 fromTimestamp;\\n        uint216 votes;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Metadata Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function name() public pure virtual returns (string memory) {\\n        uint256 placeholder;\\n\\n        assembly {\\n            placeholder := sub(\\n                calldatasize(),\\n                add(shr(240, calldataload(sub(calldatasize(), 2))), 2)\\n            )\\n\\n            placeholder := calldataload(add(placeholder, 2))\\n        }\\n\\n        return string(abi.encodePacked(placeholder));\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC165 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function supportsInterface(\\n        bytes4 interfaceId\\n    ) public view virtual returns (bool) {\\n        return\\n            // ERC165 interface ID for ERC165.\\n            interfaceId == this.supportsInterface.selector ||\\n            // ERC165 interface ID for ERC1155.\\n            interfaceId == 0xd9b67a26;\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// ERC1155 Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function balanceOfBatch(\\n        address[] calldata owners,\\n        uint256[] calldata ids\\n    ) public view virtual returns (uint256[] memory balances) {\\n        if (owners.length != ids.length) revert LengthMismatch();\\n\\n        balances = new uint256[](owners.length);\\n\\n        for (uint256 i; i < owners.length; ) {\\n            balances[i] = balanceOf[owners[i]][ids[i]];\\n\\n            // Unchecked because the only math done is incrementing\\n            // the array index counter which cannot possibly overflow.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function setApprovalForAll(\\n        address operator,\\n        bool approved\\n    ) public payable virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) public payable virtual {\\n        if (msg.sender != from)\\n            if (!isApprovedForAll[from][msg.sender]) revert Unauthorized();\\n\\n        if (!transferable[id]) revert NonTransferable();\\n\\n        if (permissioned[id])\\n            if (!userPermissioned[to][id] || !userPermissioned[from][id])\\n                revert NotPermitted();\\n\\n        // If not transferring SIGN_KEY, update delegation balance.\\n        // Otherwise, prevent transfer to SIGN_KEY holder.\\n        if (id != SIGN_KEY)\\n            _moveDelegates(delegates(from, id), delegates(to, id), id, amount);\\n        else if (balanceOf[to][id] != 0) revert Overflow();\\n\\n        balanceOf[from][id] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to][id] += amount;\\n        }\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC1155TokenReceiver(to).onERC1155Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                ) != ERC1155TokenReceiver.onERC1155Received.selector\\n            ) revert UnsafeRecipient();\\n        } else if (to == address(0)) revert InvalidRecipient();\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) public payable virtual {\\n        if (ids.length != amounts.length) revert LengthMismatch();\\n\\n        if (msg.sender != from)\\n            if (!isApprovedForAll[from][msg.sender]) revert Unauthorized();\\n\\n        // Storing these outside the loop saves ~15 gas per iteration.\\n        uint256 id;\\n        uint256 amount;\\n\\n        for (uint256 i; i < ids.length; ) {\\n            id = ids[i];\\n            amount = amounts[i];\\n\\n            if (!transferable[id]) revert NonTransferable();\\n\\n            if (permissioned[id])\\n                if (!userPermissioned[to][id] || !userPermissioned[from][id])\\n                    revert NotPermitted();\\n\\n            // If not transferring SIGN_KEY, update delegation balance.\\n            // Otherwise, prevent transfer to SIGN_KEY holder.\\n            if (id != SIGN_KEY)\\n                _moveDelegates(\\n                    delegates(from, id),\\n                    delegates(to, id),\\n                    id,\\n                    amount\\n                );\\n            else if (balanceOf[to][id] != 0) revert Overflow();\\n\\n            balanceOf[from][id] -= amount;\\n\\n            // Cannot overflow because the sum of all user\\n            // balances can't exceed the max uint256 value.\\n            unchecked {\\n                balanceOf[to][id] += amount;\\n            }\\n\\n            // An array can't have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC1155TokenReceiver(to).onERC1155BatchReceived(\\n                    msg.sender,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                ) != ERC1155TokenReceiver.onERC1155BatchReceived.selector\\n            ) revert UnsafeRecipient();\\n        } else if (to == address(0)) revert InvalidRecipient();\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// EIP-2612-style Permit Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function permit(\\n        address owner,\\n        address operator,\\n        bool approved,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public payable virtual {\\n        if (owner == address(0)) revert InvalidSig();\\n\\n        if (block.timestamp > deadline) revert ExpiredSig();\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 hash = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(\\n                        abi.encode(\\n                            keccak256(\\n                                \\\"Permit(address owner,address operator,bool approved,uint256 nonce,uint256 deadline)\\\"\\n                            ),\\n                            owner,\\n                            operator,\\n                            approved,\\n                            nonces[owner]++,\\n                            deadline\\n                        )\\n                    )\\n                )\\n            );\\n\\n            _recoverSig(hash, owner, v, r, s);\\n        }\\n\\n        isApprovedForAll[owner][operator] = approved;\\n\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Checkpoint Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function getVotes(\\n        address account,\\n        uint256 id\\n    ) public view virtual returns (uint256) {\\n        return getCurrentVotes(account, id);\\n    }\\n\\n    function getCurrentVotes(\\n        address account,\\n        uint256 id\\n    ) public view virtual returns (uint256) {\\n        // Unchecked because subtraction only occurs if positive `nCheckpoints`.\\n        unchecked {\\n            uint256 nCheckpoints = numCheckpoints[account][id];\\n\\n            uint256 result;\\n\\n            if (nCheckpoints != 0)\\n                result = checkpoints[account][id][nCheckpoints - 1].votes;\\n\\n            return result;\\n        }\\n    }\\n\\n    function getPastVotes(\\n        address account,\\n        uint256 id,\\n        uint256 timestamp\\n    ) public view virtual returns (uint256) {\\n        return getPriorVotes(account, id, timestamp);\\n    }\\n\\n    function getPriorVotes(\\n        address account,\\n        uint256 id,\\n        uint256 timestamp\\n    ) public view virtual returns (uint256) {\\n        if (block.timestamp <= timestamp) revert Undetermined();\\n\\n        uint256 nCheckpoints = numCheckpoints[account][id];\\n\\n        if (nCheckpoints == 0) return 0;\\n\\n        // Unchecked because subtraction only occurs if positive `nCheckpoints`.\\n        unchecked {\\n            uint256 prevCheckpoint = nCheckpoints - 1;\\n\\n            if (\\n                checkpoints[account][id][prevCheckpoint].fromTimestamp <=\\n                timestamp\\n            ) return checkpoints[account][id][prevCheckpoint].votes;\\n\\n            if (checkpoints[account][id][0].fromTimestamp > timestamp) return 0;\\n\\n            uint256 lower;\\n\\n            uint256 upper = prevCheckpoint;\\n\\n            while (upper > lower) {\\n                uint256 center = upper - (upper - lower) / 2;\\n\\n                Checkpoint memory cp = checkpoints[account][id][center];\\n\\n                if (cp.fromTimestamp == timestamp) {\\n                    return cp.votes;\\n                } else if (cp.fromTimestamp < timestamp) {\\n                    lower = center;\\n                } else {\\n                    upper = center - 1;\\n                }\\n            }\\n\\n            return checkpoints[account][id][lower].votes;\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Delegation Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function delegates(\\n        address account,\\n        uint256 id\\n    ) public view virtual returns (address) {\\n        address current = _delegates[account][id];\\n\\n        if (current == address(0)) current = account;\\n\\n        return current;\\n    }\\n\\n    function delegate(address delegatee, uint256 id) public payable virtual {\\n        _delegate(msg.sender, delegatee, id);\\n    }\\n\\n    function delegateBySig(\\n        address delegator,\\n        address delegatee,\\n        uint256 id,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public payable virtual {\\n        if (delegator == address(0)) revert InvalidSig();\\n\\n        if (block.timestamp > deadline) revert ExpiredSig();\\n\\n        // Unchecked because the only math done is incrementing\\n        // the delegator's nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 hash = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(\\n                        abi.encode(\\n                            keccak256(\\n                                \\\"Delegation(address delegator,address delegatee,uint256 id,uint256 nonce,uint256 deadline)\\\"\\n                            ),\\n                            delegator,\\n                            delegatee,\\n                            id,\\n                            nonces[delegator]++,\\n                            deadline\\n                        )\\n                    )\\n                )\\n            );\\n\\n            _recoverSig(hash, delegator, v, r, s);\\n        }\\n\\n        _delegate(delegator, delegatee, id);\\n    }\\n\\n    function _delegate(\\n        address delegator,\\n        address delegatee,\\n        uint256 id\\n    ) internal virtual {\\n        address currentDelegate = delegates(delegator, id);\\n\\n        _delegates[delegator][id] = delegatee;\\n\\n        emit DelegateChanged(delegator, currentDelegate, delegatee, id);\\n\\n        _moveDelegates(\\n            currentDelegate,\\n            delegatee,\\n            id,\\n            balanceOf[delegator][id]\\n        );\\n    }\\n\\n    function _moveDelegates(\\n        address srcRep,\\n        address dstRep,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        if (srcRep != dstRep) {\\n            if (amount != 0) {\\n                if (srcRep != address(0)) {\\n                    uint256 srcRepNum = numCheckpoints[srcRep][id];\\n\\n                    uint256 srcRepOld;\\n\\n                    // Unchecked because subtraction only occurs if positive `srcRepNum`.\\n                    unchecked {\\n                        srcRepOld = srcRepNum != 0\\n                            ? checkpoints[srcRep][id][srcRepNum - 1].votes\\n                            : 0;\\n                    }\\n\\n                    _writeCheckpoint(\\n                        srcRep,\\n                        id,\\n                        srcRepNum,\\n                        srcRepOld,\\n                        srcRepOld - amount\\n                    );\\n                }\\n\\n                if (dstRep != address(0)) {\\n                    uint256 dstRepNum = numCheckpoints[dstRep][id];\\n\\n                    uint256 dstRepOld;\\n\\n                    // Unchecked because subtraction only occurs if positive `dstRepNum`.\\n                    unchecked {\\n                        if (dstRepNum != 0)\\n                            dstRepOld = checkpoints[dstRep][id][dstRepNum - 1]\\n                                .votes;\\n                    }\\n\\n                    _writeCheckpoint(\\n                        dstRep,\\n                        id,\\n                        dstRepNum,\\n                        dstRepOld,\\n                        dstRepOld + amount\\n                    );\\n                }\\n            }\\n        }\\n    }\\n\\n    function _writeCheckpoint(\\n        address delegatee,\\n        uint256 id,\\n        uint256 nCheckpoints,\\n        uint256 oldVotes,\\n        uint256 newVotes\\n    ) internal virtual {\\n        emit DelegateVotesChanged(delegatee, id, oldVotes, newVotes);\\n\\n        // Unchecked because subtraction only occurs if positive `nCheckpoints`.\\n        unchecked {\\n            if (nCheckpoints != 0) {\\n                if (\\n                    checkpoints[delegatee][id][nCheckpoints - 1]\\n                        .fromTimestamp == block.timestamp\\n                ) {\\n                    checkpoints[delegatee][id][nCheckpoints - 1]\\n                        .votes = _safeCastTo216(newVotes);\\n                    return;\\n                }\\n            }\\n\\n            checkpoints[delegatee][id][nCheckpoints] = Checkpoint(\\n                _safeCastTo40(block.timestamp),\\n                _safeCastTo216(newVotes)\\n            );\\n\\n            // Unchecked because the only math done is incrementing\\n            // checkpoints which cannot realistically overflow.\\n            ++numCheckpoints[delegatee][id];\\n        }\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Safecast Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function _safeCastTo40(uint256 x) internal pure virtual returns (uint40) {\\n        if (x >= (1 << 40)) revert Overflow();\\n\\n        return uint40(x);\\n    }\\n\\n    function _safeCastTo216(uint256 x) internal pure virtual returns (uint216) {\\n        if (x >= (1 << 216)) revert Overflow();\\n\\n        return uint216(x);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal Mint/Burn Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) internal virtual {\\n        _safeCastTo216(totalSupply[id] += amount);\\n\\n        // If not minting SIGN_KEY, update delegation balance.\\n        // Otherwise, prevent minting to SIGN_KEY holder.\\n        if (id != SIGN_KEY)\\n            _moveDelegates(address(0), delegates(to, id), id, amount);\\n        else if (balanceOf[to][id] != 0) revert Overflow();\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to][id] += amount;\\n        }\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        if (to.code.length != 0) {\\n            if (\\n                ERC1155TokenReceiver(to).onERC1155Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    amount,\\n                    data\\n                ) != ERC1155TokenReceiver.onERC1155Received.selector\\n            ) revert UnsafeRecipient();\\n        } else if (to == address(0)) revert InvalidRecipient();\\n    }\\n\\n    function _burn(address from, uint256 id, uint256 amount) internal virtual {\\n        balanceOf[from][id] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply[id] -= amount;\\n        }\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n\\n        // If not burning SIGN_KEY, update delegation balance.\\n        if (id != SIGN_KEY)\\n            _moveDelegates(delegates(from, id), address(0), id, amount);\\n    }\\n\\n    /// -----------------------------------------------------------------------\\n    /// Internal Permission Logic\\n    /// -----------------------------------------------------------------------\\n\\n    function _setTransferability(uint256 id, bool on) internal virtual {\\n        transferable[id] = on;\\n\\n        emit TransferabilitySet(msg.sender, id, on);\\n    }\\n\\n    function _setPermission(uint256 id, bool on) internal virtual {\\n        permissioned[id] = on;\\n\\n        emit PermissionSet(msg.sender, id, on);\\n    }\\n\\n    function _setUserPermission(\\n        address to,\\n        uint256 id,\\n        bool on\\n    ) internal virtual {\\n        userPermissioned[to][id] = on;\\n\\n        emit UserPermissionSet(msg.sender, to, id, on);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/LibClone.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Minimal proxy library with immutable args operations.\\n/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibClone.sol)\\nlibrary LibClone {\\n    /// -----------------------------------------------------------------------\\n    /// Custom Errors\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Unable to deploy the clone.\\n    error DeploymentFailed();\\n\\n    /// -----------------------------------------------------------------------\\n    /// Clone Operations\\n    /// -----------------------------------------------------------------------\\n\\n    /// @dev Deploys a deterministic clone of `implementation`,\\n    /// using immutable arguments encoded in `data`, with `salt`.\\n    function cloneDeterministic(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt\\n    ) internal returns (address instance) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(\\n                    shl(0x48, extraLength),\\n                    0x593da1005b363d3d373d3d3d3d610000806062363936013d73\\n                )\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`.\\n            mstore(\\n                sub(data, 0x3a),\\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(\\n                    shl(0x78, add(extraLength, 0x62)),\\n                    0x6100003d81600a3d39f336602c57343d527f\\n                )\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Create the instance.\\n            instance := create2(\\n                0,\\n                sub(data, 0x4c),\\n                add(extraLength, 0x6c),\\n                salt\\n            )\\n\\n            // If `instance` is zero, revert.\\n            if iszero(instance) {\\n                // Store the function selector of `DeploymentFailed()`.\\n                mstore(0x00, 0x30116425)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n\\n    /// @dev Returns the address of the deterministic clone of\\n    /// `implementation` using immutable arguments encoded in `data`, with `salt`, by `deployer`.\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes memory data,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        assembly {\\n            // Compute the boundaries of the data and cache the memory slots around it.\\n            let mBefore3 := mload(sub(data, 0x60))\\n            let mBefore2 := mload(sub(data, 0x40))\\n            let mBefore1 := mload(sub(data, 0x20))\\n            let dataLength := mload(data)\\n            let dataEnd := add(add(data, 0x20), dataLength)\\n            let mAfter1 := mload(dataEnd)\\n\\n            // +2 bytes for telling how much data there is appended to the call.\\n            let extraLength := add(dataLength, 2)\\n\\n            // Write the bytecode before the data.\\n            mstore(data, 0x5af43d3d93803e606057fd5bf3)\\n            // Write the address of the implementation.\\n            mstore(sub(data, 0x0d), implementation)\\n            // Write the rest of the bytecode.\\n            mstore(\\n                sub(data, 0x21),\\n                or(\\n                    shl(0x48, extraLength),\\n                    0x593da1005b363d3d373d3d3d3d610000806062363936013d73\\n                )\\n            )\\n            // `keccak256(\\\"ReceiveETH(uint256)\\\")`.\\n            mstore(\\n                sub(data, 0x3a),\\n                0x9e4ac34f21c619cefc926c8bd93b54bf5a39c7ab2127a895af1cc0691d7e3dff\\n            )\\n            mstore(\\n                sub(data, 0x5a),\\n                or(\\n                    shl(0x78, add(extraLength, 0x62)),\\n                    0x6100003d81600a3d39f336602c57343d527f\\n                )\\n            )\\n            mstore(dataEnd, shl(0xf0, extraLength))\\n\\n            // Compute and store the bytecode hash.\\n            mstore(0x35, keccak256(sub(data, 0x4c), add(extraLength, 0x6c)))\\n            mstore8(0x00, 0xff) // Write the prefix.\\n            mstore(0x01, shl(96, deployer))\\n            mstore(0x15, salt)\\n            predicted := keccak256(0x00, 0x55)\\n            // Restore the part of the free memory pointer that has been overwritten.\\n            mstore(0x35, 0)\\n\\n            // Restore the overwritten memory surrounding `data`.\\n            mstore(dataEnd, mAfter1)\\n            mstore(data, dataLength)\\n            mstore(sub(data, 0x20), mBefore1)\\n            mstore(sub(data, 0x40), mBefore2)\\n            mstore(sub(data, 0x60), mBefore3)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/utils/Multicallable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Contract that enables a single call to call multiple methods on itself.\\n/// @author Modified from Solady (https://github.com/vectorized/solady/blob/main/src/utils/Multicallable.sol)\\n/// @dev WARNING!\\n/// Multicallable is NOT SAFE for use in contracts with checks / requires on `msg.value`\\n/// (e.g. in NFT minting / auction contracts) without a suitable nonce mechanism.\\n/// It WILL open up your contract to double-spend vulnerabilities / exploits.\\n/// See: (https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong/)\\nabstract contract Multicallable {\\n    /// @dev Apply `DELEGATECALL` with the current contract to each calldata in `data`,\\n    /// and store the `abi.encode` formatted results of each `DELEGATECALL` into `results`.\\n    /// If any of the `DELEGATECALL`s reverts, the entire transaction is reverted,\\n    /// and the error is bubbled up.\\n    function multicall(\\n        bytes[] calldata data\\n    ) public payable virtual returns (bytes[] memory) {\\n        assembly {\\n            mstore(0x00, 0x20)\\n            mstore(0x20, data.length) // Store `data.length` into `results`.\\n            // Early return if no data.\\n            if iszero(data.length) {\\n                return(0x00, 0x40)\\n            }\\n\\n            let results := 0x40\\n            // `shl` 5 is equivalent to multiplying by 0x20.\\n            let end := shl(5, data.length)\\n            // Copy the offsets from calldata into memory.\\n            calldatacopy(0x40, data.offset, end)\\n            // Pointer to the top of the memory (i.e. start of the free memory).\\n            let resultsOffset := end\\n\\n            for {\\n                end := add(results, end)\\n            } 1 {\\n\\n            } {\\n                // The offset of the current bytes in the calldata.\\n                let o := add(data.offset, mload(results))\\n                let memPtr := add(resultsOffset, 0x40)\\n                // Copy the current bytes from calldata to the memory.\\n                calldatacopy(\\n                    memPtr,\\n                    add(o, 0x20), // The offset of the current bytes' bytes.\\n                    calldataload(o) // The length of the current bytes.\\n                )\\n                if iszero(\\n                    delegatecall(\\n                        gas(),\\n                        address(),\\n                        memPtr,\\n                        calldataload(o),\\n                        0x00,\\n                        0x00\\n                    )\\n                ) {\\n                    // Bubble up the revert if the delegatecall reverts.\\n                    returndatacopy(0x00, 0x00, returndatasize())\\n                    revert(0x00, returndatasize())\\n                }\\n                // Append the current `resultsOffset` into `results`.\\n                mstore(results, resultsOffset)\\n                results := add(results, 0x20)\\n                // Append the `returndatasize()`, and the return data.\\n                mstore(memPtr, returndatasize())\\n                returndatacopy(add(memPtr, 0x20), 0x00, returndatasize())\\n                // Advance the `resultsOffset` by `returndatasize() + 0x20`,\\n                // rounded up to the next multiple of 32.\\n                resultsOffset := and(\\n                    add(add(resultsOffset, returndatasize()), 0x3f),\\n                    0xffffffffffffffe0\\n                )\\n                if iszero(lt(results, end)) {\\n                    break\\n                }\\n            }\\n            return(0x00, add(resultsOffset, 0x40))\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@ds/=lib/rage-router/lib/ds-test/src/\",\r\n      \"@solbase/=lib/solbase/\",\r\n      \"@std/=lib/forge-std/src/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"rage-router/=lib/rage-router/\",\r\n      \"solbase/=lib/solbase/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 9999999\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_keepTemplate\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"keep\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"enum Operation\",\"name\":\"op\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Call[]\",\"name\":\"calls\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"signers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"deployKeep\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"determineKeep\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "KeepFactory", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "9999999", "ConstructorArguments": "00000000000000000000000000000000000058018b54c271615d94645b9aab81", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}