{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"NativasFactory.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n/// @by: Nativas ClimaTech\\n/// @author: Juan Pablo Crespi\\n/// @dev: https://eips.ethereum.org/EIPS/eip-1167\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IAccessControl.sol\\\";\\nimport \\\"IERC165.sol\\\";\\nimport \\\"Context.sol\\\";\\nimport \\\"Clones.sol\\\";\\nimport \\\"IERC1155Holder.sol\\\";\\nimport \\\"Controllable.sol\\\";\\nimport \\\"NativasRoles.sol\\\";\\n\\n/**\\n * ERC1167 implementation to create new holders\\n */\\ncontract NativasFactory is Context, Controllable {\\n    using Clones for address;\\n\\n    // NativasHolder template\\n    address internal _template;\\n    // Mapping user id to holder address\\n    mapping(uint256 => address) internal _holders;\\n\\n    /**\\n     * @dev MUST trigger when a new holder is created.\\n     */\\n    event HolderCreated(\\n        uint256 indexed holderId,\\n        address indexed holderAddress\\n    );\\n\\n    /**\\n     * @dev Set NativasHolder contract template.\\n     */\\n    constructor(address controller_, address template_)\\n        Controllable(controller_)\\n    {\\n        _setTemplate(template_);\\n    }\\n\\n    /**\\n     * @dev get holder contract template\\n     */\\n    function template() public view virtual returns (address) {\\n        return _template;\\n    }\\n\\n    /**\\n     * @dev get holder contract by holderId.\\n     */\\n    function getHolder(uint256 holderId) public view virtual returns (address) {\\n        return _holders[holderId];\\n    }\\n\\n    /**\\n     * @dev See {Controllable-_safeTransferControl}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be admin.\\n     * - new controller must implement IAccessControl interface\\n     */\\n    function transferControl(address controller_) public virtual {\\n        require(\\n            _hasRole(Roles.ADMIN_ROLE),\\n            \\\"NativasFactory: caller must have admin role to tranfer control\\\"\\n        );\\n        require(\\n            controller_ != address(0),\\n            \\\"NativasFactory: new controller is the zero address\\\"\\n        );\\n        require(\\n            IERC165(controller_).supportsInterface(\\n                type(IAccessControl).interfaceId\\n            ),\\n            \\\"NativasFactory: new controller does not support IAccessControl interface\\\"\\n        );\\n        _transferControl(controller_);\\n    }\\n\\n    /**\\n     * @dev See {NativasFactory-_setHolder}\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be editor.\\n     */\\n    function setHolder(\\n        address entity_,\\n        uint256 holderId_,\\n        string memory nin_,\\n        string memory name_,\\n        address controller_,\\n        address operator_\\n    ) public virtual {\\n        require(\\n            _hasRole(Roles.MANAGER_ROLE),\\n            \\\"NativasFactory: caller must have manager role to set holder\\\"\\n        );\\n        _setHolder(entity_, holderId_, nin_, name_, operator_, controller_);\\n    }\\n\\n    /**\\n     * @dev See {NativasFactory-_updateTemplate}\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be editor.\\n     */\\n    function setTemplate(address template_) public virtual {\\n        require(\\n            _hasRole(Roles.ADMIN_ROLE),\\n            \\\"NativasFactory: caller must have admin role to set template\\\"\\n        );\\n        _setTemplate(template_);\\n    }\\n\\n    /**\\n     * @dev Create a new holder contract.\\n     */\\n    function _setHolder(\\n        address entity,\\n        uint256 holderId,\\n        string memory nin,\\n        string memory name,\\n        address controller,\\n        address operator\\n    ) internal virtual {\\n        require(\\n            _template != address(0),\\n            \\\"NativasFactory: template is the zero address\\\"\\n        );\\n        address holderAddress = _template.clone();\\n        IERC1155Holder(holderAddress).init(\\n            entity,\\n            operator,\\n            controller,\\n            holderId,\\n            nin,\\n            name\\n        );\\n        _holders[holderId] = holderAddress;\\n        emit HolderCreated(holderId, holderAddress);\\n    }\\n\\n    /**\\n     * @dev See {IAccessControl-hasRole}\\n     */\\n    function _hasRole(bytes32 role) internal virtual returns (bool) {\\n        return IAccessControl(controller()).hasRole(role, _msgSender());\\n    }\\n\\n    /**\\n     * @dev Sets the holder template contract\\n     *\\n     * Requirements:\\n     *\\n     * - the template address must not be address 0.\\n     * - tem template contract must implemente the IERC1155Holder interface\\n     */\\n    function _setTemplate(address template_) internal virtual {\\n        require(\\n            template_ != address(0),\\n            \\\"NativasFactory: new template is the zero address\\\"\\n        );\\n        require(\\n            IERC165(template_).supportsInterface(\\n                type(IERC1155Holder).interfaceId\\n            ),\\n            \\\"NativasFactory: new template does not support IERC1155Holder interface\\\"\\n        );\\n        _template = template_;\\n    }\\n}\\n\"\r\n    },\r\n    \"IAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"Clones.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\\n * deploying minimal proxy contracts, also known as \\\"clones\\\".\\n *\\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\\n *\\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\\n * deterministic method.\\n *\\n * _Available since v3.4._\\n */\\nlibrary Clones {\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create opcode, which should never revert.\\n     */\\n    function clone(address implementation) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create(0, 0x09, 0x37)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create failed\\\");\\n    }\\n\\n    /**\\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\\n     *\\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\\n     * the clones cannot be deployed twice at the same address.\\n     */\\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\\n            // of the `implementation` address with the bytecode before the address.\\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\\n            instance := create2(0, 0x09, 0x37, salt)\\n        }\\n        require(instance != address(0), \\\"ERC1167: create2 failed\\\");\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(\\n        address implementation,\\n        bytes32 salt,\\n        address deployer\\n    ) internal pure returns (address predicted) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(add(ptr, 0x38), deployer)\\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\\n            mstore(add(ptr, 0x14), implementation)\\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\\n            mstore(add(ptr, 0x58), salt)\\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\\n            predicted := keccak256(add(ptr, 0x43), 0x55)\\n        }\\n    }\\n\\n    /**\\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\\n     */\\n    function predictDeterministicAddress(address implementation, bytes32 salt)\\n        internal\\n        view\\n        returns (address predicted)\\n    {\\n        return predictDeterministicAddress(implementation, salt, address(this));\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC1155Holder.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n/// @by: Nativas ClimaTech\\n/// @author: Juan Pablo Crespi\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Extension of ERC1155 that adds backward compatibility\\n */\\ninterface IERC1155Holder {\\n    /**\\n     * @dev Initialize contract\\n     */\\n    function init(\\n        address entity_,\\n        address operator_,\\n        address controller_,\\n        uint256 holderId_,\\n        string memory nin_,\\n        string memory name_\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"Controllable.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n/// @by: Nativas ClimaTech\\n/// @author: Juan Pablo Crespi\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism.\\n */\\ncontract Controllable is Context {\\n    address private _controller;\\n\\n    event ControlTransferred(\\n        address indexed oldController,\\n        address indexed newControllerr\\n    );\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial controller.\\n     */\\n    constructor(address controller_) {\\n        _transferControl(controller_);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current controller.\\n     */\\n    function controller() public view virtual returns (address) {\\n        return _controller;\\n    }\\n\\n    /**\\n     * @dev Transfers control of the contract to a new account (`controller_`).\\n     * Can only be called by the current controller.\\n     *\\n     * NOTE: Renouncing control will leave the contract without a controller,\\n     * thereby removing any functionality that is only available to the controller.\\n     */\\n    function _transferControl(address controller_) internal virtual {\\n        address current = _controller;\\n        _controller = controller_;\\n        emit ControlTransferred(current, controller_);\\n    }\\n}\\n\"\r\n    },\r\n    \"NativasRoles.sol\": {\r\n      \"content\": \"/// SPDX-License-Identifier: MIT\\n/// @by: Nativas ClimaTech\\n/// @author: Juan Pablo Crespi\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Roles {\\n    bytes32 public constant ADMIN_ROLE = 0x00;\\n    bytes32 public constant EDITOR_ROLE = keccak256(\\\"EDITOR_ROLE\\\");\\n    bytes32 public constant MINTER_ROLE = keccak256(\\\"MINTER_ROLE\\\");\\n    bytes32 public constant PAUSER_ROLE = keccak256(\\\"PAUSER_ROLE\\\");\\n    bytes32 public constant SWAPPER_ROLE = keccak256(\\\"SWAPPER_ROLE\\\");\\n    bytes32 public constant MANAGER_ROLE = keccak256(\\\"MANAGER_ROLE\\\");\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"NativasFactory.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"template_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldController\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newControllerr\",\"type\":\"address\"}],\"name\":\"ControlTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"holderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"holderAddress\",\"type\":\"address\"}],\"name\":\"HolderCreated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"holderId\",\"type\":\"uint256\"}],\"name\":\"getHolder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"entity_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"holderId_\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"nin_\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"}],\"name\":\"setHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"template_\",\"type\":\"address\"}],\"name\":\"setTemplate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"template\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"}],\"name\":\"transferControl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "NativasFactory", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e64540b86fed02f249e549bef33074440ab825cd000000000000000000000000943ee7064530844accbdad12ee4d1ab7a2e6b753", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}