{"SourceCode": "// Sources flattened with hardhat v2.6.4 https://hardhat.org\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/utils/types/AddressIsContract.sol@v1.1.1\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\n// Partially derived from OpenZeppelin:\r\n// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/406c83649bd6169fc1b578e08506d78f0873b276/contracts/utils/Address.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Upgrades the address type to check if it is a contract.\r\n */\r\nlibrary AddressIsContract {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize, which returns 0 for contracts in\r\n        // construction, since the code is only stored at the end of the\r\n        // constructor execution.\r\n\r\n        uint256 size;\r\n        assembly {\r\n            size := extcodesize(account)\r\n        }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/utils/ERC20Wrapper.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20Wrapper\r\n * Wraps ERC20 functions to support non-standard implementations which do not return a bool value.\r\n * Calls to the wrapped functions revert only if they throw or if they return false.\r\n */\r\nlibrary ERC20Wrapper {\r\n    using AddressIsContract for address;\r\n\r\n    function wrappedTransfer(\r\n        IWrappedERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function wrappedTransferFrom(\r\n        IWrappedERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    function wrappedApprove(\r\n        IWrappedERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        _callWithOptionalReturnData(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function _callWithOptionalReturnData(IWrappedERC20 token, bytes memory callData) internal {\r\n        address target = address(token);\r\n        require(target.isContract(), \"ERC20Wrapper: non-contract\");\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory data) = target.call(callData);\r\n        if (success) {\r\n            if (data.length != 0) {\r\n                require(abi.decode(data, (bool)), \"ERC20Wrapper: operation failed\");\r\n            }\r\n        } else {\r\n            // revert using a standard revert message\r\n            if (data.length == 0) {\r\n                revert(\"ERC20Wrapper: operation failed\");\r\n            }\r\n\r\n            // revert using the revert message coming from the call\r\n            assembly {\r\n                let size := mload(data)\r\n                revert(add(32, data), size)\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IWrappedERC20 {\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/metatx/ManagedIdentity.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/*\r\n * Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner.\r\n */\r\nabstract contract ManagedIdentity {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes memory) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/access/IERC173.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC-173 Contract Ownership Standard\r\n * Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n */\r\ninterface IERC173 {\r\n    /**\r\n     * Event emited when ownership of a contract changes.\r\n     * @param previousOwner the previous owner.\r\n     * @param newOwner the new owner.\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * Get the address of the owner\r\n     * @return The address of the owner.\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * Set the address of the new owner of the contract\r\n     * Set newOwner to address(0) to renounce any ownership.\r\n     * @dev Emits an {OwnershipTransferred} event.\r\n     * @param newOwner The address of the new owner of the contract. Using the zero address means renouncing ownership.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/access/Ownable.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is ManagedIdentity, IERC173 {\r\n    address internal _owner;\r\n\r\n    /**\r\n     * Initializes the contract, setting the deployer as the initial owner.\r\n     * @dev Emits an {IERC173-OwnershipTransferred(address,address)} event.\r\n     */\r\n    constructor(address owner_) {\r\n        _owner = owner_;\r\n        emit OwnershipTransferred(address(0), owner_);\r\n    }\r\n\r\n    /**\r\n     * Gets the address of the current contract owner.\r\n     */\r\n    function owner() public view virtual override returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * See {IERC173-transferOwnership(address)}\r\n     * @dev Reverts if the sender is not the current contract owner.\r\n     * @param newOwner the address of the new owner. Use the zero address to renounce the ownership.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual override {\r\n        _requireOwnership(_msgSender());\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts if `account` is not the contract owner.\r\n     * @param account the account to test.\r\n     */\r\n    function _requireOwnership(address account) internal virtual {\r\n        require(account == this.owner(), \"Ownable: not the owner\");\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/utils/Recoverable.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n\r\nabstract contract Recoverable is ManagedIdentity, Ownable {\r\n    using ERC20Wrapper for IWrappedERC20;\r\n\r\n    /**\r\n     * Extract ERC20 tokens which were accidentally sent to the contract to a list of accounts.\r\n     * Warning: this function should be overriden for contracts which are supposed to hold ERC20 tokens\r\n     * so that the extraction is limited to only amounts sent accidentally.\r\n     * @dev Reverts if the sender is not the contract owner.\r\n     * @dev Reverts if `accounts`, `tokens` and `amounts` do not have the same length.\r\n     * @dev Reverts if one of `tokens` is does not implement the ERC20 transfer function.\r\n     * @dev Reverts if one of the ERC20 transfers fail for any reason.\r\n     * @param accounts the list of accounts to transfer the tokens to.\r\n     * @param tokens the list of ERC20 token addresses.\r\n     * @param amounts the list of token amounts to transfer.\r\n     */\r\n    function recoverERC20s(\r\n        address[] calldata accounts,\r\n        address[] calldata tokens,\r\n        uint256[] calldata amounts\r\n    ) external virtual {\r\n        _requireOwnership(_msgSender());\r\n        uint256 length = accounts.length;\r\n        require(length == tokens.length && length == amounts.length, \"Recov: inconsistent arrays\");\r\n        for (uint256 i = 0; i != length; ++i) {\r\n            IWrappedERC20(tokens[i]).wrappedTransfer(accounts[i], amounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Extract ERC721 tokens which were accidentally sent to the contract to a list of accounts.\r\n     * Warning: this function should be overriden for contracts which are supposed to hold ERC721 tokens\r\n     * so that the extraction is limited to only tokens sent accidentally.\r\n     * @dev Reverts if the sender is not the contract owner.\r\n     * @dev Reverts if `accounts`, `contracts` and `amounts` do not have the same length.\r\n     * @dev Reverts if one of `contracts` is does not implement the ERC721 transferFrom function.\r\n     * @dev Reverts if one of the ERC721 transfers fail for any reason.\r\n     * @param accounts the list of accounts to transfer the tokens to.\r\n     * @param contracts the list of ERC721 contract addresses.\r\n     * @param tokenIds the list of token ids to transfer.\r\n     */\r\n    function recoverERC721s(\r\n        address[] calldata accounts,\r\n        address[] calldata contracts,\r\n        uint256[] calldata tokenIds\r\n    ) external virtual {\r\n        _requireOwnership(_msgSender());\r\n        uint256 length = accounts.length;\r\n        require(length == contracts.length && length == tokenIds.length, \"Recov: inconsistent arrays\");\r\n        for (uint256 i = 0; i != length; ++i) {\r\n            IRecoverableERC721(contracts[i]).transferFrom(address(this), accounts[i], tokenIds[i]);\r\n        }\r\n    }\r\n}\r\n\r\ninterface IRecoverableERC721 {\r\n    /// See {IERC721-transferFrom(address,address,uint256)}\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/introspection/IERC165.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, basic interface\r\n * @dev See https://eips.ethereum.org/EIPS/eip-20\r\n * Note: The ERC-165 identifier for this interface is 0x36372b07.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when tokens are transferred, including zero value transfers.\r\n     * @param _from The account where the transferred tokens are withdrawn from.\r\n     * @param _to The account where the transferred tokens are deposited to.\r\n     * @param _value The amount of tokens being transferred.\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n     * @dev Emitted when a successful call to {IERC20-approve(address,uint256)} is made.\r\n     * @param _owner The account granting an allowance to `_spender`.\r\n     * @param _spender The account being granted an allowance from `_owner`.\r\n     * @param _value The allowance amount being granted.\r\n     */\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /**\r\n     * @notice Returns the total token supply.\r\n     * @return The total token supply.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the account balance of another account with address `owner`.\r\n     * @param owner The account whose balance will be returned.\r\n     * @return The account balance of another account with address `owner`.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * Transfers `value` amount of tokens to address `to`.\r\n     * @dev Reverts if `to` is the zero address.\r\n     * @dev Reverts if the sender does not have enough balance.\r\n     * @dev Emits an {IERC20-Transfer} event.\r\n     * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\r\n     * @param to The receiver account.\r\n     * @param value The amount of tokens to transfer.\r\n     * @return True if the transfer succeeds, false otherwise.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @notice Transfers `value` amount of tokens from address `from` to address `to` via the approval mechanism.\r\n     * @dev Reverts if `to` is the zero address.\r\n     * @dev Reverts if the sender is not `from` and has not been approved by `from` for at least `value`.\r\n     * @dev Reverts if `from` does not have at least `value` of balance.\r\n     * @dev Emits an {IERC20-Transfer} event.\r\n     * @dev Transfers of 0 values are treated as normal transfers and fire the {IERC20-Transfer} event.\r\n     * @param from The emitter account.\r\n     * @param to The receiver account.\r\n     * @param value The amount of tokens to transfer.\r\n     * @return True if the transfer succeeds, false otherwise.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * Sets `value` as the allowance from the caller to `spender`.\r\n     *  IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     *  that someone may use both the old and the new allowance by unfortunate\r\n     *  transaction ordering. One possible solution to mitigate this race\r\n     *  condition is to first reduce the spender's allowance to 0 and set the\r\n     *  desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @dev Reverts if `spender` is the zero address.\r\n     * @dev Emits the {IERC20-Approval} event.\r\n     * @param spender The account being granted the allowance by the message caller.\r\n     * @param value The allowance amount to grant.\r\n     * @return True if the approval succeeds, false otherwise.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Returns the amount which `spender` is allowed to spend on behalf of `owner`.\r\n     * @param owner The account that has granted an allowance to `spender`.\r\n     * @param spender The account that was granted an allowance by `owner`.\r\n     * @return The amount which `spender` is allowed to spend on behalf of `owner`.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Detailed.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, optional extension: Detailed\r\n * See https://eips.ethereum.org/EIPS/eip-20\r\n * Note: the ERC-165 identifier for this interface is 0xa219a025.\r\n */\r\ninterface IERC20Detailed {\r\n    /**\r\n     * Returns the name of the token. E.g. \"My Token\".\r\n     * @return The name of the token.\r\n     */\r\n    function name() external view returns (string memory);\r\n\r\n    /**\r\n     * Returns the symbol of the token. E.g. \"HIX\".\r\n     * @return The symbol of the token.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * Returns the number of decimals used to display the balances.\r\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\r\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\r\n     *\r\n     * Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei.\r\n     *\r\n     * NOTE: This information is only used for _display_ purposes: it does  not impact the arithmetic of the contract.\r\n     * @return The number of decimals used to display the balances.\r\n     */\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Allowance.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, optional extension: Allowance\r\n * See https://eips.ethereum.org/EIPS/eip-20\r\n * Note: the ERC-165 identifier for this interface is 0xd5b86388.\r\n */\r\ninterface IERC20Allowance {\r\n    /**\r\n     * Increases the allowance granted by the sender to `spender` by `value`.\r\n     *  This is an alternative to {approve} that can be used as a mitigation for\r\n     *  problems described in {IERC20-approve}.\r\n     * @dev Reverts if `spender` is the zero address.\r\n     * @dev Reverts if `spender`'s allowance overflows.\r\n     * @dev Emits an {IERC20-Approval} event with an updated allowance for `spender`.\r\n     * @param spender The account whose allowance is being increased by the message caller.\r\n     * @param value The allowance amount increase.\r\n     * @return True if the allowance increase succeeds, false otherwise.\r\n     */\r\n    function increaseAllowance(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * Decreases the allowance granted by the sender to `spender` by `value`.\r\n     *  This is an alternative to {approve} that can be used as a mitigation for\r\n     *  problems described in {IERC20-approve}.\r\n     * @dev Reverts if `spender` is the zero address.\r\n     * @dev Reverts if `spender` has an allowance with the message caller for less than `value`.\r\n     * @dev Emits an {IERC20-Approval} event with an updated allowance for `spender`.\r\n     * @param spender The account whose allowance is being decreased by the message caller.\r\n     * @param value The allowance amount decrease.\r\n     * @return True if the allowance decrease succeeds, false otherwise.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 value) external returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20SafeTransfers.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, optional extension: Safe Transfers\r\n * Note: the ERC-165 identifier for this interface is 0x53f41a97.\r\n */\r\ninterface IERC20SafeTransfers {\r\n    /**\r\n     * Transfers tokens from the caller to `to`. If this address is a contract, then calls `onERC20Received(address,address,uint256,bytes)` on it.\r\n     * @dev Reverts if `to` is the zero address.\r\n     * @dev Reverts if `value` is greater than the sender's balance.\r\n     * @dev Reverts if `to` is a contract which does not implement `onERC20Received(address,address,uint256,bytes)`.\r\n     * @dev Reverts if `to` is a contract and the call to `onERC20Received(address,address,uint256,bytes)` returns a wrong value.\r\n     * @dev Emits an {IERC20-Transfer} event.\r\n     * @param to The address for the tokens to be transferred to.\r\n     * @param amount The amount of tokens to be transferred.\r\n     * @param data Optional additional data with no specified format, to be passed to the receiver contract.\r\n     * @return true.\r\n     */\r\n    function safeTransfer(\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * Transfers tokens from `from` to another address, using the allowance mechanism.\r\n     *  If this address is a contract, then calls `onERC20Received(address,address,uint256,bytes)` on it.\r\n     * @dev Reverts if `to` is the zero address.\r\n     * @dev Reverts if `value` is greater than `from`'s balance.\r\n     * @dev Reverts if the sender does not have at least `value` allowance by `from`.\r\n     * @dev Reverts if `to` is a contract which does not implement `onERC20Received(address,address,uint256,bytes)`.\r\n     * @dev Reverts if `to` is a contract and the call to `onERC20Received(address,address,uint256,bytes)` returns a wrong value.\r\n     * @dev Emits an {IERC20-Transfer} event.\r\n     * @param from The address which owns the tokens to be transferred.\r\n     * @param to The address for the tokens to be transferred to.\r\n     * @param amount The amount of tokens to be transferred.\r\n     * @param data Optional additional data with no specified format, to be passed to the receiver contract.\r\n     * @return true.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20BatchTransfers.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, optional extension: Multi Transfers\r\n * Note: the ERC-165 identifier for this interface is 0xd5b86388.\r\n */\r\ninterface IERC20BatchTransfers {\r\n    /**\r\n     * Moves multiple `amounts` tokens from the caller's account to each of `recipients`.\r\n     * @dev Reverts if `recipients` and `amounts` have different lengths.\r\n     * @dev Reverts if one of `recipients` is the zero address.\r\n     * @dev Reverts if the caller has an insufficient balance.\r\n     * @dev Emits an {IERC20-Transfer} event for each individual transfer.\r\n     * @param recipients the list of recipients to transfer the tokens to.\r\n     * @param amounts the amounts of tokens to transfer to each of `recipients`.\r\n     * @return a boolean value indicating whether the operation succeeded.\r\n     */\r\n    function batchTransfer(address[] calldata recipients, uint256[] calldata amounts) external returns (bool);\r\n\r\n    /**\r\n     * Moves multiple `amounts` tokens from an account to each of `recipients`, using the approval mechanism.\r\n     * @dev Reverts if `recipients` and `amounts` have different lengths.\r\n     * @dev Reverts if one of `recipients` is the zero address.\r\n     * @dev Reverts if `from` has an insufficient balance.\r\n     * @dev Reverts if the sender does not have at least the sum of all `amounts` as allowance by `from`.\r\n     * @dev Emits an {IERC20-Transfer} event for each individual transfer.\r\n     * @dev Emits an {IERC20-Approval} event.\r\n     * @param from The address which owns the tokens to be transferred.\r\n     * @param recipients the list of recipients to transfer the tokens to.\r\n     * @param amounts the amounts of tokens to transfer to each of `recipients`.\r\n     * @return a boolean value indicating whether the operation succeeded.\r\n     */\r\n    function batchTransferFrom(\r\n        address from,\r\n        address[] calldata recipients,\r\n        uint256[] calldata amounts\r\n    ) external returns (bool);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Metadata.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, ERC1046 optional extension: Metadata\r\n * See https://eips.ethereum.org/EIPS/eip-1046\r\n * Note: the ERC-165 identifier for this interface is 0x3c130d90.\r\n */\r\ninterface IERC20Metadata {\r\n    /**\r\n     * Returns a distinct Uniform Resource Identifier (URI) for the token metadata.\r\n     * @return a distinct Uniform Resource Identifier (URI) for the token metadata.\r\n     */\r\n    function tokenURI() external view returns (string memory);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Permit.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, ERC2612 optional extension: permit \u2013 712-signed approvals\r\n * @dev Interface for allowing ERC20 approvals to be made via ECDSA `secp256k1` signatures.\r\n * See https://eips.ethereum.org/EIPS/eip-2612\r\n * Note: the ERC-165 identifier for this interface is 0x9d8ff7da.\r\n */\r\ninterface IERC20Permit {\r\n    /**\r\n     * Sets `value` as the allowance of `spender` over the tokens of `owner`, given `owner` account's signed permit.\r\n     * @dev WARNING: The standard ERC-20 race condition for approvals applies to `permit()` as well: https://swcregistry.io/docs/SWC-114\r\n     * @dev Reverts if `owner` is the zero address.\r\n     * @dev Reverts if the current blocktime is > `deadline`.\r\n     * @dev Reverts if `r`, `s`, and `v` is not a valid `secp256k1` signature from `owner`.\r\n     * @dev Emits an {IERC20-Approval} event.\r\n     * @param owner The token owner granting the allowance to `spender`.\r\n     * @param spender The token spender being granted the allowance by `owner`.\r\n     * @param value The token amount of the allowance.\r\n     * @param deadline The deadline from which the permit signature is no longer valid.\r\n     * @param v Permit signature v parameter\r\n     * @param r Permit signature r parameter.\r\n     * @param s Permis signature s parameter.\r\n     */\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n\r\n    /**\r\n     * Returns the current permit nonce of `owner`.\r\n     * @param owner the address to check the nonce of.\r\n     * @return the current permit nonce of `owner`.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * Returns the EIP-712 encoded hash struct of the domain-specific information for permits.\r\n     *\r\n     * @dev A common ERC-20 permit implementation choice for the `DOMAIN_SEPARATOR` is:\r\n     *\r\n     *  keccak256(\r\n     *      abi.encode(\r\n     *          keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n     *          keccak256(bytes(name)),\r\n     *          keccak256(bytes(version)),\r\n     *          chainId,\r\n     *          address(this)))\r\n     *\r\n     *  where\r\n     *   - `name` (string) is the ERC-20 token name.\r\n     *   - `version` (string) refers to the ERC-20 token contract version.\r\n     *   - `chainId` (uint256) is the chain ID to which the ERC-20 token contract is deployed to.\r\n     *   - `verifyingContract` (address) is the ERC-20 token contract address.\r\n     *\r\n     * @return the EIP-712 encoded hash struct of the domain-specific information for permits.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/IERC20Receiver.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n/**\r\n * @title ERC20 Token Standard, Receiver\r\n * See https://eips.ethereum.org/EIPS/eip-20\r\n * Note: the ERC-165 identifier for this interface is 0x4fc35859.\r\n */\r\ninterface IERC20Receiver {\r\n    /**\r\n     * Handles the receipt of ERC20 tokens.\r\n     * @param sender The initiator of the transfer.\r\n     * @param from The address which transferred the tokens.\r\n     * @param value The amount of tokens transferred.\r\n     * @param data Optional additional data with no specified format.\r\n     * @return bytes4 `bytes4(keccak256(\"onERC20Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC20Received(\r\n        address sender,\r\n        address from,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/ERC20.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 Fungible Token Contract.\r\n */\r\nabstract contract ERC20 is\r\n    ManagedIdentity,\r\n    IERC165,\r\n    IERC20,\r\n    IERC20Detailed,\r\n    IERC20Metadata,\r\n    IERC20Allowance,\r\n    IERC20BatchTransfers,\r\n    IERC20SafeTransfers,\r\n    IERC20Permit\r\n{\r\n    using AddressIsContract for address;\r\n\r\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\r\n    bytes32 internal constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\r\n\r\n    uint256 public immutable deploymentChainId;\r\n\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 internal immutable _DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public override nonces;\r\n\r\n    string internal _name;\r\n    string internal _symbol;\r\n    uint8 internal immutable _decimals;\r\n    string internal _tokenURI;\r\n\r\n    mapping(address => uint256) internal _balances;\r\n    mapping(address => mapping(address => uint256)) internal _allowances;\r\n    uint256 internal _totalSupply;\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_,\r\n        string memory tokenURI_\r\n    ) {\r\n        _name = name_;\r\n        _symbol = symbol_;\r\n        _decimals = decimals_;\r\n        _tokenURI = tokenURI_;\r\n\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        deploymentChainId = chainId;\r\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(chainId, bytes(name_));\r\n    }\r\n\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() public view override returns (bytes32) {\r\n        uint256 chainId;\r\n        assembly {\r\n            chainId := chainid()\r\n        }\r\n        // recompute the domain separator in case of fork and chainid update\r\n        return chainId == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(chainId, bytes(_name));\r\n    }\r\n\r\n    function _calculateDomainSeparator(uint256 chainId, bytes memory name_) private view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(name_),\r\n                    keccak256(\"1\"),\r\n                    chainId,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /////////////////////////////////////////// ERC165 ///////////////////////////////////////\r\n\r\n    /// @dev See {IERC165-supportsInterface}.\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return\r\n            interfaceId == type(IERC165).interfaceId ||\r\n            interfaceId == type(IERC20).interfaceId ||\r\n            interfaceId == type(IERC20Detailed).interfaceId ||\r\n            interfaceId == type(IERC20Metadata).interfaceId ||\r\n            interfaceId == type(IERC20Allowance).interfaceId ||\r\n            interfaceId == type(IERC20BatchTransfers).interfaceId ||\r\n            interfaceId == type(IERC20SafeTransfers).interfaceId ||\r\n            interfaceId == type(IERC20Permit).interfaceId;\r\n    }\r\n\r\n    /////////////////////////////////////////// ERC20Detailed ///////////////////////////////////////\r\n\r\n    /// @dev See {IERC20Detailed-name}.\r\n    function name() external view override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    /// @dev See {IERC20Detailed-symbol}.\r\n    function symbol() external view override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    /// @dev See {IERC20Detailed-decimals}.\r\n    function decimals() external view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    /////////////////////////////////////////// ERC20Metadata ///////////////////////////////////////\r\n\r\n    /// @dev See {IERC20Metadata-tokenURI}.\r\n    function tokenURI() external view override returns (string memory) {\r\n        return _tokenURI;\r\n    }\r\n\r\n    /////////////////////////////////////////// ERC20 ///////////////////////////////////////\r\n\r\n    /// @dev See {IERC20-totalSupply}.\r\n    function totalSupply() external view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /// @dev See {IERC20-balanceOf}.\r\n    function balanceOf(address account) external view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /// @dev See {IERC20-allowance}.\r\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /// @dev See {IERC20-approve}.\r\n    function approve(address spender, uint256 value) external virtual override returns (bool) {\r\n        _approve(_msgSender(), spender, value);\r\n        return true;\r\n    }\r\n\r\n    /////////////////////////////////////////// ERC20 Allowance ///////////////////////////////////////\r\n\r\n    /// @dev See {IERC20Allowance-increaseAllowance}.\r\n    function increaseAllowance(address spender, uint256 addedValue) external virtual override returns (bool) {\r\n        require(spender != address(0), \"ERC20: zero address spender\");\r\n        address owner = _msgSender();\r\n        uint256 allowance_ = _allowances[owner][spender];\r\n        if (addedValue != 0) {\r\n            uint256 newAllowance = allowance_ + addedValue;\r\n            require(newAllowance > allowance_, \"ERC20: allowance overflow\");\r\n            _allowances[owner][spender] = newAllowance;\r\n            allowance_ = newAllowance;\r\n        }\r\n        emit Approval(owner, spender, allowance_);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev See {IERC20Allowance-decreaseAllowance}.\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) external virtual override returns (bool) {\r\n        require(spender != address(0), \"ERC20: zero address spender\");\r\n        _decreaseAllowance(_msgSender(), spender, subtractedValue);\r\n        return true;\r\n    }\r\n\r\n    /// @dev See {IERC20-transfer}.\r\n    function transfer(address to, uint256 value) external virtual override returns (bool) {\r\n        _transfer(_msgSender(), to, value);\r\n        return true;\r\n    }\r\n\r\n    /// @dev See {IERC20-transferFrom}.\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external virtual override returns (bool) {\r\n        _transferFrom(_msgSender(), from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /////////////////////////////////////////// ERC20MultiTransfer ///////////////////////////////////////\r\n\r\n    /// @dev See {IERC20MultiTransfer-multiTransfer(address[],uint256[])}.\r\n    function batchTransfer(address[] calldata recipients, uint256[] calldata values) external virtual override returns (bool) {\r\n        uint256 length = recipients.length;\r\n        require(length == values.length, \"ERC20: inconsistent arrays\");\r\n        address sender = _msgSender();\r\n        uint256 balance = _balances[sender];\r\n\r\n        uint256 totalValue;\r\n        uint256 selfTransferTotalValue;\r\n        for (uint256 i; i != length; ++i) {\r\n            address to = recipients[i];\r\n            require(to != address(0), \"ERC20: to zero address\");\r\n\r\n            uint256 value = values[i];\r\n            if (value != 0) {\r\n                uint256 newTotalValue = totalValue + value;\r\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\r\n                totalValue = newTotalValue;\r\n                if (sender != to) {\r\n                    _balances[to] += value;\r\n                } else {\r\n                    require(value <= balance, \"ERC20: insufficient balance\");\r\n                    selfTransferTotalValue += value; // cannot overflow as 'selfTransferTotalValue <= totalValue' is always true\r\n                }\r\n            }\r\n            emit Transfer(sender, to, value);\r\n        }\r\n\r\n        if (totalValue != 0 && totalValue != selfTransferTotalValue) {\r\n            uint256 newBalance = balance - totalValue;\r\n            require(newBalance < balance, \"ERC20: insufficient balance\"); // balance must be sufficient, including self-transfers\r\n            _balances[sender] = newBalance + selfTransferTotalValue; // do not deduct self-transfers from the sender balance\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev See {IERC20MultiTransfer-multiTransferFrom(address,address[],uint256[])}.\r\n    function batchTransferFrom(\r\n        address from,\r\n        address[] calldata recipients,\r\n        uint256[] calldata values\r\n    ) external virtual override returns (bool) {\r\n        uint256 length = recipients.length;\r\n        require(length == values.length, \"ERC20: inconsistent arrays\");\r\n\r\n        uint256 balance = _balances[from];\r\n\r\n        uint256 totalValue;\r\n        uint256 selfTransferTotalValue;\r\n        for (uint256 i; i != length; ++i) {\r\n            address to = recipients[i];\r\n            require(to != address(0), \"ERC20: to zero address\");\r\n\r\n            uint256 value = values[i];\r\n\r\n            if (value != 0) {\r\n                uint256 newTotalValue = totalValue + value;\r\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\r\n                totalValue = newTotalValue;\r\n                if (from != to) {\r\n                    _balances[to] += value;\r\n                } else {\r\n                    require(value <= balance, \"ERC20: insufficient balance\");\r\n                    selfTransferTotalValue += value; // cannot overflow as 'selfTransferTotalValue <= totalValue' is always true\r\n                }\r\n            }\r\n\r\n            emit Transfer(from, to, value);\r\n        }\r\n\r\n        if (totalValue != 0 && totalValue != selfTransferTotalValue) {\r\n            uint256 newBalance = balance - totalValue;\r\n            require(newBalance < balance, \"ERC20: insufficient balance\"); // balance must be sufficient, including self-transfers\r\n            _balances[from] = newBalance + selfTransferTotalValue; // do not deduct self-transfers from the sender balance\r\n        }\r\n\r\n        address sender = _msgSender();\r\n        if (from != sender) {\r\n            _decreaseAllowance(from, sender, totalValue);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /////////////////////////////////////////// ERC20SafeTransfers ///////////////////////////////////////\r\n\r\n    /// @dev See {IERC20Safe-safeTransfer(address,uint256,bytes)}.\r\n    function safeTransfer(\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external virtual override returns (bool) {\r\n        address sender = _msgSender();\r\n        _transfer(sender, to, amount);\r\n        if (to.isContract()) {\r\n            require(IERC20Receiver(to).onERC20Received(sender, sender, amount, data) == type(IERC20Receiver).interfaceId, \"ERC20: transfer refused\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /// @dev See {IERC20Safe-safeTransferFrom(address,address,uint256,bytes)}.\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external virtual override returns (bool) {\r\n        address sender = _msgSender();\r\n        _transferFrom(sender, from, to, amount);\r\n        if (to.isContract()) {\r\n            require(IERC20Receiver(to).onERC20Received(sender, from, amount, data) == type(IERC20Receiver).interfaceId, \"ERC20: transfer refused\");\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /////////////////////////////////////////// ERC20Permit ///////////////////////////////////////\r\n\r\n    /// @dev See {IERC2612-permit(address,address,uint256,uint256,uint8,bytes32,bytes32)}.\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external virtual override {\r\n        require(owner != address(0), \"ERC20: zero address owner\");\r\n        require(block.timestamp <= deadline, \"ERC20: expired permit\");\r\n        bytes32 hashStruct = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline));\r\n        bytes32 hash = keccak256(abi.encodePacked(\"\\x19\\x01\", DOMAIN_SEPARATOR(), hashStruct));\r\n        address signer = ecrecover(hash, v, r, s);\r\n        require(signer == owner, \"ERC20: invalid permit\");\r\n        _approve(owner, spender, value);\r\n    }\r\n\r\n    /////////////////////////////////////////// Internal Functions ///////////////////////////////////////\r\n\r\n    function _approve(\r\n        address owner,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        require(spender != address(0), \"ERC20: zero address spender\");\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function _decreaseAllowance(\r\n        address owner,\r\n        address spender,\r\n        uint256 subtractedValue\r\n    ) internal {\r\n        uint256 allowance_ = _allowances[owner][spender];\r\n\r\n        if (allowance_ != type(uint256).max && subtractedValue != 0) {\r\n            // save gas when allowance is maximal by not reducing it (see https://github.com/ethereum/EIPs/issues/717)\r\n            uint256 newAllowance = allowance_ - subtractedValue;\r\n            require(newAllowance < allowance_, \"ERC20: insufficient allowance\");\r\n            _allowances[owner][spender] = newAllowance;\r\n            allowance_ = newAllowance;\r\n        }\r\n        emit Approval(owner, spender, allowance_);\r\n    }\r\n\r\n    function _transfer(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal virtual {\r\n        require(to != address(0), \"ERC20: to zero address\");\r\n\r\n        if (value != 0) {\r\n            uint256 balance = _balances[from];\r\n            uint256 newBalance = balance - value;\r\n            require(newBalance < balance, \"ERC20: insufficient balance\");\r\n            if (from != to) {\r\n                _balances[from] = newBalance;\r\n                _balances[to] += value;\r\n            }\r\n        }\r\n\r\n        emit Transfer(from, to, value);\r\n    }\r\n\r\n    function _transferFrom(\r\n        address sender,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _transfer(from, to, value);\r\n        if (from != sender) {\r\n            _decreaseAllowance(from, sender, value);\r\n        }\r\n    }\r\n\r\n    function _mint(address to, uint256 value) internal virtual {\r\n        require(to != address(0), \"ERC20: zero address\");\r\n        uint256 supply = _totalSupply;\r\n        if (value != 0) {\r\n            uint256 newSupply = supply + value;\r\n            require(newSupply > supply, \"ERC20: supply overflow\");\r\n            _totalSupply = newSupply;\r\n            _balances[to] += value; // balance cannot overflow if supply does not\r\n        }\r\n        emit Transfer(address(0), to, value);\r\n    }\r\n\r\n    function _batchMint(address[] memory recipients, uint256[] memory values) internal virtual {\r\n        uint256 length = recipients.length;\r\n        require(length == values.length, \"ERC20: inconsistent arrays\");\r\n\r\n        uint256 totalValue;\r\n        for (uint256 i; i != length; ++i) {\r\n            address to = recipients[i];\r\n            require(to != address(0), \"ERC20: zero address\");\r\n\r\n            uint256 value = values[i];\r\n            if (value != 0) {\r\n                uint256 newTotalValue = totalValue + value;\r\n                require(newTotalValue > totalValue, \"ERC20: values overflow\");\r\n                totalValue = newTotalValue;\r\n                _balances[to] += value; // balance cannot overflow if supply does not\r\n            }\r\n            emit Transfer(address(0), to, value);\r\n        }\r\n\r\n        if (totalValue != 0) {\r\n            uint256 supply = _totalSupply;\r\n            uint256 newSupply = supply + totalValue;\r\n            require(newSupply > supply, \"ERC20: supply overflow\");\r\n            _totalSupply = newSupply;\r\n        }\r\n    }\r\n\r\n    function _burn(address from, uint256 value) internal virtual {\r\n        if (value != 0) {\r\n            uint256 balance = _balances[from];\r\n            uint256 newBalance = balance - value;\r\n            require(newBalance < balance, \"ERC20: insufficient balance\");\r\n            _balances[from] = newBalance;\r\n            _totalSupply -= value; // will not underflow if balance does not\r\n        }\r\n        emit Transfer(from, address(0), value);\r\n    }\r\n\r\n    function _burnFrom(address from, uint256 value) internal virtual {\r\n        _burn(from, value);\r\n        address sender = _msgSender();\r\n        if (from != sender) {\r\n            _decreaseAllowance(from, sender, value);\r\n        }\r\n    }\r\n\r\n    function _batchBurnFrom(address[] memory owners, uint256[] memory values) internal virtual {\r\n        uint256 length = owners.length;\r\n        require(length == values.length, \"ERC20: inconsistent arrays\");\r\n\r\n        address sender = _msgSender();\r\n\r\n        uint256 totalValue;\r\n        for (uint256 i; i != length; ++i) {\r\n            address from = owners[i];\r\n            uint256 value = values[i];\r\n            if (value != 0) {\r\n                uint256 balance = _balances[from];\r\n                uint256 newBalance = balance - value;\r\n                require(newBalance < balance, \"ERC20: insufficient balance\");\r\n                _balances[from] = newBalance;\r\n                totalValue += value; // totalValue cannot overflow if the individual balances do not underflow\r\n            }\r\n            emit Transfer(from, address(0), value);\r\n\r\n            if (from != sender) {\r\n                _decreaseAllowance(from, sender, value);\r\n            }\r\n        }\r\n\r\n        if (totalValue != 0) {\r\n            _totalSupply -= totalValue; // _totalSupply cannot underfow as balances do not underflow\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-core-1.1.1/contracts/bridging/IChildToken.sol@v1.1.1\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\ninterface IChildToken {\r\n    function deposit(address user, bytes calldata depositData) external;\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/ERC20Receiver.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\nabstract contract ERC20Receiver is IERC20Receiver, IERC165 {\r\n    bytes4 internal constant _ERC20_RECEIVED = type(IERC20Receiver).interfaceId;\r\n    bytes4 internal constant _ERC20_REJECTED = 0xffffffff;\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC20Receiver).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/bridging/ChildERC20Base.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n/**\r\n * Polygon (MATIC) bridging base child ERC20 for deployment on the child chain (Polygon/MATIC).\r\n */\r\nabstract contract ChildERC20Base is IChildToken, ERC20Receiver {\r\n    event Withdrawn(address account, uint256 value);\r\n\r\n    // see https://github.com/maticnetwork/pos-portal/blob/master/contracts/child/ChildChainManager/ChildChainManager.sol\r\n    address public childChainManager;\r\n\r\n    /**\r\n     * Constructor\r\n     * @param childChainManager_ the Polygon/MATIC ChildChainManager proxy address.\r\n     */\r\n    constructor(address childChainManager_) {\r\n        childChainManager = childChainManager_;\r\n    }\r\n\r\n    function _requireDepositorRole(address account) internal view {\r\n        require(account == childChainManager, \"ChildERC20: only depositor\");\r\n    }\r\n}\r\n\r\n\r\n// File @animoca/ethereum-contracts-assets-1.1.3/contracts/token/ERC20/ChildERC20.sol@v1.1.3\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\nabstract contract ChildERC20 is ERC20, ChildERC20Base {\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 decimals_,\r\n        string memory tokenURI_,\r\n        address childChainManager\r\n    ) ERC20(name_, symbol_, decimals_, tokenURI_) ChildERC20Base(childChainManager) {}\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC20, ERC20Receiver) returns (bool) {\r\n        return ERC20.supportsInterface(interfaceId) || ERC20Receiver.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * Called when tokens have been deposited on the root chain.\r\n     * @dev Should handle deposit by un-escrowing the required amount for user.\r\n     * @dev Reverts if not sent by the depositor (ChildChainManager).\r\n     * @param user address for whom deposit has been done.\r\n     * @param depositData abi encoded amount.\r\n     */\r\n    function deposit(address user, bytes calldata depositData) public virtual override {\r\n        _requireDepositorRole(_msgSender());\r\n        uint256 amount = abi.decode(depositData, (uint256));\r\n        _transfer(address(this), user, amount);\r\n    }\r\n\r\n    /**\r\n     * Called when user wants to withdraw tokens back to the root chain.\r\n     * @dev Should escrow user's tokens. This transaction will be verified when exiting on root chain.\r\n     * @dev Emits a {Withdrawn} event.\r\n     * @param amount amount of tokens to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) public virtual {\r\n        address sender = _msgSender();\r\n        _transferFrom(sender, sender, address(this), amount);\r\n        emit Withdrawn(sender, amount);\r\n    }\r\n\r\n    /**\r\n     * Called when user wants to withdraw tokens back to the root chain (no pre-approval required).\r\n     * @dev Should escrow user's tokens. This transaction will be verified when exiting on root chain.\r\n     * @dev Reverts if the sender is not this contract.\r\n     * @dev Emits a {Withdrawn} event.\r\n     * _param operator The initiator of the transfer.\r\n     * @param from The address which transferred the tokens.\r\n     * @param amount The amount of tokens transferred.\r\n     * _param data Optional additional data with no specified format.\r\n     * @return bytes4 `bytes4(keccak256(\"onERC20Received(address,address,uint256,bytes)\"))`\r\n     */\r\n    function onERC20Received(\r\n        address, /*operator*/\r\n        address from,\r\n        uint256 amount,\r\n        bytes calldata /*data*/\r\n    ) public virtual override returns (bytes4) {\r\n        require(_msgSender() == address(this), \"ChildERC20: wrong sender\");\r\n        emit Withdrawn(from, amount);\r\n        return _ERC20_RECEIVED;\r\n    }\r\n}\r\n\r\n\r\n// File ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingAppendedCallData.sol@v0.1.4\r\npragma solidity ^0.7.0;\r\n\r\nabstract contract UsingAppendedCallData {\r\n    function _lastAppendedDataAsSender() internal pure virtual returns (address payable sender) {\r\n        // Copied from openzeppelin : https://github.com/OpenZeppelin/openzeppelin-contracts/blob/9d5f77db9da0604ce0b25148898a94ae2c20d70f/contracts/metatx/ERC2771Context.sol1\r\n        // The assembly code is more direct than the Solidity version using `abi.decode`.\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            sender := shr(96, calldataload(sub(calldatasize(), 20)))\r\n        }\r\n    }\r\n\r\n    function _msgDataAssuming20BytesAppendedData() internal pure virtual returns (bytes calldata) {\r\n        return msg.data[:msg.data.length - 20];\r\n    }\r\n}\r\n\r\n\r\n// File ethereum-universal-forwarder/src/solc_0.7/ERC2771/IERC2771.sol@v0.1.4\r\npragma solidity ^0.7.0;\r\n\r\ninterface IERC2771 {\r\n    function isTrustedForwarder(address forwarder) external view returns (bool);\r\n}\r\n\r\n\r\n// File ethereum-universal-forwarder/src/solc_0.7/ERC2771/IForwarderRegistry.sol@v0.1.4\r\npragma solidity ^0.7.0;\r\n\r\ninterface IForwarderRegistry {\r\n    function isForwarderFor(address, address) external view returns (bool);\r\n}\r\n\r\n\r\n// File ethereum-universal-forwarder/src/solc_0.7/ERC2771/UsingUniversalForwarding.sol@v0.1.4\r\npragma solidity ^0.7.0;\r\n\r\n\r\n\r\nabstract contract UsingUniversalForwarding is UsingAppendedCallData, IERC2771 {\r\n    IForwarderRegistry internal immutable _forwarderRegistry;\r\n    address internal immutable _universalForwarder;\r\n\r\n    constructor(IForwarderRegistry forwarderRegistry, address universalForwarder) {\r\n        _universalForwarder = universalForwarder;\r\n        _forwarderRegistry = forwarderRegistry;\r\n    }\r\n\r\n    function isTrustedForwarder(address forwarder) external view virtual override returns (bool) {\r\n        return forwarder == _universalForwarder || forwarder == address(_forwarderRegistry);\r\n    }\r\n\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        address payable msgSender = msg.sender;\r\n        address payable sender = _lastAppendedDataAsSender();\r\n        if (msgSender == address(_forwarderRegistry) || msgSender == _universalForwarder) {\r\n            // if forwarder use appended data\r\n            return sender;\r\n        }\r\n\r\n        // if msg.sender is neither the registry nor the universal forwarder,\r\n        // we have to check the last 20bytes of the call data intepreted as an address\r\n        // and check if the msg.sender was registered as forewarder for that address\r\n        // we check tx.origin to save gas in case where msg.sender == tx.origin\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        if (msgSender != tx.origin && _forwarderRegistry.isForwarderFor(sender, msgSender)) {\r\n            return sender;\r\n        }\r\n\r\n        return msgSender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        address payable msgSender = msg.sender;\r\n        if (msgSender == address(_forwarderRegistry) || msgSender == _universalForwarder) {\r\n            // if forwarder use appended data\r\n            return _msgDataAssuming20BytesAppendedData();\r\n        }\r\n\r\n        // we check tx.origin to save gas in case where msg.sender == tx.origin\r\n        // solhint-disable-next-line avoid-tx-origin\r\n        if (msgSender != tx.origin && _forwarderRegistry.isForwarderFor(_lastAppendedDataAsSender(), msgSender)) {\r\n            return _msgDataAssuming20BytesAppendedData();\r\n        }\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/token/PolygonTower.sol\r\n\r\npragma solidity >=0.7.6 <0.8.0;\r\n\r\n\r\n\r\n\r\ncontract PolygonTower is Recoverable, UsingUniversalForwarding, ChildERC20 {\r\n    using ERC20Wrapper for IWrappedERC20;\r\n\r\n    uint256 public escrowed;\r\n\r\n    constructor(\r\n        uint256 supply,\r\n        address childChainManager,\r\n        IForwarderRegistry forwarderRegistry,\r\n        address universalForwarder\r\n    ) ChildERC20(\"TOWER\", \"TOWER\", 18, \"\", childChainManager) UsingUniversalForwarding(forwarderRegistry, universalForwarder) Ownable(msg.sender) {\r\n        _mint(address(this), supply);\r\n        escrowed = supply;\r\n    }\r\n\r\n    function setTokenURI(string memory tokenURI_) external {\r\n        _requireOwnership(_msgSender());\r\n        _tokenURI = tokenURI_;\r\n    }\r\n\r\n    function deposit(address user, bytes calldata depositData) public virtual override {\r\n        escrowed -= abi.decode(depositData, (uint256));\r\n        super.deposit(user, depositData);\r\n    }\r\n\r\n    function withdraw(uint256 amount) public virtual override {\r\n        escrowed += amount;\r\n        super.withdraw(amount);\r\n    }\r\n\r\n    function onERC20Received(\r\n        address operator,\r\n        address from,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) public virtual override returns (bytes4) {\r\n        escrowed += amount;\r\n        return super.onERC20Received(operator, from, amount, data);\r\n    }\r\n\r\n    function recoverERC20s(\r\n        address[] calldata accounts,\r\n        address[] calldata tokens,\r\n        uint256[] calldata amounts\r\n    ) external virtual override {\r\n        _requireOwnership(_msgSender());\r\n        uint256 length = accounts.length;\r\n        require(length == tokens.length && length == amounts.length, \"Recov: inconsistent arrays\");\r\n        for (uint256 i = 0; i != length; ++i) {\r\n            address token = tokens[i];\r\n            uint256 amount = amounts[i];\r\n            if (token == address(this)) {\r\n                uint256 recoverable = _balances[address(this)] - escrowed;\r\n                require(amount <= recoverable, \"Recov: insufficient balance\");\r\n            }\r\n            IWrappedERC20(token).wrappedTransfer(accounts[i], amount);\r\n        }\r\n    }\r\n\r\n    function _msgSender() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (address payable) {\r\n        return UsingUniversalForwarding._msgSender();\r\n    }\r\n\r\n    function _msgData() internal view virtual override(ManagedIdentity, UsingUniversalForwarding) returns (bytes memory ret) {\r\n        return UsingUniversalForwarding._msgData();\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"childChainManager\",\"type\":\"address\"},{\"internalType\":\"contract IForwarderRegistry\",\"name\":\"forwarderRegistry\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"universalForwarder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"childChainManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"depositData\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"escrowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC20Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"recoverERC20s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"accounts\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"contracts\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"recoverERC721s\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"tokenURI_\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "PolygonTower", "CompilerVersion": "v0.7.6+commit.7338295f", "OptimizationUsed": "1", "Runs": "2000", "ConstructorArguments": "0000000000000000000000000000000000000000204fce5e3e25026110000000000000000000000000000000a6fa4fb5f76172d178d61b04b0ecd319c5d1c0aa00000000000000000000000071bee13e92e64701b78f059801a70857e4683acd00000000000000000000000056133a31f4cd01ede8c6ee780071c021bd324ad2", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fc02e1e8d78753a227e1128446c9a7759306cdbe5bb259a983cdae6e82bd32aa"}