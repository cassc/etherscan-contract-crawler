{"SourceCode": "// File: contracts\\interfaces\\UniswapRouterInterfaceV5.sol\r\n// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.7;\r\n\r\ninterface UniswapRouterInterfaceV5{\r\n\tfunction swapExactTokensForTokens(\r\n\t\tuint amountIn,\r\n\t\tuint amountOutMin,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint[] memory amounts);\r\n\r\n\tfunction swapTokensForExactTokens(\r\n\t\tuint amountOut,\r\n\t\tuint amountInMax,\r\n\t\taddress[] calldata path,\r\n\t\taddress to,\r\n\t\tuint deadline\r\n\t) external returns (uint[] memory amounts);\r\n}\r\n\r\n// File: contracts\\interfaces\\AggregatorInterfaceV5.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface AggregatorInterfaceV5{\r\n    enum OrderType { MARKET_OPEN, MARKET_CLOSE, LIMIT_OPEN, LIMIT_CLOSE }\r\n    function getPrice(uint,OrderType,uint) external returns(uint);\r\n    function tokenPriceDai() external view returns(uint);\r\n    function pairMinOpenLimitSlippageP(uint) external view returns(uint);\r\n    function closeFeeP(uint) external view returns(uint);\r\n    function linkFee(uint,uint) external view returns(uint);\r\n    function openFeeP(uint) external view returns(uint);\r\n    function pairMinLeverage(uint) external view returns(uint);\r\n    function pairMaxLeverage(uint) external view returns(uint);\r\n    function pairsCount() external view returns(uint);\r\n    function tokenDaiReservesLp() external view returns(uint, uint);\r\n    function referralP(uint) external view returns(uint);\r\n    function nftLimitOrderFeeP(uint) external view returns(uint);\r\n}\r\n\r\n// File: contracts\\interfaces\\TokenInterfaceV5.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface TokenInterfaceV5{\r\n    function burn(address, uint256) external;\r\n    function mint(address, uint256) external;\r\n    function transfer(address, uint256) external returns (bool);\r\n    function transferFrom(address, address, uint256) external returns(bool);\r\n    function balanceOf(address) external view returns(uint256);\r\n    function hasRole(bytes32, address) external view returns (bool);\r\n    function approve(address, uint256) external returns (bool);\r\n    function allowance(address, address) external view returns (uint256);\r\n}\r\n\r\n// File: contracts\\interfaces\\NftInterfaceV5.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface NftInterfaceV5{\r\n    function balanceOf(address) external view returns (uint);\r\n    function ownerOf(uint) external view returns (address);\r\n    function transferFrom(address, address, uint) external;\r\n    function tokenOfOwnerByIndex(address, uint) external view returns(uint);\r\n}\r\n\r\n// File: contracts\\interfaces\\VaultInterfaceV5.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\ninterface VaultInterfaceV5{\r\n\tfunction sendDaiToTrader(address, uint) external;\r\n\tfunction receiveDaiFromTrader(address, uint, uint) external;\r\n\tfunction currentBalanceDai() external view returns(uint);\r\n}\r\n\r\n// File: contracts\\interfaces\\StorageInterfaceV5.sol\r\n\r\npragma solidity 0.8.7;\r\n\r\n\r\n\r\n\r\n\r\n\r\ninterface StorageInterfaceV5{\r\n    enum LimitOrder { TP, SL, LIQ, OPEN }\r\n    struct Trader{\r\n        uint leverageUnlocked;\r\n        address referral;\r\n        uint referralRewardsTotal;  // 1e18\r\n    }\r\n    struct Trade{\r\n        address trader;\r\n        uint pairIndex;\r\n        uint index;\r\n        uint initialPosToken;       // 1e18\r\n        uint positionSizeDai;       // 1e18\r\n        uint openPrice;             // PRECISION\r\n        bool buy;\r\n        uint leverage;\r\n        uint tp;                    // PRECISION\r\n        uint sl;                    // PRECISION\r\n    }\r\n    struct TradeInfo{\r\n        uint tokenId;\r\n        uint tokenPriceDai;         // PRECISION\r\n        uint openInterestDai;       // 1e18\r\n        uint tpLastUpdated;\r\n        uint slLastUpdated;\r\n        bool beingMarketClosed;\r\n    }\r\n    struct OpenLimitOrder{\r\n        address trader;\r\n        uint pairIndex;\r\n        uint index;\r\n        uint positionSize;          // 1e18 (DAI or GFARM2)\r\n        uint spreadReductionP;\r\n        bool buy;\r\n        uint leverage;\r\n        uint tp;                    // PRECISION (%)\r\n        uint sl;                    // PRECISION (%)\r\n        uint minPrice;              // PRECISION\r\n        uint maxPrice;              // PRECISION\r\n        uint block;\r\n        uint tokenId;               // index in supportedTokens\r\n    }\r\n    struct PendingMarketOrder{\r\n        Trade trade;\r\n        uint block;\r\n        uint wantedPrice;           // PRECISION\r\n        uint slippageP;             // PRECISION (%)\r\n        uint spreadReductionP;\r\n        uint tokenId;               // index in supportedTokens\r\n    }\r\n    struct PendingNftOrder{\r\n        address nftHolder;\r\n        uint nftId;\r\n        address trader;\r\n        uint pairIndex;\r\n        uint index;\r\n        LimitOrder orderType;\r\n    }\r\n    function PRECISION() external pure returns(uint);\r\n    function gov() external view returns(address);\r\n    function dev() external view returns(address);\r\n    function dai() external view returns(TokenInterfaceV5);\r\n    function token() external view returns(TokenInterfaceV5);\r\n    function linkErc677() external view returns(TokenInterfaceV5);\r\n    function tokenDaiRouter() external view returns(UniswapRouterInterfaceV5);\r\n    function priceAggregator() external view returns(AggregatorInterfaceV5);\r\n    function vault() external view returns(VaultInterfaceV5);\r\n    function trading() external view returns(address);\r\n    function callbacks() external view returns(address);\r\n    function handleTokens(address,uint,bool) external;\r\n    function transferDai(address, address, uint) external;\r\n    function transferLinkToAggregator(address, uint, uint) external;\r\n    function unregisterTrade(address, uint, uint) external;\r\n    function unregisterPendingMarketOrder(uint, bool) external;\r\n    function unregisterOpenLimitOrder(address, uint, uint) external;\r\n    function hasOpenLimitOrder(address, uint, uint) external view returns(bool);\r\n    function storePendingMarketOrder(PendingMarketOrder memory, uint, bool) external;\r\n    function storeReferral(address, address) external;\r\n    function openTrades(address, uint, uint) external view returns(Trade memory);\r\n    function openTradesInfo(address, uint, uint) external view returns(TradeInfo memory);\r\n    function updateSl(address, uint, uint, uint) external;\r\n    function updateTp(address, uint, uint, uint) external;\r\n    function getOpenLimitOrder(address, uint, uint) external view returns(OpenLimitOrder memory);\r\n    function spreadReductionsP(uint) external view returns(uint);\r\n    function positionSizeTokenDynamic(uint,uint) external view returns(uint);\r\n    function maxSlP() external view returns(uint);\r\n    function storeOpenLimitOrder(OpenLimitOrder memory) external;\r\n    function reqID_pendingMarketOrder(uint) external view returns(PendingMarketOrder memory);\r\n    function storePendingNftOrder(PendingNftOrder memory, uint) external;\r\n    function updateOpenLimitOrder(OpenLimitOrder calldata) external;\r\n    function firstEmptyTradeIndex(address, uint) external view returns(uint);\r\n    function firstEmptyOpenLimitIndex(address, uint) external view returns(uint);\r\n    function increaseNftRewards(uint, uint) external;\r\n    function nftSuccessTimelock() external view returns(uint);\r\n    function currentPercentProfit(uint,uint,bool,uint) external view returns(int);\r\n    function reqID_pendingNftOrder(uint) external view returns(PendingNftOrder memory);\r\n    function setNftLastSuccess(uint) external;\r\n    function updateTrade(Trade memory) external;\r\n    function nftLastSuccess(uint) external view returns(uint);\r\n    function unregisterPendingNftOrder(uint) external;\r\n    function handleDevGovFees(uint, uint, bool, bool) external returns(uint);\r\n    function distributeLpRewards(uint) external;\r\n    function getReferral(address) external view returns(address);\r\n    function increaseReferralRewards(address, uint) external;\r\n    function storeTrade(Trade memory, TradeInfo memory) external;\r\n    function setLeverageUnlocked(address, uint) external;\r\n    function getLeverageUnlocked(address) external view returns(uint);\r\n    function openLimitOrdersCount(address, uint) external view returns(uint);\r\n    function maxOpenLimitOrdersPerPair() external view returns(uint);\r\n    function openTradesCount(address, uint) external view returns(uint);\r\n    function pendingMarketOpenCount(address, uint) external view returns(uint);\r\n    function pendingMarketCloseCount(address, uint) external view returns(uint);\r\n    function maxTradesPerPair() external view returns(uint);\r\n    function maxTradesPerBlock() external view returns(uint);\r\n    function tradesPerBlock(uint) external view returns(uint);\r\n    function pendingOrderIdsCount(address) external view returns(uint);\r\n    function maxPendingMarketOrders() external view returns(uint);\r\n    function maxGainP() external view returns(uint);\r\n    function defaultLeverageUnlocked() external view returns(uint);\r\n    function openInterestDai(uint, uint) external view returns(uint);\r\n    function getPendingOrderIds(address) external view returns(uint[] memory);\r\n    function traders(address) external view returns(Trader memory);\r\n    function nfts(uint) external view returns(NftInterfaceV5);\r\n}\r\n\r\n// File: contracts\\GNSTradingVaultV5.sol\r\n\r\n\r\npragma solidity 0.8.7;\r\n\r\ncontract GNSTradingVaultV5{\r\n\r\n    uint public constant PRECISION = 1e5;\r\n    StorageInterfaceV5 public immutable storageT;\r\n    address public constant rewardDistributor = 0xC66FbE50Dd33c9AAdd65707F7088D597C86fE00F;\r\n\r\n    // PARAMS\r\n    // 1. Refill\r\n    uint public blocksBaseRefill = 2500;    // block\r\n    uint public refillLiqP = 0.1 * 1e5;     // PRECISION (%)\r\n    uint public powerRefill = 5;            // no decimal    \r\n\r\n    // 2. Deplete\r\n    uint public blocksBaseDeplete = 10000;  // block\r\n    uint public blocksMinDeplete = 2000;    // block\r\n    uint public depleteLiqP = 0.3 * 1e5;    // PRECISION (%)\r\n    uint public coeffDepleteP = 100;        // %\r\n    uint public thresholdDepleteP = 10;     // %\r\n\r\n    // 3. Staking\r\n    uint public withdrawTimelock = 43200;   // blocks\r\n    uint public maxWithdrawP = 25;          // %\r\n\r\n    // 4. Trading\r\n    uint public swapFeeP = 0.3 * 1e5;       // PRECISION (%)\r\n\r\n    // STATE\r\n    // 1. DAI balance\r\n    uint public maxBalanceDai;      // 1e18\r\n    uint public currentBalanceDai;  // 1e18\r\n    uint public lastActionBlock;    // block\r\n\r\n    // 2. DAI staking rewards\r\n    uint public accDaiPerDai;       // 1e18\r\n    uint public rewardsDai;         // 1e18\r\n\r\n    // 3. MATIC staking rewards\r\n    uint public maticPerBlock;      // 1e18\r\n    uint public accMaticPerDai;     // 1e18\r\n    uint public maticStartBlock;    // 1e18\r\n    uint public maticEndBlock;      // 1e18\r\n    uint public maticLastRewardBlock;     // 1e18\r\n    uint public rewardsMatic;       // 1e18\r\n\r\n    // 4. Mappings\r\n    struct User{\r\n        uint daiDeposited;\r\n        uint maxDaiDeposited;\r\n        uint withdrawBlock;\r\n        uint debtDai;\r\n        uint debtMatic;\r\n    }\r\n    mapping(address => User) public users;\r\n    mapping(address => uint) public daiToClaim;\r\n\r\n    // EVENTS\r\n    event Deposited(address caller,  uint amount, uint newCurrentBalanceDai, uint newMaxBalanceDai);\r\n    event Withdrawn(address caller, uint amount, uint newCurrentBalanceDai, uint newMaxBalanceDai);\r\n    event Sent(address caller, address trader, uint amount,uint newCurrentBalanceDai, uint maxBalanceDai);\r\n    event ToClaim(address caller, address trader, uint amount,uint currentBalanceDai, uint maxBalanceDai);\r\n    event Claimed(address trader, uint amount, uint newCurrentBalanceDai, uint maxBalanceDai);\r\n    event Refilled(address caller, uint daiAmount, uint newCurrentBalanceDai, uint maxBalanceDai, uint tokensMinted);\r\n    event Depleted(address caller, uint daiAmount, uint newCurrentBalanceDai, uint maxBalanceDai, uint tokensBurnt);\r\n    event ReceivedFromTrader(address caller, address trader, uint daiAmount, uint vaultFeeDai, uint newCurrentBalanceDai, uint maxBalanceDai);\r\n    event AddressUpdated(string name, address a);\r\n    event NumberUpdated(string name, uint value);\r\n\r\n    constructor(StorageInterfaceV5 _storageT){ \r\n        require(address(_storageT) != address(0), \"ADDRESS_0\");\r\n        storageT = _storageT;\r\n    }\r\n\r\n    modifier onlyGov(){ require(msg.sender == storageT.gov(), \"GOV_ONLY\"); _; }\r\n    modifier onlyCallbacks(){ require(msg.sender == storageT.callbacks(), \"CALLBACKS_ONLY\"); _; }\r\n\r\n    // Manage state\r\n    function setBlocksBaseRefill(uint _blocksBaseRefill) external onlyGov{\r\n        require(_blocksBaseRefill >= 1000, \"BELOW_1000\");\r\n        blocksBaseRefill = _blocksBaseRefill;\r\n        emit NumberUpdated(\"blocksBaseRefill\", _blocksBaseRefill);\r\n    }\r\n    function setBlocksBaseDeplete(uint _blocksBaseDeplete) external onlyGov{\r\n        require(_blocksBaseDeplete >= 1000, \"BELOW_1000\");\r\n        blocksBaseDeplete = _blocksBaseDeplete;\r\n        emit NumberUpdated(\"blocksBaseDeplete\", _blocksBaseDeplete);\r\n    }\r\n    function setBlocksMinDeplete(uint _blocksMinDeplete) external onlyGov{\r\n        require(_blocksMinDeplete >= 1000, \"BELOW_1000\");\r\n        blocksMinDeplete = _blocksMinDeplete;\r\n        emit NumberUpdated(\"blocksMinDeplete\", _blocksMinDeplete);\r\n    }\r\n    function setRefillLiqP(uint _refillLiqP) external onlyGov{\r\n        require(_refillLiqP > 0, \"VALUE_0\");\r\n        require(_refillLiqP <= 3*PRECISION/10, \"ABOVE_0_POINT_3\");\r\n        refillLiqP = _refillLiqP;\r\n        emit NumberUpdated(\"refillLiqP\", _refillLiqP);\r\n    }\r\n    function setDepleteLiqP(uint _depleteLiqP) external onlyGov{\r\n        require(_depleteLiqP > 0, \"VALUE_0\");\r\n        require(_depleteLiqP <= 3*PRECISION/10, \"ABOVE_0_POINT_3\");\r\n        depleteLiqP = _depleteLiqP;\r\n        emit NumberUpdated(\"depleteLiqP\", _depleteLiqP);\r\n    }\r\n    function setPowerRefill(uint _powerRefill) external onlyGov{\r\n        require(_powerRefill >= 2, \"BELOW_2\");\r\n        require(_powerRefill <= 10, \"ABOVE_10\");\r\n        powerRefill = _powerRefill;\r\n        emit NumberUpdated(\"powerRefill\", _powerRefill);\r\n    }\r\n    function setCoeffDepleteP(uint _coeffDepleteP) external onlyGov{\r\n        coeffDepleteP = _coeffDepleteP;\r\n        emit NumberUpdated(\"coeffDepleteP\", _coeffDepleteP);\r\n    }\r\n    function setThresholdDepleteP(uint _thresholdDepleteP) external onlyGov{\r\n        require(_thresholdDepleteP <= 100, \"ABOVE_100\");\r\n        thresholdDepleteP = _thresholdDepleteP;\r\n        emit NumberUpdated(\"thresholdDepleteP\", _thresholdDepleteP);\r\n    }\r\n    function setSwapFeeP(uint _swapFeeP) external onlyGov{\r\n        require(_swapFeeP <= PRECISION, \"ABOVE_1\");\r\n        swapFeeP = _swapFeeP;\r\n        emit NumberUpdated(\"swapFeeP\", _swapFeeP);\r\n    }\r\n    function setWithdrawTimelock(uint _withdrawTimelock) external onlyGov{\r\n        require(_withdrawTimelock > 43200, \"LESS_THAN_1_DAY\");\r\n        withdrawTimelock = _withdrawTimelock;\r\n        emit NumberUpdated(\"withdrawTimelock\", _withdrawTimelock);\r\n    }\r\n    function setMaxWithdrawP(uint _maxWithdrawP) external onlyGov{\r\n        require(_maxWithdrawP >= 10, \"BELOW_10\");\r\n        require(_maxWithdrawP <= 100, \"ABOVE_100\");\r\n        maxWithdrawP = _maxWithdrawP;\r\n        emit NumberUpdated(\"maxWithdrawP\", _maxWithdrawP);\r\n    }\r\n\r\n    // Refill\r\n    function refill() external{\r\n        require(currentBalanceDai < maxBalanceDai, \"ALREADY_FULL\");\r\n        require(block.number >= lastActionBlock + blocksBetweenRefills(currentBalanceDai, maxBalanceDai), \"TOO_EARLY\");\r\n\r\n        (uint tokenReserve, ) = storageT.priceAggregator().tokenDaiReservesLp();\r\n        uint tokensToMint = tokenReserve*refillLiqP/100/PRECISION;\r\n\r\n        storageT.handleTokens(address(this), tokensToMint, true);\r\n\r\n        address[] memory tokenToDaiPath = new address[](2);\r\n        tokenToDaiPath[0] = address(storageT.token());\r\n        tokenToDaiPath[1] = address(storageT.dai());\r\n\r\n        storageT.token().approve(address(storageT.tokenDaiRouter()), tokensToMint);\r\n        uint[] memory amounts = storageT.tokenDaiRouter().swapExactTokensForTokens(\r\n            tokensToMint,\r\n            0,\r\n            tokenToDaiPath,\r\n            address(this),\r\n            block.timestamp + 300\r\n        );\r\n\r\n        currentBalanceDai += amounts[1];\r\n        lastActionBlock = block.number;\r\n\r\n        emit Refilled(msg.sender, amounts[1], currentBalanceDai, maxBalanceDai, tokensToMint);\r\n    }\r\n    function blocksBetweenRefills(uint _currentBalanceDai, uint _maxBalanceDai) public view returns(uint){\r\n        uint blocks = (_currentBalanceDai*PRECISION/_maxBalanceDai)**powerRefill*blocksBaseRefill/(PRECISION**powerRefill);\r\n        return blocks >= 1 ? blocks : 1;\r\n    }\r\n\r\n    // Deplete\r\n    function deplete() external{\r\n        require(currentBalanceDai > maxBalanceDai*(100+thresholdDepleteP)/100, \"NOT_FULL\");\r\n        require(block.number >= lastActionBlock + blocksBetweenDepletes(currentBalanceDai, maxBalanceDai), \"TOO_EARLY\");\r\n\r\n        (, uint daiReserve) = storageT.priceAggregator().tokenDaiReservesLp();\r\n        uint daiToBuy = daiReserve*depleteLiqP/100/PRECISION;\r\n\r\n        address[] memory daiToTokenPath = new address[](2);\r\n        daiToTokenPath[0] = address(storageT.dai());\r\n        daiToTokenPath[1] = address(storageT.token());\r\n\r\n        require(storageT.dai().approve(address(storageT.tokenDaiRouter()), daiToBuy));\r\n        uint[] memory amounts = storageT.tokenDaiRouter().swapExactTokensForTokens(\r\n            daiToBuy,\r\n            0,\r\n            daiToTokenPath,\r\n            address(this),\r\n            block.timestamp + 300\r\n        );\r\n\r\n        storageT.handleTokens(address(this), amounts[1], false);\r\n\r\n        currentBalanceDai -= daiToBuy;\r\n        lastActionBlock = block.number;\r\n\r\n        emit Depleted(msg.sender, daiToBuy, currentBalanceDai, maxBalanceDai, amounts[1]);\r\n    }\r\n    function blocksBetweenDepletes(uint _currentBalanceDai, uint _maxBalanceDai) public view returns(uint){\r\n        uint blocks = blocksBaseDeplete - (100*_currentBalanceDai - _maxBalanceDai*(100+thresholdDepleteP))*coeffDepleteP/_currentBalanceDai;\r\n        return blocks >= blocksMinDeplete ? blocks : blocksMinDeplete;\r\n    }\r\n\r\n    // Staking (user interaction)\r\n    function harvest() public{\r\n        User storage u = users[msg.sender];\r\n\r\n        require(storageT.dai().transfer(msg.sender, pendingRewardDai()));\r\n        u.debtDai = u.daiDeposited * accDaiPerDai / 1e18;\r\n\r\n        uint pendingMatic = pendingRewardMatic();\r\n        accMaticPerDai = pendingAccMaticPerDai();\r\n        maticLastRewardBlock = block.number;\r\n        u.debtMatic = u.daiDeposited * accMaticPerDai / 1e18;\r\n        payable(msg.sender).transfer(pendingMatic);\r\n    }\r\n    function depositDai(uint _amount) external{\r\n        User storage user = users[msg.sender];\r\n\r\n        require(_amount > 0, \"AMOUNT_0\");\r\n        require(storageT.dai().transferFrom(msg.sender, address(this), _amount));\r\n\r\n        harvest();\r\n\r\n        currentBalanceDai += _amount;\r\n        maxBalanceDai += _amount;\r\n\r\n        user.daiDeposited += _amount;\r\n        user.maxDaiDeposited = user.daiDeposited;\r\n        user.debtDai = user.daiDeposited * accDaiPerDai / 1e18;\r\n        user.debtMatic = user.daiDeposited * accMaticPerDai / 1e18;\r\n\r\n        emit Deposited(msg.sender, _amount, currentBalanceDai, maxBalanceDai);\r\n    }\r\n    function withdrawDai(uint _amount) external{\r\n        User storage user = users[msg.sender];\r\n\r\n        require(_amount > 0, \"AMOUNT_0\");\r\n        require(_amount <= currentBalanceDai, \"BALANCE_TOO_LOW\");\r\n        require(_amount <= user.daiDeposited, \"WITHDRAWING_MORE_THAN_DEPOSITED\");\r\n        require(_amount <= user.maxDaiDeposited * maxWithdrawP / 100, \"MAX_WITHDRAW_P\");\r\n        require(block.number >= user.withdrawBlock + withdrawTimelock, \"TOO_EARLY\");\r\n\r\n        harvest();\r\n\r\n        currentBalanceDai -= _amount;\r\n        maxBalanceDai -= _amount;\r\n\r\n        user.daiDeposited -= _amount;\r\n        user.withdrawBlock = block.number;\r\n        user.debtDai = user.daiDeposited * accDaiPerDai / 1e18;\r\n        user.debtMatic = user.daiDeposited * accMaticPerDai / 1e18;\r\n\r\n        require(storageT.dai().transfer(msg.sender, _amount));\r\n\r\n        emit Withdrawn(msg.sender, _amount, currentBalanceDai, maxBalanceDai);\r\n    }\r\n\r\n    // MATIC incentives\r\n    function distributeRewardMatic(uint _startBlock, uint _endBlock) external payable{\r\n        require(msg.sender == rewardDistributor, \"WRONG_CALLER\");\r\n        require(msg.value > 0, \"AMOUNT_0\");\r\n        require(_startBlock < _endBlock, \"START_AFTER_END\");\r\n        require(_startBlock > block.number, \"START_BEFORE_NOW\");\r\n        require(_endBlock - _startBlock >= 100000, \"TOO_SHORT\");\r\n        require(_endBlock - _startBlock <= 1500000, \"TOO_LONG\");\r\n        require(block.number > maticEndBlock, \"LAST_MATIC_DISTRIBUTION_NOT_ENDED\");\r\n        require(maxBalanceDai > 0, \"NO_DAI_STAKED\");\r\n\r\n        accMaticPerDai = pendingAccMaticPerDai();\r\n        rewardsMatic += msg.value;\r\n        maticLastRewardBlock = 0;\r\n\r\n        maticPerBlock = msg.value / (_endBlock - _startBlock);\r\n        maticStartBlock = _startBlock;\r\n        maticEndBlock = _endBlock;\r\n    }\r\n    function pendingAccMaticPerDai() view private returns(uint){\r\n        if(maxBalanceDai == 0){ return accMaticPerDai; }\r\n        \r\n        uint pendingRewardBlocks = 0;\r\n        if(block.number > maticStartBlock){\r\n            if(block.number <= maticEndBlock){\r\n                pendingRewardBlocks = maticLastRewardBlock == 0 ? block.number - maticStartBlock : block.number - maticLastRewardBlock;\r\n            }else if(maticLastRewardBlock <= maticEndBlock){\r\n                pendingRewardBlocks = maticLastRewardBlock == 0 ? maticEndBlock - maticStartBlock : maticEndBlock - maticLastRewardBlock;\r\n            }\r\n        }\r\n        return accMaticPerDai + pendingRewardBlocks*maticPerBlock*1e18/maxBalanceDai;\r\n    }\r\n    function pendingRewardMatic() public view returns(uint){\r\n        User memory u = users[msg.sender];\r\n        return u.daiDeposited * pendingAccMaticPerDai() / 1e18 - u.debtMatic;\r\n    }\r\n\r\n    // DAI incentives\r\n    function distributeRewardDai(uint _amount) public onlyCallbacks{        \r\n        if(maxBalanceDai > 0){\r\n            currentBalanceDai -= _amount;\r\n            accDaiPerDai += _amount * 1e18 / maxBalanceDai;\r\n            rewardsDai += _amount;\r\n        }\r\n    }\r\n    function pendingRewardDai() public view returns(uint){\r\n        User memory u = users[msg.sender];\r\n        return u.daiDeposited * accDaiPerDai / 1e18 - u.debtDai;\r\n    }\r\n\r\n    // Handle traders DAI when a trade is closed\r\n    function sendDaiToTrader(address _trader, uint _amount) external onlyCallbacks{\r\n        _amount -= swapFeeP * _amount / 100 / PRECISION;\r\n\r\n        if(_amount <= currentBalanceDai){\r\n            currentBalanceDai -= _amount;\r\n            require(storageT.dai().transfer(_trader, _amount));\r\n            emit Sent(msg.sender, _trader, _amount, currentBalanceDai, maxBalanceDai);\r\n        }else{\r\n            daiToClaim[_trader] += _amount;\r\n            emit ToClaim(msg.sender, _trader, _amount, currentBalanceDai, maxBalanceDai);\r\n        }\r\n    }\r\n    function claimDai() external{\r\n        uint amount = daiToClaim[msg.sender];\r\n        require(amount > 0, \"NOTHING_TO_CLAIM\");\r\n        require(currentBalanceDai > amount, \"BALANCE_TOO_LOW\");\r\n\r\n        currentBalanceDai -= amount;\r\n        require(storageT.dai().transfer(msg.sender, amount));\r\n        daiToClaim[msg.sender] = 0;\r\n\r\n        emit Claimed(msg.sender, amount, currentBalanceDai, maxBalanceDai);\r\n    }\r\n\r\n    // Handle DAI from opened trades\r\n    function receiveDaiFromTrader(address _trader, uint _amount, uint _vaultFee) external onlyCallbacks{\r\n        storageT.transferDai(address(storageT), address(this), _amount);\r\n        currentBalanceDai += _amount;\r\n\r\n        distributeRewardDai(_vaultFee);\r\n\r\n        emit ReceivedFromTrader(msg.sender, _trader, _amount, _vaultFee, currentBalanceDai, maxBalanceDai);\r\n    }\r\n\r\n    // Useful backend function (ignore)\r\n    function backend(address _trader) external view returns(uint,uint,uint,StorageInterfaceV5.Trader memory,uint[] memory, StorageInterfaceV5.PendingMarketOrder[] memory, uint[][5] memory){\r\n        uint[] memory pendingIds = storageT.getPendingOrderIds(_trader);\r\n\r\n        StorageInterfaceV5.PendingMarketOrder[] memory pendingMarket = new StorageInterfaceV5.PendingMarketOrder[](pendingIds.length);\r\n        for(uint i = 0; i < pendingIds.length; i++){\r\n            pendingMarket[i] = storageT.reqID_pendingMarketOrder(pendingIds[i]);\r\n        }\r\n\r\n        uint[][5] memory nftIds;\r\n        for(uint j = 0; j < 5; j++){\r\n            uint nftsCount = storageT.nfts(j).balanceOf(_trader);\r\n            nftIds[j] = new uint[](nftsCount);\r\n            for(uint i = 0; i < nftsCount; i++){ \r\n                nftIds[j][i] = storageT.nfts(j).tokenOfOwnerByIndex(_trader, i); \r\n            }\r\n        }\r\n\r\n        return (\r\n            storageT.dai().allowance(_trader, address(storageT)),\r\n            storageT.dai().balanceOf(_trader),\r\n            storageT.linkErc677().allowance(_trader, address(storageT)),\r\n            storageT.traders(_trader),\r\n            pendingIds, \r\n            pendingMarket, \r\n            nftIds\r\n        );\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract StorageInterfaceV5\",\"name\":\"_storageT\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"a\",\"type\":\"address\"}],\"name\":\"AddressUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCurrentBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBalanceDai\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCurrentBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensBurnt\",\"type\":\"uint256\"}],\"name\":\"Depleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCurrentBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxBalanceDai\",\"type\":\"uint256\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NumberUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"vaultFeeDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCurrentBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBalanceDai\",\"type\":\"uint256\"}],\"name\":\"ReceivedFromTrader\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"daiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCurrentBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokensMinted\",\"type\":\"uint256\"}],\"name\":\"Refilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCurrentBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBalanceDai\",\"type\":\"uint256\"}],\"name\":\"Sent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"currentBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxBalanceDai\",\"type\":\"uint256\"}],\"name\":\"ToClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newCurrentBalanceDai\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMaxBalanceDai\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"PRECISION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accDaiPerDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"accMaticPerDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"}],\"name\":\"backend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"leverageUnlocked\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralRewardsTotal\",\"type\":\"uint256\"}],\"internalType\":\"struct StorageInterfaceV5.Trader\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"pairIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"initialPosToken\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionSizeDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"openPrice\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"buy\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"leverage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"sl\",\"type\":\"uint256\"}],\"internalType\":\"struct StorageInterfaceV5.Trade\",\"name\":\"trade\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"wantedPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"slippageP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"spreadReductionP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct StorageInterfaceV5.PendingMarketOrder[]\",\"name\":\"\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256[][5]\",\"name\":\"\",\"type\":\"uint256[][5]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksBaseDeplete\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksBaseRefill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentBalanceDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBalanceDai\",\"type\":\"uint256\"}],\"name\":\"blocksBetweenDepletes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_currentBalanceDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_maxBalanceDai\",\"type\":\"uint256\"}],\"name\":\"blocksBetweenRefills\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"blocksMinDeplete\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"coeffDepleteP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentBalanceDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"daiToClaim\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"depleteLiqP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"distributeRewardDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_endBlock\",\"type\":\"uint256\"}],\"name\":\"distributeRewardMatic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"harvest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lastActionBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maticEndBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maticLastRewardBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maticPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maticStartBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxBalanceDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWithdrawP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRewardDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingRewardMatic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"powerRefill\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_vaultFee\",\"type\":\"uint256\"}],\"name\":\"receiveDaiFromTrader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refillLiqP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardDistributor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsDai\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsMatic\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendDaiToTrader\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocksBaseDeplete\",\"type\":\"uint256\"}],\"name\":\"setBlocksBaseDeplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocksBaseRefill\",\"type\":\"uint256\"}],\"name\":\"setBlocksBaseRefill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_blocksMinDeplete\",\"type\":\"uint256\"}],\"name\":\"setBlocksMinDeplete\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_coeffDepleteP\",\"type\":\"uint256\"}],\"name\":\"setCoeffDepleteP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_depleteLiqP\",\"type\":\"uint256\"}],\"name\":\"setDepleteLiqP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_maxWithdrawP\",\"type\":\"uint256\"}],\"name\":\"setMaxWithdrawP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_powerRefill\",\"type\":\"uint256\"}],\"name\":\"setPowerRefill\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_refillLiqP\",\"type\":\"uint256\"}],\"name\":\"setRefillLiqP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_swapFeeP\",\"type\":\"uint256\"}],\"name\":\"setSwapFeeP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_thresholdDepleteP\",\"type\":\"uint256\"}],\"name\":\"setThresholdDepleteP\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_withdrawTimelock\",\"type\":\"uint256\"}],\"name\":\"setWithdrawTimelock\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"storageT\",\"outputs\":[{\"internalType\":\"contract StorageInterfaceV5\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFeeP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"thresholdDepleteP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"daiDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxDaiDeposited\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtDai\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"debtMatic\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTimelock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GNSTradingVaultV5", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "999", "ConstructorArguments": "000000000000000000000000aee4d11a16b2bc65edd6416fb626eb404a6d65bd", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://5aac169588d49a12f13ae06895694618fd8d5f9acfe928298068c18e9a7a4996"}