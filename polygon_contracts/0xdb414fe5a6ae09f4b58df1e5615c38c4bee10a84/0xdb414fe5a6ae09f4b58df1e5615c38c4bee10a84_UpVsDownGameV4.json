{"SourceCode": "// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: contracts/UpVsDownGameV4.sol\r\n\r\npragma solidity >=0.4.22 <0.9.0;\r\n\r\ncontract UpVsDownGameV4 is Ownable {\r\n\r\n  struct BetGroup {\r\n    uint256[] bets;\r\n    address[] addresses;\r\n    string[] avatars;\r\n    string[] countries;\r\n    string[] whiteLabelIds;\r\n    uint256 total;\r\n    uint256 distributedCount;\r\n    uint256 totalDistributed;\r\n  }\r\n\r\n  struct Round {\r\n    bool created;\r\n    int32 startPrice;\r\n    int32 endPrice;\r\n    uint256 minBetAmount;\r\n    uint256 maxBetAmount;\r\n    uint256 poolBetsLimit;\r\n    BetGroup upBetGroup;\r\n    BetGroup downBetGroup;\r\n    int64 roundStartTime;\r\n    uint256 tradesStartTimeMS;\r\n    uint256 tradesEndTimeMS;\r\n  }\r\n\r\n  struct Distribution {\r\n    uint256 fee;\r\n    uint256 feeJackpot;\r\n    uint256 totalMinusFee;\r\n    uint256 totalMinusJackpotFee;\r\n    uint256 totalFees;\r\n    uint256 pending;\r\n  }\r\n\r\n  address public gameController;\r\n  mapping(bytes => Round) public pools;\r\n  uint8 public feePercentage = 9;\r\n  uint8 public feeJackpotPercentage = 1;\r\n  address public feeAddress = msg.sender; //default fee address\r\n  address public feeJackpotAddress = msg.sender; //default fee jackpot address\r\n  bool public isRunning;\r\n  bytes public notRunningReason;\r\n\r\n  // Errors\r\n\r\n  error PendingDistributions();\r\n\r\n  // Events\r\n\r\n  event RoundStarted(bytes poolId, int64 timestamp, int32 price, uint256 minTradeAmount, uint256 maxTradeAmount, uint256 poolTradesLimit, bytes indexed indexedPoolId);\r\n  event RoundEnded(bytes poolId, int64 timestamp, int32 startPrice, int32 endPrice, bytes indexed indexedPoolId);\r\n  event TradePlaced(bytes poolId, address sender, uint256 amount, string prediction, uint256 newTotal, bytes indexed indexedPoolId, address indexed indexedSender, string avatarUrl, string countryCode, int64 roundStartTime, string whiteLabelId);\r\n  event TradeReturned(bytes poolId, address sender, uint256 amount, string whiteLabelId);\r\n  event GameStopped(bytes reason);\r\n  event GameStarted();\r\n  event RoundDistributed(bytes poolId, uint totalWinners, uint from, uint to, int64 timestamp);\r\n  event TradeWinningsSent(bytes poolId, address sender, uint256 tradeAmount, uint256 winningsAmount, address indexed indexedSender, string whiteLabelId, uint8 feePercentage, uint8 feeJackpotPercentage);\r\n\r\n\r\n  // Modifiers\r\n\r\n  modifier onlyGameController () {\r\n    require(msg.sender == gameController, 'Only game controller can do this');\r\n    _;\r\n  }\r\n\r\n  modifier onlyOpenPool (bytes calldata poolId) {\r\n    require(isPoolOpen(poolId), 'This pool has a round in progress');\r\n    _;\r\n  }\r\n\r\n  modifier onlyGameRunning () {\r\n    require(isRunning, 'The game is not running');\r\n    _;\r\n  }\r\n\r\n  modifier onlyPoolExists (bytes calldata poolId) {\r\n    require(pools[poolId].created, 'Pool does not exist');\r\n    _;\r\n  }\r\n\r\n  constructor(address newGameController) {\r\n    gameController = newGameController;\r\n  }\r\n\r\n  // Methods\r\n\r\n  function changeGameControllerAddress(address newGameControllerAddress) public onlyOwner {\r\n    require(newGameControllerAddress != address(0x0) , \"Address cannot be zero address\");\r\n\r\n    gameController = newGameControllerAddress;\r\n  }\r\n\r\n  function changeGameFeePercentage(uint8 newFeePercentage) public onlyOwner {\r\n    require (newFeePercentage <=100 , \"Wrong fee percentage value\");\r\n\r\n    feePercentage = newFeePercentage;\r\n  }\r\n\r\n  function changeGameFeeJackpotPercentage(uint8 newFeeJackpotPercentage) public onlyOwner {\r\n    require (newFeeJackpotPercentage <=100 , \"Wrong jackpot fee percentage value\");\r\n\r\n    feeJackpotPercentage = newFeeJackpotPercentage;\r\n  }\r\n\r\n  function changeGameFeeAddress(address newFeeAddress) public onlyOwner {\r\n    require(newFeeAddress != address(0x0) , \"Address cannot be zero address\");\r\n\r\n    feeAddress = newFeeAddress;\r\n  }\r\n\r\n  function changeGameFeeJackpotAddress(address newFeeJackpotAddress) public onlyOwner {\r\n    require(newFeeJackpotAddress != address(0x0) , \"Address cannot be zero address\");\r\n\r\n    feeJackpotAddress = newFeeJackpotAddress;\r\n  }\r\n\r\n  function stopGame(bytes calldata reason) public onlyOwner {\r\n    isRunning = false;\r\n    notRunningReason = reason;\r\n    emit GameStopped(reason);\r\n  }\r\n\r\n  function startGame() public onlyOwner {\r\n    isRunning = true;\r\n    notRunningReason = '';\r\n    emit GameStarted();\r\n  }\r\n\r\n  function createPool(bytes calldata poolId, uint256 minBetAmount , uint256 maxBetAmount, uint256 poolBetsLimit) public onlyGameController {\r\n    pools[poolId].created = true;\r\n    pools[poolId].minBetAmount = minBetAmount;\r\n    pools[poolId].maxBetAmount = maxBetAmount;\r\n    pools[poolId].poolBetsLimit = poolBetsLimit;\r\n  }\r\n\r\n  function trigger(\r\n    bytes calldata poolId,\r\n    int64 timeMS,\r\n    uint256 tradesStartTimeMS,\r\n    uint256 tradesEndTimeMS,\r\n    int32 price,\r\n    uint32 batchSize\r\n  ) public onlyGameController onlyPoolExists(poolId) {\r\n    Round storage currentRound = pools[poolId];\r\n\r\n    if(isPoolOpen(poolId)) {\r\n      require(isRunning, 'The game is not running, rounds can only be ended at this point');\r\n      currentRound.startPrice = price;\r\n      currentRound.roundStartTime = timeMS;\r\n      currentRound.tradesStartTimeMS = tradesStartTimeMS;\r\n      currentRound.tradesEndTimeMS = tradesEndTimeMS;\r\n      \r\n      emit RoundStarted(poolId, timeMS, currentRound.startPrice, currentRound.minBetAmount, currentRound.maxBetAmount, currentRound.poolBetsLimit, poolId);\r\n    } else if (currentRound.endPrice == 0) {\r\n      currentRound.endPrice = price;\r\n\r\n      emit RoundEnded(poolId, timeMS, currentRound.startPrice, currentRound.endPrice, poolId);\r\n\r\n      distribute(poolId, batchSize, timeMS);\r\n    } else {\r\n      revert PendingDistributions();\r\n    }\r\n  }\r\n\r\n  function getContractBalance() public view returns (uint256) {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function returnBets (\r\n    bytes calldata poolId,\r\n    BetGroup storage group,\r\n    uint32 batchSize\r\n  ) private {\r\n    uint256 pending = group.bets.length - group.distributedCount;\r\n    uint256 limit = pending > batchSize ? batchSize : pending;\r\n    uint256 to = group.distributedCount + limit;\r\n\r\n    for (uint i = group.distributedCount; i < to; i ++) {\r\n      sendEther(group.addresses[i], group.bets[i]);\r\n      emit TradeReturned(poolId, group.addresses[i], group.bets[i], group.whiteLabelIds[i]);\r\n    }\r\n\r\n    group.distributedCount = to;\r\n  }\r\n\r\n  function distribute (\r\n    bytes calldata poolId,\r\n    uint32 batchSize,\r\n    int64 timeMS\r\n  ) public onlyGameController onlyPoolExists(poolId) {\r\n    Round storage round = pools[poolId];\r\n\r\n    if (round.upBetGroup.bets.length == 0 || round.downBetGroup.bets.length == 0 || (round.startPrice == round.endPrice)) {\r\n      if (round.startPrice == round.endPrice){ //In case of TIE return the investments to both sides\r\n        BetGroup storage returnGroupUp = round.upBetGroup;\r\n        BetGroup storage returnGroupDown = round.downBetGroup;\r\n\r\n        uint fromReturnUp = returnGroupUp.distributedCount;\r\n        uint fromReturnDown = returnGroupDown.distributedCount;\r\n\r\n        returnBets(poolId, returnGroupUp, batchSize);\r\n        returnBets(poolId, returnGroupDown, batchSize);\r\n\r\n        emit RoundDistributed(poolId, returnGroupUp.bets.length, fromReturnUp, returnGroupUp.distributedCount,timeMS);\r\n        emit RoundDistributed(poolId, returnGroupDown.bets.length, fromReturnDown, returnGroupDown.distributedCount,timeMS);\r\n\r\n        if (returnGroupUp.distributedCount == returnGroupUp.bets.length && returnGroupDown.distributedCount == returnGroupDown.bets.length) {\r\n          clearPool(poolId);\r\n        }\r\n\r\n      }else{\r\n        BetGroup storage returnGroup = round.downBetGroup.bets.length == 0 ? round.upBetGroup : round.downBetGroup;\r\n\r\n        uint fromReturn = returnGroup.distributedCount;\r\n        returnBets(poolId, returnGroup, batchSize);\r\n        emit RoundDistributed(poolId, returnGroup.bets.length, fromReturn, returnGroup.distributedCount,timeMS);\r\n\r\n        if (returnGroup.distributedCount == returnGroup.bets.length) {\r\n          clearPool(poolId);\r\n        }\r\n      }\r\n\r\n      \r\n      return;\r\n    }\r\n\r\n\r\n    BetGroup storage winners = round.downBetGroup;\r\n    BetGroup storage losers = round.upBetGroup;\r\n\r\n    if (round.startPrice < round.endPrice) {\r\n      winners = round.upBetGroup;\r\n      losers = round.downBetGroup;\r\n    }\r\n\r\n    Distribution memory dist = calculateDistribution(winners, losers);\r\n    uint256 limit = dist.pending > batchSize ? batchSize : dist.pending;\r\n    uint256 to = winners.distributedCount + limit;\r\n\r\n    for (uint i = winners.distributedCount; i < to; i++) {\r\n      uint256 winnings = (winners.bets[i] * dist.totalFees * 100 / winners.total  / 100);\r\n\r\n      sendEther(winners.addresses[i], winnings + winners.bets[i]);\r\n      emit TradeWinningsSent(poolId, winners.addresses[i], winners.bets[i], winnings, winners.addresses[i], winners.whiteLabelIds[i],feePercentage,feeJackpotPercentage);\r\n      winners.totalDistributed = winners.totalDistributed + winnings;\r\n    }\r\n\r\n    emit RoundDistributed(poolId, winners.bets.length, winners.distributedCount, to, timeMS);\r\n\r\n    winners.distributedCount = to;\r\n    if (winners.distributedCount == winners.bets.length) {\r\n      sendEther(feeAddress, (dist.fee + dist.totalMinusFee)*feePercentage / 100);\r\n      sendEther(feeJackpotAddress, (dist.feeJackpot + dist.totalMinusJackpotFee)*feeJackpotPercentage / 100);\r\n      //Send leftovers to fee address\r\n      sendEther(feeAddress,getContractBalance());\r\n\r\n      clearPool(poolId);\r\n    }\r\n  }\r\n\r\n   function calculateDistribution (\r\n    BetGroup storage winners,\r\n    BetGroup storage losers\r\n  ) private view returns (Distribution memory) {\r\n    uint256 fee = feePercentage * losers.total / 100;\r\n    uint256 jackpotFee = feeJackpotPercentage * losers.total / 100;\r\n    uint256 totalFee = fee + jackpotFee;\r\n    uint256 pending = winners.bets.length - winners.distributedCount;\r\n    uint256 totalFees = losers.total - totalFee;\r\n    uint256 totalMinusFee = losers.total - fee;\r\n    uint256 totalMinusJackpotFee = losers.total - jackpotFee;\r\n\r\n    return Distribution({\r\n      fee: fee,\r\n      feeJackpot: jackpotFee,\r\n      totalMinusFee: totalMinusFee,\r\n      totalMinusJackpotFee: totalMinusJackpotFee,\r\n      totalFees: totalFees,\r\n      pending: pending\r\n    });\r\n  }\r\n\r\n  function clearPool (\r\n    bytes calldata poolId\r\n  ) private {\r\n    delete pools[poolId].upBetGroup;\r\n    delete pools[poolId].downBetGroup;\r\n    delete pools[poolId].startPrice;\r\n    delete pools[poolId].endPrice;\r\n  }\r\n\r\n  function hasPendingDistributions(\r\n    bytes calldata poolId\r\n  ) public view returns (bool) {\r\n    return (pools[poolId].upBetGroup.bets.length + pools[poolId].downBetGroup.bets.length) > 0;\r\n  }\r\n\r\n  function isPoolOpen(\r\n    bytes calldata poolId\r\n  ) public view returns (bool) {\r\n    return pools[poolId].startPrice == 0;\r\n  }\r\n\r\n  function addBet (\r\n    BetGroup storage betGroup,\r\n    uint256 amount,\r\n    string calldata avatar,\r\n    string calldata countryCode,\r\n    string calldata whiteLabelId\r\n  ) private returns (uint256) {\r\n    betGroup.bets.push(amount);\r\n    betGroup.addresses.push(msg.sender);\r\n    betGroup.avatars.push(avatar);\r\n    betGroup.countries.push(countryCode);\r\n    betGroup.whiteLabelIds.push(whiteLabelId);\r\n    betGroup.total += amount;\r\n    return betGroup.total;\r\n  }\r\n\r\n  struct makeTradeStruct{\r\n    bytes poolId;\r\n    string avatarUrl;\r\n    string countryCode;\r\n    bool upOrDown;\r\n    string whiteLabelId;\r\n  }\r\n\r\n  struct userDataStruct{\r\n      string avatar;\r\n      string countryCode;\r\n      string whiteLabelId;\r\n      int64 roundStartTime;\r\n    }\r\n\r\n  function makeTrade(\r\n    makeTradeStruct calldata userTrade\r\n  ) public payable onlyOpenPool(userTrade.poolId) onlyGameRunning onlyPoolExists(userTrade.poolId) {\r\n\r\n    require(msg.value > 0, \"Needs to send Matic to trade\");\r\n    require(msg.value >= pools[userTrade.poolId].minBetAmount, \"Trade amount should be higher than the minimum\");\r\n    require(msg.value <= pools[userTrade.poolId].maxBetAmount, \"Trade amount should be lower than the maximum\");\r\n    \r\n    //Prevent making trade while end round transaction being confirmed on blockchain\r\n    require(block.timestamp <= pools[userTrade.poolId].tradesEndTimeMS , \"Round is closing\");\r\n\r\n    //Prevent making trade while round starts\r\n    require(block.timestamp >= pools[userTrade.poolId].tradesStartTimeMS , \"Round not started yet\");\r\n\r\n    uint256 newTotal;\r\n\r\n    if (userTrade.upOrDown) {\r\n      require(pools[userTrade.poolId].upBetGroup.bets.length <= pools[userTrade.poolId].poolBetsLimit-1,\"Pool is full, wait for next round\");\r\n      newTotal = addBet(pools[userTrade.poolId].upBetGroup, msg.value, userTrade.avatarUrl, userTrade.countryCode, userTrade.whiteLabelId);\r\n    } else {\r\n      require(pools[userTrade.poolId].downBetGroup.bets.length <= pools[userTrade.poolId].poolBetsLimit-1,\"Pool is full, wait for next round\");\r\n      newTotal = addBet(pools[userTrade.poolId].downBetGroup, msg.value, userTrade.avatarUrl, userTrade.countryCode, userTrade.whiteLabelId);\r\n    }\r\n\r\n    userDataStruct memory userTradeData;\r\n    userTradeData.avatar = userTrade.avatarUrl;\r\n    userTradeData.countryCode = userTrade.countryCode;\r\n    userTradeData.whiteLabelId = userTrade.whiteLabelId;\r\n    userTradeData.roundStartTime = pools[userTrade.poolId].roundStartTime;\r\n    \r\n    emit TradePlaced(userTrade.poolId, msg.sender, msg.value, (userTrade.upOrDown) ? \"UP\":\"DOWN\", newTotal, \r\n    userTrade.poolId, msg.sender, userTradeData.avatar, userTradeData.countryCode, \r\n    userTradeData.roundStartTime, userTradeData.whiteLabelId);\r\n  }\r\n\r\n  function sendEther (\r\n    address to, \r\n    uint256 amount\r\n  ) private {\r\n    (bool sent, bytes memory data) = payable(to).call{gas: 0, value: amount}(\"\");\r\n    require(sent, \"Couldn't send ether\");\r\n  } \r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGameController\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"PendingDistributions\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"GameStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"GameStopped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalWinners\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int64\",\"name\":\"timestamp\",\"type\":\"int64\"}],\"name\":\"RoundDistributed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"int64\",\"name\":\"timestamp\",\"type\":\"int64\"},{\"indexed\":false,\"internalType\":\"int32\",\"name\":\"startPrice\",\"type\":\"int32\"},{\"indexed\":false,\"internalType\":\"int32\",\"name\":\"endPrice\",\"type\":\"int32\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"indexedPoolId\",\"type\":\"bytes\"}],\"name\":\"RoundEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"int64\",\"name\":\"timestamp\",\"type\":\"int64\"},{\"indexed\":false,\"internalType\":\"int32\",\"name\":\"price\",\"type\":\"int32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minTradeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxTradeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"poolTradesLimit\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"indexedPoolId\",\"type\":\"bytes\"}],\"name\":\"RoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"prediction\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newTotal\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"indexedPoolId\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"indexedSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"avatarUrl\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"int64\",\"name\":\"roundStartTime\",\"type\":\"int64\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"whiteLabelId\",\"type\":\"string\"}],\"name\":\"TradePlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"whiteLabelId\",\"type\":\"string\"}],\"name\":\"TradeReturned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tradeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"winningsAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"indexedSender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"whiteLabelId\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"feePercentage\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"feeJackpotPercentage\",\"type\":\"uint8\"}],\"name\":\"TradeWinningsSent\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newGameControllerAddress\",\"type\":\"address\"}],\"name\":\"changeGameControllerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeAddress\",\"type\":\"address\"}],\"name\":\"changeGameFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newFeeJackpotAddress\",\"type\":\"address\"}],\"name\":\"changeGameFeeJackpotAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newFeeJackpotPercentage\",\"type\":\"uint8\"}],\"name\":\"changeGameFeeJackpotPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"newFeePercentage\",\"type\":\"uint8\"}],\"name\":\"changeGameFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"minBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolBetsLimit\",\"type\":\"uint256\"}],\"name\":\"createPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"batchSize\",\"type\":\"uint32\"},{\"internalType\":\"int64\",\"name\":\"timeMS\",\"type\":\"int64\"}],\"name\":\"distribute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeJackpotAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeJackpotPercentage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feePercentage\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gameController\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"}],\"name\":\"hasPendingDistributions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"}],\"name\":\"isPoolOpen\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isRunning\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"avatarUrl\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"countryCode\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"upOrDown\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"whiteLabelId\",\"type\":\"string\"}],\"internalType\":\"struct UpVsDownGameV4.makeTradeStruct\",\"name\":\"userTrade\",\"type\":\"tuple\"}],\"name\":\"makeTrade\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"notRunningReason\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"pools\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"created\",\"type\":\"bool\"},{\"internalType\":\"int32\",\"name\":\"startPrice\",\"type\":\"int32\"},{\"internalType\":\"int32\",\"name\":\"endPrice\",\"type\":\"int32\"},{\"internalType\":\"uint256\",\"name\":\"minBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBetAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"poolBetsLimit\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"bets\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"avatars\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"countries\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"whiteLabelIds\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distributedCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDistributed\",\"type\":\"uint256\"}],\"internalType\":\"struct UpVsDownGameV4.BetGroup\",\"name\":\"upBetGroup\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"bets\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"string[]\",\"name\":\"avatars\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"countries\",\"type\":\"string[]\"},{\"internalType\":\"string[]\",\"name\":\"whiteLabelIds\",\"type\":\"string[]\"},{\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"distributedCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalDistributed\",\"type\":\"uint256\"}],\"internalType\":\"struct UpVsDownGameV4.BetGroup\",\"name\":\"downBetGroup\",\"type\":\"tuple\"},{\"internalType\":\"int64\",\"name\":\"roundStartTime\",\"type\":\"int64\"},{\"internalType\":\"uint256\",\"name\":\"tradesStartTimeMS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradesEndTimeMS\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"reason\",\"type\":\"bytes\"}],\"name\":\"stopGame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"poolId\",\"type\":\"bytes\"},{\"internalType\":\"int64\",\"name\":\"timeMS\",\"type\":\"int64\"},{\"internalType\":\"uint256\",\"name\":\"tradesStartTimeMS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tradesEndTimeMS\",\"type\":\"uint256\"},{\"internalType\":\"int32\",\"name\":\"price\",\"type\":\"int32\"},{\"internalType\":\"uint32\",\"name\":\"batchSize\",\"type\":\"uint32\"}],\"name\":\"trigger\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "UpVsDownGameV4", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d77cd621164b78f85fb7d56ae75997e6c19b88a1", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3c736c8f1215112629020138a1978a77ad335b97b3ef2f05517f27c02a457a21"}