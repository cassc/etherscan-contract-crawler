{"SourceCode": "pragma solidity ^0.8.0;\r\n \r\n\r\ncontract Ownable {\r\n    \r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    \r\n    /**\r\n     * Constructor assigns ownership to the address used to deploy the contract.\r\n     * */\r\n    constructor() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function getOwner() public view returns(address) {\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n     * Any function with this modifier in its method signature can only be executed by\r\n     * the owner of the contract. Any attempt made by any other account to invoke the \r\n     * functions with this modifier will result in a loss of gas and the contract's state\r\n     * will remain untampered.\r\n     * */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Function restricted to owner of contract\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Allows for the transfer of ownership to another address;\r\n     * \r\n     * @param _newOwner The address to be assigned new ownership.\r\n     * */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(\r\n            _newOwner != address(0)\r\n            && _newOwner != owner \r\n        );\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\nabstract contract DeprecatedMultisenderSC {\r\n    function isPremiumMember(address _who) external virtual view returns(bool);\r\n}\r\n\r\n/**\r\n * Contract acts as an interface between the Crypto Multisender contract and all ERC20 compliant\r\n * tokens. \r\n * */\r\nabstract contract ERC20Interface {\r\n    function transferFrom(address _from, address _to, uint256 _value) public virtual;\r\n    function balanceOf(address who)  public virtual returns (uint256);\r\n    function allowance(address owner, address spender)  public view virtual returns (uint256);\r\n    function transfer(address to, uint256 value) public virtual returns(bool);\r\n    function gasOptimizedAirdrop(address[] calldata _addrs, uint256[] calldata _values) external virtual; \r\n}\r\n\r\n/**\r\n * Contract acts as an interface between the NFT Crypto Multisender contract and all ERC721 compliant\r\n * tokens. \r\n * */\r\nabstract contract ERC721Interface {\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public virtual;\r\n    function balanceOf(address who)  public virtual returns (uint256);\r\n    function isApprovedForAll(address _owner, address _operator) public view virtual returns(bool);\r\n    function setApprovalForAll(address _operator, bool approved) public virtual;\r\n    function gasOptimizedAirdrop(address _invoker, address[] calldata _addrs, uint256[] calldata _tokenIds) external virtual;\r\n}\r\n\r\n\r\n/**\r\n * Contract acts as an interface between the NFT Crypto Multisender contract and all ERC1155 compliant\r\n * tokens. \r\n * */\r\nabstract contract ERC1155Interface {\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _amount, bytes memory data) public virtual;\r\n    function balanceOf(address _who, uint256 _id)  public virtual returns (uint256);\r\n    function isApprovedForAll(address _owner, address _operator) public view virtual returns(bool);\r\n    function setApprovalForAll(address _operator, bool approved) public virtual;\r\n    function gasOptimizedAirdrop(address _invoker, address[] calldata _addrs, uint256[] calldata _tokenIds, uint256[] calldata _amounts) external virtual;\r\n}\r\n\r\n\r\n\r\ncontract CryptoMultisender is Ownable {\r\n \r\n    mapping (address => uint256) public tokenTrialDrops;\r\n    mapping (address => uint256) public userTrialDrops;\r\n\r\n    mapping (address => uint256) public premiumMembershipDiscount;\r\n    mapping (address => uint256) public membershipExpiryTime;\r\n\r\n    mapping (address => bool) public isGrantedPremiumMember;\r\n\r\n    mapping (address => bool) public isListedToken;\r\n    mapping (address => uint256) public tokenListingFeeDiscount;\r\n\r\n    mapping (address => bool) public isGrantedListedToken;\r\n\r\n    mapping (address => bool) public isAffiliate;\r\n    mapping (string => address) public affiliateCodeToAddr;\r\n    mapping (string => bool) public affiliateCodeExists;\r\n    mapping (address => string) public affiliateCodeOfAddr;\r\n    mapping (address => string) public isAffiliatedWith;\r\n    mapping (string => uint256) public commissionPercentage;\r\n\r\n    uint256 public oneDayMembershipFee;\r\n    uint256 public sevenDayMembershipFee;\r\n    uint256 public oneMonthMembershipFee;\r\n    uint256 public lifetimeMembershipFee;\r\n    uint256 public tokenListingFee;\r\n    uint256 public rate;\r\n    uint256 public dropUnitPrice;\r\n    address public deprecatedMultisenderAddress;\r\n\r\n    event TokenAirdrop(address indexed by, address indexed tokenAddress, uint256 totalTransfers);\r\n    event EthAirdrop(address indexed by, uint256 totalTransfers, uint256 ethValue);\r\n    event NftAirdrop(address indexed by, address indexed nftAddress, uint256 totalTransfers);\r\n    event RateChanged(uint256 from, uint256 to);\r\n    event RefundIssued(address indexed to, uint256 totalWei);\r\n    event ERC20TokensWithdrawn(address token, address sentTo, uint256 value);\r\n    event CommissionPaid(address indexed to, uint256 value);\r\n    event NewPremiumMembership(address indexed premiumMember);\r\n    event NewAffiliatePartnership(address indexed newAffiliate, string indexed affiliateCode);\r\n    event AffiliatePartnershipRevoked(address indexed affiliate, string indexed affiliateCode);\r\n    \r\n    constructor() {\r\n        rate = 3000;\r\n        dropUnitPrice = 333333333333333; \r\n        oneDayMembershipFee = 9e17;\r\n        sevenDayMembershipFee = 125e16;\r\n        oneMonthMembershipFee = 2e18;\r\n        lifetimeMembershipFee = 25e17;\r\n        tokenListingFee = 5e18;\r\n        deprecatedMultisenderAddress=address(0x8DcCba703e3CA40D3D50435A06637c577D36AAFb);\r\n    }\r\n\r\n    /**\r\n     * Allows the owner of this contract to change the fees for users to become premium members.\r\n     * \r\n     * @param _oneDayFee Fee for single day membership.\r\n     * @param _sevenDayFee Fee for one week membership.\r\n     * @param _oneMonthFee Fee for one month membership.\r\n     * @param _lifetimeFee Fee for lifetime membership.\r\n     * \r\n     * @return success True if the fee is changed successfully. False otherwise.\r\n     * */\r\n    function setMembershipFees(uint256 _oneDayFee, uint256 _sevenDayFee, uint256 _oneMonthFee, uint256 _lifetimeFee) public onlyOwner returns(bool success) {\r\n        require(_oneDayFee>0 && _oneDayFee<_sevenDayFee && _sevenDayFee<_oneMonthFee && _oneMonthFee<_lifetimeFee);\r\n        oneDayMembershipFee = _oneDayFee;\r\n        sevenDayMembershipFee = _sevenDayFee;\r\n        oneMonthMembershipFee = _oneMonthFee;\r\n        lifetimeMembershipFee = _lifetimeFee;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows for the conversion of an unsigned integer to a string value. \r\n     * \r\n     * @param _i The value of the unsigned integer\r\n     * \r\n     * @return _uintAsString The string value of the unsigned integer.\r\n     * */\r\n    function uint2str(uint _i) internal pure returns (string memory _uintAsString) {\r\n        if (_i == 0) {\r\n            return \"0\";\r\n        }\r\n        uint j = _i;\r\n        uint len;\r\n        while (j != 0) {\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len;\r\n        while (_i != 0) {\r\n            k = k-1;\r\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\r\n            bytes1 b1 = bytes1(temp);\r\n            bstr[k] = b1;\r\n            _i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    /**\r\n    * Used to give change to users who accidentally send too much ETH to payable functions. \r\n    *\r\n    * @param _price The service fee the user has to pay for function execution. \r\n    **/\r\n    function giveChange(uint256 _price) internal {\r\n        if(msg.value > _price) {\r\n            uint256 change = msg.value - _price;\r\n            payable(msg.sender).transfer(change);\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * Ensures that the correct affiliate code is used and also ensures that affiliate partners\r\n    * are not able to 'jack' commissions from existing users who they are not affiliated with. \r\n    *\r\n    * @param _afCode The affiliate code provided by the user.\r\n    *\r\n    * @return code The correct affiliate code or void.\r\n    **/\r\n    function processAffiliateCode(string memory _afCode) internal returns(string memory code) {\r\n        if(stringsAreEqual(isAffiliatedWith[msg.sender], \"void\") || !isAffiliate[affiliateCodeToAddr[_afCode]]) {\r\n            isAffiliatedWith[msg.sender] = \"void\";\r\n            return \"void\";\r\n        }\r\n        if(!stringsAreEqual(_afCode, \"\") && stringsAreEqual(isAffiliatedWith[msg.sender],\"\") \r\n                                                                && affiliateCodeExists[_afCode]) {\r\n            if(affiliateCodeToAddr[_afCode] == msg.sender) {\r\n                return \"void\";\r\n            }\r\n            isAffiliatedWith[msg.sender] = _afCode;\r\n        }\r\n        if(stringsAreEqual(_afCode,\"\") && !stringsAreEqual(isAffiliatedWith[msg.sender],\"\")) {\r\n            _afCode = isAffiliatedWith[msg.sender];\r\n        } \r\n        if(stringsAreEqual(_afCode,\"\") || !affiliateCodeExists[_afCode]) {\r\n            isAffiliatedWith[msg.sender] = \"void\";\r\n            _afCode = \"void\";\r\n        }\r\n        return _afCode;\r\n    }\r\n\r\n    /**\r\n     * Allows users to check if a user is a premium member or not. \r\n     * \r\n     * @param _addr The address of the user. \r\n     * \r\n     * @return isMember True if the user is a premium member, false otherwise.\r\n     * */\r\n    function checkIsPremiumMember(address _addr) public view returns(bool isMember) {\r\n        return membershipExpiryTime[_addr] >= block.timestamp || isGrantedPremiumMember[_addr];\r\n    }\r\n\r\n    /**\r\n    * Allows the owner of this contract to grant users with premium membership.\r\n    *\r\n    * @param _addr The address of the user who is being granted premium membership.\r\n    *\r\n    * @return success True if premium membership is granted successfully. False otherwise. \r\n    **/\r\n    function grantPremiumMembership(address _addr) public onlyOwner returns(bool success) {\r\n        require(checkIsPremiumMember(_addr) != true, \"Is already premiumMember member\");\r\n        isGrantedPremiumMember[_addr] = true;\r\n        emit NewPremiumMembership(_addr);\r\n        return true; \r\n    }\r\n\r\n    /**\r\n    * Allows the owner of this contract to revoke a granted membership.\r\n    *\r\n    * @param _addr The address of the user whos membership is being revoked.\r\n    *\r\n    * @return success True if membership is revoked successfully. False otherwise. \r\n    **/\r\n    function revokeGrantedPremiumMembership(address _addr) public onlyOwner returns(bool success) {\r\n        require(isGrantedPremiumMember[_addr], \"Not a granted membership\");\r\n        isGrantedPremiumMember[_addr] = false;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows the owner of the contract to grant a premium membership discount for a specified user.\r\n     * \r\n     * @param _addr The address of the user.\r\n     * @param _discount The discount being granted.\r\n     * \r\n     * @return success True if function executes successfully, false otherwise.\r\n     * */\r\n    function setPremiumMembershipDiscount(address _addr, uint256 _discount) public onlyOwner returns(bool success) {\r\n        premiumMembershipDiscount[_addr] = _discount;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows users to check VIP membership fees for a specific address. This is useful for validating if a discount\r\n     * has been granted for the specified user. \r\n     * \r\n     * @param _addr The address of the user.\r\n     * @param _fee The default fee. \r\n     * \r\n     * @return fee The membership fee for the specified user. \r\n     * \r\n     * */\r\n    function getPremiumMembershipFeeOfUser(address _addr, uint256 _fee) public view returns(uint256 fee) {\r\n        if(premiumMembershipDiscount[_addr] > 0) {\r\n            return _fee * premiumMembershipDiscount[_addr] / 100;\r\n        }\r\n        return _fee;\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Allows the owner of the contract to set the contract address of the old multisender SC.\r\n     * \r\n     * @param _addr The updated address.\r\n     * */\r\n    function setDeprecatedMultisenderAddress(address _addr) public onlyOwner {\r\n        deprecatedMultisenderAddress = _addr;\r\n    }\r\n\r\n\r\n    /**\r\n     * This function checks if a user address has a membership on the old SC.\r\n     * \r\n     * @param _who The address of the user.\r\n     * \r\n     * @return True if the user is a member on the old SC, false otherwise.\r\n     * */\r\n    function isMemberOfOldMultisender(address _who) public view returns(bool) {\r\n        DeprecatedMultisenderSC oldMultisender = DeprecatedMultisenderSC(deprecatedMultisenderAddress);\r\n        return oldMultisender.isPremiumMember(_who);\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows users to transfer their membership from the old SC to this SC. \r\n     * \r\n     * @return True if there is a membership to be transferred, false otherwise. \r\n     * */\r\n    function transferMembership() public returns(bool) {\r\n        require(isMemberOfOldMultisender(msg.sender), \"No membership to transfer\");\r\n        membershipExpiryTime[msg.sender] = block.timestamp + (36500 * 1 days);\r\n        return true;\r\n    }\r\n    \r\n\r\n    /**\r\n     * This function is invoked internally the functions for purchasing memberships.\r\n     * \r\n     * @param _days The number of days that the membership will be valid for. \r\n     * @param _fee The fee that is to be paid. \r\n     * @param _afCode If a user has been refferred by an affiliate partner, they can provide \r\n     * an affiliate code so the partner gets commission.\r\n     * \r\n     * @return success True if function executes successfully, false otherwise.\r\n     * */\r\n    function assignMembership(uint256 _days, uint256 _fee, string memory _afCode) internal returns(bool success) {\r\n        require(checkIsPremiumMember(msg.sender) != true, \"Is already premiumMember member\");\r\n        uint256 fee = getPremiumMembershipFeeOfUser(msg.sender, _fee);\r\n        require(\r\n            msg.value >= fee,\r\n            string(abi.encodePacked(\r\n                \"premiumMember fee is: \", uint2str(fee), \". Not enough funds sent. \", uint2str(msg.value)\r\n            ))\r\n        );\r\n        membershipExpiryTime[msg.sender] = block.timestamp + (_days * 1 days);\r\n        _afCode = processAffiliateCode(_afCode);\r\n        giveChange(fee);\r\n        distributeCommission(fee, _afCode);\r\n        emit NewPremiumMembership(msg.sender);\r\n        return true; \r\n    }\r\n\r\n    /**\r\n    * Allows users to become lifetime members.\r\n    *\r\n    * @param _afCode If a user has been refferred by an affiliate partner, they can provide \r\n    * an affiliate code so the partner gets commission.\r\n    *\r\n    * @return success True if user successfully becomes premium member. False otherwise. \r\n    **/\r\n    function becomeLifetimeMember(string memory _afCode) public payable returns(bool success) {\r\n        assignMembership(36500, lifetimeMembershipFee, _afCode);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * Allows users to become members for 1 day.\r\n    *\r\n    * @param _afCode If a user has been refferred by an affiliate partner, they can provide \r\n    * an affiliate code so the partner gets commission.\r\n    *\r\n    * @return success True if user successfully becomes premium member. False otherwise. \r\n    **/\r\n    function becomeOneDayMember(string memory _afCode) public payable returns(bool success) {\r\n        assignMembership(1, oneDayMembershipFee, _afCode);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * Allows users to become members for 7 days.\r\n    *\r\n    * @param _afCode If a user has been refferred by an affiliate partner, they can provide \r\n    * an affiliate code so the partner gets commission.\r\n    *\r\n    * @return success True if user successfully becomes premium member. False otherwise. \r\n    **/\r\n    function becomeOneWeekMember(string memory _afCode) public payable returns(bool success) {\r\n        assignMembership(7, sevenDayMembershipFee, _afCode);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * Allows users to become members for 1 month\r\n    *\r\n    * @param _afCode If a user has been refferred by an affiliate partner, they can provide \r\n    * an affiliate code so the partner gets commission.\r\n    *\r\n    * @return success True if user successfully becomes premium member. False otherwise. \r\n    **/\r\n    function becomeOneMonthMember(string memory _afCode) public payable returns(bool success) {\r\n        assignMembership(31, oneMonthMembershipFee, _afCode);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows users to check whether or not a token is listed.\r\n     * \r\n     * @param _tokenAddr The address of the token to query.\r\n     * \r\n     * @return isListed True if the token is listed, false otherwise. \r\n     * */\r\n    function checkIsListedToken(address _tokenAddr) public view returns(bool isListed) {\r\n        return isListedToken[_tokenAddr] || isGrantedListedToken[_tokenAddr];\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows the owner of the contract to set a listing discount for a specified token.\r\n     * \r\n     * @param _tokenAddr The address of the token that will receive the discount. \r\n     * @param _discount The discount that will be applied. \r\n     * \r\n     * @return success True if function executes successfully, false otherwise.\r\n     * */\r\n    function setTokenListingFeeDiscount(address _tokenAddr, uint256 _discount) public onlyOwner returns(bool success) {\r\n        tokenListingFeeDiscount[_tokenAddr] = _discount;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows users to query the listing fee for a token. This is useful to verify that a discount has been set. \r\n     * \r\n     * @param _tokenAddr The address of the token. \r\n     * \r\n     * @return fee The listing fee for the token. \r\n     * */\r\n    function getListingFeeForToken(address _tokenAddr) public view returns(uint256 fee) {\r\n        if(tokenListingFeeDiscount[_tokenAddr] > 0) {\r\n            return tokenListingFee * tokenListingFeeDiscount[_tokenAddr] / 100;\r\n        }\r\n        return tokenListingFee;\r\n    }\r\n\r\n    /**\r\n     * Allows users to list a token of their choosing. \r\n     * \r\n     * @param _tokenAddr The address of the token that will be listed. \r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return success True if function executes successfully, false otherwise.\r\n     * */\r\n    function purchaseTokenListing(address _tokenAddr, string memory _afCode) public payable returns(bool success) {\r\n        require(!checkIsListedToken(_tokenAddr), \"Token is already listed\");\r\n        _afCode = processAffiliateCode(_afCode);\r\n        uint256 fee = getListingFeeForToken(_tokenAddr);\r\n        require(msg.value >= fee, \"Not enough funds sent for listing\");\r\n        isListedToken[_tokenAddr] = true;\r\n        giveChange(fee);\r\n        distributeCommission(fee, _afCode);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows the owner of the contract to revoke a granted token listing. \r\n     * \r\n     * @param _tokenAddr The address of the token that is being delisted. \r\n     * \r\n     * @return success True if function executes successfully, false otherwise.\r\n     * */\r\n    function revokeGrantedTokenListing(address _tokenAddr) public onlyOwner returns(bool success) {\r\n        require(checkIsListedToken(_tokenAddr), \"Is not listed token\");\r\n        isGrantedListedToken[_tokenAddr] = false;\r\n        return  true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows the owner of the contract to grant a token a free listing. \r\n     * \r\n     * @param _tokenAddr The address of the token being listed.\r\n     * \r\n     * @return success True if function executes successfully, false otherwise.\r\n     * */\r\n    function grantTokenListing(address _tokenAddr) public onlyOwner returns(bool success){\r\n        require(!checkIsListedToken(_tokenAddr), \"Token is already listed\");\r\n        isGrantedListedToken[_tokenAddr] = true;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows the owner of the contract to modify the token listing fee. \r\n     * \r\n     * @param _newFee The new fee for token listings. \r\n     * \r\n     * @return success True if function executes successfully, false otherwise.\r\n     * */\r\n    function setTokenListingFee(uint256 _newFee) public onlyOwner returns(bool success){\r\n        tokenListingFee = _newFee;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n    * Allows the owner of this contract to add an affiliate partner.\r\n    *\r\n    * @param _addr The address of the new affiliate partner.\r\n    * @param _code The affiliate code.\r\n    * \r\n    * @return success True if the affiliate has been added successfully. False otherwise. \r\n    **/\r\n    function addAffiliate(address _addr, string memory _code, uint256 _percentage) public onlyOwner returns(bool success) {\r\n        require(!isAffiliate[_addr], \"Address is already an affiliate.\");\r\n        require(_addr != address(0), \"0x00 address not allowed\");\r\n        require(!affiliateCodeExists[_code], \"Affiliate code already exists!\");\r\n        require(_percentage <= 100 && _percentage > 0, \"Percentage must be > 0 && <= 100\");\r\n        affiliateCodeExists[_code] = true;\r\n        isAffiliate[_addr] = true;\r\n        affiliateCodeToAddr[_code] = _addr;\r\n        affiliateCodeOfAddr[_addr] = _code;\r\n        commissionPercentage[_code] = _percentage;\r\n        emit NewAffiliatePartnership(_addr,_code);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows the owner of the contract to set a customised commission percentage for a given affiliate partner.\r\n     * \r\n     * @param _addressOfAffiliate The wallet address of the affiliate partner.\r\n     * @param _percentage The commission percentage the affiliate will receive.\r\n     * \r\n     * @return success True if function executes successfully, false otherwise.\r\n     * */\r\n    function changeAffiliatePercentage(address _addressOfAffiliate, uint256 _percentage) public onlyOwner returns(bool success) { \r\n        require(isAffiliate[_addressOfAffiliate]);\r\n        string storage affCode = affiliateCodeOfAddr[_addressOfAffiliate];\r\n        commissionPercentage[affCode] = _percentage;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Allows the owner of this contract to remove an affiliate partner. \r\n    *\r\n    * @param _addr The address of the affiliate partner.\r\n    *\r\n    * @return success True if affiliate partner is removed successfully. False otherwise. \r\n    **/\r\n    function removeAffiliate(address _addr) public onlyOwner returns(bool success) {\r\n        require(isAffiliate[_addr]);\r\n        isAffiliate[_addr] = false;\r\n        affiliateCodeToAddr[affiliateCodeOfAddr[_addr]] = address(0);\r\n        emit AffiliatePartnershipRevoked(_addr, affiliateCodeOfAddr[_addr]);\r\n        affiliateCodeOfAddr[_addr] = \"No longer an affiliate partner\";\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Checks whether or not an ERC20 token has used its free trial of 100 drops. This is a constant \r\n     * function which does not alter the state of the contract and therefore does not require any gas \r\n     * or a signature to be executed. \r\n     * \r\n     * @param _addressOfToken The address of the token being queried.\r\n     * \r\n     * @return hasFreeTrial true if the token being queried has not used its 100 first free trial drops, false\r\n     * otherwise.\r\n     * */\r\n    function tokenHasFreeTrial(address _addressOfToken) public view returns(bool hasFreeTrial) {\r\n        return tokenTrialDrops[_addressOfToken] < 100;\r\n    }\r\n\r\n\r\n    /**\r\n     * Checks whether or not a user has a free trial. \r\n     * \r\n     * @param _addressOfUser The address of the user being queried.\r\n     * \r\n     * @return hasFreeTrial true if the user address being queried has not used the first 100 free trial drops, false\r\n     * otherwise.\r\n     * */\r\n    function userHasFreeTrial(address _addressOfUser) public view returns(bool hasFreeTrial) {\r\n        return userTrialDrops[_addressOfUser] < 100;\r\n    }\r\n    \r\n    /**\r\n     * Checks how many remaining free trial drops a token has.\r\n     * \r\n     * @param _addressOfToken the address of the token being queried.\r\n     * \r\n     * @return remainingTrialDrops the total remaining free trial drops of a token.\r\n     * */\r\n    function getRemainingTokenTrialDrops(address _addressOfToken) public view returns(uint256 remainingTrialDrops) {\r\n        if(tokenHasFreeTrial(_addressOfToken)) {\r\n            uint256 maxTrialDrops =  100;\r\n            return maxTrialDrops - tokenTrialDrops[_addressOfToken];\r\n        } \r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Checks how many remaining free trial drops a user has.\r\n     * \r\n     * @param _addressOfUser the address of the user being queried.\r\n     * \r\n     * @return remainingTrialDrops the total remaining free trial drops of a user.\r\n     * */\r\n    function getRemainingUserTrialDrops(address _addressOfUser) public view returns(uint256 remainingTrialDrops) {\r\n        if(userHasFreeTrial(_addressOfUser)) {\r\n            uint256 maxTrialDrops =  100;\r\n            return maxTrialDrops - userTrialDrops[_addressOfUser];\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    /**\r\n     * Allows for the price of drops to be changed by the owner of the contract. Any attempt made by \r\n     * any other account to invoke the function will result in a loss of gas and the price will remain \r\n     * untampered.\r\n     * \r\n     * @return success true if function executes successfully, false otherwise.\r\n     * */\r\n    function setRate(uint256 _newRate) public onlyOwner returns(bool success) {\r\n        require(\r\n            _newRate != rate \r\n            && _newRate > 0\r\n        );\r\n        emit RateChanged(rate, _newRate);\r\n        rate = _newRate;\r\n        uint256 eth = 1 ether;\r\n        dropUnitPrice = eth / rate;\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Allows for the allowance of a token from its owner to this contract to be queried. \r\n     * \r\n     * As part of the ERC20 standard all tokens which fall under this category have an allowance \r\n     * function which enables owners of tokens to allow (or give permission) to another address \r\n     * to spend tokens on behalf of the owner. This contract uses this as part of its protocol.\r\n     * Users must first give permission to the contract to transfer tokens on their behalf, however,\r\n     * this does not mean that the tokens will ever be transferrable without the permission of the \r\n     * owner. This is a security feature which was implemented on this contract. It is not possible\r\n     * for the owner of this contract or anyone else to transfer the tokens which belong to others. \r\n     * \r\n     * @param _addr The address of the token's owner.\r\n     * @param _addressOfToken The contract address of the ERC20 token.\r\n     * \r\n     * @return allowance The ERC20 token allowance from token owner to this contract. \r\n     * */\r\n    function getTokenAllowance(address _addr, address _addressOfToken) public view returns(uint256 allowance) {\r\n        ERC20Interface token = ERC20Interface(_addressOfToken);\r\n        return token.allowance(_addr, address(this));\r\n    }\r\n    \r\n    fallback() external payable {\r\n        revert();\r\n    }\r\n\r\n    receive() external payable {\r\n        revert();\r\n    }\r\n    \r\n    /**\r\n    * Checks if two strings are the same.\r\n    *\r\n    * @param _a String 1\r\n    * @param _b String 2\r\n    *\r\n    * @return areEqual True if both strings are the same. False otherwise. \r\n    **/\r\n    function stringsAreEqual(string memory _a, string memory _b) internal pure returns(bool areEqual) {\r\n        bytes32 hashA = keccak256(abi.encodePacked(_a));\r\n        bytes32 hashB = keccak256(abi.encodePacked(_b));\r\n        return hashA == hashB;\r\n    }\r\n    \r\n    /**\r\n     * Allows for the distribution of Ether to be transferred to multiple recipients at \r\n     * a time. \r\n     * \r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _values The corresponding amounts that the recipients will receive \r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return success true if function executes successfully, false otherwise.\r\n     * */\r\n    function airdropNativeCurrency(address[] memory _recipients, uint256[] memory _values, uint256 _totalToSend, string memory _afCode) public payable returns(bool success) {\r\n        require(_recipients.length == _values.length, \"Total number of recipients and values are not equal\");\r\n        uint256 totalEthValue = _totalToSend;\r\n        uint256 price = _recipients.length * dropUnitPrice;\r\n        uint256 totalCost = totalEthValue + price;\r\n        bool userHasTrial = userHasFreeTrial(msg.sender);\r\n        bool isVIP = checkIsPremiumMember(msg.sender) == true;\r\n        require(\r\n            msg.value >= totalCost || isVIP || userHasTrial, \r\n            \"Not enough funds sent with transaction!\"\r\n        );\r\n        _afCode = processAffiliateCode(_afCode);\r\n        if(!isVIP && !userHasTrial) {\r\n            distributeCommission(price, _afCode);\r\n        }\r\n        if((isVIP || userHasTrial) && msg.value > _totalToSend) {\r\n            payable(msg.sender).transfer((msg.value) - _totalToSend);\r\n        } else {\r\n            giveChange(totalCost);\r\n        }\r\n        for(uint i = 0; i < _recipients.length; i++) {\r\n            payable(_recipients[i]).transfer(_values[i]);\r\n        }\r\n        if(userHasTrial) {\r\n            userTrialDrops[msg.sender] = userTrialDrops[msg.sender] + _recipients.length;\r\n        }\r\n        emit EthAirdrop(msg.sender, _recipients.length, totalEthValue);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows for the distribution of an ERC20 token to be transferred to multiple recipients at \r\n     * a time. This function facilitates batch transfers of differing values (i.e., all recipients\r\n     * can receive different amounts of tokens).\r\n     * \r\n     * @param _addressOfToken The contract address of an ERC20 token.\r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _values The corresponding values of tokens which each address will receive.\r\n     * @param _optimized Should only be enabled for tokens with gas optimized distribution functions. \r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return success true if function executes successfully, false otherwise.\r\n     * */    \r\n    function erc20Airdrop(address _addressOfToken,  address[] memory _recipients, uint256[] memory _values, uint256 _totalToSend, bool _isDeflationary, bool _optimized, string memory _afCode) public payable returns(bool success) {\r\n        string memory afCode = processAffiliateCode(_afCode);\r\n        ERC20Interface token = ERC20Interface(_addressOfToken);\r\n        require(_recipients.length == _values.length, \"Total number of recipients and values are not equal\");\r\n        uint256 price = _recipients.length * dropUnitPrice;\r\n        bool isPremiumOrListed = checkIsPremiumMember(msg.sender) || checkIsListedToken(_addressOfToken);\r\n        bool eligibleForFreeTrial = tokenHasFreeTrial(_addressOfToken) && userHasFreeTrial(msg.sender);\r\n        require(\r\n            msg.value >= price || tokenHasFreeTrial(_addressOfToken) || userHasFreeTrial(msg.sender) || isPremiumOrListed,\r\n            \"Not enough funds sent with transaction!\"\r\n        );\r\n        if((eligibleForFreeTrial || isPremiumOrListed) && msg.value > 0) {\r\n            payable(msg.sender).transfer(msg.value);\r\n        } else {\r\n            giveChange(price);\r\n        }\r\n\r\n        if(_optimized) {\r\n            token.transferFrom(msg.sender, address(this), _totalToSend);\r\n            token.gasOptimizedAirdrop(_recipients,_values);\r\n        } else {\r\n            if(!_isDeflationary) {\r\n                token.transferFrom(msg.sender, address(this), _totalToSend);\r\n                for(uint i = 0; i < _recipients.length; i++) {\r\n                    token.transfer(_recipients[i], _values[i]);\r\n                }\r\n                if(token.balanceOf(address(this)) > 0) {\r\n                    token.transfer(msg.sender,token.balanceOf(address(this)));\r\n                }\r\n            } else {\r\n                for(uint i=0; i < _recipients.length; i++) {\r\n                    token.transferFrom(msg.sender, _recipients[i], _values[i]);\r\n                }\r\n            }\r\n        }\r\n\r\n        if(tokenHasFreeTrial(_addressOfToken)) {\r\n            tokenTrialDrops[_addressOfToken] = tokenTrialDrops[_addressOfToken] + _recipients.length;\r\n        }\r\n        if(userHasFreeTrial(msg.sender)) {\r\n            userTrialDrops[msg.sender] = userTrialDrops[msg.sender] + _recipients.length;\r\n        }\r\n        if(!eligibleForFreeTrial && !isPremiumOrListed) {\r\n            distributeCommission(_recipients.length * dropUnitPrice, afCode);\r\n        }\r\n        emit TokenAirdrop(msg.sender, _addressOfToken, _recipients.length);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows for the distribution of ERC721 tokens to be transferred to multiple recipients at \r\n     * a time. \r\n     * \r\n     * @param _addressOfNFT The contract address of an ERC721 token collection.\r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _tokenIds The corresponding IDs of the NFT collection which each address will receive.\r\n     * @param _optimized Should only be enabled for ERC721 token collections with gas optimized distribution functions. \r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return success true if function executes successfully, false otherwise.\r\n     * */ \r\n    function erc721Airdrop(address _addressOfNFT, address[] memory _recipients, uint256[] memory _tokenIds, bool _optimized, string memory _afCode) public payable returns(bool success) {\r\n        require(_recipients.length == _tokenIds.length, \"Total number of recipients and total number of NFT IDs are not the same\");\r\n        string memory afCode = processAffiliateCode(_afCode);\r\n        ERC721Interface erc721 = ERC721Interface(_addressOfNFT);\r\n        uint256 price = _recipients.length * dropUnitPrice;\r\n        bool isPremiumOrListed = checkIsPremiumMember(msg.sender) || checkIsListedToken(_addressOfNFT);\r\n        bool eligibleForFreeTrial = tokenHasFreeTrial(_addressOfNFT) && userHasFreeTrial(msg.sender);\r\n        require(\r\n            msg.value >= price || eligibleForFreeTrial || isPremiumOrListed,\r\n            \"Not enough funds sent with transaction!\"\r\n        );\r\n        if((eligibleForFreeTrial || isPremiumOrListed) && msg.value > 0) {\r\n            payable(msg.sender).transfer(msg.value);\r\n        } else {\r\n            giveChange(price);\r\n        }\r\n        if(_optimized){\r\n            erc721.gasOptimizedAirdrop(msg.sender,_recipients,_tokenIds);\r\n        } else {\r\n            for(uint i = 0; i < _recipients.length; i++) {\r\n                erc721.transferFrom(msg.sender, _recipients[i], _tokenIds[i]);\r\n            }\r\n        }\r\n        if(tokenHasFreeTrial(_addressOfNFT)) {\r\n            tokenTrialDrops[_addressOfNFT] = tokenTrialDrops[_addressOfNFT] + _recipients.length;\r\n        }\r\n        if(userHasFreeTrial(msg.sender)) {\r\n            userTrialDrops[msg.sender] = userTrialDrops[msg.sender] + _recipients.length;\r\n        }\r\n        if(!eligibleForFreeTrial && !isPremiumOrListed) {\r\n            distributeCommission(_recipients.length * dropUnitPrice, afCode);\r\n        }\r\n        emit NftAirdrop(msg.sender, _addressOfNFT, _recipients.length);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows for the distribution of ERC1155 tokens to be transferred to multiple recipients at \r\n     * a time. \r\n     * \r\n     * @param _addressOfNFT The contract address of an ERC1155 token contract.\r\n     * @param _recipients The list of addresses which will receive tokens. \r\n     * @param _ids The corresponding IDs of the token collection which each address will receive.\r\n     * @param _amounts The amount of tokens to send from each token type.\r\n     * @param _optimized Should only be enabled for ERC721 token collections with gas optimized distribution functions. \r\n     * @param _afCode If the user is affiliated with a partner, they will provide this code so that \r\n     * the parter is paid commission.\r\n     * \r\n     * @return success true if function executes successfully, false otherwise.\r\n     * */ \r\n    function erc1155Airdrop(address _addressOfNFT, address[] memory _recipients, uint256[] memory _ids, uint256[] memory _amounts, bool _optimized, string memory _afCode) public payable returns(bool success) {\r\n        require(_recipients.length == _ids.length, \"Total number of recipients and total number of NFT IDs are not the same\");\r\n        require(_recipients.length == _amounts.length, \"Total number of recipients and total number of amounts are not the same\");\r\n        string memory afCode = processAffiliateCode(_afCode);\r\n        ERC1155Interface erc1155 = ERC1155Interface(_addressOfNFT);\r\n        uint256 price = _recipients.length * dropUnitPrice;\r\n        bool isPremiumOrListed = checkIsPremiumMember(msg.sender) || checkIsListedToken(_addressOfNFT);\r\n        bool eligibleForFreeTrial = tokenHasFreeTrial(_addressOfNFT) && userHasFreeTrial(msg.sender);\r\n        require(\r\n            msg.value >= price || eligibleForFreeTrial || isPremiumOrListed,\r\n            \"Not enough funds sent with transaction!\"\r\n        );\r\n        if((eligibleForFreeTrial || isPremiumOrListed) && msg.value > 0) {\r\n            payable(msg.sender).transfer(msg.value);\r\n        } else {\r\n            giveChange(price);\r\n        }\r\n        if(_optimized){\r\n            erc1155.gasOptimizedAirdrop(msg.sender,_recipients,_ids,_amounts);\r\n        } else {\r\n            for(uint i = 0; i < _recipients.length; i++) {\r\n                erc1155.safeTransferFrom(msg.sender, _recipients[i], _ids[i], _amounts[i], \"\");\r\n            }\r\n        }\r\n        if(tokenHasFreeTrial(_addressOfNFT)) {\r\n            tokenTrialDrops[_addressOfNFT] = tokenTrialDrops[_addressOfNFT] + _recipients.length;\r\n        }\r\n        if(userHasFreeTrial(msg.sender)) {\r\n            userTrialDrops[msg.sender] = userTrialDrops[msg.sender] + _recipients.length;\r\n        }\r\n        if(!eligibleForFreeTrial && !isPremiumOrListed) {\r\n            distributeCommission(_recipients.length * dropUnitPrice, afCode);\r\n        }\r\n        emit NftAirdrop(msg.sender, _addressOfNFT, _recipients.length);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * Send the owner and affiliates commissions.\r\n    **/\r\n    function distributeCommission(uint256 _profits, string memory _afCode) internal {\r\n        if(!stringsAreEqual(_afCode,\"void\") && isAffiliate[affiliateCodeToAddr[_afCode]]) {\r\n            uint256 commission = _profits * commissionPercentage[_afCode] / 100;\r\n            payable(owner).transfer(_profits - commission);\r\n            payable(affiliateCodeToAddr[_afCode]).transfer(commission);\r\n            emit CommissionPaid(affiliateCodeToAddr[_afCode], commission);\r\n        } else {\r\n            payable(owner).transfer(_profits);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Allows the owner of the contract to withdraw any funds that may reside on the contract address.\r\n     * */\r\n    function withdrawFunds() public onlyOwner returns(bool success) {\r\n        payable(owner).transfer(address(this).balance);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Allows for any ERC20 tokens which have been mistakenly  sent to this contract to be returned \r\n     * to the original sender by the owner of the contract. Any attempt made by any other account \r\n     * to invoke the function will result in a loss of gas and no tokens will be transferred out.\r\n     * \r\n     * @param _addressOfToken The contract address of an ERC20 token.\r\n     * @param _recipient The address which will receive tokens. \r\n     * @param _value The amount of tokens to refund.\r\n     * \r\n     * @return success true if function executes successfully, false otherwise.\r\n     * */  \r\n    function withdrawERC20Tokens(address _addressOfToken,  address _recipient, uint256 _value) public onlyOwner returns(bool success){\r\n        ERC20Interface token = ERC20Interface(_addressOfToken);\r\n        token.transfer(_recipient, _value);\r\n        emit ERC20TokensWithdrawn(_addressOfToken, _recipient, _value);\r\n        return true;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"affiliate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"affiliateCode\",\"type\":\"string\"}],\"name\":\"AffiliatePartnershipRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"CommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sentTo\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ERC20TokensWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTransfers\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ethValue\",\"type\":\"uint256\"}],\"name\":\"EthAirdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newAffiliate\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"affiliateCode\",\"type\":\"string\"}],\"name\":\"NewAffiliatePartnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"premiumMember\",\"type\":\"address\"}],\"name\":\"NewPremiumMembership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTransfers\",\"type\":\"uint256\"}],\"name\":\"NftAirdrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"from\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"RateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalWei\",\"type\":\"uint256\"}],\"name\":\"RefundIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalTransfers\",\"type\":\"uint256\"}],\"name\":\"TokenAirdrop\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_code\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"addAffiliate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"affiliateCodeExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"affiliateCodeOfAddr\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"affiliateCodeToAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalToSend\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"airdropNativeCurrency\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"becomeLifetimeMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"becomeOneDayMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"becomeOneMonthMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"becomeOneWeekMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfAffiliate\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"changeAffiliatePercentage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"checkIsListedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkIsPremiumMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isMember\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"commissionPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deprecatedMultisenderAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dropUnitPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfNFT\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_optimized\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"erc1155Airdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_values\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalToSend\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isDeflationary\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"_optimized\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"erc20Airdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfNFT\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_optimized\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"erc721Airdrop\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"getListingFeeForToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"getPremiumMembershipFeeOfUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"getRemainingTokenTrialDrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remainingTrialDrops\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfUser\",\"type\":\"address\"}],\"name\":\"getRemainingUserTrialDrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remainingTrialDrops\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"getTokenAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"allowance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"grantPremiumMembership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"grantTokenListing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAffiliate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isAffiliatedWith\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isGrantedListedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isGrantedPremiumMember\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isListedToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"isMemberOfOldMultisender\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lifetimeMembershipFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"membershipExpiryTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneDayMembershipFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oneMonthMembershipFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"premiumMembershipDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_afCode\",\"type\":\"string\"}],\"name\":\"purchaseTokenListing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"removeAffiliate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"revokeGrantedPremiumMembership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"revokeGrantedTokenListing\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setDeprecatedMultisenderAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_oneDayFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_sevenDayFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_oneMonthFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lifetimeFee\",\"type\":\"uint256\"}],\"name\":\"setMembershipFees\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_discount\",\"type\":\"uint256\"}],\"name\":\"setPremiumMembershipDiscount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setTokenListingFee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_discount\",\"type\":\"uint256\"}],\"name\":\"setTokenListingFeeDiscount\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sevenDayMembershipFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"}],\"name\":\"tokenHasFreeTrial\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasFreeTrial\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenListingFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenListingFeeDiscount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenTrialDrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferMembership\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfUser\",\"type\":\"address\"}],\"name\":\"userHasFreeTrial\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasFreeTrial\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTrialDrops\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addressOfToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20Tokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CryptoMultisender", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://60411a68509cf85fa8948f9f7b1a66adc6c56160a38c8d3ac5a7c95cade1a481"}