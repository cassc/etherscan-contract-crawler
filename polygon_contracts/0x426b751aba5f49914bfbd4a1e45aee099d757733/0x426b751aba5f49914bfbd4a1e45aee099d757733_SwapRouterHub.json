{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@gridexprotocol/core/contracts/interfaces/callback/IGridSwapCallback.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Callback for IGrid#swap\\n/// @notice Any contract that calls IGrid#swap must implement this interface\\ninterface IGridSwapCallback {\\n    /// @notice Called to `msg.sender` after executing a swap via IGrid#swap\\n    /// @dev In this implementation, you are required to pay the grid tokens owed for the swap.\\n    /// The caller of the method must be a grid deployed by the canonical GridFactory.\\n    /// If there is no token swap, both amount0Delta and amount1Delta are 0\\n    /// @param amount0Delta The grid will send or receive the amount of token0 upon completion of the swap.\\n    /// In the receiving case, the callback must send this amount of token0 to the grid\\n    /// @param amount1Delta The grid will send or receive the quantity of token1 upon completion of the swap.\\n    /// In the receiving case, the callback must send this amount of token1 to the grid\\n    /// @param data Any data passed through by the caller via the IGrid#swap call\\n    function gridexSwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IGrid.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IGridStructs.sol\\\";\\nimport \\\"./IGridParameters.sol\\\";\\n\\n/// @title The interface for Gridex grid\\ninterface IGrid {\\n    ///==================================== Grid States  ====================================\\n\\n    /// @notice The first token in the grid, after sorting by address\\n    function token0() external view returns (address);\\n\\n    /// @notice The second token in the grid, after sorting by address\\n    function token1() external view returns (address);\\n\\n    /// @notice The step size in initialized boundaries for a grid created with a given fee\\n    function resolution() external view returns (int24);\\n\\n    /// @notice The fee paid to the grid denominated in hundredths of a bip, i.e. 1e-6\\n    function takerFee() external view returns (int24);\\n\\n    /// @notice The 0th slot of the grid holds a lot of values that can be gas-efficiently accessed\\n    /// externally as a single method\\n    /// @return priceX96 The current price of the grid, as a Q64.96\\n    /// @return boundary The current boundary of the grid\\n    /// @return blockTimestamp The time the oracle was last updated\\n    /// @return unlocked Whether the grid is unlocked or not\\n    function slot0() external view returns (uint160 priceX96, int24 boundary, uint32 blockTimestamp, bool unlocked);\\n\\n    /// @notice Returns the boundary information of token0\\n    /// @param boundary The boundary of the grid\\n    /// @return bundle0Id The unique identifier of bundle0\\n    /// @return bundle1Id The unique identifier of bundle1\\n    /// @return makerAmountRemaining The remaining amount of token0 that can be swapped out,\\n    /// which is the sum of bundle0 and bundle1\\n    function boundaries0(\\n        int24 boundary\\n    ) external view returns (uint64 bundle0Id, uint64 bundle1Id, uint128 makerAmountRemaining);\\n\\n    /// @notice Returns the boundary information of token1\\n    /// @param boundary The boundary of the grid\\n    /// @return bundle0Id The unique identifier of bundle0\\n    /// @return bundle1Id The unique identifier of bundle1\\n    /// @return makerAmountRemaining The remaining amount of token1 that can be swapped out,\\n    /// which is the sum of bundle0 and bundle1\\n    function boundaries1(\\n        int24 boundary\\n    ) external view returns (uint64 bundle0Id, uint64 bundle1Id, uint128 makerAmountRemaining);\\n\\n    /// @notice Returns 256 packed boundary initialized boolean values for token0\\n    function boundaryBitmaps0(int16 wordPos) external view returns (uint256 word);\\n\\n    /// @notice Returns 256 packed boundary initialized boolean values for token1\\n    function boundaryBitmaps1(int16 wordPos) external view returns (uint256 word);\\n\\n    /// @notice Returns the amount owed for token0 and token1\\n    /// @param owner The address of owner\\n    /// @return token0 The amount of token0 owed\\n    /// @return token1 The amount of token1 owed\\n    function tokensOweds(address owner) external view returns (uint128 token0, uint128 token1);\\n\\n    /// @notice Returns the information of a given bundle\\n    /// @param bundleId The unique identifier of the bundle\\n    /// @return boundaryLower The lower boundary of the bundle\\n    /// @return zero When zero is true, it represents token0, otherwise it represents token1\\n    /// @return makerAmountTotal The total amount of token0 or token1 that the maker added\\n    /// @return makerAmountRemaining The remaining amount of token0 or token1 that can be swapped out from the makers\\n    /// @return takerAmountRemaining The remaining amount of token0 or token1 that have been swapped in from the takers\\n    /// @return takerFeeAmountRemaining The remaining amount of fees that takers have paid in\\n    function bundles(\\n        uint64 bundleId\\n    )\\n        external\\n        view\\n        returns (\\n            int24 boundaryLower,\\n            bool zero,\\n            uint128 makerAmountTotal,\\n            uint128 makerAmountRemaining,\\n            uint128 takerAmountRemaining,\\n            uint128 takerFeeAmountRemaining\\n        );\\n\\n    /// @notice Returns the information of a given order\\n    /// @param orderId The unique identifier of the order\\n    /// @return bundleId The unique identifier of the bundle -- represents which bundle this order belongs to\\n    /// @return owner The address of the owner of the order\\n    /// @return amount The amount of token0 or token1 to add\\n    function orders(uint256 orderId) external view returns (uint64 bundleId, address owner, uint128 amount);\\n\\n    ///==================================== Grid Actions ====================================\\n\\n    /// @notice Initializes the grid with the given parameters\\n    /// @dev The caller of this method receives a callback in the form of\\n    /// IGridPlaceMakerOrderCallback#gridexPlaceMakerOrderCallback.\\n    /// When initializing the grid, token0 and token1's liquidity must be added simultaneously.\\n    /// @param parameters The parameters used to initialize the grid\\n    /// @param data Any data to be passed through to the callback\\n    /// @return orderIds0 The unique identifiers of the orders for token0\\n    /// @return orderIds1 The unique identifiers of the orders for token1\\n    function initialize(\\n        IGridParameters.InitializeParameters memory parameters,\\n        bytes calldata data\\n    ) external returns (uint256[] memory orderIds0, uint256[] memory orderIds1);\\n\\n    /// @notice Swaps token0 for token1, or vice versa\\n    /// @dev The caller of this method receives a callback in the form of IGridSwapCallback#gridexSwapCallback\\n    /// @param recipient The address to receive the output of the swap\\n    /// @param zeroForOne The swap direction, true for token0 to token1 and false otherwise\\n    /// @param amountSpecified The amount of the swap, configured as an exactInput (positive)\\n    /// or an exactOutput (negative)\\n    /// @param priceLimitX96 Swap price limit: if zeroForOne, the price will not be less than this value after swap,\\n    /// if oneForZero, it will not be greater than this value after swap, as a Q64.96\\n    /// @param data Any data to be passed through to the callback\\n    /// @return amount0 The balance change of the grid's token0. When negative, it will reduce the balance\\n    /// by the exact amount. When positive, it will increase by at least this amount\\n    /// @return amount1 The balance change of the grid's token1. When negative, it will reduce the balance\\n    /// by the exact amount. When positive, it will increase by at least this amount.\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 priceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    /// @notice Places a maker order on the grid\\n    /// @dev The caller of this method receives a callback in the form of\\n    /// IGridPlaceMakerOrderCallback#gridexPlaceMakerOrderCallback\\n    /// @param parameters The parameters used to place the maker order\\n    /// @param data Any data to be passed through to the callback\\n    /// @return orderId The unique identifier of the order\\n    function placeMakerOrder(\\n        IGridParameters.PlaceOrderParameters memory parameters,\\n        bytes calldata data\\n    ) external returns (uint256 orderId);\\n\\n    /// @notice Places maker orders on the grid\\n    /// @dev The caller of this method receives a callback in the form of\\n    /// IGridPlaceMakerOrderCallback#gridexPlaceMakerOrderCallback\\n    /// @param parameters The parameters used to place the maker orders\\n    /// @param data Any data to be passed through to the callback\\n    /// @return orderIds The unique identifiers of the orders\\n    function placeMakerOrderInBatch(\\n        IGridParameters.PlaceOrderInBatchParameters memory parameters,\\n        bytes calldata data\\n    ) external returns (uint256[] memory orderIds);\\n\\n    /// @notice Settles a maker order\\n    /// @param orderId The unique identifier of the order\\n    /// @return amount0 The amount of token0 that the maker received\\n    /// @return amount1 The amount of token1 that the maker received\\n    function settleMakerOrder(uint256 orderId) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Settle maker order and collect\\n    /// @param recipient The address to receive the output of the settlement\\n    /// @param orderId The unique identifier of the order\\n    /// @param unwrapWETH9 Whether to unwrap WETH9 to ETH\\n    /// @return amount0 The amount of token0 that the maker received\\n    /// @return amount1 The amount of token1 that the maker received\\n    function settleMakerOrderAndCollect(\\n        address recipient,\\n        uint256 orderId,\\n        bool unwrapWETH9\\n    ) external returns (uint128 amount0, uint128 amount1);\\n\\n    /// @notice Settles maker orders and collects in a batch\\n    /// @param recipient The address to receive the output of the settlement\\n    /// @param orderIds The unique identifiers of the orders\\n    /// @param unwrapWETH9 Whether to unwrap WETH9 to ETH\\n    /// @return amount0Total The total amount of token0 that the maker received\\n    /// @return amount1Total The total amount of token1 that the maker received\\n    function settleMakerOrderAndCollectInBatch(\\n        address recipient,\\n        uint256[] memory orderIds,\\n        bool unwrapWETH9\\n    ) external returns (uint128 amount0Total, uint128 amount1Total);\\n\\n    /// @notice For flash swaps. The caller borrows assets and returns them in the callback of the function,\\n    /// in addition to a fee\\n    /// @dev The caller of this function receives a callback in the form of IGridFlashCallback#gridexFlashCallback\\n    /// @param recipient The address which will receive the token0 and token1\\n    /// @param amount0 The amount of token0 to receive\\n    /// @param amount1 The amount of token1 to receive\\n    /// @param data Any data to be passed through to the callback\\n    function flash(address recipient, uint256 amount0, uint256 amount1, bytes calldata data) external;\\n\\n    /// @notice Collects tokens owed\\n    /// @param recipient The address to receive the collected fees\\n    /// @param amount0Requested The maximum amount of token0 to send.\\n    /// Set to 0 if fees should only be collected in token1.\\n    /// @param amount1Requested The maximum amount of token1 to send.\\n    /// Set to 0 if fees should only be collected in token0.\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(\\n        address recipient,\\n        uint128 amount0Requested,\\n        uint128 amount1Requested\\n    ) external returns (uint128 amount0, uint128 amount1);\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IGridParameters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IGridParameters {\\n    /// @dev Parameters for initializing the grid\\n    struct InitializeParameters {\\n        /// @dev The initial price of the grid, as a Q64.96.\\n        /// Price is represented as an amountToken1/amountToken0 Q64.96 value.\\n        uint160 priceX96;\\n        /// @dev The address to receive orders\\n        address recipient;\\n        /// @dev Represents the order parameters for token0\\n        BoundaryLowerWithAmountParameters[] orders0;\\n        /// @dev Represents the order parameters for token1\\n        BoundaryLowerWithAmountParameters[] orders1;\\n    }\\n\\n    /// @dev Parameters for placing an order\\n    struct PlaceOrderParameters {\\n        /// @dev The address to receive the order\\n        address recipient;\\n        /// @dev When zero is true, it represents token0, otherwise it represents token1\\n        bool zero;\\n        /// @dev The lower boundary of the order\\n        int24 boundaryLower;\\n        /// @dev The amount of token0 or token1 to add\\n        uint128 amount;\\n    }\\n\\n    struct PlaceOrderInBatchParameters {\\n        /// @dev The address to receive the order\\n        address recipient;\\n        /// @dev When zero is true, it represents token0, otherwise it represents token1\\n        bool zero;\\n        BoundaryLowerWithAmountParameters[] orders;\\n    }\\n\\n    struct BoundaryLowerWithAmountParameters {\\n        /// @dev The lower boundary of the order\\n        int24 boundaryLower;\\n        /// @dev The amount of token0 or token1 to add\\n        uint128 amount;\\n    }\\n\\n    /// @dev Status during swap\\n    struct SwapState {\\n        /// @dev When true, token0 is swapped for token1, otherwise token1 is swapped for token0\\n        bool zeroForOne;\\n        /// @dev The remaining amount of the swap, which implicitly configures\\n        /// the swap as exact input (positive), or exact output (negative)\\n        int256 amountSpecifiedRemaining;\\n        /// @dev The calculated amount to be inputted\\n        uint256 amountInputCalculated;\\n        /// @dev The calculated amount of fee to be inputted\\n        uint256 feeAmountInputCalculated;\\n        /// @dev The calculated amount to be outputted\\n        uint256 amountOutputCalculated;\\n        /// @dev The price of the grid, as a Q64.96\\n        uint160 priceX96;\\n        uint160 priceLimitX96;\\n        /// @dev The boundary of the grid\\n        int24 boundary;\\n        /// @dev The lower boundary of the grid\\n        int24 boundaryLower;\\n        uint160 initializedBoundaryLowerPriceX96;\\n        uint160 initializedBoundaryUpperPriceX96;\\n        /// @dev Whether the swap has been completed\\n        bool stopSwap;\\n    }\\n\\n    struct SwapForBoundaryState {\\n        /// @dev The price indicated by the lower boundary, as a Q64.96\\n        uint160 boundaryLowerPriceX96;\\n        /// @dev The price indicated by the upper boundary, as a Q64.96\\n        uint160 boundaryUpperPriceX96;\\n        /// @dev The price indicated by the lower or upper boundary, as a Q64.96.\\n        /// When using token0 to exchange token1, it is equal to boundaryLowerPriceX96,\\n        /// otherwise it is equal to boundaryUpperPriceX96\\n        uint160 boundaryPriceX96;\\n        /// @dev The price of the grid, as a Q64.96\\n        uint160 priceX96;\\n    }\\n\\n    struct UpdateBundleForTakerParameters {\\n        /// @dev The amount to be swapped in to bundle0\\n        uint256 amountInUsed;\\n        /// @dev The remaining amount to be swapped in to bundle1\\n        uint256 amountInRemaining;\\n        /// @dev The amount to be swapped out to bundle0\\n        uint128 amountOutUsed;\\n        /// @dev The remaining amount to be swapped out to bundle1\\n        uint128 amountOutRemaining;\\n        /// @dev The amount to be paid to bundle0\\n        uint128 takerFeeForMakerAmountUsed;\\n        /// @dev The amount to be paid to bundle1\\n        uint128 takerFeeForMakerAmountRemaining;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IGridStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IGridStructs {\\n    struct Bundle {\\n        int24 boundaryLower;\\n        bool zero;\\n        uint128 makerAmountTotal;\\n        uint128 makerAmountRemaining;\\n        uint128 takerAmountRemaining;\\n        uint128 takerFeeAmountRemaining;\\n    }\\n\\n    struct Boundary {\\n        uint64 bundle0Id;\\n        uint64 bundle1Id;\\n        uint128 makerAmountRemaining;\\n    }\\n\\n    struct Order {\\n        uint64 bundleId;\\n        address owner;\\n        uint128 amount;\\n    }\\n\\n    struct TokensOwed {\\n        uint128 token0;\\n        uint128 token1;\\n    }\\n\\n    struct Slot0 {\\n        uint160 priceX96;\\n        int24 boundary;\\n        uint32 blockTimestamp;\\n        bool unlocked;\\n    }\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/interfaces/IWETHMinimum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IWETHMinimum {\\n    function deposit() external payable;\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function withdraw(uint256) external;\\n\\n    function approve(address guy, uint256 wad) external returns (bool);\\n\\n    function balanceOf(address dst) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/libraries/BoundaryMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary BoundaryMath {\\n    int24 public constant MIN_BOUNDARY = -527400;\\n    int24 public constant MAX_BOUNDARY = 443635;\\n\\n    /// @dev The minimum value that can be returned from #getPriceX96AtBoundary. Equivalent to getPriceX96AtBoundary(MIN_BOUNDARY)\\n    uint160 internal constant MIN_RATIO = 989314;\\n    /// @dev The maximum value that can be returned from #getPriceX96AtBoundary. Equivalent to getPriceX96AtBoundary(MAX_BOUNDARY)\\n    uint160 internal constant MAX_RATIO = 1461300573427867316570072651998408279850435624081;\\n\\n    /// @dev Checks if a boundary is divisible by a resolution\\n    /// @param boundary The boundary to check\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return isValid Whether or not the boundary is valid\\n    function isValidBoundary(int24 boundary, int24 resolution) internal pure returns (bool isValid) {\\n        return boundary % resolution == 0;\\n    }\\n\\n    /// @dev Checks if a boundary is within the valid range\\n    /// @param boundary The boundary to check\\n    /// @return inRange Whether or not the boundary is in range\\n    function isInRange(int24 boundary) internal pure returns (bool inRange) {\\n        return boundary >= MIN_BOUNDARY && boundary <= MAX_BOUNDARY;\\n    }\\n\\n    /// @dev Checks if a price is within the valid range\\n    /// @param priceX96 The price to check, as a Q64.96\\n    /// @return inRange Whether or not the price is in range\\n    function isPriceX96InRange(uint160 priceX96) internal pure returns (bool inRange) {\\n        return priceX96 >= MIN_RATIO && priceX96 <= MAX_RATIO;\\n    }\\n\\n    /// @notice Calculates the price at a given boundary\\n    /// @dev priceX96 = pow(1.0001, boundary) * 2**96\\n    /// @param boundary The boundary to calculate the price at\\n    /// @return priceX96 The price at the boundary, as a Q64.96\\n    function getPriceX96AtBoundary(int24 boundary) internal pure returns (uint160 priceX96) {\\n        unchecked {\\n            uint256 absBoundary = boundary < 0 ? uint256(-int256(boundary)) : uint24(boundary);\\n\\n            uint256 ratio = absBoundary & 0x1 != 0\\n                ? 0xfff97272373d413259a46990580e213a\\n                : 0x100000000000000000000000000000000;\\n            if (absBoundary & 0x2 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absBoundary & 0x4 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absBoundary & 0x8 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absBoundary & 0x10 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absBoundary & 0x20 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absBoundary & 0x40 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absBoundary & 0x80 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absBoundary & 0x100 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absBoundary & 0x200 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absBoundary & 0x400 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absBoundary & 0x800 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absBoundary & 0x1000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absBoundary & 0x2000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absBoundary & 0x4000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absBoundary & 0x8000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absBoundary & 0x10000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absBoundary & 0x20000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absBoundary & 0x40000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n            if (absBoundary & 0x80000 != 0) ratio = (ratio * 0x149b34ee7ac263) >> 128;\\n\\n            if (boundary > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 and rounds up to go from a Q128.128 to a Q128.96.\\n            // due to out boundary input limitations, we then proceed to downcast as the\\n            // result will always fit within 160 bits.\\n            // we round up in the division so that getBoundaryAtPriceX96 of the output price is always consistent\\n            priceX96 = uint160((ratio + 0xffffffff) >> 32);\\n        }\\n    }\\n\\n    /// @notice Calculates the boundary at a given price\\n    /// @param priceX96 The price to calculate the boundary at, as a Q64.96\\n    /// @return boundary The boundary at the price\\n    function getBoundaryAtPriceX96(uint160 priceX96) internal pure returns (int24 boundary) {\\n        unchecked {\\n            uint256 ratio = uint256(priceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log10001 = log_2 * 127869479499801913173570;\\n            // 128.128 number\\n\\n            int24 boundaryLow = int24((log10001 - 1701496478404566090792001455681771637) >> 128);\\n            int24 boundaryHi = int24((log10001 + 289637967442836604689790891002483458648) >> 128);\\n\\n            boundary = boundaryLow == boundaryHi ? boundaryLow : getPriceX96AtBoundary(boundaryHi) <= priceX96\\n                ? boundaryHi\\n                : boundaryLow;\\n        }\\n    }\\n\\n    /// @dev Returns the lower boundary for the given boundary and resolution.\\n    /// The lower boundary may not be valid (if out of the boundary range)\\n    /// @param boundary The boundary to get the lower boundary for\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return boundaryLower The lower boundary for the given boundary and resolution\\n    function getBoundaryLowerAtBoundary(int24 boundary, int24 resolution) internal pure returns (int24 boundaryLower) {\\n        unchecked {\\n            return boundary - (((boundary % resolution) + resolution) % resolution);\\n        }\\n    }\\n\\n    /// @dev Rewrite the lower boundary that is not in the range to a valid value\\n    /// @param boundaryLower The lower boundary to rewrite\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return validBoundaryLower The valid lower boundary\\n    function rewriteToValidBoundaryLower(\\n        int24 boundaryLower,\\n        int24 resolution\\n    ) internal pure returns (int24 validBoundaryLower) {\\n        unchecked {\\n            if (boundaryLower < MIN_BOUNDARY) return boundaryLower + resolution;\\n            else if (boundaryLower + resolution > MAX_BOUNDARY) return boundaryLower - resolution;\\n            else return boundaryLower;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/libraries/CallbackValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./GridAddress.sol\\\";\\n\\nlibrary CallbackValidator {\\n    /// @dev Validates the `msg.sender` is the canonical grid address for the given parameters\\n    /// @param gridFactory The address of the grid factory\\n    /// @param gridKey The grid key to compute the canonical address for the grid\\n    function validate(address gridFactory, GridAddress.GridKey memory gridKey) internal view {\\n        // CV_IC: invalid caller\\n        require(GridAddress.computeAddress(gridFactory, gridKey) == msg.sender, \\\"CV_IC\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"@gridexprotocol/core/contracts/libraries/GridAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary GridAddress {\\n    bytes32 internal constant GRID_BYTES_CODE_HASH = 0x884a6891a166f885bf6f0a3b330a25e41d1761a5aa091110a229d9a0e34b2c36;\\n\\n    struct GridKey {\\n        address token0;\\n        address token1;\\n        int24 resolution;\\n    }\\n\\n    /// @notice Constructs the grid key for the given parameters\\n    /// @dev tokenA and tokenB may be passed in, in the order of either token0/token1 or token1/token0\\n    /// @param tokenA The contract address of either token0 or token1\\n    /// @param tokenB The contract address of the other token\\n    /// @param resolution The step size in initialized boundaries for a grid created with a given fee\\n    /// @return key The grid key to compute the canonical address for the grid\\n    function gridKey(address tokenA, address tokenB, int24 resolution) internal pure returns (GridKey memory key) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n\\n        return GridKey(tokenA, tokenB, resolution);\\n    }\\n\\n    /// @dev Computes the CREATE2 address for a grid with the given parameters\\n    /// @param gridFactory The address of the grid factory\\n    /// @param key The grid key to compute the canonical address for the grid\\n    /// @return grid The computed address\\n    function computeAddress(address gridFactory, GridKey memory key) internal pure returns (address grid) {\\n        require(key.token0 < key.token1);\\n        return\\n            Create2.computeAddress(\\n                keccak256(abi.encode(key.token0, key.token1, key.resolution)),\\n                GRID_BYTES_CODE_HASH,\\n                gridFactory\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(\\n        uint256 amount,\\n        bytes32 salt,\\n        bytes memory bytecode\\n    ) internal returns (address addr) {\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(\\n        bytes32 salt,\\n        bytes32 bytecodeHash,\\n        address deployer\\n    ) internal pure returns (address addr) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40) // Get free memory pointer\\n\\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\\n            // | 0xFF              |            FF                                                             |\\n            // |-------------------|---------------------------------------------------------------------------|\\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\\n\\n            mstore(add(ptr, 0x40), bytecodeHash)\\n            mstore(add(ptr, 0x20), salt)\\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\\n            mstore8(start, 0xff)\\n            addr := keccak256(start, 85)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AbstractPayments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/interfaces/IWETHMinimum.sol\\\";\\nimport \\\"./interfaces/IPayments.sol\\\";\\n\\nabstract contract AbstractPayments is IPayments, Context {\\n    /// @dev The address of IGridFactory\\n    address public immutable gridFactory;\\n    /// @dev The address of IWETHMinimum\\n    address public immutable weth9;\\n\\n    constructor(address _gridFactory, address _weth9) {\\n        // AP_NC: not contract\\n        require(Address.isContract(_gridFactory), \\\"AP_NC\\\");\\n        require(Address.isContract(_weth9), \\\"AP_NC\\\");\\n\\n        gridFactory = _gridFactory;\\n        weth9 = _weth9;\\n    }\\n\\n    modifier checkDeadline(uint256 deadline) {\\n        // AP_TTO: transaction too old\\n        require(block.timestamp <= deadline, \\\"AP_TTO\\\");\\n        _;\\n    }\\n\\n    receive() external payable {\\n        // AP_WETH9: not WETH9\\n        require(_msgSender() == weth9, \\\"AP_WETH9\\\");\\n    }\\n\\n    /// @inheritdoc IPayments\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {\\n        uint256 balanceWETH9 = IWETHMinimum(weth9).balanceOf(address(this));\\n        // AP_IWETH9: insufficient WETH9\\n        require(balanceWETH9 >= amountMinimum, \\\"AP_IWETH9\\\");\\n\\n        if (balanceWETH9 > 0) {\\n            IWETHMinimum(weth9).withdraw(balanceWETH9);\\n            Address.sendValue(payable(recipient), balanceWETH9);\\n        }\\n    }\\n\\n    /// @inheritdoc IPayments\\n    function sweepToken(address token, uint256 amountMinimum, address recipient) public payable override {\\n        uint256 balanceToken = IERC20(token).balanceOf(address(this));\\n        // AP_ITKN: insufficient token\\n        require(balanceToken >= amountMinimum, \\\"AP_ITKN\\\");\\n\\n        if (balanceToken > 0) SafeERC20.safeTransfer(IERC20(token), recipient, balanceToken);\\n    }\\n\\n    /// @inheritdoc IPayments\\n    function refundNativeToken() external payable {\\n        if (address(this).balance > 0) Address.sendValue(payable(_msgSender()), address(this).balance);\\n    }\\n\\n    /// @dev Pays the token to the recipient\\n    /// @param token The token to pay\\n    /// @param payer The address of the payment token\\n    /// @param recipient The address that will receive the payment\\n    /// @param amount The amount to pay\\n    function pay(address token, address payer, address recipient, uint256 amount) internal {\\n        if (token == weth9 && address(this).balance >= amount) {\\n            // pay with WETH9\\n            Address.sendValue(payable(weth9), amount);\\n            IWETHMinimum(weth9).transfer(recipient, amount);\\n        } else if (payer == address(this)) SafeERC20.safeTransfer(IERC20(token), recipient, amount);\\n        else SafeERC20.safeTransferFrom(IERC20(token), payer, recipient, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/AbstractSelfPermit2612.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\\\";\\n\\n/// @dev Backward compatible EIP-2612 contract definitions.\\n//  For more information, please refer to https://eips.ethereum.org/EIPS/eip-2612#backwards-compatibility\\ninterface IPermit2612Compatible {\\n    function permit(\\n        address holder,\\n        address spender,\\n        uint256 nonce,\\n        uint256 expiry,\\n        bool allowed,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\\n/// @dev Base contract for supporting the EIP-2612 specification.\\n/// For more information, please refer to https://eips.ethereum.org/EIPS/eip-2612\\nabstract contract AbstractSelfPermit2612 {\\n    function selfPermit(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable {\\n        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    }\\n\\n    function selfPermitIfNecessary(\\n        address token,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable {\\n        if (IERC20(token).allowance(msg.sender, address(this)) < value)\\n            IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);\\n    }\\n\\n    function selfPermitCompatible(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable {\\n        IPermit2612Compatible(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\\n    }\\n\\n    function selfPermitCompatibleIfNecessary(\\n        address token,\\n        uint256 nonce,\\n        uint256 expiry,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external payable {\\n        if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max)\\n            IPermit2612Compatible(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/CurveRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AbstractPayments.sol\\\";\\nimport \\\"./interfaces/ICurvePool.sol\\\";\\nimport \\\"./libraries/SwapPath.sol\\\";\\nimport \\\"./libraries/Protocols.sol\\\";\\n\\nabstract contract CurveRouter is AbstractPayments {\\n    using SwapPath for bytes;\\n\\n    struct CurvePayload {\\n        /// @dev The address of the Curve pool contract that the quote is being requested for\\n        address poolAddress;\\n        /// @dev The address of the swap contract that will be used to execute the token swap.\\n        address swapAddress;\\n        /// @dev The index of the input token in the Curve pool\\n        uint8 tokenInIndex;\\n        /// @dev The index of the output token in the Curve pool\\n        uint8 tokenOutIndex;\\n    }\\n\\n    mapping(address => mapping(address => bool)) private approved;\\n    uint256 private constant DEFAULT_APPROVED = type(uint256).max;\\n\\n    function _decodePath(\\n        bytes memory path\\n    ) internal pure returns (address tokenIn, address tokenOut, CurvePayload memory payload) {\\n        (\\n            tokenIn,\\n            tokenOut,\\n            payload.poolAddress,\\n            payload.swapAddress,\\n            payload.tokenInIndex,\\n            payload.tokenOutIndex\\n        ) = path.decodeFirstCurvePool();\\n    }\\n\\n    function curveExactInputInternal(\\n        uint256 amountIn,\\n        bytes memory path,\\n        uint8 protocol,\\n        address recipient\\n    ) internal returns (uint256 amountOut) {\\n        (address tokenIn, address tokenOut, CurvePayload memory payload) = _decodePath(path);\\n        if (!approved[tokenIn][payload.poolAddress]) {\\n            IERC20(tokenIn).approve(payload.poolAddress, DEFAULT_APPROVED);\\n            approved[tokenIn][payload.poolAddress] = true;\\n        }\\n\\n        if (protocol == Protocols.CURVE1) {\\n            ICurvePool(payload.poolAddress).exchange(\\n                int128(int8(payload.tokenInIndex)),\\n                int128(int8(payload.tokenOutIndex)),\\n                amountIn,\\n                0\\n            );\\n        } else if (protocol == Protocols.CURVE2) {\\n            ICurvePool(payload.poolAddress).exchange_underlying(\\n                int128(int8(payload.tokenInIndex)),\\n                int128(int8(payload.tokenOutIndex)),\\n                amountIn,\\n                0\\n            );\\n        } else if (protocol == Protocols.CURVE3) {\\n            ICurveCryptoPool(payload.poolAddress).exchange(\\n                uint256(payload.tokenInIndex),\\n                uint256(payload.tokenOutIndex),\\n                amountIn,\\n                0\\n            );\\n        } else if (protocol == Protocols.CURVE4) {\\n            ICurveCryptoPool(payload.poolAddress).exchange_underlying(\\n                uint256(payload.tokenInIndex),\\n                uint256(payload.tokenOutIndex),\\n                amountIn,\\n                0\\n            );\\n        } else if (protocol == Protocols.CURVE7) {\\n            uint256[2] memory _amounts;\\n            _amounts[payload.tokenInIndex] = amountIn;\\n            ICurveBasePool2Coins(payload.poolAddress).add_liquidity(_amounts, 0);\\n        } else if (protocol == Protocols.CURVE8) {\\n            uint256[3] memory _amounts;\\n            _amounts[payload.tokenInIndex] = amountIn;\\n            ICurveBasePool3Coins(payload.poolAddress).add_liquidity(_amounts, 0);\\n        } else if (protocol == Protocols.CURVE9) {\\n            uint256[3] memory _amounts;\\n            _amounts[payload.tokenInIndex] = amountIn;\\n            ICurveLendingBasePool3Coins(payload.poolAddress).add_liquidity(_amounts, 0, true);\\n        } else if (protocol == Protocols.CURVE10) {\\n            ICurveBasePool3Coins(payload.poolAddress).remove_liquidity_one_coin(\\n                amountIn,\\n                int128(int8(payload.tokenOutIndex)),\\n                0\\n            );\\n        } else if (protocol == Protocols.CURVE11) {\\n            ICurveLendingBasePool3Coins(payload.poolAddress).remove_liquidity_one_coin(\\n                amountIn,\\n                int128(int8(payload.tokenOutIndex)),\\n                0,\\n                true\\n            );\\n        } else if (protocol == Protocols.CURVE5) {\\n            ICurveLendingBasePoolMetaZap(payload.poolAddress).exchange_underlying(\\n                payload.swapAddress,\\n                int128(int8(payload.tokenInIndex)),\\n                int128(int8(payload.tokenOutIndex)),\\n                amountIn,\\n                0\\n            );\\n        } else if (protocol == Protocols.CURVE6) {\\n            ICurveCryptoMetaZap(payload.poolAddress).exchange(\\n                payload.swapAddress,\\n                uint256(payload.tokenInIndex),\\n                uint256(payload.tokenOutIndex),\\n                amountIn,\\n                0,\\n                false\\n            );\\n        } else {\\n            // CRQ_IP: invalid protocol\\n            revert(\\\"CRQ_IP\\\");\\n        }\\n        amountOut = IERC20(tokenOut).balanceOf(address(this));\\n        if (recipient != address(this)) pay(tokenOut, address(this), recipient, amountOut);\\n    }\\n\\n    function approveToCurvePool(address token, address poolAddress) external {\\n        IERC20(token).approve(poolAddress, DEFAULT_APPROVED);\\n        approved[token][poolAddress] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ICurvePool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface ICurvePool {\\n    function exchange(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable;\\n\\n    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external payable;\\n\\n    function get_dy(int128 i, int128 j, uint256 amount) external view returns (uint256);\\n\\n    function get_dy_underlying(int128 i, int128 j, uint256 amount) external view returns (uint256);\\n}\\n\\ninterface ICurveLendingBasePoolMetaZap {\\n    function exchange_underlying(address pool, int128 i, int128 j, uint256 dx, uint256 min_dy) external;\\n}\\n\\ninterface ICurveLendingBasePool3Coins {\\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount, bool use_underlying) external;\\n\\n    function calc_token_amount(uint256[3] memory amounts, bool is_deposit) external view returns (uint256);\\n\\n    function remove_liquidity_one_coin(\\n        uint256 token_amount,\\n        int128 i,\\n        uint256 min_amount,\\n        bool use_underlying\\n    ) external returns (uint256);\\n\\n    function calc_withdraw_one_coin(uint256 token_amount, int128 i) external view returns (uint256);\\n}\\n\\ninterface ICurveCryptoPool {\\n    function exchange(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable;\\n\\n    function exchange_underlying(uint256 i, uint256 j, uint256 dx, uint256 min_dy) external payable;\\n\\n    function get_dy(uint256 i, uint256 j, uint256 amount) external view returns (uint256);\\n\\n    function get_dy_underlying(uint256 i, uint256 j, uint256 amount) external view returns (uint256);\\n}\\n\\ninterface ICurveCryptoMetaZap {\\n    function get_dy(address pool, uint256 i, uint256 j, uint256 dx) external view returns (uint256);\\n\\n    function exchange(address pool, uint256 i, uint256 j, uint256 dx, uint256 min_dy, bool use_eth) external payable;\\n}\\n\\ninterface ICurveBasePool3Coins {\\n    function add_liquidity(uint256[3] memory amounts, uint256 min_mint_amount) external;\\n\\n    function calc_token_amount(uint256[3] memory amounts, bool is_deposit) external view returns (uint256);\\n\\n    function remove_liquidity_one_coin(uint256 token_amount, int128 i, uint256 min_amount) external;\\n\\n    function calc_withdraw_one_coin(uint256 token_amount, int128 i) external view returns (uint256);\\n}\\n\\ninterface ICurveBasePool2Coins {\\n    function add_liquidity(uint256[2] memory amounts, uint256 min_mint_amount) external;\\n\\n    function calc_token_amount(uint256[2] memory amounts, bool is_deposit) external view returns (uint256);\\n\\n    function remove_liquidity_one_coin(uint256 token_amount, int128 i, uint256 min_amount) external;\\n\\n    function calc_withdraw_one_coin(uint256 token_amount, int128 i) external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPayments.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IPayments {\\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\\n    /// @param recipient The address receiving ETH\\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\\n\\n    /// @notice Refunds any native token(e.g. ETH) balance held by this contract to the `msg.sender`\\n    /// @dev This method is suitable for the following 2 scenarios:\\n    /// 1. When using exactInput, the inputted Ether is not fully consumed due to insufficient liquidity so,\\n    ///    remaining Ether can be withdrawn through this method\\n    /// 2. When using exactOutput, the inputted Ether is not fully consumed because the slippage settings\\n    /// are too high, henceforth, the remaining Ether can be withdrawn through this method\\n    function refundNativeToken() external payable;\\n\\n    /// @notice Transfers the full amount of a token held by this contract to a recipient\\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\\n    /// @param token The contract address of the tokens which will be transferred to the `recipient`\\n    /// @param amountMinimum The minimum amount of tokens required for a transfer\\n    /// @param recipient The destination address of the tokens\\n    function sweepToken(address token, uint256 amountMinimum, address recipient) external payable;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"@gridexprotocol/core/contracts/interfaces/callback/IGridSwapCallback.sol\\\";\\n\\n/// @title Router token swapping functionality\\n/// @notice Functions for swapping tokens via Gridex\\ninterface ISwapRouter is IGridSwapCallback {\\n    struct ExactInputSingleParameters {\\n        /// @dev Address of the input token\\n        address tokenIn;\\n        /// @dev Address of the output token\\n        address tokenOut;\\n        /// @dev The resolution of the pool to swap on\\n        int24 resolution;\\n        /// @dev Address to receive swapped tokens\\n        address recipient;\\n        /// @dev The deadline of the transaction execution\\n        uint256 deadline;\\n        /// @dev The amount of the input token to swap\\n        uint256 amountIn;\\n        /// @dev The minimum amount of the last token to receive. Reverts if actual amount received is less than this value.\\n        uint256 amountOutMinimum;\\n        /// @dev If zero for one, the price cannot be less than this value after the swap. If one for zero,\\n        /// the price cannot be greater than this value after the swap\\n        uint160 priceLimitX96;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\\n    /// @param parameters The parameters necessary for the swap, encoded as `ExactInputSingleParameters` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInputSingle(\\n        ExactInputSingleParameters calldata parameters\\n    ) external payable returns (uint256 amountOut);\\n\\n    struct ExactInputParameters {\\n        /// @dev Path of tokens to swap\\n        bytes path;\\n        /// @dev Address to receive swapped tokens\\n        address recipient;\\n        /// @dev The deadline of the transaction execution\\n        uint256 deadline;\\n        /// @dev The amount of the input token to swap\\n        uint256 amountIn;\\n        /// @dev The minimum amount of the last token to receive. Reverts if actual amount received is less than this value.\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\\n    /// @param parameters The parameters necessary for the multi-hop swap, encoded as `ExactInputParameters` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactInput(ExactInputParameters calldata parameters) external payable returns (uint256 amountOut);\\n\\n    struct ExactOutputSingleParameters {\\n        /// @dev Address of the input token\\n        address tokenIn;\\n        /// @dev Address of the output token\\n        address tokenOut;\\n        /// @dev The resolution of the pool to swap on\\n        int24 resolution;\\n        /// @dev Address to receive swapped tokens\\n        address recipient;\\n        /// @dev The deadline of the transaction execution\\n        uint256 deadline;\\n        /// @dev The amount of the output token to receive\\n        uint256 amountOut;\\n        /// @dev The maximum amount of input tokens to spend. Reverts if actual amount spent is greater than this value.\\n        uint256 amountInMaximum;\\n        /// @dev If zero for one, the price cannot be less than this value after the swap. If one for zero,\\n        /// the price cannot be greater than this value after the swap\\n        uint160 priceLimitX96;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\\n    /// @param parameters The parameters necessary for the swap, encoded as `ExactOutputSingleParameters` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutputSingle(\\n        ExactOutputSingleParameters calldata parameters\\n    ) external payable returns (uint256 amountIn);\\n\\n    struct ExactOutputParameters {\\n        /// @dev Path of tokens to swap\\n        bytes path;\\n        /// @dev Address to receive swapped tokens\\n        address recipient;\\n        /// @dev The deadline of the transaction execution\\n        uint256 deadline;\\n        /// @dev The amount of the output token to receive\\n        uint256 amountOut;\\n        /// @dev The maximum amount of input tokens to spend. Reverts if actual amount spent is greater than this value.\\n        uint256 amountInMaximum;\\n    }\\n\\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\\n    /// @param parameters The parameters necessary for the multi-hop swap, encoded as `ExactOutputParameters` in calldata\\n    /// @return amountIn The amount of the input token\\n    function exactOutput(ExactOutputParameters calldata parameters) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ISwapRouterHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ISwapRouter.sol\\\";\\nimport \\\"./IUniswapV2Router.sol\\\";\\nimport \\\"./IUniswapV3Router.sol\\\";\\n\\ninterface ISwapRouterHub is ISwapRouter, IUniswapV2Router, IUniswapV3Router {\\n    struct ExactMixedInputParameters {\\n        /// @dev The path of tokens to trade, encoded as SwapPath.\\n        bytes path;\\n        /// @dev The address that will receive the output tokens.\\n        address recipient;\\n        /// @dev The deadline of the transaction execution.\\n        uint256 deadline;\\n        /// @dev The amount of the first token to trade.\\n        uint256 amountIn;\\n        /// @dev The minimum amount of the last token to receive. Reverts if actual amount received is less than this value.\\n        uint256 amountOutMinimum;\\n    }\\n\\n    /// @notice This function executes a mixed input swap transaction with the specified input parameters.\\n    /// @param parameters The parameters necessary for the swap, encoded as `ExactMixedInputParameters` in calldata\\n    /// @return amountOut The amount of the received token\\n    function exactMixedInput(\\n        ExactMixedInputParameters calldata parameters\\n    ) external payable returns (uint256 amountOut);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV2Pair {\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\ninterface IUniswapV2Router {\\n    function uniswapV2ExactInput(\\n        uint256 amountIn,\\n        uint256 amountOutMinimum,\\n        address[] calldata path,\\n        address to\\n    ) external payable returns (uint256 amountOut);\\n\\n    function uniswapV2ExactOutput(\\n        uint256 amountOut,\\n        uint256 amountInMaximum,\\n        address[] calldata path,\\n        address to\\n    ) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3PoolMinimum.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\ninterface IUniswapV3PoolMinimum {\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n\\n    function slot0()\\n        external\\n        view\\n        returns (\\n            uint160 sqrtPriceX96,\\n            int24 tick,\\n            uint16 observationIndex,\\n            uint16 observationCardinality,\\n            uint16 observationCardinalityNext,\\n            uint8 feeProtocol,\\n            bool unlocked\\n        );\\n\\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\\n\\n    function tickSpacing() external view returns (int24);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IUniswapV3Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\ninterface IUniswapV3Router {\\n    struct UniswapV3ExactInputSingleParameters {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\\n\\n    function uniswapV3ExactInputSingle(\\n        UniswapV3ExactInputSingleParameters calldata parameters\\n    ) external payable returns (uint256 amountOut);\\n\\n    struct UniswapV3ExactInputParameters {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountIn;\\n        uint256 amountOutMinimum;\\n    }\\n\\n    function uniswapV3ExactInput(\\n        UniswapV3ExactInputParameters calldata parameters\\n    ) external payable returns (uint256 amountOut);\\n\\n    struct UniswapV3ExactOutputSingleParameters {\\n        address tokenIn;\\n        address tokenOut;\\n        uint24 fee;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n        uint160 sqrtPriceLimitX96;\\n    }\\n\\n    function uniswapV3ExactOutputSingle(\\n        UniswapV3ExactOutputSingleParameters calldata parameters\\n    ) external payable returns (uint256 amountIn);\\n\\n    struct UniswapV3ExactOutputParameters {\\n        bytes path;\\n        address recipient;\\n        uint256 deadline;\\n        uint256 amountOut;\\n        uint256 amountInMaximum;\\n    }\\n\\n    function uniswapV3ExactOutput(\\n        UniswapV3ExactOutputParameters calldata parameters\\n    ) external payable returns (uint256 amountIn);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/BytesLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\u00e7alo S\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity ^0.8.0;\\n\\nlibrary BytesLib {\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3, \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Protocols.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary Protocols {\\n    uint8 internal constant GRIDEX = 1;\\n    uint8 internal constant UNISWAPV3 = 2;\\n    uint8 internal constant UNISWAPV2 = 3;\\n    uint8 internal constant CURVE = 4;\\n    uint8 internal constant CURVE1 = 5;\\n    uint8 internal constant CURVE2 = 6;\\n    uint8 internal constant CURVE3 = 7;\\n    uint8 internal constant CURVE4 = 8;\\n    uint8 internal constant CURVE5 = 9;\\n    uint8 internal constant CURVE6 = 10;\\n    uint8 internal constant CURVE7 = 11;\\n    uint8 internal constant CURVE8 = 12;\\n    uint8 internal constant CURVE9 = 13;\\n    uint8 internal constant CURVE10 = 14;\\n    uint8 internal constant CURVE11 = 15;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/Ratio.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nlibrary Ratio {\\n    uint160 internal constant MIN_SQRT_RATIO_PLUS_ONE = 4295128739 + 1;\\n    uint160 internal constant MAX_SQRT_RATIO_MINUS_ONE = 1461446703485210103287273052203988822378723970342 - 1;\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/SwapPath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BytesLib.sol\\\";\\nimport \\\"./Protocols.sol\\\";\\n\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary SwapPath {\\n    using BytesLib for bytes;\\n\\n    /// @dev The length of the bytes encoded token index\\n    uint256 private constant TOKEN_INDEX_SIZE = 1;\\n\\n    /// @dev The length of the bytes encoded protocol\\n    uint256 private constant PROTOCOL_SIZE = 1;\\n\\n    /// @dev The length of the bytes encoded address\\n    uint256 private constant ADDR_SIZE = 20;\\n\\n    /// @dev The length of the bytes encoded resolution\\n    uint256 private constant RESOLUTION_SIZE = 3;\\n\\n    /// @dev The offset of the encoded resolution\\n    uint256 private constant RESOLUTION_OFFSET = ADDR_SIZE + PROTOCOL_SIZE;\\n\\n    /// @dev The size of the resolution payload\\n    uint256 private constant RESOLUTION_PAYLOAD_SIZE = PROTOCOL_SIZE + RESOLUTION_SIZE;\\n\\n    /// @dev The offset of a single token address and resolution payload\\n    uint256 private constant RESOLUTION_PAYLOAD_NEXT_OFFSET = ADDR_SIZE + RESOLUTION_PAYLOAD_SIZE;\\n\\n    /// @dev The offset of the encoded resolution payload grid key\\n    uint256 private constant RESOLUTION_PAYLOAD_POP_OFFSET = RESOLUTION_PAYLOAD_NEXT_OFFSET + ADDR_SIZE;\\n\\n    /// @dev The offset of the encoded swap address in the curve payload\\n    uint256 private constant CURVE_PAYLOAD_SWAP_ADDRESS_OFFSET = RESOLUTION_OFFSET + ADDR_SIZE;\\n\\n    /// @dev The offset of the encoded token A index in the curve payload\\n    uint256 private constant CURVE_PAYLOAD_TOKEN_A_INDEX_OFFSET = CURVE_PAYLOAD_SWAP_ADDRESS_OFFSET + ADDR_SIZE;\\n\\n    /// @dev The offset of the encoded token B index in the curve payload\\n    uint256 private constant CURVE_PAYLOAD_TOKEN_B_INDEX_OFFSET = CURVE_PAYLOAD_TOKEN_A_INDEX_OFFSET + TOKEN_INDEX_SIZE;\\n\\n    /// @dev The size of the curve payload\\n    uint256 private constant CURVE_PAYLOAD_SIZE = PROTOCOL_SIZE + ADDR_SIZE * 2 + TOKEN_INDEX_SIZE * 2;\\n\\n    /// @dev The offset of a single token address and curve payload\\n    uint256 private constant CURVE_PAYLOAD_NEXT_OFFSET = ADDR_SIZE + CURVE_PAYLOAD_SIZE;\\n\\n    /// @dev The offset of an encoded curve payload grid key\\n    uint256 private constant CURVE_PAYLOAD_POP_OFFSET = CURVE_PAYLOAD_NEXT_OFFSET + ADDR_SIZE;\\n\\n    /// @notice Returns true if the path contains two or more grids\\n    /// @param path The encoded swap path\\n    /// @return True if path contains two or more grids, otherwise false\\n    function hasMultipleGrids(bytes memory path) internal pure returns (bool) {\\n        if (getProtocol(path) < Protocols.CURVE) {\\n            return path.length > RESOLUTION_PAYLOAD_POP_OFFSET;\\n        } else {\\n            return path.length > CURVE_PAYLOAD_POP_OFFSET;\\n        }\\n    }\\n\\n    /// @notice Decodes the first grid in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenA The first token of the given grid\\n    /// @return tokenB The second token of the given grid\\n    /// @return resolution The resolution of the given grid\\n    function decodeFirstGrid(\\n        bytes memory path\\n    ) internal pure returns (address tokenA, address tokenB, int24 resolution) {\\n        tokenA = path.toAddress(0);\\n        resolution = int24(path.toUint24(RESOLUTION_OFFSET));\\n        tokenB = path.toAddress(RESOLUTION_PAYLOAD_NEXT_OFFSET);\\n    }\\n\\n    /// @notice Decodes the first curve pool in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenA The first token of the given pool\\n    /// @return tokenB The second token of the given pool\\n    /// @return poolAddress The address of the given pool\\n    /// @return swapAddress The swap address only for curve protocol\\n    /// @return tokenAIndex The index of the tokenA\\n    /// @return tokenBIndex The index of the tokenB\\n    function decodeFirstCurvePool(\\n        bytes memory path\\n    )\\n        internal\\n        pure\\n        returns (\\n            address tokenA,\\n            address tokenB,\\n            address poolAddress,\\n            address swapAddress,\\n            uint8 tokenAIndex,\\n            uint8 tokenBIndex\\n        )\\n    {\\n        tokenA = path.toAddress(0);\\n        poolAddress = path.toAddress(RESOLUTION_OFFSET);\\n        swapAddress = path.toAddress(CURVE_PAYLOAD_SWAP_ADDRESS_OFFSET);\\n        tokenAIndex = uint8(path[CURVE_PAYLOAD_TOKEN_A_INDEX_OFFSET]);\\n        tokenBIndex = uint8(path[CURVE_PAYLOAD_TOKEN_B_INDEX_OFFSET]);\\n        tokenB = path.toAddress(CURVE_PAYLOAD_NEXT_OFFSET);\\n    }\\n\\n    /// @notice Gets the segment corresponding to the first grid in the path\\n    /// @param path The bytes encoded swap path\\n    /// @return The segment containing all data necessary to target the first grid in the path\\n    function getFirstGrid(bytes memory path) internal pure returns (bytes memory) {\\n        if (getProtocol(path) < Protocols.CURVE) return path.slice(0, RESOLUTION_PAYLOAD_POP_OFFSET);\\n        else return path.slice(0, CURVE_PAYLOAD_POP_OFFSET);\\n    }\\n\\n    /// @notice Skips the token and the payload element from the buffer and returns the remainder\\n    /// @param path The swap path\\n    /// @return The remaining token + payload elements in the path\\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n        if (getProtocol(path) < Protocols.CURVE)\\n            return path.slice(RESOLUTION_PAYLOAD_NEXT_OFFSET, path.length - RESOLUTION_PAYLOAD_NEXT_OFFSET);\\n        else return path.slice(CURVE_PAYLOAD_NEXT_OFFSET, path.length - CURVE_PAYLOAD_NEXT_OFFSET);\\n    }\\n\\n    /// @notice Returns the protocol identifier for the given path\\n    /// @param path The encoded swap path\\n    /// @return The protocol identifier\\n    function getProtocol(bytes memory path) internal pure returns (uint8) {\\n        return uint8(path[ADDR_SIZE]);\\n    }\\n\\n    /// @notice Returns the first token address for the given path\\n    /// @param path The encoded swap path\\n    /// @return The first token address\\n    function getTokenA(bytes memory path) internal pure returns (address) {\\n        return path.toAddress(0);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapV2Library.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"../interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary UniswapV2Library {\\n    bytes32 internal constant POOL_BYTES_CODE_HASH = 0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f;\\n\\n    function sortTokens(address tokenA, address tokenB) internal pure returns (address token0, address token1) {\\n        require(tokenA != tokenB);\\n        (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\\n        require(token0 != address(0));\\n    }\\n\\n    function pairFor(address factory, address tokenA, address tokenB) internal pure returns (address pair) {\\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\\n        pair = Create2.computeAddress(keccak256(abi.encodePacked(token0, token1)), POOL_BYTES_CODE_HASH, factory);\\n    }\\n\\n    function getReserves(\\n        address factory,\\n        address tokenA,\\n        address tokenB\\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\\n        (address token0, ) = sortTokens(tokenA, tokenB);\\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();\\n        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n    }\\n\\n    function getAmountOut(\\n        uint256 amountIn,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountOut) {\\n        // UV2L_IIA: insufficient input amount\\n        require(amountIn > 0, \\\"UV2L_IIA\\\");\\n        require(reserveIn > 0 && reserveOut > 0);\\n        uint256 amountInWithFee = amountIn * 997;\\n        uint256 numerator = amountInWithFee * reserveOut;\\n        uint256 denominator = reserveIn * 1000 + amountInWithFee;\\n        amountOut = numerator / denominator;\\n    }\\n\\n    function getAmountIn(\\n        uint256 amountOut,\\n        uint256 reserveIn,\\n        uint256 reserveOut\\n    ) internal pure returns (uint256 amountIn) {\\n        // UV2L_IOA: insufficient output amount\\n        require(amountOut > 0, \\\"UV2L_IOA\\\");\\n        require(reserveIn > 0 && reserveOut > 0);\\n        uint256 numerator = reserveIn * amountOut * 1000;\\n        uint256 denominator = (reserveOut - amountOut) * 997;\\n        amountIn = numerator / denominator + 1;\\n    }\\n\\n    function getAmountsIn(\\n        address factory,\\n        uint256 amountOut,\\n        address[] memory path\\n    ) internal view returns (uint256[] memory amounts) {\\n        require(path.length >= 2);\\n        amounts = new uint256[](path.length);\\n        amounts[amounts.length - 1] = amountOut;\\n        for (uint256 i = path.length - 1; i > 0; i--) {\\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);\\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapV3CallbackValidator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UniswapV3PoolAddress.sol\\\";\\n\\nlibrary UniswapV3CallbackValidator {\\n    function validate(address poolFactory, address tokenA, address tokenB, uint24 fee) internal view {\\n        validate(poolFactory, UniswapV3PoolAddress.poolKey(tokenA, tokenB, fee));\\n    }\\n\\n    function validate(address poolFactory, UniswapV3PoolAddress.PoolKey memory poolKey) internal view {\\n        // CV_IC: invalid caller\\n        require(UniswapV3PoolAddress.computeAddress(poolFactory, poolKey) == msg.sender, \\\"CV_IC\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/UniswapV3PoolAddress.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Create2.sol\\\";\\n\\nlibrary UniswapV3PoolAddress {\\n    bytes32 internal constant POOL_BYTES_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\\n\\n    struct PoolKey {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n    }\\n\\n    function poolKey(address tokenA, address tokenB, uint24 fee) internal pure returns (PoolKey memory) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n\\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\\n    }\\n\\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address) {\\n        require(key.token0 < key.token1);\\n        return\\n            Create2.computeAddress(\\n                keccak256(abi.encode(key.token0, key.token1, key.fee)),\\n                POOL_BYTES_CODE_HASH,\\n                factory\\n            );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\nabstract contract Multicall {\\n    function multicall(bytes[] calldata data) external payable virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        unchecked {\\n            for (uint256 i = 0; i < data.length; i++) {\\n                results[i] = _functionDelegateCall(data[i]);\\n            }\\n        }\\n\\n        return results;\\n    }\\n\\n    function _functionDelegateCall(bytes memory data) private returns (bytes memory) {\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(this).delegatecall(data);\\n        // M_LDCF: low-level delegate call failed\\n        return Address.verifyCallResult(success, returndata, \\\"M_LDCF\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SwapRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/interfaces/IGrid.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/interfaces/callback/IGridSwapCallback.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/libraries/GridAddress.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/libraries/CallbackValidator.sol\\\";\\nimport \\\"@gridexprotocol/core/contracts/libraries/BoundaryMath.sol\\\";\\nimport \\\"./interfaces/ISwapRouter.sol\\\";\\nimport \\\"./libraries/SwapPath.sol\\\";\\nimport \\\"./AbstractPayments.sol\\\";\\nimport \\\"./Multicall.sol\\\";\\n\\n/// @title Gridex Swap Router\\n/// @notice A stateless execution router adapted for the gridex protocol\\nabstract contract SwapRouter is IGridSwapCallback, ISwapRouter, AbstractPayments, Multicall {\\n    using SwapPath for bytes;\\n    using SafeCast for uint256;\\n\\n    /// @dev This constant is used as a placeholder value for amountInCached; as the computed amount (for\\n    /// an exact output swap), will never reach this value\\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\\n\\n    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.\\n    uint256 private amountInCached;\\n\\n    constructor() {\\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    }\\n\\n    /// @dev Returns the grid for the given token pair and resolution. The grid contract may or may not exist.\\n    function getGrid(address tokenA, address tokenB, int24 resolution) private view returns (IGrid) {\\n        return IGrid(GridAddress.computeAddress(gridFactory, GridAddress.gridKey(tokenA, tokenB, resolution)));\\n    }\\n\\n    struct SwapCallbackData {\\n        bytes path;\\n        address payer;\\n    }\\n\\n    /// @inheritdoc IGridSwapCallback\\n    function gridexSwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\\n        // swaps which are entirely contained within zero liquidity regions are not supported\\n        // SR_IAD: invalid amount delta\\n        require(amount0Delta > 0 || amount1Delta > 0, \\\"SR_IAD\\\");\\n        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\\n        (address tokenIn, address tokenOut, int24 resolution) = data.path.decodeFirstGrid();\\n        CallbackValidator.validate(gridFactory, GridAddress.gridKey(tokenIn, tokenOut, resolution));\\n\\n        (bool isExactInput, uint256 amountToPay) = amount0Delta > 0\\n            ? (tokenIn < tokenOut, uint256(amount0Delta))\\n            : (tokenOut < tokenIn, uint256(amount1Delta));\\n        if (isExactInput) pay(tokenIn, data.payer, _msgSender(), amountToPay);\\n        else {\\n            // either initiate the next swap or pay\\n            if (data.path.hasMultipleGrids()) {\\n                data.path = data.path.skipToken();\\n                exactOutputInternal(amountToPay, _msgSender(), 0, data);\\n            } else {\\n                amountInCached = amountToPay;\\n                // swap in/out because the exact output swaps are reversed\\n                tokenIn = tokenOut;\\n                pay(tokenIn, data.payer, _msgSender(), amountToPay);\\n            }\\n        }\\n    }\\n\\n    /// @dev Performs a single exact input swap\\n    function exactInputInternal(\\n        uint256 amountIn,\\n        address recipient,\\n        uint160 priceLimitX96,\\n        SwapCallbackData memory data\\n    ) internal returns (uint256 amountOut) {\\n        // allow swapping to the router address with address 0\\n        recipient = recipient == address(0) ? address(this) : recipient;\\n\\n        (IGrid grid, bool zeroForOne) = _decodeGridForExactInput(data);\\n\\n        (int256 amount0, int256 amount1) = grid.swap(\\n            recipient,\\n            zeroForOne,\\n            amountIn.toInt256(),\\n            priceLimitX96 == 0 ? (zeroForOne ? BoundaryMath.MIN_RATIO : BoundaryMath.MAX_RATIO) : priceLimitX96,\\n            abi.encode(data)\\n        );\\n\\n        return uint256(-(zeroForOne ? amount1 : amount0));\\n    }\\n\\n    function _decodeGridForExactInput(SwapCallbackData memory data) private view returns (IGrid grid, bool zeroForOne) {\\n        (address tokenIn, address tokenOut, int24 resolution) = data.path.decodeFirstGrid();\\n        return (getGrid(tokenIn, tokenOut, resolution), tokenIn < tokenOut);\\n    }\\n\\n    /// @inheritdoc ISwapRouter\\n    function exactInputSingle(\\n        ExactInputSingleParameters calldata parameters\\n    ) external payable override checkDeadline(parameters.deadline) returns (uint256 amountOut) {\\n        amountOut = exactInputInternal(\\n            parameters.amountIn,\\n            parameters.recipient,\\n            parameters.priceLimitX96,\\n            SwapCallbackData({\\n                path: abi.encodePacked(parameters.tokenIn, uint8(0), parameters.resolution, parameters.tokenOut),\\n                payer: _msgSender()\\n            })\\n        );\\n        // SR_TLR: too little received\\n        require(amountOut >= parameters.amountOutMinimum, \\\"SR_TLR\\\");\\n    }\\n\\n    /// @inheritdoc ISwapRouter\\n    function exactInput(\\n        ExactInputParameters memory parameters\\n    ) external payable override checkDeadline(parameters.deadline) returns (uint256 amountOut) {\\n        // msg.sender pays for the first hop\\n        address payer = _msgSender();\\n\\n        while (true) {\\n            bool hasMultipleGrids = parameters.path.hasMultipleGrids();\\n\\n            // the output of the previous swap is used as the input of the subsequent swap.\\n            parameters.amountIn = exactInputInternal(\\n                parameters.amountIn,\\n                hasMultipleGrids ? address(this) : parameters.recipient, // this contract keep the token of intermediate swaps within the path\\n                0,\\n                SwapCallbackData({\\n                    path: parameters.path.getFirstGrid(), // only the first grid in the path is necessary\\n                    payer: payer\\n                })\\n            );\\n\\n            // decide whether to continue or terminate\\n            if (hasMultipleGrids) {\\n                // at this point, the caller has paid\\n                payer = address(this);\\n                parameters.path = parameters.path.skipToken();\\n            } else {\\n                amountOut = parameters.amountIn;\\n                break;\\n            }\\n        }\\n        // SR_TLR: too little received\\n        require(amountOut >= parameters.amountOutMinimum, \\\"SR_TLR\\\");\\n    }\\n\\n    /// @dev Performs a single exact output swap\\n    function exactOutputInternal(\\n        uint256 amountOut,\\n        address recipient,\\n        uint160 priceLimitX96,\\n        SwapCallbackData memory data\\n    ) private returns (uint256 amountIn) {\\n        // allow swapping to the router address with address 0\\n        recipient = recipient == address(0) ? address(this) : recipient;\\n\\n        (IGrid grid, bool zeroForOne) = _decodeGridForExactOutput(data);\\n\\n        (int256 amount0Delta, int256 amount1Delta) = grid.swap(\\n            recipient,\\n            zeroForOne,\\n            -amountOut.toInt256(),\\n            priceLimitX96 == 0 ? (zeroForOne ? BoundaryMath.MIN_RATIO : BoundaryMath.MAX_RATIO) : priceLimitX96,\\n            abi.encode(data)\\n        );\\n\\n        uint256 amountOutReceived;\\n        (amountIn, amountOutReceived) = zeroForOne\\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\\n            : (uint256(amount1Delta), uint256(-amount0Delta));\\n        // technically, it is possible to not receive all of the output amount,\\n        // so if PriceLimit is not specified, this possibility needs to be eliminated immediately\\n        if (priceLimitX96 == 0) require(amountOutReceived == amountOut, \\\"SR_IAOR\\\"); // SR_IAOR: invalid amount out received\\n    }\\n\\n    function _decodeGridForExactOutput(\\n        SwapCallbackData memory data\\n    ) private view returns (IGrid grid, bool zeroForOne) {\\n        (address tokenOut, address tokenIn, int24 resolution) = data.path.decodeFirstGrid();\\n        return (getGrid(tokenIn, tokenOut, resolution), tokenIn < tokenOut);\\n    }\\n\\n    /// @inheritdoc ISwapRouter\\n    function exactOutputSingle(\\n        ExactOutputSingleParameters calldata parameters\\n    ) external payable override checkDeadline(parameters.deadline) returns (uint256 amountIn) {\\n        // avoid an SLOAD by using the swap return data\\n        amountIn = exactOutputInternal(\\n            parameters.amountOut,\\n            parameters.recipient,\\n            parameters.priceLimitX96,\\n            SwapCallbackData({\\n                path: abi.encodePacked(parameters.tokenOut, uint8(0), parameters.resolution, parameters.tokenIn),\\n                payer: _msgSender()\\n            })\\n        );\\n\\n        // SR_TMR: too much requested\\n        require(amountIn <= parameters.amountInMaximum, \\\"SR_TMR\\\");\\n        // must be reset, despite remaining unused in the single hop case\\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    }\\n\\n    /// @inheritdoc ISwapRouter\\n    function exactOutput(\\n        ExactOutputParameters calldata parameters\\n    ) external payable override checkDeadline(parameters.deadline) returns (uint256 amountIn) {\\n        // the payer is fixed as _msgSender() here, this is a non-issue as they only pay for the \u201cfinal\u201d exactOutput\\n        // swap, which happens first, swaps that follow are paid within nested callbacks\\n        exactOutputInternal(\\n            parameters.amountOut,\\n            parameters.recipient,\\n            0,\\n            SwapCallbackData({path: parameters.path, payer: _msgSender()})\\n        );\\n\\n        amountIn = amountInCached;\\n        // SR_TMR: too much requested\\n        require(amountIn <= parameters.amountInMaximum, \\\"SR_TMR\\\");\\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/SwapRouterHub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity =0.8.9;\\npragma abicoder v2;\\n\\nimport \\\"./SwapRouter.sol\\\";\\nimport \\\"./UniswapV3Router.sol\\\";\\nimport \\\"./UniswapV2Router.sol\\\";\\nimport \\\"./libraries/SwapPath.sol\\\";\\nimport \\\"./libraries/Protocols.sol\\\";\\nimport \\\"./interfaces/ISwapRouterHub.sol\\\";\\nimport \\\"./CurveRouter.sol\\\";\\nimport \\\"./AbstractSelfPermit2612.sol\\\";\\n\\n/// @title Gridex, Curve, UniswapV2 and UniswapV3 Swap Router\\ncontract SwapRouterHub is\\n    SwapRouter,\\n    UniswapV3Router,\\n    UniswapV2Router,\\n    ISwapRouterHub,\\n    CurveRouter,\\n    AbstractSelfPermit2612\\n{\\n    using SwapPath for bytes;\\n\\n    constructor(\\n        address _gridexGridFactory,\\n        address _uniswapV3PoolFactory,\\n        address _uniswapV2PoolFactory,\\n        address _weth9\\n    )\\n        AbstractPayments(_gridexGridFactory, _weth9)\\n        UniswapV3Router(_uniswapV3PoolFactory)\\n        UniswapV2Router(_uniswapV2PoolFactory)\\n    {}\\n\\n    /// @inheritdoc ISwapRouterHub\\n    function exactMixedInput(\\n        ExactMixedInputParameters memory parameters\\n    ) public payable override checkDeadline(parameters.deadline) returns (uint256 amountOut) {\\n        // msg.sender pays for the first hop\\n        address payer = _msgSender();\\n        uint256 i = 0;\\n        while (true) {\\n            bool hasMultipleGrids = parameters.path.hasMultipleGrids();\\n            if (parameters.path.getProtocol() == Protocols.GRIDEX) {\\n                parameters.amountIn = exactInputInternal(\\n                    parameters.amountIn,\\n                    hasMultipleGrids ? address(this) : parameters.recipient, // this contract keep the token of intermediate swaps within the path\\n                    0,\\n                    SwapCallbackData({\\n                        path: parameters.path.getFirstGrid(), // only the first grid in the path is necessary\\n                        payer: payer\\n                    })\\n                );\\n            } else if (parameters.path.getProtocol() == Protocols.UNISWAPV3) {\\n                parameters.amountIn = uniswapV3ExactInputInternal(\\n                    parameters.amountIn,\\n                    hasMultipleGrids ? address(this) : parameters.recipient, // this contract keep the token of intermediate swaps within the path\\n                    0,\\n                    UniswapV3SwapCallbackData({\\n                        path: parameters.path.getFirstGrid(), // only the first grid in the path is necessary\\n                        payer: payer\\n                    })\\n                );\\n            } else if (parameters.path.getProtocol() == Protocols.UNISWAPV2) {\\n                parameters.amountIn = uniswapV2ExactInputInternal(\\n                    parameters.amountIn,\\n                    parameters.path,\\n                    payer,\\n                    hasMultipleGrids ? address(this) : parameters.recipient\\n                );\\n            } else {\\n                if (i == 0) pay(parameters.path.getTokenA(), payer, address(this), parameters.amountIn);\\n\\n                parameters.amountIn = curveExactInputInternal(\\n                    parameters.amountIn,\\n                    parameters.path,\\n                    parameters.path.getProtocol(),\\n                    hasMultipleGrids ? address(this) : parameters.recipient\\n                );\\n            }\\n\\n            // decide whether to continue or terminate\\n            if (hasMultipleGrids) {\\n                unchecked {\\n                    i++;\\n                }\\n                // at this point, the caller has paid\\n                payer = address(this);\\n                parameters.path = parameters.path.skipToken();\\n            } else {\\n                amountOut = parameters.amountIn;\\n                break;\\n            }\\n        }\\n        // SR_TLR: too little received\\n        require(amountOut >= parameters.amountOutMinimum, \\\"SR_TLR\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./AbstractPayments.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Router.sol\\\";\\nimport \\\"./libraries/UniswapV2Library.sol\\\";\\nimport \\\"./libraries/SwapPath.sol\\\";\\n\\n/// @title Uniswap V2 Swap Router\\n/// @notice A stateless execution router adapted for the Uniswap V2 protocol\\nabstract contract UniswapV2Router is IUniswapV2Router, AbstractPayments {\\n    using SwapPath for bytes;\\n    address public immutable uniswapV2PoolFactory;\\n\\n    constructor(address _uniswapV2PoolFactory) {\\n        uniswapV2PoolFactory = _uniswapV2PoolFactory;\\n    }\\n\\n    // supports fee-on-transfer tokens\\n    // requires the initial amount to have already been sent to the first pair\\n    function _swap(address[] memory path, address _to) private {\\n        unchecked {\\n            for (uint256 i; i < path.length - 1; i++) {\\n                (address input, address output) = (path[i], path[i + 1]);\\n                address to = i < path.length - 2\\n                    ? UniswapV2Library.pairFor(uniswapV2PoolFactory, output, path[i + 2])\\n                    : _to;\\n                _swapOnce(input, output, to);\\n            }\\n        }\\n    }\\n\\n    function _swapOnce(address input, address output, address recipient) private {\\n        (address token0, ) = UniswapV2Library.sortTokens(input, output);\\n        IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(uniswapV2PoolFactory, input, output));\\n        uint256 amountInput;\\n        uint256 amountOutput;\\n        // scope to avoid stack too deep errors\\n        {\\n            (uint256 reserve0, uint256 reserve1, ) = pair.getReserves();\\n            (uint256 reserveInput, uint256 reserveOutput) = input == token0\\n                ? (reserve0, reserve1)\\n                : (reserve1, reserve0);\\n            amountInput = IERC20(input).balanceOf(address(pair)) - reserveInput;\\n            amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);\\n        }\\n        (uint256 amount0Out, uint256 amount1Out) = input == token0\\n            ? (uint256(0), amountOutput)\\n            : (amountOutput, uint256(0));\\n\\n        pair.swap(amount0Out, amount1Out, recipient, new bytes(0));\\n    }\\n\\n    function uniswapV2ExactInputInternal(\\n        uint256 amountIn,\\n        bytes memory path,\\n        address payer,\\n        address recipient\\n    ) internal returns (uint256 amountOut) {\\n        (address input, address output, ) = path.decodeFirstGrid();\\n        pay(input, payer, UniswapV2Library.pairFor(uniswapV2PoolFactory, input, output), amountIn);\\n        uint256 balanceBefore = IERC20(output).balanceOf(recipient);\\n        _swapOnce(input, output, recipient);\\n        amountOut = IERC20(output).balanceOf(recipient) - balanceBefore;\\n    }\\n\\n    /// @inheritdoc IUniswapV2Router\\n    function uniswapV2ExactInput(\\n        uint256 amountIn,\\n        uint256 amountOutMinimum,\\n        address[] calldata path,\\n        address to\\n    ) external payable override returns (uint256 amountOut) {\\n        pay(path[0], _msgSender(), UniswapV2Library.pairFor(uniswapV2PoolFactory, path[0], path[1]), amountIn);\\n\\n        // allows swapping to the router address with address 0\\n        to = to == address(0) ? address(this) : to;\\n\\n        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\\n\\n        _swap(path, to);\\n\\n        amountOut = IERC20(path[path.length - 1]).balanceOf(to) - balanceBefore;\\n        // UV2R_TLR: too little received\\n        require(amountOut >= amountOutMinimum, \\\"UV2R_TLR\\\");\\n    }\\n\\n    /// @inheritdoc IUniswapV2Router\\n    function uniswapV2ExactOutput(\\n        uint256 amountOut,\\n        uint256 amountInMaximum,\\n        address[] calldata path,\\n        address to\\n    ) external payable override returns (uint256 amountIn) {\\n        amountIn = UniswapV2Library.getAmountsIn(uniswapV2PoolFactory, amountOut, path)[0];\\n        // UV2R_TMR: Too much requested\\n        require(amountIn <= amountInMaximum, \\\"UV2R_TMR\\\");\\n\\n        pay(path[0], _msgSender(), UniswapV2Library.pairFor(uniswapV2PoolFactory, path[0], path[1]), amountIn);\\n\\n        // allows swapping to the router address with address 0\\n        to = to == address(0) ? address(this) : to;\\n\\n        _swap(path, to);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/UniswapV3Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\npragma abicoder v2;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"./AbstractPayments.sol\\\";\\nimport \\\"./interfaces/IUniswapV3Router.sol\\\";\\nimport \\\"./interfaces/IUniswapV3PoolMinimum.sol\\\";\\nimport \\\"./libraries/SwapPath.sol\\\";\\nimport \\\"./libraries/UniswapV3PoolAddress.sol\\\";\\nimport \\\"./libraries/UniswapV3CallbackValidator.sol\\\";\\nimport \\\"./libraries/Ratio.sol\\\";\\n\\n/// @title Uniswap V3 Swap Router\\n/// @notice A stateless execution router adapted for the Uniswap V3 protocol\\nabstract contract UniswapV3Router is IUniswapV3Router, AbstractPayments {\\n    using SwapPath for bytes;\\n    using SafeCast for uint256;\\n\\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\\n\\n    uint256 private amountInCached;\\n\\n    address public immutable uniswapV3PoolFactory;\\n\\n    constructor(address _uniswapV3PoolFactory) {\\n        uniswapV3PoolFactory = _uniswapV3PoolFactory;\\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    }\\n\\n    /// @dev Returns the pool for the given token pair and fee. The pool contract may or may not exist.\\n    function getUniswapV3Pool(address tokenA, address tokenB, int24 fee) private view returns (IUniswapV3PoolMinimum) {\\n        return\\n            IUniswapV3PoolMinimum(\\n                UniswapV3PoolAddress.computeAddress(\\n                    uniswapV3PoolFactory,\\n                    UniswapV3PoolAddress.poolKey(tokenA, tokenB, uint24(fee))\\n                )\\n            );\\n    }\\n\\n    struct UniswapV3SwapCallbackData {\\n        bytes path;\\n        address payer;\\n    }\\n\\n    /// @inheritdoc IUniswapV3Router\\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata _data) external override {\\n        // swaps which are entirely contained within zero liquidity regions are not supported\\n        require(amount0Delta > 0 || amount1Delta > 0);\\n        UniswapV3SwapCallbackData memory data = abi.decode(_data, (UniswapV3SwapCallbackData));\\n        (address tokenIn, address tokenOut, int24 fee) = data.path.decodeFirstGrid();\\n        UniswapV3CallbackValidator.validate(uniswapV3PoolFactory, tokenIn, tokenOut, uint24(fee));\\n\\n        (bool isExactInput, uint256 amountToPay) = amount0Delta > 0\\n            ? (tokenIn < tokenOut, uint256(amount0Delta))\\n            : (tokenOut < tokenIn, uint256(amount1Delta));\\n\\n        if (isExactInput) pay(tokenIn, data.payer, _msgSender(), amountToPay);\\n        else {\\n            // either initiate the next swap or pay\\n            if (data.path.hasMultipleGrids()) {\\n                data.path = data.path.skipToken();\\n                uniswapV3ExactOutputInternal(amountToPay, _msgSender(), 0, data);\\n            } else {\\n                amountInCached = amountToPay;\\n                // note that tokenOut is actually tokenIn because exactOutput swaps are executed in reverse order\\n                pay(tokenOut, data.payer, _msgSender(), amountToPay);\\n            }\\n        }\\n    }\\n\\n    /// @dev Performs a single exact input swap\\n    function uniswapV3ExactInputInternal(\\n        uint256 amountIn,\\n        address recipient,\\n        uint160 sqrtPriceLimitX96,\\n        UniswapV3SwapCallbackData memory data\\n    ) internal returns (uint256 amountOut) {\\n        // allow swapping to the router address with address 0\\n        recipient = recipient == address(0) ? address(this) : recipient;\\n\\n        (address tokenIn, address tokenOut, int24 fee) = data.path.decodeFirstGrid();\\n\\n        bool zeroForOne = tokenIn < tokenOut;\\n\\n        (int256 amount0, int256 amount1) = getUniswapV3Pool(tokenIn, tokenOut, fee).swap(\\n            recipient,\\n            zeroForOne,\\n            amountIn.toInt256(),\\n            sqrtPriceLimitX96 == 0\\n                ? (zeroForOne ? Ratio.MIN_SQRT_RATIO_PLUS_ONE : Ratio.MAX_SQRT_RATIO_MINUS_ONE)\\n                : sqrtPriceLimitX96,\\n            abi.encode(data)\\n        );\\n\\n        return uint256(-(zeroForOne ? amount1 : amount0));\\n    }\\n\\n    /// @inheritdoc IUniswapV3Router\\n    function uniswapV3ExactInputSingle(\\n        UniswapV3ExactInputSingleParameters calldata parameters\\n    ) external payable override checkDeadline(parameters.deadline) returns (uint256 amountOut) {\\n        amountOut = uniswapV3ExactInputInternal(\\n            parameters.amountIn,\\n            parameters.recipient,\\n            parameters.sqrtPriceLimitX96,\\n            UniswapV3SwapCallbackData({\\n                path: abi.encodePacked(parameters.tokenIn, uint8(0), parameters.fee, parameters.tokenOut),\\n                payer: _msgSender()\\n            })\\n        );\\n        // UV3R_TLR: too little received\\n        require(amountOut >= parameters.amountOutMinimum, \\\"UV3R_TLR\\\");\\n    }\\n\\n    /// @inheritdoc IUniswapV3Router\\n    function uniswapV3ExactInput(\\n        UniswapV3ExactInputParameters memory parameters\\n    ) external payable override checkDeadline(parameters.deadline) returns (uint256 amountOut) {\\n        // the first hop is paid for by msg.sender\\n        address payer = _msgSender();\\n\\n        while (true) {\\n            bool hasMultipleGrids = parameters.path.hasMultipleGrids();\\n\\n            // the output of the previous swap is used as the input of the subsequent swap\\n            parameters.amountIn = uniswapV3ExactInputInternal(\\n                parameters.amountIn,\\n                hasMultipleGrids ? address(this) : parameters.recipient, // this contract keep the token of intermediate swaps within the path\\n                0,\\n                UniswapV3SwapCallbackData({\\n                    path: parameters.path.getFirstGrid(), // only the first pool in the path is necessary\\n                    payer: payer\\n                })\\n            );\\n\\n            // decide whether to continue or terminate\\n            if (hasMultipleGrids) {\\n                // at this point, the caller has paid\\n                payer = address(this);\\n                parameters.path = parameters.path.skipToken();\\n            } else {\\n                amountOut = parameters.amountIn;\\n                break;\\n            }\\n        }\\n        // UV3R_TLR: too little received\\n        require(amountOut >= parameters.amountOutMinimum, \\\"UV3R_TLR\\\");\\n    }\\n\\n    /// @dev Performs a single exact output swap\\n    function uniswapV3ExactOutputInternal(\\n        uint256 amountOut,\\n        address recipient,\\n        uint160 sqrtPriceLimitX96,\\n        UniswapV3SwapCallbackData memory data\\n    ) internal returns (uint256 amountIn) {\\n        // allow swapping to the router address with address 0\\n        recipient = recipient == address(0) ? address(this) : recipient;\\n\\n        (address tokenOut, address tokenIn, int24 fee) = data.path.decodeFirstGrid();\\n\\n        bool zeroForOne = tokenIn < tokenOut;\\n\\n        (int256 amount0Delta, int256 amount1Delta) = getUniswapV3Pool(tokenIn, tokenOut, fee).swap(\\n            recipient,\\n            zeroForOne,\\n            -amountOut.toInt256(),\\n            sqrtPriceLimitX96 == 0\\n                ? (zeroForOne ? Ratio.MIN_SQRT_RATIO_PLUS_ONE : Ratio.MAX_SQRT_RATIO_MINUS_ONE)\\n                : sqrtPriceLimitX96,\\n            abi.encode(data)\\n        );\\n\\n        uint256 amountOutReceived;\\n        (amountIn, amountOutReceived) = zeroForOne\\n            ? (uint256(amount0Delta), uint256(-amount1Delta))\\n            : (uint256(amount1Delta), uint256(-amount0Delta));\\n        // technically, it is possible to not receive all of the output amount,\\n        // so if PriceLimit is not specified, this possibility needs to be eliminated immediately\\n        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut, \\\"UV3R_IAOR\\\"); // UV3R_IAOR: invalid amount out received\\n    }\\n\\n    /// @inheritdoc IUniswapV3Router\\n    function uniswapV3ExactOutputSingle(\\n        UniswapV3ExactOutputSingleParameters calldata parameters\\n    ) external payable override checkDeadline(parameters.deadline) returns (uint256 amountIn) {\\n        // avoid an SLOAD by using the swap return data\\n        amountIn = uniswapV3ExactOutputInternal(\\n            parameters.amountOut,\\n            parameters.recipient,\\n            parameters.sqrtPriceLimitX96,\\n            UniswapV3SwapCallbackData({\\n                path: abi.encodePacked(parameters.tokenOut, uint8(0), parameters.fee, parameters.tokenIn),\\n                payer: _msgSender()\\n            })\\n        );\\n\\n        // UV3R_TMR: too much requested\\n        require(amountIn <= parameters.amountInMaximum, \\\"UV3R_TMR\\\");\\n        // must be reset, despite remaining unused in the single hop case\\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    }\\n\\n    /// @inheritdoc IUniswapV3Router\\n    function uniswapV3ExactOutput(\\n        UniswapV3ExactOutputParameters calldata parameters\\n    ) external payable override checkDeadline(parameters.deadline) returns (uint256 amountIn) {\\n        uniswapV3ExactOutputInternal(\\n            parameters.amountOut,\\n            parameters.recipient,\\n            0,\\n            UniswapV3SwapCallbackData({path: parameters.path, payer: _msgSender()})\\n        );\\n\\n        amountIn = amountInCached;\\n        // UV3R_TMR: too much requested\\n        require(amountIn <= parameters.amountInMaximum, \\\"UV3R_TMR\\\");\\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gridexGridFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapV3PoolFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_uniswapV2PoolFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_weth9\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"}],\"name\":\"approveToCurvePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapRouter.ExactInputParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"exactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"resolution\",\"type\":\"int24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"priceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct ISwapRouter.ExactInputSingleParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"exactInputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapRouterHub.ExactMixedInputParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"exactMixedInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"}],\"internalType\":\"struct ISwapRouter.ExactOutputParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"exactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"resolution\",\"type\":\"int24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"priceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct ISwapRouter.ExactOutputSingleParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"exactOutputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gridFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"gridexSwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"refundNativeToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitCompatible\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expiry\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitCompatibleIfNecessary\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"selfPermitIfNecessary\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"uniswapV2ExactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"uniswapV2ExactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV2PoolFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3Router.UniswapV3ExactInputParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"uniswapV3ExactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOutMinimum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IUniswapV3Router.UniswapV3ExactInputSingleParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"uniswapV3ExactInputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"}],\"internalType\":\"struct IUniswapV3Router.UniswapV3ExactOutputParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"uniswapV3ExactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amountInMaximum\",\"type\":\"uint256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IUniswapV3Router.UniswapV3ExactOutputSingleParameters\",\"name\":\"parameters\",\"type\":\"tuple\"}],\"name\":\"uniswapV3ExactOutputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"uniswapV3PoolFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountMinimum\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"unwrapWETH9\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth9\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "SwapRouterHub", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "00000000000000000000000032d1f0dce675902f89d72251db4ab1d728efa19c0000000000000000000000001f98431c8ad98523631ae4a59f267346ea31f9840000000000000000000000005c69bee701ef814a2b6a3edd4b1652cb9cc5aa6f0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}