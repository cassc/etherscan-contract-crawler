{"SourceCode": "/*\r\n\r\nFFFFF  TTTTTTT  M   M         GGGGG  U    U  RRRRR     U    U\r\nFF       TTT   M M M M       G       U    U  RR   R    U    U\r\nFFFFF    TTT   M  M  M      G  GGG   U    U  RRRRR     U    U\r\nFF       TTT   M  M  M   O  G    G   U    U  RR R      U    U\r\nFF       TTT   M     M       GGGGG    UUUU   RR  RRR    UUUU\r\n\r\n\r\n\r\n\t\t\t\t\t\tContact us at:\r\n\t\t\thttps://discord.com/invite/QpyfMarNrV\r\n\t\t\t\t\thttps://t.me/FTM1337\r\n\r\n\tCommunity Mediums:\r\n\t\thttps://medium.com/@ftm1337\r\n\t\thttps://twitter.com/ftm1337\r\n\r\n\tSPDX-License-Identifier: UNLICENSED\r\n\r\n\r\n\telToken_Depositor.sol\r\n\r\n\telToken is a Liquid Staking Derivate for veTokens (Vote-Escrowed NFT).\r\n\tIt can be minted by merging a user's veNFT into the Protocol's veNFT.\r\n\telTokens are ERC20 based tokens.\r\n\tIt can be staked with Guru Network to earn pure Real Yield,\r\n\tpaid in a single prominent token such as ETH or BNB instead of multiple small tokens.\r\n\telTokens can be further deposited into other De-Fi Protocols for even more utilities!\r\n\r\n\tThe price (in Base Token) to mint an elToken goes up every epoch due to positive rebasing.\r\n\tThis property gives elTokens a \"hyper-compounding\" exponential trajectory against base tokens,\r\n\tand it helps elTokens have a true inflation-resistant future!\r\n\r\n*/\r\n\r\npragma solidity 0.8.9;\r\n\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n\tfunction transfer(address recipient, uint amount) external returns (bool);\r\n\tfunction balanceOf(address) external view returns (uint);\r\n\tfunction transferFrom(address sender, address recipient, uint amount) external returns (bool);\r\n}\r\ninterface IelToken is IERC20 {\r\n\tfunction mint(uint a, address w) external returns (bool);\r\n}\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\ninterface IVotingEscrow {\r\n\tstruct LockedBalance {\r\n\t\tint128 amount;\r\n\t\tuint end;\r\n\t}\r\n\tfunction create_lock_for(uint _value, uint _lock_duration, address _to) external returns (uint);\r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n    function locked(uint id) external view returns(LockedBalance memory);\r\n\tfunction token() external view returns (address);\r\n\tfunction merge(uint _from, uint _to) external;\r\n}\r\n\r\ncontract elToken_Depositor {\r\n\tstruct LockedBalance {\r\n\t\tint128 amount;\r\n\t\tuint end;\r\n\t}\r\n\taddress public dao;\r\n\tIelToken public elToken;\r\n\tIVotingEscrow public veToken;\r\n\tuint public ID;\r\n\tuint public supplied;\r\n\tuint public converted;\r\n\tuint public minted;\r\n\t/// @notice ftm.guru simple re-entrancy check\r\n\tbool internal _locked;\r\n\tmodifier lock() {\r\n\t\trequire(!_locked,  \"Re-entry!\");\r\n\t\t_locked = true;\r\n\t\t_;\r\n\t\t_locked = false;\r\n\t}\r\n\tmodifier DAO() {\r\n\t\trequire(msg.sender==dao, \"Unauthorized!\");\r\n\t\t_;\r\n\t}\r\n\tevent Deposit(address indexed, uint indexed, uint, uint, uint);\r\n    function onERC721Received(address, address,  uint256, bytes calldata) external view returns (bytes4) {\r\n        require(msg.sender == address(veToken), \"!veToken\");\r\n        return bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n    }\r\n\tfunction deposit(uint _id) public lock returns (uint) {\r\n\t\tuint _ts = elToken.totalSupply();\r\n\t\tIVotingEscrow.LockedBalance memory _main = veToken.locked(ID);\r\n\t\trequire(_main.amount > 0, \"Dirty veNFT!\");\r\n\t\tint _ibase = _main.amount;\t//pre-cast to int\r\n\t\tuint256 _base = uint256(_ibase);\r\n\t\tveToken.safeTransferFrom(msg.sender, address(this), _id);\t//important (bug)fix!\r\n\t\tveToken.merge(_id,ID);\r\n\t\tIVotingEscrow.LockedBalance memory _merged = veToken.locked(ID);\r\n\t\tint _in = _merged.amount - _main.amount;\r\n\t\trequire(_in > 0, \"Dirty Deposit!\");\r\n\t\tuint256 _inc = uint256(_in);//cast to uint\r\n\t\tsupplied += _inc;\r\n\t\tconverted++;\r\n\t\t// If no elToken exists, mint it 1:1 to the amount of Base Token present inside the veNFT deposited\r\n\t\tif (_ts == 0 || _base == 0) {\r\n\t\t\telToken.mint(_inc, msg.sender);\r\n\t\t\temit Deposit(msg.sender, _id, _inc, _inc, block.timestamp);\r\n\t\t\tminted+=_inc;\r\n\t\t\treturn _inc;\r\n\t\t}\r\n\t\t// Calculate and mint the amount of elToken the veNFT is worth. The ratio will change overtime,\r\n\t\t// as elToken is minted when veToken are deposited + gained from rebases\r\n\t\telse {\r\n\t\t\tuint256 _amt = (_inc * _ts) / _base;\r\n\t\t\telToken.mint(_amt, msg.sender);\r\n\t\t\temit Deposit(msg.sender, _id, _inc, _amt, block.timestamp);\r\n\t\t\tminted+=_amt;\r\n\t\t\treturn _amt;\r\n\t\t}\r\n\t}\r\n\tfunction initialize(uint _id) public DAO lock {\r\n\t\tIVotingEscrow.LockedBalance memory _main = veToken.locked(_id);\r\n\t\trequire(_main.amount > 0, \"Dirty veNFT!\");\r\n\t\tint _iamt = _main.amount;\r\n\t\tuint _amt = uint(_iamt);\r\n\t\telToken.mint(_amt, msg.sender);\r\n\t\tID = _id;\r\n\t\tsupplied += _amt;\r\n\t\tconverted++;\r\n\t\tminted+=_amt;\r\n\t}\r\n\tfunction quote(uint _id) public view returns (uint) {\r\n\t\tuint _ts = elToken.totalSupply();\r\n\t\tIVotingEscrow.LockedBalance memory _main = veToken.locked(ID);\r\n\t\tIVotingEscrow.LockedBalance memory _user = veToken.locked(_id);\r\n\t\tif( ! (_main.amount > 0) ) {return 0;}\r\n\t\tint _ibase = _main.amount;\t//pre-cast to int\r\n\t\tuint256 _base = uint256(_ibase);\r\n\t\tint _in = _user.amount;\r\n\t\tif( ! (_in > 0) ) {return 0;}\r\n\t\tuint256 _inc = uint256(_in);//cast to uint\r\n\t\t// If no elToken exists, mint it 1:1 to the amount of Base Token present inside the veNFT deposited\r\n\t\tif (_ts == 0 || _base == 0) {\r\n\t\t\treturn _inc;\r\n\t\t}\r\n\t\t// Calculate and mint the amount of elToken the veNFT is worth. The ratio will change overtime,\r\n\t\t// as elToken is minted when veToken are deposited + gained from rebases\r\n\t\telse {\r\n\t\t\tuint256 _amt = (_inc * _ts) / _base;\r\n\t\t\treturn _amt;\r\n\t\t}\r\n\t}\r\n\tfunction rawQuote(uint _inc) public view returns (uint) {\r\n\t\tuint _ts = elToken.totalSupply();\r\n\t\tIVotingEscrow.LockedBalance memory _main = veToken.locked(ID);\r\n\t\tif( ! (_main.amount > 0) ) {return 0;}\r\n\t\tint _ibase = _main.amount;\t//pre-cast to int\r\n\t\tuint256 _base = uint256(_ibase);\r\n\t\t// If no elToken exists, mint it 1:1 to the amount of Base Token present inside the veNFT deposited\r\n\t\tif (_ts == 0 || _base == 0) {\r\n\t\t\treturn _inc;\r\n\t\t}\r\n\t\t// Calculate and mint the amount of elToken the veNFT is worth. The ratio will change overtime,\r\n\t\t// as elToken is minted when veToken are deposited + gained from rebases\r\n\t\telse {\r\n\t\t\tuint256 _amt = (_inc * _ts) / _base;\r\n\t\t\treturn _amt;\r\n\t\t}\r\n\t}\r\n\tfunction price() public view returns (uint) {\r\n\t\treturn 1e36 / rawQuote(1e18);\r\n\t}\r\n\tfunction setDAO(address d) public DAO {\r\n\t\tdao = d;\r\n\t}\r\n\tfunction setID(uint _id) public DAO {\r\n\t\tID = _id;\r\n\t}\r\n\tfunction rescue(address _t, uint _a) public DAO lock {\r\n\t\tIERC20 _tk = IERC20(_t);\r\n\t\t_tk.transfer(dao, _a);\r\n\t}\r\n\tconstructor(address ve, address e) {\r\n\t\tdao=msg.sender;\r\n\t\tveToken = IVotingEscrow(ve);\r\n\t\telToken = IelToken(e);\r\n\t}\r\n}\r\n\r\n/*\r\n\tCommunity, Services & Enquiries:\r\n\t\thttps://discord.gg/QpyfMarNrV\r\n\r\n\tPowered by Guru Network DAO ( \ud83e\uddbe , \ud83d\ude80 )\r\n\t\tSimplicity is the ultimate sophistication.\r\n*/", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ve\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"e\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dao\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"elToken\",\"outputs\":[{\"internalType\":\"contract IelToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_inc\",\"type\":\"uint256\"}],\"name\":\"rawQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_t\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_a\",\"type\":\"uint256\"}],\"name\":\"rescue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"d\",\"type\":\"address\"}],\"name\":\"setDAO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"setID\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"supplied\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"veToken\",\"outputs\":[{\"internalType\":\"contract IVotingEscrow\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "elToken_Depositor", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000b419ce2ea99f356bae0cac47282b9409e38200fa000000000000000000000000fab311fe3e3be4bb3fed77257ee294fb22fa888b", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://8a85922d8530bff60ab74a228b2d876dfc4d234836c41e278737c9e3e128e782"}