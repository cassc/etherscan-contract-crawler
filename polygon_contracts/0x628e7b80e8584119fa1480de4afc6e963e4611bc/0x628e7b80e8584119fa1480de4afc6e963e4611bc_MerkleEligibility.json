{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity 0.8.12;\r\n\r\n/// @title Interface for eligibility gates, this specifies address-specific requirements for being eligible\r\n/// @notice Anything resembling a whitelist for minting should use an eligibility gate\r\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\r\n/// @dev There are a couple of functions I wanted to add here but they just don't have uniform enough structure\r\ninterface IEligibility {\r\n\r\n//    function getGate(uint) external view returns (struct Gate)\r\n//    function addGate(uint...) external\r\n\r\n    /// @notice Is the given user eligible? Concerns the address, not whether or not they have the funds\r\n    /// @dev The bytes32[] argument is for merkle proofs of eligibility\r\n    /// @return eligible true if the user can mint\r\n    function isEligible(uint, address, bytes32[] calldata) external view returns (bool eligible);\r\n\r\n    /// @notice This function is called by MerkleIdentity to make any state updates like counters\r\n    /// @dev This function should typically call isEligible, since MerkleIdentity does not\r\n    function passThruGate(uint, address, bytes32[] calldata) external;\r\n}\r\n\r\nlibrary MerkleLib {\r\n\r\n    function verifyProof(bytes32 root, bytes32 leaf, bytes32[] calldata proof) public pure returns (bool) {\r\n        bytes32 currentHash = leaf;\r\n\r\n        uint proofLength = proof.length;\r\n        for (uint i; i < proofLength;) {\r\n            currentHash = parentHash(currentHash, proof[i]);\r\n            unchecked { ++i; }\r\n        }\r\n\r\n        return currentHash == root;\r\n    }\r\n\r\n    function parentHash(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return keccak256(a < b ? abi.encode(a, b) : abi.encode(b, a));\r\n    }\r\n\r\n}\r\n\r\n/// @title This is an eligibility gate based on merkle trees, basically a scaled up whitelist\r\n/// @author metapriest, adrian.wachel, marek.babiarz, radoslaw.gorecki\r\n/// @notice This gate also allows max withdrawals per address and max withdrawals total\r\n/// @dev Anyone can add a gate, but it doesn't effect anything if it's not connected to a tree in MerkleIdentity\r\ncontract MerkleEligibility is IEligibility {\r\n    using MerkleLib for bytes32;\r\n\r\n    // the address of the MerkleIdentity contract\r\n    address public immutable gateMaster;\r\n\r\n    // This represents a single gate or whitelist\r\n    struct Gate {\r\n        bytes32 root;  // merkle root of whitelist\r\n        uint maxWithdrawalsAddress; // maximum amount of withdrawals per address\r\n        uint maxWithdrawalsTotal;  // maximum total withdrawals allowed, summed across all addresses\r\n        uint totalWithdrawals;  // number of withdrawals already made\r\n    }\r\n\r\n    // array-like mapping of gate structs\r\n    mapping (uint => Gate) public gates;\r\n    // count withdrawals per address timesWithdrawn[gateIndex][user] = count\r\n    mapping(uint => mapping(address => uint)) public timesWithdrawn;\r\n    // count the gates\r\n    uint public numGates;\r\n\r\n    error GateMasterOnly(address notGateMaster);\r\n    error IneligibleRecipient(address recipient);\r\n\r\n    /// @notice Deployer connects it to MerkleIdentity\r\n    /// @param _gateMaster address of MerkleIdentity contract, which has exclusive right to call passThruGate\r\n    constructor(address _gateMaster) {\r\n        gateMaster = _gateMaster;\r\n    }\r\n\r\n    /// @notice Add an gate, or set of eligibility criteria\r\n    /// @dev Anyone may call this, but without connecting it to MerkleIdentity (which only management can do) nothing happens\r\n    /// @param merkleRoot this is the root of the merkle tree with addresses as the leaf data\r\n    /// @param maxWithdrawalsAddress the maximum mints allowed per address by this gate\r\n    /// @param maxWithdrawalsTotal the maximum mints allowed across all addresses\r\n    /// @return index the index of the gate added\r\n    function addGate(bytes32 merkleRoot, uint maxWithdrawalsAddress, uint maxWithdrawalsTotal) external returns (uint) {\r\n        // increment the number of roots\r\n        numGates += 1;\r\n\r\n        gates[numGates] = Gate(merkleRoot, maxWithdrawalsAddress, maxWithdrawalsTotal, 0);\r\n        return numGates;\r\n    }\r\n\r\n    /// @notice Get the fields of a particular gate\r\n    /// @param index the index into the gates mapping, which gate are you talking about?\r\n    /// @return root the merkle root for this gate\r\n    /// @return maxWithdrawalsAddress the maximum withdrawals allowed per address\r\n    /// @return maxWithdrawalsTotal the maximum number of withdrawals across all addresses\r\n    /// @return totalWithdrawals the number of withdrawals already made thru this gate\r\n    function getGate(uint index) external view returns (bytes32, uint, uint, uint) {\r\n        Gate storage gate = gates[index];\r\n        return (gate.root, gate.maxWithdrawalsAddress, gate.maxWithdrawalsTotal, gate.totalWithdrawals);\r\n    }\r\n\r\n    /// @notice Find out if a given address may pass thru the gate\r\n    /// @dev Note this is called by passThruGate and represents enforcement of the eligibility criteria\r\n    /// @param index which gate are we talking about?\r\n    /// @param recipient the address that wishes to pass thru the gate\r\n    /// @param proof the array of hashes connecting the leaf data to the merkle root\r\n    /// @return eligible true if recipient may pass thru gate\r\n    function isEligible(uint index, address recipient, bytes32[] calldata proof) public override view returns (bool) {\r\n        Gate storage gate = gates[index];\r\n        // We need to pack the 20 bytes address to the 32 bytes value, so we call abi.encode\r\n        bytes32 leaf = keccak256(abi.encode(recipient));\r\n        // Check the per-address count first\r\n        bool countValid = timesWithdrawn[index][recipient] < gate.maxWithdrawalsAddress;\r\n        // Then check global count and merkle proof\r\n        return countValid && gate.totalWithdrawals < gate.maxWithdrawalsTotal && gate.root.verifyProof(leaf, proof);\r\n    }\r\n\r\n    /// @notice Pass thru the gate, incrementing the counters\r\n    /// @dev This should only be called by the gatemaster, which should be MerkleIdentity\r\n    /// @param index which gate are we passing thru?\r\n    /// @param recipient who is passing thru it?\r\n    /// @param proof merkle proof of whitelist inclusion\r\n    function passThruGate(uint index, address recipient, bytes32[] calldata proof) external override {\r\n        if (msg.sender != gateMaster) {\r\n            revert GateMasterOnly(msg.sender);\r\n        }\r\n\r\n        // close re-entrance gate, prevent double withdrawals\r\n        if (isEligible(index, recipient, proof) == false) {\r\n            revert IneligibleRecipient(recipient);\r\n        }\r\n\r\n        timesWithdrawn[index][recipient] += 1;\r\n        Gate storage gate = gates[index];\r\n        gate.totalWithdrawals += 1;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_gateMaster\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"notGateMaster\",\"type\":\"address\"}],\"name\":\"GateMasterOnly\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"IneligibleRecipient\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawalsAddress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawalsTotal\",\"type\":\"uint256\"}],\"name\":\"addGate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gateMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gates\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawalsAddress\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxWithdrawalsTotal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getGate\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"isEligible\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numGates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"passThruGate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"timesWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MerkleEligibility", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fc90786321e65b1fc3a790d30f6c3ef98c715390", "EVMVersion": "Default", "Library": "MerkleLib:2f59751cbea9f98fcbc2dcbf7ec0567a813ade92", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://60f8309de033e0d59bf2324440c677f1e969a4ebadae51294f8d765eb171477f"}