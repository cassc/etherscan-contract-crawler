{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SnowApeContractV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.1;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\ncontract SnowApeContractV3 is Ownable {\\n    uint16[] public LEAGUE_NONCES; // nonce for leagues\\n    uint256[] public FLAT_LEAGUE_FEES; // additional flat fee for leagues, otherwise time-based\\n    uint256[] public LEAGUE_FEES; // base fee to join leagues\\n\\n    uint8 public LATE_FEE_DIVISOR = 5; // (100 / LATE_FEE_DIVISOR) = the late fee percentage added per-day\\n\\n    address private payoutAddress;\\n\\n    mapping(uint16 => mapping(uint16 => uint32)) public LEAGUE_PLAYER_COUNTS;\\n    mapping(uint16 => mapping(uint16 => uint256)) public LEAGUE_TOTAL_FEES;\\n    mapping(uint16 => mapping(uint16 => mapping(address => uint16)))\\n        public portfolioCounts;\\n    mapping(uint16 => uint256) public lastLeagueStartDates;\\n\\n    constructor(uint16[] memory nonces, uint256[] memory fees, uint256[] memory flatFees) {\\n        LEAGUE_NONCES = nonces;\\n        LEAGUE_FEES = fees;\\n        FLAT_LEAGUE_FEES = flatFees;\\n    }\\n\\n    /**\\n     * Gets the current seconds since 1970 in east coast time\\n     * @return seconds\\n     */\\n    function getEastCoastSeconds() private view returns (uint256) {\\n        return block.timestamp - 14400;\\n    }\\n\\n    /**\\n     * Calculates the fee based on the number of days that have occured since the league was started\\n     * @param leagueId the league on which to calculate the fee\\n     * @return fee\\n     */\\n    function getFee(uint16 leagueId) public view returns (uint256) {\\n        if (FLAT_LEAGUE_FEES[leagueId] != 0) {\\n            return LEAGUE_FEES[leagueId] + FLAT_LEAGUE_FEES[leagueId];\\n        }\\n\\n        uint256 day = getEastCoastSeconds() / 86400;\\n        uint256 leagueFee = LEAGUE_FEES[leagueId];\\n        uint256 leagueStartDay = lastLeagueStartDates[leagueId];\\n\\n        if ((leagueStartDay == 0) || day <= (leagueStartDay + 2)) {\\n            // first league or still the weekend, do not charge a late fee\\n            return leagueFee;\\n        }\\n\\n        uint256 daysSinceStartMultiplier = day - 2 - leagueStartDay;\\n        uint256 lateFee = (leagueFee / LATE_FEE_DIVISOR) *\\n            daysSinceStartMultiplier;\\n        return leagueFee + lateFee;\\n    }\\n\\n    /**\\n        Returns current nonce for a league\\n        * @return nonce\\n     */\\n    function getNonce(uint16 leagueId) public view returns (uint16) {\\n        return LEAGUE_NONCES[leagueId];\\n    }\\n\\n    /**\\n        Returns current nonces for all leagues\\n        * @return nonce\\n     */\\n    function getNonces() public view returns (uint16[] memory) {\\n        return LEAGUE_NONCES;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of the smart contract.\\n     * @return currentBalance\\n     */\\n    function getBalance() public view returns (uint256) {\\n        return address(this).balance;\\n    }\\n\\n    /**\\n     * @dev Gets the balance of an address.\\n     * @return currentBalance\\n     */\\n    function balanceOf(address adr) public view returns (uint256) {\\n        return address(adr).balance;\\n    }\\n\\n    /**\\n     * @dev Gets the number of portfolios an address is entitled to.\\n     * @param player the address of the player\\n     * @param leagueId the id of the league\\n     * @return portfolioSize\\n     */\\n    function getPortfolioSize(address player, uint16 leagueId)\\n        public\\n        view\\n        returns (uint16, uint16)\\n    {\\n        uint16 leagueNonce = LEAGUE_NONCES[leagueId];\\n        return (portfolioCounts[leagueId][leagueNonce][player], leagueNonce);\\n    }\\n\\n    /**\\n     * Sets payout address of contract\\n     * @param adr the address to send funds to on payouts\\n     */\\n    function setPayoutAddress(address adr) public onlyOwner {\\n        payoutAddress = adr;\\n    }\\n\\n    /**\\n     * @dev Joins a league.\\n     * @param leagueId the leagueId (for determining bet size)\\n     */\\n    function joinLeague(uint16 leagueId) public payable {\\n        require(\\n            msg.value >= getFee(leagueId),\\n            \\\"Insufficient payment to play game.\\\"\\n        );\\n        uint16 leagueNonce = LEAGUE_NONCES[leagueId];\\n\\n        portfolioCounts[leagueId][leagueNonce][msg.sender]++;\\n        LEAGUE_PLAYER_COUNTS[leagueId][leagueNonce]++;\\n        LEAGUE_TOTAL_FEES[leagueId][leagueNonce] += msg.value;\\n    }\\n\\n    /**\\n     * @dev Pays the winner of a league. The winner recievs the league's player count * base league fee,\\n     * while the owner recieves the total late fees charged.\\n     * @param players the address of the players who won\\n     * @param leagueId the leagueId (for determining bet size)\\n     */\\n    function payWinners(address[] calldata players, uint16 leagueId)\\n        public\\n        onlyOwner\\n    {\\n        uint16 leagueNonce = LEAGUE_NONCES[leagueId];\\n        uint32 leaguePlayerCount = LEAGUE_PLAYER_COUNTS[leagueId][leagueNonce];\\n        uint256 payout = leaguePlayerCount * LEAGUE_FEES[leagueId];\\n        uint256 payoutPerWinner = payout / players.length;\\n        uint256 roundingExtra = payout - (payoutPerWinner * players.length);\\n\\n        for (uint32 i = 0; i < players.length; i++) {\\n            require(\\n                portfolioCounts[leagueId][leagueNonce][players[i]] > 0,\\n                \\\"Not a valid player\\\"\\n            );\\n            address payable gameFeeBeneficiary = payable(players[i]);\\n            (bool sent, ) = gameFeeBeneficiary.call{value: payoutPerWinner}(\\\"\\\");\\n\\n            assert(sent);\\n        }\\n\\n        uint256 totalFeesCollected = LEAGUE_TOTAL_FEES[leagueId][leagueNonce];\\n        uint256 ownerPayout = (totalFeesCollected - payout) + roundingExtra;\\n\\n        if (ownerPayout != 0) {\\n            address payable owner = (payoutAddress == address(0))\\n                ? payable(owner())\\n                : payable(payoutAddress);\\n            (bool success, ) = owner.call{value: ownerPayout}(\\\"\\\");\\n\\n            assert(success);\\n        }\\n\\n        LEAGUE_NONCES[leagueId]++;\\n        lastLeagueStartDates[leagueId] = getEastCoastSeconds() / 86400;\\n    }\\n\\n    /**\\n     * @dev Pays no winner, but collects late fees and moves the whole pot into next week's league.\\n     * @param leagueId the leagueId (for determining bet size)\\n     */\\n    function callNoWinner(uint16 leagueId) public onlyOwner {\\n        uint16 leagueNonce = LEAGUE_NONCES[leagueId];\\n        uint32 leaguePlayerCount = LEAGUE_PLAYER_COUNTS[leagueId][leagueNonce];\\n        uint256 payout = leaguePlayerCount * LEAGUE_FEES[leagueId];\\n\\n        uint256 totalFeesCollected = LEAGUE_TOTAL_FEES[leagueId][leagueNonce];\\n        uint256 ownerPayout = (totalFeesCollected - payout);\\n\\n        if (ownerPayout != 0) {\\n            address payable owner = (payoutAddress == address(0))\\n                ? payable(owner())\\n                : payable(payoutAddress);\\n            (bool success, ) = owner.call{value: ownerPayout}(\\\"\\\");\\n\\n            assert(success);\\n        }\\n\\n        LEAGUE_NONCES[leagueId]++;\\n        lastLeagueStartDates[leagueId] = getEastCoastSeconds() / 86400;\\n\\n        uint16 newLeagueNonce = LEAGUE_NONCES[leagueId];\\n\\n        LEAGUE_PLAYER_COUNTS[leagueId][newLeagueNonce] = leaguePlayerCount;\\n        LEAGUE_TOTAL_FEES[leagueId][newLeagueNonce] = payout;\\n    }\\n\\n    function addLeague(uint256 leagueFee, uint256 flatFee) public onlyOwner returns (uint256) {\\n        LEAGUE_FEES.push(leagueFee);\\n        FLAT_LEAGUE_FEES.push(flatFee);\\n        LEAGUE_NONCES.push(0);\\n\\n        return LEAGUE_FEES.length - 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"nonces\",\"type\":\"uint16[]\"},{\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"flatFees\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FLAT_LEAGUE_FEES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LATE_FEE_DIVISOR\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEAGUE_FEES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEAGUE_NONCES\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"LEAGUE_PLAYER_COUNTS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"LEAGUE_TOTAL_FEES\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"leagueFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"flatFee\",\"type\":\"uint256\"}],\"name\":\"addLeague\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"leagueId\",\"type\":\"uint16\"}],\"name\":\"callNoWinner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"leagueId\",\"type\":\"uint16\"}],\"name\":\"getFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"leagueId\",\"type\":\"uint16\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNonces\",\"outputs\":[{\"internalType\":\"uint16[]\",\"name\":\"\",\"type\":\"uint16[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"player\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"leagueId\",\"type\":\"uint16\"}],\"name\":\"getPortfolioSize\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"leagueId\",\"type\":\"uint16\"}],\"name\":\"joinLeague\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"lastLeagueStartDates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"players\",\"type\":\"address[]\"},{\"internalType\":\"uint16\",\"name\":\"leagueId\",\"type\":\"uint16\"}],\"name\":\"payWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"portfolioCounts\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"adr\",\"type\":\"address\"}],\"name\":\"setPayoutAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "SnowApeContractV3", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000016000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000de0b6b3a76400000000000000000000000000000000000000000000000000000de0b6b3a764000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016345785d8a0000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}