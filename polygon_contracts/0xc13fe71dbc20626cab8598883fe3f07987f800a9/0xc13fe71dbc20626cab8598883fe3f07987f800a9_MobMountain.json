{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/MobMountain.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\\\";\\n\\ninterface IERC721 {\\n  function ownerOf(uint256 tokenId) external view returns (address owner);\\n  function isApprovedForAll(address owner, address operator) external view returns (bool); \\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n}\\n\\ninterface IERC20 {\\n  function mint(address someAddress, uint256 amt) external;\\n}\\n\\ninterface IBridge {\\n  function depositOnBehalfOf(uint256 _amount, address _consumable, address _actualOwner) external;\\n}\\n\\ncontract MobMountain is Pausable, VRFConsumerBaseV2, ConfirmedOwner  {\\n  address public immutable gemsAddress;\\n  address public immutable mobsAddress;\\n  address public immutable raidersAddress;\\n  address public bridgeAddress;\\n  address constant public BURN_ADDRESS = 0x1f0233b9Fd916B0304686338EC413fa2a824B28F;\\n\\n  uint8[] public gemRewardRange;\\n  uint256 public deploymentTime;\\n  uint256 public stakedMobCount; // purely for informational purposes;\\n\\n  bool public runningEnabled;\\n\\n  uint256[] public stakedTokenIds;\\n  RunResults[101] public randomResultPool;\\n\\n  mapping(Rarities => uint16) public mobRarityToMultiplier;\\n  mapping(uint256 => bool) public mobIdToStakedState;\\n  mapping(uint256 => bool) public mobTokenIdToBridgingDesired;\\n\\n  mapping(uint256 => Rarities) public mobTokenIdToRarity;\\n  mapping(uint256 => RequestStatus) public requestIdToStatus;\\n  mapping(uint256 => uint256[]) public runnersPerWeek;\\n\\n  mapping(uint256 => mapping(uint256 => RunStates)) public weeksToRaidersToRunState;  \\n  mapping(uint256 => mapping(uint256 => uint256)) public weeksToRaidersToRequestID;\\n\\n  enum RunStates { NOT_RUN, RUN_BUT_WAITING_FOR_VRF, RETRIEVED }\\n  enum RunResults { NONE, SAFE_WITH_GEMS, SAFE_WITHOUT_GEMS, DEATH }\\n  enum Rarities { NONE, FODDER, COMMON, UNCOMMON, RARE, EPIC, LEGENDARY, MYTHIC}\\n\\n  event MobStaked(uint256 indexed mobId);\\n  event MobUnstaked(uint256 indexed mobId);\\n\\n  event RunStarted(uint256 indexed weekIndex, uint256 indexed raiderId, uint requestId);\\n  event RunComplete(uint256 indexed weekIndex, uint256 indexed raiderId, uint256 indexed mobId, RunResults runResult, uint8 gemsRewarded);\\n  event RunCancelled(uint256 indexed weekIndex, uint256 indexed raiderId);\\n\\n  constructor(\\n    uint64 subscriptionId,\\n    address _gemsAddress,\\n    address _mobsAddress,\\n    address _raidersAddress\\n)\\n    VRFConsumerBaseV2(\\t0xAE975071Be8F8eE67addBC1A82488F1C24858067)\\n    ConfirmedOwner(msg.sender)\\n{\\n    COORDINATOR = VRFCoordinatorV2Interface(0xAE975071Be8F8eE67addBC1A82488F1C24858067);\\n    s_subscriptionId = subscriptionId;\\n\\n    require(_gemsAddress != address(0),\\\"Need gem address\\\");\\n    require(_mobsAddress != address(0),\\\"Need mobs address\\\");\\n    require(_raidersAddress != address(0),\\\"Need raiders address\\\");\\n\\n    gemsAddress = _gemsAddress;\\n    mobsAddress = _mobsAddress;\\n    raidersAddress = _raidersAddress;\\n    deploymentTime = block.timestamp;\\n}\\n\\n  /* VRF */\\n  event RequestSent(uint256 requestId, uint32 numWords);\\n  event RequestFulfilled(uint256 requestId, uint256[] randomWords);\\n\\n  struct RequestStatus {\\n    bool fulfilled; // whether the request has been successfully fulfilled\\n    bool exists; // whether a requestId exists\\n    uint256[] randomWords;\\n    uint256 tokenId;\\n    uint256 weekIndex;\\n    bool bridge;\\n  }\\n\\n  VRFCoordinatorV2Interface immutable COORDINATOR;\\n\\n  // Your subscription ID.\\n  uint64 immutable s_subscriptionId;\\n\\n  // The gas lane to use, which specifies the maximum gas price to bump to.\\n  // For a list of available gas lanes on each network,\\n  // see https://docs.chain.link/docs/vrf/v2/subscription/supported-networks/#configurations\\n  bytes32 constant keyHash =\\n      0xd729dc84e21ae57ffb6be0053bf2b0668aa2aaf300a2a7b2ddf7dc0bb6e875a8;\\n\\n  // Depends on the number of requested values that you want sent to the\\n  // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\\n  // so 100,000 is a safe default for this example contract. Test and adjust\\n  // this limit based on the network that you select, the size of the request,\\n  // and the processing of the callback request in the fulfillRandomWords()\\n  // function.\\n  uint32 callbackGasLimit = 500000;\\n\\n  // The default is 3, but you can set this higher.\\n  uint16 constant requestConfirmations = 3;\\n\\n  // For this example, retrieve 2 random values in one request.\\n  // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.\\n  uint32 constant numWords = 3;\\n\\n  /* VRF */\\n\\n  function getRunnersPerWeek(uint256 weekIndex) external view returns (uint256[] memory) {\\n    return runnersPerWeek[weekIndex];\\n  }\\n\\n  function getRandomResultPool() external view returns (RunResults[101] memory) {\\n    return randomResultPool;\\n  }\\n\\n  function getRunStateForWeekAndRaider(uint256 weekIndex, uint256 raiderId) external view returns (RunStates) {\\n    return weeksToRaidersToRunState[weekIndex][raiderId];\\n  }\\n\\n  function getRequestIdForWeekAndRaider(uint256 weekIndex, uint256 raiderId) external view returns (uint256) {\\n    return weeksToRaidersToRequestID[weekIndex][raiderId];\\n  }\\n\\n  function getCurrentWeek() public view returns(uint256) {\\n    return (block.timestamp - deploymentTime) / 1 weeks;\\n  }\\n\\n  function getAllMobTokenIds() external view returns(uint256[] memory) {\\n    return stakedTokenIds;\\n  }\\n\\n  function getAvailableMobCountAfterWeighting() external view returns(uint256) {\\n    return stakedTokenIds.length;\\n  }\\n\\n  function getActualRewardRange() external view returns (uint8[] memory) {\\n    return gemRewardRange;\\n  }\\n\\n  modifier onlyMobOwner(uint256 tokenId) {\\n    require(IERC721(mobsAddress).ownerOf(tokenId) == msg.sender,\\\"Not your mob\\\");\\n    _;\\n   }\\n\\n  modifier whenRunningEnabled {\\n    require(stakedTokenIds.length >= 2,\\\"No Mobs\\\");\\n    require(runningEnabled, \\\"cant run\\\");\\n    _;\\n   }\\n\\n  function stakeMob(uint256 tokenId) external whenNotPaused onlyMobOwner(tokenId) {\\n    require(!mobIdToStakedState[tokenId], \\\"Already Staked!\\\");\\n    require(mobTokenIdToRarity[tokenId] != Rarities.NONE, \\\"not init\\\");\\n\\n    mobIdToStakedState[tokenId] = true;\\n    stakedMobCount += 1;\\n\\n    if (stakedMobCount == 0) {\\n      stakedTokenIds.push(0);\\n    }\\n\\n    uint16 thisMultiplier = mobRarityToMultiplier[mobTokenIdToRarity[tokenId]];\\n    for (uint16 i; i < thisMultiplier; i++) {\\n      stakedTokenIds.push(tokenId);\\n    }\\n    emit MobStaked(tokenId);\\n  }\\n\\n  function unstakeMob(uint256 tokenId) external whenNotPaused onlyMobOwner(tokenId) {\\n    require(mobIdToStakedState[tokenId], \\\"Not Staked!\\\");\\n\\n    mobIdToStakedState[tokenId] = false;\\n    stakedMobCount -= 1;\\n    uint256[] memory oldArray = stakedTokenIds;\\n    delete stakedTokenIds;\\n    for (uint i; i < oldArray.length; i++) {\\n      uint thisVal = oldArray[i];\\n      if (thisVal != tokenId) {\\n        stakedTokenIds.push(thisVal);\\n      }\\n    }\\n    emit MobUnstaked(tokenId);\\n  }\\n\\n  function isBridgingEnabled() public view returns(bool) {\\n    return bridgeAddress != address(0);\\n  }\\n\\n  function beginRun(uint256 tokenId, bool bridge) external whenNotPaused whenRunningEnabled  {\\n\\n    if (bridge) {\\n      require(isBridgingEnabled(), \\\"cant bridge\\\");\\n    }\\n\\n    uint256 thisWeek = getCurrentWeek();\\n    require(IERC721(raidersAddress).ownerOf(tokenId) == msg.sender,\\\"Not yours\\\");\\n\\n    require(IERC721(raidersAddress).isApprovedForAll(msg.sender, address(this)),\\\"no perms\\\");\\n    require(weeksToRaidersToRunState[thisWeek][tokenId] == RunStates.NOT_RUN, \\\"run began\\\");\\n\\n    weeksToRaidersToRunState[thisWeek][tokenId] = RunStates.RUN_BUT_WAITING_FOR_VRF;\\n    runnersPerWeek[getCurrentWeek()].push(tokenId);\\n    \\n    // Will revert if subscription is not set and funded.\\n    uint requestId = COORDINATOR.requestRandomWords(\\n      keyHash,\\n      s_subscriptionId,\\n      requestConfirmations,\\n      callbackGasLimit,\\n      numWords\\n    );\\n    requestIdToStatus[requestId] = RequestStatus({\\n      randomWords: new uint256[](0),\\n      exists: true,\\n      fulfilled: false,\\n      tokenId: tokenId,\\n      weekIndex: thisWeek,\\n      bridge: bridge\\n    });\\n\\n    weeksToRaidersToRequestID[thisWeek][tokenId] = requestId;\\n\\n    emit RunStarted(thisWeek, tokenId, requestId);\\n  }\\n\\n  function finishRun(RequestStatus memory request) internal whenRunningEnabled {\\n    uint tokenId = request.tokenId;\\n    address raiderOwner = IERC721(raidersAddress).ownerOf(tokenId);\\n\\n    if (IERC721(raidersAddress).isApprovedForAll(raiderOwner, address(this))) {\\n      require(weeksToRaidersToRunState[request.weekIndex][tokenId] == RunStates.RUN_BUT_WAITING_FOR_VRF, \\\"Already began run for this week\\\");\\n      require(request.fulfilled,\\\"VRF not fufilled\\\");\\n\\n      weeksToRaidersToRunState[request.weekIndex][tokenId] = RunStates.RETRIEVED;\\n\\n      uint finalRunResultIndex = paddedRandomPull(request.randomWords[0], randomResultPool.length - 1);\\n\\n      RunResults finalRunResult = randomResultPool[finalRunResultIndex];\\n\\n      uint gemRewardIndex = paddedRandomPull(request.randomWords[1], gemRewardRange.length - 1);\\n      uint8 gemReward = gemRewardRange[gemRewardIndex];\\n\\n      uint pickedMobTokenIdIndex = paddedRandomPull(request.randomWords[2], stakedTokenIds.length - 1);\\n      uint pickedMobTokenId = stakedTokenIds[pickedMobTokenIdIndex];\\n      handleResult(request.weekIndex, finalRunResult, raiderOwner, tokenId, pickedMobTokenId, gemReward, request.bridge);\\n    } else {\\n      emit RunCancelled(request.weekIndex, tokenId);\\n    }\\n  }\\n\\n  function handleResult(uint256 weekIndex, RunResults finalRunResult, address raiderOwner, uint256 raiderTokenId, uint256 pickedMobTokenId, uint8 gemReward, bool raiderBridging) internal {\\n    if (finalRunResult == RunResults.SAFE_WITH_GEMS) {\\n      distributeGems(gemReward, raiderOwner, raiderBridging);\\n    } else {\\n      address mobOwner = IERC721(mobsAddress).ownerOf(pickedMobTokenId);\\n      distributeGems(gemReward, mobOwner, mobTokenIdToBridgingDesired[pickedMobTokenId]);\\n      if (finalRunResult == RunResults.DEATH) {\\n        IERC721(raidersAddress).safeTransferFrom(raiderOwner, BURN_ADDRESS, raiderTokenId);\\n      }\\n    }\\n    emit RunComplete(weekIndex, raiderTokenId, pickedMobTokenId, finalRunResult, gemReward);\\n  }\\n\\n  function distributeGems(uint8 gemReward, address recipient, bool bridge) internal {\\n    if (bridge) {\\n      IBridge(bridgeAddress).depositOnBehalfOf(gemReward, gemsAddress, recipient);\\n    } else {\\n      IERC20(gemsAddress).mint(recipient, gemReward);\\n    }\\n  }\\n\\n  function fulfillRandomWords(\\n      uint256 _requestId,\\n      uint256[] memory _randomWords\\n  ) internal override {\\n      require(requestIdToStatus[_requestId].exists, \\\"not found\\\");\\n      requestIdToStatus[_requestId].fulfilled = true;\\n      requestIdToStatus[_requestId].randomWords = _randomWords;\\n      emit RequestFulfilled(_requestId, _randomWords);\\n      finishRun(requestIdToStatus[_requestId]);\\n  }\\n\\n  function getRequestStatus(\\n      uint256 _requestId\\n  ) external view returns (bool fulfilled, uint256[] memory randomWords) {\\n      require(requestIdToStatus[_requestId].exists, \\\"not found\\\");\\n      RequestStatus memory request = requestIdToStatus[_requestId];\\n      return (request.fulfilled, request.randomWords);\\n  }\\n\\n  function updateMobBridgingChoice(uint256 tokenId, bool bridgeDesired) external onlyMobOwner(tokenId) {\\n    mobTokenIdToBridgingDesired[tokenId] = bridgeDesired;\\n  }\\n\\n  function paddedRandomPull(uint256 someRandom, uint256 someMax) internal pure returns (uint256) {\\n    return (someRandom % someMax) + 1;\\n  }\\n\\n  // ---------- ADMIN FUNCTIONS ----------\\n\\n  function pause() external onlyOwner {\\n    _pause();\\n  }\\n\\n  function unpause() external onlyOwner {\\n    _unpause();\\n  }\\n\\n  function updateBridgeAddress(address newAddress) external onlyOwner {\\n    bridgeAddress = newAddress;\\n  }\\n\\n  function setNewBaseTime(uint256 newTime) external onlyOwner {\\n    deploymentTime = newTime;\\n  }\\n\\n  function updateMobRarity(uint256 tokenId, Rarities rarity) external onlyOwner {\\n    assert(rarity != Rarities.NONE);\\n    mobTokenIdToRarity[tokenId] = rarity;\\n  }\\n\\n  function updateMobRarities(uint256[2][] calldata sets) external onlyOwner {\\n    for(uint i; i < sets.length; i++) {\\n      Rarities castRarity = Rarities(sets[i][1]);\\n      assert(castRarity != Rarities.NONE);\\n      mobTokenIdToRarity[sets[i][0]] = castRarity;\\n    }\\n  }\\n\\n  function updateMobMultiplier(Rarities rarityInt, uint16 rarityMultipler) external onlyOwner {\\n    mobRarityToMultiplier[rarityInt] = rarityMultipler;\\n  }\\n\\n  function updateResultThresholds(uint8[3] memory thresholds) external onlyOwner {\\n    require(thresholds[0] + thresholds[1] + thresholds[2] == 100,\\\"not 100\\\");\\n    delete randomResultPool;\\n    randomResultPool[0] = RunResults.NONE;\\n    RunResults firstCode = RunResults.SAFE_WITH_GEMS;\\n    RunResults secondCode = RunResults.SAFE_WITHOUT_GEMS;\\n    RunResults thirdCode = RunResults.DEATH;\\n\\n    uint8 counter = 1;\\n\\n    for(uint8 i = 0; i < thresholds[0]; i++) {\\n      randomResultPool[counter] = firstCode;\\n      counter++;\\n    }\\n\\n    for(uint8 i = 0; i < thresholds[1]; i++) {\\n      randomResultPool[counter] = secondCode;\\n      counter++;    \\n    }\\n\\n    for(uint8 i = 0; i < thresholds[2]; i++) {\\n      randomResultPool[counter] = thirdCode;\\n      counter++;\\n    }\\n  }\\n\\n  function forceUnstake() external onlyOwner {\\n    delete stakedTokenIds;\\n    stakedMobCount = 0;\\n  }\\n\\n  function updateCallbackGasLimit(uint32 newLimit) external onlyOwner {\\n    callbackGasLimit = newLimit;\\n  }\\n\\n  function updateRunningEnabled(bool canRun) external onlyOwner {\\n    runningEnabled = canRun;\\n  }\\n\\n  function updateRewardRange(uint8 min, uint8 max) external onlyOwner {\\n    delete gemRewardRange;\\n    gemRewardRange.push(0);\\n    for(uint8 i = min; i < (max + 1); i++) {\\n      gemRewardRange.push(i);\\n    }\\n  }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/** ****************************************************************************\\n * @notice Interface for contracts using VRF randomness\\n * *****************************************************************************\\n * @dev PURPOSE\\n *\\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\\n * @dev making his output up to suit himself. Reggie provides Vera a public key\\n * @dev to which he knows the secret key. Each time Vera provides a seed to\\n * @dev Reggie, he gives back a value which is computed completely\\n * @dev deterministically from the seed and the secret key.\\n *\\n * @dev Reggie provides a proof by which Vera can verify that the output was\\n * @dev correctly computed once Reggie tells it to her, but without that proof,\\n * @dev the output is indistinguishable to her from a uniform random sample\\n * @dev from the output space.\\n *\\n * @dev The purpose of this contract is to make it easy for unrelated contracts\\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\\n * @dev 1. The fulfillment came from the VRFCoordinator\\n * @dev 2. The consumer contract implements fulfillRandomWords.\\n * *****************************************************************************\\n * @dev USAGE\\n *\\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\\n * @dev initialize VRFConsumerBase's attributes in their constructor as\\n * @dev shown:\\n *\\n * @dev   contract VRFConsumer {\\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\\n * @dev         <initialization with other arguments goes here>\\n * @dev       }\\n * @dev   }\\n *\\n * @dev The oracle will have given you an ID for the VRF keypair they have\\n * @dev committed to (let's call it keyHash). Create subscription, fund it\\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\\n * @dev subscription management functions).\\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\\n * @dev callbackGasLimit, numWords),\\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\\n *\\n * @dev Once the VRFCoordinator has received and validated the oracle's response\\n * @dev to your request, it will call your contract's fulfillRandomWords method.\\n *\\n * @dev The randomness argument to fulfillRandomWords is a set of random words\\n * @dev generated from your requestId and the blockHash of the request.\\n *\\n * @dev If your contract could have concurrent requests open, you can use the\\n * @dev requestId returned from requestRandomWords to track which response is associated\\n * @dev with which randomness request.\\n * @dev See \\\"SECURITY CONSIDERATIONS\\\" for principles to keep in mind,\\n * @dev if your contract could have multiple requests in flight simultaneously.\\n *\\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\\n * @dev differ.\\n *\\n * *****************************************************************************\\n * @dev SECURITY CONSIDERATIONS\\n *\\n * @dev A method with the ability to call your fulfillRandomness method directly\\n * @dev could spoof a VRF response with any random value, so it's critical that\\n * @dev it cannot be directly called by anything other than this base contract\\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\\n *\\n * @dev For your users to trust that your contract's random behavior is free\\n * @dev from malicious interference, it's best if you can write it so that all\\n * @dev behaviors implied by a VRF response are executed *during* your\\n * @dev fulfillRandomness method. If your contract must store the response (or\\n * @dev anything derived from it) and use it later, you must ensure that any\\n * @dev user-significant behavior which depends on that stored value cannot be\\n * @dev manipulated by a subsequent VRF request.\\n *\\n * @dev Similarly, both miners and the VRF oracle itself have some influence\\n * @dev over the order in which VRF responses appear on the blockchain, so if\\n * @dev your contract could have multiple VRF requests in flight simultaneously,\\n * @dev you must ensure that the order in which the VRF responses arrive cannot\\n * @dev be used to manipulate your contract's user-significant behavior.\\n *\\n * @dev Since the block hash of the block which contains the requestRandomness\\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\\n * @dev miner could, in principle, fork the blockchain to evict the block\\n * @dev containing the request, forcing the request to be included in a\\n * @dev different block with a different hash, and therefore a different input\\n * @dev to the VRF. However, such an attack would incur a substantial economic\\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\\n * @dev until it calls responds to a request. It is for this reason that\\n * @dev that you can signal to an oracle you'd like them to wait longer before\\n * @dev responding to the request (however this is not enforced in the contract\\n * @dev and so remains effective only in the case of unmodified oracle software).\\n */\\nabstract contract VRFConsumerBaseV2 {\\n  error OnlyCoordinatorCanFulfill(address have, address want);\\n  address private immutable vrfCoordinator;\\n\\n  /**\\n   * @param _vrfCoordinator address of VRFCoordinator contract\\n   */\\n  constructor(address _vrfCoordinator) {\\n    vrfCoordinator = _vrfCoordinator;\\n  }\\n\\n  /**\\n   * @notice fulfillRandomness handles the VRF response. Your contract must\\n   * @notice implement it. See \\\"SECURITY CONSIDERATIONS\\\" above for important\\n   * @notice principles to keep in mind when implementing your fulfillRandomness\\n   * @notice method.\\n   *\\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\\n   * @dev signature, and will call it once it has verified the proof\\n   * @dev associated with the randomness. (It is triggered via a call to\\n   * @dev rawFulfillRandomness, below.)\\n   *\\n   * @param requestId The Id initially returned by requestRandomness\\n   * @param randomWords the VRF output expanded to the requested number of words\\n   */\\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\\n\\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\\n  // the origin of the call\\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\\n    if (msg.sender != vrfCoordinator) {\\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\\n    }\\n    fulfillRandomWords(requestId, randomWords);\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwner.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ConfirmedOwnerWithProposal.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/ConfirmedOwnerWithProposal.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./interfaces/OwnableInterface.sol\\\";\\n\\n/**\\n * @title The ConfirmedOwner contract\\n * @notice A contract with helpers for basic contract ownership.\\n */\\ncontract ConfirmedOwnerWithProposal is OwnableInterface {\\n  address private s_owner;\\n  address private s_pendingOwner;\\n\\n  event OwnershipTransferRequested(address indexed from, address indexed to);\\n  event OwnershipTransferred(address indexed from, address indexed to);\\n\\n  constructor(address newOwner, address pendingOwner) {\\n    require(newOwner != address(0), \\\"Cannot set owner to zero\\\");\\n\\n    s_owner = newOwner;\\n    if (pendingOwner != address(0)) {\\n      _transferOwnership(pendingOwner);\\n    }\\n  }\\n\\n  /**\\n   * @notice Allows an owner to begin transferring ownership to a new address,\\n   * pending.\\n   */\\n  function transferOwnership(address to) public override onlyOwner {\\n    _transferOwnership(to);\\n  }\\n\\n  /**\\n   * @notice Allows an ownership transfer to be completed by the recipient.\\n   */\\n  function acceptOwnership() external override {\\n    require(msg.sender == s_pendingOwner, \\\"Must be proposed owner\\\");\\n\\n    address oldOwner = s_owner;\\n    s_owner = msg.sender;\\n    s_pendingOwner = address(0);\\n\\n    emit OwnershipTransferred(oldOwner, msg.sender);\\n  }\\n\\n  /**\\n   * @notice Get the current owner\\n   */\\n  function owner() public view override returns (address) {\\n    return s_owner;\\n  }\\n\\n  /**\\n   * @notice validate, transfer ownership, and emit relevant events\\n   */\\n  function _transferOwnership(address to) private {\\n    require(to != msg.sender, \\\"Cannot transfer to self\\\");\\n\\n    s_pendingOwner = to;\\n\\n    emit OwnershipTransferRequested(s_owner, to);\\n  }\\n\\n  /**\\n   * @notice validate access\\n   */\\n  function _validateOwnership() internal view {\\n    require(msg.sender == s_owner, \\\"Only callable by owner\\\");\\n  }\\n\\n  /**\\n   * @notice Reverts if called by anyone other than the contract owner.\\n   */\\n  modifier onlyOwner() {\\n    _validateOwnership();\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"@chainlink/contracts/src/v0.8/interfaces/OwnableInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface OwnableInterface {\\n  function owner() external returns (address);\\n\\n  function transferOwnership(address recipient) external;\\n\\n  function acceptOwnership() external;\\n}\\n\"\r\n    },\r\n    \"contracts-exposed/MobMountain.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\n\\npragma solidity >=0.6.0;\\n\\nimport \\\"../contracts/MobMountain.sol\\\";\\n\\nabstract contract $IERC721 is IERC721 {\\n    bytes32 public __hh_exposed_bytecode_marker = \\\"hardhat-exposed\\\";\\n\\n    constructor() {}\\n\\n    receive() external payable {}\\n}\\n\\nabstract contract $IERC20 is IERC20 {\\n    bytes32 public __hh_exposed_bytecode_marker = \\\"hardhat-exposed\\\";\\n\\n    constructor() {}\\n\\n    receive() external payable {}\\n}\\n\\nabstract contract $IBridge is IBridge {\\n    bytes32 public __hh_exposed_bytecode_marker = \\\"hardhat-exposed\\\";\\n\\n    constructor() {}\\n\\n    receive() external payable {}\\n}\\n\\ncontract $MobMountain is MobMountain {\\n    bytes32 public __hh_exposed_bytecode_marker = \\\"hardhat-exposed\\\";\\n\\n    constructor(uint64 subscriptionId, address _gemsAddress, address _mobsAddress, address _raidersAddress) MobMountain(subscriptionId, _gemsAddress, _mobsAddress, _raidersAddress) {}\\n\\n    function $COORDINATOR() external view returns (VRFCoordinatorV2Interface) {\\n        return COORDINATOR;\\n    }\\n\\n    function $s_subscriptionId() external view returns (uint64) {\\n        return s_subscriptionId;\\n    }\\n\\n    function $keyHash() external pure returns (bytes32) {\\n        return keyHash;\\n    }\\n\\n    function $callbackGasLimit() external view returns (uint32) {\\n        return callbackGasLimit;\\n    }\\n\\n    function $requestConfirmations() external pure returns (uint16) {\\n        return requestConfirmations;\\n    }\\n\\n    function $numWords() external pure returns (uint32) {\\n        return numWords;\\n    }\\n\\n    function $finishRun(MobMountain.RequestStatus calldata request) external {\\n        return super.finishRun(request);\\n    }\\n\\n    function $handleResult(uint256 weekIndex,MobMountain.RunResults finalRunResult,address raiderOwner,uint256 raiderTokenId,uint256 pickedMobTokenId,uint8 gemReward,bool raiderBridging) external {\\n        return super.handleResult(weekIndex,finalRunResult,raiderOwner,raiderTokenId,pickedMobTokenId,gemReward,raiderBridging);\\n    }\\n\\n    function $distributeGems(uint8 gemReward,address recipient,bool bridge) external {\\n        return super.distributeGems(gemReward,recipient,bridge);\\n    }\\n\\n    function $fulfillRandomWords(uint256 _requestId,uint256[] calldata _randomWords) external {\\n        return super.fulfillRandomWords(_requestId,_randomWords);\\n    }\\n\\n    function $paddedRandomPull(uint256 someRandom,uint256 someMax) external pure returns (uint256) {\\n        return super.paddedRandomPull(someRandom,someMax);\\n    }\\n\\n    function $_validateOwnership() external view {\\n        return super._validateOwnership();\\n    }\\n\\n    function $_pause() external {\\n        return super._pause();\\n    }\\n\\n    function $_unpause() external {\\n        return super._unpause();\\n    }\\n\\n    function $_msgSender() external view returns (address) {\\n        return super._msgSender();\\n    }\\n\\n    function $_msgData() external view returns (bytes memory) {\\n        return super._msgData();\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint64\",\"name\":\"subscriptionId\",\"type\":\"uint64\"},{\"internalType\":\"address\",\"name\":\"_gemsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_mobsAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_raidersAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"have\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"want\",\"type\":\"address\"}],\"name\":\"OnlyCoordinatorCanFulfill\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"mobId\",\"type\":\"uint256\"}],\"name\":\"MobStaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"mobId\",\"type\":\"uint256\"}],\"name\":\"MobUnstaked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"RequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"numWords\",\"type\":\"uint32\"}],\"name\":\"RequestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"weekIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"raiderId\",\"type\":\"uint256\"}],\"name\":\"RunCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"weekIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"raiderId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"mobId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum MobMountain.RunResults\",\"name\":\"runResult\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"gemsRewarded\",\"type\":\"uint8\"}],\"name\":\"RunComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"weekIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"raiderId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"}],\"name\":\"RunStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BURN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bridge\",\"type\":\"bool\"}],\"name\":\"beginRun\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bridgeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deploymentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"forceUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gemRewardRange\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gemsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getActualRewardRange\",\"outputs\":[{\"internalType\":\"uint8[]\",\"name\":\"\",\"type\":\"uint8[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllMobTokenIds\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAvailableMobCountAfterWeighting\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRandomResultPool\",\"outputs\":[{\"internalType\":\"enum MobMountain.RunResults[101]\",\"name\":\"\",\"type\":\"uint8[101]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"raiderId\",\"type\":\"uint256\"}],\"name\":\"getRequestIdForWeekAndRaider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_requestId\",\"type\":\"uint256\"}],\"name\":\"getRequestStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"raiderId\",\"type\":\"uint256\"}],\"name\":\"getRunStateForWeekAndRaider\",\"outputs\":[{\"internalType\":\"enum MobMountain.RunStates\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"weekIndex\",\"type\":\"uint256\"}],\"name\":\"getRunnersPerWeek\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isBridgingEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mobIdToStakedState\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MobMountain.Rarities\",\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"mobRarityToMultiplier\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mobTokenIdToBridgingDesired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mobTokenIdToRarity\",\"outputs\":[{\"internalType\":\"enum MobMountain.Rarities\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mobsAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"raidersAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomResultPool\",\"outputs\":[{\"internalType\":\"enum MobMountain.RunResults\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"requestId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"randomWords\",\"type\":\"uint256[]\"}],\"name\":\"rawFulfillRandomWords\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requestIdToStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"fulfilled\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"exists\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weekIndex\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bridge\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"runnersPerWeek\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"runningEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newTime\",\"type\":\"uint256\"}],\"name\":\"setNewBaseTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stakeMob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakedMobCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedTokenIds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unstakeMob\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"updateBridgeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"newLimit\",\"type\":\"uint32\"}],\"name\":\"updateCallbackGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"bridgeDesired\",\"type\":\"bool\"}],\"name\":\"updateMobBridgingChoice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum MobMountain.Rarities\",\"name\":\"rarityInt\",\"type\":\"uint8\"},{\"internalType\":\"uint16\",\"name\":\"rarityMultipler\",\"type\":\"uint16\"}],\"name\":\"updateMobMultiplier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2][]\",\"name\":\"sets\",\"type\":\"uint256[2][]\"}],\"name\":\"updateMobRarities\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"enum MobMountain.Rarities\",\"name\":\"rarity\",\"type\":\"uint8\"}],\"name\":\"updateMobRarity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8[3]\",\"name\":\"thresholds\",\"type\":\"uint8[3]\"}],\"name\":\"updateResultThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"min\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"max\",\"type\":\"uint8\"}],\"name\":\"updateRewardRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"canRun\",\"type\":\"bool\"}],\"name\":\"updateRunningEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"weeksToRaidersToRequestID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"weeksToRaidersToRunState\",\"outputs\":[{\"internalType\":\"enum MobMountain.RunStates\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "MobMountain", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000023900000000000000000000000023691f70323bfd03bef0eb5ffde44df70b58ffb10000000000000000000000002ad64e95eff639fbd0273bcd4d0eeb72a60c8586000000000000000000000000fd12ec7ea4b381a79c78fe8b2248b4c559011ffb", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}