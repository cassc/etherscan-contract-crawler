{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.9;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n */\r\nlibrary EnumerableSet {\r\n    // To implement this library for multiple types with as little code\r\n    // repetition as possible, we write it in terms of a generic Set type with\r\n    // bytes32 values.\r\n    // The Set implementation uses private functions, and user-facing\r\n    // implementations (such as AddressSet) are just wrappers around the\r\n    // underlying Set.\r\n    // This means that we can only create new EnumerableSets for types that fit\r\n    // in bytes32.\r\n\r\n    struct Set {\r\n        // Storage of set values\r\n        bytes32[] _values;\r\n        // Position of the value in the `values` array, plus 1 because index 0\r\n        // means a value is not in the set.\r\n        mapping(bytes32 => uint256) _indexes;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function _add(Set storage set, bytes32 value) private returns (bool) {\r\n        if (!_contains(set, value)) {\r\n            set._values.push(value);\r\n            // The value is stored at length-1, but we add 1 to all indexes\r\n            // and use 0 as a sentinel value\r\n            set._indexes[value] = set._values.length;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n        // We read and store the value's index to prevent multiple reads from the same storage slot\r\n        uint256 valueIndex = set._indexes[value];\r\n\r\n        if (valueIndex != 0) {\r\n            // Equivalent to contains(set, value)\r\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n            // This modifies the order of the array, as noted in {at}.\r\n\r\n            uint256 toDeleteIndex = valueIndex - 1;\r\n            uint256 lastIndex = set._values.length - 1;\r\n\r\n            if (lastIndex != toDeleteIndex) {\r\n                bytes32 lastvalue = set._values[lastIndex];\r\n\r\n                // Move the last value to the index where the value to delete is\r\n                set._values[toDeleteIndex] = lastvalue;\r\n                // Update the index for the moved value\r\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\r\n            }\r\n\r\n            // Delete the slot where the moved value was stored\r\n            set._values.pop();\r\n\r\n            // Delete the index for the deleted slot\r\n            delete set._indexes[value];\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n        return set._indexes[value] != 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function _length(Set storage set) private view returns (uint256) {\r\n        return set._values.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n        return set._values[index];\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function _values(Set storage set) private view returns (bytes32[] memory) {\r\n        return set._values;\r\n    }\r\n\r\n    // Bytes32Set\r\n\r\n    struct Bytes32Set {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _add(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n        return _remove(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n        return _contains(set._inner, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(Bytes32Set storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n        return _at(set._inner, index);\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n        return _values(set._inner);\r\n    }\r\n\r\n    // AddressSet\r\n\r\n    struct AddressSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(AddressSet storage set, address value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(AddressSet storage set, address value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values in the set. O(1).\r\n     */\r\n    function length(AddressSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n        return address(uint160(uint256(_at(set._inner, index))));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(AddressSet storage set) internal view returns (address[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        address[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // UintSet\r\n\r\n    struct UintSet {\r\n        Set _inner;\r\n    }\r\n\r\n    /**\r\n     * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _add(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n        return _remove(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n        return _contains(set._inner, bytes32(value));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of values on the set. O(1).\r\n     */\r\n    function length(UintSet storage set) internal view returns (uint256) {\r\n        return _length(set._inner);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n        return uint256(_at(set._inner, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n        bytes32[] memory store = _values(set._inner);\r\n        uint256[] memory result;\r\n\r\n        assembly {\r\n            result := store\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/// @title Contains constants needed for math libraries\r\nlibrary MathConstants {\r\n  uint256 internal constant TWO_POW_48 = 2 ** 48;\r\n  uint256 internal constant TWO_POW_96 = 2 ** 96;\r\n  uint128 internal constant MIN_LIQUIDITY = 100_000;\r\n  uint24 internal constant FEE_UNITS = 100_000;\r\n  uint8 internal constant RES_96 = 96;\r\n}\r\n\r\nlibrary LMMath {\r\n  function calcSumRewardPerLiquidity(\r\n    uint256 rewardAmount,\r\n    uint32 startTime,\r\n    uint32 endTime,\r\n    uint32 curTime,\r\n    uint32 lastTouchedTime,\r\n    uint256 totalLiquidity\r\n  ) internal pure returns (uint256 deltaSumRewardPerLiquidity) {\r\n    uint256 joinedDuration;\r\n    uint256 duration;\r\n\r\n    unchecked {\r\n      joinedDuration = (curTime < endTime ? curTime : endTime) - lastTouchedTime;\r\n      duration = endTime - startTime;\r\n      deltaSumRewardPerLiquidity =\r\n        (rewardAmount * joinedDuration * MathConstants.TWO_POW_96) /\r\n        (duration * totalLiquidity);\r\n    }\r\n  }\r\n\r\n  function calcRewardAmount(\r\n    uint256 curSumRewardPerLiquidity,\r\n    uint256 lastSumRewardPerLiquidity,\r\n    uint256 liquidity\r\n  ) internal pure returns (uint256 rewardAmount) {\r\n    uint256 deltaSumRewardPerLiquidity;\r\n\r\n    unchecked {\r\n      deltaSumRewardPerLiquidity = curSumRewardPerLiquidity - lastSumRewardPerLiquidity;\r\n      rewardAmount = (deltaSumRewardPerLiquidity * liquidity) / MathConstants.TWO_POW_96;\r\n    }\r\n  }\r\n\r\n  function calcRewardUntilNow(\r\n    uint256 rewardAmount,\r\n    uint32 startTime,\r\n    uint32 endTime,\r\n    uint32 curTime\r\n  ) internal pure returns (uint256 rewardAmountNow) {\r\n    uint256 joinedDuration;\r\n    uint256 duration;\r\n\r\n    unchecked {\r\n      joinedDuration = curTime - startTime;\r\n      duration = endTime - startTime;\r\n      rewardAmountNow = (rewardAmount * joinedDuration) / duration;\r\n    }\r\n  }\r\n}\r\n\r\nabstract contract KSAdmin {\r\n  address public admin;\r\n  mapping(address => bool) public operators; // address => bool\r\n\r\n  event TransferAdmin(address indexed admin);\r\n  event UpdateOperator(address indexed user, bool grantOrRevoke);\r\n\r\n  modifier isAdmin() {\r\n    require(msg.sender == admin, 'forbidden');\r\n    _;\r\n  }\r\n\r\n  modifier isOperator() {\r\n    require(operators[msg.sender], 'forbidden');\r\n    _;\r\n  }\r\n\r\n  constructor() {\r\n    admin = msg.sender;\r\n    operators[msg.sender] = true;\r\n  }\r\n\r\n  function transferAdmin(address _admin) external virtual isAdmin {\r\n    require(_admin != address(0), 'forbidden');\r\n\r\n    admin = _admin;\r\n\r\n    emit TransferAdmin(_admin);\r\n  }\r\n\r\n  function updateOperator(address user, bool grantOrRevoke) external isAdmin {\r\n    operators[user] = grantOrRevoke;\r\n\r\n    emit UpdateOperator(user, grantOrRevoke);\r\n  }\r\n}\r\n\r\ninterface IKyberSwapFarmingToken {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n   * the total supply.\r\n   *\r\n   * Emits a {Transfer} event with `from` set to the zero address.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `msg.sender` must be operator\r\n   * - `account` cannot be the zero address.\r\n   */\r\n  function mint(address account, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev Destroys `amount` tokens from the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `msg.sender` must be operator\r\n   * - `account` cannot be the zero address.\r\n   *\r\n   * See {ERC20-_burn}.\r\n   */\r\n\r\n  function burn(address account, uint256 amount) external;\r\n\r\n  /**\r\n   * @dev address of operator, only be set once in constructor.\r\n   * only operator can mint/burn tokens\r\n   */\r\n\r\n  function operator() external view returns (address);\r\n}\r\n\r\ninterface IBasePositionManager {\r\n  struct Position {\r\n    // the nonce for permits\r\n    uint96 nonce;\r\n    // the address that is approved for spending this token\r\n    address operator;\r\n    // the ID of the pool with which this token is connected\r\n    uint80 poolId;\r\n    // the tick range of the position\r\n    int24 tickLower;\r\n    int24 tickUpper;\r\n    // the liquidity of the position\r\n    uint128 liquidity;\r\n    // the current rToken that the position owed\r\n    uint256 rTokenOwed;\r\n    // fee growth per unit of liquidity as of the last update to liquidity\r\n    uint256 feeGrowthInsideLast;\r\n  }\r\n\r\n  struct PoolInfo {\r\n    address token0;\r\n    uint16 fee;\r\n    address token1;\r\n  }\r\n\r\n  struct MintParams {\r\n    address token0;\r\n    address token1;\r\n    uint24 fee;\r\n    int24 tickLower;\r\n    int24 tickUpper;\r\n    int24[2] ticksPrevious;\r\n    uint256 amount0Desired;\r\n    uint256 amount1Desired;\r\n    uint256 amount0Min;\r\n    uint256 amount1Min;\r\n    address recipient;\r\n    uint256 deadline;\r\n  }\r\n\r\n  struct IncreaseLiquidityParams {\r\n    uint256 tokenId;\r\n    uint256 amount0Desired;\r\n    uint256 amount1Desired;\r\n    uint256 amount0Min;\r\n    uint256 amount1Min;\r\n    uint256 deadline;\r\n  }\r\n\r\n  struct RemoveLiquidityParams {\r\n    uint256 tokenId;\r\n    uint128 liquidity;\r\n    uint256 amount0Min;\r\n    uint256 amount1Min;\r\n    uint256 deadline;\r\n  }\r\n\r\n  struct BurnRTokenParams {\r\n    uint256 tokenId;\r\n    uint256 amount0Min;\r\n    uint256 amount1Min;\r\n    uint256 deadline;\r\n  }\r\n\r\n  function positions(\r\n    uint256 tokenId\r\n  ) external view returns (Position memory pos, PoolInfo memory info);\r\n\r\n  function addressToPoolId(address pool) external view returns (uint80);\r\n\r\n  function WETH() external view returns (address);\r\n\r\n  function mint(\r\n    MintParams calldata params\r\n  )\r\n    external\r\n    payable\r\n    returns (uint256 tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\r\n\r\n  function addLiquidity(\r\n    IncreaseLiquidityParams calldata params\r\n  )\r\n    external\r\n    payable\r\n    returns (uint128 liquidity, uint256 amount0, uint256 amount1, uint256 additionalRTokenOwed);\r\n\r\n  function removeLiquidity(\r\n    RemoveLiquidityParams calldata params\r\n  ) external returns (uint256 amount0, uint256 amount1, uint256 additionalRTokenOwed);\r\n\r\n  function syncFeeGrowth(uint256 tokenId) external returns (uint256 additionalRTokenOwed);\r\n\r\n  function burnRTokens(\r\n    BurnRTokenParams calldata params\r\n  ) external returns (uint256 rTokenQty, uint256 amount0, uint256 amount1);\r\n\r\n  function transferAllTokens(address token, uint256 minAmount, address recipient) external payable;\r\n\r\n  function unwrapWeth(uint256 minAmount, address recipient) external payable;\r\n}\r\n\r\ninterface IKSElasticLMHelper {\r\n  struct UserInfo {\r\n    uint256 nftId;\r\n    uint256 fId;\r\n    uint256 rangeId;\r\n    uint256 liquidity;\r\n    uint256[] currentUnclaimedRewards;\r\n  }\r\n\r\n  //use by both LMv1 and LMv2\r\n  function checkPool(\r\n    address pAddress,\r\n    address nftContract,\r\n    uint256 nftId\r\n  ) external view returns (bool);\r\n\r\n  function getLiq(address nftContract, uint256 nftId) external view returns (uint128);\r\n\r\n  function getPair(address nftContract, uint256 nftId) external view returns (address, address);\r\n\r\n  //use by LMv1\r\n  function getActiveTime(\r\n    address pAddr,\r\n    address nftContract,\r\n    uint256 nftId\r\n  ) external view returns (uint128);\r\n\r\n  function getSignedFee(address nftContract, uint256 nftId) external view returns (int256);\r\n\r\n  function getSignedFeePool(\r\n    address poolAddress,\r\n    address nftContract,\r\n    uint256 nftId\r\n  ) external view returns (int256);\r\n\r\n  //use by LMv2\r\n  function getCurrentUnclaimedReward(\r\n    IKSElasticLMV2 farm,\r\n    uint256 nftId\r\n  ) external view returns (uint256[] memory currentUnclaimedRewards);\r\n\r\n  function getUserInfo(IKSElasticLMV2 farm, address user) external view returns (UserInfo[] memory);\r\n\r\n  function getEligibleRanges(\r\n    IKSElasticLMV2 farm,\r\n    uint256 fId,\r\n    uint256 nftId\r\n  ) external view returns (uint256[] memory indexesValid);\r\n\r\n  function checkPosition(\r\n    address pAddress,\r\n    address nftContract,\r\n    int24 tickLower,\r\n    int24 tickUpper,\r\n    uint256[] memory nftIds\r\n  ) external view returns (bool isInvalid, uint128[] memory liquidities);\r\n\r\n  function getPositionInfo(\r\n    address nftContract,\r\n    uint256 nftId\r\n  ) external view returns (uint256, int24, int24, uint128);\r\n}\r\n\r\ninterface IKSElasticLMV2 {\r\n  error Forbidden();\r\n  error EmergencyEnabled();\r\n\r\n  error InvalidRange();\r\n  error InvalidTime();\r\n  error InvalidReward();\r\n\r\n  error PositionNotEligible();\r\n  error FarmNotFound();\r\n  error InvalidFarm();\r\n  error NotOwner();\r\n  error StakeNotFound();\r\n  error RangeNotMatch();\r\n  error RangeNotFound();\r\n  error PhaseSettled();\r\n  error InvalidInput();\r\n  error LiquidityNotMatch();\r\n  error FailToAdd();\r\n  error FailToRemove();\r\n  error Expired();\r\n\r\n  event UpdateEmergency(bool enableOrDisable);\r\n  event UpdateTokenCode(bytes farmingTokenCode);\r\n  event UpdateHelper(IKSElasticLMHelper helper);\r\n  event WithdrawUnusedRewards(address token, uint256 amount, address receiver);\r\n\r\n  event AddFarm(\r\n    uint256 indexed fId,\r\n    address poolAddress,\r\n    RangeInput[] ranges,\r\n    PhaseInput phase,\r\n    address farmingToken\r\n  );\r\n  event AddPhase(uint256 indexed fId, PhaseInput phase);\r\n  event ForceClosePhase(uint256 indexed fId);\r\n  event AddRange(uint256 indexed fId, RangeInput range);\r\n  event RemoveRange(uint256 indexed fId, uint256 rangeId);\r\n  event ActivateRange(uint256 indexed fId, uint256 rangeId);\r\n  event ExpandEndTimeAndRewards(uint256 indexed fId, uint256 duration, uint256[] rewardAmounts);\r\n\r\n  event Deposit(\r\n    uint256 indexed fId,\r\n    uint256 rangeId,\r\n    uint256[] nftIds,\r\n    address indexed depositer,\r\n    address receiver\r\n  );\r\n  event UpdateLiquidity(uint256 indexed fId, uint256 nftId, uint256 liquidity);\r\n  event Withdraw(uint256[] nftIds, address receiver);\r\n  event WithdrawEmergency(uint256 nftId, address receiver);\r\n  event ClaimReward(\r\n    uint256 fId,\r\n    uint256[] nftIds,\r\n    address token,\r\n    uint256 amount,\r\n    address receiver\r\n  );\r\n\r\n  struct RangeInput {\r\n    int24 tickLower;\r\n    int24 tickUpper;\r\n    uint32 weight;\r\n  }\r\n\r\n  struct RewardInput {\r\n    address rewardToken;\r\n    uint256 rewardAmount;\r\n  }\r\n\r\n  struct PhaseInput {\r\n    uint32 startTime;\r\n    uint32 endTime;\r\n    RewardInput[] rewards;\r\n  }\r\n\r\n  struct RemoveLiquidityInput {\r\n    uint256 nftId;\r\n    uint128 liquidity;\r\n  }\r\n\r\n  struct RangeInfo {\r\n    int24 tickLower;\r\n    int24 tickUpper;\r\n    uint32 weight;\r\n    bool isRemoved;\r\n  }\r\n\r\n  struct PhaseInfo {\r\n    uint32 startTime;\r\n    uint32 endTime;\r\n    bool isSettled;\r\n    RewardInput[] rewards;\r\n  }\r\n\r\n  struct FarmInfo {\r\n    address poolAddress;\r\n    RangeInfo[] ranges;\r\n    PhaseInfo phase;\r\n    uint256 liquidity;\r\n    address farmingToken;\r\n    uint256[] sumRewardPerLiquidity;\r\n    uint32 lastTouchedTime;\r\n  }\r\n\r\n  struct StakeInfo {\r\n    address owner;\r\n    uint256 fId;\r\n    uint256 rangeId;\r\n    uint256 liquidity;\r\n    uint256[] lastSumRewardPerLiquidity;\r\n    uint256[] rewardUnclaimed;\r\n  }\r\n\r\n  // ======== user ============\r\n  /// @dev deposit nfts to farm\r\n  /// @dev store curRewardPerLiq now to stake info, mint an amount of farmingToken (if needed) to msg.sender\r\n  /// @param fId farm's id\r\n  /// @param rangeId rangeId to add, should use quoter to get best APR rangeId\r\n  /// @param nftIds nfts to deposit\r\n  function deposit(\r\n    uint256 fId,\r\n    uint256 rangeId,\r\n    uint256[] memory nftIds,\r\n    address receiver\r\n  ) external;\r\n\r\n  /// @dev claim reward earned for nfts\r\n  /// @param fId farm's id\r\n  /// @param nftIds nfts to claim\r\n  function claimReward(uint256 fId, uint256[] memory nftIds) external;\r\n\r\n  /// @dev withdraw nfts from farm\r\n  /// @dev only can call by nfts's owner, also claim reward earned\r\n  /// @dev burn an amount of farmingToken (if needed) from msg.sender\r\n  /// @param fId farm's id\r\n  /// @param nftIds nfts to withdraw\r\n  function withdraw(uint256 fId, uint256[] memory nftIds) external;\r\n\r\n  /// @dev add liquidity of nfts when liquidity already added on Elastic Pool\r\n  /// @dev only can call by nfts's owner\r\n  /// @dev calculate reward earned, update stakeInfo, mint an amount of farmingToken to msg.sender\r\n  /// @param fId farm's id\r\n  /// @param rangeId rangeId of deposited nfts\r\n  /// @param nftIds nfts to add liquidity\r\n  function addLiquidity(uint256 fId, uint256 rangeId, uint256[] calldata nftIds) external;\r\n\r\n  /// @dev remove liquidity of nfts from Elastic Pool\r\n  /// @dev only can call by nfts's owner\r\n  /// @dev calculate reward earned, update stakeInfo, mint/burn an amount of farmingToken\r\n  /// @param nftId id of nft to remove liquidity\r\n  /// @param liquidity amount to remove from nft\r\n  /// @param amount0Min min amount of token0 should receive\r\n  /// @param amount1Min min amount of token1 should receive\r\n  /// @param deadline deadline of remove liquidity tx\r\n  /// @param isClaimFee is also burnRTokens or not\r\n  function removeLiquidity(\r\n    uint256 nftId,\r\n    uint128 liquidity,\r\n    uint256 amount0Min,\r\n    uint256 amount1Min,\r\n    uint256 deadline,\r\n    bool isClaimFee,\r\n    bool isReceiveNative\r\n  ) external;\r\n\r\n  /// @dev claim fee from Elastic Pool\r\n  /// @dev only can call by nfts's owner\r\n  /// @param fId farm's id\r\n  /// @param nftIds nfts to claim\r\n  /// @param amount0Min min amount of token0 should receive\r\n  /// @param amount1Min min amount of token1 should receive\r\n  /// @param deadline deadline of remove liquidity tx\r\n  function claimFee(\r\n    uint256 fId,\r\n    uint256[] calldata nftIds,\r\n    uint256 amount0Min,\r\n    uint256 amount1Min,\r\n    uint256 deadline,\r\n    bool isReceiveNative\r\n  ) external;\r\n\r\n  /// @dev withdraw nfts in case emergency\r\n  /// @dev only can call by nfts's owner\r\n  /// @dev in normal case, abandon all rewards, must return farmingToken\r\n  /// @dev incase emergencyEnabled, bypass all calculation\r\n  /// @param nftIds nfts to withdraw\r\n  function withdrawEmergency(uint256[] calldata nftIds) external;\r\n\r\n  // ======== view ============\r\n  function getNft() external view returns (IERC721);\r\n\r\n  function getFarm(\r\n    uint256 fId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      address poolAddress,\r\n      RangeInfo[] memory ranges,\r\n      PhaseInfo memory phase,\r\n      uint256 liquidity,\r\n      address farmingToken,\r\n      uint256[] memory sumRewardPerLiquidity,\r\n      uint32 lastTouchedTime\r\n    );\r\n\r\n  function getDepositedNFTs(address user) external view returns (uint256[] memory listNFTs);\r\n\r\n  function getStake(\r\n    uint256 nftId\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      address owner,\r\n      uint256 fId,\r\n      uint256 rangeId,\r\n      uint256 liquidity,\r\n      uint256[] memory lastSumRewardPerLiquidity,\r\n      uint256[] memory rewardUnclaimeds\r\n    );\r\n}\r\n\r\n/// @title KyberSwap v2 factory\r\n/// @notice Deploys KyberSwap v2 pools and manages control over government fees\r\ninterface IFactory {\r\n  /// @notice Emitted when a pool is created\r\n  /// @param token0 First pool token by address sort order\r\n  /// @param token1 Second pool token by address sort order\r\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\r\n  /// @param tickDistance Minimum number of ticks between initialized ticks\r\n  /// @param pool The address of the created pool\r\n  event PoolCreated(\r\n    address indexed token0,\r\n    address indexed token1,\r\n    uint16 indexed swapFeeBps,\r\n    int24 tickDistance,\r\n    address pool\r\n  );\r\n\r\n  /// @notice Emitted when a new fee is enabled for pool creation via the factory\r\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\r\n  /// @param tickDistance Minimum number of ticks between initialized ticks for pools created with the given fee\r\n  event SwapFeeEnabled(uint16 indexed swapFeeBps, int24 indexed tickDistance);\r\n\r\n  /// @notice Emitted when vesting period changes\r\n  /// @param vestingPeriod The maximum time duration for which LP fees\r\n  /// are proportionally burnt upon LP removals\r\n  event VestingPeriodUpdated(uint32 vestingPeriod);\r\n\r\n  /// @notice Emitted when configMaster changes\r\n  /// @param oldConfigMaster configMaster before the update\r\n  /// @param newConfigMaster configMaster after the update\r\n  event ConfigMasterUpdated(address oldConfigMaster, address newConfigMaster);\r\n\r\n  /// @notice Emitted when fee configuration changes\r\n  /// @param feeTo Recipient of government fees\r\n  /// @param governmentFeeBps Fee amount, in basis points,\r\n  /// to be collected out of the fee charged for a pool swap\r\n  event FeeConfigurationUpdated(address feeTo, uint16 governmentFeeBps);\r\n\r\n  /// @notice Emitted when whitelist feature is enabled\r\n  event WhitelistEnabled();\r\n\r\n  /// @notice Emitted when whitelist feature is disabled\r\n  event WhitelistDisabled();\r\n\r\n  /// @notice Returns the maximum time duration for which LP fees\r\n  /// are proportionally burnt upon LP removals\r\n  function vestingPeriod() external view returns (uint32);\r\n\r\n  /// @notice Returns the tick distance for a specified fee.\r\n  /// @dev Once added, cannot be updated or removed.\r\n  /// @param swapFeeBps Swap fee, in basis points.\r\n  /// @return The tick distance. Returns 0 if fee has not been added.\r\n  function feeAmountTickDistance(uint16 swapFeeBps) external view returns (int24);\r\n\r\n  /// @notice Returns the address which can update the fee configuration\r\n  function configMaster() external view returns (address);\r\n\r\n  /// @notice Returns the keccak256 hash of the Pool creation code\r\n  /// This is used for pre-computation of pool addresses\r\n  function poolInitHash() external view returns (bytes32);\r\n\r\n  /// @notice Fetches the recipient of government fees\r\n  /// and current government fee charged in basis points\r\n  function feeConfiguration() external view returns (address _feeTo, uint16 _governmentFeeBps);\r\n\r\n  /// @notice Returns the status of whitelisting feature of NFT managers\r\n  /// If true, anyone can mint liquidity tokens\r\n  /// Otherwise, only whitelisted NFT manager(s) are allowed to mint liquidity tokens\r\n  function whitelistDisabled() external view returns (bool);\r\n\r\n  //// @notice Returns all whitelisted NFT managers\r\n  /// If the whitelisting feature is turned on,\r\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\r\n  function getWhitelistedNFTManagers() external view returns (address[] memory);\r\n\r\n  /// @notice Checks if sender is a whitelisted NFT manager\r\n  /// If the whitelisting feature is turned on,\r\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\r\n  /// @param sender address to be checked\r\n  /// @return true if sender is a whistelisted NFT manager, false otherwise\r\n  function isWhitelistedNFTManager(address sender) external view returns (bool);\r\n\r\n  /// @notice Returns the pool address for a given pair of tokens and a swap fee\r\n  /// @dev Token order does not matter\r\n  /// @param tokenA Contract address of either token0 or token1\r\n  /// @param tokenB Contract address of the other token\r\n  /// @param swapFeeBps Fee to be collected upon every swap in the pool, in basis points\r\n  /// @return pool The pool address. Returns null address if it does not exist\r\n  function getPool(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint16 swapFeeBps\r\n  ) external view returns (address pool);\r\n\r\n  /// @notice Fetch parameters to be used for pool creation\r\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\r\n  /// @return factory The factory address\r\n  /// @return token0 First pool token by address sort order\r\n  /// @return token1 Second pool token by address sort order\r\n  /// @return swapFeeBps Fee to be collected upon every swap in the pool, in basis points\r\n  /// @return tickDistance Minimum number of ticks between initialized ticks\r\n  function parameters()\r\n    external\r\n    view\r\n    returns (\r\n      address factory,\r\n      address token0,\r\n      address token1,\r\n      uint16 swapFeeBps,\r\n      int24 tickDistance\r\n    );\r\n\r\n  /// @notice Creates a pool for the given two tokens and fee\r\n  /// @param tokenA One of the two tokens in the desired pool\r\n  /// @param tokenB The other of the two tokens in the desired pool\r\n  /// @param swapFeeBps Desired swap fee for the pool, in basis points\r\n  /// @dev Token order does not matter. tickDistance is determined from the fee.\r\n  /// Call will revert under any of these conditions:\r\n  ///     1) pool already exists\r\n  ///     2) invalid swap fee\r\n  ///     3) invalid token arguments\r\n  /// @return pool The address of the newly created pool\r\n  function createPool(\r\n    address tokenA,\r\n    address tokenB,\r\n    uint16 swapFeeBps\r\n  ) external returns (address pool);\r\n\r\n  /// @notice Enables a fee amount with the given tickDistance\r\n  /// @dev Fee amounts may never be removed once enabled\r\n  /// @param swapFeeBps The fee amount to enable, in basis points\r\n  /// @param tickDistance The distance between ticks to be enforced for all pools created with the given fee amount\r\n  function enableSwapFee(uint16 swapFeeBps, int24 tickDistance) external;\r\n\r\n  /// @notice Updates the address which can update the fee configuration\r\n  /// @dev Must be called by the current configMaster\r\n  function updateConfigMaster(address) external;\r\n\r\n  /// @notice Updates the vesting period\r\n  /// @dev Must be called by the current configMaster\r\n  function updateVestingPeriod(uint32) external;\r\n\r\n  /// @notice Updates the address receiving government fees and fee quantity\r\n  /// @dev Only configMaster is able to perform the update\r\n  /// @param feeTo Address to receive government fees collected from pools\r\n  /// @param governmentFeeBps Fee amount, in basis points,\r\n  /// to be collected out of the fee charged for a pool swap\r\n  function updateFeeConfiguration(address feeTo, uint16 governmentFeeBps) external;\r\n\r\n  /// @notice Enables the whitelisting feature\r\n  /// @dev Only configMaster is able to perform the update\r\n  function enableWhitelist() external;\r\n\r\n  /// @notice Disables the whitelisting feature\r\n  /// @dev Only configMaster is able to perform the update\r\n  function disableWhitelist() external;\r\n}\r\n\r\ninterface IPoolStorage {\r\n  struct PoolData {\r\n    uint160 sqrtP;\r\n    int24 nearestCurrentTick;\r\n    int24 currentTick;\r\n    bool locked;\r\n    uint128 baseL;\r\n    uint128 reinvestL;\r\n    uint128 reinvestLLast;\r\n    uint256 feeGrowthGlobal;\r\n    uint128 secondsPerLiquidityGlobal;\r\n    uint32 secondsPerLiquidityUpdateTime;\r\n  }\r\n\r\n  // data stored for each initialized individual tick\r\n  struct TickData {\r\n    // gross liquidity of all positions in tick\r\n    uint128 liquidityGross;\r\n    // liquidity quantity to be added | removed when tick is crossed up | down\r\n    int128 liquidityNet;\r\n    // fee growth per unit of liquidity on the other side of this tick (relative to current tick)\r\n    // only has relative meaning, not absolute \u2014 the value depends on when the tick is initialized\r\n    uint256 feeGrowthOutside;\r\n    // seconds spent on the other side of this tick (relative to current tick)\r\n    // only has relative meaning, not absolute \u2014 the value depends on when the tick is initialized\r\n    uint128 secondsPerLiquidityOutside;\r\n  }\r\n\r\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\r\n  /// @return The contract address\r\n  function factory() external view returns (IFactory);\r\n\r\n  /// @notice The first of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token0() external view returns (IERC20);\r\n\r\n  /// @notice The second of the two tokens of the pool, sorted by address\r\n  /// @return The token contract address\r\n  function token1() external view returns (IERC20);\r\n\r\n  /// @notice The fee to be charged for a swap in basis points\r\n  /// @return The swap fee in basis points\r\n  function swapFeeBps() external view returns (uint16);\r\n\r\n  /// @notice The pool tick distance\r\n  /// @dev Ticks can only be initialized and used at multiples of this value\r\n  /// It remains an int24 to avoid casting even though it is >= 1.\r\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\r\n  /// @return The tick distance\r\n  function tickDistance() external view returns (int24);\r\n\r\n  /// @notice Maximum gross liquidity that an initialized tick can have\r\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\r\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\r\n  /// @return The max amount of liquidity per tick\r\n  function maxTickLiquidity() external view returns (uint128);\r\n\r\n  /// @notice Look up information about a specific tick in the pool\r\n  /// @param tick The tick to look up\r\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\r\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\r\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\r\n  /// secondsPerLiquidityOutside the seconds spent on the other side of the tick relative to the current tick\r\n  function ticks(\r\n    int24 tick\r\n  )\r\n    external\r\n    view\r\n    returns (\r\n      uint128 liquidityGross,\r\n      int128 liquidityNet,\r\n      uint256 feeGrowthOutside,\r\n      uint128 secondsPerLiquidityOutside\r\n    );\r\n\r\n  /// @notice Returns the previous and next initialized ticks of a specific tick\r\n  /// @dev If specified tick is uninitialized, the returned values are zero.\r\n  /// @param tick The tick to look up\r\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\r\n\r\n  /// @notice Returns the information about a position by the position's key\r\n  /// @return liquidity the liquidity quantity of the position\r\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\r\n  function getPositions(\r\n    address owner,\r\n    int24 tickLower,\r\n    int24 tickUpper\r\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\r\n\r\n  /// @notice Fetches the pool's prices, ticks and lock status\r\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\r\n  /// @return currentTick pool's current tick\r\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\r\n  /// @return locked true if pool is locked, false otherwise\r\n  function getPoolState()\r\n    external\r\n    view\r\n    returns (uint160 sqrtP, int24 currentTick, int24 nearestCurrentTick, bool locked);\r\n\r\n  /// @notice Fetches the pool's liquidity values\r\n  /// @return baseL pool's base liquidity without reinvest liqudity\r\n  /// @return reinvestL the liquidity is reinvested into the pool\r\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\r\n  function getLiquidityState()\r\n    external\r\n    view\r\n    returns (uint128 baseL, uint128 reinvestL, uint128 reinvestLLast);\r\n\r\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\r\n  function getFeeGrowthGlobal() external view returns (uint256);\r\n\r\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\r\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\r\n  function getSecondsPerLiquidityData()\r\n    external\r\n    view\r\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\r\n\r\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\r\n  /// @param tickLower The lower tick (of a position)\r\n  /// @param tickUpper The upper tick (of a position)\r\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\r\n  /// between the 2 ticks, per unit of liquidity.\r\n  function getSecondsPerLiquidityInside(\r\n    int24 tickLower,\r\n    int24 tickUpper\r\n  ) external view returns (uint128 secondsPerLiquidityInside);\r\n}\r\n\r\ncontract KSElasticLMV2 is IKSElasticLMV2, KSAdmin, ReentrancyGuard {\r\n  using EnumerableSet for EnumerableSet.UintSet;\r\n\r\n  address private constant ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n\r\n  IERC721 private immutable nft;\r\n  IKSElasticLMHelper private helper;\r\n  address public immutable weth;\r\n\r\n  bytes private farmingTokenCreationCode;\r\n  mapping(uint256 => FarmInfo) private farms; // fId => FarmInfo\r\n  mapping(uint256 => StakeInfo) private stakes; // sId => stakeInfo\r\n  mapping(address => EnumerableSet.UintSet) private depositNFTs;\r\n\r\n  uint256 public farmCount;\r\n  bool public emergencyEnabled;\r\n\r\n  constructor(IERC721 _nft, IKSElasticLMHelper _helper) {\r\n    nft = _nft;\r\n    helper = _helper;\r\n    weth = IBasePositionManager(address(_nft)).WETH();\r\n  }\r\n\r\n  receive() external payable {}\r\n\r\n  // ======== admin ============\r\n\r\n  //enable emergency mode\r\n  function updateEmergency(bool enableOrDisable) external isAdmin {\r\n    emergencyEnabled = enableOrDisable;\r\n\r\n    emit UpdateEmergency(enableOrDisable);\r\n  }\r\n\r\n  //update farming token creationCode, use to deploy when add farm\r\n  function updateTokenCode(bytes memory _farmingTokenCreationCode) external isAdmin {\r\n    farmingTokenCreationCode = _farmingTokenCreationCode;\r\n\r\n    emit UpdateTokenCode(_farmingTokenCreationCode);\r\n  }\r\n\r\n  //update helper contract, use to gather information from elastic\r\n  function updateHelper(IKSElasticLMHelper _helper) external isAdmin {\r\n    helper = _helper;\r\n\r\n    emit UpdateHelper(_helper);\r\n  }\r\n\r\n  //withdraw leftover rewards from contract\r\n  function withdrawUnusedRewards(\r\n    address[] calldata tokens,\r\n    uint256[] calldata amounts\r\n  ) external isAdmin {\r\n    uint256 rewardTokenLength = tokens.length;\r\n    for (uint256 i; i < rewardTokenLength; ) {\r\n      _safeTransfer(tokens[i], msg.sender, amounts[i]);\r\n      emit WithdrawUnusedRewards(tokens[i], amounts[i], msg.sender);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  //add a new farm\r\n  function addFarm(\r\n    address poolAddress,\r\n    RangeInput[] calldata ranges,\r\n    PhaseInput calldata phase,\r\n    bool isUsingToken\r\n  ) external isOperator returns (uint256 fId) {\r\n    //new farm id would be current farmCount\r\n    fId = farmCount;\r\n    FarmInfo storage farm = farms[fId];\r\n\r\n    //validate phase input\r\n    _isPhaseValid(phase);\r\n\r\n    for (uint256 i; i < ranges.length; ) {\r\n      //validate range input\r\n      _isRangeValid(ranges[i]);\r\n\r\n      //push range into farm ranges array\r\n      farm.ranges.push(\r\n        IKSElasticLMV2.RangeInfo({\r\n          tickLower: ranges[i].tickLower,\r\n          tickUpper: ranges[i].tickUpper,\r\n          weight: ranges[i].weight,\r\n          isRemoved: false\r\n        })\r\n      );\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    //update farm data\r\n    farm.poolAddress = poolAddress;\r\n    farm.phase.startTime = phase.startTime;\r\n    farm.phase.endTime = phase.endTime;\r\n\r\n    for (uint256 i; i < phase.rewards.length; ) {\r\n      //push rewards info to farm phase rewards array\r\n      farm.phase.rewards.push(phase.rewards[i]);\r\n\r\n      //sumReward of newly created farm would be, this sumReward is total reward per liquidity until now\r\n      farm.sumRewardPerLiquidity.push(0);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    //deploy farmingToken if needed\r\n    address destination;\r\n    if (isUsingToken) {\r\n      bytes memory creationCode = farmingTokenCreationCode;\r\n      bytes32 salt = keccak256(abi.encode(msg.sender, fId));\r\n      assembly {\r\n        destination := create2(0, add(creationCode, 32), mload(creationCode), salt)\r\n        if iszero(extcodesize(destination)) {\r\n          revert(0, 0)\r\n        }\r\n      }\r\n\r\n      farm.farmingToken = destination;\r\n    }\r\n\r\n    //last touched time would be startTime\r\n    farm.lastTouchedTime = phase.startTime;\r\n\r\n    //increase farmCount\r\n    unchecked {\r\n      ++farmCount;\r\n    }\r\n\r\n    emit AddFarm(fId, poolAddress, ranges, phase, destination);\r\n  }\r\n\r\n  function addPhase(uint256 fId, PhaseInput calldata phaseInput) external isOperator {\r\n    if (fId >= farmCount) revert InvalidFarm();\r\n\r\n    //validate phase input\r\n    _isPhaseValid(phaseInput);\r\n\r\n    PhaseInfo storage phase = farms[fId].phase;\r\n\r\n    uint256 length = phase.rewards.length;\r\n    if (phaseInput.rewards.length != length) revert InvalidInput();\r\n\r\n    //if phase not settled, update sumReward.\r\n    //if phase already settled then it's not needed since sumReward would be unchanged\r\n    if (!phase.isSettled) _updateFarmSumRewardPerLiquidity(fId);\r\n\r\n    //override phase data with new data\r\n    phase.startTime = phaseInput.startTime;\r\n    phase.endTime = phaseInput.endTime;\r\n\r\n    for (uint256 i; i < length; ) {\r\n      //new phase rewards must be the same as old phase\r\n      if (phase.rewards[i].rewardToken != phaseInput.rewards[i].rewardToken)\r\n        revert InvalidReward();\r\n\r\n      //update reward amounts\r\n      phase.rewards[i].rewardAmount = phaseInput.rewards[i].rewardAmount;\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    //newly add phase must is not settled\r\n    if (phase.isSettled) phase.isSettled = false;\r\n\r\n    //set farm lastTouchedTime to startTime\r\n    farms[fId].lastTouchedTime = phaseInput.startTime;\r\n\r\n    emit AddPhase(fId, phaseInput);\r\n  }\r\n\r\n  function forceClosePhase(uint256 fId) external isOperator {\r\n    if (fId >= farmCount) revert InvalidFarm();\r\n\r\n    if (farms[fId].phase.isSettled) revert PhaseSettled();\r\n\r\n    //update sumReward\r\n    _updateFarmSumRewardPerLiquidity(fId);\r\n\r\n    //close phase so settled must be true\r\n    if (!farms[fId].phase.isSettled) farms[fId].phase.isSettled = true;\r\n\r\n    emit ForceClosePhase(fId);\r\n  }\r\n\r\n  function addRange(uint256 fId, RangeInput calldata range) external isOperator {\r\n    if (fId >= farmCount) revert InvalidFarm();\r\n    _isRangeValid(range);\r\n\r\n    //add a new range into farm ranges array\r\n    farms[fId].ranges.push(\r\n      IKSElasticLMV2.RangeInfo({\r\n        tickLower: range.tickLower,\r\n        tickUpper: range.tickUpper,\r\n        weight: range.weight,\r\n        isRemoved: false\r\n      })\r\n    );\r\n\r\n    emit AddRange(fId, range);\r\n  }\r\n\r\n  function removeRange(uint256 fId, uint256 rangeId) external isOperator {\r\n    if (fId >= farmCount) revert InvalidFarm();\r\n    if (rangeId >= farms[fId].ranges.length || farms[fId].ranges[rangeId].isRemoved)\r\n      revert RangeNotFound();\r\n\r\n    //remove a range aka set isRemoved to true, it's still be in ranges array but cannot deposit to this range anymore\r\n    farms[fId].ranges[rangeId].isRemoved = true;\r\n\r\n    emit RemoveRange(fId, rangeId);\r\n  }\r\n\r\n  function activateRange(uint256 fId, uint256 rangeId) external isOperator {\r\n    if (fId >= farmCount) revert InvalidFarm();\r\n    if (rangeId >= farms[fId].ranges.length || !farms[fId].ranges[rangeId].isRemoved)\r\n      revert RangeNotFound();\r\n\r\n    //activate a removed range aka set isRemoved to false, this range can deposit now\r\n    farms[fId].ranges[rangeId].isRemoved = false;\r\n\r\n    emit ActivateRange(fId, rangeId);\r\n  }\r\n\r\n  // ======== user ============\r\n  /// @inheritdoc IKSElasticLMV2\r\n  function deposit(\r\n    uint256 fId,\r\n    uint256 rangeId,\r\n    uint256[] calldata nftIds,\r\n    address receiver\r\n  ) external override nonReentrant {\r\n    _isAddLiquidityValid(fId, rangeId);\r\n\r\n    //check positions meet farm requirements\r\n    (bool isInvalid, uint128[] memory nftLiquidities) = _checkPosition(\r\n      farms[fId].poolAddress,\r\n      farms[fId].ranges[rangeId].tickLower,\r\n      farms[fId].ranges[rangeId].tickUpper,\r\n      nftIds\r\n    );\r\n\r\n    if (isInvalid) revert PositionNotEligible();\r\n\r\n    //calculate lastest farm sumReward\r\n    uint256[] memory curSumRewardPerLiquidity = _updateFarmSumRewardPerLiquidity(fId);\r\n    uint32 weight = farms[fId].ranges[rangeId].weight;\r\n    uint256 rewardLength = farms[fId].phase.rewards.length;\r\n    uint256 totalLiquidity;\r\n\r\n    //loop through list nftLength\r\n    for (uint256 i; i < nftIds.length; ) {\r\n      uint256 liquidityWithWeight = nftLiquidities[i];\r\n      liquidityWithWeight = liquidityWithWeight * weight;\r\n\r\n      //transfer nft to farm, add to list deposited nfts\r\n      nft.transferFrom(msg.sender, address(this), nftIds[i]);\r\n      if (!depositNFTs[receiver].add(nftIds[i])) revert FailToAdd();\r\n\r\n      //create stake info\r\n      StakeInfo storage stake = stakes[nftIds[i]];\r\n      stake.owner = receiver;\r\n      stake.fId = fId;\r\n      stake.rangeId = rangeId;\r\n      stake.liquidity = liquidityWithWeight;\r\n\r\n      for (uint256 j; j < rewardLength; ) {\r\n        stakes[nftIds[i]].lastSumRewardPerLiquidity.push(curSumRewardPerLiquidity[j]);\r\n        stakes[nftIds[i]].rewardUnclaimed.push(0);\r\n\r\n        unchecked {\r\n          ++j;\r\n        }\r\n      }\r\n\r\n      totalLiquidity += liquidityWithWeight;\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    //update farm total liquidity\r\n    farms[fId].liquidity += totalLiquidity;\r\n\r\n    //mint farmingToken equals to stake liquidity\r\n    address farmingToken = farms[fId].farmingToken;\r\n    if (farmingToken != address(0)) _mintFarmingToken(farmingToken, receiver, totalLiquidity);\r\n\r\n    emit Deposit(fId, rangeId, nftIds, msg.sender, receiver);\r\n  }\r\n\r\n  /// @inheritdoc IKSElasticLMV2\r\n  function claimReward(uint256 fId, uint256[] calldata nftIds) external override nonReentrant {\r\n    _claimReward(fId, nftIds, msg.sender);\r\n  }\r\n\r\n  /// @inheritdoc IKSElasticLMV2\r\n  function withdraw(uint256 fId, uint256[] calldata nftIds) external override nonReentrant {\r\n    _claimReward(fId, nftIds, msg.sender);\r\n\r\n    uint256 length = nftIds.length;\r\n    uint256 totalLiq;\r\n\r\n    //loop through list nfts\r\n    for (uint256 i; i < length; ) {\r\n      totalLiq += stakes[nftIds[i]].liquidity;\r\n\r\n      //remove stake\r\n      delete stakes[nftIds[i]];\r\n      if (!depositNFTs[msg.sender].remove(nftIds[i])) revert FailToRemove();\r\n\r\n      //transfer back nft to user\r\n      nft.transferFrom(address(this), msg.sender, nftIds[i]);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    //update farm total liquidity\r\n    farms[fId].liquidity -= totalLiq;\r\n\r\n    //burn an a mount of farmingToken from msg.sender\r\n    if (farms[fId].farmingToken != address(0))\r\n      _burnFarmingToken(farms[fId].farmingToken, msg.sender, totalLiq);\r\n\r\n    emit Withdraw(nftIds, msg.sender);\r\n  }\r\n\r\n  /// @inheritdoc IKSElasticLMV2\r\n  function addLiquidity(\r\n    uint256 fId,\r\n    uint256 rangeId,\r\n    uint256[] memory nftIds\r\n  ) external override nonReentrant {\r\n    _isAddLiquidityValid(fId, rangeId);\r\n\r\n    uint256 length = nftIds.length;\r\n    uint32 weight = farms[fId].ranges[rangeId].weight;\r\n\r\n    for (uint256 i; i < length; ) {\r\n      _isStakeValidForAddLiquidity(fId, rangeId, nftIds[i]);\r\n\r\n      //get liq from elastic\r\n      uint256 posLiq = _getLiquidity(nftIds[i]);\r\n      uint256 curLiq = stakes[nftIds[i]].liquidity;\r\n      uint256 newLiq = posLiq * weight;\r\n\r\n      //only update stake liquidity if newLiq > curLiq, ignore if liquidity is the same\r\n      if (newLiq > curLiq) _updateLiquidity(fId, nftIds[i], newLiq, msg.sender);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @inheritdoc IKSElasticLMV2\r\n  function removeLiquidity(\r\n    uint256 nftId,\r\n    uint128 liquidity,\r\n    uint256 amount0Min,\r\n    uint256 amount1Min,\r\n    uint256 deadline,\r\n    bool isClaimFee,\r\n    bool isReceiveNative\r\n  ) external override nonReentrant {\r\n    if (block.timestamp > deadline) revert Expired();\r\n    if (stakes[nftId].owner != msg.sender) revert NotOwner();\r\n\r\n    //get liq from elastic\r\n    uint256 posLiq = _getLiquidity(nftId);\r\n    if (liquidity == 0 || liquidity > posLiq) revert InvalidInput();\r\n\r\n    //call to posManager to remove liquidity for position, also claim lp fee if needed\r\n    _removeLiquidity(nftId, liquidity, deadline);\r\n    if (isClaimFee) _claimFee(nftId, deadline, false);\r\n\r\n    //calculate new liquidity after remove\r\n    posLiq = posLiq - liquidity;\r\n\r\n    uint256 fId = stakes[nftId].fId;\r\n    uint256 curLiq = stakes[nftId].liquidity;\r\n    uint256 newLiq = posLiq * farms[fId].ranges[stakes[nftId].rangeId].weight;\r\n\r\n    //update liquidity if new liquidity < cur liquidity, ignore case where new liquidity >= cur liquidity\r\n    if (newLiq < curLiq) _updateLiquidity(fId, nftId, newLiq, msg.sender);\r\n\r\n    //transfer tokens from posManager to user\r\n    _transferTokens(farms[fId].poolAddress, amount0Min, amount1Min, msg.sender, isReceiveNative);\r\n  }\r\n\r\n  /// @inheritdoc IKSElasticLMV2\r\n  function claimFee(\r\n    uint256 fId,\r\n    uint256[] calldata nftIds,\r\n    uint256 amount0Min,\r\n    uint256 amount1Min,\r\n    uint256 deadline,\r\n    bool isReceiveNative\r\n  ) external override nonReentrant {\r\n    if (block.timestamp > deadline) revert Expired();\r\n\r\n    uint256 length = nftIds.length;\r\n    for (uint256 i; i < length; ) {\r\n      _isStakeValid(fId, nftIds[i]);\r\n\r\n      //call to posManager to claim fee\r\n      _claimFee(nftIds[i], deadline, true);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    //transfer tokens from posManager to user\r\n    _transferTokens(farms[fId].poolAddress, amount0Min, amount1Min, msg.sender, isReceiveNative);\r\n  }\r\n\r\n  /// @inheritdoc IKSElasticLMV2\r\n  function withdrawEmergency(uint256[] calldata nftIds) external override {\r\n    uint256 length = nftIds.length;\r\n    for (uint256 i; i < length; ) {\r\n      uint256 nftId = nftIds[i];\r\n      StakeInfo memory stake = stakes[nftId];\r\n\r\n      if (stake.owner != msg.sender) revert NotOwner();\r\n\r\n      //if emerency mode is not enable\r\n      if (!emergencyEnabled) {\r\n        address farmingToken = farms[stake.fId].farmingToken;\r\n        uint256 liquidity = stake.liquidity;\r\n\r\n        //burn farmingToken from msg.sender if stake liquidity greater than 0\r\n        if (farmingToken != address(0) && liquidity != 0)\r\n          _burnFarmingToken(farmingToken, stake.owner, liquidity);\r\n\r\n        //remove nft from deposited nft list\r\n        if (!depositNFTs[stake.owner].remove(nftId)) revert FailToRemove();\r\n\r\n        //update farm total liquidity\r\n        farms[stake.fId].liquidity -= liquidity;\r\n      }\r\n\r\n      //remove stake and transfer back nft to user, always do this even emergency enable or disable\r\n      delete stakes[nftId];\r\n      nft.transferFrom(address(this), stake.owner, nftId);\r\n\r\n      emit WithdrawEmergency(nftId, stake.owner);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  // ======== getter ============\r\n  function getNft() external view override returns (IERC721) {\r\n    return nft;\r\n  }\r\n\r\n  function getFarm(\r\n    uint256 fId\r\n  )\r\n    external\r\n    view\r\n    override\r\n    returns (\r\n      address poolAddress,\r\n      RangeInfo[] memory ranges,\r\n      PhaseInfo memory phase,\r\n      uint256 liquidity,\r\n      address farmingToken,\r\n      uint256[] memory sumRewardPerLiquidity,\r\n      uint32 lastTouchedTime\r\n    )\r\n  {\r\n    return (\r\n      farms[fId].poolAddress,\r\n      farms[fId].ranges,\r\n      farms[fId].phase,\r\n      farms[fId].liquidity,\r\n      farms[fId].farmingToken,\r\n      farms[fId].sumRewardPerLiquidity,\r\n      farms[fId].lastTouchedTime\r\n    );\r\n  }\r\n\r\n  function getDepositedNFTs(address user) external view returns (uint256[] memory listNFTs) {\r\n    listNFTs = depositNFTs[user].values();\r\n  }\r\n\r\n  function getStake(\r\n    uint256 nftId\r\n  )\r\n    external\r\n    view\r\n    override\r\n    returns (\r\n      address owner,\r\n      uint256 fId,\r\n      uint256 rangeId,\r\n      uint256 liquidity,\r\n      uint256[] memory lastSumRewardPerLiquidity,\r\n      uint256[] memory rewardUnclaimed\r\n    )\r\n  {\r\n    return (\r\n      stakes[nftId].owner,\r\n      stakes[nftId].fId,\r\n      stakes[nftId].rangeId,\r\n      stakes[nftId].liquidity,\r\n      stakes[nftId].lastSumRewardPerLiquidity,\r\n      stakes[nftId].rewardUnclaimed\r\n    );\r\n  }\r\n\r\n  // ======== internal ============\r\n  /// @dev claim reward for nfts\r\n  /// @param fId farm's id\r\n  /// @param nftIds nfts for claim reward\r\n  /// @param receiver reward receiver also msgSender\r\n  function _claimReward(uint256 fId, uint256[] memory nftIds, address receiver) internal {\r\n    uint256 nftLength = nftIds.length;\r\n\r\n    //validate list of nft valid or not\r\n    for (uint256 i; i < nftLength; ) {\r\n      _isStakeValid(fId, nftIds[i]);\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    //update rewards for all nfts\r\n    _updateRewardInfos(fId, nftIds);\r\n\r\n    //accumulate rewards from stakes and transfer at once\r\n    uint256 rewardLength = farms[fId].phase.rewards.length;\r\n    uint256[] memory rewardAmounts = new uint256[](rewardLength);\r\n    for (uint256 i; i < nftLength; ) {\r\n      for (uint256 j; j < rewardLength; ) {\r\n        rewardAmounts[j] += stakes[nftIds[i]].rewardUnclaimed[j];\r\n        stakes[nftIds[i]].rewardUnclaimed[j] = 0;\r\n\r\n        unchecked {\r\n          ++j;\r\n        }\r\n      }\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n\r\n    //transfer rewards\r\n    for (uint256 i; i < rewardLength; ) {\r\n      address token = farms[fId].phase.rewards[i].rewardToken;\r\n\r\n      if (rewardAmounts[i] != 0) {\r\n        _safeTransfer(token, receiver, rewardAmounts[i]);\r\n      }\r\n\r\n      emit ClaimReward(fId, nftIds, token, rewardAmounts[i], receiver);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  function _updateLiquidity(\r\n    uint256 fId,\r\n    uint256 nftId,\r\n    uint256 newLiq,\r\n    address receiver\r\n  ) internal {\r\n    //update farm sumReward\r\n    uint256[] memory curSumRewardPerLiquidities = _updateFarmSumRewardPerLiquidity(fId);\r\n    uint256 curLiq = stakes[nftId].liquidity;\r\n\r\n    //update stake rewards base on lastest sumReward\r\n    _updateRewardInfo(nftId, curLiq, curSumRewardPerLiquidities);\r\n\r\n    address farmingToken = farms[fId].farmingToken;\r\n\r\n    //mint/burn farmingToken base on the difference between newLiq/curLiq. there is no case that newLiq == curLiq\r\n    if (farmingToken != address(0)) {\r\n      if (newLiq > curLiq) {\r\n        _mintFarmingToken(farmingToken, receiver, newLiq - curLiq);\r\n      } else {\r\n        _burnFarmingToken(farmingToken, receiver, curLiq - newLiq);\r\n      }\r\n    }\r\n\r\n    //update stake liquidity, farm total liquidity\r\n    stakes[nftId].liquidity = newLiq;\r\n    farms[fId].liquidity = farms[fId].liquidity + newLiq - curLiq;\r\n\r\n    emit UpdateLiquidity(fId, nftId, newLiq);\r\n  }\r\n\r\n  /// @dev update rewardInfo for multiple stakes\r\n  /// @param nftIds nfts to update\r\n  function _updateRewardInfos(uint256 fId, uint256[] memory nftIds) internal {\r\n    uint256[] memory curSumRewardPerLiquidities = _updateFarmSumRewardPerLiquidity(fId);\r\n    uint256 length = nftIds.length;\r\n    for (uint256 i; i < length; ) {\r\n      _updateRewardInfo(nftIds[i], stakes[nftIds[i]].liquidity, curSumRewardPerLiquidities);\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev calculate and update rewardUnclaimed, lastSumRewardPerLiquidity for a single position\r\n  /// @dev rewardAmount = (sumRewardPerLiq - lastSumRewardPerLiq) * stake.liquidiy\r\n  /// @dev if transferRewardUnclaimed =  true then transfer all rewardUnclaimed, update rewardUnclaimed = 0\r\n  /// @dev if transferRewardUnclaimed =  false then update rewardUnclaimed = rewardUnclaimed + rewardAmount\r\n  /// @dev update lastSumRewardPerLiquidity\r\n  /// @param nftId nft's id to update\r\n  /// @param liquidity current staked liquidity\r\n  /// @param curSumRewardPerLiquidities current sumRewardPerLiquidities of farm, indexing by reward\r\n  function _updateRewardInfo(\r\n    uint256 nftId,\r\n    uint256 liquidity,\r\n    uint256[] memory curSumRewardPerLiquidities\r\n  ) internal {\r\n    uint256 length = curSumRewardPerLiquidities.length;\r\n    for (uint256 i; i < length; ) {\r\n      if (liquidity != 0) {\r\n        //calculate rewardAmount by formula rewardAmount = (sumRewardPerLiq - lastSumRewardPerLiq) * stake.liquidiy\r\n        uint256 rewardAmount = LMMath.calcRewardAmount(\r\n          curSumRewardPerLiquidities[i],\r\n          stakes[nftId].lastSumRewardPerLiquidity[i],\r\n          liquidity\r\n        );\r\n\r\n        //accumulate reward into stake rewards\r\n        if (rewardAmount != 0) {\r\n          stakes[nftId].rewardUnclaimed[i] += rewardAmount;\r\n        }\r\n      }\r\n\r\n      //store new sumReward into stake\r\n      stakes[nftId].lastSumRewardPerLiquidity[i] = curSumRewardPerLiquidities[i];\r\n\r\n      unchecked {\r\n        ++i;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev if block.timestamp > lastTouchedTime, update sumRewardPerLiquidity. Otherwise just return it\r\n  /// @dev if block.timestamp > farm's endTime then update phase to settled\r\n  /// @param fId farm's id\r\n  /// @return curSumRewardPerLiquidity array of sumRewardPerLiquidity until now\r\n  function _updateFarmSumRewardPerLiquidity(\r\n    uint256 fId\r\n  ) internal returns (uint256[] memory curSumRewardPerLiquidity) {\r\n    uint256 length = farms[fId].phase.rewards.length;\r\n    curSumRewardPerLiquidity = new uint256[](length);\r\n\r\n    uint32 lastTouchedTime = farms[fId].lastTouchedTime;\r\n    uint32 endTime = farms[fId].phase.endTime;\r\n    bool isSettled = farms[fId].phase.isSettled;\r\n    uint256 liquidity = farms[fId].liquidity;\r\n\r\n    if (block.timestamp > lastTouchedTime) {\r\n      for (uint256 i; i < length; ) {\r\n        curSumRewardPerLiquidity[i] = farms[fId].sumRewardPerLiquidity[i];\r\n        uint256 deltaSumRewardPerLiquidity;\r\n\r\n        //calculate deltaSumReward incase there is any liquidity in farm and farm is not settled yet\r\n        if (liquidity > 0 && !isSettled) {\r\n          deltaSumRewardPerLiquidity = _calcDeltaSumRewardPerLiquidity(\r\n            farms[fId].phase.rewards[i].rewardAmount,\r\n            farms[fId].phase.startTime,\r\n            endTime,\r\n            lastTouchedTime,\r\n            liquidity\r\n          );\r\n        }\r\n\r\n        if (deltaSumRewardPerLiquidity != 0) {\r\n          farms[fId].sumRewardPerLiquidity[i] =\r\n            curSumRewardPerLiquidity[i] +\r\n            deltaSumRewardPerLiquidity;\r\n\r\n          curSumRewardPerLiquidity[i] += deltaSumRewardPerLiquidity;\r\n        }\r\n\r\n        unchecked {\r\n          ++i;\r\n        }\r\n      }\r\n\r\n      farms[fId].lastTouchedTime = uint32(block.timestamp);\r\n    } else {\r\n      for (uint256 i; i < length; ) {\r\n        curSumRewardPerLiquidity[i] = farms[fId].sumRewardPerLiquidity[i];\r\n\r\n        unchecked {\r\n          ++i;\r\n        }\r\n      }\r\n    }\r\n\r\n    //if passed endTime, update phase to settled\r\n    if (block.timestamp > endTime && !isSettled) farms[fId].phase.isSettled = true;\r\n  }\r\n\r\n  /// @dev get liquidity of nft from helper\r\n  /// @param nftId nft's id\r\n  /// @return liquidity current liquidity of nft\r\n  function _getLiquidity(uint256 nftId) internal view returns (uint128 liquidity) {\r\n    (, , , liquidity) = helper.getPositionInfo(address(nft), nftId);\r\n  }\r\n\r\n  /// @dev check multiple nfts it's valid\r\n  /// @param poolAddress pool's address\r\n  /// @param tickLower farm's tickLower\r\n  /// @param tickUpper farm's tickUpper\r\n  /// @param nftIds nfts to check\r\n  function _checkPosition(\r\n    address poolAddress,\r\n    int24 tickLower,\r\n    int24 tickUpper,\r\n    uint256[] calldata nftIds\r\n  ) internal view returns (bool isInvalid, uint128[] memory nftLiquidities) {\r\n    (isInvalid, nftLiquidities) = helper.checkPosition(\r\n      poolAddress,\r\n      address(nft),\r\n      tickLower,\r\n      tickUpper,\r\n      nftIds\r\n    );\r\n  }\r\n\r\n  /// @dev remove liquidiy of nft from posManager\r\n  /// @param nftId nft's id\r\n  /// @param liquidity liquidity amount to remove\r\n  /// @param deadline removeLiquidity deadline\r\n  function _removeLiquidity(uint256 nftId, uint128 liquidity, uint256 deadline) internal {\r\n    IBasePositionManager.RemoveLiquidityParams memory removeLiq = IBasePositionManager\r\n      .RemoveLiquidityParams({\r\n        tokenId: nftId,\r\n        liquidity: liquidity,\r\n        amount0Min: 0,\r\n        amount1Min: 0,\r\n        deadline: deadline\r\n      });\r\n\r\n    IBasePositionManager(address(nft)).removeLiquidity(removeLiq);\r\n  }\r\n\r\n  /// @dev claim fee of nft from posManager\r\n  /// @param nftId nft's id\r\n  /// @param deadline claimFee deadline\r\n  /// @param syncFee is need to sync new fee or not\r\n  function _claimFee(uint256 nftId, uint256 deadline, bool syncFee) internal {\r\n    if (syncFee) {\r\n      IBasePositionManager(address(nft)).syncFeeGrowth(nftId);\r\n    }\r\n\r\n    IBasePositionManager.BurnRTokenParams memory burnRToken = IBasePositionManager\r\n      .BurnRTokenParams({tokenId: nftId, amount0Min: 0, amount1Min: 0, deadline: deadline});\r\n\r\n    IBasePositionManager(address(nft)).burnRTokens(burnRToken);\r\n  }\r\n\r\n  /// @dev transfer tokens from removeLiquidity (and burnRToken if any) to receiver, also unwrap if needed\r\n  /// @param poolAddress address of Elastic Pool\r\n  /// @param amount0Min minimum amount of token0 should receive\r\n  /// @param amount1Min minimum amount of token1 should receive\r\n  /// @param receiver receiver of tokens\r\n  function _transferTokens(\r\n    address poolAddress,\r\n    uint256 amount0Min,\r\n    uint256 amount1Min,\r\n    address receiver,\r\n    bool isReceiveNative\r\n  ) internal {\r\n    address token0 = address(IPoolStorage(poolAddress).token0());\r\n    address token1 = address(IPoolStorage(poolAddress).token1());\r\n    IBasePositionManager posManager = IBasePositionManager(address(nft));\r\n\r\n    if (isReceiveNative) {\r\n      // expect to receive in native token\r\n      if (weth == token0) {\r\n        // receive in native for token0\r\n        posManager.unwrapWeth(amount0Min, receiver);\r\n        posManager.transferAllTokens(token1, amount1Min, receiver);\r\n        return;\r\n      }\r\n      if (weth == token1) {\r\n        // receive in native for token1\r\n        posManager.transferAllTokens(token0, amount0Min, receiver);\r\n        posManager.unwrapWeth(amount1Min, receiver);\r\n        return;\r\n      }\r\n    }\r\n\r\n    posManager.transferAllTokens(token0, amount0Min, receiver);\r\n    posManager.transferAllTokens(token1, amount1Min, receiver);\r\n  }\r\n\r\n  function _safeTransfer(address token, address to, uint256 amount) internal {\r\n    (bool success, ) = token == ETH_ADDRESS\r\n      ? payable(to).call{value: amount}('')\r\n      : token.call(abi.encodeWithSignature('transfer(address,uint256)', to, amount));\r\n\r\n    require(success);\r\n  }\r\n\r\n  function _mintFarmingToken(address token, address to, uint256 amount) internal {\r\n    IKyberSwapFarmingToken(token).mint(to, amount);\r\n  }\r\n\r\n  function _burnFarmingToken(address token, address from, uint256 amount) internal {\r\n    IKyberSwapFarmingToken(token).burn(from, amount);\r\n  }\r\n\r\n  /// @dev calculate sumRewardPerLiquidity for each reward token\r\n  /// @dev if block.timestamp > lastTouched means sumRewardPerLiquidity had increase\r\n  /// @dev if not then just return it\r\n  /// @param rewardAmount rewardAmount to calculate\r\n  /// @param startTime farm's startTime\r\n  /// @param endTime farm's endTime\r\n  /// @param lastTouchedTime farm's lastTouchedTime\r\n  /// @param totalLiquidity farm's total liquidity\r\n  /// @return deltaSumRewardPerLiquidity from lastTouchedTime till now\r\n  function _calcDeltaSumRewardPerLiquidity(\r\n    uint256 rewardAmount,\r\n    uint32 startTime,\r\n    uint32 endTime,\r\n    uint32 lastTouchedTime,\r\n    uint256 totalLiquidity\r\n  ) internal view returns (uint256 deltaSumRewardPerLiquidity) {\r\n    deltaSumRewardPerLiquidity = LMMath.calcSumRewardPerLiquidity(\r\n      rewardAmount,\r\n      startTime,\r\n      endTime,\r\n      uint32(block.timestamp),\r\n      lastTouchedTime,\r\n      totalLiquidity\r\n    );\r\n  }\r\n\r\n  /// @dev check if range is valid to be add to farm, revert on fail\r\n  /// @param range range to check\r\n  function _isRangeValid(RangeInput memory range) internal pure {\r\n    if (range.tickLower > range.tickUpper || range.weight == 0) revert InvalidRange();\r\n  }\r\n\r\n  /// @dev check if phase is valid to be add to farm, revert on fail\r\n  function _isPhaseValid(PhaseInput memory phase) internal view {\r\n    if (phase.startTime < block.timestamp || phase.endTime <= phase.startTime)\r\n      revert InvalidTime();\r\n\r\n    if (phase.rewards.length == 0) revert InvalidReward();\r\n  }\r\n\r\n  /// @dev check if add liquidity conditions are meet or not, revert on fail\r\n  /// @param fId farm's id\r\n  function _isAddLiquidityValid(uint256 fId, uint256 rangeId) internal view {\r\n    if (fId >= farmCount) revert FarmNotFound();\r\n    if (rangeId >= farms[fId].ranges.length || farms[fId].ranges[rangeId].isRemoved)\r\n      revert RangeNotFound();\r\n    if (farms[fId].phase.endTime < block.timestamp || farms[fId].phase.isSettled)\r\n      revert PhaseSettled();\r\n    if (emergencyEnabled) revert EmergencyEnabled();\r\n  }\r\n\r\n  /// @dev check if stake update conditions are meet or not, revert on fail\r\n  ///   check if the caller is the owner of the NFT and the stake data is valid\r\n  /// @param fId farm's id\r\n  /// @param nftId the NFT's id\r\n  function _isStakeValid(uint256 fId, uint256 nftId) internal view {\r\n    if (stakes[nftId].owner != msg.sender) revert NotOwner();\r\n    if (stakes[nftId].fId != fId) revert StakeNotFound();\r\n  }\r\n\r\n  /// @dev check if stake add liquidity conditions are meet or not, revert on fail\r\n  /// @param fId farm's id\r\n  /// @param rangeId range's id\r\n  /// @param nftId NFT's id\r\n  function _isStakeValidForAddLiquidity(\r\n    uint256 fId,\r\n    uint256 rangeId,\r\n    uint256 nftId\r\n  ) internal view {\r\n    _isStakeValid(fId, nftId);\r\n    if (stakes[nftId].rangeId != rangeId) revert RangeNotMatch();\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"_nft\",\"type\":\"address\"},{\"internalType\":\"contract IKSElasticLMHelper\",\"name\":\"_helper\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"EmergencyEnabled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Expired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailToAdd\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailToRemove\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FarmNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Forbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFarm\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidReward\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTime\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LiquidityNotMatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PhaseSettled\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PositionNotEligible\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RangeNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RangeNotMatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StakeNotFound\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"}],\"name\":\"ActivateRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct IKSElasticLMV2.RangeInput[]\",\"name\":\"ranges\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IKSElasticLMV2.RewardInput[]\",\"name\":\"rewards\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct IKSElasticLMV2.PhaseInput\",\"name\":\"phase\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"farmingToken\",\"type\":\"address\"}],\"name\":\"AddFarm\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IKSElasticLMV2.RewardInput[]\",\"name\":\"rewards\",\"type\":\"tuple[]\"}],\"indexed\":false,\"internalType\":\"struct IKSElasticLMV2.PhaseInput\",\"name\":\"phase\",\"type\":\"tuple\"}],\"name\":\"AddPhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"indexed\":false,\"internalType\":\"struct IKSElasticLMV2.RangeInput\",\"name\":\"range\",\"type\":\"tuple\"}],\"name\":\"AddRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"ClaimReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"}],\"name\":\"ExpandEndTimeAndRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"}],\"name\":\"ForceClosePhase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"}],\"name\":\"RemoveRange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"TransferAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"enableOrDisable\",\"type\":\"bool\"}],\"name\":\"UpdateEmergency\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IKSElasticLMHelper\",\"name\":\"helper\",\"type\":\"address\"}],\"name\":\"UpdateHelper\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"name\":\"UpdateLiquidity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"grantOrRevoke\",\"type\":\"bool\"}],\"name\":\"UpdateOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"farmingTokenCode\",\"type\":\"bytes\"}],\"name\":\"UpdateTokenCode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"WithdrawEmergency\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"WithdrawUnusedRewards\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"}],\"name\":\"activateRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"internalType\":\"struct IKSElasticLMV2.RangeInput[]\",\"name\":\"ranges\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IKSElasticLMV2.RewardInput[]\",\"name\":\"rewards\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IKSElasticLMV2.PhaseInput\",\"name\":\"phase\",\"type\":\"tuple\"},{\"internalType\":\"bool\",\"name\":\"isUsingToken\",\"type\":\"bool\"}],\"name\":\"addFarm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"addLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IKSElasticLMV2.RewardInput[]\",\"name\":\"rewards\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IKSElasticLMV2.PhaseInput\",\"name\":\"phaseInput\",\"type\":\"tuple\"}],\"name\":\"addPhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"}],\"internalType\":\"struct IKSElasticLMV2.RangeInput\",\"name\":\"range\",\"type\":\"tuple\"}],\"name\":\"addRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isReceiveNative\",\"type\":\"bool\"}],\"name\":\"claimFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"farmCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"}],\"name\":\"forceClosePhase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getDepositedNFTs\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"listNFTs\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"}],\"name\":\"getFarm\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"},{\"internalType\":\"uint32\",\"name\":\"weight\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isRemoved\",\"type\":\"bool\"}],\"internalType\":\"struct IKSElasticLMV2.RangeInfo[]\",\"name\":\"ranges\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"startTime\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"endTime\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"isSettled\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct IKSElasticLMV2.RewardInput[]\",\"name\":\"rewards\",\"type\":\"tuple[]\"}],\"internalType\":\"struct IKSElasticLMV2.PhaseInfo\",\"name\":\"phase\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"farmingToken\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"sumRewardPerLiquidity\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32\",\"name\":\"lastTouchedTime\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNft\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"lastSumRewardPerLiquidity\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardUnclaimed\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"operators\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nftId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"amount0Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Min\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isClaimFee\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isReceiveNative\",\"type\":\"bool\"}],\"name\":\"removeLiquidity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rangeId\",\"type\":\"uint256\"}],\"name\":\"removeRange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enableOrDisable\",\"type\":\"bool\"}],\"name\":\"updateEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IKSElasticLMHelper\",\"name\":\"_helper\",\"type\":\"address\"}],\"name\":\"updateHelper\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"grantOrRevoke\",\"type\":\"bool\"}],\"name\":\"updateOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_farmingTokenCreationCode\",\"type\":\"bytes\"}],\"name\":\"updateTokenCode\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weth\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nftIds\",\"type\":\"uint256[]\"}],\"name\":\"withdrawEmergency\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"withdrawUnusedRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "KSElasticLMV2", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e222fbe074a436145b255442d919e4e3a6c6a4800000000000000000000000006afeb9edd6cf44fa8e89b1eee28284e6dd7705c8", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f32922f32b63a3ca784d5eefe091e9537075f1a70d091f563aaaac1ae2c84f0e"}