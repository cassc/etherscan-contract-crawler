{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.0 ;\r\n\r\ninterface IERC20 {\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function mint(uint256 amount) external;\r\n    function burn(uint256 amount) external;\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function lucaToFragment(uint256 value) external view returns (uint256);\r\n    function fragmentToLuca(uint256 value) external view returns (uint256);\r\n}\r\ninterface Itrader {\r\n    function suck(address _to, uint256 _amount) external;\r\n}\r\ninterface ICrosschain {\r\n    function transferToken(\r\n         address[2] calldata addrs,\r\n        uint256[3] calldata uints,\r\n        string[] calldata strs,\r\n        uint8[] calldata vs,\r\n        bytes32[] calldata rssMetadata) external;\r\n    function stakeToken(string memory _chain, string memory  receiveAddr, address tokenAddr, uint256 _amount) external ;\r\n}\r\n\r\nabstract contract Initializable {\r\n    /**\r\n     * @dev Indicates that the contract has been initialized.\r\n     */\r\n    bool private _initialized;\r\n\r\n    /**\r\n     * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n    bool private _initializing;\r\n\r\n    /**\r\n     * @dev Modifier to protect an initializer function from being invoked twice.\r\n     */\r\n    modifier initializer() {\r\n        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");\r\n\r\n        bool isTopLevelCall = !_initializing;\r\n        if (isTopLevelCall) {\r\n            _initializing = true;\r\n            _initialized = true;\r\n        }\r\n\r\n        _;\r\n\r\n        if (isTopLevelCall) {\r\n            _initializing = false;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Ownable is Initializable{\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the management contract as the initial owner.\r\n     */\r\n    function __Ownable_init_unchained(address _management) internal initializer {\r\n        require( _management != address(0),\"management address cannot be 0\");\r\n        _owner = _management;\r\n        emit OwnershipTransferred(address(0), _management);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the caller is the current owner.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Crosschain  is Initializable,Ownable,ICrosschain {\r\n    using SafeMath for uint256;\r\n    bool public pause;\r\n    uint256 public nodeNum;\r\n    uint256 public stakeNum;\r\n    bytes32 public DOMAIN_SEPARATOR;\r\n    bool public bscSta;\r\n    IERC20 public lucaToken;\r\n    mapping(string => mapping(address => uint256)) public chargeRate;\r\n    mapping(address => uint256) chargeAmount;\r\n    mapping(string => bool) public chainSta;\r\n    mapping(string => mapping(string => bool)) status;\r\n    mapping(address => uint256) nodeAddrIndex;\r\n    mapping(uint256 => address) public nodeIndexAddr;\r\n    mapping(address => bool) public nodeAddrSta;\r\n    mapping(uint256 => Stake) public stakeMsg;\r\n    event UpdatePause(bool sta);\r\n    event WithdrawChargeAmount(address tokenAddr, uint256 amount);\r\n    event AddNodeAddr(address[] nodeAddrs);\r\n    event DeleteNodeAddr(address[] nodeAddrs);\r\n    event UpdateChainCharge(string chain, bool sta, address[] tokens, uint256[] fees);\r\n    event TransferToken(address indexed _tokenAddr, address _receiveAddr, uint256 _fragment, uint256 _amount, string chain, string txid);\r\n    event StakeToken(address indexed _tokenAddr, address indexed _userAddr, string receiveAddr, uint256 fragment, uint256 amount, uint256 fee,string chain);\r\n    IERC20 public agtToken;\r\n    Itrader public trader;\r\n    \r\n    struct Data {\r\n        address userAddr;\r\n        address contractAddr;\r\n        uint256 fragment;\r\n        uint256 amount;\r\n        uint256 expiration;\r\n        string chain;\r\n        string txid;\r\n    }\r\n\r\n    struct Stake {\r\n        address tokenAddr;\r\n        address userAddr;\r\n        string receiveAddr;\r\n        uint256 fragment;\r\n        uint256 amount;\r\n        uint256 fee;\r\n        string chain;\r\n    }\r\n\r\n    struct Sig {\r\n        /* v parameter */\r\n        uint8 v;\r\n        /* r parameter */\r\n        bytes32 r;\r\n        /* s parameter */\r\n        bytes32 s;\r\n    }\r\n\r\n    modifier onlyGuard() {\r\n        require(!pause, \"Crosschain: The system is suspended\");\r\n        _;\r\n    }\r\n\r\n    function init( \r\n        address _lucaToken, \r\n        address _trader, \r\n        address _agt,\r\n        address _management,\r\n        bool _sta\r\n    )  external initializer{\r\n        __Ownable_init_unchained(_management);\r\n        __Crosschain_init_unchained(_lucaToken, _trader, _agt, _sta);\r\n    }\r\n\r\n    function __Crosschain_init_unchained(\r\n        address _lucaToken, \r\n        address _trader, \r\n        address _agt,\r\n        bool _sta\r\n    ) internal initializer{\r\n        require( _lucaToken != address(0),\"lucaToken address cannot be 0\");\r\n        require( _trader != address(0),\"trader address cannot be 0\");\r\n        require( _agt != address(0),\"agt address cannot be 0\");\r\n        lucaToken = IERC20(_lucaToken);\r\n        trader = Itrader(_trader);\r\n        agtToken = IERC20(_agt);\r\n        bscSta = _sta;\r\n        uint chainId;\r\n        assembly {\r\n            chainId := chainId\r\n        }\r\n        DOMAIN_SEPARATOR = keccak256(\r\n            abi.encode(\r\n                keccak256('EIP712Domain(uint256 chainId,address verifyingContract)'),\r\n                chainId,\r\n                address(this)\r\n            )\r\n        );\r\n    }\r\n\r\n    receive() payable external{\r\n\r\n    }\r\n\r\n    fallback() payable external{\r\n\r\n    }\r\n\r\n    function updatePause(bool _sta) external onlyOwner{\r\n        pause = _sta;\r\n        emit UpdatePause(_sta);\r\n    }\r\n\r\n    function updateChainCharge(string calldata _chain, bool _sta, address[] calldata _tokens, uint256[] calldata _fees) external onlyOwner{\r\n        chainSta[_chain] = _sta;\r\n        require(_tokens.length == _fees.length, \"Parameter array length does not match\");\r\n        for (uint256 i = 0; i< _tokens.length; i++){\r\n            chargeRate[_chain][_tokens[i]] = _fees[i];\r\n        }\r\n        emit UpdateChainCharge(_chain, _sta, _tokens, _fees);\r\n    }\r\n\r\n    function withdrawChargeAmount(address[] calldata tokenAddrs, address receiveAddr) external onlyOwner{\r\n        require( receiveAddr != address(0),\"receiveAddr address cannot be 0\");\r\n        for (uint256 i = 0; i< tokenAddrs.length; i++){\r\n            if(tokenAddrs[i] == address(lucaToken)){\r\n                uint256 _amount = lucaToken.fragmentToLuca(chargeAmount[tokenAddrs[i]]);\r\n                require(lucaToken.transfer(receiveAddr,_amount), \"Token transfer failed\");\r\n                chargeAmount[tokenAddrs[i]] = 0;\r\n                emit WithdrawChargeAmount(tokenAddrs[i], _amount);\r\n            }else{\r\n                IERC20 token = IERC20(tokenAddrs[i]);\r\n                uint256 _amount = chargeAmount[tokenAddrs[i]];\r\n                require(token.transfer(receiveAddr,_amount), \"Token transfer failed\");\r\n                chargeAmount[tokenAddrs[i]] = 0;\r\n                emit WithdrawChargeAmount(tokenAddrs[i], _amount);\r\n            }\r\n            \r\n        }\r\n       \r\n    }\r\n\r\n    function addNodeAddr(address[] calldata _nodeAddrs) external onlyOwner{\r\n        for (uint256 i = 0; i< _nodeAddrs.length; i++){\r\n            address _nodeAddr = _nodeAddrs[i];\r\n            require(!nodeAddrSta[_nodeAddr], \"This node is already a node address\");\r\n            nodeAddrSta[_nodeAddr] = true;\r\n            uint256 _nodeAddrIndex = nodeAddrIndex[_nodeAddr];\r\n            if (_nodeAddrIndex == 0){\r\n                _nodeAddrIndex = ++nodeNum;\r\n                nodeAddrIndex[_nodeAddr] = _nodeAddrIndex;\r\n                nodeIndexAddr[_nodeAddrIndex] = _nodeAddr;\r\n            }\r\n        }\r\n        emit AddNodeAddr(_nodeAddrs);\r\n    }\r\n\r\n    function deleteNodeAddr(address[] calldata _nodeAddrs) external onlyOwner{\r\n        for (uint256 i = 0; i< _nodeAddrs.length; i++){\r\n            address _nodeAddr = _nodeAddrs[i];\r\n            require(nodeAddrSta[_nodeAddr], \"This node is not a pledge node\");\r\n            nodeAddrSta[_nodeAddr] = false;\r\n            uint256 _nodeAddrIndex = nodeAddrIndex[_nodeAddr];\r\n            if (_nodeAddrIndex > 0){\r\n                uint256 _nodeNum = nodeNum;\r\n                address _lastNodeAddr = nodeIndexAddr[_nodeNum];\r\n                nodeAddrIndex[_lastNodeAddr] = _nodeAddrIndex;\r\n                nodeIndexAddr[_nodeAddrIndex] = _lastNodeAddr;\r\n                nodeAddrIndex[_nodeAddr] = 0;\r\n                nodeIndexAddr[_nodeNum] = address(0x0);\r\n                nodeNum--;\r\n            }\r\n        }\r\n        emit DeleteNodeAddr(_nodeAddrs);\r\n    }\r\n\r\n    function stakeToken(string memory _chain, string memory receiveAddr, address tokenAddr, uint256 _amount) override external {\r\n        address _sender = msg.sender;\r\n        require( tokenAddr == address(lucaToken) || tokenAddr == address(agtToken) , \"Crosschain: The token does not support transfers\");\r\n        require( chainSta[_chain], \"Crosschain: The chain does not support transfer\");\r\n        if (address(lucaToken) == tokenAddr){\r\n            require(lucaToken.transferFrom(_sender,address(this),_amount), \"Token transfer failed\");\r\n            uint256 _charge = chargeRate[_chain][tokenAddr];\r\n            _amount = _amount.sub(_charge);\r\n            uint256 fragment = lucaToken.lucaToFragment(_amount);\r\n            require(fragment > 0, \"Share calculation anomaly\");\r\n            uint256 fee = lucaToken.lucaToFragment(_charge);\r\n            chargeAmount[tokenAddr] = chargeAmount[tokenAddr].add(fee);\r\n            stakeMsg[++stakeNum] = Stake(tokenAddr, _sender, receiveAddr, fragment, _amount, fee, _chain);\r\n            if(!bscSta){\r\n                lucaToken.burn(_amount);        \r\n            }\r\n            emit StakeToken(tokenAddr, _sender, receiveAddr, fragment, _amount, fee, _chain);\r\n        }else{\r\n            IERC20 token = IERC20(tokenAddr);\r\n            require(token.transferFrom(_sender,address(this),_amount), \"Token transfer failed\");\r\n            uint256 fee = chargeRate[_chain][tokenAddr];\r\n            _amount = _amount.sub(fee);\r\n            chargeAmount[tokenAddr] = chargeAmount[tokenAddr].add(fee);\r\n            stakeMsg[++stakeNum] = Stake(tokenAddr, _sender, receiveAddr, 0, _amount, fee, _chain);\r\n            token.burn(_amount); \r\n            emit StakeToken(tokenAddr, _sender, receiveAddr, 0, _amount, fee, _chain);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @notice A method in which issue transfer tokens to users. \r\n    * @param addrs [User address, token contract address]\r\n    * @param uints [Number of luca fragments (0 for non-luca tokens), number of transfers, expiration time]\r\n    * @param strs [chain name, transaction id]\r\n    * @param vs  array of signature data\r\n    * @param rssMetadata array of signature data\r\n    */\r\n    function transferToken(\r\n        address[2] calldata addrs,\r\n        uint256[3] calldata uints,\r\n        string[] calldata strs,\r\n        uint8[] calldata vs,\r\n        bytes32[] calldata rssMetadata\r\n    )\r\n        external\r\n        override\r\n        onlyGuard\r\n    {\r\n        require( addrs[1] == address(lucaToken) || addrs[1] == address(agtToken) , \"Crosschain: The token does not support transfers\");\r\n        require( block.timestamp<= uints[2], \"Crosschain: The transaction exceeded the time limit\");\r\n        require( !status[strs[0]][strs[1]], \"Crosschain: The transaction has been withdrawn\");\r\n        status[strs[0]][strs[1]] = true;\r\n        uint256 len = vs.length;\r\n        uint256 counter;\r\n        require(len*2 == rssMetadata.length, \"Crosschain: Signature parameter length mismatch\");\r\n        uint256[] memory arr = new uint256[](len);\r\n        bytes32 digest = getDigest(Data( addrs[0], addrs[1], uints[0], uints[1], uints[2], strs[0], strs[1]));\r\n        for (uint256 i = 0; i < len; i++) {\r\n            (bool result, uint256 index) = verifySign(\r\n                digest,\r\n                Sig(vs[i], rssMetadata[i*2], rssMetadata[i*2+1])\r\n            );\r\n            arr[i] = index;\r\n            if (result){\r\n                counter++;\r\n            }\r\n        }\r\n        require(areElementsUnique(arr), \"IncentiveContracts: Signature parameter not unique\");\r\n        require(\r\n            counter > nodeNum/2,\r\n            \"The number of signed accounts did not reach the minimum threshold\"\r\n        );\r\n        _transferToken(addrs, uints, strs);\r\n    }\r\n   \r\n    function queryCharge(address[] calldata addrs) external view returns (address[] memory, uint256[] memory) {\r\n        address[] memory _addrArray = new address[](1) ;\r\n        uint256[] memory _chargeAmount = new uint256[](1) ;\r\n        uint256 len = addrs.length;\r\n        _addrArray = new address[](len) ;\r\n        _chargeAmount = new uint256[](len) ;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            _addrArray[i] = addrs[i];\r\n            if(addrs[i] == address(lucaToken)){\r\n                _chargeAmount[i] = lucaToken.fragmentToLuca(chargeAmount[addrs[i]]);\r\n            }else{\r\n                _chargeAmount[i] = chargeAmount[addrs[i]];\r\n            }\r\n        }\r\n        return (_addrArray, _chargeAmount);\r\n    }\r\n\r\n    function _transferToken(address[2] memory addrs, uint256[3] memory uints, string[] memory strs) internal {\r\n        if (address(lucaToken) == addrs[1]){\r\n            uint256 amount = lucaToken.fragmentToLuca(uints[0]);\r\n            if (!bscSta){\r\n                lucaToken.mint(amount);\r\n            }\r\n            uint256 balance = lucaToken.balanceOf(address(this));\r\n            require(balance >= amount,\"Insufficient token balance\");\r\n            require(\r\n                lucaToken.transfer(addrs[0],amount),\r\n                \"Token transfer failed\"\r\n            );\r\n            emit TransferToken(addrs[1], addrs[0], uints[0], amount, strs[0], strs[1]);\r\n        }else if(address(agtToken) == addrs[1]){\r\n            uint256 amount = uints[1];\r\n            uint256 balance = agtToken.balanceOf(address(this));\r\n            if (balance < amount){\r\n                trader.suck(address(this),amount);\r\n            }\r\n            balance = agtToken.balanceOf(address(this));\r\n            require(balance >= amount,\"Insufficient token balance\");\r\n            require(\r\n                agtToken.transfer(addrs[0],amount),\r\n                \"Token transfer failed\"\r\n            );\r\n            emit TransferToken(addrs[1], addrs[0], 0, amount, strs[0], strs[1]);\r\n        }\r\n    }\r\n\r\n    function areElementsUnique(uint256[] memory arr) internal pure returns (bool) {\r\n        for(uint i = 0; i < arr.length - 1; i++) {\r\n            for(uint j = i + 1; j < arr.length; j++) {\r\n                if (arr[i] == arr[j]) {\r\n                    return false; \r\n                }\r\n            }\r\n        }\r\n        return true; \r\n    }\r\n\r\n    function verifySign(bytes32 _digest,Sig memory _sig) internal view returns (bool,uint256)  {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n        bytes32 hash = keccak256(abi.encodePacked(prefix, _digest));\r\n        address _nodeAddr = ecrecover(hash, _sig.v, _sig.r, _sig.s);\r\n        require(_nodeAddr !=address(0),\"Illegal signature\");\r\n        return (nodeAddrSta[_nodeAddr],nodeAddrIndex[_nodeAddr]);\r\n    }\r\n    \r\n    function getDigest(Data memory _data) internal view returns(bytes32 digest){\r\n        digest = keccak256(\r\n            abi.encodePacked(\r\n                '\\x19\\x01',\r\n                DOMAIN_SEPARATOR,\r\n                keccak256(abi.encode(_data.userAddr, _data.contractAddr,  _data.fragment, _data.amount, _data.expiration, _data.chain, _data.txid))\r\n            )\r\n        );\r\n    }\r\n    \r\n}\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"nodeAddrs\",\"type\":\"address[]\"}],\"name\":\"AddNodeAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"nodeAddrs\",\"type\":\"address[]\"}],\"name\":\"DeleteNodeAddr\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_userAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"receiveAddr\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fragment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"}],\"name\":\"StakeToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_receiveAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_fragment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"txid\",\"type\":\"string\"}],\"name\":\"TransferToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sta\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"fees\",\"type\":\"uint256[]\"}],\"name\":\"UpdateChainCharge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sta\",\"type\":\"bool\"}],\"name\":\"UpdatePause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawChargeAmount\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nodeAddrs\",\"type\":\"address[]\"}],\"name\":\"addNodeAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"agtToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bscSta\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"chainSta\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"chargeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_nodeAddrs\",\"type\":\"address[]\"}],\"name\":\"deleteNodeAddr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_lucaToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_trader\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_agt\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_management\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_sta\",\"type\":\"bool\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lucaToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nodeAddrSta\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nodeIndexAddr\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nodeNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"queryCharge\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakeMsg\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"userAddr\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"receiveAddr\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"fragment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"chain\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakeNum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_chain\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"receiveAddr\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"stakeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trader\",\"outputs\":[{\"internalType\":\"contract Itrader\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[2]\",\"name\":\"addrs\",\"type\":\"address[2]\"},{\"internalType\":\"uint256[3]\",\"name\":\"uints\",\"type\":\"uint256[3]\"},{\"internalType\":\"string[]\",\"name\":\"strs\",\"type\":\"string[]\"},{\"internalType\":\"uint8[]\",\"name\":\"vs\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"rssMetadata\",\"type\":\"bytes32[]\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_chain\",\"type\":\"string\"},{\"internalType\":\"bool\",\"name\":\"_sta\",\"type\":\"bool\"},{\"internalType\":\"address[]\",\"name\":\"_tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_fees\",\"type\":\"uint256[]\"}],\"name\":\"updateChainCharge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_sta\",\"type\":\"bool\"}],\"name\":\"updatePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokenAddrs\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"receiveAddr\",\"type\":\"address\"}],\"name\":\"withdrawChargeAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Crosschain", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://cca1ba4618597b8e1b21ac6ea26473fd11fb5b2780ff10bf715d4df6a15be921"}