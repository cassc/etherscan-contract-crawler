{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/WalletFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\nimport \\\"../interfaces/IQredoWalletImplementation.sol\\\";\\nimport \\\"../interfaces/IWalletFactory.sol\\\";\\nimport \\\"../libraries/Create2.sol\\\";\\n\\ncontract WalletFactory is IWalletFactory {\\n\\n    mapping(address => address) private walletOwner;\\n    address immutable private _template;\\n\\n    constructor(address _template_) public {\\n        require(_template_ != address(0), \\\"WF::constructor:_template_ address cannot be 0\\\");\\n        _template = _template_;\\n    }\\n\\n    function computeFutureWalletAddress(address _walletOwner) external override view returns(address _walletAddress) {\\n        return Create2.computeAddress(\\n                    keccak256(abi.encodePacked(_walletOwner)),\\n                    keccak256(getBytecode())\\n                );\\n    }\\n   \\n    function createWallet(address _walletOwner) external override returns (address _walletAddress) {\\n        require(_walletOwner != address(0), \\\"WF::createWallet:owner address cannot be 0\\\");\\n        require(walletOwner[_walletOwner] == address(0), \\\"WF::createWallet:owner already has wallet\\\");\\n        address wallet = Create2.deploy(\\n                0,\\n                keccak256(abi.encodePacked(_walletOwner)),\\n                getBytecode()\\n            );\\n        IQredoWalletImplementation(wallet).init(_walletOwner);\\n        walletOwner[_walletOwner] = address(wallet);\\n        emit WalletCreated(msg.sender, address(wallet), _walletOwner);\\n        return wallet;\\n    }\\n\\n    /**\\n      * @dev Returns template address of the current {owner};\\n    */\\n    function getWalletByOwner(address owner) external override view returns (address _wallet) {\\n        return walletOwner[owner];\\n    }\\n\\n    function verifyWallet(address wallet) external override view returns (bool _validWallet) {\\n        return walletOwner[IQredoWalletImplementation(wallet).getWalletOwnerAddress()] != address(0);\\n    }\\n\\n    /**\\n      * @dev Returns template address;\\n    */\\n    function getTemplate() external override view returns (address template){\\n        return _template;\\n    }\\n\\n    /**\\n      * @dev EIP-1167 Minimal Proxy Bytecode with included Creation code.\\n      * More information on EIP-1167 Minimal Proxy and the full bytecode \\n      * read more here: \\n      * (https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract)\\n    */\\n    function getBytecode() private view returns (bytes memory) {\\n        bytes10 creation = 0x3d602d80600a3d3981f3;\\n        bytes10 runtimePrefix = 0x363d3d373d3d3d363d73;\\n        bytes20 targetBytes = bytes20(_template);\\n        bytes15 runtimeSuffix = 0x5af43d82803e903d91602b57fd5bf3;\\n        return abi.encodePacked(creation, runtimePrefix, targetBytes, runtimeSuffix);\\n    }\\n}\\n\\n\\n\"\r\n    },\r\n    \"/libraries/Create2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\n// import \\\"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Create2.sol\\\";\\n\\n/**\\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\\n * `CREATE2` can be used to compute in advance the address where a smart\\n * contract will be deployed, which allows for interesting new mechanisms known\\n * as 'counterfactual interactions'.\\n *\\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\\n * information.\\n */\\n\\nlibrary Create2 {\\n    /**\\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\\n     * will be deployed can be known in advance via {computeAddress}.\\n     *\\n     * The bytecode for a contract can be obtained from Solidity with\\n     * `type(contractName).creationCode`.\\n     *\\n     * Requirements:\\n     *\\n     * - `bytecode` must not be empty.\\n     * - `salt` must have not been used for `bytecode` already.\\n     * - the factory must have a balance of at least `amount`.\\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\\n     */\\n    function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address) {\\n        address addr;\\n        require(address(this).balance >= amount, \\\"Create2: insufficient balance\\\");\\n        require(bytecode.length != 0, \\\"Create2: bytecode length is zero\\\");\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\\n        }\\n        require(addr != address(0), \\\"Create2: Failed on deploy\\\");\\n        return addr;\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\\n     * `bytecodeHash` or `salt` will result in a new destination address.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\\n        return computeAddress(salt, bytecodeHash, address(this));\\n    }\\n\\n    /**\\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\\n     */\\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address) {\\n        bytes32 _data = keccak256(\\n            abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash)\\n        );\\n        return address(uint160(uint256(_data)));\\n    }\\n}\\n\"\r\n    },\r\n    \"/interfaces/IWalletFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\ninterface IWalletFactory {\\n    function computeFutureWalletAddress(address _walletOwner) external view returns(address _walletAddress);\\n    function createWallet(address owner) external returns (address _walletAddress);\\n    function getTemplate() external view returns (address template);\\n    function getWalletByOwner(address owner) external view returns (address _wallet);\\n    function verifyWallet(address wallet) external  view returns (bool _validWallet);\\n    \\n    event WalletCreated(address indexed caller, address indexed wallet, address indexed owner);\\n}\\n\"\r\n    },\r\n    \"/interfaces/IQredoWalletImplementation.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.6.11;\\n\\ninterface IQredoWalletImplementation {\\n    function init(address _walletOwner) external;\\n    function invoke(bytes memory signature, address _to, uint256 _value, bytes calldata _data) external returns (bytes memory _result);\\n    function getBalance(address tokenAddress) external view returns(uint256 _balance);\\n    function getNonce() external view returns(uint256 nonce);\\n    function getWalletOwnerAddress() external view returns(address _walletOwner);\\n    \\n    event Invoked(address indexed sender, address indexed target, uint256 value, uint256 indexed nonce, bytes data);\\n    event Received(address indexed sender, uint indexed value, bytes data);\\n    event Fallback(address indexed sender, uint indexed value, bytes data);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_template_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"WalletCreated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_walletOwner\",\"type\":\"address\"}],\"name\":\"computeFutureWalletAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_walletOwner\",\"type\":\"address\"}],\"name\":\"createWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_walletAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTemplate\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"template\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getWalletByOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"verifyWallet\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_validWallet\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "WalletFactory", "CompilerVersion": "v0.6.11+commit.5ef660b1", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000005825c125a20d233cf83d464b2047f8e81b5ac711", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}