{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/facets/DiamondLoupFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\nimport { LibDiamond } from \\\"../libraries/LibDiamond.sol\\\";\\r\\nimport { IDiamondLoupe } from \\\"../interfaces/IDiamondLoupe.sol\\\";\\r\\nimport { IERC165 } from \\\"../interfaces/IERC165.sol\\\";\\r\\n\\r\\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\\r\\n    /// @notice Gets all facets and their selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view override returns (Facet[] memory facets_) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        // create an array set to the maximum size possible\\r\\n        facets_ = new Facet[](selectorCount);\\r\\n        // create an array for counting the number of selectors for each facet\\r\\n        uint8[] memory numFacetSelectors = new uint8[](selectorCount);\\r\\n        // total number of facets\\r\\n        uint256 numFacets;\\r\\n        // loop through function selectors\\r\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\r\\n            bytes4 selector = ds.selectors[selectorIndex];\\r\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            bool continueLoop = false;\\r\\n            // find the functionSelectors array for selector and add selector to it\\r\\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\r\\n                if (facets_[facetIndex].facetAddress == facetAddress_) {\\r\\n                    facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\\r\\n                    // probably will never have more than 256 functions from one facet contract\\r\\n                    require(numFacetSelectors[facetIndex] < 255);\\r\\n                    numFacetSelectors[facetIndex]++;\\r\\n                    continueLoop = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            // if functionSelectors array exists for selector then continue loop\\r\\n            if (continueLoop) {\\r\\n                continueLoop = false;\\r\\n                continue;\\r\\n            }\\r\\n            // create a new functionSelectors array for selector\\r\\n            facets_[numFacets].facetAddress = facetAddress_;\\r\\n            facets_[numFacets].functionSelectors = new bytes4[](selectorCount);\\r\\n            facets_[numFacets].functionSelectors[0] = selector;\\r\\n            numFacetSelectors[numFacets] = 1;\\r\\n            numFacets++;\\r\\n        }\\r\\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\r\\n            uint256 numSelectors = numFacetSelectors[facetIndex];\\r\\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\\r\\n            // setting the number of selectors\\r\\n            assembly {\\r\\n                mstore(selectors, numSelectors)\\r\\n            }\\r\\n        }\\r\\n        // setting the number of facets\\r\\n        assembly {\\r\\n            mstore(facets_, numFacets)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\\r\\n    function facetFunctionSelectors(address _facet)\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (bytes4[] memory _facetFunctionSelectors)\\r\\n    {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        uint256 numSelectors;\\r\\n        _facetFunctionSelectors = new bytes4[](selectorCount);\\r\\n        // loop through function selectors\\r\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\r\\n            bytes4 selector = ds.selectors[selectorIndex];\\r\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            if (_facet == facetAddress_) {\\r\\n                _facetFunctionSelectors[numSelectors] = selector;\\r\\n                numSelectors++;\\r\\n            }\\r\\n        }\\r\\n        // Set the number of selectors in the array\\r\\n        assembly {\\r\\n            mstore(_facetFunctionSelectors, numSelectors)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        // create an array set to the maximum size possible\\r\\n        facetAddresses_ = new address[](selectorCount);\\r\\n        uint256 numFacets;\\r\\n        // loop through function selectors\\r\\n        for (uint256 selectorIndex; selectorIndex < selectorCount; selectorIndex++) {\\r\\n            bytes4 selector = ds.selectors[selectorIndex];\\r\\n            address facetAddress_ = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            bool continueLoop = false;\\r\\n            // see if we have collected the address already and break out of loop if we have\\r\\n            for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\\r\\n                if (facetAddress_ == facetAddresses_[facetIndex]) {\\r\\n                    continueLoop = true;\\r\\n                    break;\\r\\n                }\\r\\n            }\\r\\n            // continue loop if we already have the address\\r\\n            if (continueLoop) {\\r\\n                continueLoop = false;\\r\\n                continue;\\r\\n            }\\r\\n            // include address\\r\\n            facetAddresses_[numFacets] = facetAddress_;\\r\\n            numFacets++;\\r\\n        }\\r\\n        // Set the number of facet addresses in the array\\r\\n        assembly {\\r\\n            mstore(facetAddresses_, numFacets)\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Gets the facet address that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        facetAddress_ = ds.facetAddressAndSelectorPosition[_functionSelector].facetAddress;\\r\\n    }\\r\\n\\r\\n    // This implements ERC-165.\\r\\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\\r\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\r\\n        return ds.supportedInterfaces[_interfaceId];\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\ninterface IDiamondCut {\\r\\n    // Add=0, Replace=1, Remove=2\\r\\n    enum FacetCutAction {\\r\\n        Add,\\r\\n        Replace,\\r\\n        Remove\\r\\n    }\\r\\n\\r\\n    struct FacetCut {\\r\\n        address facetAddress;\\r\\n        FacetCutAction action;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\r\\n    ///         a function with delegatecall\\r\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\r\\n    /// @param _init The address of the contract or facet to execute _calldata\\r\\n    /// @param _calldata A function call, including function selector and arguments\\r\\n    ///                  _calldata is executed with delegatecall on _init\\r\\n    function diamondCut(\\r\\n        FacetCut[] calldata _diamondCut,\\r\\n        address _init,\\r\\n        bytes calldata _calldata\\r\\n    ) external;\\r\\n\\r\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\n// A loupe is a small magnifying glass used to look at diamonds.\\r\\n// These functions look at diamonds\\r\\ninterface IDiamondLoupe {\\r\\n    struct Facet {\\r\\n        address facetAddress;\\r\\n        bytes4[] functionSelectors;\\r\\n    }\\r\\n\\r\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\r\\n    /// @return facets_ Facet\\r\\n    function facets() external view returns (Facet[] memory facets_);\\r\\n\\r\\n    /// @notice Gets all the function selectors supported by a specific facet.\\r\\n    /// @param _facet The facet address.\\r\\n    /// @return facetFunctionSelectors_\\r\\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\\r\\n\\r\\n    /// @notice Get all the facet addresses used by a diamond.\\r\\n    /// @return facetAddresses_\\r\\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\\r\\n\\r\\n    /// @notice Gets the facet that supports the given selector.\\r\\n    /// @dev If facet is not found return address(0).\\r\\n    /// @param _functionSelector The function selector.\\r\\n    /// @return facetAddress_ The facet address.\\r\\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\ninterface IERC165 {\\r\\n    /// @notice Query if a contract implements an interface\\r\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\r\\n    /// @dev Interface identification is specified in ERC-165. This function\\r\\n    ///  uses less than 30,000 gas.\\r\\n    /// @return `true` if the contract implements `interfaceID` and\\r\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\r\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/libraries/LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\r\\npragma solidity >=0.8.18;\\r\\n\\r\\n/******************************************************************************\\\\\\r\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\\r\\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\\r\\n/******************************************************************************/\\r\\n\\r\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\r\\nimport { IDiamondLoupe } from \\\"../interfaces/IDiamondLoupe.sol\\\";\\r\\nimport { IERC165 } from \\\"../interfaces/IERC165.sol\\\";\\r\\n\\r\\nlibrary LibDiamond {\\r\\n    bytes32 public constant DIAMOND_STORAGE_POSITION =\\r\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\r\\n\\r\\n    struct FacetAddressAndSelectorPosition {\\r\\n        address facetAddress;\\r\\n        uint16 selectorPosition;\\r\\n    }\\r\\n\\r\\n    struct DiamondStorage {\\r\\n        // function selector => facet address and selector position in selectors array\\r\\n        mapping(bytes4 => FacetAddressAndSelectorPosition) facetAddressAndSelectorPosition;\\r\\n        bytes4[] selectors;\\r\\n        mapping(bytes4 => bool) supportedInterfaces;\\r\\n        // owner of the contract\\r\\n        address contractOwner;\\r\\n    }\\r\\n\\r\\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\\r\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\r\\n        assembly {\\r\\n            ds.slot := position\\r\\n        }\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    function setContractOwner(address _newOwner) internal {\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        address previousOwner = ds.contractOwner;\\r\\n        ds.contractOwner = _newOwner;\\r\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\r\\n    }\\r\\n\\r\\n    function contractOwner() internal view returns (address contractOwner_) {\\r\\n        contractOwner_ = diamondStorage().contractOwner;\\r\\n    }\\r\\n\\r\\n    function enforceIsOwnerOrContract() internal view {\\r\\n        require(\\r\\n            msg.sender == diamondStorage().contractOwner || msg.sender == address(this),\\r\\n            \\\"LibDiamond: Must be contract or owner\\\"\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function enforceIsContractOwner() internal view {\\r\\n        require(msg.sender == diamondStorage().contractOwner, \\\"LibDiamond: Must be contract owner\\\");\\r\\n    }\\r\\n\\r\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\r\\n\\r\\n    // Internal function version of diamondCut\\r\\n    function diamondCut(\\r\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\r\\n        address _init,\\r\\n        bytes memory _calldata\\r\\n    ) internal {\\r\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\\r\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\r\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\r\\n                addFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\r\\n                replaceFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\r\\n                removeFunctions(\\r\\n                    _diamondCut[facetIndex].facetAddress,\\r\\n                    _diamondCut[facetIndex].functionSelectors\\r\\n                );\\r\\n            } else {\\r\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\r\\n            }\\r\\n        }\\r\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\r\\n        initializeDiamondCut(_init, _calldata);\\r\\n    }\\r\\n\\r\\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        uint16 selectorCount = uint16(ds.selectors.length);\\r\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Add facet can't be address(0)\\\");\\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            require(\\r\\n                oldFacetAddress == address(0),\\r\\n                \\\"LibDiamondCut: Can't add function that already exists\\\"\\r\\n            );\\r\\n            ds.facetAddressAndSelectorPosition[selector] = FacetAddressAndSelectorPosition(\\r\\n                _facetAddress,\\r\\n                selectorCount\\r\\n            );\\r\\n            ds.selectors.push(selector);\\r\\n            selectorCount++;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        require(_facetAddress != address(0), \\\"LibDiamondCut: Replace facet can't be address(0)\\\");\\r\\n        enforceHasContractCode(_facetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            address oldFacetAddress = ds.facetAddressAndSelectorPosition[selector].facetAddress;\\r\\n            // can't replace immutable functions -- functions defined directly in the diamond\\r\\n            require(\\r\\n                oldFacetAddress != address(this),\\r\\n                \\\"LibDiamondCut: Can't replace immutable function\\\"\\r\\n            );\\r\\n            require(\\r\\n                oldFacetAddress != _facetAddress,\\r\\n                \\\"LibDiamondCut: Can't replace function with same function\\\"\\r\\n            );\\r\\n            require(\\r\\n                oldFacetAddress != address(0),\\r\\n                \\\"LibDiamondCut: Can't replace function that doesn't exist\\\"\\r\\n            );\\r\\n            // replace old facet address\\r\\n            ds.facetAddressAndSelectorPosition[selector].facetAddress = _facetAddress;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\\r\\n        require(_functionSelectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\r\\n        DiamondStorage storage ds = diamondStorage();\\r\\n        uint256 selectorCount = ds.selectors.length;\\r\\n        require(\\r\\n            _facetAddress == address(0),\\r\\n            \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\r\\n        );\\r\\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\\r\\n            bytes4 selector = _functionSelectors[selectorIndex];\\r\\n            FacetAddressAndSelectorPosition memory oldFacetAddressAndSelectorPosition = ds\\r\\n                .facetAddressAndSelectorPosition[selector];\\r\\n            require(\\r\\n                oldFacetAddressAndSelectorPosition.facetAddress != address(0),\\r\\n                \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\r\\n            );\\r\\n            // can't remove immutable functions -- functions defined directly in the diamond\\r\\n            require(\\r\\n                oldFacetAddressAndSelectorPosition.facetAddress != address(this),\\r\\n                \\\"LibDiamondCut: Can't remove immutable function.\\\"\\r\\n            );\\r\\n            // replace selector with last selector\\r\\n            selectorCount--;\\r\\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\\r\\n                bytes4 lastSelector = ds.selectors[selectorCount];\\r\\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\\r\\n                ds\\r\\n                    .facetAddressAndSelectorPosition[lastSelector]\\r\\n                    .selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\\r\\n            }\\r\\n            // delete last selector\\r\\n            ds.selectors.pop();\\r\\n            delete ds.facetAddressAndSelectorPosition[selector];\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\r\\n        if (_init == address(0)) {\\r\\n            require(\\r\\n                _calldata.length == 0,\\r\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\r\\n            );\\r\\n        } else {\\r\\n            require(\\r\\n                _calldata.length > 0,\\r\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\r\\n            );\\r\\n            if (_init != address(this)) {\\r\\n                enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\r\\n            }\\r\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\r\\n            if (!success) {\\r\\n                if (error.length > 0) {\\r\\n                    // bubble up the error\\r\\n                    revert(string(error));\\r\\n                } else {\\r\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\r\\n                }\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\r\\n        uint256 contractSize;\\r\\n        assembly {\\r\\n            contractSize := extcodesize(_contract)\\r\\n        }\\r\\n        require(contractSize > 0, _errorMessage);\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"viaIR\": true,\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_facetFunctionSelectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "DiamondLoupeFacet", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}