{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/SwapperUniswapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2023 Soccerverse Ltd\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"./SwapProvider.sol\\\";\\n\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\\\";\\n\\n/**\\n * @dev This implements the SwapProvider based on a Uniswap v2 DEX.  The swap\\n * data encodes the fixed routing path.\\n */\\ncontract SwapperUniswapV2 is SwapProvider\\n{\\n\\n  /**\\n   * @dev The address of the Uniswap router we use.  We use Router01 here\\n   * since we only need the interface, and the calls we use are included\\n   * in that already.  The implementation will be set upon deployment, and\\n   * can point to the latest router.\\n   */\\n  IUniswapV2Router01 public immutable router;\\n\\n  /**\\n   * @dev All input tokens (other than WCHI), for which the router has\\n   * already been given approval.  We use this to give approval on first use\\n   * for each token (and not on later uses).\\n   */\\n  mapping (address => bool) private tokenApproved;\\n\\n  constructor (IERC20 wc, IUniswapV2Router01 r)\\n    SwapProvider (wc)\\n  {\\n    router = r;\\n    wc.approve (address (r), type (uint256).max);\\n  }\\n\\n  /**\\n   * @dev Encodes a given swap path into a \\\"data\\\" argument that can be passed\\n   * to the other functions.  Note that the path contains only the intermediate\\n   * tokens, not the input or output (and may be empty if a direct pair\\n   * exists).  This is in contrast to the \\\"path\\\" argument for Uniswap.\\n   */\\n  function encodePath (address[] calldata path)\\n      public pure returns (bytes memory)\\n  {\\n    return abi.encode (path);\\n  }\\n\\n  /**\\n   * @dev Helper method that takes an encoded path with intermediate pairs\\n   * as well as input and output tokens and fills in the full path argument\\n   * as used by Uniswap.\\n   */\\n  function getFullPath (IERC20 inputToken, IERC20 outputToken,\\n                        bytes calldata data)\\n      private pure returns (address[] memory res)\\n  {\\n    address[] memory intermediate = abi.decode (data, (address[]));\\n    res = new address[] (intermediate.length + 2);\\n    res[0] = address (inputToken);\\n    for (uint i = 0; i < intermediate.length; ++i)\\n      res[i + 1] = intermediate[i];\\n    res[intermediate.length + 1] = address (outputToken);\\n  }\\n\\n  function quoteExactOutput (IERC20 inputToken, uint outputAmount,\\n                             bytes calldata data)\\n      public view override returns (uint)\\n  {\\n    address[] memory path = getFullPath (inputToken, wchi, data);\\n    uint[] memory amounts = router.getAmountsIn (outputAmount, path);\\n    return amounts[0];\\n  }\\n\\n  function quoteExactInput (uint inputAmount, IERC20 outputToken,\\n                            bytes calldata data)\\n      public view override returns (uint)\\n  {\\n    address[] memory path = getFullPath (wchi, outputToken, data);\\n    uint[] memory amounts = router.getAmountsOut (inputAmount, path);\\n    return amounts[amounts.length - 1];\\n  }\\n\\n  function swapExactOutput (IERC20 inputToken, uint outputAmount,\\n                            bytes calldata data) public override\\n  {\\n    address[] memory path = getFullPath (inputToken, wchi, data);\\n\\n    if (!tokenApproved[address (inputToken)])\\n      {\\n        inputToken.approve (address (router), type (uint256).max);\\n        tokenApproved[address (inputToken)] = true;\\n      }\\n\\n    /* Note that the AutoConvert contract itself enforces a maximum slippage,\\n       so we can call into Uniswap without any limit.  */\\n    router.swapTokensForExactTokens (outputAmount, type (uint256).max, path,\\n                                     address (this), block.timestamp);\\n  }\\n\\n  function swapExactInput (uint inputAmount, IERC20 outputToken,\\n                           bytes calldata data) public override\\n  {\\n    /* Note that the AutoConvert contract itself enforces a maximum slippage,\\n       so we can call into Uniswap without any limit.  */\\n    address[] memory path = getFullPath (wchi, outputToken, data);\\n    router.swapExactTokensForTokens (inputAmount, 0, path,\\n                                     address (this), block.timestamp);\\n  }\\n\\n}\\n\"\r\n    },\r\n    \"/contracts/SwapProvider.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// Copyright (C) 2023 Soccerverse Ltd\\n\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @dev This is the interface of a provider for swapping between tokens,\\n * as used by Democrit's auto-convert feature.  It can be implemented based\\n * on an on-chain DEX such as Uniswap v2 or v3.\\n *\\n * All methods accept an implementation-specific \\\"data\\\" argument, which\\n * can contain other data required, such as swap paths.\\n *\\n * Token swaps are done from / to the contract's balance.  Democrit will\\n * directly move tokens from the user's wallet to this contract, and the\\n * contract has a method to withdraw tokens from its own balance onwards\\n * after the swap, which Democrit will use.\\n */\\nabstract contract SwapProvider\\n{\\n\\n  /** @dev The WCHI token used.  */\\n  IERC20 public immutable wchi;\\n\\n  constructor (IERC20 wc)\\n  {\\n    wchi = wc;\\n  }\\n\\n  /**\\n   * @dev Transfers tokens owned by this contract.  This is a method\\n   * that Democrit will use to distribute the swap output.  It can be\\n   * called by anyone, as this contract is not expected to hold tokens\\n   * \\\"long term\\\".  Any balances it receives will be distributed by\\n   * Democrit right away in the same transaction.\\n   */\\n  function transferToken (IERC20 token, uint amount, address receiver) public\\n  {\\n    require (token.transfer (receiver, amount), \\\"token transfer failed\\\");\\n  }\\n\\n  /**\\n   * @dev Returns the expected amount of input token required to get\\n   * the provided output amount in WCHI.\\n   */\\n  function quoteExactOutput (IERC20 inputToken, uint outputAmount,\\n                             bytes calldata data)\\n      public view virtual returns (uint);\\n\\n  /**\\n   * @dev Returns the expected amount of output token if the provided\\n   * input amount of WCHI is swapped.\\n   */\\n  function quoteExactInput (uint inputAmount, IERC20 outputToken,\\n                            bytes calldata data)\\n      public view virtual returns (uint);\\n\\n  /**\\n   * @dev Performs a swap of input tokens to exact output WCHI tokens.\\n   */\\n  function swapExactOutput (IERC20 inputToken, uint outputAmount,\\n                            bytes calldata data) public virtual;\\n\\n  /**\\n   * @dev Performs a swap of an exact input of WCHI to the desired output.\\n   */\\n  function swapExactInput (uint inputAmount, IERC20 outputToken,\\n                           bytes calldata data) public virtual;\\n\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 5000\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"wc\",\"type\":\"address\"},{\"internalType\":\"contract IUniswapV2Router01\",\"name\":\"r\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"}],\"name\":\"encodePath\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"quoteExactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"quoteExactOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"contract IUniswapV2Router01\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC20\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swapExactInput\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swapExactOutput\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"transferToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"wchi\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SwapperUniswapV2", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "5000", "ConstructorArguments": "000000000000000000000000e79feaaa457ad7899357e8e2065a3267ac9ee601000000000000000000000000a5e0829caced8ffdd4de3c43696c57f7d7a678ff", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}