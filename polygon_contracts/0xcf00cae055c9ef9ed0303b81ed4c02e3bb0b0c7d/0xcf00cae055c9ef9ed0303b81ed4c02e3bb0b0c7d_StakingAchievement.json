{"SourceCode": "// Copyright (c) 2022 EverRise Pte Ltd. All rights reserved.\r\n// EverRise licenses this file to you under the MIT license.\r\n/*\r\n EverRise Memento NFTs are awards for completing EverRise staking terms,\r\n participating in events and winning challenges.\r\n\r\n  ___________      ________                              _______   __\r\n '._==_==_=_.'    /        |                            /       \\ /  |\r\n .-\\:      /-.   $$$$$$$$/__     __  ______    ______  $$$$$$$  |$$/   _______   ______  v3.14159265\r\n| (|:.     |) |  $$ |__  /  \\   /  |/      \\  /      \\ $$ |__$$ |/  | /       | /      \\\r\n '-|:.     |-'   $$    | $$  \\ /$$//$$$$$$  |/$$$$$$  |$$    $$< $$ |/$$$$$$$/ /$$$$$$  |\r\n   \\::.    /     $$$$$/   $$  /$$/ $$    $$ |$$ |  $$/ $$$$$$$  |$$ |$$      \\ $$    $$ |\r\n    '::. .'      $$ |_____ $$ $$/  $$$$$$$$/ $$ |      $$ |  $$ |$$ | $$$$$$  |$$$$$$$$/\r\n      ) (        $$       | $$$/   $$       |$$ |      $$ |  $$ |$$ |/     $$/ $$       |\r\n    _.' '._      $$$$$$$$/   $/     $$$$$$$/ $$/       $$/   $$/ $$/ $$$$$$$/   $$$$$$$/ Magnum opus\r\n   `\"\"\"\"\"\"\"`     \r\n\r\nLearn more about EverRise and the EverRise Ecosystem of dApps and\r\nhow our utilities and partners can help protect your investors\r\nand help your project grow: https://everrise.com\r\n*/\r\n\r\n// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.13;\r\n\r\nerror NotSetup();                          // 0xb09c99c0\r\nerror WalletLocked();                      // 0xd550ed24\r\nerror FailedEthSend();                     // 0xb5747cc7\r\nerror NotZeroAddress();                    // 0x66385fa3\r\nerror CallerNotApproved();                 // 0x4014f1a5\r\nerror InvalidAddress();                    // 0xe6c4247b\r\nerror CallerNotOwner();                    // 0x5cd83192\r\nerror AmountMustBeGreaterThanZero();       // 0x5e85ae73\r\nerror AmountOutOfRange();                  // 0xc64200e9\r\n\r\naddress constant EverMigrateAddress = 0x429CA183C5f4B43F09D70580C5365a6D21ccCd47;\r\naddress constant EverRiseV1Address_BSC = 0xC7D43F2B51F44f09fBB8a691a0451E8FFCF36c0a;\r\naddress constant EverRiseV1Address_ETH = 0x8A2D988Fe2E8c6716cbCeF1B33Df626C692F7B98;\r\naddress constant EverRiseV2Address = 0x0cD022ddE27169b20895e0e2B2B8A33B25e63579;\r\naddress constant EverRiseV2Address_AVAX = 0xC3A8d300333BFfE3ddF6166F2Bc84E6d38351BED;\r\naddress constant EverRiseV3Address = 0xC17c30e98541188614dF99239cABD40280810cA3;\r\naddress constant nftRiseV3Address = 0x23cD2E6b283754Fd2340a75732f9DdBb5d11807e;\r\n\r\n// Testnet\r\n// address constant EverRiseV3Address = 0x1665E2b184F352d226A882281f69ccf361349CC6;\r\n//address constant nftRiseV3Address = 0x0D3770c2318F84E33d0B0efEc8EfD2086683F0b2;\r\n//address constant EverRiseV3Address = 0x639631Ac62abE60c4F67278f80ca3291047eFc1B;\r\n// address constant nftRiseV3Address = 0x617cBE19e7A74dF4fb58eFE5830586c3466CC091;\r\n\r\naddress constant mintFeeAddress = 0xc3b7FfA7611C45C1245a1923065442BC94Af9757;\r\naddress constant royaltyFeeAddress = 0x0BFc8f6374028f1a61Ae3019E5C845F461575381;\r\nbytes constant ipfsAddress = \"ipfs://bafybeidj6gy62qkgwi6ww32iw2khbjcusf3xefvi2gugykdfau54mvux54/metaOutput/\";\r\n\r\ninterface ICreateRecipe {\r\n    function createTo(address account, uint256 toTokenId, uint256 toAmount) external;\r\n}\r\n\r\n// File: memeRISE/ITransmuteRecipe.sol\r\n\r\ninterface ITransmuteSingleRecipe {\r\n    function transmuteSingleTo(\r\n        address account,\r\n        uint256 toToken,\r\n        uint256 toAmount,\r\n        uint256[] calldata fromIds,\r\n        uint256[] calldata fromAmounts)\r\n    external;\r\n}\r\n\r\ninterface ITransmuteMultipleRecipe {\r\n    function transmuteMultipleTo(\r\n        address account,\r\n        uint256[] calldata toTokenIds,\r\n        uint256[] calldata toAmounts,\r\n        uint256[] calldata fromIds,\r\n        uint256[] calldata fromAmounts)\r\n    external;\r\n}\r\n\r\n// File: memeRISE/Abstract/nativeCoinSender.sol\r\n\r\ncontract NativeCoinSender {\r\n    function sendEthViaCall(address payable to, uint256 amount) internal {\r\n        (bool sent, ) = to.call{value: amount}(\"\");\r\n        if (!sent) revert FailedEthSend();\r\n    }\r\n}\r\n\r\n// File: memeRISE/Interfaces/IEverRoyaltySplitter.sol\r\n\r\ninterface IEverRoyaltySplitter {\r\n    event RoyaltiesSplit(uint256 value);\r\n    event SplitUpdated(uint256 previous, uint256 current);\r\n    event UniswapV2RouterSet(address indexed previous, address indexed current);\r\n    event EverRiseEcosystemSet(address indexed previous, address indexed current);\r\n    event EverRiseTokenSet(address indexed previous, address indexed current);\r\n    event StableCoinSet(address indexed previous, address indexed current);\r\n\r\n    function distribute() external;\r\n}\r\n\r\n// File: memeRISE/Interfaces/IERC173-Ownable.sol\r\n\r\ninterface IOwnable {\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    function owner() external view returns (address);\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n\r\n// File: memeRISE/Abstract/Context.sol\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address payable) {\r\n        return payable(msg.sender);\r\n    }\r\n}\r\n\r\n// File: memeRISE/Abstract/ERC173-Ownable.sol\r\n\r\ncontract Ownable is IOwnable, Context {\r\n    address public owner;\r\n\r\n    function _onlyOwner() private view {\r\n        if (owner != _msgSender()) revert CallerNotOwner();\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _onlyOwner();\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        address msgSender = _msgSender();\r\n        owner = msgSender;\r\n        emit OwnershipTransferred(address(0), msgSender);\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        if (newOwner == address(0)) revert NotZeroAddress();\r\n\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: memeRISE/Interfaces/IERC20-Token.sol\r\n\r\ninterface IERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function transferFromWithPermit(address sender, address recipient, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool);\r\n}\r\n\r\ninterface IERC20Metadata is IERC20 {\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n}\r\n\r\n// File: memeRISE/Interfaces/IEverRise.sol\r\n\r\nstruct ApprovalChecks {\r\n    // Prevent permits being reused (IERC2612)\r\n    uint64 nonce;\r\n    // Allow revoke all spenders/operators approvals in single txn\r\n    uint32 nftCheck;\r\n    uint32 tokenCheck;\r\n    // Allow auto timeout on approvals\r\n    uint16 autoRevokeNftHours;\r\n    uint16 autoRevokeTokenHours;\r\n    // Allow full wallet locking of all transfers\r\n    uint48 unlockTimestamp;\r\n}\r\n\r\nstruct Allowance {\r\n    uint128 tokenAmount;\r\n    uint32 nftCheck;\r\n    uint32 tokenCheck;\r\n    uint48 timestamp;\r\n    uint8 nftApproval;\r\n    uint8 tokenApproval;\r\n}\r\n\r\ninterface IEverRise is IERC20Metadata {\r\n    function totalBuyVolume() external view returns (uint256);\r\n    function totalSellVolume() external view returns (uint256);\r\n    function holders() external view returns (uint256);\r\n    function uniswapV2Pair() external view returns (address);\r\n    function transferStake(address fromAddress, address toAddress, uint96 amountToTransfer) external;\r\n    function isWalletLocked(address fromAddress) external view returns (bool);\r\n    function setApprovalForAll(address fromAddress, address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function isExcludedFromFee(address account) external view returns (bool);\r\n\r\n    function approvals(address operator) external view returns (ApprovalChecks memory);\r\n}\r\n\r\n// File: memeRISE/Interfaces/IERC165-SupportsInterface.sol\r\n\r\ninterface IERC165 {\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n// File: memeRISE/Abstract/ERC165-SupportsInterface.sol\r\n\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n// File: memeRISE/Interfaces/IERC2981-Royalty.sol\r\n\r\ninterface IERC2981 is IERC165 {\r\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (\r\n        address receiver,\r\n        uint256 royaltyAmount\r\n    );\r\n}\r\n\r\n// File: memeRISE/Abstract/royaltyHandler.sol\r\n\r\nabstract contract royaltyHandler is IERC2981, Ownable {\r\n    event RoyaltyFeeUpdated(uint256 newValue);\r\n    event RoyaltyAddressUpdated(address indexed contractAddress);\r\n\r\n    IEverRoyaltySplitter public royaltySplitter;\r\n    uint256 public defaultRoyaltySplit = 5;\r\n\r\n    function setDefaultNftRoyaltyFeePercent(uint256 royaltySplitRate) external onlyOwner {\r\n        if (royaltySplitRate > 10) revert AmountOutOfRange();\r\n        defaultRoyaltySplit = royaltySplitRate;\r\n\r\n        emit RoyaltyFeeUpdated(royaltySplitRate);\r\n    }\r\n\r\n    function setRoyaltyAddress(address newAddress) external onlyOwner {\r\n        if (newAddress == address(0)) revert NotZeroAddress();\r\n\r\n        _setRoyaltyAddress(newAddress);\r\n    }\r\n\r\n    function _setRoyaltyAddress(address newAddress) internal {\r\n        royaltySplitter = IEverRoyaltySplitter(newAddress);\r\n        emit RoyaltyAddressUpdated(newAddress);\r\n    }\r\n\r\n    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) external view returns (\r\n        address receiver,\r\n        uint256 royaltyAmount\r\n    ) {\r\n        if (_tokenId == 0) revert AmountMustBeGreaterThanZero();\r\n\r\n        return (address(royaltySplitter), _salePrice / defaultRoyaltySplit);\r\n    }\r\n}\r\n\r\n// File: memeRISE/Interfaces/IMementoRise.sol\r\n\r\ninterface IMementoRise {\r\n    function royaltyAddress() external view returns(address payable);\r\n    function mint(address to, uint256 tokenId, uint256 amount) external;\r\n    function mintFee(uint16 typeId) external returns (uint256);\r\n}\r\n\r\n// File: memeRISE/mementoRecipe.sol\r\n\r\nabstract contract MementoRecipe is NativeCoinSender, Ownable {\r\n    IMementoRise public mementoRise;\r\n    IEverRise public everRiseToken = IEverRise(EverRiseV3Address);\r\n\r\n    event EverRiseTokenSet(address indexed tokenAddress);\r\n    event MementoRiseSet(address indexed nftAddress);\r\n    \r\n    modifier onlyMementoRise() {\r\n        require(_msgSender() == address(mementoRise), \"Invalid requestor\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _mementoRise) {\r\n        setMementoRise(_mementoRise);\r\n    }\r\n\r\n    function setEverRiseToken(address tokenAddress) external onlyOwner {\r\n        if (tokenAddress == address(0)) revert NotZeroAddress();\r\n        \r\n        everRiseToken = IEverRise(tokenAddress);\r\n\r\n        emit EverRiseTokenSet(tokenAddress);\r\n    }\r\n\r\n    function setMementoRise(address nftAddress) public onlyOwner {\r\n        if (nftAddress == address(0)) revert NotZeroAddress();\r\n\r\n        mementoRise = IMementoRise(nftAddress);\r\n\r\n        emit MementoRiseSet(nftAddress);\r\n    }\r\n\r\n    function krakenMintFee(uint256 baseFee, uint256 quantity) internal {\r\n        distributeMintFee(payable(address(everRiseToken)), baseFee, quantity);\r\n    }\r\n\r\n    function handleMintFee(uint256 baseFee, uint256 quantity) internal {\r\n        distributeMintFee(mementoRise.royaltyAddress(), baseFee, quantity);\r\n    }\r\n\r\n    function distributeMintFee(address payable receiver, uint256 baseFee, uint256 quantity) private {\r\n        uint256 _mintFee = baseFee * quantity;\r\n        require(_mintFee == 0 || msg.value >= _mintFee, \"Mint fee not covered\");\r\n\r\n        uint256 _balance = address(this).balance;\r\n        if (_balance > 0) {\r\n            // Transfer everything, easier than transferring extras later\r\n            sendEthViaCall(receiver, _balance);\r\n        }\r\n    }\r\n}\r\n\r\n// File: memeRISE/Interfaces/IERC1155-MultiToken.sol\r\n\r\ninterface IERC1155 is IERC165 {\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n    \r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n    event URI(string value, uint256 indexed id);\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\ninterface IERC1155Receiver is IERC165 {\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external view returns (bytes4);\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external view returns (bytes4);\r\n}\r\n\r\ninterface IERC1155MetadataURI {\r\n    function uri(uint256 id) external view returns (string memory);\r\n}\r\n\r\n// File: memeRISE/mementoRise.sol\r\n\r\n// Copyright (c) 2022 EverRise Pte Ltd. All rights reserved.\r\n// EverRise licenses this file to you under the MIT license.\r\n/*\r\n EverRise Memento NFTs are awards for completing EverRise staking terms,\r\n participating in events and winning challenges.\r\n\r\n  ___________      ________                              _______   __\r\n '._==_==_=_.'    /        |                            /       \\ /  |\r\n .-\\:      /-.   $$$$$$$$/__     __  ______    ______  $$$$$$$  |$$/   _______   ______  v3.14159265\r\n| (|:.     |) |  $$ |__  /  \\   /  |/      \\  /      \\ $$ |__$$ |/  | /       | /      \\\r\n '-|:.     |-'   $$    | $$  \\ /$$//$$$$$$  |/$$$$$$  |$$    $$< $$ |/$$$$$$$/ /$$$$$$  |\r\n   \\::.    /     $$$$$/   $$  /$$/ $$    $$ |$$ |  $$/ $$$$$$$  |$$ |$$      \\ $$    $$ |\r\n    '::. .'      $$ |_____ $$ $$/  $$$$$$$$/ $$ |      $$ |  $$ |$$ | $$$$$$  |$$$$$$$$/\r\n      ) (        $$       | $$$/   $$       |$$ |      $$ |  $$ |$$ |/     $$/ $$       |\r\n    _.' '._      $$$$$$$$/   $/     $$$$$$$/ $$/       $$/   $$/ $$/ $$$$$$$/   $$$$$$$/ Magnum opus\r\n   `\"\"\"\"\"\"\"`     \r\n\r\nLearn more about EverRise and the EverRise Ecosystem of dApps and\r\nhow our utilities and partners can help protect your investors\r\nand help your project grow: https://everrise.com\r\n*/\r\n\r\ninterface IOpenSeaCollectible {\r\n    function contractURI() external view returns (string memory);\r\n}\r\n\r\nabstract contract EverRiseTokenManaged is Ownable {\r\n    IEverRise public everRiseToken;\r\n\r\n    function setEverRiseToken(address tokenAddress) public onlyOwner {\r\n        if (tokenAddress == address(0)) revert NotZeroAddress();\r\n\r\n        everRiseToken = IEverRise(tokenAddress);\r\n\r\n        emit EverRiseTokenSet(tokenAddress);\r\n    }\r\n\r\n    event EverRiseTokenSet(address indexed tokenAddress);\r\n}\r\n\r\ninterface IEverMigrate {\r\n    function userTransaction(address sourceToken, address userAddress, uint256 position) external view returns (uint256, uint256, uint32);\r\n}\r\n\r\nenum Animal\r\n{\r\n    Plankton, \r\n    Seahorse, \r\n    Starfish, \r\n    Swordfish, \r\n    Stingray, \r\n    Dolphin, \r\n    Narwhal, \r\n    Shark, \r\n    Orca, \r\n    Whale, \r\n    Megalodon, \r\n    Kraken\r\n}\r\n\r\ncontract MigrationV1V2Achievement is MementoRecipe {\r\n    mapping (uint256 => bool) public processedTxn;\r\n    mapping (address => uint16) public claimedReward;\r\n\r\n    IEverMigrate public migrate = IEverMigrate(EverMigrateAddress);\r\n    address immutable public everRiseV1;\r\n\r\n    constructor(address _mementoRise) MementoRecipe(_mementoRise) {\r\n        everRiseV1 = block.chainid == 1 ? \r\n            EverRiseV1Address_ETH :\r\n            EverRiseV1Address_BSC;\r\n    }\r\n\r\n    function claimMigrationAchievement(uint256 tokenId, uint256 txnPosition)\r\n        external payable\r\n    {\r\n        address from = _msgSender();\r\n        (uint256 amount,, uint256 txnId) = migrate.userTransaction(everRiseV1, from, txnPosition);\r\n\r\n        require(txnId > 0, \"Invalid txn\");\r\n        require(!processedTxn[txnId], \"Already claimed txn\");\r\n        processedTxn[txnId] = true;\r\n\r\n        handleMintFee(mementoRise.mintFee(uint16(tokenId & 0xffff)), 1);\r\n\r\n        Animal animal = Animal(tokenId >> 16);\r\n        require(amount > getMinAmount(animal), \"Not enough\");\r\n\r\n        uint16 flag = uint16(1 << uint8(animal));\r\n        uint16 flags = claimedReward[from];\r\n\r\n        require(flags & flag == 0, \"Already claimed level\");\r\n        claimedReward[from] = flags | flag;\r\n\r\n        mementoRise.mint(from, tokenId, 1);\r\n    }\r\n\r\n    function getMinAmount(Animal animal) private pure returns (uint256) {\r\n        // 'Plankton', threshold: 1000 }\r\n        if (animal == Animal.Plankton) {\r\n            return (1_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Seahorse', threshold: 10000 },\r\n        if (animal == Animal.Seahorse) {\r\n            return (10_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Starfish', threshold: 50000 },\r\n        if (animal == Animal.Starfish) {\r\n            return (50_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'SwordFish', threshold: 100000 },\r\n        if (animal == Animal.Swordfish) {\r\n            return (100_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Stingray', threshold: 500000 },\r\n        if (animal == Animal.Stingray) {\r\n            return (500_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Dolphin', threshold: 1000000 },\r\n        if (animal == Animal.Dolphin) {\r\n            return (1_000_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Narwhal', threshold: 5000000 },\r\n        if (animal == Animal.Narwhal) {\r\n            return (5_000_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Shark', threshold: 10000000 },\r\n        if (animal == Animal.Shark) {\r\n            return (10_000_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Orca', threshold: 25000000 },\r\n        if (animal == Animal.Orca) {\r\n            return (25_000_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Whale', threshold: 50000000 },\r\n        if (animal == Animal.Whale) {\r\n            return (50_000_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Megalodon', threshold: 100000000 },\r\n        if (animal == Animal.Megalodon) {\r\n            return (100_000_000 - 1) * 10**4 * 10**9;\r\n        }\r\n        // 'Kraken' threshold: 250000000\r\n        if (animal == Animal.Kraken) {\r\n            return (250_000_000 - 1) * 10**4 * 10**9;\r\n        }\r\n\r\n        require(false, \"Unknown level\");\r\n        return (250_000_000_000 - 1) * 10**4 * 10**9;\r\n    }\r\n}\r\n\r\ncontract HolderV2Achievement is MementoRecipe, ICreateRecipe {\r\n    IERC20 immutable public everRiseV2;\r\n    mapping (address => bool) public processedClaim;\r\n\r\n    constructor(address _mementoRise) MementoRecipe(_mementoRise) {\r\n        everRiseV2 = block.chainid == 43114 ? \r\n            IERC20(EverRiseV2Address_AVAX) :\r\n            IERC20(EverRiseV2Address);\r\n    }\r\n\r\n    function createTo(address account, uint256 toTokenId, uint256 toAmount)\r\n        external onlyMementoRise\r\n    {\r\n        require(toTokenId == 3, \"Nft doesn't exist\");\r\n        require(toAmount == 1, \"Can only claim one per chain\");\r\n\r\n        require(everRiseV2.balanceOf(account) > 0, \"Not holding RISE v2\");\r\n        require(!processedClaim[account], \"Already claimed\");\r\n\r\n        processedClaim[account] = true;\r\n    }\r\n}\r\n\r\nstruct StakingDetails {\r\n    uint96 initialTokenAmount;    // Max 79 Bn tokens\r\n    uint96 withdrawnAmount;       // Max 79 Bn tokens\r\n    uint48 depositTime;           // 8 M years\r\n    uint8 numOfMonths;            // Max 256 month period\r\n    uint8 achievementClaimed;\r\n    // 256 bits, 20000 gwei gas\r\n    address stakerAddress;        // 160 bits (96 bits remaining)\r\n    uint32 nftId;                 // Max 4 Bn nfts issued\r\n    uint32 lookupIndex;           // Max 4 Bn active stakes\r\n    uint24 stakerIndex;           // Max 16 M active stakes per wallet\r\n    uint8 isActive;\r\n    // 256 bits, 20000 gwei gas\r\n} // Total 768 bits, 40000 gwei gas\r\n\r\ninterface InftEverRise {\r\n    function getNftData(uint256 id) external view returns (StakingDetails memory);\r\n    function claimAchievement(address staker, uint256 nftId) external returns (uint32 newNftId);\r\n}\r\n\r\ncontract StakingAchievement is MementoRecipe {\r\n    InftEverRise public nftRise;\r\n\r\n    constructor(address _mementoRise) MementoRecipe(_mementoRise) {\r\n        nftRise = InftEverRise(nftRiseV3Address);\r\n    }\r\n\r\n    function _walletLock(address fromAddress) private view {\r\n        if (everRiseToken.isWalletLocked(fromAddress)) revert WalletLocked();\r\n    }\r\n\r\n    modifier walletLock(address fromAddress) {\r\n        _walletLock(fromAddress);\r\n        _;\r\n    }\r\n\r\n    function getTokenId(uint256 chainId, uint256 animalId, uint256 months) public pure returns (uint256) {\r\n        require(chainId <= type(uint8).max, \"Chain out of range\");\r\n        require(animalId <= type(uint8).max, \"AnimalId out of range\");\r\n        require(months <= type(uint8).max, \"Months out of range\");\r\n\r\n        uint256 generatedTokenId = 1;\r\n\r\n        generatedTokenId += chainId << 16;\r\n        generatedTokenId += animalId << 24;\r\n        generatedTokenId += months << 32;\r\n\r\n        return generatedTokenId;\r\n    }\r\n\r\n    function claimStakingAchievement(uint256 tokenId, uint256 stakeNftId) external payable walletLock(_msgSender()) {\r\n        address from = _msgSender();\r\n\r\n        krakenMintFee(mementoRise.mintFee(uint16(tokenId & 0xffff)), 1);\r\n        uint32 newNftId = nftRise.claimAchievement(from, stakeNftId);\r\n\r\n        StakingDetails memory stakeDetails = nftRise.getNftData(newNftId);\r\n\r\n        uint256 generatedTokenId = 1;\r\n\r\n        generatedTokenId += getChain() << 16;\r\n        generatedTokenId += getAnimal(stakeDetails.initialTokenAmount) << 24;\r\n        generatedTokenId += getMaterial(stakeDetails.numOfMonths) << 32;\r\n\r\n        require(generatedTokenId == tokenId, \"Incorrect nft requested\");\r\n\r\n        mementoRise.mint(from, tokenId, 1);\r\n    }\r\n\r\n    function getMaterial(uint256 months) private pure returns (uint256) {\r\n        if (months > 0 && months <= 12) return months;\r\n        if (months == 24) return 14;\r\n        if (months == 36) return 15;\r\n\r\n        require(false, \"Invalid time\");\r\n        return 0;\r\n    }\r\n    \r\n    function getAnimal(uint256 threshold) private pure returns (uint256) {\r\n      // 'Kraken' threshold: 250000000\r\n      if (threshold > (250_000_000 - 1) * 10**18) {\r\n          return 11;\r\n      }\r\n      // 'Megalodon', threshold: 100000000 },\r\n      if (threshold > (100_000_000 - 1) * 10**18) {\r\n          return 10;\r\n      }\r\n      // 'Whale', threshold: 50000000 },\r\n      if (threshold > (50_000_000 - 1) * 10**18) {\r\n           return 9;\r\n      }\r\n      // 'Orca', threshold: 25000000 },\r\n      if (threshold > (25_000_000 - 1) * 10**18) {\r\n          return 8;\r\n      }\r\n      // 'Shark', threshold: 10000000 },\r\n      if (threshold > (10_000_000 - 1) * 10**18) {\r\n          return 7;\r\n      }\r\n      // 'Narwhal', threshold: 5000000 },\r\n      if (threshold > (5_000_000 - 1) * 10**18) {\r\n          return 6;\r\n      }\r\n      // 'Dolphin', threshold: 1000000 },\r\n      if (threshold > (1_000_000 - 1) * 10**18) {\r\n          return 5;\r\n      }\r\n      // 'Stingray', threshold: 500000 },\r\n      if (threshold > (500_000 - 1) * 10**18) {\r\n          return 4;\r\n      }\r\n      // 'Swordfish', threshold: 100000 },\r\n      if (threshold > (100_000 - 1) * 10**18) {\r\n          return 3;\r\n      }\r\n      // 'Starfish', threshold: 50000 },\r\n      if (threshold > (50_000 - 1) * 10**18) {\r\n          return 2;\r\n      }\r\n      // 'Seahorse', threshold: 10000 },\r\n      if (threshold > (10_000 - 1) * 10**18) {\r\n          return 1;\r\n      }\r\n      // 'Plankton', threshold: 1000 }\r\n      if (threshold > (1_000 - 1) * 10**18) {\r\n          return 0;\r\n      }\r\n      // Smaller\r\n      require(false, \"Too small\");\r\n      return 0;\r\n    }\r\n\r\n    function getChain() private view returns (uint256) {\r\n        uint256 chainId = block.chainid;\r\n        if (chainId == 1 || chainId == 3 || chainId == 4 || chainId == 5 || chainId == 42) // Ethereum \r\n            return 4;\r\n        if (chainId == 56 || chainId == 97) // BNB\r\n            return 2;\r\n        if (chainId == 137 || chainId == 80001) // Polygon\r\n            return 3;\r\n        if (chainId == 250 || chainId == 4002) // Fantom \r\n            return 1;\r\n        if (chainId == 43114 || chainId == 43113) // Avalanche\r\n            return 0;\r\n\r\n      require(false, \"Unknown chain\");\r\n      return 0;\r\n    }\r\n}\r\n\r\ntype BalanceKey is uint256;\r\ntype BalanceAmount is uint256;\r\n\r\nlibrary AmountLib {\r\n    function add(BalanceAmount b, uint256 value) internal pure returns (BalanceAmount) {\r\n        require(value < type(uint240).max, \"Out of range\");\r\n\r\n        uint256 amountPos = BalanceAmount.unwrap(b);\r\n        uint240 amount = uint240(amountPos >> 16);\r\n        uint16 position = uint16(amountPos & 0xffff);\r\n\r\n        amount += uint240(value);\r\n        amountPos = (uint256(amount) << 16) | position;\r\n\r\n        return BalanceAmount.wrap(amountPos);\r\n    }\r\n\r\n    function subtract(BalanceAmount b, uint256 value) internal pure returns (BalanceAmount) {\r\n        require(value < type(uint240).max, \"Out of range\");\r\n\r\n        uint256 amountPos = BalanceAmount.unwrap(b);\r\n        uint240 amount = uint240(amountPos >> 16);\r\n        uint16 position = uint16(amountPos & 0xffff);\r\n\r\n        require (amount >= value, \"Balance too low\");\r\n\r\n        unchecked {\r\n            amount -= uint240(value);\r\n        }\r\n        amountPos = (uint256(amount) << 16) | position;\r\n\r\n        return BalanceAmount.wrap(amountPos);\r\n    }\r\n\r\n    function Amount(BalanceAmount b) internal pure returns (uint256 value) {\r\n        uint256 amountPos = BalanceAmount.unwrap(b);\r\n        return uint240(amountPos >> 16);\r\n    }\r\n    \r\n    function getPosition(BalanceAmount b) internal pure returns (uint16) {\r\n        uint256 amountPos = BalanceAmount.unwrap(b);\r\n        return uint16(amountPos & 0xffff);\r\n    }\r\n\r\n    function setPosition(BalanceAmount b, uint16 position) internal pure returns (BalanceAmount) {\r\n        uint256 amountPos = BalanceAmount.unwrap(b);\r\n        uint240 amount = uint240(amountPos >> 16);\r\n\r\n        return BalanceAmount.wrap((uint256(amount) << 16) | position);\r\n    }\r\n}\r\n\r\ncontract MementoRise is EverRiseTokenManaged, royaltyHandler, NativeCoinSender, ERC165, IERC1155, IMementoRise, IERC1155MetadataURI, IOpenSeaCollectible {\r\n    using AmountLib for BalanceAmount; \r\n\r\n    event BaseUriForTypeSet(uint16 indexed nftType, string uri);\r\n    event NftBridgeSet(address bridge);\r\n    event NftBridgedIn(address indexed contractAddress, address indexed operator, address indexed to, uint256 id, uint256 amount);\r\n    event NftsBridgedIn(address indexed contractAddress, address indexed operator, address indexed to, uint256[] ids, uint256[] amounts);\r\n    event NftBridgedOut(address indexed contractAddress, address indexed operator, address indexed from, uint256 id, uint256 amount);\r\n    event NftsBridgedOut(address indexed contractAddress, address indexed operator, address indexed from, uint256[] ids, uint256[] amounts);\r\n    \r\n    event TransferExternalTokens(address indexed tokenAddress, address indexed to, uint256 count);\r\n    event SetMintFee(uint16 typeId, uint256 fee);\r\n    event SetTransmuteFee(uint16 typeId, uint256 fee);\r\n    event SetMintFeeDefault(uint256 fee);\r\n    event SetTransmuteFeeDefault(uint256 fee);\r\n\r\n    event SetAllowedCreateTo(uint16 nftType, address contractAddress);\r\n    event SetAllowedCreateFrom(uint16 nftType, address contractAddress);\r\n    event SetAllowedTransumtateSingleTo(uint16 nftType, address contractAddress);\r\n    event SetAllowedTransumtateMultipleTo(uint16 nftType, address contractAddress);\r\n\r\n    address public nftBridge;\r\n    uint256 public defaultCreateFee;\r\n    uint256 public defaultTransmuteFee;\r\n\r\n    mapping (uint16 => uint256) private _mintFee;\r\n    mapping (uint16 => uint256) private _transmuteFee;\r\n\r\n    mapping (uint16 => ICreateRecipe) public allowedCreateTo;\r\n    mapping (uint16 => ITransmuteSingleRecipe) public allowedTransumtateSingleTo;\r\n    mapping (uint16 => ITransmuteMultipleRecipe) public allowedTransumtateMultipleTo;\r\n    mapping (uint16 => address) public allowedCreateFrom;\r\n    mapping (uint16 => bytes) public baseUris;\r\n\r\n    mapping (BalanceKey => BalanceAmount) private _balanceOf;\r\n    mapping (address => uint96[]) public tokensHeld;\r\n\r\n    // Mapping from account to operator approvals\r\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\r\n\r\n    StakingAchievement public stakingAchievement;\r\n    MigrationV1V2Achievement public migrationV1V2Achievement;\r\n    HolderV2Achievement public holderV2Achievement;\r\n\r\n    constructor(address _owner) {\r\n        _setRoyaltyAddress(royaltyFeeAddress);\r\n        \r\n        StakingAchievement _stakingAchievement = new StakingAchievement(address(this));\r\n        MigrationV1V2Achievement _migrationV1V2Achievement = new MigrationV1V2Achievement(address(this));\r\n        HolderV2Achievement _holderV2Achievement = new HolderV2Achievement(address(this));\r\n\r\n        stakingAchievement = _stakingAchievement;\r\n        migrationV1V2Achievement = _migrationV1V2Achievement;\r\n        holderV2Achievement = _holderV2Achievement;\r\n\r\n        allowedCreateFrom[1] = address(_stakingAchievement);\r\n        allowedCreateFrom[2] = address(_migrationV1V2Achievement);\r\n        allowedCreateTo[3] = _holderV2Achievement;\r\n        uint256 _defaultCreateFee = getDefaultCreateFee();\r\n        defaultCreateFee = _defaultCreateFee;\r\n        uint256 _defaultTransmuteFee = _defaultCreateFee * 5 / 2; // x2.5\r\n        defaultTransmuteFee = _defaultTransmuteFee;\r\n\r\n        emit SetMintFeeDefault(_defaultCreateFee);\r\n        emit SetTransmuteFeeDefault(_defaultTransmuteFee);\r\n\r\n        setEverRiseToken(EverRiseV3Address);\r\n        transferOwnership(_owner);\r\n        _stakingAchievement.transferOwnership(_owner);\r\n        _migrationV1V2Achievement.transferOwnership(_owner);\r\n        _holderV2Achievement.transferOwnership(_owner);\r\n\r\n        bytes memory _uri = ipfsAddress;\r\n        baseUris[1] = _uri;\r\n        baseUris[2] = _uri;\r\n        baseUris[3] = _uri;\r\n\r\n        emit TransferSingle(address(this), address(0), address(0), 4295098369, 0);\r\n        emit TransferSingle(address(this), address(0), address(0), 2, 0);\r\n        emit TransferSingle(address(this), address(0), address(0), 3, 0);\r\n    }\r\n\r\n    function name() external pure returns (string memory) {\r\n        return \"EverRise Mementos\";\r\n    }\r\n\r\n    function symbol() external pure returns (string memory) {\r\n        return \"memeRISE\";\r\n    }\r\n\r\n    function decimals() external pure returns (uint8) {\r\n        return 0;\r\n    }\r\n\r\n    uint256 public totalSupply;\r\n\r\n    function setMintFee(uint16 typeId, uint256 fee) external onlyOwner {\r\n        _mintFee[typeId] = fee;\r\n\r\n        emit SetMintFee(typeId, fee);\r\n    }\r\n\r\n    function setTransmuteFee(uint16 typeId, uint256 fee) external onlyOwner {\r\n        _transmuteFee[typeId] = fee;\r\n\r\n        emit SetTransmuteFee(typeId, fee);\r\n    }\r\n\r\n    function setMintFeeDefault(uint256 fee) external onlyOwner {\r\n        defaultCreateFee = fee;\r\n\r\n        emit SetMintFeeDefault(fee);\r\n    }\r\n\r\n    function setTransmuteFeeDefault(uint256 fee) external onlyOwner {\r\n        defaultTransmuteFee = fee;\r\n\r\n        emit SetTransmuteFeeDefault(fee);\r\n    }\r\n\r\n    function mintFee(uint16 typeId) public view returns (uint256) {\r\n        uint256 fee = _mintFee[typeId];\r\n\r\n        if (fee == 0) return defaultCreateFee;\r\n\r\n        return fee;\r\n    }\r\n\r\n    function transmuteFee(uint16 typeId) public view returns (uint256) {\r\n        uint256 fee = _transmuteFee[typeId];\r\n\r\n        if (fee == 0) return defaultTransmuteFee;\r\n\r\n        return fee;\r\n    }\r\n\r\n    function getDefaultCreateFee() private view returns (uint256) {\r\n        uint256 chainId = block.chainid;\r\n        if (chainId == 1) // Ethereum \r\n            return 10000000000000000; // 0.01\r\n        if (chainId == 56) // BNB\r\n            return 10000000000000000; // 0.01\r\n        if (chainId == 137) // Polygon\r\n            return 3000000000000000000; // 3\r\n        if (chainId == 250) // Fantom \r\n            return 3000000000000000000; // 3\r\n        if (chainId == 43114) // Avalanche\r\n            return 50000000000000000; // 0.05\r\n\r\n        return 3000000000000000000;\r\n    }\r\n\r\n    function setNftBridge(address _bridge) external onlyOwner {\r\n        nftBridge = _bridge;\r\n\r\n        emit NftBridgeSet(nftBridge);\r\n    }\r\n\r\n    function setBaseUriForType(uint16 nftType, string calldata baseUri) external onlyOwner {\r\n        baseUris[nftType] = bytes(baseUri);\r\n\r\n        emit BaseUriForTypeSet(nftType, baseUri);\r\n    }\r\n\r\n    function setAllowedCreateTo(uint16 nftType, address contractAddress) external onlyOwner {\r\n        allowedCreateTo[nftType] = ICreateRecipe(contractAddress);\r\n\r\n        emit SetAllowedCreateTo(nftType, contractAddress);\r\n    }\r\n\r\n    function setAllowedCreateFrom(uint16 nftType, address contractAddress) external onlyOwner {\r\n        allowedCreateFrom[nftType] = contractAddress;\r\n\r\n        emit SetAllowedCreateFrom(nftType, contractAddress);\r\n    }\r\n\r\n    function setAllowedTransumtateSingleTo(uint16 nftType, address contractAddress) external onlyOwner {\r\n        allowedTransumtateSingleTo[nftType] = ITransmuteSingleRecipe(contractAddress);\r\n\r\n        emit SetAllowedTransumtateSingleTo(nftType, contractAddress);\r\n    }\r\n\r\n    function setAllowedTransumtateMultipleTo(uint16 nftType, address contractAddress) external onlyOwner {\r\n        allowedTransumtateMultipleTo[nftType] = ITransmuteMultipleRecipe(contractAddress);\r\n\r\n        emit SetAllowedTransumtateMultipleTo(nftType, contractAddress);\r\n    }\r\n\r\n    function royaltyAddress() external view returns (address payable) {\r\n        return payable(address(royaltySplitter));\r\n    }\r\n\r\n    function tokenURI(uint256 id) external view returns (string memory) {\r\n        return uri(id);\r\n    }\r\n\r\n    function uri(uint256 id) public view returns (string memory) {\r\n        uint16 nftType = uint16(id & 0xffff);\r\n        bytes memory baseUri = baseUris[nftType];\r\n\r\n        require(baseUri.length > 0, \"Uri not set\");\r\n\r\n        return string(abi.encodePacked(baseUri, uint2hexstr(id), \".json\"));\r\n    }\r\n\r\n    function uint2hexstr(uint i) public pure returns (string memory) {\r\n        uint mask = 15;\r\n        bytes memory bstr = new bytes(64);\r\n        uint k = 64;\r\n        while (k > 0) {\r\n            uint curr = (i & mask);\r\n            bstr[--k] = curr > 9 ?\r\n                bytes1(uint8(55 + curr)) :\r\n                bytes1(uint8(48 + curr)); // 55 = 65 - 10\r\n            i = i >> 4;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function contractURI() external view returns (string memory) {\r\n        return string(\r\n                abi.encodePacked(\"https://data.everrise.com/data/memerise-\",\r\n                toString(block.chainid),\r\n                \".json\")\r\n        );\r\n    }\r\n\r\n    function _walletLock(address fromAddress) private view {\r\n        if (everRiseToken.isWalletLocked(fromAddress)) revert WalletLocked();\r\n    }\r\n\r\n    modifier walletLock(address fromAddress) {\r\n        _walletLock(fromAddress);\r\n        _;\r\n    }\r\n\r\n    function handleMintFee(uint256 baseFee, uint256 quantity) internal {\r\n        uint256 totalFee = baseFee * quantity;\r\n        require(totalFee == 0 || msg.value >= totalFee, \"Mint fee not covered\");\r\n\r\n        uint256 _balance = address(this).balance;\r\n        if (_balance > 0) {\r\n            // Transfer everything, easier than transferring extras later\r\n            sendEthViaCall(payable(address(royaltySplitter)), _balance);\r\n        }\r\n    }\r\n\r\n    function toBalanceKey(address account, uint256 tokenId) private pure returns (BalanceKey) {\r\n        if (tokenId > type(uint96).max) revert AmountOutOfRange();\r\n\r\n        uint256 key = uint256(uint160(account)) << 96 | uint96(tokenId);\r\n        return BalanceKey.wrap(key);\r\n    }\r\n\r\n    function balanceOf(address account, uint256 tokenId) view public returns (uint256) {\r\n        if (account == address(0)) revert NotZeroAddress();\r\n\r\n        return _balanceOf[toBalanceKey(account, tokenId)].Amount();\r\n    }\r\n    \r\n    function mint(address to, uint256 tokenId, uint256 amount) external {\r\n        address requestor = _msgSender();\r\n        uint16 nftType = uint16(tokenId & 0xffff);\r\n        require(allowedCreateFrom[nftType] == requestor, \"Requestor not allowed to mint that type\");\r\n\r\n        // Mint new tokens\r\n        AddBalance(to, tokenId, amount);\r\n        emit TransferSingle(to, address(0), to, tokenId, amount);\r\n    }\r\n    \r\n    function create(uint256 tokenId, uint256 amount) external payable {\r\n        uint16 nftType = uint16(tokenId & 0xffff);\r\n        ICreateRecipe creator = allowedCreateTo[nftType];\r\n\r\n        if (address(creator) == address(0)) revert NotSetup();\r\n\r\n        handleMintFee(mintFee(nftType), amount);\r\n\r\n        address from = _msgSender();\r\n        creator.createTo(from, tokenId, amount);\r\n\r\n        // Mint new tokens\r\n        AddBalance(from, tokenId, amount);\r\n        emit TransferSingle(from, address(0), from, tokenId, amount);\r\n    }\r\n\r\n    function getAllTokensHeld(address account) external view returns (uint96[] memory tokenIds, uint256[] memory amounts) {\r\n        uint96[] storage refTokenIds = tokensHeld[account];\r\n        uint256 tokenIdsLength = refTokenIds.length;\r\n\r\n        if (tokenIdsLength < 2) {\r\n            // Position 0 is skipped\r\n            tokenIds = new uint96[](0);\r\n            amounts = new uint256[](0);\r\n            return (tokenIds, amounts);\r\n        }\r\n\r\n        uint256 length = tokenIdsLength - 1;\r\n        uint256 position;\r\n        tokenIds = new uint96[](length);\r\n        amounts = new uint256[](length);\r\n        for (uint256 i = 1; i < tokenIdsLength;) {\r\n            unchecked {\r\n                position = i - 1;\r\n            }\r\n            uint96 tokenId = refTokenIds[i];\r\n            tokenIds[position] = tokenId;\r\n            amounts[position] = _balanceOf[toBalanceKey(account, tokenId)].Amount();\r\n\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    function AddBalance(address account, uint256 tokenId, uint256 amount) private {\r\n        require(tokenId < type(uint96).max, \"Out of range\");\r\n\r\n        BalanceKey key = toBalanceKey(account, tokenId);\r\n        BalanceAmount currentBalance = _balanceOf[key];\r\n        if (currentBalance.getPosition() > 0) {\r\n            // Simple add\r\n            _balanceOf[key] = currentBalance.add(amount);\r\n        } else {\r\n            uint96[] storage refTokenIds = tokensHeld[account];\r\n            uint256 length = refTokenIds.length;\r\n            if (length == 0) {\r\n                // Add empty zero item\r\n                refTokenIds.push();\r\n                refTokenIds.push(uint96(tokenId));\r\n                _balanceOf[key] = BalanceAmount.wrap((uint256(amount) << 16) | 1);\r\n            } else {\r\n                require(length < type(uint16).max, \"Too many types\");\r\n                uint16 position = uint16(length);\r\n\r\n                refTokenIds.push(uint96(tokenId));\r\n                _balanceOf[key] = BalanceAmount.wrap((uint256(amount) << 16) | position);\r\n            }\r\n        }\r\n\r\n        totalSupply += amount;\r\n    }\r\n\r\n    function SubtractBalance(address account, uint256 tokenId, uint256 amount) private {\r\n        require(tokenId < type(uint96).max, \"Out of range\");\r\n\r\n        BalanceKey key = toBalanceKey(account, tokenId);\r\n        BalanceAmount currentBalance = _balanceOf[key];\r\n\r\n        uint16 position = currentBalance.getPosition();\r\n        require (position > 0, \"Non-existance\");\r\n\r\n        currentBalance = currentBalance.subtract(amount);\r\n\r\n        if (currentBalance.Amount() > 0) {\r\n            // Simple decrement\r\n            _balanceOf[key] = currentBalance;\r\n        } else {\r\n            _balanceOf[key] = BalanceAmount.wrap(0);\r\n            // Remove from position array\r\n            uint96[] storage refTokenIds = tokensHeld[account];\r\n            uint256 length = refTokenIds.length;\r\n            require (length > 1, \"Token List\");\r\n\r\n            uint256 last = length - 1;\r\n            if (position < last) {\r\n                uint96 lastTokenId = refTokenIds[last];\r\n                \r\n                key = toBalanceKey(account, lastTokenId);\r\n                currentBalance = _balanceOf[key];\r\n\r\n                _balanceOf[key] = currentBalance.setPosition(position);\r\n                refTokenIds[position] = lastTokenId;\r\n            }\r\n            \r\n            refTokenIds.pop();\r\n        }\r\n\r\n        totalSupply -= amount;\r\n    }\r\n\r\n    function transmuteMultiple(uint256[] calldata toTokenIds, uint256[] calldata toAmounts, uint256[] calldata fromIds, uint256[] calldata fromAmounts) external payable walletLock(_msgSender()) {\r\n        uint256 fromIdsLength = fromIds.length;\r\n        require(fromIdsLength > 0, \"No input tokens\");\r\n        require(fromIdsLength == fromAmounts.length, \"Input: ids and amounts length mismatch\");\r\n        uint256 toTokenIdsLength = toTokenIds.length;\r\n        require(toTokenIdsLength > 0, \"No output tokens\");\r\n        require(toTokenIdsLength == toAmounts.length, \"Output: ids and amounts length mismatch\");\r\n        \r\n        uint16 nftType = uint16(toTokenIds[0] & 0xffff);\r\n\r\n        uint256 totalAmount;\r\n        for (uint256 i = 0; i < toTokenIdsLength; i++) {\r\n            uint256 toTokenId = toTokenIds[i];\r\n            require(nftType == uint16(toTokenId & 0xffff), \"Not same type outputs\");\r\n            uint256 toAmount = toAmounts[i];\r\n            require(toAmount > 0, \"No zero outputs\");\r\n            totalAmount += toAmount;\r\n        }\r\n\r\n        ITransmuteMultipleRecipe transmutator = allowedTransumtateMultipleTo[nftType];\r\n        if (address(transmutator) == address(0)) revert NotSetup();\r\n\r\n        handleMintFee(transmuteFee(nftType), totalAmount);\r\n\r\n        _transmuteMultiple(transmutator, toTokenIds, toAmounts, fromIds, fromAmounts);\r\n    }\r\n\r\n    function _transmuteMultiple(ITransmuteMultipleRecipe transmutator, uint256[] calldata toTokenIds, uint256[] calldata toAmounts, uint256[] calldata fromIds, uint256[] calldata fromAmounts) private {\r\n        address from = _msgSender();\r\n        transmutator.transmuteMultipleTo(from, toTokenIds, toAmounts, fromIds, fromAmounts);\r\n\r\n        // Burn passed in tokens\r\n        uint256 idsLength = fromIds.length;\r\n        for (uint256 i = 0; i < idsLength; i++) {\r\n            uint256 fromId = fromIds[i];\r\n            uint256 fromAmount = fromAmounts[i];\r\n\r\n            SubtractBalance(from, fromId, fromAmount);\r\n        }\r\n\r\n        emit TransferBatch(from, from, address(0), fromIds, fromAmounts);\r\n\r\n        // Mint new tokens\r\n        idsLength = toTokenIds.length;\r\n        for (uint256 i = 0; i < idsLength; i++) {\r\n            uint256 toTokenId = toTokenIds[i];\r\n            uint256 toAmount = toAmounts[i];\r\n\r\n            AddBalance(from, toTokenId, toAmount);\r\n        }\r\n\r\n        emit TransferBatch(from, address(0), from, toTokenIds, toAmounts);\r\n    }\r\n\r\n    function transmuteSingle(uint256 toTokenId, uint256 toAmount, uint256[] calldata fromIds, uint256[] calldata fromAmounts) external payable walletLock(_msgSender()) {\r\n        uint256 fromIdsLength = fromIds.length;\r\n        require(fromIdsLength == fromAmounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(toAmount > 0, \"No zero output\");\r\n        \r\n        uint16 nftType = uint16(toTokenId & 0xffff);\r\n        ITransmuteSingleRecipe transmutator = allowedTransumtateSingleTo[nftType];\r\n        if (address(transmutator) == address(0)) revert NotSetup();\r\n\r\n        handleMintFee(transmuteFee(nftType), toAmount);\r\n\r\n        address from = _msgSender();\r\n        transmutator.transmuteSingleTo(from, toTokenId, toAmount, fromIds, fromAmounts);\r\n\r\n        // Burn passed in tokens\r\n        for (uint256 i = 0; i < fromIdsLength; i++) {\r\n            uint256 tokenId = fromIds[i];\r\n            uint256 amount = fromAmounts[i];\r\n\r\n            SubtractBalance(from, tokenId, amount);\r\n        }\r\n\r\n        emit TransferBatch(from, from, address(0), fromIds, fromAmounts);\r\n\r\n        // Mint new tokens\r\n        AddBalance(from, toTokenId, toAmount);\r\n        emit TransferSingle(from, address(0), from, toTokenId, toAmount);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override (ERC165, IERC165) returns (bool) {\r\n        return \r\n            interfaceId == type(IERC2981).interfaceId ||\r\n            interfaceId == type(IERC1155).interfaceId ||\r\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\r\n            super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids) external view returns (uint256[] memory)\r\n    {\r\n        uint256 accountsLength = accounts.length;\r\n        require(accountsLength == ids.length, \"ERC1155: accounts and ids length mismatch\");\r\n\r\n        uint256[] memory batchBalances = new uint256[](accountsLength);\r\n\r\n        for (uint256 i = 0; i < accountsLength; ++i) {\r\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\r\n        }\r\n\r\n        return batchBalances;\r\n    }\r\n\r\n    // Approval\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual override {\r\n        _setApprovalForAll(_msgSender(), operator, approved);\r\n    }\r\n\r\n    function _setApprovalForAll(\r\n        address owner,\r\n        address operator,\r\n        bool approved\r\n    ) private {\r\n        require(owner != operator, \"ERC1155: setting approval status for self\");\r\n        _operatorApprovals[owner][operator] = approved;\r\n        emit ApprovalForAll(owner, operator, approved);\r\n    }\r\n\r\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\r\n        return _operatorApprovals[account][operator];\r\n    }\r\n\r\n    // Transfer\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external walletLock(from) {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: caller is not owner nor approved\"\r\n        );\r\n        _safeTransferFrom(from, to, id, amount, data);\r\n    }\r\n\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external walletLock(from) {\r\n        require(\r\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\r\n            \"ERC1155: transfer caller is not owner nor approved\"\r\n        );\r\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\r\n    }\r\n\r\n    function _safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) private {\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        SubtractBalance(from, id, amount);\r\n        AddBalance(to, id, amount);\r\n\r\n        emit TransferSingle(operator, from, to, id, amount);\r\n\r\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\r\n    }\r\n\r\n    function _safeBatchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) private {\r\n        uint256 idsLength = ids.length;\r\n        require(idsLength == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\r\n\r\n        address operator = _msgSender();\r\n\r\n        for (uint256 i = 0; i < idsLength; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            SubtractBalance(from, id, amount);\r\n            AddBalance(to, id, amount);\r\n        }\r\n\r\n        emit TransferBatch(operator, from, to, ids, amounts);\r\n\r\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\r\n    }\r\n\r\n    // Hook checks\r\n\r\n    function _doSafeBatchTransferAcceptanceCheck(address operator, address from, address to, uint256[] calldata ids, uint256[] calldata amounts, bytes calldata data) private view {\r\n        if (isContract(to)) {\r\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _doSafeTransferAcceptanceCheck(address operator, address from, address to, uint256 id, uint256 amount, bytes calldata data) private view {\r\n        if (isContract(to)) {\r\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\r\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\r\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\r\n                }\r\n            } catch Error(string memory reason) {\r\n                revert(reason);\r\n            } catch {\r\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\r\n            }\r\n        }\r\n    }\r\n\r\n    // Bridge functions\r\n\r\n    function bridgeNftOut(address from, uint256 id, uint256 amount) external {\r\n        address operator = _msgSender();\r\n        require(operator == nftBridge, \"Only bridge\");\r\n        _walletLock(from);\r\n\r\n        if (isApprovedForAll(from, operator)) {\r\n            revert CallerNotApproved();\r\n        }\r\n\r\n        SubtractBalance(from, id, amount);\r\n\r\n        emit TransferSingle(operator, from, address(0), id, amount);\r\n        emit NftBridgedOut(address(this), nftBridge, from, id, amount);\r\n    }\r\n\r\n    function bridgeNftsOut(address from, uint256[] calldata ids, uint256[] calldata amounts) external {\r\n        address operator = _msgSender();\r\n        require(operator == nftBridge, \"Only bridge\");\r\n        _walletLock(from);\r\n\r\n        if (isApprovedForAll(from, operator)) {\r\n            revert CallerNotApproved();\r\n        }\r\n        uint256 idsLength = ids.length;\r\n        require(idsLength == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        for (uint256 i = 0; i < idsLength; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n\r\n            SubtractBalance(from, id, amount);\r\n        }\r\n\r\n        emit TransferBatch(operator, from, address(0), ids, amounts);\r\n        emit NftsBridgedOut(address(this), nftBridge, from, ids, amounts);\r\n    }\r\n\r\n    function bridgeNftIn(address to, uint256 id, uint256 amount) external {\r\n        address operator = _msgSender();\r\n        require(operator == nftBridge, \"Only bridge\");\r\n\r\n        AddBalance(to, id, amount);\r\n\r\n        emit TransferSingle(operator, address(0), to, id, amount);\r\n        emit NftBridgedIn(address(this), nftBridge, to, id, amount);\r\n    }\r\n\r\n    function bridgeNftsIn(address to, uint256[] calldata ids, uint256[] calldata amounts) external {\r\n        address operator = _msgSender();\r\n        require(operator == nftBridge, \"Only bridge\");\r\n        uint256 idsLength = ids.length;\r\n        require(idsLength == amounts.length, \"ERC1155: ids and amounts length mismatch\");\r\n\r\n        for (uint256 i = 0; i < idsLength; ++i) {\r\n            uint256 id = ids[i];\r\n            uint256 amount = amounts[i];\r\n            \r\n            AddBalance(to, id, amount);\r\n        }\r\n\r\n        emit TransferBatch(operator, address(0), to, ids, amounts);\r\n        emit NftsBridgedIn(address(this), nftBridge, to, ids, amounts);\r\n    }\r\n\r\n    // Utility functions\r\n\r\n    function isContract(address account) private view returns (bool) {\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    function toString(uint256 value) private pure returns (bytes memory output)\r\n    {\r\n        if (value == 0)\r\n        {\r\n            return \"0\";\r\n        }\r\n        uint256 remaining = value;\r\n        uint256 length;\r\n        while (remaining != 0)\r\n        {\r\n            length++;\r\n            remaining /= 10;\r\n        }\r\n        output = new bytes(length);\r\n        uint256 position = length;\r\n        remaining = value;\r\n        while (remaining != 0)\r\n        {\r\n            output[--position] = bytes1(uint8(48 + remaining % 10));\r\n            remaining /= 10;\r\n        }\r\n    }\r\n\r\n    // Remove trapped tokens\r\n\r\n    function transferBalance(uint256 amount) external onlyOwner {\r\n        sendEthViaCall(_msgSender(), amount);\r\n    }\r\n\r\n    function transferExternalTokens(address tokenAddress, address to, uint256 amount) external onlyOwner {\r\n        if (tokenAddress == address(0)) revert NotZeroAddress();\r\n\r\n        transferTokens(tokenAddress, to, amount);\r\n    }\r\n\r\n    function transferTokens(address tokenAddress, address to, uint256 amount) private {\r\n        IERC20(tokenAddress).transfer(to, amount);\r\n\r\n        emit TransferExternalTokens(tokenAddress, to, amount);\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_mementoRise\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerNotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedEthSend\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WalletLocked\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"EverRiseTokenSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"MementoRiseSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeNftId\",\"type\":\"uint256\"}],\"name\":\"claimStakingAchievement\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"everRiseToken\",\"outputs\":[{\"internalType\":\"contract IEverRise\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"animalId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"months\",\"type\":\"uint256\"}],\"name\":\"getTokenId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mementoRise\",\"outputs\":[{\"internalType\":\"contract IMementoRise\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nftRise\",\"outputs\":[{\"internalType\":\"contract InftEverRise\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"setEverRiseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"setMementoRise\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakingAchievement", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000001C57a5eE9C5A90C9a5e31B5265175e0642b943b1", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://c59f58d5a63256e7230820bd78e195d441968fc17564d85cca0bb5a88d485565"}