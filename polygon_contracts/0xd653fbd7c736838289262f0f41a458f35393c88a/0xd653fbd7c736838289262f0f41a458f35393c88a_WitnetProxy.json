{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n\r\npragma solidity >=0.6.0 <0.9.0;\r\n\r\npragma experimental ABIEncoderV2;\r\n\r\n// File: contracts\\patterns\\Initializable.sol\r\ninterface Initializable {\r\n    /// @dev Initialize contract's storage context.\r\n    function initialize(bytes calldata) external;\r\n}\r\n// File: contracts\\patterns\\Proxiable.sol\r\ninterface Proxiable {\r\n    /// @dev Complying with EIP-1822: Universal Upgradable Proxy Standard (UUPS)\r\n    /// @dev See https://eips.ethereum.org/EIPS/eip-1822.\r\n    function proxiableUUID() external pure returns (bytes32);\r\n}\r\n// File: contracts\\patterns\\Upgradable.sol\r\n/* solhint-disable var-name-mixedcase */\r\n\r\n\r\n\r\n\r\nabstract contract Upgradable is Initializable, Proxiable {\r\n\r\n    address internal immutable _BASE;\r\n    bytes32 internal immutable _CODEHASH;\r\n    bool internal immutable _UPGRADABLE;\r\n\r\n    /// Emitted every time the contract gets upgraded.\r\n    /// @param from The address who ordered the upgrading. Namely, the WRB operator in \"trustable\" implementations.\r\n    /// @param baseAddr The address of the new implementation contract.\r\n    /// @param baseCodehash The EVM-codehash of the new implementation contract.\r\n    /// @param versionTag Ascii-encoded version literal with which the implementation deployer decided to tag it.\r\n    event Upgraded(\r\n        address indexed from,\r\n        address indexed baseAddr,\r\n        bytes32 indexed baseCodehash,\r\n        bytes32 versionTag\r\n    );\r\n\r\n    constructor (bool _isUpgradable) {\r\n        address _base = address(this);\r\n        bytes32 _codehash;        \r\n        assembly {\r\n            _codehash := extcodehash(_base)\r\n        }\r\n        _BASE = _base;\r\n        _CODEHASH = _codehash;        \r\n        _UPGRADABLE = _isUpgradable;\r\n    }\r\n\r\n    /// @dev Tells whether provided address could eventually upgrade the contract.\r\n    function isUpgradableFrom(address from) virtual external view returns (bool);\r\n\r\n\r\n    /// TODO: the following methods should be all declared as pure \r\n    ///       whenever this Solidity's PR gets merged and released: \r\n    ///       https://github.com/ethereum/solidity/pull/10240\r\n\r\n    /// @dev Retrieves base contract. Differs from address(this) when via delegate-proxy pattern.\r\n    function base() public view returns (address) {\r\n        return _BASE;\r\n    }\r\n\r\n    /// @dev Retrieves the immutable codehash of this contract, even if invoked as delegatecall.\r\n    /// @return _codehash This contracts immutable codehash.\r\n    function codehash() public view returns (bytes32 _codehash) {\r\n        return _CODEHASH;\r\n    }\r\n    \r\n    /// @dev Determines whether current instance allows being upgraded.\r\n    /// @dev Returned value should be invariant from whoever is calling.\r\n    function isUpgradable() public view returns (bool) {        \r\n        return _UPGRADABLE;\r\n    }\r\n\r\n    /// @dev Retrieves human-redable named version of current implementation.\r\n    function version() virtual public view returns (bytes32); \r\n}\r\n// File: contracts\\impls\\WitnetProxy.sol\r\n/// @title WitnetProxy: upgradable delegate-proxy contract that routes Witnet data requests coming from a \r\n/// `UsingWitnet`-inheriting contract to a currently active `WitnetRequestBoard` implementation. \r\n/// @author The Witnet Foundation.\r\ncontract WitnetProxy {\r\n\r\n    struct WitnetProxySlot {\r\n        address implementation;\r\n    }\r\n\r\n    /// Event emitted every time the implementation gets updated.\r\n    event Upgraded(address indexed implementation);  \r\n\r\n    /// Constructor with no params as to ease eventual support of Singleton pattern (i.e. ERC-2470).\r\n    constructor () {}\r\n\r\n    /// WitnetProxies will never accept direct transfer of ETHs.\r\n    receive() external payable {\r\n        revert(\"WitnetProxy: no transfers accepted\");\r\n    }\r\n\r\n    /// Payable fallback accepts delegating calls to payable functions.  \r\n    fallback() external payable { /* solhint-disable no-complex-fallback */\r\n        address _implementation = implementation();\r\n\r\n        assembly { /* solhint-disable avoid-low-level-calls */\r\n            // Gas optimized delegate call to 'implementation' contract.\r\n            // Note: `msg.data`, `msg.sender` and `msg.value` will be passed over \r\n            //       to actual implementation of `msg.sig` within `implementation` contract.\r\n            let ptr := mload(0x40)\r\n            calldatacopy(ptr, 0, calldatasize())\r\n            let result := delegatecall(gas(), _implementation, ptr, calldatasize(), 0, 0)\r\n            let size := returndatasize()\r\n            returndatacopy(ptr, 0, size)\r\n            switch result\r\n                case 0  { \r\n                    // pass back revert message:\r\n                    revert(ptr, size) \r\n                }\r\n                default {\r\n                  // pass back same data as returned by 'implementation' contract:\r\n                  return(ptr, size) \r\n                }\r\n        }\r\n    }\r\n\r\n    /// Returns proxy's current implementation address.\r\n    function implementation() public view returns (address) {\r\n        return _proxySlot().implementation;\r\n    }\r\n\r\n    /// Upgrades the `implementation` address.\r\n    /// @param _newImplementation New implementation address.\r\n    /// @param _initData Raw data with which new implementation will be initialized.\r\n    /// @return Returns whether new implementation would be further upgradable, or not.\r\n    function upgradeTo(address _newImplementation, bytes memory _initData)\r\n        public returns (bool)\r\n    {\r\n        // New implementation cannot be null:\r\n        require(_newImplementation != address(0), \"WitnetProxy: null implementation\");\r\n\r\n        address _oldImplementation = implementation();\r\n        if (_oldImplementation != address(0)) {\r\n            // New implementation address must differ from current one:\r\n            require(_newImplementation != _oldImplementation, \"WitnetProxy: nothing to upgrade\");\r\n\r\n            // Assert whether current implementation is intrinsically upgradable:\r\n            try Upgradable(_oldImplementation).isUpgradable() returns (bool _isUpgradable) {\r\n                require(_isUpgradable, \"WitnetProxy: not upgradable\");\r\n            } catch {\r\n                revert(\"WitnetProxy: unable to check upgradability\");\r\n            }\r\n\r\n            // Assert whether current implementation allows `msg.sender` to upgrade the proxy:\r\n            (bool _wasCalled, bytes memory _result) = _oldImplementation.delegatecall(\r\n                abi.encodeWithSignature(\r\n                    \"isUpgradableFrom(address)\",\r\n                    msg.sender\r\n                )\r\n            );\r\n            require(_wasCalled, \"WitnetProxy: not compliant\");\r\n            require(abi.decode(_result, (bool)), \"WitnetProxy: not authorized\");\r\n            require(\r\n                Upgradable(_oldImplementation).proxiableUUID() == Upgradable(_newImplementation).proxiableUUID(),\r\n                \"WitnetProxy: proxiableUUIDs mismatch\"\r\n            );\r\n        }\r\n\r\n        // Initialize new implementation within proxy-context storage:\r\n        (bool _wasInitialized,) = _newImplementation.delegatecall(\r\n            abi.encodeWithSignature(\r\n                \"initialize(bytes)\",\r\n                _initData\r\n            )\r\n        );\r\n        require(_wasInitialized, \"WitnetProxy: unable to initialize\");\r\n\r\n        // If all checks and initialization pass, update implementation address:\r\n        _proxySlot().implementation = _newImplementation;\r\n        emit Upgraded(_newImplementation);\r\n\r\n        // Asserts new implementation complies w/ minimal implementation of Upgradable interface:\r\n        try Upgradable(_newImplementation).isUpgradable() returns (bool _isUpgradable) {\r\n            return _isUpgradable;\r\n        }\r\n        catch {\r\n            revert (\"WitnetProxy: not compliant\");\r\n        }\r\n    }\r\n\r\n    /// @dev Complying with EIP-1967, retrieves storage struct containing proxy's current implementation address.\r\n    function _proxySlot() private pure returns (WitnetProxySlot storage _slot) {\r\n        assembly {\r\n            // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\r\n            _slot.slot := 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\r\n        }\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_initData\",\"type\":\"bytes\"}],\"name\":\"upgradeTo\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "WitnetProxy", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0xf395ceeb77ce9cdc44fd276be5ff307b1902d3f7", "SwarmSource": "ipfs://6aa37542ed392f6a2b75418274c31e6b24a2e07a0776d472663c2af2c62c146b"}