{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/SafeModule.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Ownable.sol\\\";\\nimport \\\"./GnosisSafe.sol\\\";\\nimport \\\"./Enums.sol\\\";\\nimport \\\"./Permissions.sol\\\";\\n\\ncontract SafeModule is Ownable {\\n  string public constant version = \\\"0.2.0\\\";\\n  uint256 internal constant _MAX_ROLE_PER_MEMBER = 16;\\n\\n  event ModuleSetup(address owner, address safeProxy);\\n  event AssignRoles(address member, bytes32[_MAX_ROLE_PER_MEMBER] roleNames);\\n  event DeprecateRole(bytes32 roleName);\\n\\n  event ExecTransaction(\\n    address to,\\n    uint256 value,\\n    bytes data,\\n    Operation operation,\\n    address sender\\n  );\\n\\n  mapping(bytes32 => Role) internal roles;\\n  mapping(address => bytes32[_MAX_ROLE_PER_MEMBER]) internal members;\\n  mapping(bytes32 => bool) internal deprecatedRoles;\\n\\n  address public _safeProxy;\\n\\n  constructor(address owner, address payable safeProxy) {\\n    bytes memory initParams = abi.encode(owner, safeProxy);\\n    setUp(initParams);\\n  }\\n\\n  function setUp(bytes memory initParams) public {\\n    (address owner, address safeProxy) = abi.decode(\\n      initParams,\\n      (address, address)\\n    );\\n\\n    require(safeProxy != address(0), \\\"Invalid safe proxy\\\");\\n    require(owner != address(0), \\\"Invalid owner\\\");\\n\\n    _setupOwner(owner);\\n    _safeProxy = safeProxy;\\n\\n    emit ModuleSetup(owner, safeProxy);\\n  }\\n\\n  modifier isValidRoleName(bytes32 roleName) {\\n    require(roleName != 0, \\\"SafeModule: empty role name\\\");\\n    require(!deprecatedRoles[roleName], \\\"SafeModule: role deprecated\\\");\\n\\n    _;\\n  }\\n\\n  /// @dev Assign roles to a member\\n  /// @param member address\\n  /// @param roleNames Id of a roles\\n  /// @notice Can only be called by owner\\n  function assignRoles(address member, bytes32[] memory roleNames)\\n    external\\n    onlyOwner\\n  {\\n    for (uint256 i = 0; i < _MAX_ROLE_PER_MEMBER; ++i) {\\n      bytes32 roleName = i < roleNames.length ? roleNames[i] : bytes32(0);\\n      require(!deprecatedRoles[roleName], \\\"SafeModule: role deprecated\\\");\\n\\n      members[member][i] = roleName;\\n    }\\n\\n    emit AssignRoles(member, members[member]);\\n  }\\n\\n  /// @dev Deprecate a roleName and this roleName can't used anymore\\n  /// @param roleName Id of a role\\n  /// @notice Can only be called by owner\\n  function deprecateRole(bytes32 roleName)\\n    external\\n    onlyOwner\\n    isValidRoleName(roleName)\\n  {\\n    deprecatedRoles[roleName] = true;\\n    emit DeprecateRole(roleName);\\n  }\\n\\n  /// @dev Get roles of an address for now\\n  /// @param member Member address\\n  function rolesOf(address member)\\n    public\\n    view\\n    returns (bytes32[] memory validRoles)\\n  {\\n    validRoles = new bytes32[](_MAX_ROLE_PER_MEMBER);\\n\\n    for (uint256 i = 0; i < _MAX_ROLE_PER_MEMBER; ++i) {\\n      bytes32 roleName = members[member][i];\\n\\n      if (roleName == 0 || deprecatedRoles[roleName]) {\\n        continue;\\n      }\\n\\n      validRoles[i] = roleName;\\n    }\\n  }\\n\\n  function hasRole(address member, bytes32 roleName)\\n    public\\n    view\\n    returns (bool)\\n  {\\n    bytes32[] memory validRoles = rolesOf(member);\\n\\n    for (uint256 i = 0; i < validRoles.length; ++i) {\\n      if (validRoles[i] == roleName) {\\n        return true;\\n      }\\n    }\\n\\n    return false;\\n  }\\n\\n  /// @dev Allow the specific roleName to call the contract\\n  /// @param roleName Id of a role\\n  /// @param theContract Allowed contract\\n  /// @param operation Defines the operation is call or delegateCall\\n  /// @notice Can only be called by owner\\n  function allowContract(\\n    bytes32 roleName,\\n    address theContract,\\n    Operation operation\\n  ) external onlyOwner isValidRoleName(roleName) {\\n    Permissions.allowContract(\\n      roles[roleName],\\n      roleName,\\n      theContract,\\n      operation\\n    );\\n  }\\n\\n  /// @dev Disable the specific roleName to call the contract\\n  /// @param roleName Id of a role\\n  /// @param theContract Allowed contract\\n  /// @notice Can only be called by owner\\n  function revokeContract(bytes32 roleName, address theContract)\\n    external\\n    onlyOwner\\n    isValidRoleName(roleName)\\n  {\\n    Permissions.revokeContract(roles[roleName], roleName, theContract);\\n  }\\n\\n  /// @dev Allow the specific roleName to call the function of contract\\n  /// @param roleName Id of a role\\n  /// @param theContract Allowed contract\\n  /// @notice Can only be called by owner\\n  function scopeContract(bytes32 roleName, address theContract)\\n    external\\n    onlyOwner\\n    isValidRoleName(roleName)\\n  {\\n    Permissions.scopeContract(roles[roleName], roleName, theContract);\\n  }\\n\\n  /// @dev Allow the specific roleName to call the function\\n  /// @param roleName Id of a role\\n  /// @param theContract Allowed contract\\n  /// @param funcSig Function selector\\n  /// @param operation Defines the operation is call or delegateCall\\n  /// @notice Can only be called by owner\\n  /// @notice Please call 'scopeContract' at the begin before config function\\n  function allowFunction(\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 funcSig,\\n    Operation operation\\n  ) external onlyOwner isValidRoleName(roleName) {\\n    Permissions.allowFunction(\\n      roles[roleName],\\n      roleName,\\n      theContract,\\n      funcSig,\\n      operation\\n    );\\n  }\\n\\n  /// @dev Disable the specific roleName to call the function\\n  /// @param roleName Id of a role\\n  /// @param theContract Allowed contract\\n  /// @param funcSig Function selector\\n  /// @notice Can only be called by owner\\n  function revokeFunction(\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 funcSig\\n  ) external onlyOwner isValidRoleName(roleName) {\\n    Permissions.revokeFunction(roles[roleName], roleName, theContract, funcSig);\\n  }\\n\\n  /// @dev Allow the specific roleName to call the function with specific parameters\\n  /// @param roleName Id of a role\\n  /// @param theContract Allowed contract\\n  /// @param funcSig Function selector\\n  /// @param isScopeds List of parameter scoped config, false for un-scoped, true for scoped\\n  /// @param parameterTypes List of parameter types, Static, Dynamic or Dynamic32, use Static type if not scoped\\n  /// @param comparisons List of parameter comparison types, Eq, Gte or Lte, use Eq if not scoped\\n  /// @param targetValues List of expected values, use '0x' if not scoped\\n  /// @param operation Defines the operation is call or delegateCall\\n  /// @notice Can only be called by owner\\n  /// @notice Please call 'scopeContract' at the begin before config function\\n  function scopeFunction(\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 funcSig,\\n    uint256 ethValueLimit,\\n    bool[] memory isScopeds,\\n    ParameterType[] memory parameterTypes,\\n    Comparison[] memory comparisons,\\n    bytes[] calldata targetValues,\\n    Operation operation\\n  ) external onlyOwner isValidRoleName(roleName) {\\n    Permissions.scopeFunction(\\n      roles[roleName],\\n      roleName,\\n      theContract,\\n      funcSig,\\n      ethValueLimit,\\n      isScopeds,\\n      parameterTypes,\\n      comparisons,\\n      targetValues,\\n      operation\\n    );\\n  }\\n\\n  /// @dev Check then exec transaction\\n  /// @param roleName role to execute this call\\n  /// @param to To address of the transaction\\n  /// @param value Ether value of the transaction\\n  /// @param data Data payload of the transaction\\n  /// @param operation Operation to execute the transaction, only call or delegateCall\\n  function execTransactionFromModule(\\n    bytes32 roleName,\\n    address to,\\n    uint256 value,\\n    bytes calldata data,\\n    Operation operation\\n  ) public {\\n    _execTransaction(roleName, to, value, data, operation);\\n  }\\n\\n  struct Exec {\\n    bytes32 roleName;\\n    address to;\\n    uint256 value;\\n    bytes data;\\n    Operation operation;\\n  }\\n\\n  function execTransactionsFromModule(Exec[] calldata execs) public {\\n    require(execs.length > 0, \\\"SafeModule: Nothing to call\\\");\\n\\n    for (uint256 i = 0; i < execs.length; ++i) {\\n      Exec memory exec = execs[i];\\n\\n      _execTransaction(\\n        exec.roleName,\\n        exec.to,\\n        exec.value,\\n        exec.data,\\n        exec.operation\\n      );\\n    }\\n  }\\n\\n  function _execTransaction(\\n    bytes32 roleName,\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    Operation operation\\n  ) internal isValidRoleName(roleName) {\\n    require(\\n      operation == Operation.Call || operation == Operation.DelegateCall,\\n      \\\"SafeModule: only support call or delegatecall\\\"\\n    );\\n    _verifyPermission(roleName, to, value, data, operation);\\n\\n    require(\\n      GnosisSafe(payable(_safeProxy)).execTransactionFromModule(\\n        to,\\n        value,\\n        data,\\n        operation == Operation.DelegateCall\\n          ? GnosisSafeEnum.Operation.DelegateCall\\n          : GnosisSafeEnum.Operation.Call\\n      ),\\n      \\\"SafeModule: execute fail on gnosis safe\\\"\\n    );\\n\\n    emit ExecTransaction(to, value, data, operation, _msgSender());\\n  }\\n\\n  function _verifyPermission(\\n    bytes32 roleName,\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    Operation operation\\n  ) internal view {\\n    require(\\n      hasRole(_msgSender(), roleName),\\n      \\\"SafeModule: sender doesn't have this role\\\"\\n    );\\n\\n    Permissions.verify(roles[roleName], to, value, data, operation);\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Context.sol\\\";\\n\\nabstract contract Ownable is Context {\\n  bool private _setup;\\n  address private _owner;\\n\\n  event OwnershipTransferred(\\n    address indexed previousOwner,\\n    address indexed newOwner\\n  );\\n\\n  function _setupOwner(address theOwner) internal virtual {\\n    require(!_setup, \\\"Ownable: setup already\\\");\\n\\n    _setup = true;\\n    _owner = theOwner;\\n    emit OwnershipTransferred(address(0), theOwner);\\n  }\\n\\n  /**\\n   * @dev Returns the address of the current owner.\\n   */\\n  function owner() public view returns (address) {\\n    return _owner;\\n  }\\n\\n  /**\\n   * @dev Throws if called by any account other than the owner.\\n   */\\n  modifier onlyOwner() {\\n    require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    _;\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/Permissions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\nimport \\\"./Enums.sol\\\";\\n\\nstruct ContractScopedConfig {\\n  Scope scope;\\n  Operation operation;\\n}\\n\\nstruct Role {\\n  mapping(address => ContractScopedConfig) contracts;\\n  mapping(bytes32 => uint256) functions;\\n  mapping(bytes32 => bytes32) targetValues;\\n}\\n\\nlibrary Permissions {\\n  uint256 internal constant _SCOPE_MAX_PARAMS = 48;\\n  uint256 internal constant _ETH_VALUE_SLOT =\\n    0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\\n\\n  event AllowContract(\\n    bytes32 roleName,\\n    address theContract,\\n    Operation operation\\n  );\\n\\n  event RevokeContract(bytes32 roleName, address theContract);\\n\\n  event ScopeContract(bytes32 roleName, address theContract);\\n\\n  event AllowFunction(\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 functionSig,\\n    Operation operation,\\n    uint256 funcScopedConfig\\n  );\\n\\n  event RevokeFunction(\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 functionSig,\\n    uint256 funcScopedConfig\\n  );\\n\\n  event ScopeFunction(\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 functionSig,\\n    uint256 ethValueLimit,\\n    bool[] isScopeds,\\n    ParameterType[] parameterTypes,\\n    Comparison[] comparisons,\\n    bytes[] targetValues,\\n    Operation operation,\\n    uint256 funcScopedConfig\\n  );\\n\\n  function verify(\\n    Role storage role,\\n    address to,\\n    uint256 value,\\n    bytes calldata data,\\n    Operation operation\\n  ) public view {\\n    _verifyTransaction(role, to, value, data, operation);\\n  }\\n\\n  function _verifyTransaction(\\n    Role storage role,\\n    address theContract,\\n    uint256 value,\\n    bytes memory data,\\n    Operation operation\\n  ) internal view {\\n    require(data.length >= 4, \\\"Permissions: function signature too short\\\");\\n\\n    ContractScopedConfig storage scopedConfig = role.contracts[theContract];\\n    require(\\n      scopedConfig.scope != Scope.None,\\n      \\\"Permissions: contract not allowed\\\"\\n    );\\n\\n    if (scopedConfig.scope == Scope.Contract) {\\n      _verifyOperation(operation, scopedConfig.operation);\\n      return;\\n    } else if (scopedConfig.scope == Scope.Function) {\\n      uint256 funcScopedConfig = role.functions[\\n        _key4Func(theContract, bytes4(data))\\n      ];\\n\\n      require(funcScopedConfig != 0, \\\"Permissions: function not allowed\\\");\\n      (Operation configOperation, bool isBypass, ) = _unpackLeft(\\n        funcScopedConfig\\n      );\\n\\n      _verifyOperation(operation, configOperation);\\n\\n      if (!isBypass) {\\n        _verifyEthValue(role, theContract, value, data);\\n        _verifyParameters(role, funcScopedConfig, theContract, data);\\n      }\\n\\n      return;\\n    }\\n\\n    require(false, \\\"Permissions: should not be here\\\");\\n  }\\n\\n  function _verifyEthValue(\\n    Role storage role,\\n    address theContract,\\n    uint256 value,\\n    bytes memory data\\n  ) internal view {\\n    bytes4 funcSig = bytes4(data);\\n    bytes32 key = _key4FuncArg(theContract, funcSig, _ETH_VALUE_SLOT);\\n    require(\\n      bytes32(value) <= role.targetValues[key],\\n      \\\"Permissions: eth value isn't less than or equal to limit\\\"\\n    );\\n  }\\n\\n  function _verifyParameters(\\n    Role storage role,\\n    uint256 funcScopedConfig,\\n    address theContract,\\n    bytes memory data\\n  ) internal view {\\n    bytes4 funcSig = bytes4(data);\\n    (, , uint256 argsCount) = _unpackLeft(funcScopedConfig);\\n\\n    for (uint256 i = 0; i < argsCount; ++i) {\\n      (\\n        bool isScoped,\\n        ParameterType parameterType,\\n        Comparison comparison\\n      ) = _unpackRight(funcScopedConfig, i);\\n\\n      if (!isScoped) {\\n        continue;\\n      }\\n\\n      bytes32 inputValue;\\n      if (parameterType != ParameterType.Static) {\\n        inputValue = _pluckDynamicValue(data, parameterType, i);\\n      } else {\\n        inputValue = _pluckStaticValue(data, i);\\n      }\\n\\n      bytes32 key = _key4FuncArg(theContract, funcSig, i);\\n      _verifyComparison(comparison, inputValue, role.targetValues[key]);\\n    }\\n  }\\n\\n  function _verifyComparison(\\n    Comparison comparison,\\n    bytes32 inputValue,\\n    bytes32 targetValue\\n  ) internal pure {\\n    if (comparison == Comparison.Eq) {\\n      require(\\n        inputValue == targetValue,\\n        \\\"Permissions: input value isn't equal to target value\\\"\\n      );\\n      return;\\n    } else if (comparison == Comparison.Gte) {\\n      require(\\n        inputValue >= targetValue,\\n        \\\"Permissions: input value isn't greater than or equal to target value\\\"\\n      );\\n      return;\\n    } else if (comparison == Comparison.Lte) {\\n      require(\\n        inputValue <= targetValue,\\n        \\\"Permissions: input value isn't less than or equal to target value\\\"\\n      );\\n      return;\\n    }\\n\\n    require(false, \\\"Permissions: invalid comparison\\\");\\n  }\\n\\n  function _verifyOperation(Operation inputOperation, Operation configOperation)\\n    internal\\n    pure\\n  {\\n    require(\\n      configOperation != Operation.None,\\n      \\\"Permissions: opearion not config\\\"\\n    );\\n\\n    if (configOperation == Operation.Call) {\\n      require(\\n        inputOperation == Operation.Call,\\n        \\\"Permissions: require call operation\\\"\\n      );\\n      return;\\n    } else if (configOperation == Operation.DelegateCall) {\\n      require(\\n        inputOperation == Operation.DelegateCall,\\n        \\\"Permissions: require delegatecall operation\\\"\\n      );\\n      return;\\n    } else if (configOperation == Operation.Both) {\\n      require(\\n        inputOperation == Operation.Call ||\\n          inputOperation == Operation.DelegateCall,\\n        \\\"Permissions: require call or delegatecall operation\\\"\\n      );\\n      return;\\n    }\\n\\n    require(false, \\\"Permissions: invalid input operation\\\");\\n  }\\n\\n  function _key4Func(address addr, bytes4 funcSig)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    return bytes32(abi.encodePacked(addr, funcSig));\\n  }\\n\\n  function _key4FuncArg(\\n    address addr,\\n    bytes4 funcSig,\\n    uint256 index\\n  ) public pure returns (bytes32) {\\n    return bytes32(abi.encodePacked(addr, funcSig, uint8(index)));\\n  }\\n\\n  function _pluckStaticValue(bytes memory data, uint256 index)\\n    internal\\n    pure\\n    returns (bytes32)\\n  {\\n    // pre-check: is there a word available for the current parameter at argumentsBlock?\\n    require(\\n      data.length >= 4 + index * 32 + 32,\\n      \\\"Permissions: calldata out of bounds for static type\\\"\\n    );\\n\\n    uint256 offset = 4 + index * 32;\\n    bytes32 value;\\n    assembly {\\n      // add 32 - jump over the length encoding of the data bytes array\\n      value := mload(add(32, add(data, offset)))\\n    }\\n    return value;\\n  }\\n\\n  function _pluckDynamicValue(\\n    bytes memory data,\\n    ParameterType parameterType,\\n    uint256 index\\n  ) internal pure returns (bytes32) {\\n    require(\\n      parameterType != ParameterType.Static,\\n      \\\"Permissions: only non-static type here\\\"\\n    );\\n    // pre-check: is there a word available for the current parameter at argumentsBlock?\\n    require(\\n      data.length >= 4 + index * 32 + 32,\\n      \\\"Permissions: calldata out of bounds for dynamic type at the first\\\"\\n    );\\n\\n    /*\\n     * Encoded calldata:\\n     * 4  bytes -> function selector\\n     * 32 bytes -> sequence, one chunk per parameter\\n     *\\n     * There is one (bytes32) chunk per parameter. Depending on type it contains:\\n     * Static    -> value encoded inline (not plucked by this function)\\n     * Dynamic   -> a byte offset to encoded data payload\\n     * Dynamic32 -> a byte offset to encoded data payload\\n     * Note: Fixed Sized Arrays (e.g., bool[2]), are encoded inline\\n     * Note: Nested types also do not follow the above described rules, and are unsupported\\n     * Note: The offset to payload does not include 4 bytes for functionSig\\n     *\\n     *\\n     * At encoded payload, the first 32 bytes are the length encoding of the parameter payload. Depending on ParameterType:\\n     * Dynamic   -> length in bytes\\n     * Dynamic32 -> length in bytes32\\n     * Note: Dynamic types are: bytes, string\\n     * Note: Dynamic32 types are non-nested arrays: address[] bytes32[] uint[] etc\\n     */\\n\\n    // the start of the parameter block\\n    // 32 bytes - length encoding of the data bytes array\\n    // 4  bytes - function sig\\n    uint256 argumentsBlock;\\n    assembly {\\n      argumentsBlock := add(data, 36)\\n    }\\n\\n    // the two offsets are relative to argumentsBlock\\n    uint256 offset = index * 32;\\n    uint256 offsetPayload;\\n    assembly {\\n      offsetPayload := mload(add(argumentsBlock, offset))\\n    }\\n\\n    uint256 lengthPayload;\\n    assembly {\\n      lengthPayload := mload(add(argumentsBlock, offsetPayload))\\n    }\\n\\n    // account for:\\n    // 4  bytes - functionSig\\n    // 32 bytes - length encoding for the parameter payload\\n    uint256 start = 4 + offsetPayload + 32;\\n    uint256 end = start +\\n      (\\n        parameterType == ParameterType.Dynamic32\\n          ? lengthPayload * 32\\n          : lengthPayload\\n      );\\n\\n    // are we slicing out of bounds?\\n    require(\\n      data.length >= end,\\n      \\\"Permissions: calldata out of bounds for dynamic type at the end\\\"\\n    );\\n\\n    return keccak256(_slice(data, start, end));\\n  }\\n\\n  function _slice(\\n    bytes memory data,\\n    uint256 start,\\n    uint256 end\\n  ) internal pure returns (bytes memory result) {\\n    result = new bytes(end - start);\\n    for (uint256 j = start; j < end; j++) {\\n      result[j - start] = data[j];\\n    }\\n  }\\n\\n  function allowContract(\\n    Role storage role,\\n    bytes32 roleName,\\n    address theContract,\\n    Operation operation\\n  ) external {\\n    role.contracts[theContract] = ContractScopedConfig(\\n      Scope.Contract,\\n      operation\\n    );\\n\\n    emit AllowContract(roleName, theContract, operation);\\n  }\\n\\n  function revokeContract(\\n    Role storage role,\\n    bytes32 roleName,\\n    address theContract\\n  ) external {\\n    role.contracts[theContract] = ContractScopedConfig(\\n      Scope.None,\\n      Operation.None\\n    );\\n\\n    emit RevokeContract(roleName, theContract);\\n  }\\n\\n  function scopeContract(\\n    Role storage role,\\n    bytes32 roleName,\\n    address theContract\\n  ) external {\\n    role.contracts[theContract] = ContractScopedConfig(\\n      Scope.Function,\\n      Operation.None\\n    );\\n\\n    emit ScopeContract(roleName, theContract);\\n  }\\n\\n  function allowFunction(\\n    Role storage role,\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 funcSig,\\n    Operation operation\\n  ) external {\\n    uint256 funcScopedConfig = _packLeft(0, operation, true, 0);\\n    role.functions[_key4Func(theContract, funcSig)] = funcScopedConfig;\\n\\n    emit AllowFunction(\\n      roleName,\\n      theContract,\\n      funcSig,\\n      operation,\\n      funcScopedConfig\\n    );\\n  }\\n\\n  function revokeFunction(\\n    Role storage role,\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 funcSig\\n  ) external {\\n    role.functions[_key4Func(theContract, funcSig)] = 0;\\n    emit RevokeFunction(roleName, theContract, funcSig, 0);\\n  }\\n\\n  function scopeFunction(\\n    Role storage role,\\n    bytes32 roleName,\\n    address theContract,\\n    bytes4 funcSig,\\n    uint256 ethValueLimit,\\n    bool[] memory isScopeds,\\n    ParameterType[] memory parameterTypes,\\n    Comparison[] memory comparisons,\\n    bytes[] calldata targetValues,\\n    Operation operation\\n  ) external {\\n    uint256 argsCount = isScopeds.length;\\n\\n    require(\\n      argsCount <= _SCOPE_MAX_PARAMS,\\n      \\\"Permissions: parameters count exceeded\\\"\\n    );\\n    require(\\n      argsCount == parameterTypes.length &&\\n        argsCount == comparisons.length &&\\n        argsCount == targetValues.length,\\n      \\\"Permissions: length of arrays should be the same\\\"\\n    );\\n\\n    for (uint256 i = 0; i < argsCount; ++i) {\\n      if (!isScopeds[i]) {\\n        continue;\\n      }\\n\\n      _enforceConfigComparison(parameterTypes[i], comparisons[i]);\\n      _enforceTargetValue(parameterTypes[i], targetValues[i]);\\n    }\\n\\n    uint256 funcScopedConfig = _packLeft(0, operation, false, argsCount);\\n\\n    for (uint256 i = 0; i < argsCount; ++i) {\\n      funcScopedConfig = _packRight(\\n        funcScopedConfig,\\n        i,\\n        isScopeds[i],\\n        parameterTypes[i],\\n        comparisons[i]\\n      );\\n    }\\n\\n    role.functions[_key4Func(theContract, funcSig)] = funcScopedConfig;\\n\\n    for (uint256 i = 0; i < argsCount; ++i) {\\n      role.targetValues[\\n        _key4FuncArg(theContract, funcSig, i)\\n      ] = _compressTargetValue(parameterTypes[i], targetValues[i]);\\n    }\\n\\n    role.targetValues[\\n      _key4FuncArg(theContract, funcSig, _ETH_VALUE_SLOT)\\n    ] = _compressTargetValue(\\n      ParameterType.Static,\\n      abi.encodePacked(ethValueLimit)\\n    );\\n\\n    emit ScopeFunction(\\n      roleName,\\n      theContract,\\n      funcSig,\\n      ethValueLimit,\\n      isScopeds,\\n      parameterTypes,\\n      comparisons,\\n      targetValues,\\n      operation,\\n      funcScopedConfig\\n    );\\n  }\\n\\n  function _compressTargetValue(\\n    ParameterType parameterType,\\n    bytes memory targetValue\\n  ) internal pure returns (bytes32) {\\n    return\\n      parameterType == ParameterType.Static\\n        ? bytes32(targetValue)\\n        : keccak256(targetValue);\\n  }\\n\\n  function _enforceConfigComparison(\\n    ParameterType parameterType,\\n    Comparison comparison\\n  ) internal pure {\\n    require(uint256(parameterType) <= 2, \\\"Permissions: invalid parameter type\\\");\\n    require(uint256(comparison) <= 2, \\\"Permissions: invalid comparison type\\\");\\n\\n    if (parameterType != ParameterType.Static && comparison != Comparison.Eq) {\\n      require(\\n        false,\\n        \\\"Permissions: only supports eq comparison for non-static type\\\"\\n      );\\n    }\\n  }\\n\\n  function _enforceTargetValue(\\n    ParameterType parameterType,\\n    bytes calldata targetValue\\n  ) internal pure {\\n    if (parameterType == ParameterType.Static && targetValue.length != 32) {\\n      require(false, \\\"Permissions: length of static type value should be 32\\\");\\n    }\\n\\n    if (\\n      parameterType == ParameterType.Dynamic32 && targetValue.length % 32 != 0\\n    ) {\\n      require(\\n        false,\\n        \\\"Permissions: length of dynamic32 type value should be a multiples of 32\\\"\\n      );\\n    }\\n  }\\n\\n  // LEFT SIDE\\n  // 2   bits -> operation\\n  // 1   bits -> isBypass\\n  // 5   bits -> unused\\n  // 8   bits -> length\\n  function _packLeft(\\n    uint256 funcScopedConfig,\\n    Operation operation,\\n    bool isBypass,\\n    uint256 length\\n  ) internal pure returns (uint256) {\\n    // Wipe the LEFT SIDE clean. Start from there\\n    funcScopedConfig = (funcScopedConfig << 16) >> 16;\\n\\n    // set operation -> 256 - 2 = 254\\n    funcScopedConfig |= uint256(operation) << 254;\\n\\n    // set isBypass -> 256 - 2 - 1 = 253\\n    if (isBypass) {\\n      funcScopedConfig |= 1 << 253;\\n    }\\n\\n    // set Length -> 48 + 96 + 96 = 240\\n    funcScopedConfig |= (length << 248) >> 8;\\n\\n    return funcScopedConfig;\\n  }\\n\\n  function _unpackLeft(uint256 funcScopedConfig)\\n    internal\\n    pure\\n    returns (\\n      Operation operation,\\n      bool isBypass,\\n      uint256 argsCount\\n    )\\n  {\\n    uint256 isBypassMask = 1 << 253;\\n\\n    operation = Operation(funcScopedConfig >> 254);\\n    isBypass = funcScopedConfig & isBypassMask != 0;\\n    argsCount = (funcScopedConfig << 8) >> 248;\\n  }\\n\\n  // RIGHT SIDE\\n  // 48  bits -> isScoped\\n  // 96  bits -> paramType (2 bits per entry 48*2)\\n  // 96  bits -> paramComp (2 bits per entry 48*2)\\n  function _packRight(\\n    uint256 funcScopedConfig,\\n    uint256 index,\\n    bool isScoped,\\n    ParameterType parameterType,\\n    Comparison comparison\\n  ) internal pure returns (uint256) {\\n    uint256 isScopedMask = 1 << (index + 96 + 96);\\n    uint256 twoBitsMask = 3;\\n    uint256 typeMask = 3 << (index * 2 + 96);\\n    uint256 comparisonMask = 3 << (index * 2);\\n\\n    if (isScoped) {\\n      funcScopedConfig |= isScopedMask;\\n    } else {\\n      funcScopedConfig &= ~isScopedMask;\\n    }\\n\\n    funcScopedConfig &= ~typeMask;\\n    funcScopedConfig |=\\n      (uint256(parameterType) & twoBitsMask) <<\\n      (index * 2 + 96);\\n\\n    funcScopedConfig &= ~comparisonMask;\\n    funcScopedConfig |= (uint256(comparison) & twoBitsMask) << (index * 2);\\n\\n    return funcScopedConfig;\\n  }\\n\\n  function _unpackRight(uint256 funcScopedConfig, uint256 index)\\n    internal\\n    pure\\n    returns (\\n      bool isScoped,\\n      ParameterType parameterType,\\n      Comparison comparison\\n    )\\n  {\\n    uint256 isScopedMask = 1 << (index + 96 + 96);\\n    uint256 typeMask = 3 << (index * 2 + 96);\\n    uint256 comparisonMask = 3 << (index * 2);\\n\\n    isScoped = (funcScopedConfig & isScopedMask) != 0;\\n    parameterType = ParameterType(\\n      (funcScopedConfig & typeMask) >> (index * 2 + 96)\\n    );\\n    comparison = Comparison((funcScopedConfig & comparisonMask) >> (index * 2));\\n  }\\n}\\n\"\r\n    },\r\n    \"contracts/GnosisSafe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/// @title Enum - Collection of enums\\n/// @author Richard Meissner - <richard@gnosis.pm>\\ncontract GnosisSafeEnum {\\n  enum Operation {\\n    Call,\\n    DelegateCall\\n  }\\n}\\n\\ninterface GnosisSafe {\\n  /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\\n  /// @param to Destination address of module transaction.\\n  /// @param value Ether value of module transaction.\\n  /// @param data Data payload of module transaction.\\n  /// @param operation Operation type of module transaction.\\n  function execTransactionFromModule(\\n    address to,\\n    uint256 value,\\n    bytes memory data,\\n    GnosisSafeEnum.Operation operation\\n  ) external returns (bool success);\\n}\\n\"\r\n    },\r\n    \"contracts/Enums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nenum ParameterType {\\n  Static,\\n  Dynamic,\\n  Dynamic32\\n}\\n\\nenum Comparison {\\n  Eq,\\n  Gte,\\n  Lte\\n}\\n\\nenum Scope {\\n  None,\\n  Contract,\\n  Function\\n}\\n\\nenum Operation {\\n  None,\\n  Call,\\n  DelegateCall,\\n  Both\\n}\\n\"\r\n    },\r\n    \"contracts/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n  function _msgSender() internal view returns (address) {\\n    return msg.sender;\\n  }\\n\\n  function _msgData() internal pure returns (bytes calldata) {\\n    return msg.data;\\n  }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/Permissions.sol\": {\r\n        \"Permissions\": \"0xe887a115b4764069d053ebc7f5717f73d2d69184\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"safeProxy\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32[16]\",\"name\":\"roleNames\",\"type\":\"bytes32[16]\"}],\"name\":\"AssignRoles\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"}],\"name\":\"DeprecateRole\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"ExecTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"safeProxy\",\"type\":\"address\"}],\"name\":\"ModuleSetup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"_safeProxy\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"theContract\",\"type\":\"address\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"allowContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"theContract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcSig\",\"type\":\"bytes4\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"allowFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"roleNames\",\"type\":\"bytes32[]\"}],\"name\":\"assignRoles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"}],\"name\":\"deprecateRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"execTransactionFromModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"internalType\":\"struct SafeModule.Exec[]\",\"name\":\"execs\",\"type\":\"tuple[]\"}],\"name\":\"execTransactionsFromModule\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"theContract\",\"type\":\"address\"}],\"name\":\"revokeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"theContract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcSig\",\"type\":\"bytes4\"}],\"name\":\"revokeFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"member\",\"type\":\"address\"}],\"name\":\"rolesOf\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"validRoles\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"theContract\",\"type\":\"address\"}],\"name\":\"scopeContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"roleName\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"theContract\",\"type\":\"address\"},{\"internalType\":\"bytes4\",\"name\":\"funcSig\",\"type\":\"bytes4\"},{\"internalType\":\"uint256\",\"name\":\"ethValueLimit\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"isScopeds\",\"type\":\"bool[]\"},{\"internalType\":\"enum ParameterType[]\",\"name\":\"parameterTypes\",\"type\":\"uint8[]\"},{\"internalType\":\"enum Comparison[]\",\"name\":\"comparisons\",\"type\":\"uint8[]\"},{\"internalType\":\"bytes[]\",\"name\":\"targetValues\",\"type\":\"bytes[]\"},{\"internalType\":\"enum Operation\",\"name\":\"operation\",\"type\":\"uint8\"}],\"name\":\"scopeFunction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"initParams\",\"type\":\"bytes\"}],\"name\":\"setUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "SafeModule", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee000000000000000000000000eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}