{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/ROI.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: UNLICENSED\\r\\npragma solidity ^0.8.6;\\r\\n\\r\\ninterface IERC20 {\\r\\n    function transfer(address _to, uint256 _amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address _from,\\r\\n        address _to,\\r\\n        uint256 _amount\\r\\n    ) external returns (bool);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n}\\r\\n\\r\\nlibrary SafeMath {\\r\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        uint256 c = a + b;\\r\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\r\\n        uint256 c = a - b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        if (a == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        uint256 c = a * b;\\r\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n\\r\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\r\\n        uint256 c = a / b;\\r\\n\\r\\n        return c;\\r\\n    }\\r\\n}\\r\\n\\r\\ninterface IIPFSDeployer {\\r\\n    function deploy(\\r\\n        address payable owner,\\r\\n        address payable dev,\\r\\n        address payable marketing,\\r\\n        address payable mainContract\\r\\n    ) external;\\r\\n\\r\\n    function isWhitelisted(address _user) external view returns (bool);\\r\\n}\\r\\n\\r\\ninterface IInsuranceContract {\\r\\n    function initiate() external;\\r\\n\\r\\n    function getBalance() external view returns (uint256);\\r\\n\\r\\n    function getMainContract() external view returns (address);\\r\\n}\\r\\n\\r\\ncontract INSURANCE {\\r\\n    IERC20 public tokenAddress =\\r\\n        IERC20(0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063);\\r\\n\\r\\n    //accept funds from MainContract\\r\\n    receive() external payable {}\\r\\n\\r\\n    address payable public MAINCONTRACT;\\r\\n\\r\\n    constructor() {\\r\\n        MAINCONTRACT = payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    function initiate() public {\\r\\n        require(msg.sender == MAINCONTRACT, \\\"Forbidden\\\");\\r\\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\\r\\n        if (balance == 0) return;\\r\\n        IERC20(tokenAddress).transfer(MAINCONTRACT, balance);\\r\\n    }\\r\\n\\r\\n    function getBalance() public view returns (uint256) {\\r\\n        return address(this).balance;\\r\\n    }\\r\\n\\r\\n    function getMainContract() public view returns (address) {\\r\\n        return MAINCONTRACT;\\r\\n    }\\r\\n}\\r\\n\\r\\nstruct DepositStruct {\\r\\n    uint256 amount;\\r\\n    uint40 time;\\r\\n    uint256 withdrawn;\\r\\n}\\r\\n\\r\\nstruct WithdrawDetails {\\r\\n    uint256 timestamp;\\r\\n    uint256 amount;\\r\\n}\\r\\n\\r\\nstruct LatestDeposits{\\r\\n    uint256 amount;\\r\\n    uint256 time;\\r\\n    address user;\\r\\n}\\r\\n\\r\\nstruct Investor {\\r\\n    uint256 lastInvestedAmount;\\r\\n    address daddy;\\r\\n    uint40 lastPayout;\\r\\n    uint256 totalInvested;\\r\\n    uint256 totalReferralInvested;\\r\\n    uint256 totalWithdrawn;\\r\\n    uint256 totalBonus;\\r\\n    DepositStruct[] deposits;\\r\\n    mapping(uint256 => uint256) referralEarningsL;\\r\\n    uint256[5] structure;\\r\\n    uint256 totalRewards;\\r\\n    uint256 withdrawalTime;\\r\\n    uint256 time;\\r\\n    uint256 unsettled;\\r\\n    bool isExist;\\r\\n    uint256 lastDepositeTime;\\r\\n}\\r\\n\\r\\nstruct UserTeams{\\r\\n    uint256 totalBusiness;\\r\\n    uint256 totalTeam;\\r\\n}\\r\\n\\r\\nstruct userEarning{\\r\\n    uint256 dividendIncome;\\r\\n    uint256 royaltyIncome;\\r\\n    uint256 royaltyIncome1;\\r\\n    uint256 pensionIncome;\\r\\n    uint256 joinedTime;\\r\\n    uint256 pensionIncomeAvailable;\\r\\n}\\r\\n\\r\\ncontract IPFSUNO {\\r\\n    using SafeMath for uint256;\\r\\n    using SafeMath for uint40;\\r\\n\\r\\n    IERC20 public tokenAddress =\\r\\n        IERC20(0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063);\\r\\n    address roiDeployerAddress;\\r\\n    LatestDeposits[] public _latestDeposits;\\r\\n\\r\\n    uint256 public contractInvested;\\r\\n    uint256 public contractWithdrawn;\\r\\n    uint256 public matchBonus;\\r\\n    uint256 public totalUsers;\\r\\n\\r\\n    uint8 constant BonusLinesCount = 5;\\r\\n    uint16 constant percentDivider = 100;\\r\\n    uint16 constant percentDividerROI = 10000;\\r\\n    uint256 public maxWithdrawl = 100 ether;\\r\\n    uint256 MAX_EARNING = 50100 ether;\\r\\n\\r\\n    uint256 referralBonus = 0;\\r\\n\\r\\n    uint256 public MAX_LIMIT = 200;\\r\\n    uint40 public TIME_STEP = 86400;\\r\\n    uint8 public Daily_ROI_Per = 100;\\r\\n\\r\\n    uint256 MinimumDiposit = 5 * 1e18;\\r\\n    uint256 MaximumDiposit = 100 * 1e18;\\r\\n    uint256 CreatorsPercentage = 4;\\r\\n    uint256 referralBonusPer = 40;\\r\\n    uint256 public royaltyFunds = 0;\\r\\n    uint256 public royaltyFundsLevel2 = 0;\\r\\n    uint256 public pensionFunds;\\r\\n\\r\\n    uint256[BonusLinesCount] RefferalPer = [35, 1, 2, 3, 4];\\r\\n\\r\\n    mapping(address => Investor) public investorsMap;\\r\\n    mapping(address=>userEarning) public earningUsers;\\r\\n    mapping(address=>UserTeams) public userTeams;\\r\\n    mapping(address => WithdrawDetails) public withdrawDetails;\\r\\n    mapping(address => bool) public idDeactivated;\\r\\n    address[] public royaltyUsers;\\r\\n\\r\\n    address payable public owner;\\r\\n    address payable public dev;\\r\\n    address payable public marketing;\\r\\n\\r\\n    address payable public INSURANCE_CONTRACT;\\r\\n    mapping(uint256 => uint256) public INSURANCE_MAXBALANCE;\\r\\n    uint256 public constant INSURANCE_PERCENT = 2; \\r\\n    uint256 public constant INSURANCE_LOWBALANCE_PERCENT = 2; // protection kicks in at 2% or lower\\r\\n    uint256 public INSURANCE_TRIGGER_BALANCE;\\r\\n    bool public isInsuranceTriggered;\\r\\n\\r\\n    struct UserStruct {\\r\\n        uint256 activeLevel;\\r\\n        uint256 planbactivatedround;\\r\\n    }\\r\\n    struct userInfo {\\r\\n        uint256 id;\\r\\n        uint256 referrerID;\\r\\n        uint256 childCount;\\r\\n        address userAddress;\\r\\n        uint256 noofpayments;\\r\\n        uint256 activeLevel;\\r\\n    }\\r\\n\\r\\n    struct BonusLevels {\\r\\n        uint40 level;\\r\\n        uint256 index;\\r\\n        bool isAdded;\\r\\n    }\\r\\n    mapping(address => UserStruct) public dividendUsers;\\r\\n    mapping(uint256 => mapping(uint256 => userInfo)) public userInfos;\\r\\n    mapping(address => mapping(uint256 => uint256)) public noofPayments;\\r\\n    mapping(address => BonusLevels) public bonusLevels;\\r\\n    uint256 public currUserID = 0;\\r\\n    mapping(uint256 => mapping(uint256 => address payable))\\r\\n        public userAddressByID;\\r\\n    // mapping(uint256 => mapping(uint256 => uint256)) public walletAmountPlanB;\\r\\n\\r\\n    mapping(uint256 => uint256) public lastIDCount;\\r\\n    mapping(uint256 => uint256) public lastFreeParent;\\r\\n    mapping(uint256 => uint256) public LEVEL_PRICE;\\r\\n\\r\\n    event Upline(address indexed addr, address indexed upline, uint256 bonus);\\r\\n    event NewDeposit(address indexed addr, uint256 amount);\\r\\n    event MatchPayout(\\r\\n        address indexed addr,\\r\\n        address indexed from,\\r\\n        uint256 amount\\r\\n    );\\r\\n    event Withdraw(address indexed addr, uint256 amount);\\r\\n    event FeePayed(address indexed user, uint256 totalAmount);\\r\\n\\r\\n    event regLevelEvent(\\r\\n        address indexed _user,\\r\\n        address indexed _referrer,\\r\\n        uint256 _time\\r\\n    );\\r\\n\\r\\n    event buyLevelEvent(\\r\\n        address indexed _user,\\r\\n        uint256 _level,\\r\\n        uint256 _time,\\r\\n        uint256 _amount,\\r\\n        uint256 _roundid\\r\\n    );\\r\\n    event binaryData(\\r\\n        address indexed _user,\\r\\n        uint256 _userId,\\r\\n        uint256 _referralID,\\r\\n        uint256 _level,\\r\\n        address referralAddress,\\r\\n        uint256 _roundid\\r\\n    );\\r\\n\\r\\n    constructor(address payable CreatorAddr, address payable DevAddr,address payable MarketingAddr) {\\r\\n        INSURANCE_CONTRACT = payable(new INSURANCE());\\r\\n        owner = CreatorAddr;\\r\\n        dev = DevAddr;\\r\\n        marketing = MarketingAddr;\\r\\n        LEVEL_PRICE[1] = 1 ether;\\r\\n        LEVEL_PRICE[2] = 2 ether;\\r\\n        investorsMap[owner].isExist = true;\\r\\n        investorsMap[owner].daddy = owner;\\r\\n    }\\r\\n\\r\\n    function setRoiDeployerAddress(address _restart) external {\\r\\n        require(msg.sender == dev, \\\"invalid to set restart\\\");\\r\\n        roiDeployerAddress = _restart;\\r\\n    }\\r\\n\\r\\n    function _refPayout(address _addr, uint256 _amount) private {\\r\\n        address up = investorsMap[_addr].daddy;\\r\\n        uint256 i = 0;\\r\\n\\r\\n        uint256 bonus = 0;\\r\\n        for (i = 0; i < BonusLinesCount; i++) {\\r\\n            if (up == address(0)) break;\\r\\n\\r\\n            userTeams[up].totalBusiness+=_amount;\\r\\n            \\r\\n            bool flag = false;\\r\\n            uint256 _sendAmount = investorsMap[up].totalInvested > _amount\\r\\n                ? _amount\\r\\n                : investorsMap[up].totalInvested;\\r\\n            bonus = (_sendAmount * RefferalPer[i]) / percentDivider;\\r\\n\\r\\n            if (i == 0) {\\r\\n                flag = true;\\r\\n            } else if (\\r\\n                (i == 1 || i == 2) &&\\r\\n                investorsMap[up].structure[0] >= 5 &&\\r\\n                investorsMap[up].totalReferralInvested >= 500 * 1e18\\r\\n            ) {\\r\\n                flag = true;\\r\\n            } else if (\\r\\n                (i == 3 || i == 4) &&\\r\\n                investorsMap[up].structure[0] >= 10 &&\\r\\n                investorsMap[up].totalReferralInvested >= 1000 * 1e18\\r\\n            ) {\\r\\n                flag = true;\\r\\n            }\\r\\n\\r\\n            if (flag) {\\r\\n                \\r\\n                    investorsMap[up].referralEarningsL[i] = investorsMap[up]\\r\\n                        .referralEarningsL[i]\\r\\n                        .add(bonus);\\r\\n                    investorsMap[up].totalBonus += bonus;\\r\\n                    matchBonus += bonus;\\r\\n                    emit MatchPayout(up, _addr, bonus);\\r\\n                \\r\\n\\r\\n                if (\\r\\n                    investorsMap[up].structure[0]>5 &&\\r\\n                    userTeams[up].totalTeam >= 50 &&\\r\\n                    userTeams[up].totalBusiness >= 5000 ether &&\\r\\n                    bonusLevels[up].level == 0\\r\\n                ) {\\r\\n                    //50\\r\\n                    if (!bonusLevels[up].isAdded) {\\r\\n                        royaltyUsers.push(up);\\r\\n                        bonusLevels[up].isAdded = true;\\r\\n                    }\\r\\n                    bonusLevels[up].level = 1;\\r\\n                }\\r\\n                if (\\r\\n                    investorsMap[up].structure[0]>10 &&\\r\\n                    userTeams[up].totalTeam >= 100 &&\\r\\n                    userTeams[up].totalBusiness >= 10000 ether &&\\r\\n                    bonusLevels[up].level < 2\\r\\n                ) {\\r\\n                    //100\\r\\n                    if (!bonusLevels[up].isAdded) {\\r\\n                        royaltyUsers.push(up);\\r\\n                        bonusLevels[up].isAdded = true;\\r\\n                    }\\r\\n                    bonusLevels[up].level = 2;\\r\\n                }\\r\\n            }\\r\\n\\r\\n            up = investorsMap[up].daddy;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _setUpdaddy(address _addr, address _upline) private {\\r\\n        if (\\r\\n            investorsMap[_addr].daddy == address(0) &&\\r\\n            investorsMap[_upline].isExist &&\\r\\n            _addr != _upline  && _upline!=address(0)\\r\\n        ) {\\r\\n            investorsMap[_addr].daddy = _upline;\\r\\n            emit regLevelEvent(_addr,_upline,block.timestamp);\\r\\n\\r\\n            for (uint256 i = 0; i < BonusLinesCount; i++) {\\r\\n                investorsMap[_upline].structure[i]++;\\r\\n                userTeams[_upline].totalTeam++;\\r\\n                _upline = investorsMap[_upline].daddy;\\r\\n\\r\\n                if (_upline == address(0)) break;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function deposit(uint256 _amount, address _upline) public payable {\\r\\n        uint256 amount = _amount;\\r\\n        require(!idDeactivated[msg.sender], \\\"Id Deactivated\\\");\\r\\n        require(!isInsuranceTriggered, \\\"Insurance payment started\\\");\\r\\n        collect(msg.sender);\\r\\n        Investor storage investor = investorsMap[msg.sender];\\r\\n        if (investorsMap[msg.sender].deposits.length == 0) {\\r\\n            require(\\r\\n                amount >= MinimumDiposit && amount <= MaximumDiposit,\\r\\n                \\\"You can deposite min 5$ or max 100$\\\"\\r\\n            );\\r\\n            earningUsers[msg.sender].joinedTime = block.timestamp;\\r\\n        } else  {\\r\\n            require(amount >= 1 ether, \\\"Deposite must be greater than 1$\\\");\\r\\n            require(investor.totalWithdrawn>=investor.totalInvested.div(2),\\\"Need to wait\\\");\\r\\n        }\\r\\n\\r\\n        require(investor.deposits.length < 100, \\\"Max 100 deposits per address\\\");\\r\\n\\r\\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\\r\\n\\r\\n        if (_upline == address(0) || !investorsMap[_upline].isExist) {\\r\\n            _upline = owner;\\r\\n        }\\r\\n\\r\\n        uint256 cfee = amount.mul(CreatorsPercentage).div(percentDivider).div(\\r\\n            2\\r\\n        );\\r\\n        IERC20(tokenAddress).transfer(marketing, cfee);\\r\\n        IERC20(tokenAddress).transfer(dev, cfee);\\r\\n\\r\\n        _setUpdaddy(msg.sender, _upline);\\r\\n        investor.isExist = true;\\r\\n        investor.deposits.push(\\r\\n            DepositStruct({\\r\\n                amount: amount,\\r\\n                time: uint40(block.timestamp),\\r\\n                withdrawn: 0\\r\\n            })\\r\\n        );\\r\\n        _latestDeposits.push(LatestDeposits({amount:amount,time:block.timestamp,user:msg.sender}));\\r\\n\\r\\n        investor.lastInvestedAmount = amount;\\r\\n        if (investor.deposits.length == 1) {\\r\\n            totalUsers++;\\r\\n        }\\r\\n\\r\\n        investor.totalInvested += amount;\\r\\n        investorsMap[investorsMap[msg.sender].daddy]\\r\\n            .totalReferralInvested += amount;\\r\\n        investorsMap[msg.sender].time = block.timestamp;\\r\\n        contractInvested += amount;\\r\\n        royaltyFunds = royaltyFunds.add(_amount.mul(50).div(10000));\\r\\n        royaltyFundsLevel2 = royaltyFundsLevel2.add(_amount.mul(25).div(10000));\\r\\n        pensionFunds = pensionFunds.add(_amount.mul(25).div(10000));\\r\\n\\r\\n        _refPayout(msg.sender, amount);\\r\\n        if (investor.deposits.length == 1) {\\r\\n            regUserPlanB(payable(msg.sender));\\r\\n        }\\r\\n        investor.lastDepositeTime = block.timestamp;\\r\\n        uint256 insuranceAmount = (amount * INSURANCE_PERCENT) / percentDivider;\\r\\n        IERC20(tokenAddress).transfer(INSURANCE_CONTRACT, insuranceAmount);\\r\\n        distributePool();\\r\\n        emit NewDeposit(msg.sender, amount);\\r\\n    }\\r\\n\\r\\n    function _insuranceTrigger() internal {\\r\\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\\r\\n\\r\\n        INSURANCE_TRIGGER_BALANCE =\\r\\n            (contractInvested * INSURANCE_LOWBALANCE_PERCENT) /\\r\\n            percentDivider;\\r\\n\\r\\n        //low balance - initiate Insurance\\r\\n        if (balance < INSURANCE_TRIGGER_BALANCE && !isInsuranceTriggered) {\\r\\n            isInsuranceTriggered = true;\\r\\n            IInsuranceContract(INSURANCE_CONTRACT).initiate();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function regUserPlanB(address payable userAddress) internal {\\r\\n        dividendUsers[userAddress].planbactivatedround++;\\r\\n        uint256 _roundid = dividendUsers[userAddress].planbactivatedround;\\r\\n        if (lastFreeParent[_roundid] == 0) {\\r\\n            UserStruct memory userStruct;\\r\\n\\r\\n            userStruct = UserStruct({\\r\\n                activeLevel: 1,\\r\\n                planbactivatedround: _roundid\\r\\n            });\\r\\n\\r\\n            dividendUsers[owner] = userStruct;\\r\\n\\r\\n            userInfo memory UserInfoowner;\\r\\n\\r\\n            UserInfoowner = userInfo({\\r\\n                id: 1,\\r\\n                referrerID: 0,\\r\\n                childCount: 0,\\r\\n                userAddress: owner,\\r\\n                noofpayments: 0,\\r\\n                activeLevel: 8\\r\\n            });\\r\\n\\r\\n            userInfos[_roundid][1] = UserInfoowner;\\r\\n            lastIDCount[_roundid] = 1;\\r\\n            lastFreeParent[_roundid] = 1;\\r\\n            userAddressByID[_roundid][1] = owner;\\r\\n        }\\r\\n\\r\\n        if (userInfos[_roundid][lastFreeParent[_roundid]].childCount >= 2)\\r\\n            lastFreeParent[_roundid]++;\\r\\n\\r\\n        userInfo memory UserInfo;\\r\\n        lastIDCount[_roundid]++;\\r\\n\\r\\n        UserInfo = userInfo({\\r\\n            id: lastIDCount[_roundid],\\r\\n            referrerID: lastFreeParent[_roundid],\\r\\n            childCount: 0,\\r\\n            userAddress: userAddress,\\r\\n            noofpayments: 0,\\r\\n            activeLevel: 1\\r\\n        });\\r\\n\\r\\n        userInfos[_roundid][lastIDCount[_roundid]] = UserInfo;\\r\\n        userInfos[_roundid][lastFreeParent[_roundid]].childCount++;\\r\\n        userAddressByID[_roundid][lastIDCount[_roundid]] = userAddress;\\r\\n        dividendUsers[userAddress].activeLevel = 1;\\r\\n\\r\\n        emit buyLevelEvent(\\r\\n            userAddress,\\r\\n            1,\\r\\n            block.timestamp,\\r\\n            LEVEL_PRICE[1],\\r\\n            _roundid\\r\\n        );\\r\\n        emit binaryData(\\r\\n            userAddress,\\r\\n            lastIDCount[_roundid],\\r\\n            lastFreeParent[_roundid],\\r\\n            6,\\r\\n            userAddressByID[_roundid][lastFreeParent[_roundid]],\\r\\n            _roundid\\r\\n        );\\r\\n        distributeBonus(lastIDCount[_roundid], 1, _roundid);\\r\\n    }\\r\\n\\r\\n    function distributeBonus(\\r\\n        uint256 _addr,\\r\\n        uint256 _level,\\r\\n        uint256 _roundid\\r\\n    ) internal {\\r\\n        uint256 up = userInfos[_roundid][_addr].referrerID;\\r\\n        uint256 amt = LEVEL_PRICE[_level];\\r\\n\\r\\n        for (uint256 i = 0; i < _level - 1; i++) {\\r\\n            if (up == 0) break;\\r\\n            up = userInfos[_roundid][up].referrerID;\\r\\n        }\\r\\n        if (up < 2) {\\r\\n            investorsMap[owner].totalBonus += amt;\\r\\n            earningUsers[owner].dividendIncome +=amt;\\r\\n        } else {\\r\\n            address payable receiver = userAddressByID[_roundid][up];\\r\\n            noofPayments[receiver][_level]++;\\r\\n\\r\\n            if (_level == 1 && noofPayments[receiver][_level] == 2) {\\r\\n                distributeBonus(up, 2, _roundid);\\r\\n                // _buyLevel(2, up, _roundid);\\r\\n                emit buyLevelEvent(\\r\\n                    receiver,\\r\\n                    _level,\\r\\n                    block.timestamp,\\r\\n                    LEVEL_PRICE[_level],\\r\\n                    _roundid\\r\\n                );\\r\\n            }\\r\\n            if (_level == 2 && noofPayments[receiver][_level] == 4) {\\r\\n                investorsMap[receiver].totalBonus += LEVEL_PRICE[2].div(2);\\r\\n                earningUsers[receiver].dividendIncome +=LEVEL_PRICE[2].div(2);\\r\\n                noofPayments[receiver][1] = 0;\\r\\n                noofPayments[receiver][2] = 0;\\r\\n                regUserPlanB(receiver);\\r\\n            } else if (_level == 2) {\\r\\n                investorsMap[receiver].totalBonus += amt;\\r\\n                earningUsers[receiver].dividendIncome += amt;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n\\r\\n    function withdraw() external {\\r\\n        require(!idDeactivated[msg.sender], \\\"Id Deactivated\\\");\\r\\n        Investor storage investor = investorsMap[msg.sender];\\r\\n        collect(msg.sender);\\r\\n        // require(block.timestamp > investor.withdrawalTime.add(10 minutes),\\\"Withdrawal available every 24 hours\\\");\\r\\n\\r\\n        uint256 profit = investor.totalInvested.mul(MAX_LIMIT).div(100);\\r\\n        if (isInsuranceTriggered) {\\r\\n            profit = investor.totalInvested;\\r\\n        }\\r\\n\\r\\n        uint256 amount = investor.totalRewards +\\r\\n            investor.unsettled;\\r\\n\\r\\n        investor.unsettled = 0;\\r\\n        if (amount.add(investor.totalWithdrawn) > profit) {\\r\\n            amount = profit.sub(investor.totalWithdrawn);\\r\\n        }\\r\\n        uint256 _maxWithdrawal = maxWithdrawl;\\r\\n        if (\\r\\n            block.timestamp >\\r\\n            withdrawDetails[msg.sender].timestamp.add(24 hours)\\r\\n        ) {\\r\\n            withdrawDetails[msg.sender].timestamp = block.timestamp;\\r\\n            withdrawDetails[msg.sender].amount = 0;\\r\\n        } else {\\r\\n            if (withdrawDetails[msg.sender].amount.add(amount) > maxWithdrawl) {\\r\\n                _maxWithdrawal = maxWithdrawl.sub(\\r\\n                    withdrawDetails[msg.sender].amount\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (amount > _maxWithdrawal) {\\r\\n            investor.unsettled = amount.sub(_maxWithdrawal);\\r\\n            amount = _maxWithdrawal;\\r\\n        }\\r\\n\\r\\n        require(amount > 0, \\\"Nothing to withdraw\\\");\\r\\n        withdrawDetails[msg.sender].amount += amount;\\r\\n        investor.totalRewards = 0;\\r\\n        investor.totalBonus = 0;\\r\\n        investor.totalWithdrawn += amount;\\r\\n        if (investor.totalWithdrawn >= MAX_EARNING) {\\r\\n            idDeactivated[msg.sender] = true;\\r\\n            if (!bonusLevels[msg.sender].isAdded) {\\r\\n                royaltyUsers.push(msg.sender);\\r\\n                bonusLevels[msg.sender].isAdded = true;\\r\\n            }\\r\\n            bonusLevels[msg.sender].level = 3;\\r\\n        }\\r\\n        investor.withdrawalTime = block.timestamp;\\r\\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\\r\\n        if (amount > balance) {\\r\\n            IERC20(tokenAddress).transfer(msg.sender, balance);\\r\\n            contractWithdrawn += balance;\\r\\n        } else {\\r\\n            IERC20(tokenAddress).transfer(msg.sender, amount);\\r\\n            contractWithdrawn += amount;\\r\\n        }\\r\\n\\r\\n        _insuranceTrigger();\\r\\n\\r\\n        if (IERC20(tokenAddress).balanceOf(address(this)) == 0) {\\r\\n            IIPFSDeployer(roiDeployerAddress).deploy(\\r\\n                owner,\\r\\n                dev,\\r\\n                marketing,\\r\\n                payable(address(this))\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function getRoiPer(address _user) public view returns (uint256) {\\r\\n        if (investorsMap[_user].totalWithdrawn.add(investorsMap[_user].unsettled) >= 1000 * 1e18) {\\r\\n            return 25;\\r\\n        } else if (investorsMap[_user].totalWithdrawn.add(investorsMap[_user].unsettled) >= 500 * 1e18) {\\r\\n            return 50;\\r\\n        }\\r\\n        return Daily_ROI_Per;\\r\\n    }\\r\\n\\r\\n    function collect(address _addr) internal {\\r\\n        Investor storage investor = investorsMap[_addr];\\r\\n        uint256 per = getRoiPer(msg.sender);\\r\\n\\r\\n        for (uint256 i = 0; i < investor.deposits.length; i++) {\\r\\n            DepositStruct storage dep = investor.deposits[i];\\r\\n            uint256 share = dep.amount.mul(per).div(percentDividerROI);\\r\\n            uint256 from = dep.time > investor.time ? dep.time : investor.time;\\r\\n            uint256 to = block.timestamp;\\r\\n            uint256 dividends = 0;\\r\\n            uint256 profit = dep.amount.mul(MAX_LIMIT).div(percentDivider);\\r\\n            if (from < to) {\\r\\n                dividends = share.mul(to.sub(from)).div(TIME_STEP);\\r\\n                if (\\r\\n                    dep.withdrawn.add(dividends) > profit\\r\\n                ) {\\r\\n                    dividends = dep\\r\\n                        .amount\\r\\n                        .mul(MAX_LIMIT)\\r\\n                        .div(percentDivider)\\r\\n                        .sub(dep.withdrawn);\\r\\n                }\\r\\n                else if(investor.totalBonus>0){\\r\\n                    uint256 pendingProfit = profit.sub(dep.withdrawn.add(dividends));\\r\\n                    if(investor.totalBonus>pendingProfit)\\r\\n                    {\\r\\n                        dividends = dividends.add(pendingProfit);\\r\\n                        investor.totalBonus = investor.totalBonus.sub(pendingProfit);\\r\\n                    }\\r\\n                    else{\\r\\n                        dividends = dividends.add(investor.totalBonus);\\r\\n                        investor.totalBonus = 0;\\r\\n                    }\\r\\n                }\\r\\n                investor.totalRewards = investor.totalRewards.add(dividends);\\r\\n                dep.withdrawn = dep.withdrawn.add(dividends);\\r\\n            }\\r\\n        }\\r\\n        investor.totalBonus = 0;\\r\\n        investor.time = block.timestamp;\\r\\n    }\\r\\n\\r\\n    function _distributeRoyaltyLevel1() public {\\r\\n        if (royaltyFunds > 5 ether) {\\r\\n        uint256 globalCount;\\r\\n        for (uint256 i = 0; i < royaltyUsers.length; i++) {\\r\\n            if (bonusLevels[royaltyUsers[i]].level == 1) {\\r\\n                globalCount = globalCount.add(1);\\r\\n            }\\r\\n        }\\r\\n        if (globalCount > 0) {\\r\\n            uint256 reward = royaltyFunds.div(globalCount);\\r\\n            for (uint256 i = 0; i < royaltyUsers.length; i++) {\\r\\n                if (bonusLevels[royaltyUsers[i]].level == 1) {\\r\\n                    investorsMap[royaltyUsers[i]].totalBonus = investorsMap[\\r\\n                        royaltyUsers[i]\\r\\n                    ].totalBonus.add(reward);\\r\\n                    earningUsers[royaltyUsers[i]].royaltyIncome += reward;\\r\\n                }\\r\\n            }\\r\\n            royaltyFunds = 0;\\r\\n        }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _distributeRoyaltyLevel2() public {\\r\\n        if (royaltyFundsLevel2 > 5 ether) {\\r\\n        uint256 globalCount;\\r\\n        for (uint256 i = 0; i < royaltyUsers.length; i++) {\\r\\n            if (bonusLevels[royaltyUsers[i]].level == 2) {\\r\\n                globalCount = globalCount.add(1);\\r\\n            }\\r\\n        }\\r\\n        if (globalCount > 0) {\\r\\n            uint256 reward = royaltyFundsLevel2.div(globalCount);\\r\\n            for (uint256 i = 0; i < royaltyUsers.length; i++) {\\r\\n                if (bonusLevels[royaltyUsers[i]].level == 2) {\\r\\n                    investorsMap[royaltyUsers[i]].totalBonus = investorsMap[\\r\\n                        royaltyUsers[i]\\r\\n                    ].totalBonus.add(reward);\\r\\n                    earningUsers[royaltyUsers[i]].royaltyIncome1 += reward;\\r\\n                }\\r\\n            }\\r\\n            royaltyFundsLevel2 = 0;\\r\\n        }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function _distributePension() public {\\r\\n        if (pensionFunds > 5 ether) {\\r\\n        uint256 globalCount;\\r\\n        for (uint256 i = 0; i < royaltyUsers.length; i++) {\\r\\n            if (bonusLevels[royaltyUsers[i]].level == 3) {\\r\\n                globalCount = globalCount.add(1);\\r\\n            }\\r\\n        }\\r\\n        if (globalCount > 0) {\\r\\n            uint256 reward = pensionFunds.div(globalCount);\\r\\n            for (uint256 i = 0; i < royaltyUsers.length; i++) {\\r\\n                if (bonusLevels[royaltyUsers[i]].level == 3) {\\r\\n                    earningUsers[royaltyUsers[i]].pensionIncomeAvailable += reward;\\r\\n                    earningUsers[royaltyUsers[i]].pensionIncome += reward;\\r\\n                }\\r\\n            }\\r\\n            pensionFunds = 0;\\r\\n        }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawPension() external{\\r\\n        require(earningUsers[msg.sender].pensionIncomeAvailable>0,\\\"Nothing to withdraw\\\");\\r\\n         IERC20(tokenAddress).transfer(msg.sender, earningUsers[msg.sender].pensionIncomeAvailable);\\r\\n        emit Withdraw(msg.sender,earningUsers[msg.sender].pensionIncomeAvailable);\\r\\n        earningUsers[msg.sender].pensionIncomeAvailable = 0;\\r\\n    }\\r\\n\\r\\n    function distributePool() internal {\\r\\n        if (royaltyFunds > 5 ether) {\\r\\n            _distributeRoyaltyLevel1();\\r\\n        }\\r\\n        if (royaltyFundsLevel2 > 5 ether) {\\r\\n            _distributeRoyaltyLevel2();\\r\\n        }\\r\\n        if (pensionFunds > 5 ether) {\\r\\n            _distributePension();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calcPayout(address _addr) public view returns (uint256) {\\r\\n        Investor storage investor = investorsMap[_addr];\\r\\n        uint256 per = getRoiPer(_addr);\\r\\n        uint256 totalAmount;\\r\\n\\r\\n        for (uint256 i = 0; i < investor.deposits.length; i++) {\\r\\n            DepositStruct memory dep = investor.deposits[i];\\r\\n            uint256 share = dep.amount.mul(per).div(percentDividerROI);\\r\\n            uint256 from = dep.time > investor.time ? dep.time : investor.time;\\r\\n            uint256 profit = dep.amount.mul(MAX_LIMIT).div(percentDivider);\\r\\n            uint256 dividends = 0;\\r\\n            if (from < block.timestamp) {\\r\\n                dividends = share.mul((block.timestamp).sub(from)).div(TIME_STEP);\\r\\n                if (\\r\\n                    dep.withdrawn.add(dividends) >\\r\\n                    profit\\r\\n                ) {\\r\\n                    dividends = dep\\r\\n                        .amount\\r\\n                        .mul(MAX_LIMIT)\\r\\n                        .div(percentDivider)\\r\\n                        .sub(dep.withdrawn);\\r\\n                }\\r\\n                else if(investor.totalBonus>0){\\r\\n                    uint256 pendingProfit = profit.sub(dep.withdrawn.add(dividends));\\r\\n                    if(investor.totalBonus>pendingProfit)\\r\\n                    {\\r\\n                        dividends = dividends.add(pendingProfit);\\r\\n                    }\\r\\n                    else{\\r\\n                        dividends = dividends.add(investor.totalBonus);\\r\\n                    }\\r\\n                }\\r\\n                totalAmount = totalAmount.add(dividends);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return totalAmount;\\r\\n    }\\r\\n\\r\\n    function getAvailabel(address _addr) public view returns (uint256) {\\r\\n        Investor storage investor = investorsMap[_addr];\\r\\n        uint256 payout = this.calcPayout(_addr);\\r\\n        uint256 amount = investor.totalRewards.add(payout).add(\\r\\n            investor.unsettled\\r\\n        );\\r\\n        uint256 profit = investor.totalInvested.mul(MAX_LIMIT).div(\\r\\n            percentDivider\\r\\n        );\\r\\n        if (isInsuranceTriggered) {\\r\\n            profit = investor.totalInvested;\\r\\n        }\\r\\n\\r\\n        if (amount.add(investor.totalWithdrawn) > profit) {\\r\\n            amount = profit.sub(investor.totalWithdrawn);\\r\\n        }\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    \\r\\n\\r\\n\\r\\n    function _userInfo(address _addr)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 for_withdraw,\\r\\n            uint256 totalInvested,\\r\\n            uint256 totalWithdrawn,\\r\\n            uint256 totalBonus,\\r\\n            uint256 totalRewards,\\r\\n            uint256 totalReferralInvested,\\r\\n            uint256[BonusLinesCount] memory structure,\\r\\n            uint256[BonusLinesCount] memory referralEarningsL,\\r\\n            DepositStruct[] memory deposits\\r\\n        )\\r\\n    {\\r\\n        Investor storage investor = investorsMap[_addr];\\r\\n\\r\\n        uint256 payout = this.calcPayout(_addr);\\r\\n\\r\\n        for (uint8 i = 0; i < BonusLinesCount; i++) {\\r\\n            structure[i] = investor.structure[i];\\r\\n            referralEarningsL[i] = investor.referralEarningsL[i];\\r\\n        }\\r\\n\\r\\n        return (\\r\\n            payout,\\r\\n            investor.totalInvested,\\r\\n            investor.totalWithdrawn,\\r\\n            investor.totalBonus,\\r\\n            investor.totalRewards,\\r\\n            investor.totalReferralInvested,\\r\\n            structure,\\r\\n            referralEarningsL,\\r\\n            investor.deposits\\r\\n        );\\r\\n    }\\r\\n\\r\\n\\r\\n     function _userEarningInfo(address _addr)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 dividendIncome,\\r\\n            uint256 roayltyIncome,\\r\\n            uint256 royaltyIncome1,\\r\\n            uint256 pensionIncome,\\r\\n            uint256 joinedTime\\r\\n        )\\r\\n    {\\r\\n        userEarning storage investor = earningUsers[_addr];\\r\\n\\r\\n        return (\\r\\n            investor.dividendIncome,\\r\\n            investor.royaltyIncome,\\r\\n            investor.royaltyIncome1,\\r\\n            investor.pensionIncome,\\r\\n            investor.joinedTime\\r\\n            );\\r\\n    }\\r\\n\\r\\n    function contractInfo()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint256 _invested,\\r\\n            uint256 _withdrawn,\\r\\n            uint256 _match_bonus,\\r\\n            uint256 _totalUsers,\\r\\n            uint256 latestDeposits\\r\\n        )\\r\\n    {\\r\\n        return (contractInvested, contractWithdrawn, matchBonus, totalUsers,_latestDeposits.length);\\r\\n    }\\r\\n\\r\\n    function isContract(address addr) internal view returns (bool) {\\r\\n        uint256 size;\\r\\n        assembly {\\r\\n            size := extcodesize(addr)\\r\\n        }\\r\\n        return size > 0;\\r\\n    }\\r\\n\\r\\n    function setReferral(address _user, address _upline) external returns(bool) {\\r\\n        require(\\r\\n            IIPFSDeployer(roiDeployerAddress).isWhitelisted(msg.sender),\\r\\n            \\\"Invalid user\\\"\\r\\n        );\\r\\n        investorsMap[_user].isExist = true;\\r\\n        if(earningUsers[_user].joinedTime==0){\\r\\n        earningUsers[_user].joinedTime = block.timestamp;\\r\\n        }\\r\\n        if (_upline == address(0) || !investorsMap[_upline].isExist) {\\r\\n            _upline = owner;\\r\\n        }\\r\\n         if (\\r\\n            investorsMap[_user].daddy == address(0) &&\\r\\n            investorsMap[_upline].isExist &&\\r\\n            _user != _upline  && _upline!=address(0)\\r\\n        ) {\\r\\n            investorsMap[_user].daddy = _upline;\\r\\n            emit regLevelEvent(_user,_upline,block.timestamp);\\r\\n            return true;\\r\\n        }\\r\\n        return false;\\r\\n    }\\r\\n\\r\\n    function getReferral(address _user) external view returns (address) {\\r\\n        require(\\r\\n            IIPFSDeployer(roiDeployerAddress).isWhitelisted(msg.sender),\\r\\n            \\\"Invalid user\\\"\\r\\n        );\\r\\n        return investorsMap[_user].daddy;\\r\\n    }\\r\\n}\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"CreatorAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"DevAddr\",\"type\":\"address\"},{\"internalType\":\"address payable\",\"name\":\"MarketingAddr\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MatchPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"upline\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonus\",\"type\":\"uint256\"}],\"name\":\"Upline\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_userId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_referralID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_roundid\",\"type\":\"uint256\"}],\"name\":\"binaryData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_roundid\",\"type\":\"uint256\"}],\"name\":\"buyLevelEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"regLevelEvent\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Daily_ROI_Per\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSURANCE_CONTRACT\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSURANCE_LOWBALANCE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"INSURANCE_MAXBALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSURANCE_PERCENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INSURANCE_TRIGGER_BALANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"LEVEL_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_distributePension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_distributeRoyaltyLevel1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_distributeRoyaltyLevel2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_latestDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_userEarningInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dividendIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"roayltyIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyIncome1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pensionIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joinedTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"_userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"for_withdraw\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferralInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256[5]\",\"name\":\"structure\",\"type\":\"uint256[5]\"},{\"internalType\":\"uint256[5]\",\"name\":\"referralEarningsL\",\"type\":\"uint256[5]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint40\",\"name\":\"time\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"internalType\":\"struct DepositStruct[]\",\"name\":\"deposits\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusLevels\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"level\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isAdded\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"calcPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_invested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_match_bonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_totalUsers\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"latestDeposits\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractInvested\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currUserID\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dev\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"dividendUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"activeLevel\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"planbactivatedround\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"earningUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dividendIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"royaltyIncome1\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pensionIncome\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"joinedTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pensionIncomeAvailable\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getAvailabel\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getReferral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getRoiPer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"idDeactivated\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"investorsMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastInvestedAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"daddy\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"lastPayout\",\"type\":\"uint40\"},{\"internalType\":\"uint256\",\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReferralInvested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalWithdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawalTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unsettled\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isExist\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"lastDepositeTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInsuranceTriggered\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastFreeParent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastIDCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketing\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matchBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxWithdrawl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"noofPayments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pensionFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"royaltyFundsLevel2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"royaltyUsers\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_upline\",\"type\":\"address\"}],\"name\":\"setReferral\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_restart\",\"type\":\"address\"}],\"name\":\"setRoiDeployerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userAddressByID\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"userInfos\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referrerID\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"childCount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"noofpayments\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"activeLevel\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userTeams\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"totalBusiness\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalTeam\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawDetails\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "IPFSUNO", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000533810632ed08c0f8c0bf2911dc0195f0a6287a9000000000000000000000000533810632ed08c0f8c0bf2911dc0195f0a6287a9000000000000000000000000d0db6ccf4f38f9b136714f3a78951374129df94e", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}