{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * The default value of {decimals} is 18. To change this, you should override\\n * this function so it returns a different value.\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the default value returned by this function, unless\\n     * it's overridden.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address from, address to, uint256 amount) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/ArrayUtils.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nlibrary ArrayUtils {\\n    function search(address[] storage array, address value) internal view returns (bool) {\\n        for (uint i = 0; i < array.length; i++) {\\n            if (array[i] == value) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    function add(address[] storage array, address value) internal {\\n        array.push(value);\\n    }\\n\\n    function remove(address[] storage array, address value) internal {\\n        for (uint i = 0; i < array.length; i++) {\\n            if (array[i] == value) {\\n                array[i] = array[array.length - 1];\\n                array.pop();\\n                break;\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKonaGlobals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IKonaGlobals {\\n    event KonaPoolsSet(address oldAddress, address newAddress);\\n    event KonaOraclesSet(address oldAddress, address newAddress);\\n    event KonaStakingSet(address oldAddress, address newAddress);\\n    event ReferenceRateSet(uint256 oldValue, uint256 _newValue);\\n    event KonaDistributionSet(address oldAddress, address newAddress);\\n\\n    function setKonaPools(address _newAddress) external;\\n\\n    function setKonaOracles(address _newAddress) external;\\n\\n    function setKonaStaking(address _newAddress) external;\\n\\n    function setRefenceRate(uint256 _newValue) external;\\n\\n    function setKonaDistribution(address _newAddress) external;\\n\\n    function konaPools() external view returns (address);\\n\\n    function konaOracles() external view returns (address);\\n\\n    function konaStaking() external view returns (address);\\n\\n    function konaDistribution() external view returns (address);\\n\\n    function referenceRate() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKonaOracles.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IKonaOracles {\\n    function konaGlobals() external view returns (address _globals);\\n\\n    function isOracleEnabled(address _oracle) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKonaPools.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IKonaPools {\\n    event PoolStatusChanged(address indexed pool, bool status);\\n\\n    enum Status {\\n        JOIN_LEAVE,\\n        VOTING,\\n        ASSIGN_CAPITAL,\\n        CYCLE,\\n        DISTRIBUTION\\n    }\\n\\n    function konaGlobals() external view returns (address _globals);\\n\\n    function emergencyMode() external view returns (bool);\\n\\n    function getPools() external view returns (address[] memory);\\n\\n    function isValidPool(address pool) external view returns (bool);\\n\\n    function changePoolStatus(address _pool, bool _status) external;\\n\\n    function canStartJoinLeave() external view returns (bool);\\n\\n    function canStartAssignCapital() external view returns (bool);\\n\\n    function canStartVoting() external view returns (bool);\\n\\n    function canStartNewCycle() external view returns (bool);\\n\\n    function startNewCycle() external;\\n\\n    function startJoinLeave() external;\\n\\n    function startVoting() external;\\n\\n    function startAssignCapital() external;\\n\\n    function isDateInsideCurrentCycle(uint256 _maturity) external view returns (bool);\\n\\n    function getCycleStatus() external view returns (uint256, uint256, Status);\\n\\n    function getCycleDays() external pure returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKonaStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IKonaStaking {\\n    event StakeIncreased(address indexed user, uint256 total);\\n    event StakeReduced(address indexed user, uint256 total);\\n    event StakeIncreasedAfterInflation(address indexed user, uint256 total);\\n    event StakerVoted(\\n        address indexed staker,\\n        address indexed pool,\\n        address indexed oracle,\\n        uint256 cycle,\\n        uint256 totalVotes\\n    );\\n\\n    function setBrzRewardPerOracleRate(uint cycle, address pool, address oracle, uint rewardRate) external;\\n\\n    function claimReward(address pool) external;\\n\\n    function totalVotedPoolPerCycle(uint, address) external view returns (uint);\\n\\n    function totalVotesPerCycle(uint) external view returns (uint);\\n\\n    function stake(uint256 _total) external;\\n\\n    function unstake(uint256 _total) external;\\n\\n    function rewardPerOracleRate(uint, address, address) external returns (int);\\n\\n    function increaseStakerAfterInflation(address _user, uint256 _total) external;\\n\\n    function increaseNewMintedTokens(uint256 _newMintedTokens) external;\\n\\n    function getTotalStaked() external view returns (uint256);\\n\\n    function getTotalStakedByUser(address _user) external view returns (uint256);\\n\\n    function getOraclesInPoolLength(uint cycle, address user, address pool) external view returns (uint);\\n\\n    function getOutstandingLpReward(address user, address pool) external view returns (uint);\\n\\n    function setRewardPerOracleRate(uint cycle, address pool, address oracle, int rate) external;\\n\\n    function setInflationRateCycle(uint cycle, uint inflationRewardRate) external;\\n\\n    function totalVotedPoolOraclePerCycle(uint, address, address) external view returns (uint);\\n\\n    function getUserHasVotedInPool(uint, address, address) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IKonaToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IKonaToken {\\n    function totalSupply() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/ILoan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface ILoan {\\n\\n   function repay(uint256 _total) external;\\n   \\n   function getMaturity() external view returns(uint256);\\n   \\n   function getIsFunded() external view returns(bool);\\n   \\n   function getAmount() external view returns(uint256);\\n   \\n   function setIsFunded() external;\\n   \\n   function getCycle() external view returns (uint256);\\n   \\n   function getBrzToken() external view returns (IERC20);\\n   \\n   function getBorrower() external view returns (address);\\n   \\n   function getInterestRate() external view returns (uint256);\\n   \\n   function getRepayments() external view returns (uint256);\\n   \\n   function getAmountPlusInterest() external view returns (uint256);\\n   \\n   function getExcessCollateral() external view returns (uint256);\\n   \\n   function getBorrowerInfo() external view returns (string memory);\\n   \\n   function getLockReference() external view returns (string memory);\\n   \\n   function getTotalRepaid() external view returns (uint256);\\n   \\n   function getOracle() external view returns (address);\\n\\n   event Withdrawn(address indexed rampAddress, uint256 amount);\\n   event Repaid(address indexed rampAddress, address indexed oracle, address indexed pool, uint256 amount);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IOracle.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IOracle {\\n    event StandByCapitalCommited(address indexed pool, uint256 indexed cycle, uint256 total);\\n    event LoanWithdrawn(\\n        address indexed loan,\\n        address indexed pool,\\n        uint256 indexed cycle,\\n        address rampAddress,\\n        uint256 total\\n    );\\n    struct LoanParams {\\n        address _borrower;\\n        uint256 _amount;\\n        uint256 _interestRate;\\n        uint256 _maturity;\\n        uint256 _repayments;\\n        uint256 _amountPlusInterest;\\n        uint256 _excessCollateral;\\n        string _borrowerInfo;\\n        string _lockReference;\\n        address _pool;\\n    }\\n    event LoanRepaid(address indexed loan, address indexed pool, uint256 indexed loanCycle, uint256 total);\\n\\n    event LoanDeployed(address indexed loan);\\n\\n    function acceptCapitalAssigned(address _pool, uint256 _total) external;\\n\\n    function commitStandByCapital(address _pool, uint256 _total) external;\\n\\n    function oracleFee() external view returns (uint256);\\n\\n    function repay(uint256 _total) external;\\n\\n    function loans(address _loan) external returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IPool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\ninterface IPool {\\n    struct Vote {\\n        address staker;\\n        uint256 totalVotes;\\n    }\\n\\n    event OracleStatusChanged(address indexed oracle, bool status);\\n    event OracleCostOfCapitalSet(address indexed oracle, uint256 cycle, uint256 total);\\n    event OracleCapitalAssignedSet(address indexed oracle, uint256 cycle, uint256 total);\\n    event OracleCapitalAssignedAccepted(address indexed oracle, uint256 cycle, uint256 totalAccepted);\\n    event LoanStatusChanged(address indexed loan, bool status);\\n    event OracleStandByCapitalCommitted(address indexed oracle, uint256 cycle, uint256 total);\\n    event LoanFunded(uint256 indexed cycle, address indexed oracle, address indexed loan, uint256 loanAmount);\\n    event LoanRepaid(address indexed loan, address indexed oracle, uint256 indexed loanCycle, uint256 total);\\n    event FundsAddedAfterDistribution(uint256 indexed cycle, address indexed oracle, uint256 total);\\n    event StandByCapitalReturnedAfterDistribution(uint256 indexed cycle, address indexed oracle, uint256 total);\\n\\n    event NewDepositRequest(address indexed liquidityProvider, uint indexed cycle, uint256 brzTokens);\\n    event NewWithdrawRequest(address indexed liquidityProvider, uint indexed cycle, uint256 lpTokens);\\n\\n    event CanceledDepositRequest(address indexed liquidityProvider, uint indexed cycle, uint256 brzTokens);\\n    event CanceledWithdrawRequest(address indexed liquidityProvider, uint indexed cycle, uint256 lpTokens);\\n\\n    event FinalDepositRequest(address indexed liquidityProvider, uint indexed cycle, uint256 brzTokens);\\n    event FinalWithdrawRequest(address indexed liquidityProvider, uint indexed cycle, uint256 lpTokens);\\n\\n    event DirectDeposit(address indexed liquidityProvider, uint indexed cycle, uint256 brzTokens);\\n    event DirectWithdraw(address indexed liquidityProvider, uint indexed cycle, uint256 lpTokens);\\n\\n    event NewRewardDeposit(address indexed liquidityProvider, uint indexed cycle, uint256 total);\\n    event ClaimRewardDeposit(address indexed liquidityProvider, uint indexed cycle, uint256 total);\\n\\n    function konaGlobals() external view returns (address _globals);\\n\\n    function getOracles() external view returns (address[] memory);\\n\\n    function directDeposit(uint amount) external;\\n\\n    function directWithdraw(uint amount) external;\\n\\n    function queueDeposit(uint256 amount) external;\\n\\n    function queueWithdraw(uint256 amount) external;\\n\\n    function finalizeDepositQueue(uint amount, uint requestedCycle) external;\\n\\n    function finalizeWithdrawQueue(uint amount, uint requestedCycle) external;\\n\\n    function depositBalancePerCycle(uint cycle, address user) external returns (uint);\\n\\n    function requestFunding(address _loan) external returns (bool);\\n\\n    function claimRewardDeposit(address _beneficiary, uint _total, uint _cycle) external;\\n\\n    function totalCapitalSupplyPerCycle(uint cycle) external view returns (uint);\\n\\n    function totalCapitalsAcceptedManual(uint cycle) external view returns (uint);\\n\\n    function totalCapitalsAccepted(uint cycle) external view returns (uint);\\n\\n    function assignCapitalAfterVoting(address[] memory _oracles) external;\\n\\n    function isDateInsideCurrentCycle(uint256 _maturity) external returns (bool);\\n\\n    function commitStandByCapital(uint256 _total) external;\\n\\n    function getBRZForShares(uint shares, uint cycleNumber) external view returns (uint);\\n\\n    function getShares(uint _brzAmount, uint cycleNumber) external view returns (uint);\\n\\n    function acceptCapitalAssigned(uint256 _total) external;\\n\\n    function getOriginalCapitalAssigned(address _oracle, uint256 _cycleNumber) external view returns (uint256);\\n\\n    function getAcceptedCapitalAssigned(address _oracle, uint256 _cycleNumber) external view returns (uint256);\\n\\n    function getCommittedStandByCapital(address _oracle, uint256 _cycleNumber) external view returns (uint256);\\n\\n    function changeOracleStatus(address _oracle, bool _status) external;\\n\\n    function repay(address _loan, uint256 _total) external;\\n\\n    function getFundsAvailableToSpend(address _oracle, uint256 _cycleNumber) external view returns (uint256);\\n\\n    function getCostOfCapital(address _oracle, uint256 _cycleNumber) external view returns (uint256);\\n\\n    function addFundsAfterDistribution(uint256 _cycleNumber, address _oracle, uint256 _total) external;\\n\\n    function sendStandByBackToOracle(uint256 _cycleNumber, address _oracle, uint256 _total) external;\\n\\n    function hasOracles() external view returns (bool);\\n\\n    function createRewardDeposit(address _beneficiary, uint256 _total) external;\\n\\n    function getBRZBalanceWithRewards(address user) external view returns (uint);\\n\\n    function atLeastOneOraclesHasCapital(uint256 _cycleNumber) external view returns (bool);\\n\\n    function onCycleRollOver(uint lastCycle) external;\\n}\\n\"\r\n    },\r\n    \"contracts/KonaMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport '@openzeppelin/contracts/utils/math/SafeMath.sol';\\n\\n/**\\n * @title KonaMath\\n * @dev A library for mathematical calculations related to the Kona protocol.\\n */\\nlibrary KonaMath {\\n    using SafeMath for uint256;\\n\\n    uint256 constant k = 19;\\n    uint256 constant c = 147221949; //0.147221949 * 1e18; //147221949; //0.147221949\\n    uint256 constant M = 1e27; //KonaToken total supply\\n\\n    uint256 private constant SCALE = 1e18;\\n\\n    /**\\n     * @dev Calculates the cost of capital based on the reference rate, staker weight, cycle duration, and other factors.\\n     * @param _referenceRate The reference rate value\\n     * @param _s The staker weight value\\n     * @param _c The constant value\\n     * @param _cycleDuration The duration of the cycle\\n     * @return The cost of capital as a percentage\\n     * The result is a percentage and the two last digits are decimals\\n     */\\n    function calculateCostOfCapital(\\n        uint256 _referenceRate,\\n        uint256 _s,\\n        uint256 _c,\\n        uint256 _cycleDuration\\n    ) public pure returns (uint256) {\\n        return ((_referenceRate * 100 + max(100 - _s - _c, 0) ** 2 / 2) * _cycleDuration) / 360;\\n    }\\n\\n    /**\\n     * @dev Calculates the excess for stakers based on the alpha value and staker weight.\\n     * @param _alpha The alpha value\\n     * @param _s The staker weight value\\n     * @return The excess for stakers\\n     */\\n    function calculateExcessForStakers(uint256 _alpha, uint256 _s) public pure returns (uint256) {\\n        // I need to do alpha^2 * exp(1-alpha) * S / 2\\n\\n        uint x = 100 - _alpha;\\n        uint256 exp = expApproximation(x, 100);\\n        uint256 calc = _alpha ** 2 * exp;\\n        uint256 excess = (calc * _s) / 2 / SCALE / 1e16;\\n        return excess;\\n    }\\n\\n    /**\\n     * @dev Calculates the slash rate based on the alpha value.\\n     * @param _alpha The alpha value\\n     * @return The slash rate\\n     */\\n    function calculateSlashRate(uint256 _alpha) public pure returns (uint256) {\\n        if (_alpha == 100 || _alpha == 0) {\\n            return 0;\\n        }\\n\\n        uint256 tan = uint256(tanh(100 - _alpha, _alpha));\\n        uint256 slashRate = (tan * _alpha) / (100 - _alpha);\\n        return slashRate;\\n    }\\n\\n    /**\\n     * @dev Calculates the inflation based on the winning oracles weight, staker weight, and cycle number.\\n     * @param _winningOraclesWeight The weight of the winning oracles\\n     * @param _s The staker weight value\\n     * @param _cycleNumber The cycle number\\n     * @return The total new supply as a result of inflation\\n     */\\n    function calculateInflation(\\n        uint256 _winningOraclesWeight,\\n        uint256 _s,\\n        uint256 _cycleNumber\\n    ) public pure returns (uint256) {\\n        uint256 t = _winningOraclesWeight * _s * _cycleNumber;\\n        uint256 c_t = c * t;\\n\\n        uint256 e = expApproximation(c_t, 1e29);\\n        uint256 er = reciprocal(e);\\n        uint256 div = 1e18 + k * er;\\n        uint256 totalNewSupply = (M * 1e18) / div;\\n\\n        return totalNewSupply;\\n    }\\n\\n    /**\\n     * @dev Calculates the reciprocal of a number.\\n     * @param _x The input number\\n     * @return The reciprocal of the input number\\n     */\\n    function reciprocal(uint256 _x) internal pure returns (uint256) {\\n        return 1e36 / _x; // Adjusted to maintain decimal precision\\n    }\\n\\n    /**\\n     * @dev Finds the maximum of two numbers.\\n     * @param a The first number\\n     * @param b The second number\\n     * @return The maximum of the two numbers\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a >= b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Calculates the hyperbolic tangent of a number.\\n     * @param _numerator The numerator value\\n     * @param _denominator The denominator value\\n     * @return The hyperbolic tangent of the input values\\n     */\\n    function tanh(uint256 _numerator, uint256 _denominator) internal pure returns (uint256) {\\n        //tanh(x) = 1 - 2 / (1 + e^2x)\\n        uint256 exp = expApproximation(2 * _numerator, _denominator);\\n        uint256 denom = SCALE + exp; //Scales by 1e18\\n        return 1e6 - (2 * SCALE * 1e6) / denom;\\n    }\\n\\n    /**\\n     * @dev Calculates an approximation of the exponential function.\\n     * @param _numerator The numerator value\\n     * @param _denominator The denominator value\\n     * @return The approximation of the exponential function\\n     */\\n    function expApproximation(uint256 _numerator, uint256 _denominator) internal pure returns (uint256) {\\n        uint256 scaledX = (_numerator * SCALE) / _denominator;\\n        uint256 scaledX2 = (scaledX * scaledX) / SCALE; // Scale down x^2 by 1e18\\n        uint256 scaledX3 = (scaledX2 * scaledX) / SCALE; // Scale down x^3 by 1e18\\n        uint256 scaledX4 = (scaledX3 * scaledX) / SCALE; // Scale down x^4 by 1e18\\n        uint256 scaledX5 = (scaledX4 * scaledX) / SCALE; // Scale down x^5 by 1e18\\n\\n        uint256 result = SCALE + scaledX + (scaledX2 / 2) + (scaledX3 / 6) + (scaledX4 / 24) + (scaledX5 / 120);\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.19;\\n\\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\nimport '@openzeppelin/contracts/token/ERC20/ERC20.sol';\\nimport './interfaces/IKonaPools.sol';\\nimport './interfaces/IPool.sol';\\nimport './interfaces/ILoan.sol';\\nimport './interfaces/IOracle.sol';\\nimport './interfaces/IKonaStaking.sol';\\nimport './interfaces/IKonaGlobals.sol';\\nimport './interfaces/IKonaOracles.sol';\\nimport './interfaces/IKonaToken.sol';\\nimport './KonaMath.sol';\\nimport './ArrayUtils.sol';\\n\\n/**\\n * @title Pool\\n * @dev This contract represents a pool that manages funds, oracles, and loans.\\n */\\ncontract Pool is ERC20, IPool {\\n    using ArrayUtils for address[];\\n\\n    // AccuracyBase for all the rates\\n    uint256 private constant ACCURACY_BASE = 1e18;\\n\\n    address public override konaGlobals;\\n\\n    address[] private oracles;\\n    mapping(address => bool) public loans;\\n\\n    address public owner;\\n\\n    // The Emergency Wallet where funds in an emergency are sent to\\n    address public emergencyWallet;\\n\\n    // Maps cycle => user => LP token balance for that cycle\\n    mapping(uint => mapping(address => uint)) lpTokenBalancePerCycle;\\n\\n    // Maps cycle => user => withdraw amount queued for that cycle\\n    mapping(uint => mapping(address => uint)) public withdrawBalancePerCycle;\\n\\n    // Maps cycle => user => deposit amount queued for that cycle\\n    mapping(uint => mapping(address => uint)) public depositBalancePerCycle;\\n\\n    // Maps cycle => user => BRZ recovered for that cycle\\n    mapping(uint => mapping(address => uint)) balanceRecoveredPerCycle;\\n\\n    // Maps cycle => amountRecovered\\n    mapping(uint => uint) public lateRecovered;\\n\\n    // Maps cycle => user => amountClaimed per user in the cycle\\n    mapping(uint => mapping(address => uint)) public recoveryClaimedUser;\\n\\n    // Stores list of cycles where user had relevant balance changes\\n    mapping(address => uint[]) relevantChanges;\\n\\n    // Stores total LP token supply for each cycle\\n    mapping(uint => uint) public totalLPTokenSupplyPerCycle;\\n\\n    // Stores total capital supply for each cycle\\n    mapping(uint => uint) public totalCapitalSupplyPerCycle;\\n\\n    // Stores LP tokens to remove queued for each cycle\\n    mapping(uint => uint) lpToRemoveThisCycle;\\n\\n    // Stores capital to add queued for each cycle\\n    mapping(uint => uint) capitalToAddCycle;\\n\\n    mapping(uint => mapping(address => uint)) public brzRewardPerOracleRate;\\n\\n    IERC20 public brzToken;\\n    IKonaToken public konaToken;\\n    string public poolName;\\n\\n    /**\\n     * @dev Struct representing the assigned capital to an oracle for a specific cycle.\\n     */\\n    struct CapitalAssigned {\\n        bool confirmed;\\n        bool isManuallyAssigned;\\n        uint256 totalOriginal;\\n        uint256 totalAccepted;\\n        uint256 fundsAvailableToSpend;\\n    }\\n\\n    //Cycle x Oracle x Stand By Capital\\n    mapping(uint256 => mapping(address => uint256)) public standByCapitals;\\n\\n    //Cycle x Oracle Address x Capital Assigned\\n    mapping(uint256 => mapping(address => CapitalAssigned)) public capitalsAssigned;\\n    mapping(uint256 => uint256) public totalCapitalsAssignedManual;\\n    mapping(uint256 => uint256) public totalCapitalsAcceptedManual;\\n    mapping(uint256 => uint256) public totalCapitalsAccepted;\\n\\n    //Cycle x Oracle Address x Cost Of Capital\\n    mapping(uint256 => mapping(address => uint256)) public costsOfCapital;\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner, 'only Owner can call this');\\n        _;\\n    }\\n    modifier onlyEmergencyWallet() {\\n        require(msg.sender == emergencyWallet, 'only Owner can call this');\\n        _;\\n    }\\n    modifier onlyOracle() {\\n        require(oracles.search(msg.sender), 'Only Oracles can call this');\\n        _;\\n    }\\n\\n    modifier onlyKonaPools() {\\n        require(msg.sender == address(getKonaPools()), 'Only the Pool Manager can call this');\\n        _;\\n    }\\n\\n    function transferOwnership(address newOwner) external onlyOwner {\\n        owner = newOwner;\\n    }\\n\\n    /**\\n     * @dev Initializes the Pool contract.\\n     * @param _poolName The pool's name.\\n     * @param _konaGlobals The Kona Globals contract address.\\n     * @param _brzToken The BRZ token contract address.\\n     * @param _konaToken The Kona token contract address.\\n     */\\n    constructor(\\n        string memory _poolName,\\n        address _konaGlobals,\\n        IERC20 _brzToken,\\n        IKonaToken _konaToken\\n    ) ERC20('KonaPoolToken', 'KPT') {\\n        require((konaGlobals = _konaGlobals) != address(0), 'P:ZERO_ADDRESS');\\n        owner = msg.sender;\\n        poolName = _poolName;\\n        brzToken = _brzToken;\\n        konaToken = _konaToken;\\n\\n        emergencyWallet = msg.sender;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimal places for the token.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev Change the status of an oracle.\\n     * @param _oracle The address of the oracle.\\n     * @param _status The new status to set.s\\n     */\\n    function changeOracleStatus(address _oracle, bool _status) public onlyOwner {\\n        require(!oracles.search(_oracle) || !_status, 'Can set the same status');\\n\\n        if (_status) {\\n            address konaOracles = IKonaGlobals(konaGlobals).konaOracles();\\n            bool isOracleEnabled = IKonaOracles(konaOracles).isOracleEnabled(_oracle);\\n            require(isOracleEnabled, 'Oracle not enabled by Manager');\\n            oracles.add(_oracle);\\n        } else {\\n            oracles.remove(_oracle);\\n        }\\n\\n        emit OracleStatusChanged(_oracle, _status);\\n    }\\n\\n    /**\\n     * @dev Allows a user to queue a withdrawal of LP tokens\\n     * @param amount - the amount of LP tokens to withdraw\\n     */\\n    function queueWithdraw(uint amount) external {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        (uint currentCycle,IKonaPools.Status status , ) = getCurrentCycleStatus();\\n        require(status != IKonaPools.Status.JOIN_LEAVE, 'Can only query outside of the J/L Period');\\n        // Transfer LP tokens from user to contract //don't burn because of the rate being inaccurate if you burn before adjusting the capital etc.\\n        require(this.transferFrom(msg.sender, address(this), amount), 'Transfer failed');\\n\\n        // Get current cycle number\\n\\n        // Add amount to user's withdraw balance for this cycle\\n        withdrawBalancePerCycle[currentCycle][msg.sender] += amount;\\n\\n        // Store user's current LP token balance for next cycle\\n        lpTokenBalancePerCycle[currentCycle + 1][msg.sender] = balanceOf(msg.sender);\\n\\n        // Add next cycle to list of cycles with relevant changes\\n        relevantChanges[msg.sender].push(currentCycle + 1);\\n\\n        // Increase total LP tokens to remove next cycle\\n        lpToRemoveThisCycle[currentCycle + 1] += amount;\\n\\n        emit NewWithdrawRequest(msg.sender, currentCycle, amount);\\n    }\\n\\n    /**\\n     * @dev Allows a user to cancel a portion of their queued withdrawal\\n     * @param amount - the amount of the queued withdrawal to cancel\\n     */\\n    function cancelWithdraw(uint amount) external {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        // Get current cycle\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n        // Get user's withdraw balance for current cycle\\n        uint balance = withdrawBalancePerCycle[currentCycle][msg.sender];\\n\\n        // Check that balance is sufficient\\n        require(balance >= amount, \\\"you don't have enough funds in the withdraw queue\\\");\\n\\n        // Decrease user's withdraw balance\\n        withdrawBalancePerCycle[currentCycle][msg.sender] = balance - amount;\\n\\n        // Remove cycle from list of relevant changes if the whole withdrawal is cancelled\\n        if (amount == balance) {\\n            relevantChanges[msg.sender].pop();\\n        }\\n\\n        // Decrease total LP tokens to remove\\n        lpToRemoveThisCycle[currentCycle + 1] -= amount;\\n\\n        // Transfer LP tokens back to user\\n        require(this.transfer(msg.sender, amount), 'Transfer failed');\\n\\n        // Update user's LP token balance\\n        lpTokenBalancePerCycle[currentCycle + 1][msg.sender] = balanceOf(msg.sender);\\n\\n        emit CanceledWithdrawRequest(msg.sender, currentCycle, amount);\\n    }\\n\\n    /**\\n     * @dev Withdraws LP tokens that were previously queued\\n     * @param amount - amount in LP to withdraw\\n     * @param requestedCycle - cycle the withdrawal was queued in\\n     */\\n    function finalizeWithdrawQueue(uint amount, uint requestedCycle) external {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        // Get current cycle number\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n        // Check requested cycle is in the past\\n        require(currentCycle != requestedCycle, 'The Cycle did not yet pass');\\n\\n        // Check if enough was queued for withdrawal\\n        require(\\n            amount <= withdrawBalancePerCycle[requestedCycle][msg.sender],\\n            'not enought queued for withdrawal in that cycle'\\n        );\\n\\n        // Calculate BRZ amount based on last cycle's supplies\\n        uint brzAmount = getBRZForShares(amount, requestedCycle + 1);\\n\\n        // Decrease user's queued withdrawal amount\\n        withdrawBalancePerCycle[requestedCycle][msg.sender] -= amount;\\n\\n        // Get last cycle with relevant change for user\\n        uint lastChange;\\n        if (relevantChanges[msg.sender].length != 0) {\\n            lastChange = relevantChanges[msg.sender][relevantChanges[msg.sender].length - 1];\\n        }\\n\\n        // Add current cycle if different than last change\\n        if (lastChange != currentCycle || lastChange == 0) {\\n            relevantChanges[msg.sender].push(currentCycle);\\n        }\\n        require(brzToken.transfer(msg.sender, brzAmount), 'Transfer failed');\\n\\n        emit FinalWithdrawRequest(msg.sender, requestedCycle, amount);\\n    }\\n\\n    /**\\n     * @dev Allows a user to queue a deposit of BRZ\\n     * @param amount - amount of BRZ to deposit\\n     */\\n    function queueDeposit(uint amount) external {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        (uint currentCycle,IKonaPools.Status status , ) = getCurrentCycleStatus();\\n        require(status != IKonaPools.Status.JOIN_LEAVE, 'Can only query outside of the J/L Period');\\n        // Transfer BRZ from user to contract\\n        require(brzToken.transferFrom(msg.sender, address(this), amount), 'Transfer failed');\\n\\n        // Get current cycle number\\n\\n        // Increase user's deposit balance for next cycle\\n        depositBalancePerCycle[currentCycle][msg.sender] += amount;\\n\\n        // Increase total capital to add next cycle\\n        capitalToAddCycle[currentCycle + 1] += amount;\\n\\n        emit NewDepositRequest(msg.sender, currentCycle, amount);\\n    }\\n\\n    /**\\n     * @dev Allows a user to cancel a queued deposit\\n     * @param amount - amount of queued deposit to cancel\\n     */\\n    function cancelDeposit(uint amount) external {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        // Get current cycle number\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n        // Check user has enough queued for cancelation\\n        require(\\n            depositBalancePerCycle[currentCycle][msg.sender] >= amount,\\n            'not enough balance, or cancel peroid over'\\n        );\\n\\n        // Decrease user's queued deposit amount\\n        depositBalancePerCycle[currentCycle][msg.sender] -= amount;\\n\\n        // Decrease total capital to add next cycle\\n        capitalToAddCycle[currentCycle + 1] -= amount;\\n\\n        // Return BRZ to user\\n        require(brzToken.transfer(msg.sender, amount), 'Transfer failed');\\n\\n        emit CanceledDepositRequest(msg.sender, currentCycle, amount);\\n    }\\n\\n    /**\\n     * @dev Gives the User the shares for the BRZ that were previously queued\\n     * @param amount - amount to deposit\\n     * @param requestedCycle - cycle the deposit was queued in\\n     */\\n    function finalizeDepositQueue(uint amount, uint requestedCycle) external {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        // Get current cycle number\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n        // Check requested cycle is in past\\n        require(requestedCycle != currentCycle, 'Requested cycle must have already passed');\\n\\n        // Validate deposit amount\\n        require(amount != 0 && amount <= depositBalancePerCycle[requestedCycle][msg.sender], 'Invalid amount');\\n\\n        // Calculate LP tokens to mint based on last cycle data\\n        uint sharesToMint = getShares(amount, requestedCycle + 1);\\n\\n        // Decrease user's queued deposit amount\\n        depositBalancePerCycle[requestedCycle][msg.sender] -= amount;\\n\\n        // Mint LP tokens to user\\n        require(this.transfer(msg.sender, sharesToMint), 'Transfer failed');\\n        lpTokenBalancePerCycle[requestedCycle][msg.sender] += sharesToMint;\\n        if (requestedCycle != getLastChangedCycle(msg.sender)) {\\n            relevantChanges[msg.sender].push(currentCycle);\\n        }\\n\\n        emit FinalDepositRequest(msg.sender, currentCycle, amount);\\n    }\\n\\n    function isValidPool() internal view returns(bool){\\n        return getKonaPools().isValidPool(address(this));\\n    }\\n\\n    /**\\n     * @dev Directly deposits BRZ during join/leave period\\n     * @param amount Amount of BRZ to deposit\\n     */\\n    function directDeposit(uint amount) external {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        // Check we are in join/leave period\\n        (uint currentCycle,IKonaPools.Status status , ) = getCurrentCycleStatus();\\n        require(\\n            status == IKonaPools.Status.JOIN_LEAVE || !isValidPool(),\\n            'Not join or leave-period'\\n        );\\n\\n        // Transfer BRZ from user\\n        require(brzToken.transferFrom(msg.sender, address(this), amount), 'Transfer failed');\\n\\n        // Get current cycle\\n\\n        // Mint LP tokens based on deposit amount\\n        uint toMint = getShares(amount, currentCycle);\\n        _mint(msg.sender, toMint);\\n\\n        // Update user's deposit balance and cycles changed\\n        relevantChanges[msg.sender].push(currentCycle);\\n        lpTokenBalancePerCycle[currentCycle][msg.sender] += toMint;\\n        totalLPTokenSupplyPerCycle[currentCycle] += toMint;\\n\\n        // Update contract balance and cycles changed\\n        totalCapitalSupplyPerCycle[currentCycle] += amount;\\n\\n        emit DirectDeposit(msg.sender, currentCycle, amount);\\n    }\\n\\n    /**\\n     * @dev Directly withdraws BRZ during join/leave period\\n     * @param amount Amount of LP tokens to redeem for BRZ\\n     */\\n    function directWithdraw(uint amount) external {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        // Check we are in join/leave period\\n        (uint currentCycle,IKonaPools.Status status , ) = getCurrentCycleStatus();\\n        require(\\n            status == IKonaPools.Status.JOIN_LEAVE || !isValidPool(),\\n            'Not join- or leave-period'\\n        );\\n        // Burn the user's LP tokens\\n        _burn(msg.sender, amount);\\n\\n        // Get current cycle\\n\\n        // Calculate BRZ to withdraw based on LP tokens\\n        uint toWithdraw = getBRZForShares(amount, currentCycle);\\n\\n        // Update user's token balance and cycles changed\\n        lpTokenBalancePerCycle[currentCycle][msg.sender] -= amount;\\n        relevantChanges[msg.sender].push(currentCycle);\\n\\n        // Update contract balance and cycles changed\\n        totalCapitalSupplyPerCycle[currentCycle] -= amount;\\n        totalLPTokenSupplyPerCycle[currentCycle] -= toWithdraw;\\n\\n        // Transfer BRZ to user\\n        require(brzToken.transfer(msg.sender, toWithdraw), 'Transfer failed');\\n\\n        emit DirectWithdraw(msg.sender, currentCycle, amount);\\n    }\\n\\n    /**\\n     * @dev Changes the status of a loan.\\n     * @param _loan The address of the loan.\\n     * @param _status The new status of the loan.\\n     */\\n    function changeLoanStatus(address _loan, bool _status) public onlyOwner {\\n        require(loans[_loan] != _status, 'Cannot set the same status');\\n\\n        if (_status) {\\n            uint256 maturity = ILoan(_loan).getMaturity();\\n            bool isInsideCurrentCycle = getKonaPools().isDateInsideCurrentCycle(maturity);\\n            require(isInsideCurrentCycle, 'Maturity outside current cycle');\\n        } else {\\n            require(!ILoan(_loan).getIsFunded(), 'Loan already funded');\\n        }\\n\\n        loans[_loan] = _status;\\n\\n        emit LoanStatusChanged(_loan, _status);\\n    }\\n\\n    /**\\n     * @dev Checks if a given date is inside the current cycle.\\n     * @param _date The date to check.\\n     * @return A boolean value indicating whether the date is inside the current cycle.\\n     */\\n    function isDateInsideCurrentCycle(uint256 _date) public view returns (bool) {\\n        return getKonaPools().isDateInsideCurrentCycle(_date);\\n    }\\n\\n    /**\\n     * @dev Returns the current cycle number & status.\\n     * @return The current cycle number & status.\\n     */\\n    function getCurrentCycleStatus() public view returns (uint256, IKonaPools.Status, uint256) {\\n        (uint256 currentCycle, uint startedOn, IKonaPools.Status status) = getKonaPools().getCycleStatus();\\n        return (currentCycle, status, startedOn);\\n    }\\n\\n    // /**\\n    //  * @dev Checks if the current period is the join or leave period.\\n    //  * @return A boolean value indicating whether the current period is the join or leave period.\\n    //  */\\n    // function isJoinOrLeavePeriod() internal view returns (bool) {\\n    //     address konaPools = IKonaGlobals(konaGlobals).konaPools();\\n    //     (, , IKonaPools.Status status) = IKonaPools(konaPools).getCycleStatus();\\n    //     return status == IKonaPools.Status.JOIN_LEAVE;\\n    // }\\n\\n    /**\\n     * @dev Adds funds to the pool after distribution.\\n     * @param _cycleNumber The cycle number.\\n     * @param _oracle The address of the oracle.\\n     * @param _total The total amount of funds to be added.\\n     */\\n    function addFundsAfterDistribution(uint256 _cycleNumber, address _oracle, uint256 _total) external {\\n        require(msg.sender == address(getKonaPools()), 'Only callable by KonaPools');\\n\\n        totalCapitalSupplyPerCycle[_cycleNumber] += _total;\\n\\n        emit FundsAddedAfterDistribution(_cycleNumber, _oracle, _total);\\n    }\\n\\n    function sendStandByBackToOracle(uint256 _cycleNumber, address _oracle, uint256 _total) external {\\n        require(msg.sender == address(getKonaPools()), 'Only callable by KonaPools');\\n\\n        brzToken.transfer(_oracle, _total);\\n\\n        emit StandByCapitalReturnedAfterDistribution(_cycleNumber, _oracle, _total);\\n    }\\n\\n    /**\\n     * @dev Calculates the costs of capital for an oracle in the current cycle.\\n     * @param _oracle The address of the oracle.\\n     */\\n    function calculateCostsOfCapital(address _oracle) internal {\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n        //Once the cycle started, we can't set it again\\n\\n        (uint256 referenceRate, uint256 s, uint256 c) = getCostOfCapitalParams(_oracle, currentCycle);\\n        uint256 cycleDays = getKonaPools().getCycleDays();\\n        uint256 calculatedCost = KonaMath.calculateCostOfCapital(referenceRate, s, c, cycleDays);\\n\\n        costsOfCapital[currentCycle][_oracle] = calculatedCost;\\n\\n        emit OracleCostOfCapitalSet(_oracle, currentCycle, calculatedCost);\\n    }\\n\\n    /**\\n     * @dev Retrieves the parameters for calculating the cost of capital for an oracle in a specific cycle.\\n     * @param _oracle The address of the oracle.\\n     * @param _cycle The cycle number.\\n     * @return The reference rate, staked percentage, and standby capital percentage.\\n     */\\n    function getCostOfCapitalParams(address _oracle, uint256 _cycle) internal view returns (uint256, uint256, uint256) {\\n        CapitalAssigned memory capitalAssigned = capitalsAssigned[_cycle][_oracle];\\n        uint256 totalAssigned = capitalAssigned.confirmed\\n            ? capitalAssigned.totalAccepted\\n            : capitalAssigned.totalOriginal;\\n        uint256 referenceRate = IKonaGlobals(konaGlobals).referenceRate();\\n        address staking = IKonaGlobals(konaGlobals).konaStaking();\\n        uint256 totalStaked = IKonaStaking(staking).getTotalStaked();\\n        uint256 totalTokens = konaToken.totalSupply();\\n        uint256 s = (totalStaked * 100) / totalTokens;\\n        uint256 c = (standByCapitals[_cycle][_oracle] * 100) / totalAssigned;\\n        return (referenceRate, s, c);\\n    }\\n\\n    /**\\n     * @dev Assigns capital to oracles after the voting period.\\n     * @param _oracles The array of oracle addresses.\\n     */\\n    function assignCapitalAfterVoting(address[] calldata _oracles) public {\\n        // Callable by everyone as we have security checks in place (skipping oracles already assigned)\\n        (uint currentCycle, IKonaPools.Status status, ) = getCurrentCycleStatus();\\n        require(status == IKonaPools.Status.ASSIGN_CAPITAL, 'needs to happen in assignment');\\n        IKonaStaking staking = IKonaStaking(IKonaGlobals(konaGlobals).konaStaking());\\n        uint totalVotesPool = staking.totalVotedPoolPerCycle(currentCycle, address(this));\\n        for (uint i = 0; i < _oracles.length; i++) {\\n            if (oracles.search(_oracles[i])) {\\n                //Skipping if already assined\\n                if (capitalsAssigned[currentCycle][_oracles[i]].totalOriginal == 0) {\\n                    uint totalOracleVotes = staking.totalVotedPoolOraclePerCycle(\\n                        currentCycle,\\n                        address(this),\\n                        _oracles[i]\\n                    );\\n                    // Skipping if less than 0.1% of votes\\n                    if (totalVotesPool / 1000 < totalOracleVotes) {\\n                        uint256 weight = (1e18 * totalOracleVotes) / totalVotesPool;\\n                        uint256 totalOriginal = (totalCapitalSupplyPerCycle[currentCycle] * weight) / 1e18;\\n\\n                        capitalsAssigned[currentCycle][_oracles[i]].totalOriginal = totalOriginal;\\n                        capitalsAssigned[currentCycle][_oracles[i]].isManuallyAssigned = false;\\n\\n                        emit OracleCapitalAssignedSet(_oracles[i], currentCycle, totalOriginal);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Assigns capital to oracles after the voting period (Increase of the already accepted Capital).\\n     * @param _oracles The array of oracle addresses.\\n     */\\n    function manuallyAssignCapital(address[] calldata _oracles, uint[] calldata values) public onlyOwner {\\n        (uint currentCycle, IKonaPools.Status status, uint startedOn) = getCurrentCycleStatus();\\n        require(\\n            status == IKonaPools.Status.CYCLE && startedOn + 2 * 86400 > block.timestamp,\\n            'needs to happen after assignment'\\n        );\\n\\n        uint virtualTotalAssigned = totalCapitalsAssignedManual[currentCycle];\\n        for (uint i = 0; i < _oracles.length; i++) {\\n            virtualTotalAssigned += values[i];\\n            require(values[i] > 0, 'Invalid Value, check your Values');\\n            require(\\n                totalCapitalSupplyPerCycle[currentCycle] + totalCapitalsAcceptedManual[currentCycle] >=\\n                    virtualTotalAssigned,\\n                \\\"Can't assign more than available\\\"\\n            );\\n            //If not assignd manually use the totalAccepted as base to avoid using funds that are counted as freed up\\n            uint totalOriginal = capitalsAssigned[currentCycle][_oracles[i]].isManuallyAssigned\\n                ? capitalsAssigned[currentCycle][_oracles[i]].totalOriginal\\n                : capitalsAssigned[currentCycle][_oracles[i]].totalAccepted;\\n            totalOriginal += values[i];\\n            capitalsAssigned[currentCycle][_oracles[i]].totalOriginal = totalOriginal;\\n            capitalsAssigned[currentCycle][_oracles[i]].isManuallyAssigned = true;\\n\\n            emit OracleCapitalAssignedSet(_oracles[i], currentCycle, totalOriginal);\\n        }\\n        totalCapitalsAssignedManual[currentCycle] += virtualTotalAssigned;\\n    }\\n\\n    //ORACLES\\n\\n    /**\\n     * @dev Commits standby capital for an oracle in the current cycle.\\n     * @param _total The total amount of standby capital to commit.\\n     */\\n    function commitStandByCapital(uint256 _total) external onlyOracle {\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n        standByCapitals[currentCycle][msg.sender] += _total;\\n\\n        emit OracleStandByCapitalCommitted(msg.sender, currentCycle, _total);\\n    }\\n\\n    /**\\n     * @dev Accepts the assigned capital for an oracle in the current cycle.\\n     * @param _totalAccepted The total amount of accepted capital.\\n     */\\n    function acceptCapitalAssigned(uint256 _totalAccepted) external onlyOracle {\\n        (uint currentCycle, IKonaPools.Status status, ) = getCurrentCycleStatus();\\n        require(status == IKonaPools.Status.CYCLE || status == IKonaPools.Status.ASSIGN_CAPITAL, \\\"Action not available in this state\\\");\\n        require(\\n            _totalAccepted <= capitalsAssigned[currentCycle][msg.sender].totalOriginal,\\n            'You cannot accept more than what you were assigned'\\n        );\\n        if (status == IKonaPools.Status.CYCLE) {\\n            require(capitalsAssigned[currentCycle][msg.sender].isManuallyAssigned, 'Capital not manually assigned.');\\n            totalCapitalsAcceptedManual[currentCycle] += _totalAccepted;\\n        }\\n        uint lastTotalAccepted = capitalsAssigned[currentCycle][msg.sender].totalAccepted;\\n        totalCapitalsAccepted[currentCycle] += (_totalAccepted - lastTotalAccepted);\\n        capitalsAssigned[currentCycle][msg.sender].confirmed = true;\\n        capitalsAssigned[currentCycle][msg.sender].fundsAvailableToSpend = _totalAccepted;\\n\\n        totalCapitalSupplyPerCycle[currentCycle] =\\n            totalCapitalSupplyPerCycle[currentCycle] +\\n            lastTotalAccepted -\\n            _totalAccepted;\\n        capitalsAssigned[currentCycle][msg.sender].totalAccepted = _totalAccepted;\\n\\n        emit OracleCapitalAssignedAccepted(msg.sender, currentCycle, _totalAccepted);\\n        calculateCostsOfCapital(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Requests funding for a loan from an oracle.\\n     * @param _loan The address of the loan.\\n     */\\n    function requestFunding(address _loan) external onlyOracle returns (bool) {\\n        require(!isEmergencyMode(), 'In Emergency Mode');\\n        require(loans[_loan], 'Loan not approved');\\n        require(!ILoan(_loan).getIsFunded(), 'Loan already funded');\\n\\n        (uint currentCycle,IKonaPools.Status status , ) = getCurrentCycleStatus();\\n        uint loanCycle = ILoan(_loan).getCycle();\\n        uint maturity = ILoan(_loan).getCycle();\\n        require(loanCycle == currentCycle && isDateInsideCurrentCycle(maturity), \\\"maturiy and cycle should be inside the current cycle\\\");\\n        require(IKonaPools.Status.CYCLE == status, \\\"Needs to be inside the cycle!\\\");\\n        uint256 loanAmount = ILoan(_loan).getAmount();\\n        uint256 fundsAvailableToSpend = capitalsAssigned[currentCycle][msg.sender].fundsAvailableToSpend;\\n\\n        require(fundsAvailableToSpend >= loanAmount, 'Insufficent funds');\\n        capitalsAssigned[currentCycle][msg.sender].fundsAvailableToSpend -= loanAmount;\\n\\n        address borrower = ILoan(_loan).getBorrower();\\n        brzToken.transfer(borrower, loanAmount);\\n\\n        emit LoanFunded(currentCycle, msg.sender, _loan, loanAmount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Repays a loan.\\n     * @param _loan The address of the loan.\\n     * @param _total The total amount to repay.\\n     */\\n    function repay(address _loan, uint256 _total) external onlyOracle {\\n        brzToken.transferFrom(_loan, address(this), _total);\\n\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n        uint cycle = ILoan(_loan).getCycle();\\n        if (cycle <= currentCycle) {\\n            lateRecovered[cycle] += _total;\\n        } else {\\n            capitalsAssigned[currentCycle][msg.sender].fundsAvailableToSpend += _total;\\n        }\\n        emit LoanRepaid(_loan, msg.sender, cycle, _total);\\n    }\\n\\n    /**\\n     * @dev Allows a user to claim their share of recovered funds in a cycle\\n     * @param cycle The cycle to claim funds for\\n     */\\n    function claimLateRepayment(uint cycle) external {\\n        // Check there are funds to claim this cycle\\n        uint recovered = lateRecovered[cycle];\\n        require(recovered > 0, 'Nothing recovered this cycle');\\n\\n        // Verify user had LP this cycle\\n        uint userLP = _getUserLpInCycle(cycle, msg.sender);\\n        require(userLP > 0, 'No LP in this cycle');\\n\\n        // Get amount already claimed by user\\n        uint claimed = recoveryClaimedUser[cycle][msg.sender];\\n\\n        // Calculate user's share of recovered amount\\n        uint shareOfUser = (userLP * ACCURACY_BASE) / totalLPTokenSupplyPerCycle[cycle];\\n        uint claimable = (recovered * shareOfUser) / ACCURACY_BASE;\\n\\n        // Check there is still funds left to claim\\n        require(claimable > claimed, 'You already claimed your share');\\n\\n        // Update claimed amount\\n        recoveryClaimedUser[cycle][msg.sender] = claimable;\\n\\n        // Transfer funds to user\\n        require(brzToken.transfer(msg.sender, claimable - claimed), 'Transfer failed');\\n    }\\n\\n    /**\\n     * @dev Gets a user's BRZ balance including staking rewards\\n     * @param user The user's address\\n     * @return The BRZ balance + rewards\\n     */\\n    function getBRZBalanceWithRewards(address user) external view returns (uint) {\\n        // Get user's current LP token balance\\n        uint balance = balanceOf(user);\\n\\n        // Get current cycle\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n        // Convert LP tokens to BRZ amount based on current values\\n        balance = getBRZForShares(balance, currentCycle);\\n\\n        // Add LP rewards (excess)\\n        balance += IKonaStaking(IKonaGlobals(konaGlobals).konaStaking()).getOutstandingLpReward(user, address(this));\\n\\n        // Return total BRZ balance + rewards\\n        return balance;\\n    }\\n\\n    /**\\n     * @dev Gets the user's requesting LP token balance for a cycle\\n     * @param cycle The cycle number\\n     * @return The user's LP token balance\\n     */\\n    function getMyLpInCycle(uint cycle) public view returns (uint) {\\n        _getUserLpInCycle(cycle, msg.sender);\\n    }\\n\\n    /**\\n     * @dev Gets a user's LP token balance for a cycle\\n     * @param cycle The cycle number\\n     * @param user The user requested\\n     * @return The user's LP token balance\\n     */\\n    function getUserLpInCycle(uint cycle, address user) external view returns (uint) {\\n        _getUserLpInCycle(cycle, user);\\n    }\\n\\n    /**\\n     * @dev Gets a user's LP token balance for a cycle\\n     * @param cycle The cycle number\\n     * @param user The user requested\\n     * @return The user's LP token balance\\n     */\\n    function _getUserLpInCycle(uint cycle, address user) internal view returns (uint) {\\n        // Get array of cycles where user balance changed\\n        uint[] memory localRelevantChanges = relevantChanges[user];\\n\\n        // Iterate cycles to find match\\n        for (uint i = 0; i < localRelevantChanges.length; i++) {\\n            // If change found in requested cycle, return balance\\n            if (localRelevantChanges[i] == cycle) {\\n                return lpTokenBalancePerCycle[cycle][user];\\n            }\\n\\n            // If greater than target, return prior balance or if it is the first time a balance was changed return 0\\n            if (localRelevantChanges[i] > cycle) {\\n                return i == 0 ? 0 : lpTokenBalancePerCycle[localRelevantChanges[i - 1]][user];\\n            }\\n        }\\n\\n        // Cycle not found, so balance is zero\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev Called by the contract on cycle rollover to handle queued withdrawals/deposits\\n     * @param lastCycle - the cycle that just ended\\n     */\\n    function onCycleRollOver(uint lastCycle) external onlyKonaPools {\\n        //restrict to only rolling over Contract\\n\\n        // Get total capital supply from previous cycle\\n        uint capitalLastCycle = totalCapitalSupplyPerCycle[lastCycle];\\n\\n        // Get total lp supply from previous cycle\\n        uint lpLastCycle = totalSupply();\\n\\n        // Set total lp supply for previous cycle\\n        totalLPTokenSupplyPerCycle[lastCycle] = lpLastCycle;\\n\\n        // Get total LP tokens queued for removal this cycle\\n        uint lpToRemove = lpToRemoveThisCycle[lastCycle + 1];\\n\\n        // Get total capital queued for adding this cycle\\n        uint capitalToAdd = capitalToAddCycle[lastCycle + 1];\\n\\n        // Calculate LP tokens to mint based on capital to add\\n        uint lpToMint = capitalToAdd == 0 ? 0 : getShares(capitalToAdd, lastCycle);\\n\\n        uint capitalToRemove = lpToRemove == 0 ? 0 : getBRZForShares(lpToRemove, lastCycle);\\n        // Update total capital supply for new cycle\\n        // Remove capital for LP tokens removed + add queued capital\\n        totalCapitalSupplyPerCycle[lastCycle + 1] = capitalLastCycle + capitalToAdd - capitalToRemove;\\n        totalLPTokenSupplyPerCycle[lastCycle + 1] = lpLastCycle + lpToMint - lpToRemove;\\n        // If more LP tokens removed than minted, burn the difference\\n        if (lpToRemove > lpToMint) {\\n            _burn(address(this), lpToRemove - lpToMint);\\n        }\\n        // If more LP tokens minted than removed, mint the difference\\n        else {\\n            _mint(address(this), lpToMint - lpToRemove);\\n        }\\n    }\\n\\n    /**\\n     * @dev Creates a reward deposit for a beneficiary.\\n     * @param _beneficiary The address to receive the reward deposit.\\n     * @param _total The total amount of the reward deposit.\\n     */\\n    function createRewardDeposit(address _beneficiary, uint256 _total) external onlyKonaPools {\\n        _createRewardDeposit(_beneficiary, _total);\\n    }\\n\\n    function _createRewardDeposit(address _beneficiary, uint256 _total) internal {\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n        uint shares = getShares(_total, currentCycle);\\n        _mint(_beneficiary, shares);\\n        if (_beneficiary != address(this)) {\\n            relevantChanges[_beneficiary].push(currentCycle);\\n        }\\n        totalCapitalSupplyPerCycle[currentCycle] += _total;\\n        totalLPTokenSupplyPerCycle[currentCycle] += shares;\\n\\n        emit NewRewardDeposit(_beneficiary, currentCycle, _total);\\n    }\\n\\n    function claimRewardDeposit(address _beneficiary, uint256 _total, uint _cycle) external {\\n        require(msg.sender == IKonaGlobals(konaGlobals).konaStaking(), 'Can only be called via KonaStaking');\\n        uint shares = getShares(_total, _cycle);\\n        require(this.transfer(_beneficiary, shares));\\n        relevantChanges[_beneficiary].push(_cycle);\\n\\n        emit ClaimRewardDeposit(msg.sender, _cycle, _total);\\n    }\\n\\n    //GET\\n\\n    /**\\n     * @dev Calculates the number of shares for a given BRZ amount.\\n     * @param _brzAmount The BRZ amount.\\n     * @return The number of shares.\\n     */\\n    function getShares(uint _brzAmount, uint cycleNumber) public view returns (uint) {\\n        if (_brzAmount == 0) return 0;\\n        if (totalLPTokenSupplyPerCycle[cycleNumber] == 0) return _brzAmount;\\n        return (_brzAmount * totalLPTokenSupplyPerCycle[cycleNumber]) / totalCapitalSupplyPerCycle[cycleNumber];\\n    }\\n\\n    /**\\n     * @dev Calculates the BRZ amount for a given number of shares.\\n     * @param shares The number of shares.\\n     * @return The BRZ amount.\\n     */\\n    function getBRZForShares(uint shares, uint cycleNumber) public view returns (uint) {\\n        if (shares == 0) return 0;\\n        if (totalLPTokenSupplyPerCycle[cycleNumber] == 0) return 0;\\n        return (shares * totalCapitalSupplyPerCycle[cycleNumber]) / totalLPTokenSupplyPerCycle[cycleNumber];\\n    }\\n\\n    /**\\n     * @dev Calculates the BRZ amount for the shares owned by the calling address.\\n     * @return The BRZ amount.\\n     */\\n    function getBRZForMyShares() public view returns (uint) {\\n        uint256 shares = balanceOf(msg.sender);\\n        (uint currentCycle, , ) = getCurrentCycleStatus();\\n        return (shares * totalCapitalSupplyPerCycle[currentCycle]) / totalSupply();\\n    }\\n\\n    /**\\n     * @dev Returns the funds available to spend for an oracle in a specific cycle.\\n     * @param _oracle The address of the oracle.\\n     * @param _cycleNumber The cycle number.\\n     * @return The funds available to spend.\\n     */\\n    function getFundsAvailableToSpend(address _oracle, uint256 _cycleNumber) external view returns (uint256) {\\n        return capitalsAssigned[_cycleNumber][_oracle].fundsAvailableToSpend;\\n    }\\n\\n    /**\\n     * @dev Returns the committed standby capital for an oracle in a specific cycle.\\n     * @param _oracle The address of the oracle.\\n     * @param _cycleNumber The cycle number.\\n     * @return The committed standby capital.\\n     */\\n    function getCommittedStandByCapital(address _oracle, uint256 _cycleNumber) external view returns (uint256) {\\n        return standByCapitals[_cycleNumber][_oracle];\\n    }\\n\\n    /**\\n     * @dev Return the total original capital assigned to the oracle for the given cycle number.\\n     * @param _oracle The address of the oracle.\\n     * @param _cycleNumber The cycle number.\\n     * @return The total original capital assigned.\\n     */\\n    function getOriginalCapitalAssigned(address _oracle, uint256 _cycleNumber) external view returns (uint256) {\\n        return capitalsAssigned[_cycleNumber][_oracle].totalOriginal;\\n    }\\n\\n    /**\\n     * @dev Return the total accepted capital assigned to the oracle for the given cycle number.\\n     * @param _oracle The address of the oracle.\\n     * @param _cycleNumber The cycle number.\\n     * @return The total accepted capital assigned.\\n     */\\n    function getAcceptedCapitalAssigned(address _oracle, uint256 _cycleNumber) external view returns (uint256) {\\n        return capitalsAssigned[_cycleNumber][_oracle].totalAccepted;\\n    }\\n\\n    /**\\n     * @dev Return the cost of capital for the oracle in the given cycle number.\\n     * @param _oracle The address of the oracle.\\n     * @param _cycleNumber The cycle number.\\n     * @return The cost of capital.\\n     */\\n    function getCostOfCapital(address _oracle, uint256 _cycleNumber) external view returns (uint256) {\\n        return costsOfCapital[_cycleNumber][_oracle];\\n    }\\n\\n    /**\\n     * @dev Get the list of oracles.\\n     * @return An array of oracle addresses.\\n     */\\n    function getOracles() external view returns (address[] memory) {\\n        return oracles;\\n    }\\n\\n    /**\\n     * @dev Check if there are any oracles.\\n     * @return A boolean indicating if there are oracles.\\n     */\\n    function hasOracles() external view returns (bool) {\\n        return oracles.length > 0;\\n    }\\n\\n    /**\\n     * @dev Check if at least one oracle in the pool has accepted capital in the given cycle number.\\n     * @param _cycleNumber The cycle number.\\n     * @return A boolean indicating if all oracles have been assigned capital.\\n     */\\n    function atLeastOneOraclesHasCapital(uint256 _cycleNumber) external view returns (bool) {\\n        for (uint i = 0; i < oracles.length; i++) {\\n            if(capitalsAssigned[_cycleNumber][oracles[i]].totalOriginal != 0){ \\n                if (!capitalsAssigned[_cycleNumber][oracles[i]].confirmed) {\\n                    return true;\\n                }\\n            }\\n        }\\n    }\\n\\n    //INTERNAL OVERRIDE\\n    /**\\n     * @dev Hook that is called after any transfer of tokens\\n     * Updates user balances for the current cycle\\n     * @param from Address tokens are transferred from\\n     * @param to Address tokens are transferred to\\n     * @param amount Amount of tokens transferred\\n     */\\n    function _afterTokenTransfer(address from, address to, uint amount) internal override {\\n        // Get current cycle\\n        if (from != address(0) && to != address(0) && from != address(this) && to != address(this)) {\\n            (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n            // Get last cycle each user had a relevant change\\n            uint lastFrom = getLastChangedCycle(from);\\n            uint lastTo = getLastChangedCycle(to);\\n\\n            // Update balances based on last recorded balances\\n\\n            lpTokenBalancePerCycle[currentCycle][from] = lpTokenBalancePerCycle[lastFrom][from] - amount;\\n            lpTokenBalancePerCycle[currentCycle][to] = lpTokenBalancePerCycle[lastTo][to] + amount;\\n\\n            // Record cycle as changed for each user if different than last\\n            if (currentCycle != lastFrom) {\\n                relevantChanges[from].push(currentCycle);\\n            }\\n            if (currentCycle != lastTo) {\\n                relevantChanges[to].push(currentCycle);\\n            }\\n\\n            // Call parent hook\\n            super._afterTokenTransfer(from, to, amount);\\n        }\\n    }\\n\\n    // Get the last cycle a user had a relevant change\\n    function getLastChangedCycle(address user) private view returns (uint) {\\n        if (relevantChanges[user].length == 0) {\\n            return 0;\\n        } else {\\n            return relevantChanges[user][relevantChanges[user].length - 1];\\n        }\\n    }\\n\\n    function setEmergencyWallet(address newWallet) external onlyEmergencyWallet {\\n        emergencyWallet = newWallet;\\n    }\\n\\n    /**\\n     * @dev Checks if emergency mode is active\\n     * @return True if emergency mode, false otherwise\\n     */\\n    function isEmergencyMode() public view returns (bool) {\\n        return getKonaPools().emergencyMode();\\n    }\\n\\n    /**\\n     * @dev Withdraws all BRZ to owner in emergency\\n     * Only callable by owner\\n     * Reverts if not in emergency mode\\n     */\\n    function emergencyWithdraw() external onlyEmergencyWallet {\\n        // Check in emergency mode\\n        require(isEmergencyMode(), 'Not in Emergency Mode');\\n\\n        require(emergencyWallet != address(0), 'Emergency Wallet not set');\\n\\n        // Withdraw all BRZ to owner\\n        require(brzToken.transfer(emergencyWallet, brzToken.balanceOf(address(this))), 'Transfer Failed');\\n    }\\n    /// @dev internal helper function to get the KonaPools (uses less bytecode like this)\\n    function getKonaPools() internal view returns(IKonaPools){\\n        return IKonaPools(IKonaGlobals(konaGlobals).konaPools());\\n    }\\n    // /**\\n    //  * @dev [TESTING ONLY] Allows spending funds available to an oracle.\\n    //  * @param _total The total amount of funds to spend.\\n    //  * @param _oracle The address of the oracle.\\n    //  */\\n    // function spend_TESTING_ONLY(uint256 _total, address _oracle) public {\\n    //     (uint currentCycle, , ) = getCurrentCycleStatus();\\n\\n    //     capitalsAssigned[currentCycle][_oracle].fundsAvailableToSpend -= _total;\\n    //     brzToken.transfer(msg.sender, _total);\\n    // }\\n\\n    // /**\\n    //  * @dev [TESTING ONLY] Repays funds to an oracle.\\n    //  * @param _total The total amount of funds to repay.\\n    //  * @param _oracle The address of the oracle.\\n    //  */\\n    // function repay_TESTING_ONLY(uint256 _total, address _oracle) public {\\n    //     brzToken.transferFrom(msg.sender, address(this), _total);\\n    //     (uint currentCycle, , ) = getCurrentCycleStatus();\\n    //     capitalsAssigned[currentCycle][_oracle].fundsAvailableToSpend += _total;\\n    // }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 100\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {\r\n      \"contracts/KonaMath.sol\": {\r\n        \"KonaMath\": \"0x4b9e899c78854d41aa59a7c08f942afbdbc6b4d4\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_poolName\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_konaGlobals\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"_brzToken\",\"type\":\"address\"},{\"internalType\":\"contract IKonaToken\",\"name\":\"_konaToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"brzTokens\",\"type\":\"uint256\"}],\"name\":\"CanceledDepositRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"}],\"name\":\"CanceledWithdrawRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"ClaimRewardDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"brzTokens\",\"type\":\"uint256\"}],\"name\":\"DirectDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"}],\"name\":\"DirectWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"brzTokens\",\"type\":\"uint256\"}],\"name\":\"FinalDepositRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"}],\"name\":\"FinalWithdrawRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"FundsAddedAfterDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loanAmount\",\"type\":\"uint256\"}],\"name\":\"LoanFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"loanCycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"LoanRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"loan\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"LoanStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"brzTokens\",\"type\":\"uint256\"}],\"name\":\"NewDepositRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"NewRewardDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidityProvider\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lpTokens\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAccepted\",\"type\":\"uint256\"}],\"name\":\"OracleCapitalAssignedAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"OracleCapitalAssignedSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"OracleCostOfCapitalSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"OracleStandByCapitalCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"OracleStatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oracle\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"StandByCapitalReturnedAfterDistribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_totalAccepted\",\"type\":\"uint256\"}],\"name\":\"acceptCapitalAssigned\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"addFundsAfterDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"}],\"name\":\"assignCapitalAfterVoting\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"atLeastOneOraclesHasCapital\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"brzRewardPerOracleRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"brzToken\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancelDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancelWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"capitalsAssigned\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"confirmed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isManuallyAssigned\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalAccepted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fundsAvailableToSpend\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"changeLoanStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"changeOracleStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"claimLateRepayment\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_cycle\",\"type\":\"uint256\"}],\"name\":\"claimRewardDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"commitStandByCapital\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"costsOfCapital\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_beneficiary\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"createRewardDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositBalancePerCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"directDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"directWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedCycle\",\"type\":\"uint256\"}],\"name\":\"finalizeDepositQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"requestedCycle\",\"type\":\"uint256\"}],\"name\":\"finalizeWithdrawQueue\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"getAcceptedCapitalAssigned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBRZBalanceWithRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBRZForMyShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"}],\"name\":\"getBRZForShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"getCommittedStandByCapital\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"getCostOfCapital\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentCycleStatus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum IKonaPools.Status\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"getFundsAvailableToSpend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"}],\"name\":\"getMyLpInCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOracles\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"}],\"name\":\"getOriginalCapitalAssigned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_brzAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"cycleNumber\",\"type\":\"uint256\"}],\"name\":\"getShares\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"cycle\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserLpInCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hasOracles\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"isDateInsideCurrentCycle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isEmergencyMode\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"konaGlobals\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"konaToken\",\"outputs\":[{\"internalType\":\"contract IKonaToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lateRecovered\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"loans\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_oracles\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"values\",\"type\":\"uint256[]\"}],\"name\":\"manuallyAssignCapital\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"lastCycle\",\"type\":\"uint256\"}],\"name\":\"onCycleRollOver\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"queueDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"queueWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"recoveryClaimedUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_loan\",\"type\":\"address\"}],\"name\":\"requestFunding\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_cycleNumber\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_oracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_total\",\"type\":\"uint256\"}],\"name\":\"sendStandByBackToOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"setEmergencyWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"standByCapitals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalCapitalSupplyPerCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalCapitalsAccepted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalCapitalsAcceptedManual\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalCapitalsAssignedManual\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalLPTokenSupplyPerCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawBalancePerCycle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Pool", "CompilerVersion": "v0.8.19+commit.7dd6d404", "OptimizationUsed": "1", "Runs": "100", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000800000000000000000000000002ba2ce1e169fe9a2602c3c381294b9e35989cf580000000000000000000000004ed141110f6eeeaba9a1df36d8c26f684d2475dc000000000000000000000000ddf6db363853508eea06bd78d3eb1acf85b3cdf100000000000000000000000000000000000000000000000000000000000000094b6f6e6120506f6f6c0000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}