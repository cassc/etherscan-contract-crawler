{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// File @openzeppelin/contracts/token/ERC20/IERC20.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Address.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\r\n\r\npragma solidity ^0.8.1;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            // Look for revert reason and bubble it up if present\r\n            if (returndata.length > 0) {\r\n                // The easiest way to bubble the revert reason is using memory via assembly\r\n\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    function safeTransfer(\r\n        IERC20 token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n    }\r\n\r\n    /**\r\n     * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n    function safeApprove(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        // safeApprove should only be called when setting an initial allowance,\r\n        // or when resetting it to zero. To increase and decrease it, use\r\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n        require(\r\n            (value == 0) || (token.allowance(address(this), spender) == 0),\r\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n        );\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n    }\r\n\r\n    function safeIncreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n    }\r\n\r\n    function safeDecreaseAllowance(\r\n        IERC20 token,\r\n        address spender,\r\n        uint256 value\r\n    ) internal {\r\n        unchecked {\r\n            uint256 oldAllowance = token.allowance(address(this), spender);\r\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n            uint256 newAllowance = oldAllowance - value;\r\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n        if (returndata.length > 0) {\r\n            // Return data is optional\r\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/IAccessControl.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev External interface of AccessControl declared to support ERC165 detection.\r\n */\r\ninterface IAccessControl {\r\n    /**\r\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\r\n     *\r\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\r\n     * {RoleAdminChanged} not being emitted signaling this.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is granted `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call, an admin role\r\n     * bearer except when using {AccessControl-_setupRole}.\r\n     */\r\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Emitted when `account` is revoked `role`.\r\n     *\r\n     * `sender` is the account that originated the contract call:\r\n     *   - if using `revokeRole`, it is the admin role bearer\r\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\r\n     */\r\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) external;\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) external;\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Context.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/Strings.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        if (value == 0) {\r\n            return \"0x00\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 length = 0;\r\n        while (temp != 0) {\r\n            length++;\r\n            temp >>= 8;\r\n        }\r\n        return toHexString(value, length);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/IERC165.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/utils/introspection/ERC165.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Implementation of the {IERC165} interface.\r\n *\r\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\r\n * for the additional interface id that will be supported. For example:\r\n *\r\n * ```solidity\r\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r\n * }\r\n * ```\r\n *\r\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\r\n */\r\nabstract contract ERC165 is IERC165 {\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IERC165).interfaceId;\r\n    }\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/AccessControl.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts (last updated v4.5.0) (access/AccessControl.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that allows children to implement role-based access\r\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\r\n * members except through off-chain means by accessing the contract event logs. Some\r\n * applications may benefit from on-chain enumerability, for those cases see\r\n * {AccessControlEnumerable}.\r\n *\r\n * Roles are referred to by their `bytes32` identifier. These should be exposed\r\n * in the external API and be unique. The best way to achieve this is by\r\n * using `public constant` hash digests:\r\n *\r\n * ```\r\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\r\n * ```\r\n *\r\n * Roles can be used to represent a set of permissions. To restrict access to a\r\n * function call, use {hasRole}:\r\n *\r\n * ```\r\n * function foo() public {\r\n *     require(hasRole(MY_ROLE, msg.sender));\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Roles can be granted and revoked dynamically via the {grantRole} and\r\n * {revokeRole} functions. Each role has an associated admin role, and only\r\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\r\n *\r\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\r\n * that only accounts with this role will be able to grant or revoke other\r\n * roles. More complex role relationships can be created by using\r\n * {_setRoleAdmin}.\r\n *\r\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\r\n * grant and revoke this role. Extra precautions should be taken to secure\r\n * accounts that have been granted it.\r\n */\r\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\r\n    struct RoleData {\r\n        mapping(address => bool) members;\r\n        bytes32 adminRole;\r\n    }\r\n\r\n    mapping(bytes32 => RoleData) private _roles;\r\n\r\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\r\n\r\n    /**\r\n     * @dev Modifier that checks that an account has a specific role. Reverts\r\n     * with a standardized message including the required role.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     *\r\n     * _Available since v4.1._\r\n     */\r\n    modifier onlyRole(bytes32 role) {\r\n        _checkRole(role, _msgSender());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC165-supportsInterface}.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\r\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns `true` if `account` has been granted `role`.\r\n     */\r\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\r\n        return _roles[role].members[account];\r\n    }\r\n\r\n    /**\r\n     * @dev Revert with a standard message if `account` is missing `role`.\r\n     *\r\n     * The format of the revert reason is given by the following regular expression:\r\n     *\r\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r\n     */\r\n    function _checkRole(bytes32 role, address account) internal view virtual {\r\n        if (!hasRole(role, account)) {\r\n            revert(\r\n                string(\r\n                    abi.encodePacked(\r\n                        \"AccessControl: account \",\r\n                        Strings.toHexString(uint160(account), 20),\r\n                        \" is missing role \",\r\n                        Strings.toHexString(uint256(role), 32)\r\n                    )\r\n                )\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\r\n     * {revokeRole}.\r\n     *\r\n     * To change a role's admin, use {_setRoleAdmin}.\r\n     */\r\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\r\n        return _roles[role].adminRole;\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have ``role``'s admin role.\r\n     */\r\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from the calling account.\r\n     *\r\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\r\n     * purpose is to provide a mechanism for accounts to lose their privileges\r\n     * if they are compromised (such as when a trusted device is misplaced).\r\n     *\r\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\r\n     * event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must be `account`.\r\n     */\r\n    function renounceRole(bytes32 role, address account) public virtual override {\r\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\r\n\r\n        _revokeRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\r\n     * event. Note that unlike {grantRole}, this function doesn't perform any\r\n     * checks on the calling account.\r\n     *\r\n     * [WARNING]\r\n     * ====\r\n     * This function should only be called from the constructor when setting\r\n     * up the initial roles for the system.\r\n     *\r\n     * Using this function in any other way is effectively circumventing the admin\r\n     * system imposed by {AccessControl}.\r\n     * ====\r\n     *\r\n     * NOTE: This function is deprecated in favor of {_grantRole}.\r\n     */\r\n    function _setupRole(bytes32 role, address account) internal virtual {\r\n        _grantRole(role, account);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `adminRole` as ``role``'s admin role.\r\n     *\r\n     * Emits a {RoleAdminChanged} event.\r\n     */\r\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\r\n        bytes32 previousAdminRole = getRoleAdmin(role);\r\n        _roles[role].adminRole = adminRole;\r\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\r\n    }\r\n\r\n    /**\r\n     * @dev Grants `role` to `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     */\r\n    function _grantRole(bytes32 role, address account) internal virtual {\r\n        if (!hasRole(role, account)) {\r\n            _roles[role].members[account] = true;\r\n            emit RoleGranted(role, account, _msgSender());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Revokes `role` from `account`.\r\n     *\r\n     * Internal function without access restriction.\r\n     */\r\n    function _revokeRole(bytes32 role, address account) internal virtual {\r\n        if (hasRole(role, account)) {\r\n            _roles[role].members[account] = false;\r\n            emit RoleRevoked(role, account, _msgSender());\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Strategy/interface/IAaveLendingPool.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\n/**\r\n * @author Polytrade\r\n * @title Interface AAVE\r\n * @notice It will interact will Staking Strategy Contract of Lender Pool V2\r\n */\r\ninterface IAaveLendingPool {\r\n    //AAVE V2 is used\r\n\r\n    /**\r\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to deposit\r\n     * @param amount The amount to be deposited\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to Address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint amount,\r\n        address to\r\n    ) external returns (uint);\r\n}\r\n\r\n\r\n// File contracts/Token/interface/IToken.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\n/**\r\n * @author Polytrade\r\n * @title Token\r\n */\r\ninterface IToken is IERC20 {\r\n    /**\r\n     * @notice mints ERC20 token\r\n     * @dev creates `amount` tokens and assigns them to `to`, increasing the total supply.\r\n     * @param to, receiver address of the ERC20 address\r\n     * @param amount, amount of ERC20 token minted\r\n     *\r\n     * Emits a {Transfer} event with `from` set to the zero address.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function mint(address to, uint amount) external;\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\r\n     * allowance.\r\n     *\r\n     * See {ERC20-_burn} and {ERC20-allowance}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the caller must have allowance for ``accounts``'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function burnFrom(address account, uint amount) external;\r\n}\r\n\r\n\r\n// File contracts/Strategy/interface/IStrategy.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\ninterface IStrategy {\r\n    /**\r\n     * @notice Emitted when funds are deposited\r\n     * @param amount, total amount deposited\r\n     */\r\n    event Deposit(uint amount);\r\n\r\n    /**\r\n     * @notice Emitted when funds are withdrawn from lender pool\r\n     * @param amount, total amount withdrawn\r\n     */\r\n    event Withdraw(uint amount);\r\n\r\n    /**\r\n     * @notice transfer funds to aave lending pool\r\n     * @dev accepts token from msg.sender and transfers to aave lending pool\r\n     * @param amount, total amount accepted from user and transferred to aave\r\n     */\r\n    function deposit(uint amount) external;\r\n\r\n    /**\r\n     * @notice withdraw funds from aave and send to lending pool\r\n     * @dev can be called by only lender pool\r\n     * @param amount, total amount accepted from user and transferred to aave\r\n     */\r\n    function withdraw(uint amount) external;\r\n\r\n    /**\r\n     * @notice get aStable balance of staking strategy smart contract\r\n     * @return total amount of aStable token in this contract\r\n     */\r\n    function getBalance() external view returns (uint);\r\n}\r\n\r\n\r\n// File contracts/Strategy/Strategy.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author Polytrade\r\n * @title Strategy\r\n */\r\ncontract Strategy is IStrategy, AccessControl {\r\n    using SafeERC20 for IToken;\r\n\r\n    IToken public stable;\r\n    IToken public aStable;\r\n\r\n    IAaveLendingPool public immutable aave;\r\n\r\n    bytes32 public constant LENDER_POOL = keccak256(\"LENDER_POOL\");\r\n\r\n    constructor(\r\n        address _aave,\r\n        address _stable,\r\n        address _aStable\r\n    ) {\r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n        stable = IToken(_stable);\r\n        aStable = IToken(_aStable);\r\n        aave = IAaveLendingPool(_aave);\r\n    }\r\n\r\n    /**\r\n     * @notice transfer funds to aave lending pool\r\n     * @dev accepts token from msg.sender and transfers to aave lending pool\r\n     * @param amount, total amount accepted from user and transferred to aave\r\n     */\r\n    function deposit(uint amount) external {\r\n        stable.safeTransferFrom(msg.sender, address(this), amount);\r\n        stable.safeApprove(address(aave), amount);\r\n        aave.deposit(address(stable), amount, address(this), 0);\r\n        emit Deposit(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice withdraw funds from aave and send to lending pool\r\n     * @dev can be called by only lender pool\r\n     * @param amount, total amount accepted from user and transferred to aave\r\n     */\r\n    function withdraw(uint amount) external onlyRole(LENDER_POOL) {\r\n        aave.withdraw(address(stable), amount, msg.sender);\r\n        emit Withdraw(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice get aStable balance of staking strategy smart contract\r\n     * @return total amount of aStable token in this contract\r\n     */\r\n    function getBalance() external view returns (uint) {\r\n        return aStable.balanceOf(address(this));\r\n    }\r\n}\r\n\r\n\r\n// File contracts/LenderPool/interface/ILenderPool.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\ninterface ILenderPool {\r\n    struct Lender {\r\n        uint deposit;\r\n        mapping(address => bool) isRegistered;\r\n    }\r\n\r\n    /**\r\n     * @notice Emits when new fund is added to the Lender Pool\r\n     * @dev Emitted when funds are deposited by the `lender`.\r\n     * @param lender, address of the lender\r\n     * @param amount, stable token deposited by the lender\r\n     */\r\n    event Deposit(address indexed lender, uint amount);\r\n\r\n    /**\r\n     * @notice Emits when fund is withdrawn by the lender\r\n     * @dev Emitted when tStable token are withdrawn by the `lender`.\r\n     * @param lender, address of the lender\r\n     * @param amount, tStable token withdrawn by the lender\r\n     */\r\n    event Withdraw(address indexed lender, uint amount);\r\n\r\n    /**\r\n     * @notice Emitted when staking treasury is switched\r\n     * @dev Emitted when switchTreasury function is called by owner\r\n     * @param oldTreasury, address of the old staking treasury\r\n     * @param newTreasury, address of the new staking treasury\r\n     */\r\n    event TreasurySwitched(address oldTreasury, address newTreasury);\r\n\r\n    /**\r\n     * @notice Emits when new DepositLimit is set\r\n     * @dev Emitted when new DepositLimit is set by the owner\r\n     * @param oldVerification, old verification Address\r\n     * @param newVerification, new verification Address\r\n     */\r\n    event VerificationSwitched(\r\n        address oldVerification,\r\n        address newVerification\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when staking strategy is switched\r\n     * @dev Emitted when switchStrategy function is called by owner\r\n     * @param oldStrategy, address of the old staking strategy\r\n     * @param newStrategy, address of the new staking strategy\r\n     */\r\n    event StrategySwitched(address oldStrategy, address newStrategy);\r\n\r\n    /**\r\n     * @notice Emitted when `RewardManager` is switched\r\n     * @dev Emitted when `RewardManager` function is called by owner\r\n     * @param oldRewardManager, address of the old RewardManager\r\n     * @param newRewardManager, address of the old RewardManager\r\n     */\r\n    event RewardManagerSwitched(\r\n        address oldRewardManager,\r\n        address newRewardManager\r\n    );\r\n\r\n    /**\r\n     * @notice `deposit` is used by lenders to deposit stable token to smart contract.\r\n     * @dev It transfers the approved stable token from msg.sender to lender pool.\r\n     * @param amount, The number of stable token to be deposited.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `amount` should be greater than zero.\r\n     * - `amount` must be approved from the stable token contract for the LenderPool.\r\n     * - `amount` should be less than validation limit or KYC needs to be completed.\r\n     *\r\n     * Emits {Deposit} event\r\n     */\r\n    function deposit(uint amount) external;\r\n\r\n    /**\r\n     * @notice `withdrawAllDeposit` send lender tStable equivalent to stable deposited.\r\n     * @dev It mints tStable and sends to lender.\r\n     * @dev It sets the amount deposited by lender to zero.\r\n     *\r\n     * Emits {Withdraw} event\r\n     */\r\n    function withdrawAllDeposit() external;\r\n\r\n    /**\r\n     * @notice `withdrawDeposit` send lender tStable equivalent to stable requested.\r\n     * @dev It mints tStable and sends to lender.\r\n     * @dev It decreases the amount deposited by lender.\r\n     * @param amount, Total token requested by lender.\r\n     *\r\n     * Requirements:\r\n     * - `amount` should be greater than 0.\r\n     * - `amount` should be not greater than deposited.\r\n     *\r\n     * Emits {Withdraw} event\r\n     */\r\n    function withdrawDeposit(uint amount) external;\r\n\r\n    /**\r\n     * @notice `redeemAll` call transfers all reward and deposited amount in stable token.\r\n     * @dev It converts the tStable to stable using `RedeemPool`.\r\n     * @dev It calls `claimRewardsFor` from `RewardManager`.\r\n     *\r\n     * Requirements :\r\n     * - `RedeemPool` should have stable tokens more than lender deposited.\r\n     *\r\n     */\r\n    function redeemAll() external;\r\n\r\n    /**\r\n     * @notice `switchRewardManager` is used to switch reward manager.\r\n     * @dev It pauses reward for previous `RewardManager` and initializes new `RewardManager` .\r\n     * @dev It can be called by only owner of LenderPool.\r\n     * @dev Changed `RewardManager` contract must complies with `IRewardManager`.\r\n     * @param newRewardManager, Address of the new `RewardManager`.\r\n     *\r\n     * Emits {RewardManagerSwitched} event\r\n     */\r\n    function switchRewardManager(address newRewardManager) external;\r\n\r\n    /**\r\n     * @notice `switchVerification` updates the Verification contract address.\r\n     * @dev Changed verification Contract must complies with `IVerification`\r\n     * @param newVerification, address of the new Verification contract\r\n     *\r\n     * Emits {VerificationContractUpdated} event\r\n     */\r\n    function switchVerification(address newVerification) external;\r\n\r\n    /**\r\n     * @notice `switchStrategy` is used for switching the strategy.\r\n     * @dev It moves all the funds from the old strategy to the new strategy.\r\n     * @dev It can be called by only owner of LenderPool.\r\n     * @dev Changed strategy contract must complies with `IStrategy`.\r\n     * @param newStrategy, address of the new staking strategy.\r\n     *\r\n     * Emits {StrategySwitched} event\r\n     */\r\n    function switchStrategy(address newStrategy) external;\r\n\r\n    /**\r\n     * @notice `claimReward` transfer all the `token` reward to `msg.sender`\r\n     * @dev It loops through all the `RewardManager` and transfer `token` reward.\r\n     * @param token, address of the token\r\n     */\r\n    function claimReward(address token) external;\r\n\r\n    /**\r\n     * @notice `rewardOf` returns the total reward of the lender\r\n     * @dev It returns array of number, where each element is a reward\r\n     * @dev For example - [stable reward, trade reward 1, trade reward 2]\r\n     * @return Returns the total pending reward\r\n     */\r\n    function rewardOf(address lender, address token) external returns (uint);\r\n\r\n    /**\r\n     * @notice `getDeposit` returns total amount deposited by the lender\r\n     * @param lender, address of the lender\r\n     * @return returns amount of stable token deposited by the lender\r\n     */\r\n    function getDeposit(address lender) external view returns (uint);\r\n}\r\n\r\n\r\n// File contracts/RedeemPool/interface/IRedeemPool.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\ninterface IRedeemPool {\r\n    /**\r\n     * @notice Emits when tStable token is exchanged for stable token\r\n     * @param account, the number of tokens exchanged\r\n     * @param amount, address of the account receiving the stable token\r\n     */\r\n    event StableWithdrawn(address account, uint amount);\r\n\r\n    /**\r\n     * @notice exchange tStable token for the stable token\r\n     * @dev users can directly call this function using EOA after approving `amount`\r\n     * @param amount, the number of tokens to be exchanged\r\n     */\r\n    function redeemStable(uint amount) external;\r\n\r\n    /**\r\n     * @notice exchange tStable token for the stable token\r\n     * @dev burns the tStable from msg.sender and sends stable to `account`\r\n     * @param amount, the number of tokens to be exchanged\r\n     * @param account, address of the account that will receive the stable token\r\n     */\r\n    function redeemStableFor(address account, uint amount) external;\r\n}\r\n\r\n\r\n// File contracts/Verification/interface/IVerification.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\n/**\r\n * @author Polytrade\r\n * @title IVerification\r\n */\r\ninterface IVerification {\r\n    struct UserStatus {\r\n        bytes2 provider;\r\n        bool status;\r\n    }\r\n\r\n    /**\r\n     * @notice Emits when a agent is set (added, removed)\r\n     * @param agent, address of the agent to be added or removed\r\n     * @param status, true if added or false if removed\r\n     */\r\n    event AgentSet(address agent, bool status);\r\n\r\n    /**\r\n     * @notice Emits when a user is validated or removed\r\n     * @param user, address of the user to be validated or removed\r\n     * @param provider, code of the provider (bytes2)\r\n     * @param status, true if added or false if removed\r\n     */\r\n    event UserValidation(address user, bytes2 provider, bool status);\r\n\r\n    /**\r\n     * @notice Emits when new kyc Limit is set\r\n     * @dev Emitted when new kycLimit is set by the owner\r\n     * @param kycLimit, new value of kycLimit\r\n     */\r\n    event ValidationLimitUpdated(uint kycLimit);\r\n\r\n    /**\r\n     * @notice Updates the limit for the Validation to be required\r\n     * @dev updates validationLimit variable\r\n     * @param validationLimit, new value of depositLimit\r\n     *\r\n     * Emits {ValidationLimitUpdated} event\r\n     */\r\n    function updateValidationLimit(uint validationLimit) external;\r\n\r\n    /**\r\n     * @notice Returns whether a user's KYC is verified or not\r\n     * @dev returns a boolean if the KYC is valid\r\n     * @param user, address of the user to check\r\n     * @return returns true if user's KYC is valid or false if not\r\n     */\r\n    function isValid(address user) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Returns whether a validation is required or not based on deposit\r\n     * @dev returns a boolean if the KYC is required or not\r\n     * @param user, address of the user to check\r\n     * @param amount, amount to be added\r\n     * @return returns a boolean if the amount requires a Validation or not\r\n     */\r\n    function isValidationRequired(address user, uint amount)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n// File contracts/RewardManager/interface/IRewardManager.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\ninterface IRewardManager {\r\n    struct Lender {\r\n        uint deposit;\r\n        bool registered;\r\n    }\r\n\r\n    /**\r\n     * @notice Emitted when RewardManger has started\r\n     * @dev Emitted when RewardManger has started (can be called only by owner)\r\n     * @param startTime, starting time (timestamp)\r\n     */\r\n    event RewardManagerStarted(uint40 startTime);\r\n\r\n    /**\r\n     * @notice `startRewardManager` registers the `RewardManager`\r\n     * @dev It can be called by LENDER_POOL only\r\n     */\r\n    function startRewardManager() external;\r\n\r\n    /**\r\n     * @notice `registerUser` registers the user to the current `RewardManager`\r\n     * @dev It copies the user information from previous `RewardManager`.\r\n     * @param lender, address of the lender\r\n     */\r\n    function registerUser(address lender) external;\r\n\r\n    /**\r\n     * @notice `claimRewardsFor` claims reward for the lender.\r\n     * @dev All the reward are transferred to the lender.\r\n     * @dev It can by only called by `LenderPool`.\r\n     * @param lender, address of the lender\r\n     */\r\n    function claimAllRewardsFor(address lender) external;\r\n\r\n    /**\r\n     * @notice `increaseDeposit` increases the amount deposited by lender.\r\n     * @dev It calls the `deposit` function of all the rewards in `RewardManager`.\r\n     * @dev It can by only called by `LenderPool`.\r\n     * @param lender, address of the lender\r\n     * @param amount, amount deposited by the lender\r\n     */\r\n    function increaseDeposit(address lender, uint amount) external;\r\n\r\n    /**\r\n     * @notice `withdrawDeposit` decrease the amount deposited by the lender.\r\n     * @dev It calls the `withdraw` function of all the rewards in `RewardManager`\r\n     * @dev It can by only called by `LenderPool`.\r\n     * @param lender, address of the lender\r\n     * @param amount, amount withdrawn by the lender\r\n     */\r\n    function withdrawDeposit(address lender, uint amount) external;\r\n\r\n    /**\r\n     * @notice `resetRewards` sets the reward for all the tokens to 0\r\n     */\r\n    function resetRewards() external;\r\n\r\n    /**\r\n     * @notice `claimRewardFor` transfer all the `token` reward to the `user`\r\n     * @dev It can be called by LENDER_POOL only.\r\n     * @param lender, address of the lender\r\n     * @param token, address of the token\r\n     */\r\n    function claimRewardFor(address lender, address token) external;\r\n\r\n    /**\r\n     * @notice `rewardOf` returns array of reward for the lender\r\n     * @dev It returns array of number, where each element is a reward\r\n     * @dev For example - [stable reward, trade reward 1, trade reward 2]\r\n     */\r\n    function rewardOf(address lender, address token)\r\n        external\r\n        view\r\n        returns (uint);\r\n\r\n    /**\r\n     * @notice `getDeposit` returns the total amount deposited by the lender\r\n     * @dev If this RewardManager is not the current and user has registered then this value will not be updated\r\n     * @param lender, address of the lender\r\n     * @return total amount deposited by the lender\r\n     */\r\n    function getDeposit(address lender) external view returns (uint);\r\n}\r\n\r\n\r\n// File @openzeppelin/contracts/access/Ownable.sol@v4.5.0\r\n\r\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/LenderPool/LenderPool.sol\r\n\r\npragma solidity =0.8.15;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @author Polytrade\r\n * @title LenderPool V2\r\n */\r\ncontract LenderPool is ILenderPool, Ownable {\r\n    mapping(address => Lender) private _lender;\r\n    mapping(address => uint) public managerToIndex;\r\n\r\n    address[] public managerList;\r\n\r\n    IToken public immutable stable;\r\n    IToken public immutable tStable;\r\n    IRedeemPool public immutable redeemPool;\r\n    IStrategy public strategy;\r\n    IVerification public verification;\r\n    IRewardManager public rewardManager;\r\n    address public treasury;\r\n\r\n    uint public currManager = 0;\r\n\r\n    constructor(\r\n        address _stableAddress,\r\n        address _tStableAddress,\r\n        address _redeemPool,\r\n        address _treasuryAddress,\r\n        address _rewardManager\r\n    ) {\r\n        stable = IToken(_stableAddress);\r\n        tStable = IToken(_tStableAddress);\r\n        redeemPool = IRedeemPool(_redeemPool);\r\n        treasury = _treasuryAddress;\r\n        rewardManager = IRewardManager(_rewardManager);\r\n        managerList.push(address(rewardManager));\r\n    }\r\n\r\n    /**\r\n     * @notice `switchStrategy` is used for switching the strategy.\r\n     * @dev It moves all the funds from the old strategy to the new strategy.\r\n     * @dev It can only be called by the owner of LenderPool.\r\n     * @dev Changed strategy contract must comply with `IStrategy`.\r\n     * @param newStrategy, address of the new staking strategy.\r\n     *\r\n     * Emits {StrategySwitched} event\r\n     */\r\n    function switchStrategy(address newStrategy) external onlyOwner {\r\n        require(newStrategy != address(0));\r\n        address oldStrategy = address(strategy);\r\n        if (oldStrategy != address(0)) {\r\n            uint amount = strategy.getBalance();\r\n            strategy.withdraw(amount);\r\n            strategy = Strategy(newStrategy);\r\n            _depositInStrategy(amount);\r\n        }\r\n        strategy = Strategy(newStrategy);\r\n        emit StrategySwitched(oldStrategy, newStrategy);\r\n    }\r\n\r\n    /**\r\n     * @notice `switchRewardManager` is used to switch reward manager.\r\n     * @dev It pauses reward for previous `RewardManager` and initializes new `RewardManager` .\r\n     * @dev It can only be called by the owner of LenderPool.\r\n     * @dev Changed `RewardManager` contract must comply with `IRewardManager`.\r\n     * @param newRewardManager, Address of the new `RewardManager`.\r\n     *\r\n     * Emits {RewardManagerSwitched} event\r\n     */\r\n    function switchRewardManager(address newRewardManager) external onlyOwner {\r\n        require(newRewardManager != address(0));\r\n        address oldRewardManager = address(rewardManager);\r\n        if (oldRewardManager != address(0)) {\r\n            rewardManager.resetRewards();\r\n        }\r\n        rewardManager = IRewardManager(newRewardManager);\r\n        rewardManager.startRewardManager();\r\n        currManager++;\r\n        managerToIndex[newRewardManager] = currManager;\r\n        managerList.push(newRewardManager);\r\n        emit RewardManagerSwitched(oldRewardManager, newRewardManager);\r\n    }\r\n\r\n    /**\r\n     * @notice `switchVerification` updates the Verification contract address.\r\n     * @dev Changed verification Contract must comply with `IVerification`\r\n     * @param newVerification, address of the new Verification contract\r\n     *\r\n     * Emits {VerificationContractUpdated} event\r\n     */\r\n    function switchVerification(address newVerification) external onlyOwner {\r\n        require(newVerification != address(0));\r\n        address oldVerification = address(verification);\r\n        verification = IVerification(newVerification);\r\n        emit VerificationSwitched(oldVerification, newVerification);\r\n    }\r\n\r\n    /**\r\n     * @notice `switchTreasury` updates the Treasury contract address.\r\n     * @param newTreasury, address of the new Treasury contract\r\n     *\r\n     * Emits {TreasuryContractUpdated} event\r\n     */\r\n    function switchTreasury(address newTreasury) external onlyOwner {\r\n        require(newTreasury != address(0));\r\n        address oldTreasury = address(treasury);\r\n        stable.approve(oldTreasury, 0);\r\n        treasury = newTreasury;\r\n        emit TreasurySwitched(oldTreasury, newTreasury);\r\n    }\r\n\r\n    /**\r\n     * @notice `deposit` is used by lenders to deposit stable token to the LenderPool.\r\n     * @dev It transfers the approved stable token from msg.sender to the LenderPool.\r\n     * @param amount, The number of stable token to be deposited.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `amount` should be greater than zero.\r\n     * - `amount` must be approved from the stable token contract for the LenderPool.\r\n     * - `amount` should be less than validation limit or KYC needs to be completed.\r\n     *\r\n     * Emits {Deposit} event\r\n     */\r\n    function deposit(uint amount) external {\r\n        require(amount > 0);\r\n        if (!(_lender[msg.sender].isRegistered[address(rewardManager)])) {\r\n            registerUser();\r\n        }\r\n\r\n        _isUserRegistered(msg.sender);\r\n\r\n        require(\r\n            !verification.isValidationRequired(msg.sender, amount),\r\n            \"Need verification\"\r\n        );\r\n\r\n        stable.transferFrom(msg.sender, address(this), amount);\r\n        _depositInStrategy(amount);\r\n\r\n        rewardManager.increaseDeposit(msg.sender, amount);\r\n        _lender[msg.sender].deposit += amount;\r\n        emit Deposit(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice `withdrawAllDeposit` send lender tStable equivalent to stable deposited.\r\n     * @dev It mints tStable and sends to lender.\r\n     * @dev It sets the amount deposited by lender to zero.\r\n     *\r\n     * Emits {Withdraw} event\r\n     */\r\n    function withdrawAllDeposit() external {\r\n        _isUserRegistered(msg.sender);\r\n        uint balance = _lender[msg.sender].deposit;\r\n        require(balance > 0);\r\n        rewardManager.withdrawDeposit(msg.sender, balance);\r\n        _lender[msg.sender].deposit = 0;\r\n        tStable.mint(msg.sender, balance);\r\n        emit Withdraw(msg.sender, balance);\r\n    }\r\n\r\n    /**\r\n     * @notice `withdrawDeposit` send lender tStable equivalent to stable requested.\r\n     * @dev It mints tStable and sends to lender.\r\n     * @dev It decreases the amount deposited by lender.\r\n     * @param amount, Total token requested by lender.\r\n     *\r\n     * Requirements:\r\n     * - `amount` should be greater than 0.\r\n     * - `amount` should be not greater than deposited.\r\n     *\r\n     * Emits {Withdraw} event\r\n     */\r\n    function withdrawDeposit(uint amount) external {\r\n        _isUserRegistered(msg.sender);\r\n        require(amount > 0);\r\n        uint balance = _lender[msg.sender].deposit;\r\n        require(balance >= amount);\r\n        rewardManager.withdrawDeposit(msg.sender, amount);\r\n        _lender[msg.sender].deposit -= amount;\r\n        tStable.mint(msg.sender, amount);\r\n        emit Withdraw(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice `claimRewards` transfers lender all the reward of the current manager.\r\n     * @dev It calls `claimRewardsFor` from `RewardManager`.\r\n     * @dev RewardManager may be changed by LenderPool's owner.\r\n     */\r\n    function claimAllRewards() external {\r\n        _isUserRegistered(msg.sender);\r\n        for (uint i = 0; i <= currManager; i++) {\r\n            IRewardManager(managerList[i]).claimAllRewardsFor(msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice `claimReward` transfer all the `token` reward to `msg.sender`\r\n     * @dev It loops through all the `RewardManager` and transfer `token` reward.\r\n     * @param token, address of the token\r\n     */\r\n    function claimReward(address token) external {\r\n        _isUserRegistered(msg.sender);\r\n        for (uint i = 0; i <= currManager; i++) {\r\n            IRewardManager(managerList[i]).claimRewardFor(msg.sender, token);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice `redeemAll` call transfers all reward and deposited amount in stable token.\r\n     * @dev It converts the tStable to stable using `RedeemPool`.\r\n     * @dev It calls `claimRewardsFor` from `RewardManager`.\r\n     *\r\n     * Requirements :\r\n     * - `RedeemPool` should have stable tokens more than lender deposited.\r\n     *\r\n     */\r\n    function redeemAll() external {\r\n        _isUserRegistered(msg.sender);\r\n\r\n        uint balance = _lender[msg.sender].deposit;\r\n\r\n        if (balance > 0) {\r\n            rewardManager.withdrawDeposit(\r\n                msg.sender,\r\n                _lender[msg.sender].deposit\r\n            );\r\n        }\r\n\r\n        _lender[msg.sender].deposit = 0;\r\n        tStable.mint(address(this), balance);\r\n        tStable.approve(address(redeemPool), balance);\r\n        redeemPool.redeemStableFor(msg.sender, balance);\r\n        rewardManager.claimAllRewardsFor(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice `redeem` send caller the amount in stable token by converting its tStable to Stable\r\n     * @dev It converts the tStable to stable using `RedeemPool`.\r\n     *\r\n     * Requirements :\r\n     * - `RedeemPool` should have enough stable tokens on the RedeemPool.\r\n     *\r\n     */\r\n    function redeem(uint amount) external {\r\n        require(amount > 0 && _lender[msg.sender].deposit >= amount);\r\n\r\n        _isUserRegistered(msg.sender);\r\n\r\n        rewardManager.withdrawDeposit(msg.sender, amount);\r\n        _lender[msg.sender].deposit -= amount;\r\n        tStable.mint(address(this), amount);\r\n        tStable.approve(address(redeemPool), amount);\r\n        redeemPool.redeemStableFor(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw funds from strategy and send it to the RedeemPool\r\n     * @param amount to be send to the RedeemPool\r\n     */\r\n    function fillRedeemPool(uint amount) external onlyOwner {\r\n        require(amount > 0);\r\n        strategy.withdraw(amount);\r\n        stable.transfer(address(redeemPool), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw funds from strategy and approve Treasury to spend\r\n     * @param amount to be withdrawn from Strategy and approved to treasury\r\n     */\r\n    function requestFundInvoice(uint amount) external {\r\n        require(msg.sender == treasury);\r\n        strategy.withdraw(amount);\r\n        stable.approve(address(treasury), amount);\r\n    }\r\n\r\n    /**\r\n     * @notice `rewardOf` returns the total reward of the lender\r\n     * @dev It returns the sum of all amount among all RewardManagers\r\n     * @param lender, address of the lender to check rewards.\r\n     * @param token, address of the token to check rewards from (USDC, TRADE, etc.).\r\n     * @return Returns the total pending reward\r\n     */\r\n    function rewardOf(address lender, address token)\r\n        external\r\n        view\r\n        returns (uint)\r\n    {\r\n        uint totalReward = 0;\r\n        for (uint i = 0; i <= currManager; i++) {\r\n            totalReward += IRewardManager(managerList[i]).rewardOf(\r\n                lender,\r\n                token\r\n            );\r\n        }\r\n        return totalReward;\r\n    }\r\n\r\n    /**\r\n     * @notice `getDeposit` returns total amount deposited by the lender\r\n     * @param lender, address of the lender\r\n     * @return returns amount of stable token deposited by the lender\r\n     */\r\n    function getDeposit(address lender) external view returns (uint) {\r\n        return _lender[lender].deposit;\r\n    }\r\n\r\n    /**\r\n     * @notice Registers user to all the reward manager\r\n     * @dev User have to register to RewardManager before interacting with RewardManager\r\n     */\r\n    function registerUser() public {\r\n        for (uint i = 0; i <= currManager; i++) {\r\n            if (!_lender[msg.sender].isRegistered[managerList[i]]) {\r\n                IRewardManager manager = IRewardManager(managerList[i]);\r\n                manager.registerUser(msg.sender);\r\n                _lender[msg.sender].isRegistered[address(manager)] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice `_depositInStrategy` deposits stable token to external protocol.\r\n     * @dev Funds will be deposited to a Strategy (external protocols) like Aave, compound\r\n     * @param amount, total amount to be deposited.\r\n     */\r\n    function _depositInStrategy(uint amount) private {\r\n        stable.approve(address(strategy), amount);\r\n        strategy.deposit(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Checks and requires that the user is registered in the current and previous RewardManager\r\n     * @param _user, address of the user\r\n     */\r\n    function _isUserRegistered(address _user) private view {\r\n        if (currManager == 0) {\r\n            require((_lender[_user].isRegistered[address(rewardManager)]));\r\n        } else {\r\n            require(\r\n                _lender[_user].isRegistered[\r\n                    managerList[managerToIndex[address(rewardManager)] - 1]\r\n                ] && _lender[_user].isRegistered[address(rewardManager)]\r\n            );\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_stableAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tStableAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_redeemPool\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_treasuryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldRewardManager\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newRewardManager\",\"type\":\"address\"}],\"name\":\"RewardManagerSwitched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldStrategy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"StrategySwitched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldTreasury\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"TreasurySwitched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldVerification\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newVerification\",\"type\":\"address\"}],\"name\":\"VerificationSwitched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"claimAllRewards\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"claimReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currManager\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"fillRedeemPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"name\":\"getDeposit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"managerList\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"managerToIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"redeem\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"redeemPool\",\"outputs\":[{\"internalType\":\"contract IRedeemPool\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerUser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"requestFundInvoice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardManager\",\"outputs\":[{\"internalType\":\"contract IRewardManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"rewardOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stable\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategy\",\"outputs\":[{\"internalType\":\"contract IStrategy\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newRewardManager\",\"type\":\"address\"}],\"name\":\"switchRewardManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newStrategy\",\"type\":\"address\"}],\"name\":\"switchStrategy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newTreasury\",\"type\":\"address\"}],\"name\":\"switchTreasury\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newVerification\",\"type\":\"address\"}],\"name\":\"switchVerification\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tStable\",\"outputs\":[{\"internalType\":\"contract IToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treasury\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"verification\",\"outputs\":[{\"internalType\":\"contract IVerification\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawDeposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LenderPool", "CompilerVersion": "v0.8.15+commit.e14f2714", "OptimizationUsed": "1", "Runs": "10", "ConstructorArguments": "0000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa841740000000000000000000000002601309bdb3a6cda6d6c2153b12d035eaed95286000000000000000000000000eb36025c274c7d2658836eefb1b30c84cd8dca0b00000000000000000000000042a95f80e618de42faa218b707b82fde9f1675ac0000000000000000000000000bc9bd86faa029123fa667a78414b47910307b1f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a2a0ac170bf2adf0a31dab7487e46a07bdc392cfc17adf17a6c16124ef2ffcda"}