{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Diamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibEnvironmentConfig} from \\\"LibEnvironmentConfig.sol\\\";\\nimport {IDiamondCut} from \\\"IDiamondCut.sol\\\";\\nimport {LibString} from \\\"LibString.sol\\\";\\n\\ncontract Diamond {\\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\\n        LibDiamond.setContractOwner(_contractOwner);\\n        LibEnvironmentConfig.configureForPolygonMainnet();\\n        // Add the diamondCut external function from the diamondCutFacet\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n        cut[0] = IDiamondCut.FacetCut({\\n            facetAddress: _diamondCutFacet,\\n            action: IDiamondCut.FacetCutAction.Add,\\n            functionSelectors: functionSelectors\\n        });\\n        LibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n    }\\n\\n    // Find facet for function that is called and execute the\\n    // function if a facet is found and return any value.\\n    fallback() external payable {\\n        LibDiamond.DiamondStorage storage ds;\\n        bytes32 position = LibDiamond.DIAMOND_STORAGE_POSITION;\\n        // get diamond storage\\n        assembly {\\n            ds.slot := position\\n        }\\n        // get facet from function selector\\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\\n        require(\\n            facet != address(0),\\n            string.concat(\\n                \\\"Diamond: Function does not exist: \\\",\\n                LibString.selectorToString(msg.sig)\\n            )\\n        );\\n        // Execute external function from facet using delegatecall and return any value.\\n        assembly {\\n            // copy function selector and any arguments\\n            calldatacopy(0, 0, calldatasize())\\n            // execute function call using the facet\\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\\n            // get any return value\\n            returndatacopy(0, 0, returndatasize())\\n            // return any return value or error back to the caller\\n            switch result\\n            case 0 {\\n                revert(0, returndatasize())\\n            }\\n            default {\\n                return(0, returndatasize())\\n            }\\n        }\\n    }\\n\\n    receive() external payable {}\\n}\\n\"\r\n    },\r\n    \"LibDiamond.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\nimport {IDiamondCut} from \\\"IDiamondCut.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\nimport {LibValidate} from \\\"LibValidate.sol\\\";\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.standard.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // owner of the contract\\n        address contractOwner;\\n        // UNIM token address\\n        address unimTokenAddress;\\n        // DarkMarks token address\\n        address darkMarksTokenAddress;\\n        // LG game bank address\\n        address gameBankAddress;\\n        // LG rituals address\\n        address ritualsAddress;\\n        // LG shadowcorn address\\n        address shadowcornAddress;\\n        // LG unicorn address\\n        address unicornAddress;\\n        // Terminus contract address for Shadowcorn Items\\n        address shadowcornItemsAddress;\\n        // Terminus contract address for Unicorn Items\\n        address unicornItemsAddress;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function setContractOwner(address _newOwner) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        address previousOwner = ds.contractOwner;\\n        ds.contractOwner = _newOwner;\\n        emit LibEvents.OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    function contractOwner() internal view returns (address _contractOwner) {\\n        _contractOwner = diamondStorage().contractOwner;\\n    }\\n\\n    function setGameBankAddress(address _gameBankAddress) internal {\\n        LibValidate.enforceNonZeroAddress(_gameBankAddress);\\n        diamondStorage().gameBankAddress = _gameBankAddress;\\n    }\\n\\n    function gameBankAddress()\\n        internal\\n        view\\n        returns (address _gameBankAddress)\\n    {\\n        _gameBankAddress = diamondStorage().gameBankAddress;\\n    }\\n\\n    function setDarkMarksTokenAddress(address _darkMarksTokenAddress) internal {\\n        LibValidate.enforceNonZeroAddress(_darkMarksTokenAddress);\\n        diamondStorage().darkMarksTokenAddress = _darkMarksTokenAddress;\\n    }\\n\\n    function darkMarksTokenAddress()\\n        internal\\n        view\\n        returns (address _darkMarksTokenAddress)\\n    {\\n        _darkMarksTokenAddress = diamondStorage().darkMarksTokenAddress;\\n    }\\n\\n    function setUnimTokenAddress(address _unimTokenAddress) internal {\\n        LibValidate.enforceNonZeroAddress(_unimTokenAddress);\\n        diamondStorage().unimTokenAddress = _unimTokenAddress;\\n    }\\n\\n    function unimTokenAddress()\\n        internal\\n        view\\n        returns (address _unimTokenAddress)\\n    {\\n        _unimTokenAddress = diamondStorage().unimTokenAddress;\\n    }\\n\\n    function setShadowcornItemsAddress(address _shadowcornItemsAddress) internal {\\n        LibValidate.enforceNonZeroAddress(_shadowcornItemsAddress);\\n        diamondStorage().shadowcornItemsAddress = _shadowcornItemsAddress;\\n    }\\n\\n    function shadowcornItemsAddress()\\n        internal\\n        view\\n        returns (address _shadowcornItemsAddress)\\n    {\\n        _shadowcornItemsAddress = diamondStorage().shadowcornItemsAddress;\\n    }\\n\\n    function setUnicornItemsAddress(address _unicornItemsAddress) internal {\\n        LibValidate.enforceNonZeroAddress(_unicornItemsAddress);\\n        diamondStorage().unicornItemsAddress = _unicornItemsAddress;\\n    }\\n\\n    function unicornItemsAddres() internal view returns (address _unicornItemsAddress) {\\n        _unicornItemsAddress = diamondStorage().unicornItemsAddress;\\n    }\\n\\n    function setUnicornAddress(address newUnicornAddress) internal {\\n        LibValidate.enforceNonZeroAddress(newUnicornAddress);\\n        diamondStorage().unicornAddress = newUnicornAddress;\\n    }\\n\\n    function unicornAddress() internal view returns (address _unicornAddress) {\\n        _unicornAddress = diamondStorage().unicornAddress;\\n    }\\n\\n    function setRitualsAddress(address newRitualsAddress) internal {\\n        LibValidate.enforceNonZeroAddress(newRitualsAddress);\\n        diamondStorage().ritualsAddress = newRitualsAddress;\\n    }\\n\\n    function ritualsAddress() internal view returns (address _ritualsAddress) {\\n        _ritualsAddress = diamondStorage().ritualsAddress;\\n    }\\n\\n    function setShadowcornAddress(address newShadowcornAddress) internal {\\n        LibValidate.enforceNonZeroAddress(newShadowcornAddress);\\n        diamondStorage().shadowcornAddress = newShadowcornAddress;\\n    }\\n\\n    function shadowcornAddress() internal view returns (address _shadowcornAddress) {\\n        _shadowcornAddress = diamondStorage().shadowcornAddress;\\n    }\\n\\n    function enforceIsContractOwner() internal view {\\n        require(\\n            msg.sender == diamondStorage().contractOwner,\\n            \\\"LibDiamond: Must be contract owner\\\"\\n        );\\n    }\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit LibEvents.DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint96 selectorPosition = uint96(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress == address(0),\\n                \\\"LibDiamondCut: Can't add function that already exists\\\"\\n            );\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint96 selectorPosition = uint96(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress != _facetAddress,\\n                \\\"LibDiamondCut: Can't replace function with same function\\\"\\n            );\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        require(\\n            _functionSelectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(\\n            _facetAddress == address(0),\\n            \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n        );\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < _functionSelectors.length;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(\\n        DiamondStorage storage ds,\\n        address _facetAddress\\n    ) internal {\\n        enforceHasContractCode(\\n            _facetAddress,\\n            \\\"LibDiamondCut: New facet has no code\\\"\\n        );\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\\n            .facetAddresses\\n            .length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        DiamondStorage storage ds,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n            _selector\\n        );\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(\\n        DiamondStorage storage ds,\\n        address _facetAddress,\\n        bytes4 _selector\\n    ) internal {\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n        );\\n        // an immutable function is a function defined directly in a diamond\\n        require(\\n            _facetAddress != address(this),\\n            \\\"LibDiamondCut: Can't remove immutable function\\\"\\n        );\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds\\n            .facetFunctionSelectors[_facetAddress]\\n            .functionSelectors\\n            .length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n                selectorPosition\\n            ] = lastSelector;\\n            ds\\n                .selectorToFacetAndPosition[lastSelector]\\n                .functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[\\n                    lastFacetAddressPosition\\n                ];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds\\n                    .facetFunctionSelectors[lastFacetAddress]\\n                    .facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        if (_init == address(0)) {\\n            require(\\n                _calldata.length == 0,\\n                \\\"LibDiamondCut: _init is address(0) but_calldata is not empty\\\"\\n            );\\n        } else {\\n            require(\\n                _calldata.length > 0,\\n                \\\"LibDiamondCut: _calldata is empty but _init is not address(0)\\\"\\n            );\\n            if (_init != address(this)) {\\n                enforceHasContractCode(\\n                    _init,\\n                    \\\"LibDiamondCut: _init address has no code\\\"\\n                );\\n            }\\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n            if (!success) {\\n                if (error.length > 0) {\\n                    // bubble up the error\\n                    revert(string(error));\\n                } else {\\n                    revert(\\\"LibDiamondCut: _init function reverted\\\");\\n                }\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\"\r\n    },\r\n    \"IDiamondCut.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata _calldata\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"LibEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {IDiamondCut} from \\\"IDiamondCut.sol\\\";\\n\\nimport {LibStructs} from \\\"LibStructs.sol\\\";\\nimport {LibHatcheryRituals} from \\\"LibHatcheryRituals.sol\\\";\\nimport {LibRitualComponents} from \\\"LibRitualComponents.sol\\\";\\nimport {LibConstraints} from \\\"LibConstraints.sol\\\";\\n\\n\\nlibrary LibEvents {\\n    event HatcheryLevelUnlocked(\\n        address indexed player,\\n        uint256 oldLevel,\\n        uint256 newLevel\\n    );\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n    event Log(string message, uint256 data);\\n    event ClaimedRewards(\\n        address indexed player,\\n        uint256 rewardUNIM,\\n        uint256 rewardDarkMarks\\n    );\\n    event AddedToQueue(\\n        address indexed player,\\n        uint256 waveId,\\n        uint256 quantity\\n    );\\n    event BegunNewWave(\\n        uint256 newWaveId,\\n        uint256 prevWaveTime,\\n        uint256 newWaveTime\\n    );\\n    event ShadowcornStaked(\\n        uint256 indexed tokenId,\\n        address indexed staker,\\n        bool staked,\\n        uint256 farmableItemId,\\n        uint256 stakeTimestamp\\n    );\\n    event SetShadowcornFarmingData(\\n        address indexed player,\\n        uint256 indexed tokenId,\\n        LibStructs.FarmableItem farmingData\\n    );\\n\\n    event FarmableItemRegistered(\\n        address indexed admin,\\n        uint256 farmableItemId,\\n        uint256 poolId,\\n        uint256 hourlyRate,\\n        uint256 cap,\\n        string indexed uri\\n    );\\n    event FarmableItemModified(\\n        address indexed admin,\\n        uint256 farmableItemId,\\n        uint256 poolId,\\n        uint256 hourlyRate,\\n        uint256 cap,\\n        uint256 class,\\n        uint256 stat\\n    );\\n\\n    event FarmableItemActivated(address indexed admin, uint256 farmableItemId);\\n    event FarmableItemDeactivated(address indexed admin, uint256 farmableItemId);\\n    event FarmableItemDeleted(address indexed admin, uint256 farmableItemId);\\n\\n    event ShadowcornUnstaked(\\n        uint256 indexed tokenId,\\n        address indexed staker,\\n        bool staked,\\n        uint256 farmableItemId,\\n        uint256 stakedTime\\n    );\\n\\n    event ForcedUnstakeExecuted(address indexed player, uint256 indexed tokenId);\\n\\n    event ShadowcornHarvest(\\n        address indexed player,\\n        uint256 indexed tokenId,\\n        uint256 indexed poolId,\\n        uint256 stakingRewards\\n    );\\n\\n    event RitualTemplateCreated(uint256 indexed id);\\n    event RitualTemplatePoolCreated(uint256 indexed id);\\n    event AffixCreated(uint256 indexed id);\\n    event AffixBucketCreated(uint256 indexed id, uint256[] affixIds);\\n    event BeginRitualCreation(address indexed playerWallet, uint256 indexed ritualTemplatePoolId, uint256 indexed vrfRequestId);\\n    event FinishRitualCreation(uint256 indexed vrfRequestId, uint256 indexed ritualTemplateId, uint256 indexed ritualTokenId, uint256[] affixIdsApplied);\\n    event HatcheryAffixWarning(string warningText);\\n}\\n\"\r\n    },\r\n    \"LibStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nlibrary LibStructs {\\n    struct StakeData {\\n        address staker; //  Address of the staker\\n        bool staked; //  TRUE if the stake is active\\n        uint256 farmableItemId; //  Id of the FarmableItem being farmed\\n        uint256 stakeTimestamp; //  Timestamp of the stake\\n    }\\n\\n    /// Definition of a Terminus pool that can be yield farmed by Shadowcorns\\n    struct FarmableItem {\\n        bool active; /// TRUE if the item can be farmed\\n        uint256 poolId; /// Id of the pool on Terminus contract\\n        uint256 hourlyRate; /// how many of the items are made per hour (3 decimals)\\n        uint256 cap; /// max number that can be farmed per session\\n        string uri; /// passthrough from Terminus\\n        uint256 class; /// class of the shadowcorn\\n        uint256 stat; /// stat of the shadowcorn to use\\n        bool receivesHatcheryLevelBonus;\\n        bool receivesRarityBonus;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibHatcheryRituals.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\nimport {LibHatcheryRitualConstraints} from \\\"LibHatcheryRitualConstraints.sol\\\";\\nimport {LibConstraints} from \\\"LibConstraints.sol\\\";\\nimport {LibHatcheryRitualComponents} from \\\"LibHatcheryRitualComponents.sol\\\";\\nimport {LibRitualComponents} from \\\"LibRitualComponents.sol\\\";\\nimport {LibConstraintOperator} from \\\"LibConstraintOperator.sol\\\";\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {IRitualFacet} from \\\"IRitualFacet.sol\\\";\\nimport {LibRNG} from \\\"LibRNG.sol\\\";\\nimport {LibRitualNames} from \\\"LibRitualNames.sol\\\";\\nimport {LibArray} from \\\"LibArray.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\nimport {LibRitualData} from \\\"LibRitualData.sol\\\";\\nimport {LibString} from \\\"LibString.sol\\\";\\n\\nlibrary LibHatcheryRituals {\\n    struct HatcheryRitualStorage {\\n        uint256 lastTemplateId;\\n        uint256 lastPoolId;\\n        uint256 lastAffixId;\\n        mapping(uint256 => BasicRitualTemplate) basicRitualTemplateByRitualTemplateId;\\n        mapping(uint256 => LibConstraints.Constraint[]) consumptionConstraintsByRitualTemplateId;\\n        mapping(uint256 => LibRitualComponents.RitualCost[]) consumptionCostsByRitualTemplateId;\\n        mapping(uint256 => LibRitualComponents.RitualProduct[]) consumptionProductsByRitualTemplateId;\\n        mapping(uint256 => LibConstraints.Constraint[]) creationConstraintsByTemplatePoolId;\\n        mapping(uint256 => LibRitualComponents.RitualCost[]) creationCostsByTemplatePoolId;\\n        mapping(uint256 => uint256[]) affixBucketIdsByRitualTemplateId;\\n        mapping(uint256 => uint256[]) ritualTemplateIdsByTemplatePoolId;\\n        mapping(uint256 => uint256[]) ritualTemplateWeightsByTemplatePoolId;\\n        mapping(uint256 => uint256) ritualTemplateSumWeightByTemplatePoolId;\\n        mapping(uint256 => Affix) affixById;\\n        mapping(uint256 => uint256[]) affixIdsByAffixBucketId;\\n        mapping(uint256 => uint256) ritualTemplatePoolIdByVRFRequestId;\\n        mapping(uint256 => address) playerWalletByVRFRequestId;\\n        uint256 lastAffixBucketId;\\n        uint256 maxRitualsPerBatch;\\n    }\\n\\n    enum AffixType {\\n        NONE,\\n        COST,\\n        PRODUCT,\\n        CHARGES,\\n        CONSTRAINT,\\n        SOULBOUND\\n    }\\n\\n    struct Affix {\\n        AffixType affixType;\\n        bool isPositive;\\n        uint256 charges;\\n        LibRitualComponents.RitualCost cost;\\n        LibRitualComponents.RitualProduct product;\\n        LibConstraints.Constraint constraint;\\n        uint256 weight;\\n    }\\n\\n    struct BasicRitualTemplate {\\n        uint8 rarity;\\n        uint256 charges;\\n        bool soulbound;\\n    }\\n\\n    struct RitualTemplate {\\n        uint8 rarity;\\n        uint256 charges;\\n        bool soulbound;\\n        uint256[] affixBucketIds;\\n        LibConstraints.Constraint[] consumptionConstraints;\\n        LibRitualComponents.RitualCost[] consumptionCosts;\\n        LibRitualComponents.RitualProduct[] consumptionProducts;\\n    }\\n\\n    uint256 private constant SALT_1 = 1;\\n    uint256 private constant SALT_PER_BUCKET = 100000;\\n\\n    bytes32 private constant HATCHERY_RITUAL_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.HatcheryRitual.Storage\\\");\\n\\n    function hatcheryRitualStorage()\\n        internal\\n        pure\\n        returns (HatcheryRitualStorage storage ds)\\n    {\\n        bytes32 position = HATCHERY_RITUAL_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    // @notice This function is used to check if the user meets the constraints of a ritual.\\n    // @param constraints The constraints of the ritual.\\n    function checkConstraints(\\n        LibConstraints.Constraint[] memory constraints,\\n        address user\\n    ) internal view {\\n        for (uint256 i = 0; i < constraints.length; i++) {\\n            //Max uint256 is used as a placeholder for the tokenId in the constraints.\\n            LibHatcheryRitualConstraints.checkConstraint(constraints[i], user);\\n        }\\n    }\\n\\n    // @notice This function is used to pay the costs of a ritual.\\n    // @param costs The costs of the ritual.\\n    function payCosts(LibRitualComponents.RitualCost[] memory costs) internal {\\n        for (uint256 i = 0; i < costs.length; i++) {\\n            LibHatcheryRitualComponents.payCost(costs[i]);\\n        }\\n    }\\n\\n    // @notice This function is used to mint the products of a ritual.\\n    // @param products The products of the ritual.\\n    function mintProducts(\\n        LibRitualComponents.RitualProduct[] memory products\\n    ) internal {\\n        for (uint256 i = 0; i < products.length; i++) {\\n            LibHatcheryRitualComponents.mintProduct(products[i]);\\n        }\\n    }\\n\\n    function consumeRitualCharge(uint256 ritualId) internal {\\n        address ritualsAddress = LibDiamond.ritualsAddress();\\n        LibRitualData.Ritual memory ritual = IRitualFacet(ritualsAddress)\\n            .validateChargesAndGetRitualDetailsForConsume(ritualId, msg.sender);\\n        checkConstraints(ritual.constraints, msg.sender);\\n        payCosts(ritual.costs);\\n        IRitualFacet(ritualsAddress).consumeRitualCharge(ritualId);\\n        mintProducts(ritual.products);\\n    }\\n\\n    function canConsumeRitual(\\n        uint256 ritualId,\\n        address user\\n    ) internal view returns (bool canConsume) {\\n        address ritualsAddress = LibDiamond.ritualsAddress();\\n        LibRitualData.Ritual memory ritual = IRitualFacet(ritualsAddress)\\n            .validateChargesAndGetRitualDetailsForConsume(ritualId, user);\\n        checkConstraints(ritual.constraints, user);\\n        return true;\\n    }\\n\\n    function nextRitualTemplatePoolId() private returns (uint256) {\\n        return ++hatcheryRitualStorage().lastPoolId;\\n    }\\n\\n    function nextRitualTemplateId() private returns (uint256) {\\n        return ++hatcheryRitualStorage().lastTemplateId;\\n    }\\n\\n    function nextAffixId() private returns (uint256) {\\n        return ++hatcheryRitualStorage().lastAffixId;\\n    }\\n\\n    function nextHatcheryBucketId() internal returns (uint256) {\\n        return ++hatcheryRitualStorage().lastAffixBucketId;\\n    }\\n\\n    function setMaxRitualsPerBatch(uint256 maxRitualsPerBatch) internal {\\n        hatcheryRitualStorage().maxRitualsPerBatch = maxRitualsPerBatch;\\n    }\\n\\n    function getMaxRitualsPerBatch() internal view returns (uint256) {\\n        return hatcheryRitualStorage().maxRitualsPerBatch;\\n    }\\n\\n    function createBasicRitualTemplate(\\n        uint8 rarity,\\n        uint256 charges,\\n        bool soulbound\\n    ) internal returns (uint256 templateId) {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        templateId = nextRitualTemplateId();\\n\\n        hrs.basicRitualTemplateByRitualTemplateId[\\n            templateId\\n        ] = BasicRitualTemplate({\\n            rarity: rarity,\\n            charges: charges,\\n            soulbound: soulbound\\n        });\\n    }\\n\\n    function createRitualTemplate(\\n        RitualTemplate memory template\\n    ) internal returns (uint256 id) {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        id = nextRitualTemplateId();\\n        hrs.basicRitualTemplateByRitualTemplateId[id] = BasicRitualTemplate({\\n            rarity: template.rarity,\\n            charges: template.charges,\\n            soulbound: template.soulbound\\n        });\\n\\n        for (uint256 i = 0; i < template.consumptionConstraints.length; ++i) {\\n            hrs.consumptionConstraintsByRitualTemplateId[id].push(\\n                template.consumptionConstraints[i]\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < template.consumptionCosts.length; ++i) {\\n            hrs.consumptionCostsByRitualTemplateId[id].push(\\n                template.consumptionCosts[i]\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < template.consumptionProducts.length; ++i) {\\n            hrs.consumptionProductsByRitualTemplateId[id].push(\\n                template.consumptionProducts[i]\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < template.affixBucketIds.length; ++i) {\\n            hrs.affixBucketIdsByRitualTemplateId[id].push(\\n                template.affixBucketIds[i]\\n            );\\n        }\\n        emit LibEvents.RitualTemplateCreated(id);\\n    }\\n\\n    function createRitualTemplatePool(\\n        LibRitualComponents.RitualCost[] memory creationCosts,\\n        LibConstraints.Constraint[] memory creationConstraints\\n    ) internal returns (uint256 id) {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        id = nextRitualTemplatePoolId();\\n        for (uint256 i = 0; i < creationConstraints.length; ++i) {\\n            hrs.creationConstraintsByTemplatePoolId[id].push(\\n                creationConstraints[i]\\n            );\\n        }\\n\\n        for (uint256 i = 0; i < creationCosts.length; ++i) {\\n            hrs.creationCostsByTemplatePoolId[id].push(creationCosts[i]);\\n        }\\n        emit LibEvents.RitualTemplatePoolCreated(id);\\n    }\\n\\n    function addRitualTemplateToPool(\\n        uint256 ritualTemplateId,\\n        uint256 ritualPoolId,\\n        uint256 rngWeight\\n    ) internal {\\n        require(\\n            ritualTemplateExists(ritualTemplateId),\\n            \\\"LibHatcheryRituals: ritualTemplateId does not exist\\\"\\n        );\\n        //require(ritualPoolExists(ritualPoolId), \\\"LibHatcheryRituals: Pool does not exist\\\");\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        hrs.ritualTemplateIdsByTemplatePoolId[ritualPoolId].push(\\n            ritualTemplateId\\n        );\\n        hrs.ritualTemplateWeightsByTemplatePoolId[ritualPoolId].push(rngWeight);\\n        hrs.ritualTemplateSumWeightByTemplatePoolId[ritualPoolId] += rngWeight;\\n    }\\n\\n    function removeRitualTemplateFromPool(\\n        uint256 ritualTemplateId,\\n        uint256 ritualPoolId\\n    ) internal {\\n        //  TODO: Find the index of ritualTemplateId in ritualTemplateIdsByTemplatePoolId[ritualPoolId]\\n        //    subtract ritualTemplateWeightsByTemplatePoolId[ritualPoolId][index] from  ritualTemplateSumWeightByTemplatePoolId[ritualPoolId]\\n        //    delete index out of ritualTemplateIdsByTemplatePoolId[ritualPoolId]\\n        //    delete index out of hrs.ritualTemplateWeightsByTemplatePoolId[ritualPoolId]\\n        revert(\\\"Function not implemented\\\");\\n    }\\n\\n    function createAffix(Affix memory affix) internal returns (uint256 id) {\\n        id = nextAffixId();\\n        hatcheryRitualStorage().affixById[id] = affix;\\n        emit LibEvents.AffixCreated(id);\\n    }\\n\\n    function createAffixBucket(\\n        uint256[] memory affixIds\\n    ) internal returns (uint256 affixBucketId) {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        affixBucketId = nextHatcheryBucketId();\\n        for (uint256 i = 0; i < affixIds.length; i++) {\\n            hatcheryRitualStorage().affixIdsByAffixBucketId[affixBucketId].push(\\n                affixIds[i]\\n            );\\n        }\\n        emit LibEvents.AffixBucketCreated(affixBucketId, affixIds);\\n    }\\n\\n    function addAffixesToBucket(\\n        uint256[] memory affixIds,\\n        uint256 bucketId\\n    ) internal {\\n        //This creates the bucket implicitly.\\n        require(affixBucketExists(bucketId), \\\"Bucket does not exist\\\");\\n        require(affixesExist(affixIds), \\\"Some affixes do not exist\\\");\\n        for (uint256 i = 0; i < affixIds.length; i++) {\\n            hatcheryRitualStorage().affixIdsByAffixBucketId[bucketId].push(\\n                affixIds[i]\\n            );\\n        }\\n    }\\n\\n    function removeAffixFromBucket(uint256 affixId, uint256 bucketId) internal {\\n        require(affixBucketExists(bucketId), \\\"Bucket does not exist\\\");\\n        require(affixExists(affixId), \\\"Affix does not exist\\\");\\n        uint256[] storage affixIds = hatcheryRitualStorage()\\n            .affixIdsByAffixBucketId[bucketId];\\n        for (uint256 i = 0; i < affixIds.length; i++) {\\n            if (affixIds[i] == affixId) {\\n                affixIds[i] = affixIds[affixIds.length - 1];\\n                affixIds.pop();\\n                break;\\n            }\\n        }\\n    }\\n\\n    function affixBucketExists(uint256 bucketId) private view returns (bool) {\\n        return\\n            hatcheryRitualStorage().affixIdsByAffixBucketId[bucketId].length >\\n            0;\\n    }\\n\\n    function affixExists(uint256 affixId) private view returns (bool) {\\n        return\\n            hatcheryRitualStorage().affixById[affixId].affixType ==\\n            AffixType.NONE;\\n    }\\n\\n    function affixesExist(\\n        uint256[] memory affixIds\\n    ) private view returns (bool) {\\n        for (uint256 i = 0; i < affixIds.length; i++) {\\n            if (affixExists(affixIds[i]) == false) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    function ritualPoolExists(\\n        uint256 ritualPoolId\\n    ) private view returns (bool) {\\n        return\\n            hatcheryRitualStorage()\\n                .ritualTemplateIdsByTemplatePoolId[ritualPoolId]\\n                .length > 0;\\n    }\\n\\n    function ritualTemplateExists(\\n        uint256 ritualTemplateId\\n    ) private view returns (bool) {\\n        BasicRitualTemplate memory basicRitualTemplate = hatcheryRitualStorage()\\n            .basicRitualTemplateByRitualTemplateId[ritualTemplateId];\\n        return\\n            basicRitualTemplate.charges > 0 || basicRitualTemplate.rarity > 0;\\n    }\\n\\n    function createRitual(uint256 ritualTemplatePoolId) internal {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        require(\\n            ritualPoolExists(ritualTemplatePoolId),\\n            \\\"LibHatcheryRituals: Pool does not exist\\\"\\n        );\\n        checkConstraints(\\n            hrs.creationConstraintsByTemplatePoolId[ritualTemplatePoolId],\\n            msg.sender\\n        );\\n        payCosts(hrs.creationCostsByTemplatePoolId[ritualTemplatePoolId]);\\n        uint256 vrfRequestId = LibRNG.requestRandomWordsFor(\\n            LibRNG.RNG_CREATE_RITUAL\\n        );\\n        saveCreateRitualData(ritualTemplatePoolId, msg.sender, vrfRequestId);\\n        emit LibEvents.BeginRitualCreation(\\n            msg.sender,\\n            ritualTemplatePoolId,\\n            vrfRequestId\\n        );\\n    }\\n\\n    function selectAndApplyAffixesSimple(\\n        uint256 ritualTemplateId,\\n        uint256 randomness\\n    ) internal returns (RitualTemplate memory) {\\n        RitualTemplate memory ritualTemplate = getRitualTemplateById(\\n            ritualTemplateId\\n        );\\n        uint256[] memory affixIdsToApply = selectAffixes(\\n            ritualTemplateId,\\n            randomness\\n        );\\n        return applyAffixes(ritualTemplate, affixIdsToApply);\\n    }\\n\\n    event ExternalErrorLog(bytes message, string key, uint256 keyvalue);\\n\\n    function createRitualFulfillRandomness(\\n        uint256 vrfRequestId,\\n        uint256 randomness\\n    ) internal {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        uint256 ritualTemplatePoolId = hrs.ritualTemplatePoolIdByVRFRequestId[\\n            vrfRequestId\\n        ];\\n        address playerWallet = hrs.playerWalletByVRFRequestId[vrfRequestId];\\n        uint256 ritualTemplateId = selectRitualTemplateFromPool(\\n            randomness,\\n            ritualTemplatePoolId\\n        );\\n        (\\n            RitualTemplate memory ritualTemplateWithAffixesApplied,\\n            uint256[] memory affixIdsApplied\\n        ) = selectAndApplyAffixes(ritualTemplateId, randomness);\\n        string memory name = LibRitualNames.getRandomName(randomness);\\n        uint256 ritualTokenId = IRitualFacet(LibDiamond.ritualsAddress())\\n            .createRitual(\\n                playerWallet, //to\\n                name, // name\\n                ritualTemplateWithAffixesApplied.rarity, //rarity\\n                ritualTemplateWithAffixesApplied.consumptionCosts, //costs\\n                ritualTemplateWithAffixesApplied.consumptionProducts, //products\\n                ritualTemplateWithAffixesApplied.consumptionConstraints, //constraints\\n                ritualTemplateWithAffixesApplied.charges, // charges\\n                ritualTemplateWithAffixesApplied.soulbound //soulbound\\n            );\\n        emit LibEvents.FinishRitualCreation(\\n                vrfRequestId,\\n                ritualTemplateId,\\n                ritualTokenId,\\n                affixIdsApplied\\n            );\\n    }\\n\\n    function selectRitualTemplateFromPool(\\n        uint256 randomness,\\n        uint256 ritualTemplatePoolId\\n    ) internal view returns (uint256) {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        uint256[] memory ritualTemplateIds = hrs\\n            .ritualTemplateIdsByTemplatePoolId[ritualTemplatePoolId];\\n        uint256[] memory weights = hrs.ritualTemplateWeightsByTemplatePoolId[\\n            ritualTemplatePoolId\\n        ];\\n        uint256 totalWeight = hrs.ritualTemplateSumWeightByTemplatePoolId[\\n            ritualTemplatePoolId\\n        ];\\n        uint256 target = LibRNG.expand(totalWeight, randomness, SALT_1);\\n        uint256 cumulativeWeight = 0;\\n        for (uint256 i = 0; i < ritualTemplateIds.length; i++) {\\n            cumulativeWeight += weights[i];\\n            if (target < cumulativeWeight) {\\n                return ritualTemplateIds[i];\\n            }\\n        }\\n    }\\n\\n    function selectAffixFromBucket(\\n        uint256 randomness,\\n        uint256 affixBucketId,\\n        uint256 salt\\n    ) private view returns (uint256) {\\n        uint256[] memory affixIds = hatcheryRitualStorage()\\n            .affixIdsByAffixBucketId[affixBucketId];\\n        mapping(uint256 => Affix) storage affixById = hatcheryRitualStorage()\\n            .affixById;\\n        uint256 totalWeight = 0;\\n        for (uint256 i = 0; i < affixIds.length; i++) {\\n            totalWeight += affixById[affixIds[i]].weight;\\n        }\\n\\n        uint256 target = LibRNG.expand(\\n            totalWeight,\\n            randomness,\\n            SALT_PER_BUCKET + salt\\n        );\\n        uint256 cumulativeWeight = 0;\\n        for (uint256 i = 0; i < affixIds.length; i++) {\\n            cumulativeWeight += affixById[affixIds[i]].weight;\\n            if (target < cumulativeWeight) {\\n                return affixIds[i];\\n            }\\n        }\\n    }\\n\\n    function selectAffixes(\\n        uint256 ritualTemplateId,\\n        uint256 randomness\\n    ) private view returns (uint256[] memory affixIdsToApply) {\\n        uint256[] storage affixBucketIds = hatcheryRitualStorage()\\n            .affixBucketIdsByRitualTemplateId[ritualTemplateId];\\n        affixIdsToApply = new uint256[](affixBucketIds.length);\\n        for (uint256 i = 0; i < affixBucketIds.length; i++) {\\n            affixIdsToApply[i] = selectAffixFromBucket(\\n                randomness,\\n                affixBucketIds[i],\\n                i\\n            );\\n        }\\n    }\\n\\n    function componentsAreEqual(\\n        LibRitualComponents.RitualComponent memory component1,\\n        LibRitualComponents.RitualComponent memory component2\\n    ) private pure returns (bool) {\\n        return\\n            component1.assetType == component2.assetType &&\\n            component1.poolId == component2.poolId &&\\n            component1.asset == component2.asset;\\n    }\\n\\n    function searchIfProductIsPresent(\\n        RitualTemplate memory ritualTemplate,\\n        LibRitualComponents.RitualProduct memory product\\n    ) private pure returns (uint256) {\\n        for (\\n            uint256 i = 0;\\n            i < ritualTemplate.consumptionProducts.length;\\n            i++\\n        ) {\\n            if (\\n                componentsAreEqual(\\n                    ritualTemplate.consumptionProducts[i].component,\\n                    product.component\\n                )\\n            ) {\\n                return i;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    function searchIfCostIsPresent(\\n        RitualTemplate memory ritualTemplate,\\n        LibRitualComponents.RitualCost memory cost\\n    ) private pure returns (uint256) {\\n        for (uint256 i = 0; i < ritualTemplate.consumptionCosts.length; i++) {\\n            if (\\n                componentsAreEqual(\\n                    ritualTemplate.consumptionCosts[i].component,\\n                    cost.component\\n                )\\n            ) {\\n                return i;\\n            }\\n        }\\n        return type(uint256).max;\\n    }\\n\\n    function applyAffix(\\n        RitualTemplate memory ritualTemplate,\\n        Affix memory affix\\n    ) internal pure returns (RitualTemplate memory resultTemplate, bool shouldEmitWarning, string memory warningText) {\\n        shouldEmitWarning = false;\\n        warningText = \\\"\\\";\\n        if (affix.affixType == AffixType.CHARGES) {\\n            if(ritualTemplate.charges == type(uint256).max) {\\n                shouldEmitWarning = true;\\n                warningText = \\\"Ignoring error: LibHatcheryRituals: Cannot add nor subtract from a ritual with type(uint256).max charges, leaving ritualTemplate.charges as is\\\";\\n            } else if (affix.isPositive) {\\n                if (affix.charges == type(uint256).max) {\\n                    // for unlimited charges\\n                    ritualTemplate.charges = type(uint256).max;\\n                } else {\\n                    ritualTemplate.charges += affix.charges;\\n                }\\n            } else {\\n                if(affix.charges == type(uint256).max) {\\n                    shouldEmitWarning = true;\\n                    warningText = \\\"Ignoring error: LibHatcheryRituals: Cannot have an affix were isPositive = false and charges = type(uint256).max, leaving ritualTemplate.charges as is\\\";\\n                } else if(ritualTemplate.charges > affix.charges) { \\n                    // ritualTemplate.charges - affix.charges > 0, thus >= 1\\n                    ritualTemplate.charges -= affix.charges;\\n                } else {\\n                    // if ritualTemplate.charges - affix.charges == 0 or is negative, then:\\n                    if(affix.charges != ritualTemplate.charges) {\\n                        shouldEmitWarning = true;\\n                        warningText = \\\"Ignoring error: LibHatcheryRituals: Cannot subtract more than the amount of charges, leaving 1 as amount of charges instead\\\";\\n                    }\\n                    ritualTemplate.charges = 1;\\n                }\\n            }\\n        } else if (affix.affixType == AffixType.CONSTRAINT) {\\n            //Constraints are only additive\\n            // Then => just add the constraint to the list\\n            ritualTemplate.consumptionConstraints = LibArray\\n                .pushToConstraintMemoryArray(\\n                    ritualTemplate.consumptionConstraints,\\n                    affix.constraint\\n                );\\n        } else if (affix.affixType == AffixType.COST) {\\n            // Costs can be new costs or old costs.\\n            uint256 costIndex = searchIfCostIsPresent(\\n                ritualTemplate,\\n                affix.cost\\n            );\\n            if (affix.isPositive) {\\n                if (costIndex == type(uint256).max) {\\n                    // If the cost is not present, we add it.\\n                    ritualTemplate.consumptionCosts = LibArray\\n                        .pushToCostMemoryArray(\\n                            ritualTemplate.consumptionCosts,\\n                            affix.cost\\n                        );\\n                } else {\\n                    // If the cost is present, we add to that cost.\\n                    ritualTemplate\\n                        .consumptionCosts[costIndex]\\n                        .component\\n                        .amount += affix.cost.component.amount;\\n                }\\n            } else {\\n                if (costIndex == type(uint256).max) {\\n                    // If the cost is not present, we fail. Cannot subtract to a cost that is not present.\\n                    shouldEmitWarning = true;\\n                    warningText = \\\"Ignoring error: LibHatcheryRituals: Cannot subtract to a cost that is not present\\\";\\n                } else {\\n                    if (\\n                        ritualTemplate\\n                            .consumptionCosts[costIndex]\\n                            .component\\n                            .amount <= affix.cost.component.amount\\n                    ) {\\n                        // If the cost is present, there is at least one cost apart from this one \\n                        // and we subtract more than the cost, we remove cost from array\\n                        if(ritualTemplate.consumptionCosts.length > 1) {\\n                            LibArray.removeFromCostMemoryArray(\\n                                ritualTemplate.consumptionCosts,\\n                                costIndex\\n                            );\\n                        } else {\\n                            // If the cost is present, there is only one cost and we subtract more than the cost, \\n                            // we ignore the removal and emit a warning.\\n                            shouldEmitWarning = true;\\n                            warningText = \\\"Ignoring error: LibHatcheryRituals: Cannot leave a ritual with no costs\\\";\\n                        }\\n                    } else {\\n                        // If the cost is present and we subtract less than the cost, we subtract\\n                        ritualTemplate\\n                            .consumptionCosts[costIndex]\\n                            .component\\n                            .amount -= affix.cost.component.amount;\\n                    }\\n                }\\n            }\\n        } else if (affix.affixType == AffixType.PRODUCT) {\\n            // Product can be new product or old product.\\n            uint256 productIndex = searchIfProductIsPresent(\\n                ritualTemplate,\\n                affix.product\\n            );\\n            if (affix.isPositive) {\\n                if (productIndex == type(uint256).max) {\\n                    // If the product is not present, we add it.\\n                    ritualTemplate.consumptionProducts = LibArray\\n                        .pushToProductMemoryArray(\\n                            ritualTemplate.consumptionProducts,\\n                            affix.product\\n                        );\\n                } else {\\n                    // If the product is present, we add to that product.\\n                    ritualTemplate\\n                        .consumptionProducts[productIndex]\\n                        .component\\n                        .amount += affix.product.component.amount;\\n                }\\n            } else {\\n                if (productIndex == type(uint256).max) {\\n                    // If the product is not present, we fail. Cannot subtract to a product that is not present.\\n                    shouldEmitWarning = true;\\n                    warningText = \\\"Ignoring error: LibHatcheryRituals: Cannot subtract to a product that is not present\\\";\\n                } else {\\n                    if (\\n                        ritualTemplate\\n                            .consumptionProducts[productIndex]\\n                            .component\\n                            .amount <= affix.product.component.amount\\n                    ) {\\n                        // If the product is present, there is at least one product apart from this one\\n                        // and we subtract more than the product, we remove product from array\\n                        if(ritualTemplate.consumptionProducts.length > 1){\\n                            LibArray.removeFromProductMemoryArray(\\n                                ritualTemplate.consumptionProducts,\\n                                productIndex\\n                            );\\n                        } else {\\n                            // If the product is present, there is only one product and we subtract more than the product,\\n                            // we ignore the removal and emit a warning.\\n                            shouldEmitWarning = true;\\n                            warningText = \\\"Ignoring error: LibHatcheryRituals: Cannot leave a ritual with no products\\\";\\n                        }\\n                    } else {\\n                        // If the product is present and we subtract less than the product, we subtract\\n                        ritualTemplate\\n                            .consumptionProducts[productIndex]\\n                            .component\\n                            .amount -= affix.product.component.amount;\\n                    }\\n                }\\n            }\\n        } else if (affix.affixType == AffixType.SOULBOUND) {\\n            //isPositive == true means that the ritual becomes soulbound\\n            //isPositive == false means that the ritual becomes not soulbound\\n            ritualTemplate.soulbound = affix.isPositive;\\n        }\\n        // implicitly: applyAffix(AffixType.NONE) => do nothing\\n        resultTemplate = ritualTemplate;\\n    }\\n\\n    function applyAffixes(\\n        RitualTemplate memory ritualTemplate,\\n        uint256[] memory affixIdsToApply\\n    ) private returns (RitualTemplate memory) {\\n        string memory warningText = \\\"\\\";\\n        bool shouldEmitWarning = false;\\n        for (uint256 i = 0; i < affixIdsToApply.length; i++) {\\n            Affix memory affix = hatcheryRitualStorage().affixById[\\n                affixIdsToApply[i]\\n            ];\\n            bool _shouldEmitWarning;\\n            string memory _warningText;\\n            RitualTemplate memory _ritualTemplate;\\n            (_ritualTemplate, _shouldEmitWarning, _warningText) = applyAffix(ritualTemplate, affix);\\n            \\n            if(_shouldEmitWarning) {\\n                shouldEmitWarning = true;\\n                warningText = string.concat(warningText, \\\" // \\\", _warningText, \\\", affixId:\\\", LibString.uintToString(affixIdsToApply[i]));\\n            }\\n        }\\n        if(shouldEmitWarning) {\\n            emit LibEvents.HatcheryAffixWarning(warningText);\\n        }\\n        return ritualTemplate;\\n    }\\n\\n    function selectAndApplyAffixes(\\n        uint256 ritualTemplateId,\\n        uint256 randomness\\n    ) internal returns (RitualTemplate memory, uint256[] memory) {\\n        RitualTemplate memory ritualTemplate = getRitualTemplateById(\\n            ritualTemplateId\\n        );\\n        uint256[] memory affixIdsToApply = selectAffixes(\\n            ritualTemplateId,\\n            randomness\\n        );\\n        return (applyAffixes(ritualTemplate, affixIdsToApply), affixIdsToApply);\\n    }\\n\\n    function getRitualTemplateById(\\n        uint256 ritualTemplateId\\n    ) internal view returns (RitualTemplate memory ritualTemplate) {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        BasicRitualTemplate memory basicRitualTemplate = hrs\\n            .basicRitualTemplateByRitualTemplateId[ritualTemplateId];\\n        ritualTemplate = RitualTemplate({\\n            rarity: basicRitualTemplate.rarity,\\n            charges: basicRitualTemplate.charges,\\n            soulbound: basicRitualTemplate.soulbound,\\n            affixBucketIds: hrs.affixBucketIdsByRitualTemplateId[\\n                ritualTemplateId\\n            ],\\n            consumptionConstraints: hrs\\n                .consumptionConstraintsByRitualTemplateId[ritualTemplateId],\\n            consumptionCosts: hrs.consumptionCostsByRitualTemplateId[\\n                ritualTemplateId\\n            ],\\n            consumptionProducts: hrs.consumptionProductsByRitualTemplateId[\\n                ritualTemplateId\\n            ]\\n        });\\n    }\\n\\n    function saveCreateRitualData(\\n        uint256 ritualTemplatePoolId,\\n        address sender,\\n        uint256 vrfRequestId\\n    ) private {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        hrs.ritualTemplatePoolIdByVRFRequestId[\\n            vrfRequestId\\n        ] = ritualTemplatePoolId;\\n        hrs.playerWalletByVRFRequestId[vrfRequestId] = sender;\\n    }\\n\\n    function getCreationConstraintsAndCosts(\\n        uint256 ritualTemplatePoolId\\n    )\\n        internal\\n        view\\n        returns (\\n            LibConstraints.Constraint[] memory constraints,\\n            LibRitualComponents.RitualCost[] memory costs\\n        )\\n    {\\n        HatcheryRitualStorage storage hrs = hatcheryRitualStorage();\\n        constraints = hrs.creationConstraintsByTemplatePoolId[\\n            ritualTemplatePoolId\\n        ];\\n        costs = hrs.creationCostsByTemplatePoolId[ritualTemplatePoolId];\\n    }\\n\\n    //  Clone an Affix template into a generic instance for use in a ritual\\n    function instantiateAffixDefinition(\\n        uint256 affixId,\\n        uint256 weight\\n    ) internal view returns (Affix memory) {\\n        return hatcheryRitualStorage().affixById[affixId];\\n        // return Affix(\\n        //     template.affixType,\\n        //     template.isPositive,\\n        //     template.charges,\\n        //     template.cost,\\n        //     template.product,\\n        //     template.constraint,\\n        //     template.weight\\n        // );\\n        // }\\n    }\\n\\n    function mintInnateRitualsToInnateOwnerAccount(\\n        address _innateOwnerAccount\\n    ) internal {\\n        /*\\n            Baseline template ids:\\n            - 1: Pyrofiend (T1 Baseline Fire Minion)\\n            - 2: Swamplix (T1 Baseline Slime Minion)\\n            - 3: Shockwisp (T1 Baseline Volt Minion)\\n            - 4: Sorciphant (T1 Baseline Soul Minion)\\n            - 5: Stargrub (T1 Baseline Nebula Minion)\\n            - 6: Shadow Forge Key\\n         */\\n        uint8[6] memory innateRitualTemplateIds = [1, 2, 3, 4, 5, 6];\\n        string[6] memory innateRitualTemplateNames = [\\n            \\\"Pyrofiend Ritual\\\",\\n            \\\"Swamplix Ritual\\\",\\n            \\\"Shockwisp Ritual\\\",\\n            \\\"Sorciphant Ritual\\\",\\n            \\\"Stargrub Ritual\\\",\\n            \\\"Shadow Forge Key Ritual\\\"\\n        ];\\n\\n        for (uint256 i = 0; i < innateRitualTemplateIds.length; i++) {\\n            RitualTemplate memory ritualTemplate = getRitualTemplateById(\\n                innateRitualTemplateIds[i]\\n            );\\n            string memory name = innateRitualTemplateNames[i];\\n            IRitualFacet(LibDiamond.ritualsAddress()).createRitual(\\n                _innateOwnerAccount, //to\\n                name, // name\\n                ritualTemplate.rarity, //rarity\\n                ritualTemplate.consumptionCosts, //costs\\n                ritualTemplate.consumptionProducts, //products\\n                ritualTemplate.consumptionConstraints, //constraints\\n                ritualTemplate.charges, // charges\\n                ritualTemplate.soulbound //soulbound\\n            );\\n        }\\n    }\\n\\n    // function initializeAffixes() internal {\\n\\n    // }\\n    // function initializeAffixBuckets() internal {\\n    //     // bucketId = nextAffixBucketId();\\n    //     // affixBucketIdToAffixIds\\n    // }\\n    // function initializeRitualTemplates() internal {\\n\\n    // }\\n    // function initializeRitualPools() internal {\\n\\n    // }\\n}\\n\\n// // ERC20 Cost\\n//         // Makes the recipe cheaper or more expensive\\n//         uint256 id = nextAffixId();\\n//         Affix memory addERC20CostAffix = Affix({\\n//             affixType: AffixType.COST,\\n//             isPositive: true,\\n//             component: LibRitualComponents.RitualComponents({\\n//                 amount: 1000,\\n//                 assetType: 20,\\n//                 poolId: 0,\\n//                 // TODO: FIX THIS\\n//                 asset: address(0)\\n//             }),\\n//             constraint: LibConstraints.Constraint({\\n//                 ritualConstraintType: LibConstraints.ConstraintType.NONE,\\n//                 operator: LibOperators.Operator.NONE,\\n//                 value: 0\\n//             }),\\n//             weight: 10\\n//         });\\n//         affixById[id] = addERC20CostAffix;\\n\\n//         id = nextAffixId();\\n//         Affix memory removeERC20CostAffix = Affix({\\n//             affixType: AffixType.COST,\\n//             isPositive: false,\\n//             component: LibRitualComponents.RitualComponents({\\n//                 amount: 1000,\\n//                 assetType: 20,\\n//                 poolId: 0,\\n//                 // TODO: FIX THIS\\n//                 asset: address(0)\\n//             }),\\n//             constraint: LibConstraints.Constraint({\\n//                 ritualConstraintType: LibConstraints.ConstraintType.NONE,\\n//                 operator: LibOperators.Operator.NONE,\\n//                 value: 0\\n//             }),\\n//             weight: 10\\n//         });\\n//         affixById[id] = removeERC20CostAffix;\\n\\n//         // ERC1155 Cost\\n//         // Makes the recipe cheaper or more expensive\\n\\n//         id = nextAffixId();\\n//         Affix memory addERC1155CostAffix = Affix({\\n//             affixType: AffixType.COST,\\n//             isPositive: false,\\n//             component: LibRitualComponents.RitualComponents({\\n//                 amount: 1000,\\n//                 assetType: 1155,\\n//                 poolId: 0,\\n//                 // TODO: FIX THIS\\n//                 asset: address(0)\\n//             }),\\n//             constraint: LibConstraints.Constraint({\\n//                 ritualConstraintType: LibConstraints.ConstraintType.NONE,\\n//                 operator: LibOperators.Operator.NONE,\\n//                 value: 0\\n//             }),\\n//             weight: 10\\n//         });\\n//         affixById[id] = addERC1155CostAffix;\\n\\n//         id = nextAffixId();\\n//         Affix memory removeERC1155CostAffix = Affix({\\n//             affixType: AffixType.COST,\\n//             isPositive: false,\\n//             component: LibRitualComponents.RitualComponents({\\n//                 amount: 1000,\\n//                 assetType: 1155,\\n//                 poolId: 0,\\n//                 // TODO: FIX THIS\\n//                 asset: address(0)\\n//             }),\\n//             constraint: LibConstraints.Constraint({\\n//                 ritualConstraintType: LibConstraints.ConstraintType.NONE,\\n//                 operator: LibOperators.Operator.NONE,\\n//                 value: 0\\n//             }),\\n//             weight: 10\\n//         });\\n//         affixById[id] = removeERC1155CostAffix;\\n\\n//         // ERC20 Product\\n//         // Makes the recipe produce more or less\\n\\n//         id = nextAffixId();\\n//         Affix memory addERC20ProductAffix = Affix({\\n//             affixType: AffixType.PRODUCT,\\n//             isPositive: true,\\n//             component: LibRitualComponents.RitualComponents({\\n//                 amount: 1000,\\n//                 assetType: 20,\\n//                 poolId: 0,\\n//                 // TODO: FIX THIS\\n//                 asset: address(0)\\n//             }),\\n//             constraint: LibConstraints.Constraint({\\n//                 ritualConstraintType: LibConstraints.ConstraintType.NONE,\\n//                 operator: LibOperators.Operator.NONE,\\n//                 value: 0\\n//             }),\\n//             weight: 10\\n//         });\\n//         affixById[id] = addERC20ProductAffix;\\n\\n//         id = nextAffixId();\\n//         Affix memory removeERC20ProdcutAffix = Affix({\\n//             affixType: AffixType.COST,\\n//             isPositive: false,\\n//             component: LibRitualComponents.RitualComponents({\\n//                 amount: 1000,\\n//                 assetType: 20,\\n//                 poolId: 0,\\n//                 // TODO: FIX THIS\\n//                 asset: address(0)\\n//             }),\\n//             constraint: LibConstraints.Constraint({\\n//                 ritualConstraintType: LibConstraints.ConstraintType.NONE,\\n//                 operator: LibOperators.Operator.NONE,\\n//                 value: 0\\n//             }),\\n//             weight: 10\\n//         });\\n//         affixById[id] = removeERC20ProdcutAffix;\\n\\n//         // ERC1155 Product\\n//         // Makes the recipe produce more or less\\n\\n//         // Charges\\n//         // Add or remove recipe charges\\n\\n//         // Hatchery Level\\n//         // Add constraint: Recipe only works when hatchery level is >= n\\n\\n//         id = nextAffixId();\\n//         Affix memory addHatcheryLevelConstraintAffix = Affix({\\n//             affixType: AffixType.CONSTRAINT,\\n//             componentIsPositive: false,\\n//             component: LibRitualComponents.RitualComponents({\\n//                 amount: 0,\\n//                 assetType: 0,\\n//                 poolId: 0,\\n//                 asset: address(0)\\n//             }),\\n//             constraint: LibConstraints.Constraint({\\n//                 ritualConstraintType: LibConstraints.ConstraintType.HATCHERY_LEVEL,\\n//                 operator: LibConstraintOperator.ConstraintOperator.NONE,\\n//                 value: 5\\n//             }),\\n//             weight: 10\\n//         });\\n//         affixById[id] = addHatcheryLevelConstraintAffix;\\n\\n//         // Prestige Level\\n//         // Add constraint: Recipe only works when prestige level is >= n\\n\\n//         // Shadowcorn Balance\\n//         // Add constraint: Recipe only works when owner has n Shadowcorns\\n\\n//         // Shadowcorn Rarity\\n//         // Add constraint: Recipe only works when owner has Shadowcorn of n rarity\\n\\n//         // Unicorn 1155 Balance\\n//         // Add constraint: Recipe only works when owner has n of a Unicorn item (eg. badges, lootboxes)\\n\\n//         // Shadowcorn 1155 Balance\\n//         // Add constraint: Recipe only works when owner has n of a Shadowcorn item (eg. Rift crystals, SC badges)\\n\\n//         // Soulbound\\n//         // Add Soulbound flag to Ritual (non-transferable)\\n\"\r\n    },\r\n    \"LibHatcheryRitualConstraints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {IConstraintFacet} from \\\"IConstraintFacet.sol\\\";\\nimport {LibConstraintOperator} from \\\"LibConstraintOperator.sol\\\";\\nimport {LibConstraints} from \\\"LibConstraints.sol\\\";\\nimport {LibLevel} from \\\"LibLevel.sol\\\";\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibStaking} from \\\"LibStaking.sol\\\";\\n\\nlibrary LibHatcheryRitualConstraints {\\n    // @notice This function is used to check a constraint.\\n    // @param constraint The constraint to check.\\n    function checkConstraint(LibConstraints.Constraint memory constraint, address user) internal view {\\n        LibConstraints.enforceValidConstraintType(constraint.constraintType);\\n        LibConstraints.ConstraintType constraintType = LibConstraints.ConstraintType(constraint.constraintType);\\n        if(constraintType == LibConstraints.ConstraintType.HATCHERY_LEVEL) {\\n            require(checkHatcheryLevelConstraint(constraint.operator, constraint.value, user), \\\"LibHatcheryRitualConstraints: hatchery level constraint not met.\\\");\\n        } else if (constraintType >= LibConstraints.ConstraintType.SHADOWCORN_RARITY \\n        && constraintType <= LibConstraints.ConstraintType.SHADOWCORN_ARCANA \\n        || constraintType == LibConstraints.ConstraintType.BALANCE_SHADOWCORN) {\\n            require(checkShadowcornConstraint(constraint, user), \\\"LibHatcheryRitualConstraints: shadowcorn constraint not met.\\\");\\n        } else if (constraintType == LibConstraints.ConstraintType.BALANCE_UNICORN) {\\n            require(checkUnicornBalanceConstraint(constraint, user), \\\"LibHatcheryRitualConstraints: unicorn balance constraint not met.\\\");\\n        }\\n    }\\n\\n    // @notice This function is used to check if the user meets the hatchery level constraint.\\n    // @param operator The conditional operator that will be checked against the constraintType\\n    // @param value The value that will be checked with the operator against the constraintType\\n    function checkHatcheryLevelConstraint(uint256 operator, uint256 value, address user) internal view returns (bool){\\n        return LibConstraintOperator.checkOperator(LibLevel.getHatcheryLevelForAddress(user), operator, value);\\n    }\\n\\n    // @notice This function is used to check if the user meets a shadowcorn constraint.\\n    // @param constraint The constraint to check.\\n    function checkShadowcornConstraint(LibConstraints.Constraint memory constraint, address user) internal view returns (bool) {\\n        return IConstraintFacet(LibDiamond.shadowcornAddress()).checkConstraintForUserAndExtraTokens(user, constraint, LibStaking.stakingStorage().userToStakedShadowcorns[user]);\\n    }\\n\\n    // @notice This function is used to check if the user meets the unicorn balance constraint.\\n    // @param operator The conditional operator that will be checked against the constraintType\\n    // @param value The value that will be checked with the operator against the constraintType\\n    function checkUnicornBalanceConstraint(LibConstraints.Constraint memory constraint, address user) internal view returns (bool) {\\n        return IConstraintFacet(LibDiamond.unicornAddress()).checkConstraint(user, constraint);\\n    }\\n}\\n\"\r\n    },\r\n    \"IConstraintFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibConstraints} from \\\"LibConstraints.sol\\\";\\n\\ninterface IConstraintFacet {\\n    \\n    /// @notice Check if constraint for an owner is met\\n    /// @dev This uses @lg-commons/LibConstraintOperator to check. \\n    /// @param owner The owner to check\\n    /// @param constraint The constraint to check, must be one of the constraint types and operators defined in @lg-commons/LibConstraintOperator\\n    /// @return isMet True if the constraint is met, false otherwise\\n    function checkConstraint(address owner, LibConstraints.Constraint memory constraint) external view returns (bool);\\n\\n    /// @notice Check if constraint for an owner or for the extraTokens is met\\n    /// @dev This uses @lg-commons/LibConstraintOperator to check. \\n    /// @param owner Will check if the constraint is met any tokens owned by this address \\n    /// @param constraint The constraint to check, must be one of the constraint types and operators defined in @lg-commons/LibConstraintOperator\\n    /// @param extraTokenIdsToCheck Will check if the constraint is met for these extra token ids\\n    /// @return isMet True if the constraint is met, false otherwise\\n    function checkConstraintForUserAndExtraTokens(address owner, LibConstraints.Constraint memory constraint, uint256[] memory extraTokenIdsToCheck) external view returns (bool);\\n\\n}\"\r\n    },\r\n    \"LibConstraints.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary LibConstraints {\\n\\n    /// @notice This Constraints are used to check if the user meets \\n    //  certain requirements to mint rituals or consume charges from \\n    //  a ritual in the minion hatchery\\n    //  @param constraintType What will the constraint check against\\n    //  @param operator The conditional operator that will be checked against the constraintType\\n    //  @param value The value that will be checked with the operator against the constraintType\\n    struct Constraint {\\n        uint128 constraintType;\\n        uint128 operator;\\n        uint256 value;\\n    }\\n\\n    //DO NOT REORDER THIS VALUES\\n    enum ConstraintType {\\n        NONE,                           //0\\n        HATCHERY_LEVEL,                 //1\\n        SHADOWCORN_RARITY,              //2\\n        SHADOWCORN_CLASS,               //3\\n        SHADOWCORN_BALANCE,             //4\\n        SHADOWCORN_MIGHT,               //5\\n        SHADOWCORN_WICKEDNESS,          //6\\n        SHADOWCORN_TENACITY,            //7\\n        SHADOWCORN_CUNNING,             //8\\n        SHADOWCORN_ARCANA,              //9\\n        BALANCE_UNICORN,                //10\\n        BALANCE_SHADOWCORN              //11\\n    }\\n\\n    // @notice This function is used to check if a constraint type is valid.\\n    // @param constraintType The constraint type to check.\\n    function enforceValidConstraintType(uint256 constraintType) internal pure {\\n        require(constraintType <= uint(type(ConstraintType).max), \\\"LibConstraints: invalid constraint type.\\\");\\n    }\\n}\"\r\n    },\r\n    \"LibConstraintOperator.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary LibConstraintOperator {\\n\\n    //DO NOT REORDER THIS VALUES\\n    enum ConstraintOperator {\\n        NONE,                   //0\\n        LESS_THAN,              //1 (<)\\n        LESS_THAN_OR_EQUAL,     //2 (<=)\\n        EQUAL,                  //3 (=)\\n        GREATER_THAN_OR_EQUAL,  //4 (>=)\\n        GREATER_THAN,           //5 (>)\\n        NOT_EQUAL               //6 (!=)\\n    }\\n\\n    /*\\n        @title Enforce valid operator\\n        @notice This function will revert if the operator is not valid\\n        @param operator The operator to check\\n     */\\n    function enforceValidOperator(uint256 operator) internal pure {\\n        require(\\n            operator <= uint(type(ConstraintOperator).max),\\n            \\\"LibConstraintOperator: invalid constraint operator.\\\"\\n        );\\n    }\\n\\n    /*\\n        @title Check mathematical operator against two values\\n        @notice This function will return whether the condition for the mathematical operator and the given values is true or false.\\n        @dev This function will revert if the operator is NONE or not valid.\\n        @param leftValue The first value that we need to compare with the other value parameter for the given mathematical operator.\\n        @param operator The operator to check (=, >, <, >=, <=, !=)\\n        @param rightValue The second value to check\\n        @return bool Whether the operator condition for the given values is true or false.\\n     */\\n    function checkOperator(\\n        uint256 leftValue,\\n        uint256 operator,\\n        uint256 rightValue\\n    ) internal pure returns (bool) {\\n        enforceValidOperator(operator);\\n\\n        ConstraintOperator castedOperator = ConstraintOperator(operator);\\n        require(castedOperator != ConstraintOperator.NONE, \\\"LibConstraintOperator: Operator should not be NONE.\\\");\\n\\n        if (castedOperator == ConstraintOperator.LESS_THAN) {\\n            return leftValue < rightValue;\\n        }\\n        if (castedOperator == ConstraintOperator.LESS_THAN_OR_EQUAL) {\\n            return leftValue <= rightValue;\\n        }\\n        if (castedOperator == ConstraintOperator.EQUAL) {\\n            return leftValue == rightValue;\\n        }\\n        if (castedOperator == ConstraintOperator.GREATER_THAN_OR_EQUAL) {\\n            return leftValue >= rightValue;\\n        }\\n        if (castedOperator == ConstraintOperator.GREATER_THAN) {\\n            return leftValue > rightValue;\\n        }\\n        if (castedOperator == ConstraintOperator.NOT_EQUAL) {\\n            return leftValue != rightValue;\\n        }\\n\\n        revert(\\\"LibConstraintOperator: Invalid operator.\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"LibLevel.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {IERC20} from \\\"IERC20.sol\\\";\\nimport {ERC20Burnable} from \\\"ERC20Burnable.sol\\\";\\nimport {IERC721} from \\\"IERC721.sol\\\";\\nimport {ERC721Burnable} from \\\"ERC721Burnable.sol\\\";\\n\\nimport {LevelUnlockCost} from \\\"LevelUnlockCost.sol\\\";\\nimport {LibConstraintOperator} from \\\"LibConstraintOperator.sol\\\";\\nimport {LevelUpgradeBonus} from \\\"LevelUpgradeBonus.sol\\\";\\nimport {LevelUpgradeBonusType} from \\\"LevelUpgradeBonusType.sol\\\";\\nimport {LevelUpgradeBonusFrequency} from \\\"LevelUpgradeBonusFrequency.sol\\\";\\nimport {LibRitualData} from \\\"LibRitualData.sol\\\";\\nimport {LevelUnlockCostTokenTransferType} from \\\"LevelUnlockCostTokenTransferType.sol\\\";\\nimport {Component} from \\\"Component.sol\\\";\\nimport {TerminusFacet} from \\\"TerminusFacet.sol\\\";\\nimport {ERC1155, IERC1155} from \\\"ERC1155.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\nimport {LibValidate} from \\\"LibValidate.sol\\\";\\nimport {LibRitualValidate} from \\\"LibRitualValidate.sol\\\";\\nimport {LibToken} from \\\"LibToken.sol\\\";\\n\\n/// @notice LibLevel\\n/// @author Facundo Vidal\\n/// @dev Implementation of Minion Hatchery leveling\\nlibrary LibLevel {\\n    uint256 private constant HATCHERY_LEVEL_MIN = 1;\\n\\n    bytes32 private constant HATCHERY_LEVEL_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.HatcheryLevel.Storage\\\");\\n\\n    /// @dev Do not modify the ordering of this struct once it has been deployed.\\n    /// @dev If you need to add new fields, add them to the end.\\n    struct LibLevelStorage {\\n        // Maps each user to their current level. If the user is level 1, the user might not be in this map.\\n        mapping(address => uint256) userToHatcheryLevel;\\n        // The maximum level that the hatchery can reach.\\n        uint256 hatcheryLevelCap;\\n        // Unlocking costs for each level\\n        mapping(uint256 => LevelUnlockCost[]) hatcheryLevelToUnlockCosts;\\n        // **DEPRECATED: DONT DELETE THIS, KEEP STORAGE ORDER!** Available farm slots and bonuses for each level\\n        mapping(uint256 => uint256) hatcheryLevelToUpgradeFarmSlots;\\n        // **DEPRECATED: DONT DELETE THIS, KEEP STORAGE ORDER!** Bonuses for each level\\n        mapping(uint256 => LevelUpgradeBonus[]) hatcheryLevelToUpgradeBonuses;\\n        // **DEPRECATED: DONT DELETE THIS, KEEP STORAGE ORDER!** Available rituals for each level\\n        mapping(uint256 => LibRitualData.BasicRitual[]) hatcheryLevelToUpgradeRituals;\\n    }\\n\\n    function levelStorage()\\n        internal\\n        pure\\n        returns (LibLevelStorage storage lrs)\\n    {\\n        bytes32 position = HATCHERY_LEVEL_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            lrs.slot := position\\n        }\\n    }\\n\\n    /// @notice Set the unlocking costs for an specific hatchery level\\n    /// @notice This function will be used to set the unlocking costs for each level.\\n    /// @dev When setting the costs for an specific level, the previous costs will be deleted\\n    /// @dev There are multiple parallel arrays instead of a single array to prevent big nested structs array.\\n    /// @param _hatcheryLevel The level that will be unlocked\\n    /// @param _transferTypes The type of transfer that will be used for the cost (BURN, TRANSFER)\\n    /// @param _amounts The amount of tokens that will be used for the cost\\n    /// @param _assetTypes The type of asset that will be used for the cost (ERC20, ERC721, ERC1155)\\n    /// @param _assets The address of the asset that will be used for the cost\\n    /// @param _poolIds The pool id of the asset that will be used for the cost\\n    function setHatcheryLevelUnlockCosts(\\n        uint256 _hatcheryLevel,\\n        uint256[] memory _transferTypes,\\n        uint128[] memory _amounts,\\n        uint128[] memory _assetTypes,\\n        address[] memory _assets,\\n        uint256[] memory _poolIds\\n    ) internal {\\n        // Enforce that all the parameter array lengths are the same\\n        require(\\n            _amounts.length == _assetTypes.length &&\\n                _assetTypes.length == _assets.length &&\\n                _assets.length == _poolIds.length &&\\n                _poolIds.length == _transferTypes.length,\\n            \\\"LibLevel: parameter array lengths must be the same.\\\"\\n        );\\n\\n        // Clear old costs for level\\n        delete levelStorage().hatcheryLevelToUnlockCosts[_hatcheryLevel];\\n\\n        for (uint256 i = 0; i < _amounts.length; i++) {\\n            enforceValidTransferType(_transferTypes[i]);\\n            enforceValidAssetType(_assetTypes[i]);    \\n            addHatcheryLevelUnlockCost(\\n                _hatcheryLevel,\\n                LevelUnlockCostTokenTransferType(_transferTypes[i]),\\n                _amounts[i],\\n                _assetTypes[i],\\n                _assets[i],\\n                _poolIds[i]\\n            );\\n        }\\n    }\\n\\n    /// @notice Enforce valid asset type\\n    /// @notice This function will revert if the asset type is not valid\\n    /// @param _assetType The asset type\\n    function enforceValidAssetType(uint256 _assetType) private pure {\\n        require(\\n            _assetType == LibToken.TYPE_ERC20 ||\\n                _assetType == LibToken.TYPE_ERC721 ||\\n                _assetType == LibToken.TYPE_ERC1155,\\n            \\\"LibComponents: Invalid asset type.\\\"\\n        );\\n    }\\n   \\n    ///  @notice Unlock next hatchery level\\n    ///  @dev This function is called when a user wants to unlock the next hatchery level\\n    ///  @dev This function will revert if the user has reached the level cap\\n    ///  @dev This function will revert if the user has not unlocked the previous level\\n    function unlockNextHatcheryLevel() internal {\\n        // Get the current level\\n        uint256 currentLevel = getHatcheryLevelForAddress(msg.sender);\\n\\n        // Get the next level\\n        uint256 nextLevel = currentLevel + 1;\\n\\n        // Get the level cap\\n        uint256 levelCap = getHatcheryLevelCap();\\n\\n        // Check if the user has reached the level cap\\n        require(\\n            currentLevel < levelCap,\\n            \\\"LibLevel: User has reached the level cap\\\"\\n        );\\n\\n        LibLevelStorage storage llStorage = levelStorage();\\n\\n        // Get new level costs\\n        LevelUnlockCost[] memory newLevelCosts = llStorage\\n            .hatcheryLevelToUnlockCosts[nextLevel];\\n\\n        for (uint256 i = 0; i < newLevelCosts.length; i++) {\\n            // Get the cost\\n            LevelUnlockCost memory newLevelCost = newLevelCosts[i];\\n\\n            if (newLevelCost.component.assetType == LibToken.TYPE_ERC20) {\\n                consumeERC20Cost(\\n                    newLevelCost.component.amount,\\n                    newLevelCost.component.asset,\\n                    newLevelCost.transferType\\n                );\\n            } else if (\\n                newLevelCost.component.assetType == LibToken.TYPE_ERC721\\n            ) {\\n                // TODO: implement ERC721 usage and adapt Component structure to support it.\\n                revert(\\\"LibLevel: ERC721 for costs was not implemented yet\\\");\\n            } else if (\\n                newLevelCost.component.assetType == LibToken.TYPE_ERC1155\\n            ) {\\n                consumeERC1155Cost(\\n                    newLevelCost.component.amount,\\n                    newLevelCost.component.asset,\\n                    newLevelCost.transferType,\\n                    newLevelCost.component.poolId\\n                );\\n            }\\n        }\\n\\n        // Unlock the next level\\n        llStorage.userToHatcheryLevel[msg.sender] = nextLevel;\\n\\n        emit LibEvents.HatcheryLevelUnlocked(\\n            msg.sender,\\n            currentLevel,\\n            nextLevel\\n        );\\n    }\\n\\n    /// @notice Consume ERC20 cost for hatchery leveling\\n    /// @notice This function will consume the ERC20 cost for hatchery leveling\\n    /// @dev This function will revert if the transfer type is invalid\\n    /// @param _amount The amount of ERC20 tokens to consume\\n    /// @param _asset The address of the ERC20 token\\n    /// @param _transferType The transfer type (BURN, TRANSFER)\\n    function consumeERC20Cost(\\n        uint256 _amount,\\n        address _asset,\\n        LevelUnlockCostTokenTransferType _transferType\\n    ) internal {\\n        if (_transferType == LevelUnlockCostTokenTransferType.BURN) {\\n            // Burn the tokens\\n            ERC20Burnable(_asset).burnFrom(msg.sender, _amount);\\n            return;\\n        } else if (\\n            _transferType == LevelUnlockCostTokenTransferType.TRANSFER\\n        ) {\\n            // Transfer the tokens to the game bank\\n            IERC20(_asset).transferFrom(\\n                msg.sender,\\n                LibDiamond.gameBankAddress(),\\n                _amount\\n            );\\n            return;\\n        }\\n\\n        revert(\\\"LibLevel: Invalid transfer type\\\");\\n    }\\n\\n    /// @notice Consume ERC1155 cost for hatchery leveling\\n    /// @notice This function will consume the ERC1155 or Terminus token cost for hatchery leveling\\n    /// @dev This function will revert if the transfer type is invalid\\n    /// @param _amount The amount of ERC1155/Terminus tokens to consume\\n    /// @param _asset The address of the ERC1155/Terminus token\\n    /// @param _transferType The transfer type (Only BURN is supported)\\n    /// @param _poolId The pool id\\n    function consumeERC1155Cost(\\n        uint256 _amount,\\n        address _asset,\\n        LevelUnlockCostTokenTransferType _transferType,\\n        uint256 _poolId\\n    ) internal {\\n        if (_transferType == LevelUnlockCostTokenTransferType.BURN) {\\n            // Burn the tokens\\n            TerminusFacet(_asset).burn(msg.sender, _poolId, _amount);\\n            return;\\n        }\\n\\n        revert(\\\"LibLevel: Invalid transfer type\\\");\\n    }\\n\\n    /// @notice Get the costs to unlock an specific hatchery level\\n    /// @param _hatcheryLevel The level\\n    /// @return Array of costs with token type and quantity\\n    function getHatcheryLevelUnlockCosts(\\n        uint256 _hatcheryLevel\\n    ) internal view returns (LevelUnlockCost[] memory) {\\n        return levelStorage().hatcheryLevelToUnlockCosts[_hatcheryLevel];\\n    }\\n\\n    /// @notice Add a cost for a hatchery level\\n    /// @notice This function is used to add a cost to an specific level\\n    /// @dev This function can only be called by the contract owner\\n    /// @param _hatcheryLevel The level to set the cost for\\n    /// @param _transferType The type of transfer that will be used for the cost (BURN, TRANSFER)\\n    /// @param _amount The amount of the cost\\n    /// @param _assetType The type of asset that will be used for the cost (0: ERC20, 1: ERC1155, 2: ERC721)\\n    /// @param _asset The asset of the cost\\n    /// @param _poolId The pool id of the cost (0 if the asset is not ERC1155/Terminus)\\n    function addHatcheryLevelUnlockCost(\\n        uint256 _hatcheryLevel,\\n        LevelUnlockCostTokenTransferType _transferType,\\n        uint128 _amount,\\n        uint128 _assetType,\\n        address _asset,\\n        uint256 _poolId\\n    ) internal {\\n        enforceValidAssetType(_assetType);\\n\\n        LibValidate.enforceNonZeroAddress(_asset);\\n\\n        if (_assetType == LibToken.TYPE_ERC1155) {\\n            // Require transferType = BURN since we are not supporting transfer for ERC1155/Terminus tokens.\\n            require(\\n                _transferType == LevelUnlockCostTokenTransferType.BURN,\\n                \\\"LibLevel: must use transfer type BURN for ERC1155 or Terminus assets.\\\"\\n            );\\n\\n            require(\\n                _poolId > 0,\\n                \\\"LibLevel: must assign a pool id to a level cost with asset type ERC1155.\\\"\\n            );\\n        }\\n\\n        // Push unlock cost to level\\n        levelStorage().hatcheryLevelToUnlockCosts[_hatcheryLevel].push(\\n            LevelUnlockCost({\\n                component: Component({\\n                    amount: _amount,\\n                    assetType: _assetType,\\n                    asset: _asset,\\n                    poolId: _poolId\\n                }),\\n                transferType: _transferType\\n            })\\n        );\\n    }\\n\\n    /// @notice Get the hatchery level cap\\n    /// @dev This function will return the minimum level if the level cap is 0\\n    /// @return The level cap\\n    function getHatcheryLevelCap() internal view returns (uint256) {\\n        // Get the level cap\\n        uint256 levelCap = levelStorage().hatcheryLevelCap;\\n\\n        // If the level cap is 0, return the minimum level cap\\n        return (levelCap == 0) ? HATCHERY_LEVEL_MIN : levelCap;\\n    }\\n\\n    /// @notice Set the hatchery level cap\\n    /// @dev This function will revert if the level cap is 0\\n    /// @param _hatcheryLevelCap The level cap\\n    function setHatcheryLevelCap(uint256 _hatcheryLevelCap) internal {\\n        require(\\n            _hatcheryLevelCap > HATCHERY_LEVEL_MIN,\\n            \\\"LibLevel: Level cap must be greater than the minimum level\\\"\\n        );\\n\\n        levelStorage().hatcheryLevelCap = _hatcheryLevelCap;\\n    }\\n\\n    /// @notice Get the hatchery level for an address\\n    /// @param _user The address of the user\\n    /// @dev If the user has not been initialized, it returns 1.\\n    /// @return The current level of the user\\n    function getHatcheryLevelForAddress(\\n        address _user\\n    ) internal view returns (uint256) {\\n        uint256 level = levelStorage().userToHatcheryLevel[_user];\\n\\n        // If the user has not been initialized, it has level 1\\n        return (level == 0) ? 1 : level;\\n    }\\n\\n    /// @notice Enforces valid level\\n    /// @dev This function will revert if the level is not valid\\n    /// @param _hatcheryLevel The level to validate\\n    function enforceValidLevel(uint256 _hatcheryLevel) internal view {\\n        require(\\n            _hatcheryLevel >= HATCHERY_LEVEL_MIN && _hatcheryLevel <= getHatcheryLevelCap(),\\n            \\\"LibLevel: Level must be greater than or equal to the minimum level\\\"\\n        );\\n    }\\n\\n    /// @notice Enforces valid transfer type for token\\n    /// @dev This function will revert if the transfer type is not valid\\n    /// @param _transferType The transfer type to validate\\n    function enforceValidTransferType(uint256 _transferType) internal pure {\\n        require(\\n            _transferType == uint(LevelUnlockCostTokenTransferType.BURN) ||\\n                _transferType ==\\n                uint(LevelUnlockCostTokenTransferType.TRANSFER),\\n            \\\"LibLevel: Invalid transfer type\\\"\\n        );\\n    }\\n\\n    /// @notice Resets hatchery level\\n    /// @dev This function should only be called on local or testnet for debugging purposes\\n    /// @param user The address of the user\\n    function resetHatcheryLevel(address user) internal {\\n        levelStorage().userToHatcheryLevel[user] = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"ERC20.sol\\\";\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 currentAllowance = allowance(account, _msgSender());\\n        require(currentAllowance >= amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(account, _msgSender(), currentAllowance - amount);\\n        }\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"IERC20Metadata.sol\\\";\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        unchecked {\\n            _approve(sender, _msgSender(), currentAllowance - amount);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[sender] = senderBalance - amount;\\n        }\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n\\n        _afterTokenTransfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"ERC721Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"ERC721.sol\\\";\\nimport \\\"Context.sol\\\";\\n\\n/**\\n * @title ERC721 Burnable Token\\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\\n */\\nabstract contract ERC721Burnable is Context, ERC721 {\\n    /**\\n     * @dev Burns `tokenId`. See {ERC721-_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own `tokenId` or be an approved operator.\\n     */\\n    function burn(uint256 tokenId) public virtual {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721Burnable: caller is not owner nor approved\\\");\\n        _burn(tokenId);\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC721.sol\\\";\\nimport \\\"IERC721Receiver.sol\\\";\\nimport \\\"IERC721Metadata.sol\\\";\\nimport \\\"Address.sol\\\";\\nimport \\\"Context.sol\\\";\\nimport \\\"Strings.sol\\\";\\nimport \\\"ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\\n * {ERC721Enumerable}.\\n */\\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\\n    using Address for address;\\n    using Strings for uint256;\\n\\n    // Token name\\n    string private _name;\\n\\n    // Token symbol\\n    string private _symbol;\\n\\n    // Mapping from token ID to owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    // Mapping owner address to token count\\n    mapping(address => uint256) private _balances;\\n\\n    // Mapping from token ID to approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // Mapping from owner to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    /**\\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-balanceOf}.\\n     */\\n    function balanceOf(address owner) public view virtual override returns (uint256) {\\n        require(owner != address(0), \\\"ERC721: balance query for the zero address\\\");\\n        return _balances[owner];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-ownerOf}.\\n     */\\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"ERC721: owner query for nonexistent token\\\");\\n        return owner;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-name}.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-symbol}.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {IERC721Metadata-tokenURI}.\\n     */\\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\\n        require(_exists(tokenId), \\\"ERC721Metadata: URI query for nonexistent token\\\");\\n\\n        string memory baseURI = _baseURI();\\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\\n     * by default, can be overriden in child contracts.\\n     */\\n    function _baseURI() internal view virtual returns (string memory) {\\n        return \\\"\\\";\\n    }\\n\\n    /**\\n     * @dev See {IERC721-approve}.\\n     */\\n    function approve(address to, uint256 tokenId) public virtual override {\\n        address owner = ERC721.ownerOf(tokenId);\\n        require(to != owner, \\\"ERC721: approval to current owner\\\");\\n\\n        require(\\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\\n            \\\"ERC721: approve caller is not owner nor approved for all\\\"\\n        );\\n\\n        _approve(to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-getApproved}.\\n     */\\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\\n        require(_exists(tokenId), \\\"ERC721: approved query for nonexistent token\\\");\\n\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(operator != _msgSender(), \\\"ERC721: approve to caller\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[owner][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC721-transferFrom}.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        //solhint-disable-next-line max-line-length\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) public virtual override {\\n        safeTransferFrom(from, to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev See {IERC721-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) public virtual override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"ERC721: transfer caller is not owner nor approved\\\");\\n        _safeTransfer(from, to, tokenId, _data);\\n    }\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\\n     *\\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _transfer(from, to, tokenId);\\n        require(_checkOnERC721Received(from, to, tokenId, _data), \\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n    }\\n\\n    /**\\n     * @dev Returns whether `tokenId` exists.\\n     *\\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\\n     *\\n     * Tokens start existing when they are minted (`_mint`),\\n     * and stop existing when they are burned (`_burn`).\\n     */\\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n    /**\\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\\n        require(_exists(tokenId), \\\"ERC721: operator query for nonexistent token\\\");\\n        address owner = ERC721.ownerOf(tokenId);\\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\\n    }\\n\\n    /**\\n     * @dev Safely mints `tokenId` and transfers it to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _safeMint(address to, uint256 tokenId) internal virtual {\\n        _safeMint(to, tokenId, \\\"\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\\n     */\\n    function _safeMint(\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal virtual {\\n        _mint(to, tokenId);\\n        require(\\n            _checkOnERC721Received(address(0), to, tokenId, _data),\\n            \\\"ERC721: transfer to non ERC721Receiver implementer\\\"\\n        );\\n    }\\n\\n    /**\\n     * @dev Mints `tokenId` and transfers it to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must not exist.\\n     * - `to` cannot be the zero address.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _mint(address to, uint256 tokenId) internal virtual {\\n        require(to != address(0), \\\"ERC721: mint to the zero address\\\");\\n        require(!_exists(tokenId), \\\"ERC721: token already minted\\\");\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Destroys `tokenId`.\\n     * The approval is cleared when the token is burned.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _burn(uint256 tokenId) internal virtual {\\n        address owner = ERC721.ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        // Clear approvals\\n        _approve(address(0), tokenId);\\n\\n        _balances[owner] -= 1;\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n    }\\n\\n    /**\\n     * @dev Transfers `tokenId` from `from` to `to`.\\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {\\n        require(ERC721.ownerOf(tokenId) == from, \\\"ERC721: transfer of token that is not own\\\");\\n        require(to != address(0), \\\"ERC721: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        // Clear approvals from the previous owner\\n        _approve(address(0), tokenId);\\n\\n        _balances[from] -= 1;\\n        _balances[to] += 1;\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Approve `to` to operate on `tokenId`\\n     *\\n     * Emits a {Approval} event.\\n     */\\n    function _approve(address to, uint256 tokenId) internal virtual {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    /**\\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\\n     * The call is not executed if the target address is not a contract.\\n     *\\n     * @param from address representing the previous owner of the given token ID\\n     * @param to target address that will receive the tokens\\n     * @param tokenId uint256 ID of the token to be transferred\\n     * @param _data bytes optional data to send along with the call\\n     * @return bool whether the call correctly returned the expected magic value\\n     */\\n    function _checkOnERC721Received(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) private returns (bool) {\\n        if (to.isContract()) {\\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\\n                return retval == IERC721Receiver.onERC721Received.selector;\\n            } catch (bytes memory reason) {\\n                if (reason.length == 0) {\\n                    revert(\\\"ERC721: transfer to non ERC721Receiver implementer\\\");\\n                } else {\\n                    assembly {\\n                        revert(add(32, reason), mload(reason))\\n                    }\\n                }\\n            }\\n        } else {\\n            return true;\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\\n     * transferred to `to`.\\n     * - When `from` is zero, `tokenId` will be minted for `to`.\\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"IERC721Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"IERC721Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    },\r\n    \"LevelUnlockCost.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nimport {Component} from \\\"Component.sol\\\";\\nimport {LevelUnlockCostTokenTransferType} from \\\"LevelUnlockCostTokenTransferType.sol\\\";\\n\\n/*\\n    @title Level Unlock Cost\\n    @notice This struct is used to define the cost of unlocking each level\\n    @param component The component that is required to unlock the level\\n    @param transferType The type of transfer that will be used for the cost (BURN, TRANSFER)\\n */\\nstruct LevelUnlockCost {\\n    Component component;\\n    LevelUnlockCostTokenTransferType transferType;\\n}\\n\"\r\n    },\r\n    \"Component.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nstruct Component {\\n    address asset; //address of the asset\\n    uint256 poolId; //poolId is for ERC1155 assets, doesn't need to be assigned for non 1155\\n    uint128 amount;\\n    uint128 assetType; //20 = ERC20, 721 = ERC721, 1155 = ERC1155\\n}\\n\"\r\n    },\r\n    \"LevelUnlockCostTokenTransferType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nenum LevelUnlockCostTokenTransferType {\\n    NONE, //0\\n    BURN, //1\\n    TRANSFER //2\\n}\\n\"\r\n    },\r\n    \"LevelUpgradeBonus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nimport {LevelUpgradeBonusType} from \\\"LevelUpgradeBonusType.sol\\\";\\nimport {LevelUpgradeBonusFrequency} from \\\"LevelUpgradeBonusFrequency.sol\\\";\\n\\n/*\\n    @title Level Upgrade Bonus\\n    @notice This struct is used to define the upgrade bonus for each level\\n    @dev Examples of bonuses:\\n    +1 Dark Mark per hour\\n        bonusType = HUSK_GENERATION\\n        bonusValue = 1\\n        bonusFrequency = HOURLY\\n    +10 Husk storage cap\\n        bonusType = HUSK_STORAGE\\n        bonusValue = 10\\n        bonusFrequency = PERMANENT\\n*/\\n// TODO(fvidal): review this struct to see if it matches the design specs\\nstruct LevelUpgradeBonus {\\n    LevelUpgradeBonusType bonusType;\\n    uint256 bonusValue;\\n    LevelUpgradeBonusFrequency bonusFrequency;\\n}\"\r\n    },\r\n    \"LevelUpgradeBonusType.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\n\\nenum LevelUpgradeBonusType {\\n    NONE,\\n    HUSK_GENERATION,\\n    DARK_MARK_GENERATION,\\n    HUSK_STORAGE\\n}\"\r\n    },\r\n    \"LevelUpgradeBonusFrequency.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nenum LevelUpgradeBonusFrequency {\\n    NONE, //0\\n    PERMANENT, //1\\n    HOURLY, //2\\n    DAILY //3\\n}\\n\"\r\n    },\r\n    \"LibRitualData.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {LibRitualComponents} from \\\"LibRitualComponents.sol\\\";\\nimport {LibConstraints} from \\\"LibConstraints.sol\\\";\\n\\nlibrary LibRitualData {\\n    ///   @dev Basic rituals just hold basic data in order to easily handle the storage.\\n    ///   @param name The ritual's name\\n    ///   @param rarity The ritual's rarity expressed in integer value.\\n    ///   @param charges The amount of times the ritual can consume a charge to exchange costs for products.\\n    ///   @param soulbound Flag to indicate if the ritual is soulbound or not.\\n    struct BasicRitual {\\n        string name;\\n        uint8 rarity;\\n        uint256 charges;\\n        bool soulbound;\\n    }\\n\\n    ///   @dev Rituals are the return data type, they hold the entire storage in a single struct.\\n    ///   @param name The ritual's name\\n    ///   @param rarity The ritual's rarity expressed in integer value.\\n    ///   @param costs The costs to pay to consume a ritual charge expressed in components.\\n    ///   @param products The outcome of consuming a ritual charge expressed in components.\\n    ///   @param constraints The restrictions to consume a ritual charge expressed in constraints.\\n    ///   @param charges The amount of times the ritual can consume a charge to exchange costs for products.\\n    ///   @param soulbound Flag to indicate if the ritual is soulbound or not.\\n    struct Ritual {\\n        string name;\\n        uint8 rarity;\\n        LibRitualComponents.RitualCost[] costs; \\n        LibRitualComponents.RitualProduct[] products; \\n        LibConstraints.Constraint[] constraints;\\n        uint256 charges;\\n        bool soulbound;\\n    }\\n}\\n \"\r\n    },\r\n    \"LibRitualComponents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary LibRitualComponents {\\n\\n    /// @notice Components are the costs and products of the rituals\\n    //  both share the same format, a component can be either a cost or a product.\\n    //  @param amount The amount of a certain asset (applies for erc20 and 1155)\\n    //  @param assetType The ERC type 20 = ERC20, 721 = ERC721, 1155 = ERC1155\\n    //  @param asset The address of the asset\\n    //  @param poolId The poolId of the ERC1155 asset (only applies in that case)\\n    struct RitualComponent {\\n        uint256 amount;\\n        uint128 assetType;         \\n        uint128 poolId;  \\n        address asset;              \\n    }\\n\\n    // @notice This enum contains the different transfer types for costs.\\n    enum RitualCostTransferType {\\n        NONE,\\n        BURN,\\n        TRANSFER\\n    }\\n\\n    // @notice This enum contains the different transfer types for products.\\n    enum RitualProductTransferType {\\n        NONE,\\n        MINT,\\n        TRANSFER\\n    }\\n\\n    // @notice RitualCosts contain components and transfer types for the costs themselves.\\n    // @param component The component of the cost.\\n    // @param transferType The transfer type of the cost.\\n    struct RitualCost {\\n        RitualComponent component;\\n        RitualCostTransferType transferType;\\n    }\\n\\n    // @notice RitualProducts contain components and transfer types for the products themselves.\\n    // @param component The component of the product.\\n    // @param transferType The transfer type of the product.\\n    struct RitualProduct {\\n        RitualComponent component;\\n        RitualProductTransferType transferType;\\n    }\\n}\"\r\n    },\r\n    \"TerminusFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/**\\n * Authors: Moonstream Engineering (engineering@moonstream.to)\\n * GitHub: https://github.com/bugout-dev/dao\\n *\\n * This is an implementation of the Terminus decentralized authorization contract.\\n *\\n * Terminus users can create authorization pools. Each authorization pool has the following properties:\\n * 1. Controller: The address that controls the pool. Initially set to be the address of the pool creator.\\n * 2. Pool URI: Metadata URI for the authorization pool.\\n * 3. Pool capacity: The total number of tokens that can be minted in that authorization pool.\\n * 4. Pool supply: The number of tokens that have actually been minted in that authorization pool.\\n * 5. Transferable: A boolean value which denotes whether or not tokens from that pool can be transfered\\n *    between addresses. (Note: Implemented by TerminusStorage.poolNotTransferable since we expect most\\n *    pools to be transferable. This negation is better for storage + gas since false is default value\\n *    in map to bool.)\\n * 6. Burnable: A boolean value which denotes whether or not tokens from that pool can be burned.\\n */\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC20.sol\\\";\\nimport \\\"ERC1155WithTerminusStorage.sol\\\";\\nimport \\\"LibTerminus.sol\\\";\\nimport \\\"LibDiamond.sol\\\";\\n\\ncontract TerminusFacet is ERC1155WithTerminusStorage {\\n    constructor() {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.controller = msg.sender;\\n    }\\n\\n    event PoolMintBatch(\\n        uint256 indexed id,\\n        address indexed operator,\\n        address from,\\n        address[] toAddresses,\\n        uint256[] amounts\\n    );\\n\\n    function poolMintBatch(\\n        uint256 id,\\n        address[] memory toAddresses,\\n        uint256[] memory amounts\\n    ) public {\\n        address operator = _msgSender();\\n        LibTerminus.enforcePoolIsController(id, operator);\\n        require(\\n            toAddresses.length == amounts.length,\\n            \\\"TerminusFacet: _poolMintBatch -- toAddresses and amounts length mismatch\\\"\\n        );\\n\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n\\n        uint256 i = 0;\\n        uint256 totalAmount = 0;\\n\\n        for (i = 0; i < toAddresses.length; i++) {\\n            address to = toAddresses[i];\\n            uint256 amount = amounts[i];\\n            require(\\n                to != address(0),\\n                \\\"TerminusFacet: _poolMintBatch -- cannot mint to zero address\\\"\\n            );\\n            totalAmount += amount;\\n            ts.poolBalances[id][to] += amount;\\n            emit TransferSingle(operator, address(0), to, id, amount);\\n        }\\n\\n        require(\\n            ts.poolSupply[id] + totalAmount <= ts.poolCapacity[id],\\n            \\\"TerminusFacet: _poolMintBatch -- Minted tokens would exceed pool capacity\\\"\\n        );\\n        ts.poolSupply[id] += totalAmount;\\n\\n        emit PoolMintBatch(id, operator, address(0), toAddresses, amounts);\\n    }\\n\\n    function terminusController() external view returns (address) {\\n        return LibTerminus.terminusStorage().controller;\\n    }\\n\\n    function paymentToken() external view returns (address) {\\n        return LibTerminus.terminusStorage().paymentToken;\\n    }\\n\\n    function setPaymentToken(address newPaymentToken) external {\\n        LibTerminus.enforceIsController();\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.paymentToken = newPaymentToken;\\n    }\\n\\n    function poolBasePrice() external view returns (uint256) {\\n        return LibTerminus.terminusStorage().poolBasePrice;\\n    }\\n\\n    function setPoolBasePrice(uint256 newBasePrice) external {\\n        LibTerminus.enforceIsController();\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.poolBasePrice = newBasePrice;\\n    }\\n\\n    function _paymentTokenContract() internal view returns (IERC20) {\\n        address paymentTokenAddress = LibTerminus\\n            .terminusStorage()\\n            .paymentToken;\\n        require(\\n            paymentTokenAddress != address(0),\\n            \\\"TerminusFacet: Payment token has not been set\\\"\\n        );\\n        return IERC20(paymentTokenAddress);\\n    }\\n\\n    function withdrawPayments(address toAddress, uint256 amount) external {\\n        LibTerminus.enforceIsController();\\n        require(\\n            _msgSender() == toAddress,\\n            \\\"TerminusFacet: withdrawPayments -- Controller can only withdraw to self\\\"\\n        );\\n        IERC20 paymentTokenContract = _paymentTokenContract();\\n        paymentTokenContract.transfer(toAddress, amount);\\n    }\\n\\n    function setURI(uint256 poolID, string memory poolURI) external {\\n        LibTerminus.enforcePoolIsController(poolID, _msgSender());\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.poolURI[poolID] = poolURI;\\n    }\\n\\n    function totalPools() external view returns (uint256) {\\n        return LibTerminus.terminusStorage().currentPoolID;\\n    }\\n\\n    function setPoolController(uint256 poolID, address newController) external {\\n        LibTerminus.enforcePoolIsController(poolID, msg.sender);\\n        LibTerminus.setPoolController(poolID, newController);\\n    }\\n\\n    function terminusPoolController(uint256 poolID)\\n        external\\n        view\\n        returns (address)\\n    {\\n        return LibTerminus.terminusStorage().poolController[poolID];\\n    }\\n\\n    function terminusPoolCapacity(uint256 poolID)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return LibTerminus.terminusStorage().poolCapacity[poolID];\\n    }\\n\\n    function terminusPoolSupply(uint256 poolID)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        return LibTerminus.terminusStorage().poolSupply[poolID];\\n    }\\n\\n    function createSimplePool(uint256 _capacity) external returns (uint256) {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        uint256 requiredPayment = ts.poolBasePrice;\\n        IERC20 paymentTokenContract = _paymentTokenContract();\\n        require(\\n            paymentTokenContract.allowance(_msgSender(), address(this)) >=\\n                requiredPayment,\\n            \\\"TerminusFacet: createSimplePool -- Insufficient allowance on payment token\\\"\\n        );\\n        paymentTokenContract.transferFrom(\\n            msg.sender,\\n            address(this),\\n            requiredPayment\\n        );\\n        return LibTerminus.createSimplePool(_capacity);\\n    }\\n\\n    function createPoolV1(\\n        uint256 _capacity,\\n        bool _transferable,\\n        bool _burnable\\n    ) external returns (uint256) {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        // TODO(zomglings): Implement requiredPayment update based on pool features.\\n        uint256 requiredPayment = ts.poolBasePrice;\\n        IERC20 paymentTokenContract = _paymentTokenContract();\\n        require(\\n            paymentTokenContract.allowance(_msgSender(), address(this)) >=\\n                requiredPayment,\\n            \\\"TerminusFacet: createPoolV1 -- Insufficient allowance on payment token\\\"\\n        );\\n        paymentTokenContract.transferFrom(\\n            msg.sender,\\n            address(this),\\n            requiredPayment\\n        );\\n        uint256 poolID = LibTerminus.createSimplePool(_capacity);\\n        if (!_transferable) {\\n            ts.poolNotTransferable[poolID] = true;\\n        }\\n        if (_burnable) {\\n            ts.poolBurnable[poolID] = true;\\n        }\\n        return poolID;\\n    }\\n\\n    function mint(\\n        address to,\\n        uint256 poolID,\\n        uint256 amount,\\n        bytes memory data\\n    ) external {\\n        LibTerminus.enforcePoolIsController(poolID, msg.sender);\\n        _mint(to, poolID, amount, data);\\n    }\\n\\n    function mintBatch(\\n        address to,\\n        uint256[] memory poolIDs,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) external {\\n        for (uint256 i = 0; i < poolIDs.length; i++) {\\n            LibTerminus.enforcePoolIsController(poolIDs[i], _msgSender());\\n        }\\n        _mintBatch(to, poolIDs, amounts, data);\\n    }\\n\\n    function burn(\\n        address from,\\n        uint256 poolID,\\n        uint256 amount\\n    ) external {\\n        address operator = _msgSender();\\n        require(\\n            operator == from || isApprovedForPool(poolID, operator),\\n            \\\"TerminusFacet: burn -- caller is neither owner nor approved\\\"\\n        );\\n        _burn(from, poolID, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC1155WithTerminusStorage.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/**\\n * Authors: Moonstream Engineering (engineering@moonstream.to)\\n * GitHub: https://github.com/bugout-dev/dao\\n *\\n * An ERC1155 implementation which uses the Moonstream DAO common storage structure for proxies.\\n * EIP1155: https://eips.ethereum.org/EIPS/eip-1155\\n *\\n * The Moonstream contract is used to delegate calls from an EIP2535 Diamond proxy.\\n *\\n * This implementation is adapted from the OpenZeppelin ERC1155 implementation:\\n * https://github.com/OpenZeppelin/openzeppelin-contracts/tree/6bd6b76d1156e20e45d1016f355d154141c7e5b9/contracts/token/ERC1155\\n */\\n\\npragma solidity ^0.8.9;\\n\\nimport \\\"IERC1155.sol\\\";\\nimport \\\"IERC1155Receiver.sol\\\";\\nimport \\\"IERC1155MetadataURI.sol\\\";\\nimport \\\"Address.sol\\\";\\nimport \\\"Context.sol\\\";\\nimport \\\"ERC165.sol\\\";\\nimport \\\"LibTerminus.sol\\\";\\n\\ncontract ERC1155WithTerminusStorage is\\n    Context,\\n    ERC165,\\n    IERC1155,\\n    IERC1155MetadataURI\\n{\\n    using Address for address;\\n\\n    constructor() {}\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        view\\n        virtual\\n        override(ERC165, IERC165)\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    function uri(uint256 poolID)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (string memory)\\n    {\\n        return LibTerminus.terminusStorage().poolURI[poolID];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256)\\n    {\\n        require(\\n            account != address(0),\\n            \\\"ERC1155WithTerminusStorage: balance query for the zero address\\\"\\n        );\\n        return LibTerminus.terminusStorage().poolBalances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(\\n            accounts.length == ids.length,\\n            \\\"ERC1155WithTerminusStorage: accounts and ids length mismatch\\\"\\n        );\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved)\\n        public\\n        virtual\\n        override\\n    {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (bool)\\n    {\\n        return\\n            LibTerminus.terminusStorage().globalOperatorApprovals[account][\\n                operator\\n            ];\\n    }\\n\\n    function isApprovedForPool(uint256 poolID, address operator)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return LibTerminus._isApprovedForPool(poolID, operator);\\n    }\\n\\n    function approveForPool(uint256 poolID, address operator) external {\\n        LibTerminus.enforcePoolIsController(poolID, _msgSender());\\n        LibTerminus._approveForPool(poolID, operator);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() ||\\n                isApprovedForAll(from, _msgSender()) ||\\n                isApprovedForPool(id, _msgSender()),\\n            \\\"ERC1155WithTerminusStorage: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155WithTerminusStorage: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            to != address(0),\\n            \\\"ERC1155WithTerminusStorage: transfer to the zero address\\\"\\n        );\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        require(\\n            !ts.poolNotTransferable[id],\\n            \\\"ERC1155WithTerminusStorage: _safeTransferFrom -- pool is not transferable\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            from,\\n            to,\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            data\\n        );\\n\\n        uint256 fromBalance = ts.poolBalances[id][from];\\n        require(\\n            fromBalance >= amount,\\n            \\\"ERC1155WithTerminusStorage: insufficient balance for transfer\\\"\\n        );\\n        unchecked {\\n            ts.poolBalances[id][from] = fromBalance - amount;\\n        }\\n        ts.poolBalances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155WithTerminusStorage: ids and amounts length mismatch\\\"\\n        );\\n        require(\\n            to != address(0),\\n            \\\"ERC1155WithTerminusStorage: transfer to the zero address\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = ts.poolBalances[id][from];\\n            require(\\n                fromBalance >= amount,\\n                \\\"ERC1155WithTerminusStorage: insufficient balance for transfer\\\"\\n            );\\n            unchecked {\\n                ts.poolBalances[id][from] = fromBalance - amount;\\n            }\\n            ts.poolBalances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            operator,\\n            from,\\n            to,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            to != address(0),\\n            \\\"ERC1155WithTerminusStorage: mint to the zero address\\\"\\n        );\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        require(\\n            ts.poolSupply[id] + amount <= ts.poolCapacity[id],\\n            \\\"ERC1155WithTerminusStorage: _mint -- Minted tokens would exceed pool capacity\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            address(0),\\n            to,\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            data\\n        );\\n\\n        ts.poolSupply[id] += amount;\\n        ts.poolBalances[id][to] += amount;\\n        emit TransferSingle(operator, address(0), to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(\\n            operator,\\n            address(0),\\n            to,\\n            id,\\n            amount,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(\\n            to != address(0),\\n            \\\"ERC1155WithTerminusStorage: mint to the zero address\\\"\\n        );\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155WithTerminusStorage: ids and amounts length mismatch\\\"\\n        );\\n\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            require(\\n                ts.poolSupply[ids[i]] + amounts[i] <= ts.poolCapacity[ids[i]],\\n                \\\"ERC1155WithTerminusStorage: _mintBatch -- Minted tokens would exceed pool capacity\\\"\\n            );\\n        }\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            ts.poolSupply[ids[i]] += amounts[i];\\n            ts.poolBalances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(\\n            operator,\\n            address(0),\\n            to,\\n            ids,\\n            amounts,\\n            data\\n        );\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `from`\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `from` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(\\n            from != address(0),\\n            \\\"ERC1155WithTerminusStorage: burn from the zero address\\\"\\n        );\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        require(\\n            ts.poolBurnable[id],\\n            \\\"ERC1155WithTerminusStorage: _burn -- pool is not burnable\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(\\n            operator,\\n            from,\\n            address(0),\\n            _asSingletonArray(id),\\n            _asSingletonArray(amount),\\n            \\\"\\\"\\n        );\\n\\n        uint256 fromBalance = ts.poolBalances[id][from];\\n        require(\\n            fromBalance >= amount,\\n            \\\"ERC1155WithTerminusStorage: burn amount exceeds balance\\\"\\n        );\\n        unchecked {\\n            ts.poolBalances[id][from] = fromBalance - amount;\\n            ts.poolSupply[id] -= amount;\\n        }\\n\\n        emit TransferSingle(operator, from, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(\\n            from != address(0),\\n            \\\"ERC1155WithTerminusStorage: burn from the zero address\\\"\\n        );\\n        require(\\n            ids.length == amounts.length,\\n            \\\"ERC1155WithTerminusStorage: ids and amounts length mismatch\\\"\\n        );\\n\\n        address operator = _msgSender();\\n\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            require(\\n                ts.poolBurnable[ids[i]],\\n                \\\"ERC1155WithTerminusStorage: _burnBatch -- pool is not burnable\\\"\\n            );\\n        }\\n\\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = ts.poolBalances[id][from];\\n            require(\\n                fromBalance >= amount,\\n                \\\"ERC1155WithTerminusStorage: burn amount exceeds balance\\\"\\n            );\\n            unchecked {\\n                ts.poolBalances[id][from] = fromBalance - amount;\\n                ts.poolSupply[id] -= amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, from, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Approve `operator` to operate on all of `owner` tokens\\n     *\\n     * Emits a {ApprovalForAll} event.\\n     */\\n    function _setApprovalForAll(\\n        address owner,\\n        address operator,\\n        bool approved\\n    ) internal virtual {\\n        require(\\n            owner != operator,\\n            \\\"ERC1155WithTerminusStorage: setting approval status for self\\\"\\n        );\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.globalOperatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155Received(\\n                    operator,\\n                    from,\\n                    id,\\n                    amount,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\n                        \\\"ERC1155WithTerminusStorage: ERC1155Receiver rejected tokens\\\"\\n                    );\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\n                    \\\"ERC1155WithTerminusStorage: transfer to non ERC1155Receiver implementer\\\"\\n                );\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try\\n                IERC1155Receiver(to).onERC1155BatchReceived(\\n                    operator,\\n                    from,\\n                    ids,\\n                    amounts,\\n                    data\\n                )\\n            returns (bytes4 response) {\\n                if (\\n                    response != IERC1155Receiver.onERC1155BatchReceived.selector\\n                ) {\\n                    revert(\\n                        \\\"ERC1155WithTerminusStorage: ERC1155Receiver rejected tokens\\\"\\n                    );\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\n                    \\\"ERC1155WithTerminusStorage: transfer to non ERC1155Receiver implementer\\\"\\n                );\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element)\\n        private\\n        pure\\n        returns (uint256[] memory)\\n    {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155 is IERC165 {\\n    /**\\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\\n     */\\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\\n\\n    /**\\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\\n     * transfers.\\n     */\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] values\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\\n     * `approved`.\\n     */\\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\\n     *\\n     * If an {URI} event was emitted for `id`, the standard\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\\n     * returned by {IERC1155MetadataURI-uri}.\\n     */\\n    event URI(string value, uint256 indexed id);\\n\\n    /**\\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\\n        external\\n        view\\n        returns (uint256[] memory);\\n\\n    /**\\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `operator` cannot be the caller.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\\n     *\\n     * See {setApprovalForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"IERC1155Receiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n        @dev Handles the receipt of a single ERC1155 token type. This function is\\n        called at the end of a `safeTransferFrom` after the balance has been updated.\\n        To accept the transfer, this must return\\n        `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n        (i.e. 0xf23a6e61, or its own function selector).\\n        @param operator The address which initiated the transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param id The ID of the token being transferred\\n        @param value The amount of tokens being transferred\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n        @dev Handles the receipt of a multiple ERC1155 token types. This function\\n        is called at the end of a `safeBatchTransferFrom` after the balances have\\n        been updated. To accept the transfer(s), this must return\\n        `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n        (i.e. 0xbc197c81, or its own function selector).\\n        @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n        @param from The address which previously owned the token\\n        @param ids An array containing ids of each token being transferred (order and length must match values array)\\n        @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n        @param data Additional data with no specified format\\n        @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n    */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"IERC1155MetadataURI.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC1155.sol\\\";\\n\\n/**\\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\\n *\\n * _Available since v3.1._\\n */\\ninterface IERC1155MetadataURI is IERC1155 {\\n    /**\\n     * @dev Returns the URI for token type `id`.\\n     *\\n     * If the `\\\\{id\\\\}` substring is present in the URI, it must be replaced by\\n     * clients with the actual token type ID.\\n     */\\n    function uri(uint256 id) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"LibTerminus.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Apache-2.0\\n\\n/**\\n * Authors: Moonstream Engineering (engineering@moonstream.to)\\n * GitHub: https://github.com/bugout-dev/dao\\n *\\n * Common storage structure and internal methods for Moonstream DAO Terminus contracts.\\n * As Terminus is an extension of ERC1155, this library can also be used to implement bare ERC1155 contracts\\n * using the common storage pattern (e.g. for use in diamond proxies).\\n */\\n\\n// TODO(zomglings): Should we support EIP1761 in addition to ERC1155 or roll our own scopes and feature flags?\\n// https://eips.ethereum.org/EIPS/eip-1761\\n\\npragma solidity ^0.8.9;\\n\\nlibrary LibTerminus {\\n    bytes32 constant TERMINUS_STORAGE_POSITION =\\n        keccak256(\\\"moonstreamdao.eth.storage.terminus\\\");\\n\\n    struct TerminusStorage {\\n        // Terminus administration\\n        address controller;\\n        bool isTerminusActive;\\n        uint256 currentPoolID;\\n        address paymentToken;\\n        uint256 poolBasePrice;\\n        // Terminus pools\\n        mapping(uint256 => address) poolController;\\n        mapping(uint256 => string) poolURI;\\n        mapping(uint256 => uint256) poolCapacity;\\n        mapping(uint256 => uint256) poolSupply;\\n        mapping(uint256 => mapping(address => uint256)) poolBalances;\\n        mapping(uint256 => bool) poolNotTransferable;\\n        mapping(uint256 => bool) poolBurnable;\\n        mapping(address => mapping(address => bool)) globalOperatorApprovals;\\n        mapping(uint256 => mapping(address => bool)) globalPoolOperatorApprovals;\\n    }\\n\\n    function terminusStorage()\\n        internal\\n        pure\\n        returns (TerminusStorage storage es)\\n    {\\n        bytes32 position = TERMINUS_STORAGE_POSITION;\\n        assembly {\\n            es.slot := position\\n        }\\n    }\\n\\n    event ControlTransferred(\\n        address indexed previousController,\\n        address indexed newController\\n    );\\n\\n    event PoolControlTransferred(\\n        uint256 indexed poolID,\\n        address indexed previousController,\\n        address indexed newController\\n    );\\n\\n    function setController(address newController) internal {\\n        TerminusStorage storage ts = terminusStorage();\\n        address previousController = ts.controller;\\n        ts.controller = newController;\\n        emit ControlTransferred(previousController, newController);\\n    }\\n\\n    function enforceIsController() internal view {\\n        TerminusStorage storage ts = terminusStorage();\\n        require(msg.sender == ts.controller, \\\"LibTerminus: Must be controller\\\");\\n    }\\n\\n    function setTerminusActive(bool active) internal {\\n        TerminusStorage storage ts = terminusStorage();\\n        ts.isTerminusActive = active;\\n    }\\n\\n    function setPoolController(uint256 poolID, address newController) internal {\\n        TerminusStorage storage ts = terminusStorage();\\n        address previousController = ts.poolController[poolID];\\n        ts.poolController[poolID] = newController;\\n        emit PoolControlTransferred(poolID, previousController, newController);\\n    }\\n\\n    function createSimplePool(uint256 _capacity) internal returns (uint256) {\\n        TerminusStorage storage ts = terminusStorage();\\n        uint256 poolID = ts.currentPoolID + 1;\\n        setPoolController(poolID, msg.sender);\\n        ts.poolCapacity[poolID] = _capacity;\\n        ts.currentPoolID++;\\n        return poolID;\\n    }\\n\\n    function enforcePoolIsController(uint256 poolID, address maybeController)\\n        internal\\n        view\\n    {\\n        TerminusStorage storage ts = terminusStorage();\\n        require(\\n            ts.poolController[poolID] == maybeController,\\n            \\\"LibTerminus: Must be pool controller\\\"\\n        );\\n    }\\n\\n    function _isApprovedForPool(uint256 poolID, address operator)\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        if (operator == ts.poolController[poolID]) {\\n            return true;\\n        } else if (ts.globalPoolOperatorApprovals[poolID][operator]) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    function _approveForPool(uint256 poolID, address operator) internal {\\n        LibTerminus.TerminusStorage storage ts = LibTerminus.terminusStorage();\\n        ts.globalPoolOperatorApprovals[poolID][operator] = true;\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC1155.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"IERC1155.sol\\\";\\nimport \\\"IERC1155Receiver.sol\\\";\\nimport \\\"IERC1155MetadataURI.sol\\\";\\nimport \\\"Address.sol\\\";\\nimport \\\"Context.sol\\\";\\nimport \\\"ERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the basic standard multi-token.\\n * See https://eips.ethereum.org/EIPS/eip-1155\\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\\n *\\n * _Available since v3.1._\\n */\\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\\n    using Address for address;\\n\\n    // Mapping from token ID to account balances\\n    mapping(uint256 => mapping(address => uint256)) private _balances;\\n\\n    // Mapping from account to operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\\n    string private _uri;\\n\\n    /**\\n     * @dev See {_setURI}.\\n     */\\n    constructor(string memory uri_) {\\n        _setURI(uri_);\\n    }\\n\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\\n        return\\n            interfaceId == type(IERC1155).interfaceId ||\\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\\n            super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155MetadataURI-uri}.\\n     *\\n     * This implementation returns the same URI for *all* token types. It relies\\n     * on the token type ID substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * Clients calling this function must replace the `\\\\{id\\\\}` substring with the\\n     * actual token type ID.\\n     */\\n    function uri(uint256) public view virtual override returns (string memory) {\\n        return _uri;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOf}.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\\n        require(account != address(0), \\\"ERC1155: balance query for the zero address\\\");\\n        return _balances[id][account];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-balanceOfBatch}.\\n     *\\n     * Requirements:\\n     *\\n     * - `accounts` and `ids` must have the same length.\\n     */\\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        override\\n        returns (uint256[] memory)\\n    {\\n        require(accounts.length == ids.length, \\\"ERC1155: accounts and ids length mismatch\\\");\\n\\n        uint256[] memory batchBalances = new uint256[](accounts.length);\\n\\n        for (uint256 i = 0; i < accounts.length; ++i) {\\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\\n        }\\n\\n        return batchBalances;\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-setApprovalForAll}.\\n     */\\n    function setApprovalForAll(address operator, bool approved) public virtual override {\\n        require(_msgSender() != operator, \\\"ERC1155: setting approval status for self\\\");\\n\\n        _operatorApprovals[_msgSender()][operator] = approved;\\n        emit ApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-isApprovedForAll}.\\n     */\\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\\n        return _operatorApprovals[account][operator];\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeTransferFrom}.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: caller is not owner nor approved\\\"\\n        );\\n        _safeTransferFrom(from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev See {IERC1155-safeBatchTransferFrom}.\\n     */\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual override {\\n        require(\\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\\n            \\\"ERC1155: transfer caller is not owner nor approved\\\"\\n        );\\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        uint256 fromBalance = _balances[id][from];\\n        require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n        unchecked {\\n            _balances[id][from] = fromBalance - amount;\\n        }\\n        _balances[id][to] += amount;\\n\\n        emit TransferSingle(operator, from, to, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\\n     *\\n     * Emits a {TransferBatch} event.\\n     *\\n     * Requirements:\\n     *\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n        require(to != address(0), \\\"ERC1155: transfer to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; ++i) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 fromBalance = _balances[id][from];\\n            require(fromBalance >= amount, \\\"ERC1155: insufficient balance for transfer\\\");\\n            unchecked {\\n                _balances[id][from] = fromBalance - amount;\\n            }\\n            _balances[id][to] += amount;\\n        }\\n\\n        emit TransferBatch(operator, from, to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Sets a new URI for all token types, by relying on the token type ID\\n     * substitution mechanism\\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\\n     *\\n     * By this mechanism, any occurrence of the `\\\\{id\\\\}` substring in either the\\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\\n     * clients with the token type ID.\\n     *\\n     * For example, the `https://token-cdn-domain/\\\\{id\\\\}.json` URI would be\\n     * interpreted by clients as\\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\\n     * for token type ID 0x4cce0.\\n     *\\n     * See {uri}.\\n     *\\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\\n     * this function emits no events.\\n     */\\n    function _setURI(string memory newuri) internal virtual {\\n        _uri = newuri;\\n    }\\n\\n    /**\\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `account`.\\n     *\\n     * Emits a {TransferSingle} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - If `account` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\\n     * acceptance magic value.\\n     */\\n    function _mint(\\n        address account,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: mint to the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), account, _asSingletonArray(id), _asSingletonArray(amount), data);\\n\\n        _balances[id][account] += amount;\\n        emit TransferSingle(operator, address(0), account, id, amount);\\n\\n        _doSafeTransferAcceptanceCheck(operator, address(0), account, id, amount, data);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\\n     * acceptance magic value.\\n     */\\n    function _mintBatch(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {\\n        require(to != address(0), \\\"ERC1155: mint to the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            _balances[ids[i]][to] += amounts[i];\\n        }\\n\\n        emit TransferBatch(operator, address(0), to, ids, amounts);\\n\\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens of token type `id` from `account`\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens of token type `id`.\\n     */\\n    function _burn(\\n        address account,\\n        uint256 id,\\n        uint256 amount\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), _asSingletonArray(id), _asSingletonArray(amount), \\\"\\\");\\n\\n        uint256 accountBalance = _balances[id][account];\\n        require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[id][account] = accountBalance - amount;\\n        }\\n\\n        emit TransferSingle(operator, account, address(0), id, amount);\\n    }\\n\\n    /**\\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\\n     *\\n     * Requirements:\\n     *\\n     * - `ids` and `amounts` must have the same length.\\n     */\\n    function _burnBatch(\\n        address account,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal virtual {\\n        require(account != address(0), \\\"ERC1155: burn from the zero address\\\");\\n        require(ids.length == amounts.length, \\\"ERC1155: ids and amounts length mismatch\\\");\\n\\n        address operator = _msgSender();\\n\\n        _beforeTokenTransfer(operator, account, address(0), ids, amounts, \\\"\\\");\\n\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            uint256 accountBalance = _balances[id][account];\\n            require(accountBalance >= amount, \\\"ERC1155: burn amount exceeds balance\\\");\\n            unchecked {\\n                _balances[id][account] = accountBalance - amount;\\n            }\\n        }\\n\\n        emit TransferBatch(operator, account, address(0), ids, amounts);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any token transfer. This includes minting\\n     * and burning, as well as batched variants.\\n     *\\n     * The same hook is called on both single and batched variants. For single\\n     * transfers, the length of the `id` and `amount` arrays will be 1.\\n     *\\n     * Calling conditions (for each `id` and `amount` pair):\\n     *\\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * of token type `id` will be  transferred to `to`.\\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\\n     * for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\\n     * will be burned.\\n     * - `from` and `to` are never both zero.\\n     * - `ids` and `amounts` have the same, non-zero length.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal virtual {}\\n\\n    function _doSafeTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _doSafeBatchTransferAcceptanceCheck(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) private {\\n        if (to.isContract()) {\\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\\n                bytes4 response\\n            ) {\\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\\n                    revert(\\\"ERC1155: ERC1155Receiver rejected tokens\\\");\\n                }\\n            } catch Error(string memory reason) {\\n                revert(reason);\\n            } catch {\\n                revert(\\\"ERC1155: transfer to non ERC1155Receiver implementer\\\");\\n            }\\n        }\\n    }\\n\\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\\n        uint256[] memory array = new uint256[](1);\\n        array[0] = element;\\n\\n        return array;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibValidate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nlibrary LibValidate {\\n    function enforceNonEmptyString(string memory str) internal pure {\\n        require(bytes(str).length > 0, \\\"LibValidate: String cannot be empty\\\");\\n    }\\n\\n    function enforceNonZeroAddress(address addr) internal pure {\\n        require(\\n            addr != address(0),\\n            \\\"LibValidate: Address cannot be zero address\\\"\\n        );\\n    }\\n\\n    function enforceNonEmptyAddressArray(address[] memory array) internal pure {\\n        require(\\n            array.length != 0,\\n            \\\"LibValidate: Address array cannot be empty.\\\"\\n        );\\n    }\\n\\n    function enforceNonEmptyStringArray(string[] memory array) internal pure {\\n        require(\\n            array.length != 0,\\n            \\\"LibValidate: String array cannot be empty.\\\"\\n        );\\n    }\\n\\n    function enforceNonEmptyUintArray(uint256[] memory array) internal pure {\\n        require(\\n            array.length != 0,\\n            \\\"LibValidate: uint256 array cannot be empty.\\\"\\n        );\\n    }\\n\\n    function enforceNonEmptyBoolArray(bool[] memory array) internal pure {\\n        require(array.length != 0, \\\"LibValidate: bool array cannot be empty.\\\");\\n    }\\n}\\n\"\r\n    },\r\n    \"LibRitualValidate.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n/*\\n    @title LibRitualValidate\\n    @dev This library has methods to validate rituals\\n */\\nlibrary LibRitualValidate {\\n    /*\\n        @title Enforces ritual is valid\\n        @author Facundo Vidal\\n        @dev This function is called to ensure that the ritual is valid\\n        Reverts if the ritual is invalid\\n        @param _name The name of the ritual\\n        @param _rarity The rarity of the ritual\\n        @param _charges The charges of the ritual\\n     */\\n    function enforceValidRitual(string memory _name,\\n        uint8 _rarity,\\n        uint256 _charges) internal pure {\\n        // Check if name is valid\\n        require(bytes(_name).length > 0, \\\"LibRitualValidate: invalid name\\\");\\n        // Check if rarity is valid\\n        require(_rarity >= 1 && _rarity <= 3, \\\"LibRitualValidate: invalid rarity\\\"); // 1=MYTHIC, 2=RARE, 3=COMMON\\n        // Check if charges is valid\\n        require(_charges > 0, \\\"LibRitualValidate: invalid charges\\\");\\n    }\\n}\"\r\n    },\r\n    \"LibToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nlibrary LibToken {\\n    uint256 internal constant TYPE_ERC20 = 20;\\n    uint256 internal constant TYPE_ERC721 = 721;\\n    uint256 internal constant TYPE_ERC1155 = 1155;\\n}\"\r\n    },\r\n    \"LibStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\nimport {LibStructs} from \\\"LibStructs.sol\\\";\\nimport {LibFarming} from \\\"LibFarming.sol\\\";\\nimport {IERC721} from \\\"IERC721.sol\\\";\\nimport {TerminusFacet} from \\\"TerminusFacet.sol\\\";\\nimport {LibValidate} from \\\"LibValidate.sol\\\";\\nimport {IShadowcornStatsFacet} from \\\"IShadowcornStatsFacet.sol\\\";\\nimport {LibLevel} from \\\"LibLevel.sol\\\";\\nimport {LevelFullInfo} from \\\"LevelFullInfo.sol\\\";\\n\\n/// @title LibStaking\\n/// @author Shiva Shanmuganathan\\n/// @dev Library implementation of the staking in minion hatchery.\\nlibrary LibStaking {\\n    uint8 private constant SHADOWCORN_CLASS_FIRE = 1;\\n    uint8 private constant SHADOWCORN_CLASS_SLIME = 2;\\n    uint8 private constant SHADOWCORN_CLASS_VOLT = 3;\\n    uint8 private constant SHADOWCORN_CLASS_SOUL = 4;\\n    uint8 private constant SHADOWCORN_CLASS_NEBULA = 5;\\n\\n    uint8 private constant SHADOWCORN_STAT_MIGHT = 1;\\n    uint8 private constant SHADOWCORN_STAT_WICKEDNESS = 2;\\n    uint8 private constant SHADOWCORN_STAT_TENACITY = 3;\\n    uint8 private constant SHADOWCORN_STAT_CUNNING = 4;\\n    uint8 private constant SHADOWCORN_STAT_ARCANA = 5;\\n\\n    // Position to store the staking storage\\n    bytes32 private constant STAKING_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.Staking.Storage\\\");\\n\\n    // Staking storage struct that holds all relevant stake data\\n    struct LibStakingStorage {\\n        mapping(uint256 tokenId => LibStructs.StakeData stakeData) shadowcornStakeData;\\n        mapping(uint256 tokenId => LibStructs.FarmableItem farmableItemData) shadowcornFarmingData;\\n        mapping(address user => uint256[] stakedTokenIds) userToStakedShadowcorns;\\n        mapping(uint256 levelId => uint256 cumulativeBonus) hatcheryLevelStakingCumulativeBonus;\\n        mapping(uint256 levelId => uint256 cumulativeHuskLimit) hatcheryLevelHuskLimitCumulative;\\n    }\\n\\n    /// @notice Sets the cumulative husk limit for a given hatchery level\\n    /// @param hatcheryLevel - The hatchery level\\n    /// @param cumulativeHuskLimit - The cumulative husk limit\\n    /// @dev the limit should be set times * 100: example: if the limit is meant to be 0.2, the value should be set to 20.\\n    function setHatcheryLevelHuskLimitCumulative(\\n        uint256 hatcheryLevel,\\n        uint256 cumulativeHuskLimit\\n    ) internal {\\n        stakingStorage().hatcheryLevelHuskLimitCumulative[\\n            hatcheryLevel\\n        ] = cumulativeHuskLimit;\\n    }\\n\\n    /// @notice Gets the cumulative husk limit for a given hatchery level\\n    /// @return cumulativeHuskLimit - The cumulative husk limit\\n    function getHatcheryLevelHuskLimitCumulative(\\n        uint256 hatcheryLevel\\n    ) internal view returns (uint256 cumulativeHuskLimit) {\\n        cumulativeHuskLimit = stakingStorage().hatcheryLevelHuskLimitCumulative[\\n            hatcheryLevel\\n        ];\\n    }\\n\\n    /// @notice Sets the cumulative staking bonus for a given hatchery level\\n    /// @param hatcheryLevel - The hatchery level\\n    /// @param cumulativeBonus - The cumulative bonus\\n    /// @dev the bonuses should be set times * 100: example: if the bonus is meant to be 0.2, the bonus should be set to 20.\\n    function setHatcheryLevelCumulativeBonus(\\n        uint256 hatcheryLevel,\\n        uint256 cumulativeBonus\\n    ) internal {\\n        stakingStorage().hatcheryLevelStakingCumulativeBonus[\\n            hatcheryLevel\\n        ] = cumulativeBonus;\\n    }\\n\\n    /// @notice Gets the cumulative staking bonus for a given hatchery level\\n    /// @param hatcheryLevel - The hatchery level\\n    function getHatcheryLevelCumulativeBonus(\\n        uint256 hatcheryLevel\\n    ) internal view returns (uint256) {\\n        return\\n            stakingStorage().hatcheryLevelStakingCumulativeBonus[hatcheryLevel];\\n    }\\n\\n    function resetStakedArray(address user) internal {\\n        stakingStorage().userToStakedShadowcorns[user] = new uint256[](0);\\n    }\\n\\n    /// @notice Get staked shadowcorns of sender\\n    /// @dev Returns paginated data of player's staked shadowcorns. Max page size is 12,\\n    /// The `moreEntriesExist` flag is TRUE when additional pages are available past the current call.\\n    /// The first page is 0\\n    /// @return stakedShadowcorns - Array of staked shadowcorns\\n    /// @return moreEntriesExist - Flag to indicate if more entries exist\\n    function getStakedShadowcorns(\\n        address staker,\\n        uint32 _pageNumber\\n    )\\n        internal\\n        view\\n        returns (uint256[] memory stakedShadowcorns, bool moreEntriesExist)\\n    {\\n        uint256 balance = stakingStorage()\\n            .userToStakedShadowcorns[staker]\\n            .length;\\n        uint start = _pageNumber * 12;\\n        uint count = balance - start;\\n\\n        if (count > 12) {\\n            count = 12;\\n            moreEntriesExist = true;\\n        }\\n\\n        stakedShadowcorns = new uint256[](count);\\n\\n        for (uint i = 0; i < count; ++i) {\\n            uint256 indx = start + i;\\n\\n            stakedShadowcorns[i] = (\\n                stakingStorage().userToStakedShadowcorns[staker][indx]\\n            );\\n        }\\n    }\\n\\n    /// Transfer a Shadowcorn into the Hatchery contract to begin yield farming.\\n    /// @param tokenId - The NFT to transfer\\n    /// @param farmableItemId - Id for the product to farm\\n    /// @custom:emits Transfer, ShadowcornStaked\\n    function stakeShadowcorn(uint256 tokenId, uint256 farmableItemId) internal {\\n        // check valid farmable item ID\\n        LibFarming.enforceValidFarmableItemId(farmableItemId);\\n\\n        // check if farmable item is active\\n        require(\\n            LibFarming.farmingStorage().farmableItemData[farmableItemId].active,\\n            \\\"LibStaking: Farmable item not active\\\"\\n        );\\n\\n        IERC721 shadowcornContract = IERC721(LibDiamond.shadowcornAddress());\\n        // check that the Shadowcorn is owned by the sender\\n        address shadowcornOwner = shadowcornContract.ownerOf(tokenId);\\n        require(\\n            shadowcornContract.ownerOf(tokenId) == msg.sender,\\n            \\\"LibStaking: Not owner of Shadowcorn\\\"\\n        );\\n\\n        // transfer the Shadowcorn to the Hatchery contract\\n        // replace this with the special transfer function from the Shadowcorn contract\\n        shadowcornContract.transferFrom(msg.sender, address(this), tokenId);\\n\\n        // set the staking data for the Shadowcorn\\n        stakingStorage().shadowcornStakeData[tokenId] = LibStructs.StakeData({\\n            staker: msg.sender,\\n            staked: true,\\n            farmableItemId: farmableItemId,\\n            stakeTimestamp: block.timestamp\\n        });\\n        // Get shadowcorn stats\\n\\n        (\\n            uint256 might,\\n            uint256 wickedness,\\n            uint256 tenacity,\\n            uint256 cunning,\\n            uint256 arcana\\n        ) = IShadowcornStatsFacet(LibDiamond.shadowcornAddress()).getStats(\\n                tokenId\\n            );\\n\\n        // set the farming data and farming bonus for the Shadowcorn\\n        stakingStorage().shadowcornFarmingData[tokenId] = calculateFarmingBonus(\\n            tokenId,\\n            farmableItemId,\\n            shadowcornOwner,\\n            (might + wickedness + tenacity + cunning + arcana)\\n        );\\n\\n        // add the Shadowcorn to the staker's list of staked Shadowcorns\\n        stakingStorage().userToStakedShadowcorns[msg.sender].push(tokenId);\\n\\n        // get the staking data\\n        LibStructs.StakeData memory stakeData = stakingStorage()\\n            .shadowcornStakeData[tokenId];\\n\\n        // emit the event\\n        emit LibEvents.ShadowcornStaked(\\n            tokenId,\\n            stakeData.staker,\\n            stakeData.staked,\\n            stakeData.farmableItemId,\\n            stakeData.stakeTimestamp\\n        );\\n        emit LibEvents.SetShadowcornFarmingData(\\n            stakeData.staker,\\n            tokenId,\\n            stakingStorage().shadowcornFarmingData[tokenId]\\n        );\\n    }\\n\\n    //  Collect any goods that have been farmed by a Shadowcorn, and immediately\\n    //  re-stake the Shadowcorn back to yield farming. Progress toward incomplete\\n    //  items is carried over.\\n    //  @param tokenId - The NFT to unstake\\n    //  @custom:emits ShadowcornHarvest\\n    function harvestAndRestakeShadowcorn(uint256 tokenId) internal {\\n        // check that the Shadowcorn is staked\\n        require(\\n            stakingStorage().shadowcornStakeData[tokenId].staked == true,\\n            \\\"LibStaking: Shadowcorn not staked.\\\"\\n        );\\n\\n        address shadowcornOwner = stakingStorage()\\n            .shadowcornStakeData[tokenId]\\n            .staker;\\n        require(\\n            shadowcornOwner == msg.sender,\\n            \\\"LibStaking: Not owner of Shadowcorn.\\\"\\n        );\\n\\n        // get the staking data\\n        LibStructs.StakeData memory stakeData = stakingStorage()\\n            .shadowcornStakeData[tokenId];\\n\\n        // get the farming data\\n        LibStructs.FarmableItem memory farmingData = stakingStorage()\\n            .shadowcornFarmingData[tokenId];\\n\\n        uint256 stakingRewards = calculateStakingRewards(tokenId);\\n\\n        // reset the staking data for the Shadowcorn\\n        stakingStorage().shadowcornStakeData[tokenId] = LibStructs.StakeData({\\n            staker: stakeData.staker,\\n            staked: true,\\n            farmableItemId: stakeData.farmableItemId,\\n            stakeTimestamp: block.timestamp\\n        });\\n\\n        // Get shadowcorn stats\\n\\n        (\\n            uint256 might,\\n            uint256 wickedness,\\n            uint256 tenacity,\\n            uint256 cunning,\\n            uint256 arcana\\n        ) = IShadowcornStatsFacet(LibDiamond.shadowcornAddress()).getStats(\\n                tokenId\\n            );\\n\\n        // reset the farming data for the Shadowcorn\\n        stakingStorage().shadowcornFarmingData[tokenId] = calculateFarmingBonus(\\n            tokenId,\\n            stakeData.farmableItemId,\\n            shadowcornOwner,\\n            (might + wickedness + tenacity + cunning + arcana)\\n        );\\n\\n        // setting terminus address\\n        TerminusFacet terminus = TerminusFacet(\\n            LibDiamond.diamondStorage().shadowcornItemsAddress\\n        );\\n\\n        // mint terminus tokens to the staker\\n        terminus.mint(msg.sender, farmingData.poolId, stakingRewards, \\\"\\\");\\n\\n        // emit the harvest event\\n        emit LibEvents.ShadowcornHarvest(\\n            stakeData.staker,\\n            tokenId,\\n            farmingData.poolId,\\n            stakingRewards\\n        );\\n    }\\n\\n    function returnShadowcorn(uint256 tokenId, address user) internal {\\n        IERC721 shadowcornContract = IERC721(LibDiamond.shadowcornAddress());\\n        // check that the Shadowcorn is owned by the sender\\n        require(\\n            shadowcornContract.ownerOf(tokenId) == address(this),\\n            \\\"LibStaking: Hatchery not in possession of Shadowcorn.\\\"\\n        );\\n\\n        // transfer the Shadowcorn back to the owner\\n        shadowcornContract.transferFrom(address(this), user, tokenId);\\n    }\\n\\n    //  Unstake a Shadowcorn, transfer it back to the owner's wallet, and collect\\n    //  any goods that have been farmed. Progress toward incomplete items are lost.\\n    //  @param tokenId - The NFT to unstake\\n    //  @custom:emits Transfer, ShadowcornUnstaked, ShadowcornHarvest\\n    function unstakeShadowcorn(uint256 tokenId) internal {\\n        // check that the Shadowcorn is staked\\n        require(\\n            stakingStorage().shadowcornStakeData[tokenId].staked == true,\\n            \\\"LibStaking: Shadowcorn not staked.\\\"\\n        );\\n\\n        require(\\n            stakingStorage().shadowcornStakeData[tokenId].staker == msg.sender,\\n            \\\"LibStaking: Not owner of Shadowcorn.\\\"\\n        );\\n\\n        // get the staking data\\n        LibStructs.StakeData memory stakeData = stakingStorage()\\n            .shadowcornStakeData[tokenId];\\n\\n        // get the farming data\\n        LibStructs.FarmableItem memory farmingData = stakingStorage()\\n            .shadowcornFarmingData[tokenId];\\n\\n        uint256 stakingRewards = calculateStakingRewards(tokenId);\\n\\n        resetStakingData(tokenId);\\n\\n        // setting terminus address\\n        TerminusFacet terminus = TerminusFacet(\\n            LibDiamond.diamondStorage().shadowcornItemsAddress\\n        );\\n\\n        // mint terminus tokens to the staker\\n        terminus.mint(msg.sender, farmingData.poolId, stakingRewards, \\\"\\\");\\n\\n        // emit the harvest event\\n        emit LibEvents.ShadowcornHarvest(\\n            stakeData.staker,\\n            tokenId,\\n            farmingData.poolId,\\n            stakingRewards\\n        );\\n\\n        IERC721 shadowcornContract = IERC721(LibDiamond.shadowcornAddress());\\n\\n        // remove tokenId element from mapping user=>staked shadowcorns\\n        removeStakedShadowcornFromUserList(tokenId);\\n\\n        // transfer the Shadowcorn back to the owner\\n        shadowcornContract.transferFrom(address(this), msg.sender, tokenId);\\n\\n        // emit the event\\n        emit LibEvents.ShadowcornUnstaked(\\n            tokenId,\\n            stakingStorage().shadowcornStakeData[tokenId].staker,\\n            false,\\n            stakingStorage().shadowcornStakeData[tokenId].farmableItemId,\\n            block.timestamp -\\n                stakingStorage().shadowcornStakeData[tokenId].stakeTimestamp\\n        );\\n    }\\n\\n    function resetStakingData(uint256 tokenId) internal {\\n        // reset the staking data for the Shadowcorn\\n        delete stakingStorage().shadowcornStakeData[tokenId];\\n\\n        // reset the farming data for the Shadowcorn\\n        delete stakingStorage().shadowcornFarmingData[tokenId];\\n    }\\n\\n    //  Transfer a Shadowcorn back to the owner immediately.\\n    //  No yields are rewarded.\\n    //  @custom:emits Transfer, ShadowcornUnstaked\\n    function forceUnstake(uint256 tokenId) internal {\\n        // check if ownerOf tokenId is msg.sender\\n        IERC721 shadowcornContract = IERC721(LibDiamond.shadowcornAddress());\\n\\n        // check that the Shadowcorn is staked\\n        require(\\n            stakingStorage().shadowcornStakeData[tokenId].staked == true,\\n            \\\"LibStaking: Shadowcorn not staked\\\"\\n        );\\n\\n        // check that the msg.sender is the owner of the Shadowcorn\\n        require(\\n            stakingStorage().shadowcornStakeData[tokenId].staker == msg.sender,\\n            \\\"LibStaking: Not owner of Shadowcorn\\\"\\n        );\\n\\n        // get the staking data\\n        LibStructs.StakeData memory stakeData = stakingStorage()\\n            .shadowcornStakeData[tokenId];\\n\\n        resetStakingData(tokenId);\\n\\n        // remove tokenId element from mapping user=>staked shadowcorns\\n        removeStakedShadowcornFromUserList(tokenId);\\n\\n        // transfer the Shadowcorn back to the owner\\n        shadowcornContract.transferFrom(address(this), msg.sender, tokenId);\\n\\n        // emit the event\\n        emit LibEvents.ShadowcornUnstaked(\\n            tokenId,\\n            stakeData.staker,\\n            false,\\n            stakeData.farmableItemId,\\n            block.timestamp - stakeData.stakeTimestamp\\n        );\\n\\n        emit LibEvents.ForcedUnstakeExecuted(stakeData.staker, tokenId);\\n    }\\n\\n    function calculateFarmingBonus(\\n        uint256 tokenId,\\n        uint256 farmableItemId\\n    )\\n        internal\\n        view\\n        returns (LibStructs.FarmableItem memory shadowcornFarmingData)\\n    {\\n        // Get shadowcorn stats\\n\\n        (\\n            uint256 might,\\n            uint256 wickedness,\\n            uint256 tenacity,\\n            uint256 cunning,\\n            uint256 arcana\\n        ) = IShadowcornStatsFacet(LibDiamond.shadowcornAddress()).getStats(\\n                tokenId\\n            );\\n        return\\n            calculateFarmingBonus(\\n                tokenId,\\n                farmableItemId,\\n                IERC721(LibDiamond.shadowcornAddress()).ownerOf(tokenId),\\n                (might + wickedness + tenacity + cunning + arcana)\\n            );\\n    }\\n\\n    function calculateFarmingBonus(\\n        uint256 tokenId,\\n        uint256 farmableItemId,\\n        address shadowcornOwner,\\n        uint256 shadowcornTotalStats\\n    )\\n        internal\\n        view\\n        returns (LibStructs.FarmableItem memory shadowcornFarmingData)\\n    {\\n        //check is shadowcorn is staked\\n        LibStructs.StakeData memory stakeData = stakingStorage().shadowcornStakeData[tokenId];\\n        if(stakeData.staked) {\\n            shadowcornOwner = stakeData.staker;\\n        } else {\\n            shadowcornOwner = IERC721(LibDiamond.shadowcornAddress()).ownerOf(\\n                tokenId\\n            );\\n        }\\n        \\n        // check that the Shadowcorn tokenId is valid\\n        LibValidate.enforceNonZeroAddress(shadowcornOwner);\\n\\n        // get the farming storage\\n        LibFarming.LibFarmingStorage storage lfs = LibFarming.farmingStorage();\\n        LibStructs.FarmableItem memory farmableItem = lfs.farmableItemData[\\n            farmableItemId\\n        ];\\n        shadowcornFarmingData = farmableItem;\\n\\n        (uint256 class, uint256 rarity, uint256 stat) = IShadowcornStatsFacet(\\n            LibDiamond.shadowcornAddress()\\n        ).getClassRarityAndStat(tokenId, farmableItem.stat);\\n\\n        // Set the baseRate to the FarmableItem\u2019s hourlyRate (ok if this is 0)\\n        uint256 baseRate = farmableItem.hourlyRate;\\n\\n        // If the stat is non-zero, add 1/100th of the stat to the baseRate (will later by divided by 100 when calculating rewards)\\n        if (stat > 0) {\\n            baseRate = stat;\\n        }\\n\\n        // If receivesHatcheryLevelBonus is true, add the cumulative level bonus (the same calculation we\u2019re currently using)\\n        if (farmableItem.receivesHatcheryLevelBonus) {\\n            uint256 hatcheryLevel = LibLevel.getHatcheryLevelForAddress(\\n                shadowcornOwner\\n            );\\n            baseRate += stakingStorage().hatcheryLevelStakingCumulativeBonus[\\n                hatcheryLevel\\n            ];\\n        }\\n\\n        uint256 multiplierRate = 10;\\n\\n        // If receivesRarityBonus is true, add the rarity multiplier bonus\\n        if (farmableItem.receivesRarityBonus) {\\n            multiplierRate += getMultiplicativeRarityBonus(rarity);\\n        }\\n\\n        // If class is non-zero, and class matches the Shadowcorn, add the class multiplier bonus\\n        if (class > 0) {\\n            multiplierRate += getMultiplicativeClassBonus(\\n                class,\\n                farmableItem.class\\n            );\\n        }\\n\\n        //This value is stored times 1000, it should be divided by 1000 when used\\n        shadowcornFarmingData.hourlyRate = baseRate * multiplierRate;\\n\\n        // Calculate cap\\n        if (farmableItem.cap > 0) {\\n            // If the FarmableItem\u2019s cap is non-zero, use that number\\n            shadowcornFarmingData.cap = farmableItem.cap;\\n        } else {\\n            // If the cap is zero, calculate the yield cap\\n            // yieldCap = (total shadowcorn stats / 10)\\n            uint256 yieldCap = shadowcornTotalStats;\\n\\n            // yieldCap += hatchery Level Cumulative HuskLimit Bonus[level]\\n            yieldCap +=\\n                getHatcheryLevelHuskLimitCumulative(\\n                    LibLevel.getHatcheryLevelForAddress(shadowcornOwner)\\n                ) *\\n                10;\\n\\n            // yieldCap *= getMultiplicativeRarityBonus\\n            yieldCap *= (10 + getMultiplicativeRarityBonus(rarity));\\n\\n            shadowcornFarmingData.cap = yieldCap / 100;\\n        }\\n    }\\n\\n    function getMultiplicativeClassBonus(\\n        uint256 shadowcornClass,\\n        uint256 farmableItemClass\\n    ) internal pure returns (uint256) {\\n        if (shadowcornClass == farmableItemClass) {\\n            //This is meant to be 0.5\\n            return 5;\\n        }\\n        return 0;\\n    }\\n\\n    function getMultiplicativeRarityBonus(\\n        uint256 rarity\\n    ) internal pure returns (uint256) {\\n        if (rarity == 1) {\\n            //This is meant to be 0.1\\n            return 1;\\n        } else if (rarity == 2) {\\n            //This is meant to be 1\\n            return 10;\\n        }\\n        //This is meant to be 4\\n        return 40;\\n    }\\n\\n    function calculateStakingRewards(\\n        uint256 tokenId\\n    ) internal view returns (uint256) {\\n        // get the staking storage\\n        LibStakingStorage storage lss = stakingStorage();\\n\\n        // get the staking data\\n        LibStructs.StakeData memory stakeData = lss.shadowcornStakeData[\\n            tokenId\\n        ];\\n\\n        // get the farming data\\n        LibStructs.FarmableItem memory farmingData = lss.shadowcornFarmingData[\\n            tokenId\\n        ];\\n\\n        // get the time since the last update\\n        uint256 timeSinceStaking = block.timestamp - stakeData.stakeTimestamp;\\n\\n        // calculate the staking reward\\n        uint256 stakingReward = (timeSinceStaking * farmingData.hourlyRate) /\\n            3600;\\n\\n        //Divide by 1000 to scale back to the original value\\n        stakingReward = stakingReward / 1000;\\n\\n        // if the staking reward is greater than the cap, set it to the cap\\n        if (stakingReward > farmingData.cap) {\\n            stakingReward = farmingData.cap;\\n        }\\n\\n        return stakingReward;\\n    }\\n\\n    function stakingStorage()\\n        internal\\n        pure\\n        returns (LibStakingStorage storage lss)\\n    {\\n        bytes32 position = STAKING_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            lss.slot := position\\n        }\\n    }\\n\\n    function removeStakedShadowcornFromUserList(uint256 _tokenId) internal {\\n        LibStakingStorage storage lss = stakingStorage();\\n        uint256[] storage arr = lss.userToStakedShadowcorns[msg.sender];\\n\\n        for (uint i = 0; i < arr.length; i++) {\\n            if (arr[i] == _tokenId) {\\n                arr[i] = arr[arr.length - 1];\\n                arr.pop();\\n                return;\\n            }\\n        }\\n        revert(\\\"LibStaking: shadowcorn not found on user list.\\\");\\n    }\\n\\n    function getFarmingBonusBreakdown(\\n        uint256 tokenId\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 baseRate,\\n            uint256 hatcheryLevelBonus,\\n            uint256 classBonus,\\n            uint256 rarityBonus\\n        )\\n    {\\n        // get the farming storage\\n        LibStructs.FarmableItem memory farmableItem = stakingStorage()\\n            .shadowcornFarmingData[tokenId];\\n\\n        (uint256 class, uint256 rarity, uint256 stat) = IShadowcornStatsFacet(\\n            LibDiamond.shadowcornAddress()\\n        ).getClassRarityAndStat(tokenId, farmableItem.stat);\\n\\n        baseRate = stat;\\n        LibStructs.StakeData memory stakeData = stakingStorage().shadowcornStakeData[tokenId];\\n        address shadowcornOwner;\\n        if(stakeData.staked) {\\n            shadowcornOwner = stakeData.staker;\\n        } else {\\n            shadowcornOwner = IERC721(LibDiamond.shadowcornAddress()).ownerOf(\\n                tokenId\\n            );\\n        }\\n        uint256 hatcheryLevel = LibLevel.getHatcheryLevelForAddress(\\n            shadowcornOwner\\n        );\\n        hatcheryLevelBonus = stakingStorage()\\n            .hatcheryLevelStakingCumulativeBonus[hatcheryLevel];\\n\\n        classBonus = getMultiplicativeClassBonus(class, farmableItem.class);\\n        rarityBonus = getMultiplicativeRarityBonus(rarity);\\n    }\\n\\n    function getFarmingRateByFarmableItems(uint256 tokenId, uint256[] memory farmableItemIds) internal view returns(uint256[] memory) { \\n        uint256 length = farmableItemIds.length;\\n        uint256[] memory husksPerFarmable = new uint256[](length);\\n        for(uint256 i = 0; i < length; i++) {\\n            husksPerFarmable[i] = calculateFarmingBonus(tokenId, farmableItemIds[i]).hourlyRate;\\n        }\\n        return husksPerFarmable;\\n    }\\n\\n    function getFarmingHusksPerHour(\\n        uint256 tokenId\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 fireHusks,\\n            uint256 slimeHusks,\\n            uint256 voltHusks,\\n            uint256 soulHusks,\\n            uint256 nebulaHusks\\n        )\\n    {\\n        //This should then be divided by 1000 when used\\n        IERC721 shadowcornContract = IERC721(LibDiamond.shadowcornAddress());\\n        address shadowcornOwner = shadowcornContract.ownerOf(tokenId);\\n        uint256 hatcheryLevel = LibLevel.getHatcheryLevelForAddress(\\n            shadowcornOwner\\n        );\\n        uint256 hatcheryLevelBonus = stakingStorage()\\n            .hatcheryLevelStakingCumulativeBonus[hatcheryLevel];\\n        uint256 rarityBonus = getMultiplicativeRarityBonus(\\n            IShadowcornStatsFacet(LibDiamond.shadowcornAddress()).getRarity(\\n                tokenId\\n            )\\n        );\\n        uint256 class = IShadowcornStatsFacet(LibDiamond.shadowcornAddress())\\n            .getClass(tokenId);\\n        fireHusks = getFireHuskRate(\\n            tokenId,\\n            rarityBonus,\\n            hatcheryLevelBonus,\\n            class\\n        );\\n        slimeHusks = getSlimeHuskRate(\\n            tokenId,\\n            rarityBonus,\\n            hatcheryLevelBonus,\\n            class\\n        );\\n        voltHusks = getVoltHuskRate(\\n            tokenId,\\n            rarityBonus,\\n            hatcheryLevelBonus,\\n            class\\n        );\\n        soulHusks = getSoulHuskRate(\\n            tokenId,\\n            rarityBonus,\\n            hatcheryLevelBonus,\\n            class\\n        );\\n        nebulaHusks = getNebulaHuskRate(\\n            tokenId,\\n            rarityBonus,\\n            hatcheryLevelBonus,\\n            class\\n        );\\n    }\\n\\n    function getFireHuskRate(\\n        uint256 tokenId,\\n        uint256 rarityBonus,\\n        uint256 hatcheryLevelBonus,\\n        uint256 class\\n    ) internal view returns (uint256) {\\n        uint256 might = IShadowcornStatsFacet(LibDiamond.shadowcornAddress())\\n            .getMight(tokenId);\\n        uint256 fireClassBonus = getMultiplicativeClassBonus(class, 1);\\n        return\\n            (might + hatcheryLevelBonus) * (10 + rarityBonus + fireClassBonus);\\n    }\\n\\n    function getSlimeHuskRate(\\n        uint256 tokenId,\\n        uint256 rarityBonus,\\n        uint256 hatcheryLevelBonus,\\n        uint256 class\\n    ) internal view returns (uint256) {\\n        uint256 wickedness = IShadowcornStatsFacet(\\n            LibDiamond.shadowcornAddress()\\n        ).getWickedness(tokenId);\\n        uint256 slimeClassBonus = getMultiplicativeClassBonus(class, 2);\\n        return\\n            (wickedness + hatcheryLevelBonus) *\\n            (10 + rarityBonus + slimeClassBonus);\\n    }\\n\\n    function getVoltHuskRate(\\n        uint256 tokenId,\\n        uint256 rarityBonus,\\n        uint256 hatcheryLevelBonus,\\n        uint256 class\\n    ) internal view returns (uint256) {\\n        uint256 tenacity = IShadowcornStatsFacet(LibDiamond.shadowcornAddress())\\n            .getTenacity(tokenId);\\n        uint256 voltClassBonus = getMultiplicativeClassBonus(class, 3);\\n        return\\n            (tenacity + hatcheryLevelBonus) *\\n            (10 + rarityBonus + voltClassBonus);\\n    }\\n\\n    function getSoulHuskRate(\\n        uint256 tokenId,\\n        uint256 rarityBonus,\\n        uint256 hatcheryLevelBonus,\\n        uint256 class\\n    ) internal view returns (uint256) {\\n        uint256 cunning = IShadowcornStatsFacet(LibDiamond.shadowcornAddress())\\n            .getCunning(tokenId);\\n        uint256 soulClassBonus = getMultiplicativeClassBonus(class, 4);\\n        return\\n            (cunning + hatcheryLevelBonus) *\\n            (10 + rarityBonus + soulClassBonus);\\n    }\\n\\n    function getNebulaHuskRate(\\n        uint256 tokenId,\\n        uint256 rarityBonus,\\n        uint256 hatcheryLevelBonus,\\n        uint256 class\\n    ) internal view returns (uint256) {\\n        uint256 arcana = IShadowcornStatsFacet(LibDiamond.shadowcornAddress())\\n            .getArcana(tokenId);\\n        uint256 nebulaClassBonus = getMultiplicativeClassBonus(class, 5);\\n        return\\n            (arcana + hatcheryLevelBonus) *\\n            (10 + rarityBonus + nebulaClassBonus);\\n    }\\n\\n    function getFarmableItemByShadowcornId(\\n        uint256 tokenId\\n    ) internal view returns (LibStructs.FarmableItem memory) {\\n        return stakingStorage().shadowcornFarmingData[tokenId];\\n    }\\n\\n    /// @notice Computes the time remaining until the cap is reached for a given token\\n    /// @param tokenId The ID of the token for which to calculate the time\\n    /// @return timeToReachCap The time remaining, in seconds, until the cap is reached\\n    function computeTimeToReachCap(\\n        uint256 tokenId\\n    ) internal view returns (uint256 timeToReachCap) {\\n        // get the farming data\\n        LibStructs.FarmableItem memory farmingData = stakingStorage()\\n            .shadowcornFarmingData[tokenId];\\n\\n        // get the staking data\\n        LibStructs.StakeData memory stakeData = stakingStorage()\\n            .shadowcornStakeData[tokenId];\\n\\n        if (stakeData.stakeTimestamp == 0) {\\n            return 0;\\n        }\\n\\n        // get the time since the last update\\n        uint256 timeSinceStaking = block.timestamp - stakeData.stakeTimestamp;\\n\\n        // cap = hourlyRate * totalTimeToReachCap\\n        // totalTimeToReachCap = cap / hourlyRate\\n        // Convert totalTimeToReachCap to seconds and hourlyRate to decimals by multiplying with 3600 and 1000 respectively.\\n        uint256 totalTimeToReachCap = ((farmingData.cap * 3600 * 1000) /\\n            farmingData.hourlyRate);\\n\\n        if (timeSinceStaking > totalTimeToReachCap) {\\n            return 0;\\n        }\\n\\n        timeToReachCap = totalTimeToReachCap - timeSinceStaking;\\n\\n        return (timeToReachCap);\\n    }\\n\\n    /// @notice Computes the time remaining until the next husk is created for a given token\\n    /// @param tokenId The ID of the token for which to calculate the time\\n    /// @return timeUntilNextHusk The time remaining, in seconds, until the next husk is created\\n    function getTimeUntilNextHusk(\\n        uint256 tokenId\\n    ) internal view returns (uint256 timeUntilNextHusk) {\\n        // get the farming data\\n        LibStructs.FarmableItem memory farmingData = stakingStorage()\\n            .shadowcornFarmingData[tokenId];\\n\\n        // get the staking data\\n        LibStructs.StakeData memory stakeData = stakingStorage()\\n            .shadowcornStakeData[tokenId];\\n\\n        // get hourly rate and time to get single husk\\n        uint256 hourlyRate = farmingData.hourlyRate;\\n        uint256 timeToGetSingleHusk = (3600 * 1000) / (hourlyRate);\\n\\n        // get the time since the last update\\n        uint256 timeSinceStaking = block.timestamp - stakeData.stakeTimestamp;\\n\\n        if (timeToGetSingleHusk >= timeSinceStaking) {\\n            return timeToGetSingleHusk - timeSinceStaking;\\n        }\\n\\n        // get the time until next husk\\n        timeUntilNextHusk =\\n            timeToGetSingleHusk -\\n            (timeSinceStaking % timeToGetSingleHusk);\\n\\n        return timeUntilNextHusk;\\n    }\\n\\n    /// @notice Retrieves staking details including the husks created, time to reach cap, cap amount, and time until next husk\\n    /// @param tokenId The ID of the token for which to retrieve the details\\n    /// @return husksCreated The number of husks created since staking\\n    /// @return timeToReachCap The time remaining, in seconds, until the cap is reached\\n    /// @return capAmount The cap amount\\n    /// @return timeUntilNextHusk The time remaining, in seconds, until the next husk is created\\n    function getStakingDetails(\\n        uint256 tokenId\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 husksCreated,\\n            uint256 timeToReachCap,\\n            uint256 capAmount,\\n            uint256 timeUntilNextHusk\\n        )\\n    {\\n        husksCreated = calculateStakingRewards(tokenId);\\n        timeToReachCap = computeTimeToReachCap(tokenId);\\n        capAmount = stakingStorage().shadowcornFarmingData[tokenId].cap;\\n        timeUntilNextHusk = getTimeUntilNextHusk(tokenId);\\n\\n        return (husksCreated, timeToReachCap, capAmount, timeUntilNextHusk);\\n    }\\n\\n    /// @notice Retrieves the staking information for a specific Shadowcorn token\\n    /// @param tokenId The ID of the Shadowcorn token for which to retrieve the staking information\\n    /// @return A LibStructs.StakeData struct containing the staking details for the specified token\\n    function getStakingInfoByShadowcornId(\\n        uint256 tokenId\\n    ) internal view returns (LibStructs.StakeData memory) {\\n        return stakingStorage().shadowcornStakeData[tokenId];\\n    }\\n\\n    function getHatcheryLevelFullInfo(uint256 _hatcheryLevel) internal view returns(LevelFullInfo memory fullInfo){\\n        fullInfo.unlockCosts = LibLevel.getHatcheryLevelUnlockCosts(_hatcheryLevel);\\n        fullInfo.cumulativeBonus = getHatcheryLevelCumulativeBonus(_hatcheryLevel);\\n        fullInfo.cumulativeHuskLimit = getHatcheryLevelHuskLimitCumulative(_hatcheryLevel);\\n        fullInfo.hatcheryLevel = _hatcheryLevel;\\n    }\\n\\n    function getHatcheryLevelsFullInfo(uint8 page) internal view returns(LevelFullInfo[5] memory levelsInfo) {\\n        uint256 initialLevel = page * 5 + 1;\\n        for(uint256 i = 0; i < 5; i++) {\\n            levelsInfo[i] = getHatcheryLevelFullInfo(initialLevel + i);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"LibFarming.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.20;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\nimport {LibStructs} from \\\"LibStructs.sol\\\";\\nimport {IERC721} from \\\"IERC721.sol\\\";\\nimport {TerminusFacet} from \\\"TerminusFacet.sol\\\";\\nimport {LibConstraints} from \\\"LibConstraints.sol\\\";\\nimport {LibConstraintOperator} from \\\"LibConstraintOperator.sol\\\";\\nimport {IConstraintFacet} from \\\"IConstraintFacet.sol\\\";\\n\\nimport {LibValidate} from \\\"LibValidate.sol\\\";\\n\\n/// @title LibFarming\\n/// @author Shiva Shanmuganathan\\n/// @dev Library implementation of the yield farming in minion hatchery.\\nlibrary LibFarming {\\n    // Position to store the farming storage\\n    bytes32 private constant FARMING_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.Farming.Storage\\\");\\n\\n    // Farming storage struct that holds all relevant stake data\\n    struct LibFarmingStorage {\\n        uint256 farmableItemCount;\\n        mapping(uint256 farmableItemId => LibStructs.FarmableItem farmableItemData) farmableItemData;\\n        uint256[] huskPoolIds;\\n        uint256[] minionPoolIds;\\n        mapping(uint256 huskPoolId => uint256 index) huskPoolIdToIndex;\\n        mapping(uint256 minionPoolId => uint256 index) minionPoolIdToIndex;\\n    }\\n\\n    function getFarmableItemData(\\n        uint256 farmableItemId\\n    ) internal view returns (LibStructs.FarmableItem memory) {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        return lfs.farmableItemData[farmableItemId];\\n    }\\n\\n    /// Setup a new item for yield farming by the Shadowcorns.\\n    /// @param poolId - Terminus pool (Shadowcorns item collection only)\\n    /// @param hourlyRate - Number of items created in one batch per hour (3 decimals)\\n    /// @param cap - Max number of items that can be farmed per session\\n    /// @param class - Class of the Shadowcorn\\n    /// @param stat - Stat of the Shadowcorn to check when farming\\n    /// @param receivesHatcheryLevelBonus - Whether the item receives a bonus based on the hatchery level\\n    /// @param receivesRarityBonus - Whether the item receives a bonus based on the rarity of the minion\\n    function registerNewFarmableItem(\\n        uint256 poolId,\\n        uint256 hourlyRate,\\n        uint256 cap,\\n        uint256 class,\\n        uint256 stat,\\n        bool receivesHatcheryLevelBonus,\\n        bool receivesRarityBonus\\n    ) internal {\\n        // check valid farmable item ID by checking if terminus pool exists\\n        require(\\n            poolId <=\\n                TerminusFacet(\\n                    LibDiamond.diamondStorage().shadowcornItemsAddress\\n                ).totalPools(),\\n            \\\"LibFarming: Terminus pool does not exist.\\\"\\n        );\\n\\n        require(class >= 0 && class < 6, \\\"LibFarming: Invalid class.\\\"); // We can have no class (0)\\n        require(stat >= 0 && stat < 6, \\\"LibFarming: Invalid stat.\\\");\\n\\n        LibFarmingStorage storage lfs = farmingStorage();\\n\\n        // increment farmable item count\\n        lfs.farmableItemCount++;\\n\\n        // get uri from terminus\\n        string memory uri = TerminusFacet(\\n            LibDiamond.diamondStorage().shadowcornItemsAddress\\n        ).uri(poolId);\\n\\n        // register the new farmable item\\n        lfs.farmableItemData[lfs.farmableItemCount] = LibStructs.FarmableItem({\\n            active: false,\\n            poolId: poolId,\\n            hourlyRate: hourlyRate,\\n            cap: cap,\\n            uri: uri,\\n            class: class,\\n            stat: stat,\\n            receivesHatcheryLevelBonus: receivesHatcheryLevelBonus,\\n            receivesRarityBonus: receivesRarityBonus\\n        });\\n\\n        // emit event\\n        emit LibEvents.FarmableItemRegistered(\\n            msg.sender,\\n            lfs.farmableItemCount,\\n            poolId,\\n            hourlyRate,\\n            cap,\\n            uri\\n        );\\n    }\\n\\n    /// Change the details of a farmableItem\\n    /// @param farmableItemId - Item to modify\\n    /// @param hourlyRate - Number of items created in one batch per hour (3 decimals)\\n    /// @param cap - Max number of items that can be farmed per session\\n    /// @param receivesHatcheryLevelBonus - Whether the item receives a bonus based on the hatchery level\\n    /// @param receivesRarityBonus - Whether the item receives a bonus based on the rarity of the minion\\n    function modifyFarmableItem(\\n        uint256 farmableItemId,\\n        uint256 poolId,\\n        uint256 hourlyRate,\\n        uint256 cap,\\n        uint256 class, \\n        uint256 stat,\\n        bool receivesHatcheryLevelBonus,\\n        bool receivesRarityBonus\\n    ) internal {\\n        // check valid farmable item ID\\n        enforceValidFarmableItemId(farmableItemId);\\n\\n        // get the farming storage\\n        LibFarmingStorage storage lfs = farmingStorage();\\n\\n        // get the farmable item\\n        LibStructs.FarmableItem storage fi = lfs.farmableItemData[\\n            farmableItemId\\n        ];\\n\\n        // check that the farmable item is not active\\n        require(\\n            fi.active == false,\\n            \\\"LibFarming: Cannot modify active farmable item.\\\"\\n        );\\n\\n        // modify the farmable item\\n        lfs.farmableItemData[farmableItemId].poolId = poolId;\\n        lfs.farmableItemData[farmableItemId].hourlyRate = hourlyRate;\\n        lfs.farmableItemData[farmableItemId].cap = cap;\\n        lfs.farmableItemData[farmableItemId].class = class;\\n        lfs.farmableItemData[farmableItemId].stat = stat;\\n        lfs.farmableItemData[farmableItemId]\\n            .receivesHatcheryLevelBonus = receivesHatcheryLevelBonus;\\n        lfs.farmableItemData[farmableItemId].receivesRarityBonus = receivesRarityBonus;\\n\\n        // emit event\\n        emit LibEvents.FarmableItemModified(\\n            msg.sender,\\n            farmableItemId,\\n            poolId,\\n            hourlyRate,\\n            cap,\\n            class,\\n            stat\\n        );\\n    }\\n\\n    /// Turn on a Farmable item for use\\n    function activateFarmableItem(uint256 farmableItemId) internal {\\n        // check valid farmable item ID\\n        enforceValidFarmableItemId(farmableItemId);\\n\\n        LibFarmingStorage storage lfs = farmingStorage();\\n\\n        LibStructs.FarmableItem storage fi = lfs.farmableItemData[\\n            farmableItemId\\n        ];\\n        require(\\n            fi.active == false,\\n            \\\"LibFarming: Farmable item already active.\\\"\\n        );\\n        lfs.farmableItemData[farmableItemId].active = true;\\n        emit LibEvents.FarmableItemActivated(msg.sender, farmableItemId);\\n    }\\n\\n    /// Turn off a Farmable item for use\\n    function deactivateFarmableItem(uint256 farmableItemId) internal {\\n        // check valid farmable item ID\\n        enforceValidFarmableItemId(farmableItemId);\\n\\n        LibFarmingStorage storage lfs = farmingStorage();\\n\\n        LibStructs.FarmableItem storage fi = lfs.farmableItemData[\\n            farmableItemId\\n        ];\\n        require(fi.active, \\\"LibFarming: Farmable item already inactive.\\\");\\n        lfs.farmableItemData[farmableItemId].active = false;\\n        emit LibEvents.FarmableItemDeactivated(msg.sender, farmableItemId);\\n    }\\n\\n    /// Returns a list of Farmable items that are currently active.\\n    function getActiveFarmables()\\n        internal\\n        view\\n        returns (LibStructs.FarmableItem[] memory, uint256[] memory)\\n    {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        uint256 activeCount = getActiveFarmableCount();\\n        LibStructs.FarmableItem[]\\n            memory activeFarmables = new LibStructs.FarmableItem[](activeCount);\\n        uint256 activeIndex = 0;\\n        uint256[] memory farmableItemIds = new uint256[](activeCount);\\n        for (uint256 i = 1; i <= lfs.farmableItemCount; i++) {\\n            if (lfs.farmableItemData[i].active) {\\n                activeFarmables[activeIndex] = lfs.farmableItemData[i];\\n                farmableItemIds[activeIndex] = i;\\n\\n                activeIndex++;\\n            }\\n        }\\n\\n        return (activeFarmables, farmableItemIds);\\n    }\\n\\n    /// Returns the number of FarmableItem objects registered\\n    function getFarmableItemCount() internal view returns (uint256) {\\n        return farmingStorage().farmableItemCount;\\n    }\\n\\n    /// Returns the number of FarmableItem objects that are active=true\\n    function getActiveFarmableCount() internal view returns (uint256) {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        uint256 activeCount = 0;\\n        for (uint256 i = 1; i <= lfs.farmableItemCount; i++) {\\n            if (lfs.farmableItemData[i].active) {\\n                activeCount++;\\n            }\\n        }\\n        return activeCount;\\n    }\\n\\n    // check valid farmable item ID by checking it is below farmableItemCount\\n    function enforceValidFarmableItemId(uint256 farmableItemId) internal view {\\n        require(\\n            farmableItemId > 0 &&\\n                farmableItemId <= farmingStorage().farmableItemCount,\\n            \\\"LibFarming: Invalid farmable item ID.\\\"\\n        );\\n    }\\n\\n    /// @notice Adds a new minion pool ID.\\n    /// @param poolId The ID of the minion pool to add.\\n    function addMinionPoolId(uint256 poolId) internal {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        require(\\n            minionPoolExists(poolId) == false,\\n            \\\"LibFarming: Minion pool already exists.\\\"\\n        );\\n        lfs.minionPoolIds.push(poolId);\\n        lfs.minionPoolIdToIndex[poolId] = lfs.minionPoolIds.length;\\n    }\\n\\n    /// @notice Checks if a given minion pool ID exists.\\n    /// @param poolId The ID of the minion pool to check.\\n    /// @return True if the pool ID exists, false otherwise.\\n    function minionPoolExists(uint256 poolId) internal view returns (bool) {\\n        return farmingStorage().minionPoolIdToIndex[poolId] > 0;\\n    }\\n\\n    /// @notice Returns the index of a given minion pool ID.\\n    /// @param poolId The ID of the minion pool to find.\\n    /// @return The index of the given minion pool ID.\\n    function getMinionPoolIndex(\\n        uint256 poolId\\n    ) internal view returns (uint256) {\\n        return farmingStorage().minionPoolIdToIndex[poolId] - 1;\\n    }\\n\\n    /// @notice Removes a given minion pool ID.\\n    /// @param poolId The ID of the minion pool to remove.\\n    function removeMinionPoolId(uint256 poolId) internal {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        require(\\n            minionPoolExists(poolId),\\n            \\\"LibFarming: Minion pool does not exist.\\\"\\n        );\\n        uint256 index = getMinionPoolIndex(poolId);\\n        lfs.minionPoolIds[index] = lfs.minionPoolIds[\\n            lfs.minionPoolIds.length - 1\\n        ];\\n        lfs.minionPoolIds.pop();\\n        lfs.minionPoolIdToIndex[poolId] = 0;\\n    }\\n\\n    /// @notice Adds a new husk pool ID.\\n    /// @param poolId The ID of the husk pool to add.\\n    function addHuskPoolId(uint256 poolId) internal {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        require(\\n            huskPoolExists(poolId) == false,\\n            \\\"LibFarming: Husk pool already exists.\\\"\\n        );\\n        lfs.huskPoolIds.push(poolId);\\n        lfs.huskPoolIdToIndex[poolId] = lfs.huskPoolIds.length;\\n    }\\n\\n    /// @notice Checks if a given husk pool ID exists.\\n    /// @param poolId The ID of the husk pool to check.\\n    /// @return True if the pool ID exists, false otherwise.\\n    function huskPoolExists(uint256 poolId) internal view returns (bool) {\\n        return farmingStorage().huskPoolIdToIndex[poolId] > 0;\\n    }\\n\\n    /// @notice Removes a given husk pool ID.\\n    /// @param poolId The ID of the husk pool to remove.\\n    function removeHuskPoolId(uint256 poolId) internal {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        require(\\n            huskPoolExists(poolId),\\n            \\\"LibFarming: Husk pool does not exist.\\\"\\n        );\\n        uint256 index = getHuskPoolIndex(poolId);\\n        lfs.huskPoolIds[index] = lfs.huskPoolIds[lfs.huskPoolIds.length - 1];\\n        lfs.huskPoolIds.pop();\\n        lfs.huskPoolIdToIndex[poolId] = 0;\\n    }\\n\\n    /// @notice Returns the index of a given husk pool ID.\\n    /// @param poolId The ID of the husk pool to find.\\n    /// @return The index of the given husk pool ID.\\n    function getHuskPoolIndex(uint256 poolId) internal view returns (uint256) {\\n        return farmingStorage().huskPoolIdToIndex[poolId] - 1;\\n    }\\n\\n    /// @notice Returns the list of husk pool IDs.\\n    /// @return huskPoolIds An array containing all the husk pool IDs.\\n    function getHuskPoolIds()\\n        internal\\n        view\\n        returns (uint256[] memory huskPoolIds)\\n    {\\n        return farmingStorage().huskPoolIds;\\n    }\\n\\n    /// @notice Returns the list of minion pool IDs.\\n    /// @return minionPoolIds An array containing all the minion pool IDs.\\n    function getMinionPoolIds()\\n        internal\\n        view\\n        returns (uint256[] memory minionPoolIds)\\n    {\\n        return farmingStorage().minionPoolIds;\\n    }\\n\\n    /// @notice Retrieves the total supply of husks by iterating through all husk pool IDs.\\n    /// @return totalHusks The total supply of husks across all husk pools.\\n    function getTotalHusks() internal view returns (uint256 totalHusks) {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        TerminusFacet terminusFacet = TerminusFacet(\\n            LibDiamond.diamondStorage().shadowcornItemsAddress\\n        );\\n\\n        for (uint256 i = 0; i < lfs.huskPoolIds.length; i++) {\\n            totalHusks += terminusFacet.terminusPoolSupply(lfs.huskPoolIds[i]);\\n        }\\n    }\\n\\n    /// @notice Retrieves the total supply of minions by iterating through all minion pool IDs.\\n    /// @return totalMinions The total supply of minions across all minion pools.\\n    function getTotalMinions() internal view returns (uint256 totalMinions) {\\n        LibFarmingStorage storage lfs = farmingStorage();\\n        TerminusFacet terminusFacet = TerminusFacet(\\n            LibDiamond.diamondStorage().shadowcornItemsAddress\\n        );\\n\\n        for (uint256 i = 0; i < lfs.minionPoolIds.length; i++) {\\n            totalMinions += terminusFacet.terminusPoolSupply(\\n                lfs.minionPoolIds[i]\\n            );\\n        }\\n    }\\n\\n    /// @notice Enforces the validity of a Terminus pool ID.\\n    /// @param poolId The ID of the Terminus pool to validate.\\n    /// @dev Reverts if the pool ID is greater than the total number of Terminus pools.\\n    function enforceValidTerminusPoolId(uint256 poolId) internal view {\\n        require(\\n            poolId <=\\n                TerminusFacet(\\n                    LibDiamond.diamondStorage().shadowcornItemsAddress\\n                ).totalPools(),\\n            \\\"LibFarming: Terminus pool does not exist.\\\"\\n        );\\n    }\\n\\n    /// @notice Returns the farming storage structure.\\n    function farmingStorage()\\n        internal\\n        pure\\n        returns (LibFarmingStorage storage lfs)\\n    {\\n        bytes32 position = FARMING_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            lfs.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"IShadowcornStatsFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\ninterface IShadowcornStatsFacet {\\n\\n    // //  Classes\\n    // uint256 constant FIRE = 1;\\n    // uint256 constant SLIME = 2;\\n    // uint256 constant VOLT = 3;\\n    // uint256 constant SOUL = 4;\\n    // uint256 constant NEBULA = 5;\\n\\n    // //  Stats\\n    // uint256 constant MIGHT = 1;\\n    // uint256 constant WICKEDNESS = 2;\\n    // uint256 constant TENACITY = 3;\\n    // uint256 constant CUNNING = 4;\\n    // uint256 constant ARCANA = 5;\\n\\n    // //  Rarities\\n    // uint256 constant COMMON = 1;\\n    // uint256 constant RARE = 2;\\n    // uint256 constant MYTHIC = 3;\\n\\n    function getClass(uint256 tokenId) external view returns (uint256 class);\\n    function getClassRarityAndStat(uint256 tokenId, uint256 statId) external view returns (uint256 class, uint256 rarity, uint256 stat);\\n    function getStats(uint256 tokenId) external view returns (uint256 might, uint256 wickedness, uint256 tenacity, uint256 cunning, uint256 arcana);\\n    function getMight(uint256 tokenId) external view returns (uint256 might);\\n    function getWickedness(uint256 tokenId) external view returns (uint256 wickedness);\\n    function getTenacity(uint256 tokenId) external view returns (uint256 tenacity);\\n    function getCunning(uint256 tokenId) external view returns (uint256 cunning);\\n    function getArcana(uint256 tokenId) external view returns (uint256 arcana);\\n    function getRarity(uint256 tokenId) external view returns (uint256 rarity);\\n}\\n\"\r\n    },\r\n    \"LevelFullInfo.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\nimport {LevelUnlockCost} from \\\"LevelUnlockCost.sol\\\";\\n\\nstruct LevelFullInfo {\\n    LevelUnlockCost[] unlockCosts; \\n    uint256 cumulativeBonus; \\n    uint256 cumulativeHuskLimit;\\n    uint256 hatcheryLevel;\\n}\"\r\n    },\r\n    \"LibHatcheryRitualComponents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {IERC20} from \\\"IERC20.sol\\\";\\nimport {ERC20Burnable} from \\\"ERC20Burnable.sol\\\";\\nimport {LibToken} from \\\"LibToken.sol\\\";\\nimport {LibRitualData} from \\\"LibRitualData.sol\\\";\\nimport {TerminusFacet} from \\\"TerminusFacet.sol\\\";\\nimport {LibRitualComponents} from \\\"LibRitualComponents.sol\\\";\\nimport {LibFarming} from \\\"LibFarming.sol\\\";\\nimport {LibRewards} from \\\"LibRewards.sol\\\";\\n\\nlibrary LibHatcheryRitualComponents {\\n    // @notice This function makes the player pay a RitualCost.\\n    // @param cost The cost to be paid.\\n    function payCost(LibRitualComponents.RitualCost memory cost) internal {\\n        LibRitualComponents.RitualCostTransferType transferType = LibRitualComponents\\n                .RitualCostTransferType(cost.transferType);\\n        if (cost.component.assetType == LibToken.TYPE_ERC20) {\\n            if (\\n                transferType == LibRitualComponents.RitualCostTransferType.BURN\\n            ) {\\n                ERC20Burnable(cost.component.asset).burnFrom(\\n                    msg.sender,\\n                    cost.component.amount\\n                );\\n            } else if (\\n                transferType ==\\n                LibRitualComponents.RitualCostTransferType.TRANSFER\\n            ) {\\n                IERC20(cost.component.asset).transferFrom(\\n                    msg.sender,\\n                    LibDiamond.gameBankAddress(),\\n                    cost.component.amount\\n                );\\n            }\\n        } else if (cost.component.assetType == LibToken.TYPE_ERC1155) {\\n            if (\\n                transferType == LibRitualComponents.RitualCostTransferType.BURN\\n            ) {\\n                TerminusFacet(cost.component.asset).burn(\\n                    msg.sender,\\n                    cost.component.poolId,\\n                    cost.component.amount\\n                );\\n            } else if (\\n                transferType ==\\n                LibRitualComponents.RitualCostTransferType.TRANSFER\\n            ) {\\n                revert(\\n                    \\\"LibHatcheryRitualComponents: ERC1155s should not be transferred as costs.\\\"\\n                );\\n            }\\n        } else {\\n            revert(\\\"LibHatcheryRitualComponents: Invalid cost asset type.\\\");\\n        }\\n    }\\n\\n    // @notice This function makes the player receive a RitualProduct.\\n    // @param product The product to be received.\\n    function mintProduct(\\n        LibRitualComponents.RitualProduct memory product\\n    ) internal {\\n        LibRitualComponents.RitualProductTransferType transferType = LibRitualComponents\\n                .RitualProductTransferType(product.transferType);\\n        if (product.component.assetType == LibToken.TYPE_ERC20) {\\n            if (\\n                transferType ==\\n                LibRitualComponents.RitualProductTransferType.TRANSFER\\n            ) {\\n                IERC20(product.component.asset).transferFrom(\\n                    LibDiamond.gameBankAddress(),\\n                    msg.sender,\\n                    product.component.amount\\n                );\\n            } else if (\\n                transferType ==\\n                LibRitualComponents.RitualProductTransferType.MINT\\n            ) {\\n                revert(\\n                    \\\"LibHatcheryRitualComponents: ERC20 should not be minted as products.\\\"\\n                );\\n            }\\n        } else if (product.component.assetType == LibToken.TYPE_ERC1155) {\\n            if (\\n                transferType ==\\n                LibRitualComponents.RitualProductTransferType.MINT\\n            ) {\\n                TerminusFacet(product.component.asset).mint(\\n                    msg.sender,\\n                    product.component.poolId,\\n                    product.component.amount,\\n                    \\\"\\\"\\n                );\\n                addTokenToQueueIfMinion(product.component.poolId, product.component.amount, msg.sender);\\n            } else if (\\n                transferType ==\\n                LibRitualComponents.RitualProductTransferType.TRANSFER\\n            ) {\\n                revert(\\n                    \\\"LibHatcheryRitualComponents: ERC1155s should not be transferred as products.\\\"\\n                );\\n            }\\n        } else {\\n            revert(\\\"LibHatcheryRitualComponents: Invalid product asset type.\\\");\\n        }\\n    }\\n\\n    function addTokenToQueueIfMinion(uint256 poolId, uint256 quantity, address user) internal {\\n        if (LibFarming.minionPoolExists(poolId)) {\\n            LibRewards.addToQueue(quantity, user);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"LibRewards.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\nimport \\\"IERC20.sol\\\";\\n\\nimport {LibPlayerQueue} from \\\"LibPlayerQueue.sol\\\";\\nimport {LibGlobalQueue} from \\\"LibGlobalQueue.sol\\\";\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport {LibEvents} from \\\"LibEvents.sol\\\";\\nimport {LibTime} from \\\"LibTime.sol\\\";\\n\\ninterface IERC20Mintable is IERC20 {\\n    function mint(address to, uint256 amount) external returns (bool);\\n}\\n\\n/// @title LibRewards\\n/// @author Shiva Shanmuganathan\\n/// @dev Implementation of the daily rewards in minion hatchery\\nlibrary LibRewards {\\n    // Position to store the rewards storage\\n    bytes32 private constant REWARD_STORAGE_POSITION =\\n        keccak256(\\\"CryptoUnicorns.Rewards.Storage\\\");\\n\\n    using LibPlayerQueue for LibPlayerQueue.QueueStorage;\\n    using LibGlobalQueue for LibGlobalQueue.QueueStorage;\\n\\n    // Reward storage struct that holds all relevant reward data\\n    struct LibRewardsStorage {\\n        mapping(address => LibPlayerQueue.QueueStorage) playerQueue; // Player-specific reward queue\\n        LibGlobalQueue.QueueStorage globalQueue; // Global reward queue\\n        uint256 waveUNIM; // Amount of UNIM tokens to be released per wave\\n        uint256 waveDarkMarks; // Amount of DarkMarks tokens to be released per wave\\n        uint256 waveTime; // Timestamp of the current reward wave\\n        uint256 waveCount; // Number of reward waves\\n        bool initialized; // Whether the reward system has been initialized\\n        uint256 distributedUNIM; // Amount of UNIM tokens distributed\\n        uint256 distributedDarkMarks; // Amount of DarkMarks tokens distributed\\n    }\\n\\n    /// @notice Initializes the global reward queue.\\n    /// @dev Must be called once before using the reward system. This function sets the reward wave.\\n    function initializeGlobalQueue() internal {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n        // initialize\\n        require(\\n            globalQueue.isInitialized() == false,\\n            \\\"Global Queue already initialised\\\"\\n        );\\n        globalQueue.initialize();\\n        beginNewWave();\\n        lrs.initialized = true;\\n    }\\n\\n    /// @notice Begins the current reward wave\\n    /// @dev Should be called whenever a new reward wave starts.\\n    /// @dev This should happen approximately every 24 hours depending on user minion creation.\\n    /// @dev Updates unclaimed reward quantities.\\n    /// @custom:emits BegunNewWave\\n    function beginNewWave() internal {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        uint256 lastWaveTime = lrs.waveTime;\\n        if (lrs.initialized) {\\n            (lrs.waveCount, lrs.waveTime) = calculateCurrentWaveData();\\n        } else {\\n            lrs.waveCount = lrs.waveCount + 1;\\n            lrs.waveTime = calculateMidnightUTCTime();\\n        }\\n\\n        emit LibEvents.BegunNewWave(lrs.waveCount, lastWaveTime, lrs.waveTime);\\n    }\\n\\n    /// @notice Calculate Current Wave Data\\n    /// @dev Calculates the current wave count and the corresponding wave time in UTC, considering midnight as the beginning of a new wave.\\n    /// @return currentWaveCount The current wave count, including any new waves since the last recorded wave time.\\n    /// @return currentWaveTime The timestamp of the beginning of the current wave, corresponding to midnight UTC on the current day.\\n    function calculateCurrentWaveData()\\n        internal\\n        view\\n        returns (uint256 currentWaveCount, uint256 currentWaveTime)\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        uint256 lastWaveTime = lrs.waveTime;\\n        currentWaveTime = calculateMidnightUTCTime();\\n        uint256 waveCountToAdd = (currentWaveTime - lastWaveTime) /\\n            LibTime.SECONDS_PER_DAY;\\n        currentWaveCount = lrs.waveCount + waveCountToAdd;\\n    }\\n\\n    /// @notice Calculate Midnight UTC Time\\n    /// @dev Calculates the timestamp corresponding to midnight UTC of the current day. This is used to identify the beginning of a new wave.\\n    /// @return newWaveTime The timestamp representing midnight UTC on the current day.\\n    function calculateMidnightUTCTime()\\n        internal\\n        view\\n        returns (uint256 newWaveTime)\\n    {\\n        (uint year, uint month, uint day) = LibTime._daysToDate(\\n            block.timestamp / LibTime.SECONDS_PER_DAY\\n        );\\n        newWaveTime = LibTime.timestampFromDate(year, month, day);\\n    }\\n\\n    /// @notice Adds player's contribution to player and global queue\\n    /// @dev This function should be triggered by a function in the facet layer when minions are created using recipes, passing the number of minions and the user creating them.\\n    /// @dev Adds a player to the reward queue for a given quantity of tokens.\\n    /// @param quantity The quantity of tokens to add to the player's reward queue.\\n    /// @param user The address of the player to add to the queue.\\n    function addToQueue(uint256 quantity, address user) internal {\\n        checkAndInitializePlayerQueue(user);\\n\\n        (\\n            uint256 waveUNIM,\\n            uint256 waveDarkMarks,\\n            bool globalQueueUpdated\\n        ) = handleExpiredWave(\\n                rewardStorage().waveUNIM,\\n                rewardStorage().waveDarkMarks,\\n                quantity\\n            );\\n\\n        handleQueueUpdates(\\n            user,\\n            rewardStorage().waveCount,\\n            quantity,\\n            waveUNIM,\\n            waveDarkMarks,\\n            globalQueueUpdated\\n        );\\n\\n        emit LibEvents.AddedToQueue(user, rewardStorage().waveCount, quantity);\\n    }\\n\\n    /// @notice Get the wave IDs for the start and end of a specified range based on the current wave count.\\n    /// @dev If the current wave count is greater than 1, the startWaveId is set to currentWaveCount - 1.\\n    ///      If the current wave count is greater or equal to 7, the endWaveId is set to currentWaveCount - 7.\\n    ///      Otherwise, startWaveId and endWaveId are set to 0.\\n    /// @return startWaveId The starting wave ID of the range.\\n    /// @return endWaveId The ending wave ID of the range.\\n    /// @return currentWaveCount The current wave count at the time of calling this function.\\n    function getWaveIdRange()\\n        internal\\n        view\\n        returns (\\n            uint256 startWaveId,\\n            uint256 endWaveId,\\n            uint256 currentWaveCount\\n        )\\n    {\\n        (currentWaveCount, ) = calculateCurrentWaveData();\\n\\n        if (currentWaveCount > 1) {\\n            startWaveId = currentWaveCount - 1;\\n        } else {\\n            startWaveId = 0;\\n        }\\n\\n        if (currentWaveCount >= 7) {\\n            endWaveId = currentWaveCount - 7;\\n        } else {\\n            endWaveId = 0;\\n        }\\n\\n        return (startWaveId, endWaveId, currentWaveCount);\\n    }\\n\\n    /// @notice Calculates the rewards owed to a player for a specific wave ID.\\n    /// @param waveId The ID of the wave for which to calculate the rewards.\\n    /// @param player The address of the player for whom to calculate the rewards.\\n    /// @return owedUNIM The amount of UNIM tokens owed to the player for the given wave ID.\\n    /// @return owedDarkMarks The amount of DarkMarks tokens owed to the player for the given wave ID.\\n    function calculateRewardsByWaveId(\\n        uint256 waveId,\\n        address player\\n    ) internal view returns (uint256 owedUNIM, uint256 owedDarkMarks) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[\\n            player\\n        ];\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n\\n        uint256 playerMinionQty = playerQueue.getQtyByWaveId(waveId);\\n        uint256 globalMinionQty = globalQueue.getQtyByWaveId(waveId);\\n\\n        uint256 totalUNIM = globalQueue.getWaveUNIMByWaveId(waveId);\\n        uint256 totalDarkMarks = globalQueue.getWaveDarkMarksByWaveId(waveId);\\n\\n        owedUNIM = (totalUNIM * playerMinionQty) / globalMinionQty;\\n        owedDarkMarks = (totalDarkMarks * playerMinionQty) / globalMinionQty;\\n\\n        return (owedUNIM, owedDarkMarks);\\n    }\\n\\n    /// @notice Handles the updates to both the player queue and global queue, enqueuing or updating the quantity as required.\\n    /// @param user The address of the user whose queue is to be updated.\\n    /// @param waveCount The current wave count at the time of the update.\\n    /// @param quantity The quantity to be added or updated in the queues.\\n    /// @param waveUNIM The amount of UNIM tokens associated with the wave.\\n    /// @param waveDarkMarks The amount of DarkMarks tokens associated with the wave.\\n    /// @param globalQueueUpdated A boolean flag indicating whether the global queue has already been updated for the wave.\\n    function handleQueueUpdates(\\n        address user,\\n        uint256 waveCount,\\n        uint256 quantity,\\n        uint256 waveUNIM,\\n        uint256 waveDarkMarks,\\n        bool globalQueueUpdated\\n    ) internal {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[user];\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n\\n        if (!playerQueue.waveIdExistsInQueue(waveCount)) {\\n            // add to playerQueue\\n            playerQueue.enqueue(waveCount, quantity);\\n        } else {\\n            // update playerQueue\\n            playerQueue.updateQty(waveCount, quantity);\\n        }\\n\\n        if (!globalQueue.waveIdExistsInQueue(waveCount)) {\\n            // add to globalQueue\\n            globalQueue.enqueue(\\n                waveCount,\\n                quantity,\\n                waveUNIM,\\n                waveDarkMarks,\\n                waveUNIM,\\n                waveDarkMarks\\n            );\\n        } else {\\n            if (!globalQueueUpdated) {\\n                // update globalQueue\\n                globalQueue.updateQty(waveCount, quantity);\\n            }\\n        }\\n    }\\n\\n    /// @notice Ensures the player queue for a specific user is initialized, calling the initialize function if it has not been done yet.\\n    /// @param user The address of the user whose queue needs to be initialized if not already done.\\n    function checkAndInitializePlayerQueue(address user) internal {\\n        LibPlayerQueue.QueueStorage storage playerQueue = rewardStorage()\\n            .playerQueue[user];\\n        if (playerQueue.isInitialized() == false) {\\n            playerQueue.initialize();\\n        }\\n    }\\n\\n    /// @notice Handle processing of an expired wave.\\n    /// @param waveUNIM The initial amount of UNIM for the wave.\\n    /// @param waveDarkMarks The initial amount of DarkMarks for the wave.\\n    /// @param quantity The quantity to be processed.\\n    /// @return _waveUNIM The updated amount of UNIM after handling the expired wave.\\n    /// @return _waveDarkMarks The updated amount of DarkMarks after handling the expired wave.\\n    /// @return _globalQueueUpdated A boolean flag indicating if the global queue was updated.\\n    ///\\n    /// This function checks if the current wave is expired and performs necessary operations\\n    /// such as dequeuing outdated waves, updating wave rewards, and adding new entries to the\\n    /// global queue. If the wave is not expired, the original parameters are returned unchanged.\\n    function handleExpiredWave(\\n        uint256 waveUNIM,\\n        uint256 waveDarkMarks,\\n        uint256 quantity\\n    )\\n        internal\\n        returns (\\n            uint256 _waveUNIM,\\n            uint256 _waveDarkMarks,\\n            bool _globalQueueUpdated\\n        )\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n        if (isWaveExpired()) {\\n            (uint256 currentWaveCount, ) = calculateCurrentWaveData();\\n            // check if global queue has more than 7 days of txs\\n            if (globalQueue.hasOutdatedWaves(currentWaveCount)) {\\n                // getDequeueCount\\n                uint256 dequeueCount = globalQueue.getDequeueCount(\\n                    currentWaveCount\\n                );\\n\\n                // get total unclaimed rewards in dequeued txs\\n                (\\n                    uint256 totalUnclaimedUNIM,\\n                    uint256 totalUnclaimedDarkMarks\\n                ) = globalQueue.getUnclaimedRewardsInQueue(currentWaveCount);\\n\\n                for (uint256 i = 0; i < dequeueCount; i++) {\\n                    // dequeue\\n                    globalQueue.dequeue();\\n                }\\n\\n                // update wave rewards\\n                waveUNIM = waveUNIM + totalUnclaimedUNIM;\\n                waveDarkMarks = waveDarkMarks + totalUnclaimedDarkMarks;\\n            }\\n\\n            beginNewWave();\\n\\n            // add to globalQueue\\n            globalQueue.enqueue(\\n                lrs.waveCount,\\n                quantity,\\n                waveUNIM,\\n                waveDarkMarks,\\n                waveUNIM,\\n                waveDarkMarks\\n            );\\n            return (waveUNIM, waveDarkMarks, true);\\n        }\\n        return (waveUNIM, waveDarkMarks, false);\\n    }\\n\\n    /// @notice Claims the rewards for the calling user and transfers the corresponding tokens.\\n    /// @dev Dequeues contributions older than a day in player queue\\n    /// @dev Calculate rewards with the playerMinionsQty and globalMinionsQty in the last 7 days except the last 24 hours\\n    /// @return rewardUNIM The total amount of UNIM tokens that were claimed.\\n    /// @return rewardDarkMarks The total amount of DarkMarks tokens that were claimed.\\n    function claimRewards()\\n        internal\\n        returns (uint256 rewardUNIM, uint256 rewardDarkMarks)\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[\\n            msg.sender\\n        ];\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n\\n        (\\n            uint256 startWaveId,\\n            uint256 endWaveId,\\n            uint256 currentWaveCount\\n        ) = getWaveIdRange();\\n\\n        // loop from today's wave id back to the 6 waves before\\n        for (uint256 waveId = startWaveId; waveId > endWaveId; waveId--) {\\n            // check if wave id exists in both queues\\n            if (\\n                playerQueue.waveIdExistsInQueue(waveId) &&\\n                globalQueue.waveIdExistsInQueue(waveId)\\n            ) {\\n                // calculate rewards by wave id\\n                (\\n                    uint256 owedUNIM,\\n                    uint256 owedDarkMarks\\n                ) = calculateRewardsByWaveId(waveId, msg.sender);\\n\\n                globalQueue.deductClaimedRewards(\\n                    waveId,\\n                    owedUNIM,\\n                    owedDarkMarks\\n                );\\n\\n                rewardUNIM += owedUNIM;\\n                rewardDarkMarks += owedDarkMarks;\\n            }\\n        }\\n\\n        uint256 playerDequeueCount = playerQueue.getDequeueCount(\\n            currentWaveCount\\n        );\\n        // dequeue txs older than 1 day in player queue\\n        for (uint256 i = 0; i < playerDequeueCount; i++) {\\n            playerQueue.dequeue();\\n        }\\n\\n        // add distributed rewards\\n        lrs.distributedUNIM += rewardUNIM;\\n        lrs.distributedDarkMarks += rewardDarkMarks;\\n\\n        // check if player has any rewards to redeem\\n        IERC20 unimToken = IERC20(LibDiamond.diamondStorage().unimTokenAddress);\\n        bool transferStatus = unimToken.transfer(msg.sender, rewardUNIM);\\n        require(transferStatus == true, \\\"LibRewards: UNIM Transfer Failed\\\");\\n\\n        IERC20Mintable darkMarksToken = IERC20Mintable(\\n            LibDiamond.diamondStorage().darkMarksTokenAddress\\n        );\\n        bool mintStatus = darkMarksToken.mint(msg.sender, rewardDarkMarks);\\n        require(mintStatus == true, \\\"LibRewards: DarkMarks Mint Failed\\\");\\n\\n        emit LibEvents.ClaimedRewards(msg.sender, rewardUNIM, rewardDarkMarks);\\n    }\\n\\n    /// @notice Retrieves the current wave count from the rewards storage.\\n    /// @return waveCount The current wave count value.\\n    function getWaveCount() internal view returns (uint256 waveCount) {\\n        return rewardStorage().waveCount;\\n    }\\n\\n    /// @notice Retrieves the current wave time from the rewards storage.\\n    /// @return waveTime The current wave time value.\\n    function getWaveTime() internal view returns (uint256 waveTime) {\\n        return rewardStorage().waveTime;\\n    }\\n\\n    /// @notice Calculates the total rewards (UNIM and Dark Marks) for a specific user based on wave IDs.\\n    /// @param user The address of the user whose rewards are to be calculated.\\n    /// @return rewardUNIM The total UNIM rewards owed to the user.\\n    /// @return rewardDarkMarks The total Dark Marks rewards owed to the user.\\n    function getPlayerRewards(\\n        address user\\n    ) internal view returns (uint256 rewardUNIM, uint256 rewardDarkMarks) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[user];\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n\\n        (\\n            uint256 startWaveId,\\n            uint256 endWaveId,\\n            uint256 currentWaveCount\\n        ) = getWaveIdRange();\\n\\n        // loop from today's wave id back to the 6 waves before\\n        for (uint256 waveId = startWaveId; waveId > endWaveId; waveId--) {\\n            // check if wave id exists in both queues\\n            if (\\n                playerQueue.waveIdExistsInQueue(waveId) &&\\n                globalQueue.waveIdExistsInQueue(waveId)\\n            ) {\\n                // calculate rewards by wave id\\n                (\\n                    uint256 owedUNIM,\\n                    uint256 owedDarkMarks\\n                ) = calculateRewardsByWaveId(waveId, user);\\n\\n                rewardUNIM += owedUNIM;\\n                rewardDarkMarks += owedDarkMarks;\\n            }\\n        }\\n        return (rewardUNIM, rewardDarkMarks);\\n    }\\n\\n    /// @dev Internal function to get the length of the player-specific queue.\\n    /// @param user The address of the player whose queue length is to be retrieved.\\n    /// @return length The number of items in the player's queue.\\n    function getPlayerQueueLength(\\n        address user\\n    ) internal view returns (uint256 length) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[user];\\n        return playerQueue.length();\\n    }\\n\\n    /// @dev Internal function to get the length of the global queue.\\n    /// @return length The number of items in the global queue.\\n    function getGlobalQueueLength() internal view returns (uint256 length) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n        return globalQueue.length();\\n    }\\n\\n    /// @dev Internal function to get the front (oldest) item of the player's queue.\\n    /// @param user The address of the player whose queue is being accessed.\\n    /// @return waveId The waveId of the front item in the player's queue.\\n    /// @return quantity The quantity associated with the front item in the player's queue.\\n    function getPlayerQueueFront(\\n        address user\\n    ) internal view returns (uint256 waveId, uint256 quantity) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[user];\\n        return playerQueue.peek();\\n    }\\n\\n    /// @dev Internal function to get the front (oldest) item of the global queue.\\n    /// @return waveId The waveId of the front item in the global queue.\\n    /// @return quantity The quantity associated with the front item in the global queue.\\n    function getGlobalQueueFront()\\n        internal\\n        view\\n        returns (\\n            uint256 waveId,\\n            uint256 quantity,\\n            uint256 waveUNIM,\\n            uint256 waveDarkMarks,\\n            uint256 unclaimedUnim,\\n            uint256 unclaimedDarkmarks\\n        )\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n        return globalQueue.peek();\\n    }\\n\\n    /// @dev Internal function to get the tail (newest) item of the player-specific queue.\\n    /// @param user The address of the player whose queue is being accessed.\\n    /// @return waveId The waveId of the tail item in the player-specific queue.\\n    /// @return quantity The quantity associated with the tail item in the player-specific queue.\\n    function getPlayerQueueTail(\\n        address user\\n    ) internal view returns (uint256 waveId, uint256 quantity) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[user];\\n        return playerQueue.peekLast();\\n    }\\n\\n    /// @dev Internal function to get the tail (newest) item of the global queue.\\n    /// @return waveId The waveId of the tail item in the global queue.\\n    /// @return quantity The quantity associated with the tail item in the global queue.\\n    function getGlobalQueueTail()\\n        internal\\n        view\\n        returns (\\n            uint256 waveId,\\n            uint256 quantity,\\n            uint256 waveUNIM,\\n            uint256 waveDarkMarks,\\n            uint256 unclaimedUnim,\\n            uint256 unclaimedDarkmarks\\n        )\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n        return globalQueue.peekLast();\\n    }\\n\\n    /// @dev Internal function to get the item at the specified index in the player-specific queue.\\n    /// @param user The address of the player whose queue is being accessed.\\n    /// @param index The index of the item to retrieve from the player-specific queue.\\n    /// @return waveId The waveId of the item at the specified index in the player-specific queue.\\n    /// @return quantity The quantity associated with the item at the specified index in the player-specific queue.\\n    function getPlayerQueueAtIndex(\\n        address user,\\n        uint256 index\\n    ) internal view returns (uint256 waveId, uint256 quantity) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[user];\\n        return playerQueue.at(index);\\n    }\\n\\n    /// @dev Internal function to get the item at the specified index in the global queue.\\n    /// @param index The index of the item to retrieve from the global queue.\\n    /// @return waveId The waveId of the item at the specified index in the global queue.\\n    /// @return quantity The quantity associated with the item at the specified index in the global queue.\\n    function getGlobalQueueAtIndex(\\n        uint256 index\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 waveId,\\n            uint256 quantity,\\n            uint256 waveUNIM,\\n            uint256 waveDarkMarks,\\n            uint256 unclaimedUnim,\\n            uint256 unclaimedDarkmarks\\n        )\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n        return globalQueue.at(index);\\n    }\\n\\n    /// @dev Internal function to retrieve the player-specific queue for the given user.\\n    /// @param user The address of the player whose queue is being accessed.\\n    /// @return waveIdsArray An array containing the waveIds of items in the player-specific queue.\\n    /// @return quantityArray An array containing the quantities associated with items in the player-specific queue.\\n    function getPlayerQueue(\\n        address user\\n    )\\n        internal\\n        view\\n        returns (uint256[] memory waveIdsArray, uint256[] memory quantityArray)\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage queue = lrs.playerQueue[user];\\n\\n        uint256 queueLen = queue.length();\\n        waveIdsArray = new uint256[](queueLen);\\n        quantityArray = new uint256[](queueLen);\\n\\n        for (uint256 i = 0; i < queueLen; i++) {\\n            (uint256 waveId, uint256 quantity) = queue.at(i);\\n            waveIdsArray[i] = waveId;\\n            quantityArray[i] = quantity;\\n        }\\n\\n        return (waveIdsArray, quantityArray);\\n    }\\n\\n    /// @dev Internal function to retrieve the global queue.\\n    /// @return waveIdsArray An array containing the waveIds of items in the global queue.\\n    /// @return quantityArray An array containing the quantities associated with items in the global queue.\\n    function getGlobalQueue()\\n        internal\\n        view\\n        returns (uint256[] memory waveIdsArray, uint256[] memory quantityArray)\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage queue = lrs.globalQueue;\\n\\n        uint256 queueLen = queue.length();\\n        waveIdsArray = new uint256[](queueLen);\\n        quantityArray = new uint256[](queueLen);\\n        for (uint256 i = 0; i < queueLen; i++) {\\n            (uint256 waveId, uint256 quantity, , , , ) = queue.at(i);\\n            waveIdsArray[i] = waveId;\\n            quantityArray[i] = quantity;\\n        }\\n\\n        return (waveIdsArray, quantityArray);\\n    }\\n\\n    /// @dev Internal function to set the wave UNIM tokens available for rewards.\\n    /// @param _waveUNIM The new wave UNIM token value to be set.\\n    function setWaveUNIM(uint256 _waveUNIM) internal {\\n        rewardStorage().waveUNIM = _waveUNIM;\\n    }\\n\\n    /// @dev Internal function to get the wave UNIM tokens available for rewards.\\n    /// @return waveUNIM The wave UNIM token value.\\n    function getWaveUNIM() internal view returns (uint256 waveUNIM) {\\n        return rewardStorage().waveUNIM;\\n    }\\n\\n    /// @dev Internal function to set the wave Dark Marks available for rewards.\\n    /// @param _waveDarkMarks The new wave Dark Marks value to be set.\\n    function setWaveDarkMarks(uint256 _waveDarkMarks) internal {\\n        rewardStorage().waveDarkMarks = _waveDarkMarks;\\n    }\\n\\n    /// @dev Internal function to get the wave Dark Marks available for rewards.\\n    /// @return waveDarkMarks The wave Dark Marks value.\\n    function getWaveDarkMarks() internal view returns (uint256 waveDarkMarks) {\\n        return rewardStorage().waveDarkMarks;\\n    }\\n\\n    /// @dev Internal function to check if the player's queue is initialized.\\n    /// @param user The address of the player whose queue is to be checked.\\n    /// @return isInitialized True if the player's queue is initialized, false otherwise.\\n    function isPlayerQueueInitialized(\\n        address user\\n    ) internal view returns (bool isInitialized) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[user];\\n        return playerQueue.isInitialized();\\n    }\\n\\n    /// @dev Internal function to check if the global queue is initialized.\\n    /// @return isInitialized True if the global queue is initialized, false otherwise.\\n    function isGlobalQueueInitialized()\\n        internal\\n        view\\n        returns (bool isInitialized)\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n        return globalQueue.isInitialized();\\n    }\\n\\n    /// @notice Checks if the current reward wave has expired.\\n    /// @dev Returns true if the time elapsed since the last wave started is greater than or equal to the duration of a reward wave (24 hours).\\n    /// @return isExpired True if the current reward wave is expired, otherwise false.\\n    function isWaveExpired() internal view returns (bool isExpired) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        return block.timestamp - lrs.waveTime >= LibTime.SECONDS_PER_DAY;\\n    }\\n\\n    /// @notice Retrieves the wave rewards (UNIM and Dark Marks) from the global queue.\\n    /// @return waveUNIMArray An array containing the UNIM rewards for each wave in the global queue.\\n    /// @return waveDarkMarksArray An array containing the Dark Marks rewards for each wave in the global queue.\\n    function getGlobalQueueWaveRewards()\\n        internal\\n        view\\n        returns (\\n            uint256[] memory waveUNIMArray,\\n            uint256[] memory waveDarkMarksArray\\n        )\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage queue = lrs.globalQueue;\\n\\n        uint256 queueLen = queue.length();\\n        waveUNIMArray = new uint256[](queueLen);\\n        waveDarkMarksArray = new uint256[](queueLen);\\n        for (uint256 i = 0; i < queueLen; i++) {\\n            (, , uint256 waveUNIM, uint256 waveDarkMarks, , ) = queue.at(i);\\n            waveUNIMArray[i] = waveUNIM;\\n            waveDarkMarksArray[i] = waveDarkMarks;\\n        }\\n\\n        return (waveUNIMArray, waveDarkMarksArray);\\n    }\\n\\n    /// @notice Retrieves the unclaimed rewards (UNIM and Dark Marks) from the global queue.\\n    /// @return unclaimedUnimArray An array containing the unclaimed UNIM for each wave in the global queue.\\n    /// @return unclaimedDarkmarksArray An array containing the unclaimed Dark Marks for each wave in the global queue.\\n    function getGlobalQueueUnclaimedRewards()\\n        internal\\n        view\\n        returns (\\n            uint256[] memory unclaimedUnimArray,\\n            uint256[] memory unclaimedDarkmarksArray\\n        )\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage queue = lrs.globalQueue;\\n\\n        uint256 queueLen = queue.length();\\n        unclaimedUnimArray = new uint256[](queueLen);\\n        unclaimedDarkmarksArray = new uint256[](queueLen);\\n\\n        for (uint256 i = 0; i < queueLen; i++) {\\n            (, , , , uint256 unclaimedUnim, uint256 unclaimedDarkmarks) = queue\\n                .at(i);\\n            unclaimedUnimArray[i] = unclaimedUnim;\\n            unclaimedDarkmarksArray[i] = unclaimedDarkmarks;\\n        }\\n\\n        return (unclaimedUnimArray, unclaimedDarkmarksArray);\\n    }\\n\\n    /// @notice Retrieves the claimable UNIM (Universal Incentive Mechanism) tokens for a given wave ID.\\n    /// @param waveId The wave ID for which to retrieve the claimable UNIM.\\n    /// @return claimableUNIM The amount of claimable UNIM tokens for the specified wave ID.\\n    function getClaimableUNIM(\\n        uint256 waveId\\n    ) internal view returns (uint256 claimableUNIM) {\\n        return rewardStorage().globalQueue.getClaimableUNIM(waveId);\\n    }\\n\\n    /// @notice Retrieves the claimable Dark Marks tokens for a given wave ID.\\n    /// @param waveId The wave ID for which to retrieve the claimable Dark Marks.\\n    /// @return claimableDarkMarks The amount of claimable Dark Marks tokens for the specified wave ID.\\n    function getClaimableDarkMarks(\\n        uint256 waveId\\n    ) internal view returns (uint256 claimableDarkMarks) {\\n        return rewardStorage().globalQueue.getClaimableDarkMarks(waveId);\\n    }\\n\\n    /// @notice Retrieves the UNIM tokens for a given wave ID.\\n    /// @param waveId The wave ID for which to retrieve the UNIM tokens.\\n    /// @return waveUNIM The amount of UNIM tokens for the specified wave ID.\\n    function getWaveUNIMByWaveId(\\n        uint256 waveId\\n    ) internal view returns (uint256 waveUNIM) {\\n        return rewardStorage().globalQueue.getWaveUNIMByWaveId(waveId);\\n    }\\n\\n    /// @notice Retrieves the Dark Marks for a given wave ID.\\n    /// @param waveId The wave ID for which to retrieve the Dark Marks.\\n    /// @return waveDarkMarks The amount of Dark Marks for the specified wave ID.\\n    function getWaveDarkMarksByWaveId(\\n        uint256 waveId\\n    ) internal view returns (uint256 waveDarkMarks) {\\n        return rewardStorage().globalQueue.getWaveDarkMarksByWaveId(waveId);\\n    }\\n\\n    /// @dev Retrieves the total unclaimed rewards in the global queue.\\n    /// Iterates through the queue, summing the unclaimed UNIM and Darkmarks rewards.\\n    /// @return unclaimedUnim The total amount of unclaimed UNIM tokens.\\n    /// @return unclaimedDarkmarks The total amount of unclaimed Darkmarks.\\n    function getUnclaimedRewards()\\n        internal\\n        view\\n        returns (uint256 unclaimedUnim, uint256 unclaimedDarkmarks)\\n    {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibGlobalQueue.QueueStorage storage queue = lrs.globalQueue;\\n\\n        uint256 queueLen = queue.length();\\n        for (uint256 i = 0; i < queueLen; i++) {\\n            (\\n                ,\\n                ,\\n                ,\\n                ,\\n                uint256 _unclaimedUnim,\\n                uint256 _unclaimedDarkmarks\\n            ) = queue.at(i);\\n            unclaimedUnim += _unclaimedUnim;\\n            unclaimedDarkmarks += _unclaimedDarkmarks;\\n        }\\n\\n        return (unclaimedUnim, unclaimedDarkmarks);\\n    }\\n\\n    /// @dev Retrieves the total distributed rewards.\\n    /// @return distributedUNIM The total amount of distributed UNIM tokens.\\n    /// @return distributedDarkMarks The total amount of distributed Darkmarks.\\n    function getDistributedRewards()\\n        internal\\n        view\\n        returns (uint256 distributedUNIM, uint256 distributedDarkMarks)\\n    {\\n        return (\\n            rewardStorage().distributedUNIM,\\n            rewardStorage().distributedDarkMarks\\n        );\\n    }\\n\\n    /// @dev Calculates the contribution percentage of a specific user over the last 7 waves (including the current wave).\\n    /// It calculates the total contribution of a user in comparison to the global contributions.\\n    /// @param user The address of the user whose contribution percentage is being calculated.\\n    /// @return contributionPercentage The percentage of the user's contribution in the last 7 waves.\\n    function getContributionPercentage(\\n        address user\\n    ) internal view returns (uint256 contributionPercentage) {\\n        LibRewardsStorage storage lrs = rewardStorage();\\n        LibPlayerQueue.QueueStorage storage playerQueue = lrs.playerQueue[user];\\n        LibGlobalQueue.QueueStorage storage globalQueue = lrs.globalQueue;\\n\\n        // get today's wave id\\n        (uint256 currentWaveCount, ) = calculateCurrentWaveData();\\n\\n        uint256 startWaveId;\\n        if (currentWaveCount > 1) {\\n            startWaveId = currentWaveCount - 1;\\n        } else {\\n            startWaveId = 0;\\n        }\\n\\n        uint256 endWaveId;\\n        if (currentWaveCount >= 7) {\\n            endWaveId = currentWaveCount - 7;\\n        } else {\\n            endWaveId = 0;\\n        }\\n\\n        uint256 totalPlayerMinions;\\n        uint256 totalGlobalMinions;\\n\\n        // loop from today's wave id back to the 6 waves before\\n        for (uint256 waveId = startWaveId; waveId > endWaveId; waveId--) {\\n            // check if wave id exists in both queues\\n            if (\\n                playerQueue.waveIdExistsInQueue(waveId) &&\\n                globalQueue.waveIdExistsInQueue(waveId)\\n            ) {\\n                // calculate player and global contribution\\n                totalPlayerMinions += playerQueue.getQtyByWaveId(waveId);\\n                totalGlobalMinions += globalQueue.getQtyByWaveId(waveId);\\n            }\\n        }\\n\\n        if (totalGlobalMinions == 0) {\\n            return (0);\\n        }\\n\\n        contributionPercentage =\\n            (totalPlayerMinions * 100) /\\n            totalGlobalMinions;\\n\\n        return (contributionPercentage);\\n    }\\n\\n    /// @notice Returns the daily UNIM rewards.\\n    /// @return dailyUNIM The quantity of UNIM allocated for the current wave.\\n    function getDailyUNIM() internal view returns (uint256 dailyUNIM) {\\n        (uint256 waveId, ) = calculateCurrentWaveData();\\n        dailyUNIM = getWaveUNIMByWaveId(waveId);\\n        if (dailyUNIM == 0) {\\n            dailyUNIM = getWaveUNIM();\\n        }\\n        return dailyUNIM;\\n    }\\n\\n    /// @notice Returns the daily DarkMarks rewards.\\n    /// @return dailyDarkMarks The quantity of DarkMarks allocated for the current wave.\\n    function getDailyDarkMarks()\\n        internal\\n        view\\n        returns (uint256 dailyDarkMarks)\\n    {\\n        (uint256 waveId, ) = calculateCurrentWaveData();\\n        dailyDarkMarks = getWaveDarkMarksByWaveId(waveId);\\n        if (dailyDarkMarks == 0) {\\n            dailyDarkMarks = getWaveDarkMarks();\\n        }\\n        return dailyDarkMarks;\\n    }\\n\\n    /// @notice Returns both the daily UNIM and DarkMarks rewards.\\n    /// @return dailyUNIM The quantity of UNIM allocated for the current wave.\\n    /// @return dailyDarkMarks The quantity of DarkMarks allocated for the current wave.\\n    function getDailyRewards()\\n        internal\\n        view\\n        returns (uint256 dailyUNIM, uint256 dailyDarkMarks)\\n    {\\n        return (getDailyUNIM(), getDailyDarkMarks());\\n    }\\n\\n    /// @dev Retrieves the storage position for LibRewardsStorage using inline assembly.\\n    /// This function accesses the storage location associated with the constant REWARD_STORAGE_POSITION.\\n    /// @return lrs The reference to LibRewardsStorage structure in storage.\\n    function rewardStorage()\\n        internal\\n        pure\\n        returns (LibRewardsStorage storage lrs)\\n    {\\n        bytes32 position = REWARD_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            lrs.slot := position\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"LibPlayerQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\n/// @title LibPlayerQueue\\n/// @author Shiva Shanmuganathan\\n/// @dev Implementation of the queue data structure, providing a library with struct definition for queue storage in consuming contracts.\\n/// @notice This library provides functionalities to manage a queue data structure, allowing contracts to enqueue and dequeue items.\\nlibrary LibPlayerQueue {\\n    struct QueueStorage {\\n        mapping(uint256 idx => uint256 waveId) idxToWaveId;\\n        mapping(uint256 waveId => uint256 quantity) waveIdToQty;\\n        uint256 first;\\n        uint256 last;\\n    }\\n\\n    /// @dev Initializes the queue by setting the first and last indices.\\n    /// @param queue The queue to initialize.\\n    function initialize(QueueStorage storage queue) internal {\\n        queue.first = 1;\\n        queue.last = 0;\\n    }\\n\\n    /// @dev Enqueues a new item into the queue.\\n    /// @param queue The queue to enqueue the item into.\\n    /// @param waveId The waveId of the item.\\n    /// @param quantity The quantity associated with the item.\\n    function enqueue(\\n        QueueStorage storage queue,\\n        uint256 waveId,\\n        uint256 quantity\\n    ) internal {\\n        enforceQueueInitialized(queue);\\n        queue.idxToWaveId[++queue.last] = waveId;\\n        queue.waveIdToQty[waveId] = quantity;\\n    }\\n\\n    /// @dev Dequeues an item from the front of the queue.\\n    /// @param queue The queue to dequeue an item from.\\n    /// @return waveId The waveId of the dequeued item.\\n    /// @return quantity The quantity associated with the dequeued item.\\n    function dequeue(\\n        QueueStorage storage queue\\n    ) internal returns (uint256 waveId, uint256 quantity) {\\n        enforceQueueInitialized(queue);\\n        enforceNonEmptyQueue(queue);\\n\\n        waveId = queue.idxToWaveId[queue.first];\\n        quantity = queue.waveIdToQty[waveId];\\n\\n        delete queue.waveIdToQty[waveId];\\n        delete queue.idxToWaveId[queue.first];\\n\\n        queue.first = queue.first + 1;\\n    }\\n\\n    /// @notice Updates the quantity of rewards associated with a given wave ID in the queue.\\n    /// @dev Ensures that the specified wave ID matches the last wave ID in the queue.\\n    /// @param queue The storage reference to the queue being updated.\\n    /// @param waveId The wave ID for which the quantity is being updated.\\n    /// @param quantity The amount to add to the existing quantity associated with the wave ID.\\n    /// require The specified wave ID must match the last wave ID in the queue.\\n    function updateQty(\\n        QueueStorage storage queue,\\n        uint256 waveId,\\n        uint256 quantity\\n    ) internal {\\n        require(\\n            queue.idxToWaveId[queue.last] == waveId,\\n            \\\"LibPlayerQueue: Wave does not exist in Player Queue.\\\"\\n        );\\n        queue.waveIdToQty[waveId] += quantity;\\n    }\\n\\n    /// @dev Checks if the queue has been initialized.\\n    /// @param queue The queue to check.\\n    /// @return isQueueInitialized True if the queue is initialized, false otherwise.\\n    function isInitialized(\\n        QueueStorage storage queue\\n    ) internal view returns (bool isQueueInitialized) {\\n        return queue.first != 0;\\n    }\\n\\n    /// @dev Checks if the queue is initialized and raises an error if not.\\n    /// @param queue The queue to check for initialization.\\n    function enforceQueueInitialized(QueueStorage storage queue) internal view {\\n        require(\\n            isInitialized(queue),\\n            \\\"LibPlayerQueue: Queue is not initialized.\\\"\\n        );\\n    }\\n\\n    /// @dev Function to check if the queue is not empty.\\n    /// @param queue The queue to check.\\n    function enforceNonEmptyQueue(QueueStorage storage queue) internal view {\\n        require(!isEmpty(queue), \\\"LibPlayerQueue: Queue is empty.\\\");\\n    }\\n\\n    /// @dev Returns the length of the queue.\\n    /// @param queue The queue to get the length of.\\n    /// @return queueLength The length of the queue.\\n    function length(\\n        QueueStorage storage queue\\n    ) internal view returns (uint256 queueLength) {\\n        if (queue.last < queue.first) {\\n            return 0;\\n        }\\n        return queue.last - queue.first + 1;\\n    }\\n\\n    /// @dev Checks if the queue is empty.\\n    /// @param queue The queue to check.\\n    /// @return isQueueEmpty True if the queue is empty, false otherwise.\\n    function isEmpty(\\n        QueueStorage storage queue\\n    ) internal view returns (bool isQueueEmpty) {\\n        return length(queue) == 0;\\n    }\\n\\n    /// @dev Returns the item at the front of the queue without dequeuing it.\\n    /// @param queue The queue to get the front item from.\\n    /// @return waveId The waveId of the front item.\\n    /// @return quantity The quantity associated with the front item.\\n    function peek(\\n        QueueStorage storage queue\\n    ) internal view returns (uint256 waveId, uint256 quantity) {\\n        enforceNonEmptyQueue(queue);\\n        waveId = queue.idxToWaveId[queue.first];\\n        quantity = queue.waveIdToQty[waveId];\\n    }\\n\\n    /// @dev Returns the item at the end of the queue without dequeuing it.\\n    /// @param queue The queue to get the last item from.\\n    /// @return waveId The waveId of the last item.\\n    /// @return quantity The quantity associated with the last item.\\n    function peekLast(\\n        QueueStorage storage queue\\n    ) internal view returns (uint256 waveId, uint256 quantity) {\\n        enforceNonEmptyQueue(queue);\\n        waveId = queue.idxToWaveId[queue.last];\\n        quantity = queue.waveIdToQty[waveId];\\n    }\\n\\n    /// @dev Returns the item at the given index in the queue.\\n    /// @param queue The queue to get the item from.\\n    /// @param idx The index of the item to retrieve.\\n    /// @return waveId The waveId of the item at the given index.\\n    /// @return quantity The quantity associated with the item at the given index.\\n    function at(\\n        QueueStorage storage queue,\\n        uint256 idx\\n    ) internal view returns (uint256 waveId, uint256 quantity) {\\n        idx = idx + queue.first;\\n        waveId = queue.idxToWaveId[idx];\\n        quantity = queue.waveIdToQty[waveId];\\n    }\\n\\n    /// @notice Checks if a given wave ID exists in the specified queue.\\n    /// @param queue The storage reference to the queue being checked.\\n    /// @param waveId The wave ID to check for existence in the queue.\\n    /// @return waveExists A boolean value indicating whether the specified wave ID exists in the queue.\\n    function waveIdExistsInQueue(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (bool waveExists) {\\n        if (queue.waveIdToQty[waveId] == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Retrieves the quantity associated with a given wave ID in the specified queue.\\n    /// @param queue The storage reference to the queue from which the quantity is being retrieved.\\n    /// @param waveId The wave ID for which the quantity is being fetched.\\n    /// @return quantity The quantity associated with the specified wave ID.\\n    function getQtyByWaveId(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (uint256 quantity) {\\n        return queue.waveIdToQty[waveId];\\n    }\\n\\n    /// @notice Calculates the number of elements that can be dequeued from the provided queue based on the given wave ID.\\n    /// @dev This function checks the last element in the queue to determine how many elements can be dequeued.\\n    ///      The dequeuing logic is dependent on whether the last wave ID in the queue matches the given wave ID.\\n    /// @param queue The storage reference to the queue from which the dequeue count is being calculated.\\n    /// @param waveId The wave ID used as the reference point for calculating the dequeue count.\\n    /// @return dequeueCount The calculated number of elements that can be dequeued from the queue.\\n    function getDequeueCount(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (uint256 dequeueCount) {\\n        uint256 queueLen = length(queue);\\n        (uint256 waveIdFromQueue, ) = peekLast(queue);\\n        if (waveIdFromQueue == waveId) {\\n            dequeueCount = queueLen - 1;\\n        } else {\\n            dequeueCount = queueLen;\\n        }\\n        return dequeueCount;\\n    }\\n}\"\r\n    },\r\n    \"LibGlobalQueue.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.20;\\n\\n/// @title LibGlobalQueue\\n/// @author Shiva Shanmuganathan\\n/// @dev Implementation of the queue data structure, providing a library with struct definition for queue storage in consuming contracts.\\n/// @notice This library provides functionalities to manage a queue data structure, allowing contracts to enqueue and dequeue items.\\nlibrary LibGlobalQueue {\\n    struct QueueStorage {\\n        mapping(uint256 idx => uint256 waveId) idxToWaveId;\\n        mapping(uint256 waveId => TxData txData) waveIdToTxData;\\n        uint256 first;\\n        uint256 last;\\n    }\\n\\n    // NOTE: This structure is a STORAGE STRUCT (used in storage), modifying it can have significant implications.\\n    // Please exercise caution and avoid modifying this structure unless absolutely necessary.\\n    struct TxData {\\n        uint256 quantity;\\n        uint256 waveUNIM;\\n        uint256 waveDarkMarks;\\n        uint256 unclaimedUnim;\\n        uint256 unclaimedDarkmarks;\\n    }\\n\\n    /// @dev Initializes the queue by setting the first and last indices.\\n    /// @param queue The queue to initialize.\\n    function initialize(QueueStorage storage queue) internal {\\n        queue.first = 1;\\n        queue.last = 0;\\n    }\\n\\n    /// @dev Enqueues a new item into the queue.\\n    /// @param queue The queue to enqueue the item into.\\n    /// @param waveId The waveId of the item.\\n    /// @param quantity The quantity associated with the item.\\n    /// @param waveUNIM The unim pool associated with the item.\\n    /// @param waveDarkMarks The darkmarks pool associated with the item.\\n    /// @param unclaimedUnim The unclaimed unim associated with the item.\\n    /// @param unclaimedDarkmarks The unclaimed darkmarks associated with the item.\\n    function enqueue(\\n        QueueStorage storage queue,\\n        uint256 waveId,\\n        uint256 quantity,\\n        uint256 waveUNIM,\\n        uint256 waveDarkMarks,\\n        uint256 unclaimedUnim,\\n        uint256 unclaimedDarkmarks\\n    ) internal {\\n        enforceQueueInitialized(queue);\\n        queue.idxToWaveId[++queue.last] = waveId;\\n        queue.waveIdToTxData[waveId] = TxData(\\n            quantity,\\n            waveUNIM,\\n            waveDarkMarks,\\n            unclaimedUnim,\\n            unclaimedDarkmarks\\n        );\\n    }\\n\\n    /// @dev Dequeues an item from the front of the queue.\\n    /// @param queue The queue to dequeue an item from.\\n    /// @return waveId The waveId of the dequeued item.\\n    /// @return quantity The quantity associated with the dequeued item.\\n    /// @return waveUNIM The unim pool associated with the dequeued item.\\n    /// @return waveDarkMarks The darkmarks pool associated with the dequeued item.\\n    /// @return unclaimedUnim The unclaimed unim associated with the dequeued item.\\n    /// @return unclaimedDarkmarks The unclaimed darkmarks associated with the dequeued item.\\n    function dequeue(\\n        QueueStorage storage queue\\n    )\\n        internal\\n        returns (\\n            uint256 waveId,\\n            uint256 quantity,\\n            uint256 waveUNIM,\\n            uint256 waveDarkMarks,\\n            uint256 unclaimedUnim,\\n            uint256 unclaimedDarkmarks\\n        )\\n    {\\n        enforceQueueInitialized(queue);\\n        enforceNonEmptyQueue(queue);\\n        waveId = queue.idxToWaveId[queue.first];\\n        TxData memory txData = queue.waveIdToTxData[waveId];\\n        quantity = txData.quantity;\\n        waveUNIM = txData.waveUNIM;\\n        waveDarkMarks = txData.waveDarkMarks;\\n        unclaimedUnim = txData.unclaimedUnim;\\n        unclaimedDarkmarks = txData.unclaimedDarkmarks;\\n\\n        delete queue.waveIdToTxData[waveId];\\n        delete queue.idxToWaveId[queue.first];\\n        queue.first = queue.first + 1;\\n    }\\n\\n    /// @notice Updates the quantity of rewards associated with a given wave ID in the queue.\\n    /// @dev Ensures that the specified wave ID matches the last wave ID in the queue.\\n    /// @param queue The storage reference to the queue being updated.\\n    /// @param waveId The wave ID for which the quantity is being updated.\\n    /// @param quantity The amount to add to the existing quantity associated with the wave ID.\\n    /// require The specified wave ID must match the last wave ID in the queue.\\n    function updateQty(\\n        QueueStorage storage queue,\\n        uint256 waveId,\\n        uint256 quantity\\n    ) internal {\\n        require(\\n            queue.idxToWaveId[queue.last] == waveId,\\n            \\\"LibGlobalQueue: Wave does not exist in Global Queue.\\\"\\n        );\\n        queue.waveIdToTxData[waveId].quantity += quantity;\\n    }\\n\\n    /// @notice Deducts the claimed UNIM and Dark Marks rewards for a specific wave ID in the provided queue.\\n    /// @dev This function updates the unclaimed rewards within the queue's transaction data, reducing them by the amounts claimed.\\n    /// @param queue The storage reference to the queue where the claimed rewards are being deducted.\\n    /// @param waveId The wave ID for which the rewards are being deducted.\\n    /// @param claimedUnim The amount of UNIM rewards that have been claimed and should be deducted.\\n    /// @param claimedDarkmarks The amount of Dark Marks rewards that have been claimed and should be deducted.\\n    function deductClaimedRewards(\\n        QueueStorage storage queue,\\n        uint256 waveId,\\n        uint256 claimedUnim,\\n        uint256 claimedDarkmarks\\n    ) internal {\\n        TxData storage txData = queue.waveIdToTxData[waveId];\\n        txData.unclaimedUnim -= claimedUnim;\\n        txData.unclaimedDarkmarks -= claimedDarkmarks;\\n    }\\n\\n    /// @dev Checks if the queue has been initialized.\\n    /// @param queue The queue to check.\\n    /// @return isQueueInitialized True if the queue is initialized, false otherwise.\\n    function isInitialized(\\n        QueueStorage storage queue\\n    ) internal view returns (bool isQueueInitialized) {\\n        return queue.first != 0;\\n    }\\n\\n    /// @dev Checks if the queue is initialized and raises an error if not.\\n    /// @param queue The queue to check for initialization.\\n    function enforceQueueInitialized(QueueStorage storage queue) internal view {\\n        require(\\n            isInitialized(queue),\\n            \\\"LibGlobalQueue: Queue is not initialized.\\\"\\n        );\\n    }\\n\\n    /// @dev Function to check if the queue is not empty.\\n    /// @param queue The queue to check.\\n    function enforceNonEmptyQueue(QueueStorage storage queue) internal view {\\n        require(!isEmpty(queue), \\\"LibGlobalQueue: Queue is empty.\\\");\\n    }\\n\\n    /// @dev Returns the length of the queue.\\n    /// @param queue The queue to get the length of.\\n    /// @return queueLength The length of the queue.\\n    function length(\\n        QueueStorage storage queue\\n    ) internal view returns (uint256 queueLength) {\\n        if (queue.last < queue.first) {\\n            return 0;\\n        }\\n        return queue.last - queue.first + 1;\\n    }\\n\\n    /// @dev Checks if the queue is empty.\\n    /// @param queue The queue to check.\\n    /// @return isQueueEmpty True if the queue is empty, false otherwise.\\n    function isEmpty(\\n        QueueStorage storage queue\\n    ) internal view returns (bool isQueueEmpty) {\\n        return length(queue) == 0;\\n    }\\n\\n    /// @dev Returns the item at the front of the queue without dequeuing it.\\n    /// @param queue The queue to get the front item from.\\n    /// @return waveId The waveId of the front item.\\n    /// @return quantity The quantity associated with the front item.\\n    /// @return waveUNIM The unim pool associated with the front item.\\n    /// @return waveDarkMarks The darkmarks pool associated with the front item.\\n    /// @return unclaimedUnim The unclaimed unim associated with the front item.\\n    /// @return unclaimedDarkmarks The unclaimed darkmarks associated with the front item.\\n    function peek(\\n        QueueStorage storage queue\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 waveId,\\n            uint256 quantity,\\n            uint256 waveUNIM,\\n            uint256 waveDarkMarks,\\n            uint256 unclaimedUnim,\\n            uint256 unclaimedDarkmarks\\n        )\\n    {\\n        waveId = queue.idxToWaveId[queue.first];\\n        TxData memory txData = queue.waveIdToTxData[waveId];\\n        quantity = txData.quantity;\\n        waveUNIM = txData.waveUNIM;\\n        waveDarkMarks = txData.waveDarkMarks;\\n        unclaimedUnim = txData.unclaimedUnim;\\n        unclaimedDarkmarks = txData.unclaimedDarkmarks;\\n    }\\n\\n    /// @dev Returns the item at the end of the queue without dequeuing it.\\n    /// @param queue The queue to get the last item from.\\n    /// @return waveId The waveId of the last item.\\n    /// @return quantity The quantity associated with the last item.\\n    /// @return waveUNIM The unim pool associated with the last item.\\n    /// @return waveDarkMarks The darkmarks pool associated with the last item.\\n    /// @return unclaimedUnim The unclaimed unim associated with the last item.\\n    /// @return unclaimedDarkmarks The unclaimed darkmarks associated with the last item.\\n    function peekLast(\\n        QueueStorage storage queue\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 waveId,\\n            uint256 quantity,\\n            uint256 waveUNIM,\\n            uint256 waveDarkMarks,\\n            uint256 unclaimedUnim,\\n            uint256 unclaimedDarkmarks\\n        )\\n    {\\n        waveId = queue.idxToWaveId[queue.last];\\n        TxData memory txData = queue.waveIdToTxData[waveId];\\n        quantity = txData.quantity;\\n        waveUNIM = txData.waveUNIM;\\n        waveDarkMarks = txData.waveDarkMarks;\\n        unclaimedUnim = txData.unclaimedUnim;\\n        unclaimedDarkmarks = txData.unclaimedDarkmarks;\\n    }\\n\\n    /// @dev Returns the item at the given index in the queue.\\n    /// @param queue The queue to get the item from.\\n    /// @param idx The index of the item to retrieve.\\n    /// @return waveId The waveId of the item at the given index.\\n    /// @return quantity The quantity associated with the item at the given index.\\n    /// @return waveUNIM The unim pool associated with the item at the given index.\\n    /// @return waveDarkMarks The darkmarks pool associated with the item at the given index.\\n    /// @return unclaimedUnim The unclaimed unim associated with the item at the given index.\\n    /// @return unclaimedDarkmarks The unclaimed darkmarks associated with the item at the given index.\\n    function at(\\n        QueueStorage storage queue,\\n        uint256 idx\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 waveId,\\n            uint256 quantity,\\n            uint256 waveUNIM,\\n            uint256 waveDarkMarks,\\n            uint256 unclaimedUnim,\\n            uint256 unclaimedDarkmarks\\n        )\\n    {\\n        idx = idx + queue.first;\\n        waveId = queue.idxToWaveId[idx];\\n        TxData memory txData = queue.waveIdToTxData[waveId];\\n        quantity = txData.quantity;\\n        waveUNIM = txData.waveUNIM;\\n        waveDarkMarks = txData.waveDarkMarks;\\n        unclaimedUnim = txData.unclaimedUnim;\\n        unclaimedDarkmarks = txData.unclaimedDarkmarks;\\n    }\\n\\n    /// @notice Checks if a given wave ID exists in the specified queue.\\n    /// @param queue The storage reference to the queue being checked.\\n    /// @param waveId The wave ID to check for existence in the queue.\\n    /// @return waveExists A boolean value indicating whether the specified wave ID exists in the queue.\\n    function waveIdExistsInQueue(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (bool waveExists) {\\n        if (queue.waveIdToTxData[waveId].quantity == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    /// @notice Retrieves the quantity associated with a given wave ID in the specified queue.\\n    /// @param queue The storage reference to the queue from which the quantity is being retrieved.\\n    /// @param waveId The wave ID for which the quantity is being fetched.\\n    /// @return quantity The quantity associated with the specified wave ID.\\n    function getQtyByWaveId(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (uint256 quantity) {\\n        return queue.waveIdToTxData[waveId].quantity;\\n    }\\n\\n    /// @dev Returns the dequeue count for waves more than 7 days old (or 7 waves ago) from the provided waveId.\\n    /// @param queue The queue to get the dequeue count from.\\n    /// @param waveId The waveId from which to count older waves.\\n    /// @return dequeueCount The count of waves more than 7 days old.\\n    function getDequeueCount(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (uint256) {\\n        uint256 dequeueCount = 0;\\n        uint256 waveIdFromQueue;\\n\\n        // If queue length is 0, there's nothing to dequeue.\\n        if (length(queue) == 0) {\\n            return 0;\\n        }\\n\\n        // Loop over the queue from the end to the beginning.\\n        for (uint256 i = 0; i < length(queue); i++) {\\n            // Get the waveIdFromQueue at index i\\n            (waveIdFromQueue, , , , , ) = at(queue, i);\\n\\n            // If the waveIdFromQueue is more than 7 days old, increment dequeueCount and continue.\\n            if (waveId - 6 > waveIdFromQueue) {\\n                dequeueCount++;\\n            } else {\\n                // If the waveIdFromQueue is within 7 days, break the loop.\\n                break;\\n            }\\n        }\\n\\n        return dequeueCount;\\n    }\\n\\n    /// @notice Checks if the queue has any waves that are considered outdated based on the given wave ID.\\n    /// @param queue The storage reference to the queue being checked.\\n    /// @param waveId The wave ID used to determine if there are any outdated waves in the queue.\\n    /// @return waveExists A boolean value indicating whether there are outdated waves in the queue.\\n    function hasOutdatedWaves(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (bool waveExists) {\\n        (uint256 waveIdFromQueueStart, , , , , ) = peek(queue);\\n        if (waveId - waveIdFromQueueStart + 1 > 7) {\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    /// @notice Calculates the total unclaimed rewards in UNIM and DarkMarks for outdated waves in the queue.\\n    /// @param queue The storage reference to the queue being examined.\\n    /// @param waveId The wave ID used to determine if there are any outdated waves in the queue.\\n    /// @return totalUnclaimedUNIM The total unclaimed rewards in UNIM for the outdated waves.\\n    /// @return totalUnclaimedDarkMarks The total unclaimed rewards in DarkMarks for the outdated waves.\\n    function getUnclaimedRewardsInQueue(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    )\\n        internal\\n        view\\n        returns (uint256 totalUnclaimedUNIM, uint256 totalUnclaimedDarkMarks)\\n    {\\n        for (uint256 i = 0; i < length(queue); i++) {\\n            (\\n                uint256 waveIdFromQueue,\\n                ,\\n                ,\\n                ,\\n                uint256 unclaimedUnim,\\n                uint256 unclaimedDarkmarks\\n            ) = at(queue, i);\\n            if (waveId - 6 > waveIdFromQueue) {\\n                totalUnclaimedUNIM += (unclaimedUnim);\\n                totalUnclaimedDarkMarks += (unclaimedDarkmarks);\\n            } else {\\n                break;\\n            }\\n        }\\n        return (totalUnclaimedUNIM, totalUnclaimedDarkMarks);\\n    }\\n\\n    /// @notice Retrieves the claimable UNIM reward for a given wave ID from the queue.\\n    /// @param queue The storage reference to the queue being examined.\\n    /// @param waveId The wave ID for which the claimable UNIM is being retrieved.\\n    /// @return claimableUNIM The amount of claimable UNIM for the specified wave ID.\\n    function getClaimableUNIM(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (uint256 claimableUNIM) {\\n        return queue.waveIdToTxData[waveId].unclaimedUnim;\\n    }\\n\\n    /// @notice Retrieves the claimable DarkMarks reward for a given wave ID from the queue.\\n    /// @param queue The storage reference to the queue being examined.\\n    /// @param waveId The wave ID for which the claimable DarkMarks is being retrieved.\\n    /// @return claimableDarkMarks The amount of claimable DarkMarks for the specified wave ID.\\n    function getClaimableDarkMarks(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (uint256 claimableDarkMarks) {\\n        return queue.waveIdToTxData[waveId].unclaimedDarkmarks;\\n    }\\n\\n    /// @notice Retrieves the UNIM rewards associated with a given wave ID in the specified queue.\\n    /// @param queue The storage reference to the queue from which the UNIM rewards are being retrieved.\\n    /// @param waveId The wave ID for which the UNIM rewards are being fetched.\\n    /// @return waveUNIM The UNIM rewards associated with the specified wave ID.\\n    function getWaveUNIMByWaveId(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (uint256 waveUNIM) {\\n        return queue.waveIdToTxData[waveId].waveUNIM;\\n    }\\n\\n    /// @notice Retrieves the Dark Marks rewards associated with a given wave ID in the specified queue.\\n    /// @param queue The storage reference to the queue from which the Dark Marks rewards are being retrieved.\\n    /// @param waveId The wave ID for which the Dark Marks rewards are being fetched.\\n    /// @return waveDarkMarks The Dark Marks rewards associated with the specified wave ID.\\n    function getWaveDarkMarksByWaveId(\\n        QueueStorage storage queue,\\n        uint256 waveId\\n    ) internal view returns (uint256 waveDarkMarks) {\\n        return queue.waveIdToTxData[waveId].waveDarkMarks;\\n    }\\n}\\n\"\r\n    },\r\n    \"LibTime.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\n// ----------------------------------------------------------------------------\\n// BokkyPooBah's DateTime Library v1.01\\n//\\n// A gas-efficient Solidity date and time library\\n//\\n// https://github.com/bokkypoobah/BokkyPooBahsDateTimeLibrary\\n//\\n// Tested date range 1970/01/01 to 2345/12/31\\n//\\n// Conventions:\\n// Unit      | Range         | Notes\\n// :-------- |:-------------:|:-----\\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\\n// year      | 1970 ... 2345 |\\n// month     | 1 ... 12      |\\n// day       | 1 ... 31      |\\n// hour      | 0 ... 23      |\\n// minute    | 0 ... 59      |\\n// second    | 0 ... 59      |\\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\\n//\\n//\\n// Enjoy. (c) BokkyPooBah / Bok Consulting Pty Ltd 2018-2019. The MIT Licence.\\n// ----------------------------------------------------------------------------\\n\\nlibrary LibTime {\\n    uint constant SECONDS_PER_WEEK = 7 * 24 * 60 * 60;\\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\\n    uint constant SECONDS_PER_HOUR = 60 * 60;\\n    uint constant SECONDS_PER_MINUTE = 60;\\n    int constant OFFSET19700101 = 2440588;\\n\\n    uint constant DOW_MON = 1;\\n    uint constant DOW_TUE = 2;\\n    uint constant DOW_WED = 3;\\n    uint constant DOW_THU = 4;\\n    uint constant DOW_FRI = 5;\\n    uint constant DOW_SAT = 6;\\n    uint constant DOW_SUN = 7;\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate the number of days from 1970/01/01 to year/month/day using\\n    // the date conversion algorithm from\\n    //   https://aa.usno.navy.mil/faq/JD_formula.html\\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // days = day\\n    //      - 32075\\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\\n    //      - offset\\n    // ------------------------------------------------------------------------\\n    function _daysFromDate(\\n        uint year,\\n        uint month,\\n        uint day\\n    ) internal pure returns (uint _days) {\\n        require(year >= 1970);\\n        int _year = int(year);\\n        int _month = int(month);\\n        int _day = int(day);\\n\\n        int __days = _day -\\n            32075 +\\n            (1461 * (_year + 4800 + (_month - 14) / 12)) /\\n            4 +\\n            (367 * (_month - 2 - ((_month - 14) / 12) * 12)) /\\n            12 -\\n            (3 * ((_year + 4900 + (_month - 14) / 12) / 100)) /\\n            4 -\\n            OFFSET19700101;\\n\\n        _days = uint(__days);\\n    }\\n\\n    // ------------------------------------------------------------------------\\n    // Calculate year/month/day from the number of days since 1970/01/01 using\\n    // the date conversion algorithm from\\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\\n    //\\n    // int L = days + 68569 + offset\\n    // int N = 4 * L / 146097\\n    // L = L - (146097 * N + 3) / 4\\n    // year = 4000 * (L + 1) / 1461001\\n    // L = L - 1461 * year / 4 + 31\\n    // month = 80 * L / 2447\\n    // dd = L - 2447 * month / 80\\n    // L = month / 11\\n    // month = month + 2 - 12 * L\\n    // year = 100 * (N - 49) + year + L\\n    // ------------------------------------------------------------------------\\n    function _daysToDate(\\n        uint _days\\n    ) internal pure returns (uint year, uint month, uint day) {\\n        int __days = int(_days);\\n\\n        int L = __days + 68569 + OFFSET19700101;\\n        int N = (4 * L) / 146097;\\n        L = L - (146097 * N + 3) / 4;\\n        int _year = (4000 * (L + 1)) / 1461001;\\n        L = L - (1461 * _year) / 4 + 31;\\n        int _month = (80 * L) / 2447;\\n        int _day = L - (2447 * _month) / 80;\\n        L = _month / 11;\\n        _month = _month + 2 - 12 * L;\\n        _year = 100 * (N - 49) + _year + L;\\n\\n        year = uint(_year);\\n        month = uint(_month);\\n        day = uint(_day);\\n    }\\n\\n    function timestampFromDate(\\n        uint year,\\n        uint month,\\n        uint day\\n    ) internal pure returns (uint timestamp) {\\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\\n    }\\n\\n    function timestampFromDateTime(\\n        uint year,\\n        uint month,\\n        uint day,\\n        uint hour,\\n        uint minute,\\n        uint second\\n    ) internal pure returns (uint timestamp) {\\n        timestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            hour *\\n            SECONDS_PER_HOUR +\\n            minute *\\n            SECONDS_PER_MINUTE +\\n            second;\\n    }\\n\\n    function timestampToDate(\\n        uint timestamp\\n    ) internal pure returns (uint year, uint month, uint day) {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function timestampToDateTime(\\n        uint timestamp\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint year,\\n            uint month,\\n            uint day,\\n            uint hour,\\n            uint minute,\\n            uint second\\n        )\\n    {\\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        uint secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n        secs = secs % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n        second = secs % SECONDS_PER_MINUTE;\\n    }\\n\\n    function isValidDate(\\n        uint year,\\n        uint month,\\n        uint day\\n    ) internal pure returns (bool valid) {\\n        if (year >= 1970 && month > 0 && month <= 12) {\\n            uint daysInMonth = _getDaysInMonth(year, month);\\n            if (day > 0 && day <= daysInMonth) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isValidDateTime(\\n        uint year,\\n        uint month,\\n        uint day,\\n        uint hour,\\n        uint minute,\\n        uint second\\n    ) internal pure returns (bool valid) {\\n        if (isValidDate(year, month, day)) {\\n            if (hour < 24 && minute < 60 && second < 60) {\\n                valid = true;\\n            }\\n        }\\n    }\\n\\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\\n        (uint year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        leapYear = _isLeapYear(year);\\n    }\\n\\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\\n    }\\n\\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\\n    }\\n\\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\\n    }\\n\\n    function getDaysInMonth(\\n        uint timestamp\\n    ) internal pure returns (uint daysInMonth) {\\n        (uint year, uint month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n        daysInMonth = _getDaysInMonth(year, month);\\n    }\\n\\n    function _getDaysInMonth(\\n        uint year,\\n        uint month\\n    ) internal pure returns (uint daysInMonth) {\\n        if (\\n            month == 1 ||\\n            month == 3 ||\\n            month == 5 ||\\n            month == 7 ||\\n            month == 8 ||\\n            month == 10 ||\\n            month == 12\\n        ) {\\n            daysInMonth = 31;\\n        } else if (month != 2) {\\n            daysInMonth = 30;\\n        } else {\\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\\n        }\\n    }\\n\\n    // 1 = Monday, 7 = Sunday\\n    function getDayOfWeek(\\n        uint timestamp\\n    ) internal pure returns (uint dayOfWeek) {\\n        uint _days = timestamp / SECONDS_PER_DAY;\\n        dayOfWeek = ((_days + 3) % 7) + 1;\\n    }\\n\\n    function getYear(uint timestamp) internal pure returns (uint year) {\\n        (year, , ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getMonth(uint timestamp) internal pure returns (uint month) {\\n        (, month, ) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getDay(uint timestamp) internal pure returns (uint day) {\\n        (, , day) = _daysToDate(timestamp / SECONDS_PER_DAY);\\n    }\\n\\n    function getHour(uint timestamp) internal pure returns (uint hour) {\\n        uint secs = timestamp % SECONDS_PER_DAY;\\n        hour = secs / SECONDS_PER_HOUR;\\n    }\\n\\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\\n        uint secs = timestamp % SECONDS_PER_HOUR;\\n        minute = secs / SECONDS_PER_MINUTE;\\n    }\\n\\n    function getSecond(uint timestamp) internal pure returns (uint second) {\\n        second = timestamp % SECONDS_PER_MINUTE;\\n    }\\n\\n    function addYears(\\n        uint timestamp,\\n        uint _years\\n    ) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(\\n            timestamp / SECONDS_PER_DAY\\n        );\\n        year += _years;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMonths(\\n        uint timestamp,\\n        uint _months\\n    ) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(\\n            timestamp / SECONDS_PER_DAY\\n        );\\n        month += _months;\\n        year += (month - 1) / 12;\\n        month = ((month - 1) % 12) + 1;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addDays(\\n        uint timestamp,\\n        uint _days\\n    ) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addHours(\\n        uint timestamp,\\n        uint _hours\\n    ) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addMinutes(\\n        uint timestamp,\\n        uint _minutes\\n    ) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function addSeconds(\\n        uint timestamp,\\n        uint _seconds\\n    ) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp + _seconds;\\n        require(newTimestamp >= timestamp);\\n    }\\n\\n    function subYears(\\n        uint timestamp,\\n        uint _years\\n    ) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(\\n            timestamp / SECONDS_PER_DAY\\n        );\\n        year -= _years;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMonths(\\n        uint timestamp,\\n        uint _months\\n    ) internal pure returns (uint newTimestamp) {\\n        (uint year, uint month, uint day) = _daysToDate(\\n            timestamp / SECONDS_PER_DAY\\n        );\\n        uint yearMonth = year * 12 + (month - 1) - _months;\\n        year = yearMonth / 12;\\n        month = (yearMonth % 12) + 1;\\n        uint daysInMonth = _getDaysInMonth(year, month);\\n        if (day > daysInMonth) {\\n            day = daysInMonth;\\n        }\\n        newTimestamp =\\n            _daysFromDate(year, month, day) *\\n            SECONDS_PER_DAY +\\n            (timestamp % SECONDS_PER_DAY);\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subDays(\\n        uint timestamp,\\n        uint _days\\n    ) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subHours(\\n        uint timestamp,\\n        uint _hours\\n    ) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subMinutes(\\n        uint timestamp,\\n        uint _minutes\\n    ) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function subSeconds(\\n        uint timestamp,\\n        uint _seconds\\n    ) internal pure returns (uint newTimestamp) {\\n        newTimestamp = timestamp - _seconds;\\n        require(newTimestamp <= timestamp);\\n    }\\n\\n    function diffYears(\\n        uint fromTimestamp,\\n        uint toTimestamp\\n    ) internal pure returns (uint _years) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint fromYear, , ) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\\n        (uint toYear, , ) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\\n        _years = toYear - fromYear;\\n    }\\n\\n    function diffMonths(\\n        uint fromTimestamp,\\n        uint toTimestamp\\n    ) internal pure returns (uint _months) {\\n        require(fromTimestamp <= toTimestamp);\\n        (uint fromYear, uint fromMonth, ) = _daysToDate(\\n            fromTimestamp / SECONDS_PER_DAY\\n        );\\n        (uint toYear, uint toMonth, ) = _daysToDate(\\n            toTimestamp / SECONDS_PER_DAY\\n        );\\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\\n    }\\n\\n    function diffDays(\\n        uint fromTimestamp,\\n        uint toTimestamp\\n    ) internal pure returns (uint _days) {\\n        require(fromTimestamp <= toTimestamp);\\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\\n    }\\n\\n    function diffHours(\\n        uint fromTimestamp,\\n        uint toTimestamp\\n    ) internal pure returns (uint _hours) {\\n        require(fromTimestamp <= toTimestamp);\\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\\n    }\\n\\n    function diffMinutes(\\n        uint fromTimestamp,\\n        uint toTimestamp\\n    ) internal pure returns (uint _minutes) {\\n        require(fromTimestamp <= toTimestamp);\\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\\n    }\\n\\n    function diffSeconds(\\n        uint fromTimestamp,\\n        uint toTimestamp\\n    ) internal pure returns (uint _seconds) {\\n        require(fromTimestamp <= toTimestamp);\\n        _seconds = toTimestamp - fromTimestamp;\\n    }\\n}\\n\"\r\n    },\r\n    \"IRitualFacet.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.0;\\n\\nimport {LibRitualComponents} from \\\"LibRitualComponents.sol\\\";\\nimport {LibConstraints} from \\\"LibConstraints.sol\\\";\\nimport {LibRitualData} from \\\"LibRitualData.sol\\\";\\n\\ninterface IRitualFacet {\\n\\n    /// @notice This function creates a ritual and mints it to the target user,\\n    /// can only be called by minion hatchery.\\n    /// @param to The user that the ritual should be minted to.\\n    /// @param name The ritual's name.\\n    /// @param rarity The ritual's rarity expressed in integer value.\\n    /// @param costs The costs to pay to consume a ritual charge expressed in components.\\n    /// @param products The outcome of consuming a ritual charge expressed in components.\\n    /// @param constraints The restrictions to consume a ritual charge expressed in constraints.\\n    /// @param charges The amount of times the ritual can consume a charge to exchange costs for products.\\n    /// @param soulbound Flag to indicate if the ritual is soulbound or not.\\n    function createRitual(\\n        address to,\\n        string calldata name,\\n        uint8 rarity, \\n        LibRitualComponents.RitualCost[] memory costs, \\n        LibRitualComponents.RitualProduct[] memory products, \\n        LibConstraints.Constraint[] memory constraints, \\n        uint256 charges,\\n        bool soulbound\\n    ) external returns(uint256 ritualTokenId);\\n\\n    /// @notice This function returns the entire ritual data that is relevant for the minion hatchery.\\n    /// @param ritualId The id of the ritual.\\n    /// @return Ritual (name, rarity, costs, products, constraints, charges and soulbound).\\n    function getRitualDetails(uint256 ritualId) external view returns(LibRitualData.Ritual memory);\\n\\n    /// @notice This function consumes a ritual charge, can only be called by minion hatchery.\\n    /// @param ritualId The id of the ritual.\\n    function consumeRitualCharge(uint256 ritualId) external;\\n\\n    /// @notice This function validates checks that the address that wants to consume a charge\\n    /// is the owner of the ritual and that is has charges left, then\\n    /// returns the ritual details, can only be called by minion hatchery.\\n    /// @param ritualId The id of the ritual.\\n    /// @param ritualOwner The owner of the ritual.\\n    /// @return Ritual (name, rarity, costs, products, constraints, charges and soulbound).\\n    function validateChargesAndGetRitualDetailsForConsume(uint256 ritualId, address ritualOwner) external view returns(LibRitualData.Ritual memory);\\n}\"\r\n    },\r\n    \"LibRNG.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\nimport {VRFCoordinatorV2Interface} from \\\"VRFCoordinatorV2Interface.sol\\\";\\n\\nlibrary LibRNG {\\n    uint256 internal constant RNG_CREATE_RITUAL = 1;\\n\\n    bytes32 private constant RNGVRF_STORAGE_POSITION = keccak256(\\\"diamond.LibRNGVRFV2.storage\\\");\\n\\n    struct LibRNGVRFV2Storage {\\n        // Your subscription ID.\\n        //1923 mumbai\\n        uint64 subscriptionId;\\n\\n        // see https://docs.chain.link/docs/vrf-contracts/#configurations\\n        // mumbai = 0x7a1BaC17Ccc5b313516C5E16fb24f7659aA5ebed\\n        address vrfCoordinator;\\n\\n        // The gas lane to use, which specifies the maximum gas price to bump to.\\n        // For a list of available gas lanes on each network,\\n        // see https://docs.chain.link/docs/vrf-contracts/#configurations\\n        //mumbai = 0x4b09e658ed251bcafeebbc69400383d49f344ace09b9576fe248bb02c003fe9f\\n        bytes32 keyHash;\\n\\n        // Depends on the number of requested values that you want sent to the\\n        // fulfillRandomWords() function. Storing each word costs about 20,000 gas,\\n        // so 100,000 is a safe default for this example contract. Test and adjust\\n        // this limit based on the network that you select, the size of the request,\\n        // and the processing of the callback request in the fulfillRandomWords()\\n        // function.\\n        mapping (uint256 => uint32) callbackGasLimitForMechanicId;\\n\\n        // The default is 3, but you can set this higher.\\n        mapping (uint256 => uint16) confirmationsForMechanicId;\\n\\n        // Cannot exceed VRFCoordinatorV2.MAX_NUM_WORDS.\\n        uint32 numWords;\\n\\n        // requestId (number provided by ChainLink) => mechanicId (ie RITUALS)\\n        // This map allows us to share RNG facet between mechanics.\\n        mapping(uint256 => uint256) rng_mechanicIdByVRFRequestId;\\n        // requestId => randomness provided by ChainLink\\n        mapping(uint256 => uint256) rng_randomness;\\n\\n        uint256 rngNonce;\\n    }\\n\\n    function vrfV2Storage() internal pure returns (LibRNGVRFV2Storage storage vrf) {\\n        bytes32 position = RNGVRF_STORAGE_POSITION;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            vrf.slot := position\\n        }\\n    }\\n\\n    function requestRandomWordsFor(uint256 mechanicId) internal returns(uint256) {\\n        LibRNGVRFV2Storage storage vrfs = vrfV2Storage();\\n        uint32 callbackGasLimit = vrfs.callbackGasLimitForMechanicId[mechanicId];\\n        uint16 requestConfirmations = vrfs.confirmationsForMechanicId[mechanicId];\\n        uint256 requestId = VRFCoordinatorV2Interface(vrfs.vrfCoordinator).requestRandomWords(\\n            vrfs.keyHash,\\n            vrfs.subscriptionId,\\n            requestConfirmations,\\n            callbackGasLimit,\\n            vrfs.numWords\\n        );\\n        vrfs.rng_mechanicIdByVRFRequestId[requestId] = mechanicId;\\n        return requestId;\\n    }\\n\\n    function setVRFV2RequestConfirmationsByMechanicId(uint256 mechanicId, uint16 confirmations) internal {\\n        vrfV2Storage().confirmationsForMechanicId[mechanicId] = confirmations;\\n    }\\n\\n    function setVRFV2NumWords(uint32 words) internal {\\n        vrfV2Storage().numWords = words;\\n    }\\n\\n    function setVRFV2CallbackGasLimitByMechanicId(uint256 mechanicId, uint32 limit) internal {\\n        vrfV2Storage().callbackGasLimitForMechanicId[mechanicId] = limit;\\n    }\\n\\n    function setVRFV2KeyHash(bytes32 keyHash) internal {\\n        vrfV2Storage().keyHash = keyHash;\\n    }\\n\\n    function setVRFV2VrfCoordinatorAddress(address coordinator) internal {\\n        vrfV2Storage().vrfCoordinator = coordinator;\\n    }\\n\\n    function setVRFV2SubscriptionId(uint64 subscriptionId) internal {\\n        vrfV2Storage().subscriptionId = subscriptionId;\\n    }\\n\\n    function getVRFV2RequestConfirmationsByMechanicId(uint256 mechanicId) internal view returns(uint16) {\\n        return vrfV2Storage().confirmationsForMechanicId[mechanicId];\\n    }\\n\\n    function getVRFV2NumWords() internal view returns(uint32) {\\n        return vrfV2Storage().numWords;\\n    }\\n\\n    function getVRFV2CallbackGasLimitByMechanicId(uint256 mechanicId) internal view returns(uint32) {\\n        return vrfV2Storage().callbackGasLimitForMechanicId[mechanicId];\\n    }\\n\\n    function getVRFV2KeyHash() internal view returns(bytes32) {\\n        return vrfV2Storage().keyHash;\\n    }\\n\\n    function getVRFV2VrfCoordinatorAddress() internal view returns(address) {\\n        return vrfV2Storage().vrfCoordinator;\\n    }\\n\\n    function getVRFV2SubscriptionId() internal view returns(uint64) {\\n        return vrfV2Storage().subscriptionId;\\n    }\\n\\n    function makeRequestId(bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\\n    }\\n    function makeVRFInputSeed(\\n        bytes32 _keyHash,\\n        uint256 _userSeed,\\n        address _requester,\\n        uint256 _nonce\\n    ) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\\n    }\\n\\n    function removeMechanicIdByVRFRequestId(uint256 requestId) internal {\\n        delete vrfV2Storage().rng_mechanicIdByVRFRequestId[requestId];\\n    }\\n\\n    function getMechanicIdByVRFRequestId(uint256 requestId) internal view returns(uint256) {\\n        return vrfV2Storage().rng_mechanicIdByVRFRequestId[requestId];\\n    }\\n\\n    function setRandomWord(uint256 requestId, uint256 randomWord) internal {\\n        vrfV2Storage().rng_randomness[requestId] = randomWord;\\n    }\\n\\n    function expand(uint256 _modulus, uint256 _seed, uint256 _salt) internal pure returns (uint256) {\\n        return uint256(keccak256(abi.encode(_seed, _salt))) % _modulus;\\n    }\\n\\n    function getRuntimeRNG() internal returns (uint256) {\\n        return getRuntimeRNG(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\\n    }\\n\\n    function getRuntimeRNG(uint _modulus) internal returns (uint256) {\\n        require(msg.sender != block.coinbase, \\\"RNG: Validators are not allowed to generate their own RNG\\\");\\n        return uint256(keccak256(abi.encodePacked(block.coinbase, gasleft(), block.number, ++vrfV2Storage().rngNonce))) % _modulus;\\n    }\\n}\\n\"\r\n    },\r\n    \"VRFCoordinatorV2Interface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface VRFCoordinatorV2Interface {\\n  /**\\n   * @notice Get configuration relevant for making requests\\n   * @return minimumRequestConfirmations global min for request confirmations\\n   * @return maxGasLimit global max for request gas limit\\n   * @return s_provingKeyHashes list of registered key hashes\\n   */\\n  function getRequestConfig()\\n    external\\n    view\\n    returns (\\n      uint16,\\n      uint32,\\n      bytes32[] memory\\n    );\\n\\n  /**\\n   * @notice Request a set of random words.\\n   * @param keyHash - Corresponds to a particular oracle job which uses\\n   * that key for generating the VRF proof. Different keyHash's have different gas price\\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\\n   * @param subId  - The ID of the VRF subscription. Must be funded\\n   * with the minimum subscription balance required for the selected keyHash.\\n   * @param minimumRequestConfirmations - How many blocks you'd like the\\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\\n   * for why you may want to request more. The acceptable range is\\n   * [minimumRequestBlockConfirmations, 200].\\n   * @param callbackGasLimit - How much gas you'd like to receive in your\\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\\n   * may be slightly less than this amount because of gas used calling the function\\n   * (argument decoding etc.), so you may need to request slightly more than you expect\\n   * to have inside fulfillRandomWords. The acceptable range is\\n   * [0, maxGasLimit]\\n   * @param numWords - The number of uint256 random values you'd like to receive\\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\\n   * @return requestId - A unique identifier of the request. Can be used to match\\n   * a request to a response in fulfillRandomWords.\\n   */\\n  function requestRandomWords(\\n    bytes32 keyHash,\\n    uint64 subId,\\n    uint16 minimumRequestConfirmations,\\n    uint32 callbackGasLimit,\\n    uint32 numWords\\n  ) external returns (uint256 requestId);\\n\\n  /**\\n   * @notice Create a VRF subscription.\\n   * @return subId - A unique subscription id.\\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\\n   * @dev Note to fund the subscription, use transferAndCall. For example\\n   * @dev  LINKTOKEN.transferAndCall(\\n   * @dev    address(COORDINATOR),\\n   * @dev    amount,\\n   * @dev    abi.encode(subId));\\n   */\\n  function createSubscription() external returns (uint64 subId);\\n\\n  /**\\n   * @notice Get a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @return balance - LINK balance of the subscription in juels.\\n   * @return reqCount - number of requests for this subscription, determines fee tier.\\n   * @return owner - owner of the subscription.\\n   * @return consumers - list of consumer address which are able to use this subscription.\\n   */\\n  function getSubscription(uint64 subId)\\n    external\\n    view\\n    returns (\\n      uint96 balance,\\n      uint64 reqCount,\\n      address owner,\\n      address[] memory consumers\\n    );\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @param newOwner - proposed new owner of the subscription\\n   */\\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\\n\\n  /**\\n   * @notice Request subscription owner transfer.\\n   * @param subId - ID of the subscription\\n   * @dev will revert if original owner of subId has\\n   * not requested that msg.sender become the new owner.\\n   */\\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\\n\\n  /**\\n   * @notice Add a consumer to a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - New consumer which can use the subscription\\n   */\\n  function addConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Remove a consumer from a VRF subscription.\\n   * @param subId - ID of the subscription\\n   * @param consumer - Consumer to remove from the subscription\\n   */\\n  function removeConsumer(uint64 subId, address consumer) external;\\n\\n  /**\\n   * @notice Cancel a subscription\\n   * @param subId - ID of the subscription\\n   * @param to - Where to send the remaining LINK to\\n   */\\n  function cancelSubscription(uint64 subId, address to) external;\\n\\n  /*\\n   * @notice Check to see if there exists a request commitment consumers\\n   * for all consumers and keyhashes for a given sub.\\n   * @param subId - ID of the subscription\\n   * @return true if there exists at least one unfulfilled request for the subscription, false\\n   * otherwise.\\n   */\\n  function pendingRequestExists(uint64 subId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"LibRitualNames.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport { LibRNG } from \\\"LibRNG.sol\\\";\\n\\nlibrary LibRitualNames {\\n\\n    uint256 private constant SALT_1 = 239;\\n    uint256 private constant SALT_2 = 240;\\n    uint256 private constant SALT_3 = 241;\\n    uint256 private constant SALT_4 = 242;\\n\\n    bytes32 private constant RITUAL_NAMES_STORAGE_POSITION = keccak256(\\\"CryptoUnicorns.HatcheryRitual.Names.Storage\\\");\\n\\n    struct RitualNameStorage {\\n        string[] validFirstNames;                       //  source\\n        string[] validMiddleNames;                      //  descriptor\\n        string[] validLastNames;                        //  noun/verb\\n    }\\n\\n    function nameStorage() internal pure returns (RitualNameStorage storage ns) {\\n        bytes32 position = RITUAL_NAMES_STORAGE_POSITION;\\n        assembly {\\n            ns.slot := position\\n        }\\n    }\\n\\n    function getRandomName(uint256 randomness) internal view returns (string memory) {\\n        RitualNameStorage storage ns = nameStorage();\\n        if(LibRNG.expand(100, randomness, SALT_4) < 10) {\\n            //  10% chance that we will skip the middle descriptor\\n            return string.concat(\\n                ns.validFirstNames[LibRNG.expand(ns.validFirstNames.length, randomness, SALT_1)],\\n                \\\" \\\",\\n                ns.validLastNames[LibRNG.expand(ns.validLastNames.length, randomness, SALT_3)]\\n            );\\n        } else {\\n            return string.concat(\\n                ns.validFirstNames[LibRNG.expand(ns.validFirstNames.length, randomness, SALT_1)],\\n                \\\" \\\",\\n                ns.validMiddleNames[LibRNG.expand(ns.validMiddleNames.length, randomness, SALT_2)],\\n                \\\" \\\",\\n                ns.validLastNames[LibRNG.expand(ns.validLastNames.length, randomness, SALT_3)]\\n            );\\n        }\\n    }\\n\\n    function registerFirstNames(string[] memory names) internal {\\n        RitualNameStorage storage ns = nameStorage();\\n        for(uint256 i = 0; i < names.length; ++i) {\\n            ns.validFirstNames.push(names[i]);\\n        }\\n    }\\n\\n    function registerMiddleNames(uint256[] memory ids, string[] memory names, bool addToRNG) internal {\\n        RitualNameStorage storage ns = nameStorage();\\n        for(uint256 i = 0; i < names.length; ++i) {\\n            ns.validMiddleNames.push(names[i]);\\n        }\\n    }\\n\\n    function registerLastNames(uint256[] memory ids, string[] memory names, bool addToRNG) internal {\\n        RitualNameStorage storage ns = nameStorage();\\n        for(uint256 i = 0; i < names.length; ++i) {\\n            ns.validLastNames.push(names[i]);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"LibArray.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\nimport {LibRitualComponents} from \\\"LibRitualComponents.sol\\\";\\nimport {LibConstraints} from \\\"LibConstraints.sol\\\";\\n\\nlibrary LibArray {\\n    function popFromMemoryArray(uint256[] memory array) internal pure returns(uint256[] memory) {\\n        require(array.length > 0, \\\"LibArray: Cannot pop from empty array\\\");\\n        assembly { mstore(array, sub(mload(array), 1)) }\\n        return array;\\n        // Some important points to remember:\\n\\n        // Make sure this assembly code never runs when backerList.length == 0 (don't allow the array length to underflow)\\n\\n        // Don't try to use this to increase the size of an array (by replacing sub with add)\\n\\n        // Only use it on variables with a type like ...[] memory (for example, don't use it on a address[10] memory or address)\\n\\n        // Disclaimer: The use of inline assembly is usually not recommended. Use it with caution and at your own risk :)\\n        // source: https://ethereum.stackexchange.com/questions/51891/how-to-pop-from-decrease-the-length-of-a-memory-array-in-solidity\\n    }\\n    function removeFromMemoryArray(uint256[] memory array, uint256 positionToRemove) internal pure returns(uint256[] memory){\\n        require(array.length > 0, \\\"LibArray: Cannot remove from empty array\\\");\\n        require(positionToRemove < array.length, \\\"LibArray: Cannot remove from array at position greater than array length\\\");\\n        array[positionToRemove] = array[array.length - 1];\\n        assembly { mstore(array, sub(mload(array), 1)) }\\n        return array;\\n    }\\n    function pushToMemoryArray(uint256[] memory array, uint256 element) internal pure returns(uint256[] memory) {\\n        uint256[] memory newArray = new uint256[](array.length + 1);\\n        for (uint256 i = 0; i < array.length; i++) {\\n            newArray[i] = array[i];\\n        }\\n        newArray[array.length] = element;\\n        return newArray;\\n    }\\n\\n    function pushToConstraintMemoryArray(LibConstraints.Constraint[] memory array, LibConstraints.Constraint memory element) internal pure returns(LibConstraints.Constraint[] memory) {\\n        LibConstraints.Constraint[] memory newArray = new LibConstraints.Constraint[](array.length + 1);\\n        for (uint256 i = 0; i < array.length; i++) {\\n            newArray[i] = array[i];\\n        }\\n        newArray[array.length] = element;\\n        return newArray;\\n    }\\n    function removeFromConstraintMemoryArray(LibConstraints.Constraint[] memory array, uint256 positionToRemove) internal pure returns(LibConstraints.Constraint[] memory) {\\n        require(array.length > 0, \\\"LibArray: Cannot remove from empty array\\\");\\n        require(positionToRemove < array.length, \\\"LibArray: Cannot remove from array at position greater than array length\\\");\\n        array[positionToRemove] = array[array.length - 1];\\n        assembly { mstore(array, sub(mload(array), 1)) }\\n        return array;\\n    }\\n    function popFromConstraintMemoryArray(LibConstraints.Constraint[] memory array) internal pure returns(LibConstraints.Constraint[] memory) {\\n        require(array.length > 0, \\\"LibArray: Cannot pop from empty array\\\");\\n        assembly { mstore(array, sub(mload(array), 1)) }\\n        return array;\\n    }\\n\\n    function pushToProductMemoryArray(LibRitualComponents.RitualProduct[] memory array, LibRitualComponents.RitualProduct memory element) internal pure returns(LibRitualComponents.RitualProduct[] memory) {\\n        LibRitualComponents.RitualProduct[] memory newArray = new LibRitualComponents.RitualProduct[](array.length + 1);\\n        for (uint256 i = 0; i < array.length; i++) {\\n            newArray[i] = array[i];\\n        }\\n        newArray[array.length] = element;\\n        return newArray;\\n    }\\n    function removeFromProductMemoryArray(LibRitualComponents.RitualProduct[] memory array, uint256 positionToRemove) internal pure returns(LibRitualComponents.RitualProduct[] memory) {\\n        require(array.length > 0, \\\"LibArray: Cannot remove from empty array\\\");\\n        require(positionToRemove < array.length, \\\"LibArray: Cannot remove from array at position greater than array length\\\");\\n        array[positionToRemove] = array[array.length - 1];\\n        assembly { mstore(array, sub(mload(array), 1)) }\\n        return array;\\n    }\\n    function popFromProductMemoryArray(LibRitualComponents.RitualProduct[] memory array) internal pure returns(LibRitualComponents.RitualProduct[] memory) {\\n        require(array.length > 0, \\\"LibArray: Cannot pop from empty array\\\");\\n        assembly { mstore(array, sub(mload(array), 1)) }\\n        return array;\\n    }\\n\\n    function pushToCostMemoryArray(LibRitualComponents.RitualCost[] memory array, LibRitualComponents.RitualCost memory element) internal pure returns(LibRitualComponents.RitualCost[] memory) {\\n        LibRitualComponents.RitualCost[] memory newArray = new LibRitualComponents.RitualCost[](array.length + 1);\\n        for (uint256 i = 0; i < array.length; i++) {\\n            newArray[i] = array[i];\\n        }\\n        newArray[array.length] = element;\\n        return newArray;\\n    }\\n    function removeFromCostMemoryArray(LibRitualComponents.RitualCost[] memory array, uint256 positionToRemove) internal pure returns(LibRitualComponents.RitualCost[] memory) {\\n        require(array.length > 0, \\\"LibArray: Cannot remove from empty array\\\");\\n        require(positionToRemove < array.length, \\\"LibArray: Cannot remove from array at position greater than array length\\\");\\n        array[positionToRemove] = array[array.length - 1];\\n        assembly { mstore(array, sub(mload(array), 1)) }\\n        return array;\\n    }\\n    function popFromCostMemoryArray(LibRitualComponents.RitualCost[] memory array) internal pure returns(LibRitualComponents.RitualCost[] memory) {\\n        require(array.length > 0, \\\"LibArray: Cannot pop from empty array\\\");\\n        assembly { mstore(array, sub(mload(array), 1)) }\\n        return array;\\n    }\\n}\"\r\n    },\r\n    \"LibString.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.20;\\n\\n/// @author Uriel Chami\\nlibrary LibString {\\n\\n    /// @notice Converts uint to readable string\\n    /// @dev Any uint from uint8 up to uint256\\n    /// @param _i uint8 to uint256 number to convert\\n    /// @return _uintAsString number as string\\n    function uintToString(uint _i) internal pure returns (string memory _uintAsString) {\\n        if (_i == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint j = _i;\\n        uint len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint k = len;\\n        while (_i != 0) {\\n            k = k-1;\\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            _i /= 10;\\n        }\\n        return string(bstr);\\n    }\\n\\n    /// @notice Converts address to readable string\\n    /// @dev the final string includes \\\"0x\\\"\\n    /// @param x address to convert\\n    /// @return s address as string including \\\"0x\\\" at the start\\n    function addressToString(address x) internal pure returns(string memory) {\\n        bytes memory s = new bytes(40);\\n        for (uint i = 0; i < 20; i++) {\\n            bytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\\n            bytes1 hi = bytes1(uint8(b) / 16);\\n            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n            s[2*i] = char(hi);\\n            s[2*i+1] = char(lo);\\n        }\\n        return string(abi.encodePacked(\\\"0x\\\", s));\\n    }\\n\\n    function char(bytes1 b) internal pure returns(bytes1 c) {\\n        if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n        else return bytes1(uint8(b) + 0x57);\\n    }\\n\\n    function toHexDigit(uint8 d) internal pure returns (bytes1) {\\n        if (0 <= d && d <= 9) {\\n        return bytes1(uint8(bytes1(\\\"0\\\")) + d);\\n        } else if (10 <= uint8(d) && uint8(d) <= 15) {\\n        return bytes1(uint8(bytes1(\\\"a\\\")) + d - 10);\\n        }\\n        revert();\\n    }\\n\\n    /// @notice Converts bytes4 to readable string\\n    /// @dev the final string includes \\\"0x\\\". useful for selectors\\n    /// @param code bytes4 to convert\\n    /// @return s bytes4 as string including \\\"0x\\\" at the start\\n    function selectorToString(bytes4 code) internal pure returns (string memory) {\\n        bytes memory result = new bytes(10);\\n        result[0] = bytes1(\\\"0\\\");\\n        result[1] = bytes1(\\\"x\\\");\\n        for (uint i = 0; i < 4; ++i) {\\n        result[2 * i + 2] = toHexDigit(uint8(code[i]) / 16);\\n        result[2 * i + 3] = toHexDigit(uint8(code[i]) % 16);\\n        }\\n        return string(result);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"LibEnvironmentConfig.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport {LibDiamond} from \\\"LibDiamond.sol\\\";\\nimport \\\"IERC165.sol\\\";\\nimport {IERC173} from \\\"IERC173.sol\\\";\\nimport {IDiamondCut} from \\\"IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"IDiamondLoupe.sol\\\";\\n\\nlibrary LibEnvironmentConfig {\\n    uint256 private constant POLYGON_CHAINID = 137;\\n\\n    function initializeSupportedInterface() internal {\\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\\n    }\\n\\n    function configureForPolygonMainnet() internal {\\n        initializeSupportedInterface();\\n    }\\n\\n    function configureForMumbaiTestnet() internal {\\n        require(\\n            block.chainid != POLYGON_CHAINID,\\n            \\\"This configuration cannot be loaded on mainnet!\\\"\\n        );\\n        initializeSupportedInterface();\\n    }\\n\\n    // MISSING THIS PARAMS\\n    // address gameBank, address unim, address rbw, address terminus, address vrfCoordinator, address link\\n    // TODO: Delete initalizers and pass this parameters here.\\n    function configureForLocalhost() internal {\\n        require(\\n            block.chainid != POLYGON_CHAINID,\\n            \\\"This configuration cannot be loaded on mainnet!\\\"\\n        );\\n        configureForMumbaiTestnet(); //  for now, copy testnet\\n    }\\n}\\n\"\r\n    },\r\n    \"IERC173.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n/// @title ERC-173 Contract Ownership Standard\\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\\n/* is ERC165 */\\ninterface IERC173 {\\n    /// @dev This emits when ownership of a contract changes.\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    /// @notice Get the address of the owner\\n    /// @return owner_ The address of the owner.\\n    function owner() external view returns (address owner_);\\n\\n    /// @notice Set the address of the new owner of the contract\\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\\n    /// @param _newOwner The address of the new owner of the contract\\n    function transferOwnership(address _newOwner) external;\\n}\\n\"\r\n    },\r\n    \"IDiamondLoupe.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\n// Adapted from the Diamond 3 reference implementation by Nick Mudge:\\n// https://github.com/mudgen/diamond-3-hardhat\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(address _facet)\\n        external\\n        view\\n        returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(bytes4 _functionSelector)\\n        external\\n        view\\n        returns (address facetAddress_);\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"istanbul\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"libraries\": {\r\n      \"Diamond.sol\": {}\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Diamond", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000453d39960a9fd2c652987f64e00feba43f348393000000000000000000000000df87b334d425bca5ae43f111a5fc3822c4fceb5f", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x84fb6aa9e3bafcbe039513b33fb7326d64ad17ac", "SwarmSource": ""}