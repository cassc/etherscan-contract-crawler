{"SourceCode": "{\"AccessController.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG----\\n\\npragma solidity ^0.8.12;\\n\\ncontract AccessController {\\n\\n    address public ceoAddress;\\n\\n    mapping (address =\\u003e bool) public isWorker;\\n\\n    event CEOSet(\\n        address newCEO\\n    );\\n\\n    event WorkerAdded(\\n        address newWorker\\n    );\\n\\n    event WorkerRemoved(\\n        address existingWorker\\n    );\\n\\n    constructor() {\\n\\n        address creator = msg.sender;\\n\\n        ceoAddress = creator;\\n\\n        isWorker[creator] = true;\\n\\n        emit CEOSet(\\n            creator\\n        );\\n\\n        emit WorkerAdded(\\n            creator\\n        );\\n    }\\n\\n    modifier onlyCEO() {\\n        require(\\n            msg.sender == ceoAddress,\\n            \\u0027AccessControl: CEO access denied\\u0027\\n        );\\n        _;\\n    }\\n\\n    modifier onlyWorker() {\\n        require(\\n            isWorker[msg.sender] == true,\\n            \\u0027AccessControl: worker access denied\\u0027\\n        );\\n        _;\\n    }\\n\\n    modifier nonZeroAddress(address checkingAddress) {\\n        require(\\n            checkingAddress != address(0x0),\\n            \\u0027AccessControl: invalid address\\u0027\\n        );\\n        _;\\n    }\\n\\n    function setCEO(\\n        address _newCEO\\n    )\\n        external\\n        nonZeroAddress(_newCEO)\\n        onlyCEO\\n    {\\n        ceoAddress = _newCEO;\\n\\n        emit CEOSet(\\n            ceoAddress\\n        );\\n    }\\n\\n    function addWorker(\\n        address _newWorker\\n    )\\n        external\\n        onlyCEO\\n    {\\n        _addWorker(\\n            _newWorker\\n        );\\n    }\\n\\n    function addWorkerBulk(\\n        address[] calldata _newWorkers\\n    )\\n        external\\n        onlyCEO\\n    {\\n        for (uint8 index = 0; index \\u003c _newWorkers.length; index++) {\\n            _addWorker(_newWorkers[index]);\\n        }\\n    }\\n\\n    function _addWorker(\\n        address _newWorker\\n    )\\n        internal\\n        nonZeroAddress(_newWorker)\\n    {\\n        require(\\n            isWorker[_newWorker] == false,\\n            \\u0027AccessControl: worker already exist\\u0027\\n        );\\n\\n        isWorker[_newWorker] = true;\\n\\n        emit WorkerAdded(\\n            _newWorker\\n        );\\n    }\\n\\n    function removeWorker(\\n        address _existingWorker\\n    )\\n        external\\n        onlyCEO\\n    {\\n        _removeWorker(\\n            _existingWorker\\n        );\\n    }\\n\\n    function removeWorkerBulk(\\n        address[] calldata _workerArray\\n    )\\n        external\\n        onlyCEO\\n    {\\n        for (uint8 index = 0; index \\u003c _workerArray.length; index++) {\\n            _removeWorker(_workerArray[index]);\\n        }\\n    }\\n\\n    function _removeWorker(\\n        address _existingWorker\\n    )\\n        internal\\n        nonZeroAddress(_existingWorker)\\n    {\\n        require(\\n            isWorker[_existingWorker] == true,\\n            \\\"AccessControl: worker not detected\\\"\\n        );\\n\\n        isWorker[_existingWorker] = false;\\n\\n        emit WorkerRemoved(\\n            _existingWorker\\n        );\\n    }\\n}\\n\"},\"EIP712Base.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG----\\n\\npragma solidity ^0.8.12;\\n\\ncontract EIP712Base {\\n\\n    struct EIP712Domain {\\n        string name;\\n        string version;\\n        uint256 chainId;\\n        address verifyingContract;\\n    }\\n\\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH = keccak256(bytes(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"));\\n    bytes32 internal domainSeperator;\\n\\n    constructor(string memory name, string memory version) {\\n        domainSeperator = keccak256(abi.encode(\\n\\t\\t\\tEIP712_DOMAIN_TYPEHASH,\\n\\t\\t\\tkeccak256(bytes(name)),\\n\\t\\t\\tkeccak256(bytes(version)),\\n\\t\\t\\tgetChainID(),\\n\\t\\t\\taddress(this)\\n\\t\\t));\\n    }\\n\\n    function getChainID() internal pure returns (uint256 id) {\\n\\t\\tassembly {\\n\\t\\t\\tid := 1 // set to Goerli for now, Mainnet later\\n\\t\\t}\\n\\t}\\n\\n    function getDomainSeperator() private view returns(bytes32) {\\n\\t\\treturn domainSeperator;\\n\\t}\\n\\n    /**\\n    * Accept message hash and returns hash message in EIP712 compatible form\\n    * So that it can be used to recover signer from signature signed using EIP712 formatted data\\n    * https://eips.ethereum.org/EIPS/eip-712\\n    * \\\"\\\\\\\\x19\\\" makes the encoding deterministic\\n    * \\\"\\\\\\\\x01\\\" is the version byte to make it compatible to EIP-191\\n    */\\n    function toTypedMessageHash(bytes32 messageHash) internal view returns(bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", getDomainSeperator(), messageHash));\\n    }\\n}\\n\"},\"EIP712MetaTransaction.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG----\\n\\npragma solidity ^0.8.12;\\n\\nimport \\\"./EIP712Base.sol\\\";\\n\\nabstract contract EIP712MetaTransaction is EIP712Base {\\n\\n    bytes32 private constant META_TRANSACTION_TYPEHASH =\\n        keccak256(\\n            bytes(\\n                \\\"MetaTransaction(uint256 nonce,address from,bytes functionSignature)\\\"\\n            )\\n        );\\n\\n    event MetaTransactionExecuted(\\n        address userAddress,\\n        address payable relayerAddress,\\n        bytes functionSignature\\n    );\\n\\n    mapping(address =\\u003e uint256) internal nonces;\\n\\n    /*\\n     * Meta transaction structure.\\n     * No point of including value field here as if user is doing value transfer then he has the funds to pay for gas\\n     * He should call the desired function directly in that case.\\n     */\\n    struct MetaTransaction {\\n\\t\\tuint256 nonce;\\n\\t\\taddress from;\\n        bytes functionSignature;\\n\\t}\\n\\n    function executeMetaTransaction(\\n        address userAddress,\\n        bytes memory functionSignature,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    )\\n        public\\n        payable\\n        returns(bytes memory)\\n    {\\n        MetaTransaction memory metaTx = MetaTransaction(\\n            {\\n                nonce: nonces[userAddress],\\n                from: userAddress,\\n                functionSignature: functionSignature\\n            }\\n        );\\n\\n        require(\\n            verify(\\n                userAddress,\\n                metaTx,\\n                sigR,\\n                sigS,\\n                sigV\\n            ), \\\"Signer and signature do not match\\\"\\n        );\\n\\n\\t    nonces[userAddress] =\\n\\t    nonces[userAddress] + 1;\\n\\n        // Append userAddress at the end to extract it from calling context\\n        (bool success, bytes memory returnData) = address(this).call(\\n            abi.encodePacked(\\n                functionSignature,\\n                userAddress\\n            )\\n        );\\n\\n        require(\\n            success,\\n            \\u0027Function call not successful\\u0027\\n        );\\n\\n        emit MetaTransactionExecuted(\\n            userAddress,\\n            payable(msg.sender),\\n            functionSignature\\n        );\\n\\n        return returnData;\\n    }\\n\\n    function hashMetaTransaction(\\n        MetaTransaction memory metaTx\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n\\t\\treturn keccak256(\\n\\t\\t    abi.encode(\\n                META_TRANSACTION_TYPEHASH,\\n                metaTx.nonce,\\n                metaTx.from,\\n                keccak256(metaTx.functionSignature)\\n            )\\n        );\\n\\t}\\n\\n    function verify(\\n        address user,\\n        MetaTransaction memory metaTx,\\n        bytes32 sigR,\\n        bytes32 sigS,\\n        uint8 sigV\\n    )\\n        internal\\n        view\\n        returns (bool)\\n    {\\n        address signer = ecrecover(\\n            toTypedMessageHash(\\n                hashMetaTransaction(metaTx)\\n            ),\\n            sigV,\\n            sigR,\\n            sigS\\n        );\\n\\n        require(\\n            signer != address(0x0),\\n            \\u0027Invalid signature\\u0027\\n        );\\n\\t\\treturn signer == user;\\n\\t}\\n\\n    function msgSender() internal view returns(address sender) {\\n        if(msg.sender == address(this)) {\\n            bytes memory array = msg.data;\\n            uint256 index = msg.data.length;\\n            assembly {\\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\\n                sender := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\\n            }\\n        } else {\\n            sender = msg.sender;\\n        }\\n        return sender;\\n    }\\n\\n    function getNonce(\\n        address _user\\n    )\\n        external\\n        view\\n        returns(uint256 nonce)\\n    {\\n        nonce = nonces[_user];\\n    }\\n}\\n\"},\"Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG----\\n\\npragma solidity ^0.8.12;\\n\\ninterface ERC721 {\\n\\n    function ownerOf(\\n        uint256 _tokenId\\n    )\\n        external\\n        view\\n        returns (address);\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _tokenId\\n    )\\n        external;\\n}\\n\\ninterface ERC20 {\\n\\n    function burn(\\n        uint256 _amount\\n    )\\n        external;\\n}\\n\\ninterface DGAccessories  {\\n\\n    function issueTokens(\\n        address[] calldata _beneficiaries,\\n        uint256[] calldata _itemIds\\n    )\\n        external;\\n\\n    function encodeTokenId(\\n        uint256 _itemId,\\n        uint256 _issuedId\\n    )\\n        external\\n        pure\\n        returns (uint256 id);\\n\\n    function decodeTokenId(\\n        uint256 _tokenId\\n    )\\n        external\\n        pure\\n        returns (\\n            uint256 itemId,\\n            uint256 issuedId\\n        );\\n\\n    function items(\\n        uint256 _id\\n    )\\n        external\\n        view\\n        returns (\\n            string memory rarity,\\n            uint256 maxSupply,\\n            uint256 totalSupply,\\n            uint256 price,\\n            address beneficiary,\\n            string memory metadata,\\n            string memory contentHash\\n        );\\n\\n    function itemsCount()\\n        external\\n        view\\n        returns (uint256);\\n}\\n\"},\"NFTPurchaser.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG---\\n\\npragma solidity =0.8.12;\\n\\nimport \\\"./EIP712MetaTransaction.sol\\\";\\nimport \\\"./AccessController.sol\\\";\\nimport \\\"./TransferHelper.sol\\\";\\nimport \\\"./Interfaces.sol\\\";\\n\\ncontract NFTPurchaser is AccessController, TransferHelper, EIP712MetaTransaction {\\n\\n    uint256 public buyingPrice;\\n    address public paymentToken;\\n\\n    uint256 public saleCount;\\n    uint256 public saleFrame;\\n    uint256 public saleLimit;\\n\\n    bool public allowChangeSaleLimit;\\n\\n    mapping (address =\\u003e address) public targets;\\n    mapping (address =\\u003e uint256) public frames;\\n    mapping (uint256 =\\u003e uint256) public limits;\\n\\n    event Buy(\\n        uint256 indexed tokenId,\\n        uint256 indexed buyCount,\\n        address indexed tokenOwner\\n    );\\n\\n    event SupplyCheck(\\n        string rarity,\\n        uint256 maxSupply,\\n        uint256 price,\\n        address indexed beneficiary,\\n        string indexed metadata,\\n        string indexed contentHash\\n    );\\n\\n    constructor(\\n        uint256 _buyingPrice,\\n        address _paymentToken,\\n        address _accessoriesContract\\n    )\\n        EIP712Base(\\\"NFTPurchaser\\\", \\\"v1.0\\\")\\n    {\\n        saleLimit = 500;\\n        saleFrame = 1 hours;\\n\\n        paymentToken = _paymentToken;\\n        buyingPrice = _buyingPrice;\\n\\n        allowChangeSaleLimit = true;\\n        targets[_accessoriesContract] = _accessoriesContract;\\n\\n        limits[0] = 100;\\n    }\\n\\n    function changeBuyingPrice(\\n        uint256 _newBuyingPrice\\n    )\\n        external\\n        onlyCEO\\n    {\\n        buyingPrice = _newBuyingPrice;\\n    }\\n\\n    function changeBuyingLimits(\\n        uint256 _itemId,\\n        uint256 _newLimit\\n    )\\n        external\\n        onlyCEO\\n    {\\n        limits[_itemId] = _newLimit;\\n    }\\n\\n    function changeSaleFrame(\\n        uint256 _newSaleFrame\\n    )\\n        external\\n        onlyCEO\\n    {\\n        saleFrame = _newSaleFrame;\\n    }\\n\\n    function changeSaleLimit(\\n        uint256 _newSaleLimit\\n    )\\n        external\\n        onlyCEO\\n    {\\n        require(\\n            allowChangeSaleLimit == true,\\n            \\\"NFTPurchaser: DISABLED\\\"\\n        );\\n\\n        saleLimit = _newSaleLimit;\\n    }\\n\\n    function disabledSaleLimitChange()\\n        external\\n        onlyCEO\\n    {\\n        allowChangeSaleLimit = false;\\n    }\\n\\n    function changePaymentToken(\\n        address _newPaymentToken\\n    )\\n        external\\n        onlyCEO\\n    {\\n        paymentToken = _newPaymentToken;\\n    }\\n\\n    function changeTargetContract(\\n        address _tokenAddress,\\n        address _accessoriesContract\\n    )\\n        external\\n        onlyCEO\\n    {\\n        targets[_tokenAddress] = _accessoriesContract;\\n    }\\n\\n    function purchaseToken(\\n        uint256 _itemId,\\n        address _buyerAddress,\\n        address _tokenAddress\\n    )\\n        external\\n        onlyWorker\\n    {\\n        require(\\n            saleLimit \\u003e saleCount,\\n            \\\"NFTPurchaser: SOLD_OUT\\\"\\n        );\\n\\n        unchecked {\\n            saleCount =\\n            saleCount + 1;\\n        }\\n\\n        require(\\n            limits[_itemId] \\u003e 0,\\n            \\\"NFTPurchaser: LIMITED\\\"\\n        );\\n\\n        unchecked {\\n            limits[_itemId] =\\n            limits[_itemId] - 1;\\n        }\\n\\n        require(\\n            canPurchaseAgain(_buyerAddress),\\n            \\\"NFTPurchaser: COOL_DOWN_DETECTED\\\"\\n        );\\n\\n        frames[_buyerAddress] = block.timestamp;\\n\\n        safeTransferFrom(\\n            paymentToken,\\n            _buyerAddress,\\n            ceoAddress,\\n            buyingPrice\\n        );\\n\\n        DGAccessories target = DGAccessories(\\n            targets[_tokenAddress]\\n        );\\n\\n        uint256 newTokenId = target.encodeTokenId(\\n            _itemId,\\n            getSupply(_itemId, targets[_tokenAddress]) + 1\\n        );\\n\\n        address[] memory beneficiaries = new address[](1);\\n        beneficiaries[0] = _buyerAddress;\\n\\n        uint256[] memory itemIds = new uint256[](1);\\n        itemIds[0] = _itemId;\\n\\n        target.issueTokens(\\n            beneficiaries,\\n            itemIds\\n        );\\n\\n        emit Buy(\\n            newTokenId,\\n            saleCount,\\n            _buyerAddress\\n        );\\n    }\\n\\n    function canPurchaseAgain(\\n        address _buyerAddress\\n    )\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return block.timestamp - frames[_buyerAddress] \\u003e saleFrame;\\n    }\\n\\n    function getSupply(\\n        uint256 _itemId,\\n        address _accessoriesContract\\n    )\\n        public\\n        returns (uint256)\\n    {\\n        (   string memory rarity,\\n            uint256 maxSupply,\\n            uint256 totalSupply,\\n            uint256 price,\\n            address beneficiary,\\n            string memory metadata,\\n            string memory contentHash\\n\\n        ) = DGAccessories(_accessoriesContract).items(_itemId);\\n\\n        emit SupplyCheck(\\n            rarity,\\n            maxSupply,\\n            price,\\n            beneficiary,\\n            metadata,\\n            contentHash\\n        );\\n\\n        return totalSupply;\\n    }\\n}\\n\"},\"TransferHelper.sol\":{\"content\":\"// SPDX-License-Identifier: ---DG----\\n\\npragma solidity ^0.8.12;\\n\\ncontract TransferHelper {\\n\\n    bytes4 private constant TRANSFER = bytes4(\\n        keccak256(\\n            bytes(\\n                \\u0027transfer(address,uint256)\\u0027 // 0xa9059cbb\\n            )\\n        )\\n    );\\n\\n    bytes4 private constant TRANSFER_FROM = bytes4(\\n        keccak256(\\n            bytes(\\n                \\u0027transferFrom(address,address,uint256)\\u0027 // 0x23b872dd\\n            )\\n        )\\n    );\\n\\n    function safeTransfer(\\n        address _token,\\n        address _to,\\n        uint256 _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER, // 0xa9059cbb\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\u0027TransferHelper: TRANSFER_FAILED\\u0027\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address _token,\\n        address _from,\\n        address _to,\\n        uint _value\\n    )\\n        internal\\n    {\\n        (bool success, bytes memory data) = _token.call(\\n            abi.encodeWithSelector(\\n                TRANSFER_FROM,\\n                _from,\\n                _to,\\n                _value\\n            )\\n        );\\n\\n        require(\\n            success \\u0026\\u0026 (\\n                data.length == 0 || abi.decode(\\n                    data, (bool)\\n                )\\n            ),\\n            \\u0027TransferHelper: TRANSFER_FROM_FAILED\\u0027\\n        );\\n    }\\n\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_buyingPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_paymentToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_accessoriesContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"buyCount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newCEO\",\"type\":\"address\"}],\"name\":\"CEOSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address payable\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"rarity\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxSupply\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"metadata\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"string\",\"name\":\"contentHash\",\"type\":\"string\"}],\"name\":\"SupplyCheck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWorker\",\"type\":\"address\"}],\"name\":\"WorkerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"existingWorker\",\"type\":\"address\"}],\"name\":\"WorkerRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newWorker\",\"type\":\"address\"}],\"name\":\"addWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_newWorkers\",\"type\":\"address[]\"}],\"name\":\"addWorkerBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"allowChangeSaleLimit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_buyerAddress\",\"type\":\"address\"}],\"name\":\"canPurchaseAgain\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_newLimit\",\"type\":\"uint256\"}],\"name\":\"changeBuyingLimits\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newBuyingPrice\",\"type\":\"uint256\"}],\"name\":\"changeBuyingPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPaymentToken\",\"type\":\"address\"}],\"name\":\"changePaymentToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSaleFrame\",\"type\":\"uint256\"}],\"name\":\"changeSaleFrame\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newSaleLimit\",\"type\":\"uint256\"}],\"name\":\"changeSaleLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_accessoriesContract\",\"type\":\"address\"}],\"name\":\"changeTargetContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"disabledSaleLimitChange\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"sigR\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"sigS\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"sigV\",\"type\":\"uint8\"}],\"name\":\"executeMetaTransaction\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"frames\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_accessoriesContract\",\"type\":\"address\"}],\"name\":\"getSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isWorker\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"limits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_itemId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_buyerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"purchaseToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_existingWorker\",\"type\":\"address\"}],\"name\":\"removeWorker\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_workerArray\",\"type\":\"address[]\"}],\"name\":\"removeWorkerBulk\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleFrame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"saleLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"targets\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "NFTPurchaser", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000016345785d8a00000000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f619000000000000000000000000cb06f6aee0655252a3f6f2884680421d55d3c645", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://89f2cd06132a300b08aba7ff7400620b32420c8fcf1caf12b28bff523ddee311"}