{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/forward-v2/forwarder/BiconomyForwarderV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"./ForwardRequestTypesV2.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n *\\n * @title BiconomyForwarder\\n *\\n * @notice A trusted forwarder for Biconomy relayed meta transactions\\n *\\n * @dev - Inherits Forward Request structs from Forward Request Types\\n * @dev - Verifies EIP712 signatures\\n * @dev - Verifies traditional personalSign signatures\\n * @dev - Implements 2D nonces... each Tx has a BatchId and a BatchNonce\\n * @dev - Keeps track of highest BatchId used by a given address, to assist in encoding of transactions client-side\\n * @dev - maintains a list of verified domain seperators\\n *\\n */\\n\\n contract BiconomyForwarderV2 is ForwardRequestTypesV2, Ownable {\\n    using ECDSA for bytes32;\\n\\n    mapping(bytes32 => bool) public domains;\\n\\n    uint256 chainId;\\n\\n    string public constant EIP712_DOMAIN_TYPE = \\\"EIP712Domain(string name,string version,address verifyingContract,bytes32 salt)\\\";\\n\\n    //@review\\n    bytes32 public constant REQUEST_TYPEHASH = keccak256(bytes(\\\"ForwardRequest(address from,address to,uint256 txGas,uint256 batchId,uint256 batchNonce,uint256 deadline,bytes data)\\\"));\\n\\n    //@review and rename\\n    bytes32 public constant FORWARD_REQUEST_TYPEHASH = keccak256(bytes(\\\"ERC20ForwardRequest(address from,address to,address token,uint256 txGas,uint256 tokenGasPrice,uint256 batchId,uint256 batchNonce,uint256 deadline,bytes data)\\\"));\\n\\n    //Sandbox use case\\n    bytes32 public constant CUSTOM_FORWARD_REQUEST_TYPEHASH = keccak256(bytes(\\\"CustomForwardRequest(string warning,string info,string action,ERC20ForwardRequest request)ERC20ForwardRequest(address from,address to,address token,uint256 txGas,uint256 tokenGasPrice,uint256 batchId,uint256 batchNonce,uint256 deadline,bytes data)\\\"));\\n\\n    mapping(address => mapping(uint256 => uint256)) nonces;\\n\\n    constructor(\\n    ) public {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        chainId = id;\\n    }\\n\\n    /**\\n     * @dev registers domain seperators, maintaining that all domain seperators used for EIP712 forward requests use...\\n     * ... the address of this contract and the chainId of the chain this contract is deployed to\\n     * @param name : name of dApp/dApp fee proxy\\n     * @param version : version of dApp/dApp fee proxy\\n     */\\n    function registerDomainSeparator(string calldata name, string calldata version) external onlyOwner{\\n        uint256 id;\\n        /* solhint-disable-next-line no-inline-assembly */\\n        assembly {\\n            id := chainid()\\n        }\\n\\n        bytes memory domainValue = abi.encode(\\n            keccak256(bytes(EIP712_DOMAIN_TYPE)),\\n            keccak256(bytes(name)),\\n            keccak256(bytes(version)),\\n            address(this),\\n            bytes32(id));\\n\\n        bytes32 domainHash = keccak256(domainValue);\\n\\n        domains[domainHash] = true;\\n        emit DomainRegistered(domainHash, domainValue);\\n    }\\n\\n    event DomainRegistered(bytes32 indexed domainSeparator, bytes domainValue);\\n\\n    event MetaTransactionExecuted(address indexed userAddress, address indexed relayerAddress, bytes indexed functionSignature);\\n\\n    /**\\n     * @dev returns a value from the nonces 2d mapping\\n     * @param from : the user address\\n     * @param batchId : the key of the user's batch being queried\\n     * @return nonce : the number of transaction made within said batch\\n     */\\n    function getNonce(address from, uint256 batchId)\\n    public view\\n    returns (uint256) {\\n        return nonces[from][batchId];\\n    }\\n\\n    //TODO\\n    //@review if new read method is needed for Custom\\n    /**\\n     * @dev an external function which exposes the internal _verifySigEIP712 method\\n     * @param req : request being verified\\n     * @param domainSeparator : the domain separator presented to the user when signing\\n     * @param sig : the signature generated by the user's wallet\\n     */\\n    function verifyEIP712(\\n        ERC20ForwardRequest calldata req,\\n        bytes32 domainSeparator,\\n        bytes calldata sig)\\n    external view {\\n        _verifySigEIP712(req, domainSeparator, sig);\\n    }\\n\\n    /**\\n     * @dev verifies the call is valid by calling _verifySigEIP712\\n     * @dev executes the forwarded call if valid\\n     * @dev updates the nonce after\\n     * @param req : ERC20 forward request being executed\\n     * @param domainSeparator : the domain separator presented to the user when signing\\n     * @param sig : the signature generated by the user's wallet\\n     * @return success : false if call fails. true otherwise\\n     * @return ret : any return data from the call\\n     */\\n    function executeEIP712(\\n        ERC20ForwardRequest calldata req,\\n        bytes32 domainSeparator,\\n        bytes calldata sig\\n    )\\n    external \\n    returns (bool success, bytes memory ret) {\\n        _verifySigEIP712(req,domainSeparator,sig);\\n        _updateNonce(req);\\n        /* solhint-disable-next-line avoid-low-level-calls */\\n         (success,ret) = req.to.call{gas : req.txGas}(abi.encodePacked(req.data, req.from));\\n         // Validate that the relayer has sent enough gas for the call.\\n        // See https://ronan.eth.link/blog/ethereum-gas-dangers/\\n        assert(gasleft() > req.txGas / 63);\\n        _verifyCallResult(success,ret,\\\"Forwarded call to destination did not succeed\\\");\\n        emit MetaTransactionExecuted(req.from, msg.sender, req.data);\\n    }\\n\\n    /**\\n     * @dev verifies the call is valid by calling _verifySigEIP712Custom\\n     * @dev executes the forwarded call if valid\\n     * @dev updates the nonce after\\n     * @param req : Custom ERC20 forward request being executed\\n     * @param domainSeparator : the domain separator presented to the user when signing\\n     * @param sig : the signature generated by the user's wallet\\n     * @return success : false if call fails. true otherwise\\n     * @return ret : any return data from the call\\n     */\\n    function executeEIP712Custom(\\n        CustomForwardRequest calldata req,\\n        bytes32 domainSeparator,\\n        bytes calldata sig\\n    )\\n    external \\n    returns (bool success, bytes memory ret) {\\n        _verifySigEIP712Custom(req,domainSeparator,sig);\\n        _updateNonceCustom(req);\\n        /* solhint-disable-next-line avoid-low-level-calls */\\n         (success,ret) = req.request.to.call{gas : req.request.txGas}(abi.encodePacked(req.request.data, req.request.from));\\n         // Validate that the relayer has sent enough gas for the call.\\n        // See https://ronan.eth.link/blog/ethereum-gas-dangers/\\n        assert(gasleft() > req.request.txGas / 63);\\n        _verifyCallResult(success,ret,\\\"Forwarded call to destination did not succeed\\\");\\n        emit MetaTransactionExecuted(req.request.from, msg.sender, req.request.data);\\n    }\\n\\n    /**\\n     * @dev an external function which exposes the internal _verifySigPersonSign method\\n     * @param req : request being verified\\n     * @param sig : the signature generated by the user's wallet\\n     */\\n    function verifyPersonalSign(\\n        ERC20ForwardRequest calldata req,\\n        bytes calldata sig)\\n    external view {\\n        _verifySigPersonalSign(req, sig);\\n    }\\n\\n    /**\\n     * @dev verifies the call is valid by calling _verifySigPersonalSign\\n     * @dev executes the forwarded call if valid\\n     * @dev updates the nonce after\\n     * @param req : ERC20 forward request being executed\\n     * @param sig : the signature generated by the user's wallet\\n     * @return success : false if call fails. true otherwise\\n     * @return ret : any return data from the call\\n     */\\n    function executePersonalSign(ERC20ForwardRequest calldata req,bytes calldata sig)\\n    external \\n    returns(bool success, bytes memory ret){\\n        _verifySigPersonalSign(req, sig);\\n        _updateNonce(req);\\n        (success,ret) = req.to.call{gas : req.txGas}(abi.encodePacked(req.data, req.from));\\n        // Validate that the relayer has sent enough gas for the call.\\n        // See https://ronan.eth.link/blog/ethereum-gas-dangers/\\n        assert(gasleft() > req.txGas / 63);\\n        _verifyCallResult(success,ret,\\\"Forwarded call to destination did not succeed\\\");\\n        emit MetaTransactionExecuted(req.from, msg.sender, req.data);\\n    }\\n\\n    /**\\n     * @dev Increments the nonce of given user/batch pair\\n     * @dev Updates the highestBatchId of the given user if the request's batchId > current highest\\n     * @dev only intended to be called post call execution\\n     * @param req : ERC20 forward request that was executed\\n     */\\n    function _updateNonce(ERC20ForwardRequest calldata req) internal {\\n        nonces[req.from][req.batchId]++;\\n    }\\n    \\n    /**\\n     * @dev Increments the nonce of given user/batch pair\\n     * @dev Updates the highestBatchId of the given user if the request's batchId > current highest\\n     * @dev only intended to be called post call execution\\n     * @param req : ERC20 custom forward request that was executed\\n     */\\n    function _updateNonceCustom(CustomForwardRequest calldata req) internal {\\n        nonces[req.request.from][req.request.batchId]++;\\n    }\\n\\n    /**\\n     * @dev verifies the domain separator used has been registered via registerDomainSeparator()\\n     * @dev recreates the 32 byte hash signed by the user's wallet (as per EIP712 specifications)\\n     * @dev verifies the signature using Open Zeppelin's ECDSA library\\n     * @dev signature valid if call doesn't throw\\n     *\\n     * @param req : ERC20 forward request being executed\\n     * @param domainSeparator : the domain separator presented to the user when signing\\n     * @param sig : the signature generated by the user's wallet\\n     *\\n     */\\n    function _verifySigEIP712(\\n        ERC20ForwardRequest calldata req,\\n        bytes32 domainSeparator,\\n        bytes memory sig)\\n    internal\\n    view\\n    {   \\n        uint256 id;\\n        /* solhint-disable-next-line no-inline-assembly */\\n        assembly {\\n            id := chainid()\\n        }\\n        require(req.deadline == 0 || block.timestamp + 20 <= req.deadline, \\\"request expired\\\");\\n        require(domains[domainSeparator], \\\"unregistered domain separator\\\");\\n        require(chainId == id, \\\"potential replay attack on the fork\\\");\\n        bytes32 digest =\\n            keccak256(abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                hashERC20ForwardRequest(req)\\n            ));\\n        require(digest.recover(sig) == req.from, \\\"signature mismatch\\\");\\n    }\\n\\n    /**\\n     * @dev verifies the domain separator used has been registered via registerDomainSeparator()\\n     * @dev recreates the 32 byte hash signed by the user's wallet (as per EIP712 specifications)\\n     * @dev verifies the signature using Open Zeppelin's ECDSA library\\n     * @dev signature valid if call doesn't throw\\n     *\\n     * @param req : Custom ERC20 forward request being executed\\n     * @param domainSeparator : the domain separator presented to the user when signing\\n     * @param sig : the signature generated by the user's wallet\\n     *\\n     */\\n    function _verifySigEIP712Custom(\\n        CustomForwardRequest calldata req,\\n        bytes32 domainSeparator,\\n        bytes memory sig)\\n    internal\\n    view\\n    {   \\n        uint256 id;\\n        /* solhint-disable-next-line no-inline-assembly */\\n        assembly {\\n            id := chainid()\\n        }\\n        require(req.request.deadline == 0 || block.timestamp + 20 <= req.request.deadline, \\\"request expired\\\");\\n        require(domains[domainSeparator], \\\"unregistered domain separator\\\");\\n        require(chainId == id, \\\"potential replay attack on the fork\\\");\\n        bytes32 digest =\\n            keccak256(abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                domainSeparator,\\n                hashCustomForwardRequest(req)\\n            ));\\n        require(digest.recover(sig) == req.request.from, \\\"signature mismatch\\\");\\n    }\\n\\n\\n    function hashERC20ForwardRequest(ERC20ForwardRequest calldata request) internal view returns (bytes32) {\\n        return keccak256(abi.encode(\\n            FORWARD_REQUEST_TYPEHASH,\\n            request.from,\\n            request.to,\\n            request.token,\\n            request.txGas,\\n            request.tokenGasPrice,\\n            request.batchId,\\n            nonces[request.from][request.batchId],\\n            request.deadline,\\n            keccak256(request.data)\\n        ));\\n    }\\n\\n    function hashCustomForwardRequest(CustomForwardRequest calldata req) internal view returns (bytes32) {\\n        return keccak256(abi.encode(\\n            CUSTOM_FORWARD_REQUEST_TYPEHASH,\\n            keccak256(bytes(req.warning)),\\n            keccak256(bytes(req.info)),\\n            keccak256(bytes(req.action)),\\n            hashERC20ForwardRequest(req.request) \\n        ));\\n    }\\n\\n    /**\\n     * @dev encodes a 32 byte data string (presumably a hash of encoded data) as per eth_sign\\n     *\\n     * @param hash : hash of encoded data that signed by user's wallet using eth_sign\\n     * @return input hash encoded to matched what is signed by the user's key when using eth_sign*/\\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev recreates the 32 byte hash signed by the user's wallet\\n     * @dev verifies the signature using Open Zeppelin's ECDSA library\\n     * @dev signature valid if call doesn't throw\\n     *\\n     * @param req : ERC20 forward request being executed\\n     * @param sig : the signature generated by the user's wallet\\n     *\\n     */\\n    function _verifySigPersonalSign(\\n        ERC20ForwardRequest calldata req,\\n        bytes memory sig)\\n    internal\\n    view\\n    {\\n        require(req.deadline == 0 || block.timestamp + 20 <= req.deadline, \\\"request expired\\\");\\n        bytes32 digest = prefixed(keccak256(abi.encodePacked(\\n            req.from,\\n            req.to,\\n            req.token,\\n            req.txGas,\\n            req.tokenGasPrice,\\n            req.batchId,\\n            nonces[req.from][req.batchId],\\n            req.deadline,\\n            keccak256(req.data)\\n        )));\\n        require(digest.recover(sig) == req.from, \\\"signature mismatch\\\");\\n    }\\n\\n    /**\\n     * @dev verifies the call result and bubbles up revert reason for failed calls\\n     *\\n     * @param success : outcome of forwarded call\\n     * @param returndata : returned data from the frowarded call\\n     * @param errorMessage : fallback error message to show \\n     */\\n     function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure {\\n        if (!success) {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s;\\n        uint8 v;\\n        assembly {\\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\\n            v := add(shr(255, vs), 27)\\n        }\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/forward-v2/forwarder/ForwardRequestTypesV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.4;\\n\\n\\n/* deadline can be removed : GSN reference https://github.com/opengsn/gsn/blob/master/contracts/forwarder/IForwarder.sol (Saves 250 more gas)*/\\n/**\\n* @title ForwardRequestTypes \\n* @notice specifies structures required by Forwarders to verify structured signatures.\\n* @notice This contract defines a struct which both ERC20Forwarder and BiconomyForwarder inherit. ERC20ForwardRequest includes all the fields present in the GSN V2 ForwardRequest struct, \\n* but adds the following :\\n* address token : address of the token to pay for gas fees. For gasless transactions token address will be 0 address\\n* uint256 tokenGasPrice : gas price in the context of fee token\\n* uint256 txGas : gas to be supplied for recipient method call\\n* uint256 batchNonce : used for 2D nonces\\n* uint256 deadline \\n* @dev Fields are placed in type order, to minimise storage used when executing transactions.\\n*/\\ncontract ForwardRequestTypesV2 {\\n\\n/*allow the EVM to optimize for this, \\nensure that you try to order your storage variables and struct members such that they can be packed tightly*/\\n\\n    struct ForwardRequest {\\n        address from; \\n        address to; \\n        uint256 txGas;\\n        uint256 batchId; \\n        uint256 batchNonce; \\n        uint256 deadline; \\n        bytes data;\\n    }\\n\\n    struct ERC20ForwardRequest {\\n        address from; \\n        address to; \\n        address token; \\n        uint256 txGas;\\n        uint256 tokenGasPrice;\\n        uint256 batchId; \\n        uint256 batchNonce; \\n        uint256 deadline; \\n        bytes data;\\n    }\\n\\n    //@review\\n    //should be SandBox Forward Request?\\n    struct CustomForwardRequest {\\n        string warning; //optional\\n        string info;\\n        string action;\\n        ERC20ForwardRequest request;\\n    }\\n\\n     //For DAI and EIP2612 type Permits\\n     struct PermitRequest {\\n        address holder; \\n        address spender;  \\n        uint256 value;\\n        uint256 nonce;\\n        uint256 expiry;\\n        bool allowed; \\n        uint8 v;\\n        bytes32 r; \\n        bytes32 s; \\n    }\\n\\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _setOwner(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _setOwner(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _setOwner(newOwner);\\n    }\\n\\n    function _setOwner(address newOwner) private {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"evmVersion\": \"berlin\",\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"domainValue\",\"type\":\"bytes\"}],\"name\":\"DomainRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes\",\"name\":\"functionSignature\",\"type\":\"bytes\"}],\"name\":\"MetaTransactionExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CUSTOM_FORWARD_REQUEST_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"EIP712_DOMAIN_TYPE\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"FORWARD_REQUEST_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REQUEST_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"domains\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct ForwardRequestTypesV2.ERC20ForwardRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"executeEIP712\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"ret\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"warning\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"info\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"action\",\"type\":\"string\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct ForwardRequestTypesV2.ERC20ForwardRequest\",\"name\":\"request\",\"type\":\"tuple\"}],\"internalType\":\"struct ForwardRequestTypesV2.CustomForwardRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"executeEIP712Custom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"ret\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct ForwardRequestTypesV2.ERC20ForwardRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"executePersonalSign\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"},{\"internalType\":\"bytes\",\"name\":\"ret\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"}],\"name\":\"getNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"version\",\"type\":\"string\"}],\"name\":\"registerDomainSeparator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct ForwardRequestTypesV2.ERC20ForwardRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes32\",\"name\":\"domainSeparator\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verifyEIP712\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"txGas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenGasPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"batchNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct ForwardRequestTypesV2.ERC20ForwardRequest\",\"name\":\"req\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verifyPersonalSign\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "BiconomyForwarderV2", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}