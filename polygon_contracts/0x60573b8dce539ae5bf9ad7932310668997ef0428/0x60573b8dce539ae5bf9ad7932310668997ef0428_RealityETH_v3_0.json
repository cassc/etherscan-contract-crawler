{"SourceCode": "// SPDX-License-Identifier: GPL-3.0-only\r\n\r\npragma solidity ^0.8.6;\r\n\r\ncontract BalanceHolder {\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    event LogWithdraw(\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n\r\n    function withdraw() \r\n    public {\r\n        uint256 bal = balanceOf[msg.sender];\r\n        balanceOf[msg.sender] = 0;\r\n        payable(msg.sender).transfer(bal);\r\n        emit LogWithdraw(msg.sender, bal);\r\n    }\r\n\r\n}\r\n\r\ncontract RealityETH_v3_0 is BalanceHolder {\r\n\r\n    address constant NULL_ADDRESS = address(0);\r\n\r\n    // History hash when no history is created, or history has been cleared\r\n    bytes32 constant NULL_HASH = bytes32(0);\r\n\r\n    // An unitinalized finalize_ts for a question will indicate an unanswered question.\r\n    uint32 constant UNANSWERED = 0;\r\n\r\n    // An unanswered reveal_ts for a commitment will indicate that it does not exist.\r\n    uint256 constant COMMITMENT_NON_EXISTENT = 0;\r\n\r\n    // Commit->reveal timeout is 1/8 of the question timeout (rounded down).\r\n    uint32 constant COMMITMENT_TIMEOUT_RATIO = 8;\r\n\r\n    // Proportion withheld when you claim an earlier bond.\r\n    uint256 constant BOND_CLAIM_FEE_PROPORTION = 40; // One 40th ie 2.5%\r\n\r\n    // Special value representing a question that was answered too soon.\r\n    // bytes32(-2). By convention we use bytes32(-1) for \"invalid\", although the contract does not handle this.\r\n    bytes32 constant UNRESOLVED_ANSWER = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe;\r\n\r\n    event LogSetQuestionFee(\r\n        address arbitrator,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogNewTemplate(\r\n        uint256 indexed template_id,\r\n        address indexed user, \r\n        string question_text\r\n    );\r\n\r\n    event LogNewQuestion(\r\n        bytes32 indexed question_id,\r\n        address indexed user, \r\n        uint256 template_id,\r\n        string question,\r\n        bytes32 indexed content_hash,\r\n        address arbitrator, \r\n        uint32 timeout,\r\n        uint32 opening_ts,\r\n        uint256 nonce,\r\n        uint256 created\r\n    );\r\n\r\n    event LogMinimumBond(\r\n        bytes32 indexed question_id,\r\n        uint256 min_bond\r\n    );\r\n\r\n    event LogFundAnswerBounty(\r\n        bytes32 indexed question_id,\r\n        uint256 bounty_added,\r\n        uint256 bounty,\r\n        address indexed user \r\n    );\r\n\r\n    event LogNewAnswer(\r\n        bytes32 answer,\r\n        bytes32 indexed question_id,\r\n        bytes32 history_hash,\r\n        address indexed user,\r\n        uint256 bond,\r\n        uint256 ts,\r\n        bool is_commitment\r\n    );\r\n\r\n    event LogAnswerReveal(\r\n        bytes32 indexed question_id, \r\n        address indexed user, \r\n        bytes32 indexed answer_hash, \r\n        bytes32 answer, \r\n        uint256 nonce, \r\n        uint256 bond\r\n    );\r\n\r\n    event LogNotifyOfArbitrationRequest(\r\n        bytes32 indexed question_id,\r\n        address indexed user \r\n    );\r\n\r\n    event LogCancelArbitration(\r\n        bytes32 indexed question_id\r\n    );\r\n\r\n    event LogFinalize(\r\n        bytes32 indexed question_id,\r\n        bytes32 indexed answer\r\n    );\r\n\r\n    event LogClaim(\r\n        bytes32 indexed question_id,\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogReopenQuestion(\r\n        bytes32 indexed question_id,\r\n        bytes32 indexed reopened_question_id\r\n    );\r\n\r\n    struct Question {\r\n        bytes32 content_hash;\r\n        address arbitrator;\r\n        uint32 opening_ts;\r\n        uint32 timeout;\r\n        uint32 finalize_ts;\r\n        bool is_pending_arbitration;\r\n        uint256 bounty;\r\n        bytes32 best_answer;\r\n        bytes32 history_hash;\r\n        uint256 bond;\r\n        uint256 min_bond;\r\n    }\r\n\r\n    // Stored in a mapping indexed by commitment_id, a hash of commitment hash, question, bond. \r\n    struct Commitment {\r\n        uint32 reveal_ts;\r\n        bool is_revealed;\r\n        bytes32 revealed_answer;\r\n    }\r\n\r\n    // Only used when claiming more bonds than fits into a transaction\r\n    // Stored in a mapping indexed by question_id.\r\n    struct Claim {\r\n        address payee;\r\n        uint256 last_bond;\r\n        uint256 queued_funds;\r\n    }\r\n\r\n    uint256 nextTemplateID = 0;\r\n    mapping(uint256 => uint256) public templates;\r\n    mapping(uint256 => bytes32) public template_hashes;\r\n    mapping(bytes32 => Question) public questions;\r\n    mapping(bytes32 => Claim) public question_claims;\r\n    mapping(bytes32 => Commitment) public commitments;\r\n    mapping(address => uint256) public arbitrator_question_fees; \r\n    mapping(bytes32 => bytes32) public reopened_questions;\r\n    mapping(bytes32 => bool) public reopener_questions;\r\n\r\n\r\n    modifier onlyArbitrator(bytes32 question_id) {\r\n        require(msg.sender == questions[question_id].arbitrator, \"msg.sender must be arbitrator\");\r\n        _;\r\n    }\r\n\r\n    modifier stateAny() {\r\n        _;\r\n    }\r\n\r\n    modifier stateNotCreated(bytes32 question_id) {\r\n        require(questions[question_id].timeout == 0, \"question must not exist\");\r\n        _;\r\n    }\r\n\r\n    modifier stateOpen(bytes32 question_id) {\r\n        require(questions[question_id].timeout > 0, \"question must exist\");\r\n        require(!questions[question_id].is_pending_arbitration, \"question must not be pending arbitration\");\r\n        uint32 finalize_ts = questions[question_id].finalize_ts;\r\n        require(finalize_ts == UNANSWERED || finalize_ts > uint32(block.timestamp), \"finalization deadline must not have passed\");\r\n        uint32 opening_ts = questions[question_id].opening_ts;\r\n        require(opening_ts == 0 || opening_ts <= uint32(block.timestamp), \"opening date must have passed\"); \r\n        _;\r\n    }\r\n\r\n    modifier statePendingArbitration(bytes32 question_id) {\r\n        require(questions[question_id].is_pending_arbitration, \"question must be pending arbitration\");\r\n        _;\r\n    }\r\n\r\n    modifier stateOpenOrPendingArbitration(bytes32 question_id) {\r\n        require(questions[question_id].timeout > 0, \"question must exist\");\r\n        uint32 finalize_ts = questions[question_id].finalize_ts;\r\n        require(finalize_ts == UNANSWERED || finalize_ts > uint32(block.timestamp), \"finalization dealine must not have passed\");\r\n        uint32 opening_ts = questions[question_id].opening_ts;\r\n        require(opening_ts == 0 || opening_ts <= uint32(block.timestamp), \"opening date must have passed\"); \r\n        _;\r\n    }\r\n\r\n    modifier stateFinalized(bytes32 question_id) {\r\n        require(isFinalized(question_id), \"question must be finalized\");\r\n        _;\r\n    }\r\n\r\n    modifier bondMustDoubleAndMatchMinimum(bytes32 question_id) {\r\n        require(msg.value > 0, \"bond must be positive\"); \r\n        uint256 current_bond = questions[question_id].bond;\r\n        if (current_bond == 0) {\r\n            require(msg.value >= (questions[question_id].min_bond), \"bond must exceed the minimum\");\r\n        } else {\r\n            require(msg.value >= (current_bond * 2), \"bond must be double at least previous bond\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier previousBondMustNotBeatMaxPrevious(bytes32 question_id, uint256 max_previous) {\r\n        if (max_previous > 0) {\r\n            require(questions[question_id].bond <= max_previous, \"bond must exceed max_previous\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @notice Constructor, sets up some initial templates\r\n    /// @dev Creates some generalized templates for different question types used in the DApp.\r\n    constructor() {\r\n        createTemplate('{\"title\": \"%s\", \"type\": \"bool\", \"category\": \"%s\", \"lang\": \"%s\"}');\r\n        createTemplate('{\"title\": \"%s\", \"type\": \"uint\", \"decimals\": 18, \"category\": \"%s\", \"lang\": \"%s\"}');\r\n        createTemplate('{\"title\": \"%s\", \"type\": \"single-select\", \"outcomes\": [%s], \"category\": \"%s\", \"lang\": \"%s\"}');\r\n        createTemplate('{\"title\": \"%s\", \"type\": \"multiple-select\", \"outcomes\": [%s], \"category\": \"%s\", \"lang\": \"%s\"}');\r\n        createTemplate('{\"title\": \"%s\", \"type\": \"datetime\", \"category\": \"%s\", \"lang\": \"%s\"}');\r\n    }\r\n\r\n    /// @notice Function for arbitrator to set an optional per-question fee. \r\n    /// @dev The per-question fee, charged when a question is asked, is intended as an anti-spam measure.\r\n    /// @param fee The fee to be charged by the arbitrator when a question is asked\r\n    function setQuestionFee(uint256 fee) \r\n        stateAny() \r\n    external {\r\n        arbitrator_question_fees[msg.sender] = fee;\r\n        emit LogSetQuestionFee(msg.sender, fee);\r\n    }\r\n\r\n    /// @notice Create a reusable template, which should be a JSON document.\r\n    /// Placeholders should use gettext() syntax, eg %s.\r\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\r\n    /// @param content The template content\r\n    /// @return The ID of the newly-created template, which is created sequentially.\r\n    function createTemplate(string memory content) \r\n        stateAny()\r\n    public returns (uint256) {\r\n        uint256 id = nextTemplateID;\r\n        templates[id] = block.number;\r\n        template_hashes[id] = keccak256(abi.encodePacked(content));\r\n        emit LogNewTemplate(id, msg.sender, content);\r\n        nextTemplateID = id + 1;\r\n        return id;\r\n    }\r\n\r\n    /// @notice Create a new reusable template and use it to ask a question\r\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\r\n    /// @param content The template content\r\n    /// @param question A string containing the parameters that will be passed into the template to make the question\r\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\r\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\r\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\r\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\r\n    /// @return The ID of the newly-created template, which is created sequentially.\r\n    function createTemplateAndAskQuestion(\r\n        string memory content, \r\n        string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce \r\n    ) \r\n        // stateNotCreated is enforced by the internal _askQuestion\r\n    public payable returns (bytes32) {\r\n        uint256 template_id = createTemplate(content);\r\n        return askQuestion(template_id, question, arbitrator, timeout, opening_ts, nonce);\r\n    }\r\n\r\n    /// @notice Ask a new question and return the ID\r\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\r\n    /// @param template_id The ID number of the template the question will use\r\n    /// @param question A string containing the parameters that will be passed into the template to make the question\r\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\r\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\r\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\r\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\r\n    /// @return The ID of the newly-created question, created deterministically.\r\n    function askQuestion(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce) \r\n        // stateNotCreated is enforced by the internal _askQuestion\r\n    public payable returns (bytes32) {\r\n\r\n        require(templates[template_id] > 0, \"template must exist\");\r\n\r\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\r\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, uint256(0), address(this), msg.sender, nonce));\r\n\r\n        // We emit this event here because _askQuestion doesn't need to know the unhashed question. Other events are emitted by _askQuestion.\r\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, block.timestamp);\r\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, 0);\r\n\r\n        return question_id;\r\n    }\r\n\r\n    /// @notice Ask a new question and return the ID\r\n    /// @dev Template data is only stored in the event logs, but its block number is kept in contract storage.\r\n    /// @param template_id The ID number of the template the question will use\r\n    /// @param question A string containing the parameters that will be passed into the template to make the question\r\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\r\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\r\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\r\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\r\n    /// @param min_bond The minimum bond that may be used for an answer.\r\n    /// @return The ID of the newly-created question, created deterministically.\r\n    function askQuestionWithMinBond(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 min_bond) \r\n        // stateNotCreated is enforced by the internal _askQuestion\r\n    public payable returns (bytes32) {\r\n\r\n        require(templates[template_id] > 0, \"template must exist\");\r\n\r\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\r\n        bytes32 question_id = keccak256(abi.encodePacked(content_hash, arbitrator, timeout, min_bond, address(this), msg.sender, nonce));\r\n\r\n        // We emit this event here because _askQuestion doesn't need to know the unhashed question.\r\n        // Other events are emitted by _askQuestion.\r\n        emit LogNewQuestion(question_id, msg.sender, template_id, question, content_hash, arbitrator, timeout, opening_ts, nonce, block.timestamp);\r\n        _askQuestion(question_id, content_hash, arbitrator, timeout, opening_ts, min_bond);\r\n\r\n        return question_id;\r\n    }\r\n\r\n    function _askQuestion(bytes32 question_id, bytes32 content_hash, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 min_bond) \r\n        stateNotCreated(question_id)\r\n    internal {\r\n\r\n        // A timeout of 0 makes no sense, and we will use this to check existence\r\n        require(timeout > 0, \"timeout must be positive\"); \r\n        require(timeout < 365 days, \"timeout must be less than 365 days\"); \r\n\r\n        uint256 bounty = msg.value;\r\n\r\n        // The arbitrator can set a fee for asking a question. \r\n        // This is intended as an anti-spam defence.\r\n        // The fee is waived if the arbitrator is asking the question.\r\n        // This allows them to set an impossibly high fee and make users proxy the question through them.\r\n        // This would allow more sophisticated pricing, question whitelisting etc.\r\n        if (arbitrator != NULL_ADDRESS && msg.sender != arbitrator) {\r\n            uint256 question_fee = arbitrator_question_fees[arbitrator];\r\n            require(bounty >= question_fee, \"ETH provided must cover question fee\"); \r\n            bounty = bounty - question_fee;\r\n            balanceOf[arbitrator] = balanceOf[arbitrator] + question_fee;\r\n        }\r\n\r\n        questions[question_id].content_hash = content_hash;\r\n        questions[question_id].arbitrator = arbitrator;\r\n        questions[question_id].opening_ts = opening_ts;\r\n        questions[question_id].timeout = timeout;\r\n\r\n        if (bounty > 0) {\r\n            questions[question_id].bounty = bounty;\r\n            emit LogFundAnswerBounty(question_id, bounty, bounty, msg.sender);\r\n        }\r\n\r\n        if (min_bond > 0) {\r\n            questions[question_id].min_bond = min_bond;\r\n            emit LogMinimumBond(question_id, min_bond);\r\n        }\r\n\r\n    }\r\n\r\n    /// @notice Add funds to the bounty for a question\r\n    /// @dev Add bounty funds after the initial question creation. Can be done any time until the question is finalized.\r\n    /// @param question_id The ID of the question you wish to fund\r\n    function fundAnswerBounty(bytes32 question_id) \r\n        stateOpen(question_id)\r\n    external payable {\r\n        questions[question_id].bounty = questions[question_id].bounty + msg.value;\r\n        emit LogFundAnswerBounty(question_id, msg.value, questions[question_id].bounty, msg.sender);\r\n    }\r\n\r\n    /// @notice Submit an answer for a question.\r\n    /// @dev Adds the answer to the history and updates the current \"best\" answer.\r\n    /// May be subject to front-running attacks; Substitute submitAnswerCommitment()->submitAnswerReveal() to prevent them.\r\n    /// @param question_id The ID of the question\r\n    /// @param answer The answer, encoded into bytes32\r\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\r\n    function submitAnswer(bytes32 question_id, bytes32 answer, uint256 max_previous) \r\n        stateOpen(question_id)\r\n        bondMustDoubleAndMatchMinimum(question_id)\r\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\r\n    external payable {\r\n        _addAnswerToHistory(question_id, answer, msg.sender, msg.value, false);\r\n        _updateCurrentAnswer(question_id, answer);\r\n    }\r\n\r\n    /// @notice Submit an answer for a question, crediting it to the specified account.\r\n    /// @dev Adds the answer to the history and updates the current \"best\" answer.\r\n    /// May be subject to front-running attacks; Substitute submitAnswerCommitment()->submitAnswerReveal() to prevent them.\r\n    /// @param question_id The ID of the question\r\n    /// @param answer The answer, encoded into bytes32\r\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\r\n    /// @param answerer The account to which the answer should be credited\r\n    function submitAnswerFor(bytes32 question_id, bytes32 answer, uint256 max_previous, address answerer)\r\n        stateOpen(question_id)\r\n        bondMustDoubleAndMatchMinimum(question_id)\r\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\r\n    external payable {\r\n        require(answerer != NULL_ADDRESS, \"answerer must be non-zero\");\r\n        _addAnswerToHistory(question_id, answer, answerer, msg.value, false);\r\n        _updateCurrentAnswer(question_id, answer);\r\n    }\r\n\r\n    // @notice Verify and store a commitment, including an appropriate timeout\r\n    // @param question_id The ID of the question to store\r\n    // @param commitment The ID of the commitment\r\n    function _storeCommitment(bytes32 question_id, bytes32 commitment_id) \r\n    internal\r\n    {\r\n        require(commitments[commitment_id].reveal_ts == COMMITMENT_NON_EXISTENT, \"commitment must not already exist\");\r\n\r\n        uint32 commitment_timeout = questions[question_id].timeout / COMMITMENT_TIMEOUT_RATIO;\r\n        commitments[commitment_id].reveal_ts = uint32(block.timestamp) + commitment_timeout;\r\n    }\r\n\r\n    /// @notice Submit the hash of an answer, laying your claim to that answer if you reveal it in a subsequent transaction.\r\n    /// @dev Creates a hash, commitment_id, uniquely identifying this answer, to this question, with this bond.\r\n    /// The commitment_id is stored in the answer history where the answer would normally go.\r\n    /// Does not update the current best answer - this is left to the later submitAnswerReveal() transaction.\r\n    /// @param question_id The ID of the question\r\n    /// @param answer_hash The hash of your answer, plus a nonce that you will later reveal\r\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\r\n    /// @param _answerer If specified, the address to be given as the question answerer. Defaults to the sender.\r\n    /// @dev Specifying the answerer is useful if you want to delegate the commit-and-reveal to a third-party.\r\n    function submitAnswerCommitment(bytes32 question_id, bytes32 answer_hash, uint256 max_previous, address _answerer) \r\n        stateOpen(question_id)\r\n        bondMustDoubleAndMatchMinimum(question_id)\r\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\r\n    external payable {\r\n\r\n        bytes32 commitment_id = keccak256(abi.encodePacked(question_id, answer_hash, msg.value));\r\n        address answerer = (_answerer == NULL_ADDRESS) ? msg.sender : _answerer;\r\n        _storeCommitment(question_id, commitment_id);\r\n        _addAnswerToHistory(question_id, commitment_id, answerer, msg.value, true);\r\n\r\n    }\r\n\r\n    /// @notice Submit the answer whose hash you sent in a previous submitAnswerCommitment() transaction\r\n    /// @dev Checks the parameters supplied recreate an existing commitment, and stores the revealed answer\r\n    /// Updates the current answer unless someone has since supplied a new answer with a higher bond\r\n    /// msg.sender is intentionally not restricted to the user who originally sent the commitment; \r\n    /// For example, the user may want to provide the answer+nonce to a third-party service and let them send the tx\r\n    /// NB If we are pending arbitration, it will be up to the arbitrator to wait and see any outstanding reveal is sent\r\n    /// @param question_id The ID of the question\r\n    /// @param answer The answer, encoded as bytes32\r\n    /// @param nonce The nonce that, combined with the answer, recreates the answer_hash you gave in submitAnswerCommitment()\r\n    /// @param bond The bond that you paid in your submitAnswerCommitment() transaction\r\n    function submitAnswerReveal(bytes32 question_id, bytes32 answer, uint256 nonce, uint256 bond) \r\n        stateOpenOrPendingArbitration(question_id)\r\n    external {\r\n\r\n        bytes32 answer_hash = keccak256(abi.encodePacked(answer, nonce));\r\n        bytes32 commitment_id = keccak256(abi.encodePacked(question_id, answer_hash, bond));\r\n\r\n        require(!commitments[commitment_id].is_revealed, \"commitment must not have been revealed yet\");\r\n        require(commitments[commitment_id].reveal_ts > uint32(block.timestamp), \"reveal deadline must not have passed\");\r\n\r\n        commitments[commitment_id].revealed_answer = answer;\r\n        commitments[commitment_id].is_revealed = true;\r\n\r\n        if (bond == questions[question_id].bond) {\r\n            _updateCurrentAnswer(question_id, answer);\r\n        }\r\n\r\n        emit LogAnswerReveal(question_id, msg.sender, answer_hash, answer, nonce, bond);\r\n\r\n    }\r\n\r\n    function _addAnswerToHistory(bytes32 question_id, bytes32 answer_or_commitment_id, address answerer, uint256 bond, bool is_commitment) \r\n    internal \r\n    {\r\n        bytes32 new_history_hash = keccak256(abi.encodePacked(questions[question_id].history_hash, answer_or_commitment_id, bond, answerer, is_commitment));\r\n\r\n        // Update the current bond level, if there's a bond (ie anything except arbitration)\r\n        if (bond > 0) {\r\n            questions[question_id].bond = bond;\r\n        }\r\n        questions[question_id].history_hash = new_history_hash;\r\n\r\n        emit LogNewAnswer(answer_or_commitment_id, question_id, new_history_hash, answerer, bond, block.timestamp, is_commitment);\r\n    }\r\n\r\n    function _updateCurrentAnswer(bytes32 question_id, bytes32 answer)\r\n    internal {\r\n        questions[question_id].best_answer = answer;\r\n        questions[question_id].finalize_ts = uint32(block.timestamp) + questions[question_id].timeout;\r\n    }\r\n\r\n    // Like _updateCurrentAnswer but without advancing the timeout\r\n    function _updateCurrentAnswerByArbitrator(bytes32 question_id, bytes32 answer)\r\n    internal {\r\n        questions[question_id].best_answer = answer;\r\n        questions[question_id].finalize_ts = uint32(block.timestamp);\r\n    }\r\n\r\n    /// @notice Notify the contract that the arbitrator has been paid for a question, freezing it pending their decision.\r\n    /// @dev The arbitrator contract is trusted to only call this if they've been paid, and tell us who paid them.\r\n    /// @param question_id The ID of the question\r\n    /// @param requester The account that requested arbitration\r\n    /// @param max_previous If specified, reverts if a bond higher than this was submitted after you sent your transaction.\r\n    function notifyOfArbitrationRequest(bytes32 question_id, address requester, uint256 max_previous) \r\n        onlyArbitrator(question_id)\r\n        stateOpen(question_id)\r\n        previousBondMustNotBeatMaxPrevious(question_id, max_previous)\r\n    external {\r\n        require(questions[question_id].finalize_ts > UNANSWERED, \"Question must already have an answer when arbitration is requested\");\r\n        questions[question_id].is_pending_arbitration = true;\r\n        emit LogNotifyOfArbitrationRequest(question_id, requester);\r\n    }\r\n\r\n    /// @notice Cancel a previously-requested arbitration and extend the timeout\r\n    /// @dev Useful when doing arbitration across chains that can't be requested atomically\r\n    /// @param question_id The ID of the question\r\n    function cancelArbitration(bytes32 question_id) \r\n        onlyArbitrator(question_id)\r\n        statePendingArbitration(question_id)\r\n    external {\r\n        questions[question_id].is_pending_arbitration = false;\r\n        questions[question_id].finalize_ts = uint32(block.timestamp) + questions[question_id].timeout;\r\n        emit LogCancelArbitration(question_id);\r\n    }\r\n\r\n    /// @notice Submit the answer for a question, for use by the arbitrator.\r\n    /// @dev Doesn't require (or allow) a bond.\r\n    /// If the current final answer is correct, the account should be whoever submitted it.\r\n    /// If the current final answer is wrong, the account should be whoever paid for arbitration.\r\n    /// However, the answerer stipulations are not enforced by the contract.\r\n    /// @param question_id The ID of the question\r\n    /// @param answer The answer, encoded into bytes32\r\n    /// @param answerer The account credited with this answer for the purpose of bond claims\r\n    function submitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address answerer) \r\n        onlyArbitrator(question_id)\r\n        statePendingArbitration(question_id)\r\n    public {\r\n\r\n        require(answerer != NULL_ADDRESS, \"answerer must be provided\");\r\n        emit LogFinalize(question_id, answer);\r\n\r\n        questions[question_id].is_pending_arbitration = false;\r\n        _addAnswerToHistory(question_id, answer, answerer, 0, false);\r\n        _updateCurrentAnswerByArbitrator(question_id, answer);\r\n\r\n    }\r\n\r\n    /// @notice Submit the answer for a question, for use by the arbitrator, working out the appropriate winner based on the last answer details.\r\n    /// @dev Doesn't require (or allow) a bond.\r\n    /// @param question_id The ID of the question\r\n    /// @param answer The answer, encoded into bytes32\r\n    /// @param payee_if_wrong The account to by credited as winner if the last answer given is wrong, usually the account that paid the arbitrator\r\n    /// @param last_history_hash The history hash before the final one\r\n    /// @param last_answer_or_commitment_id The last answer given, or the commitment ID if it was a commitment.\r\n    /// @param last_answerer The address that supplied the last answer\r\n    function assignWinnerAndSubmitAnswerByArbitrator(bytes32 question_id, bytes32 answer, address payee_if_wrong, bytes32 last_history_hash, bytes32 last_answer_or_commitment_id, address last_answerer) \r\n    external {\r\n        bool is_commitment = _verifyHistoryInputOrRevert(questions[question_id].history_hash, last_history_hash, last_answer_or_commitment_id, questions[question_id].bond, last_answerer);\r\n\r\n        address payee;\r\n        // If the last answer is an unrevealed commit, it's always wrong.\r\n        // For anything else, the last answer was set as the \"best answer\" in submitAnswer or submitAnswerReveal.\r\n        if (is_commitment && !commitments[last_answer_or_commitment_id].is_revealed) {\r\n            require(commitments[last_answer_or_commitment_id].reveal_ts < uint32(block.timestamp), \"You must wait for the reveal deadline before finalizing\");\r\n            payee = payee_if_wrong;\r\n        } else {\r\n            payee = (questions[question_id].best_answer == answer) ? last_answerer : payee_if_wrong;\r\n        }\r\n        submitAnswerByArbitrator(question_id, answer, payee);\r\n    }\r\n\r\n\r\n    /// @notice Report whether the answer to the specified question is finalized\r\n    /// @param question_id The ID of the question\r\n    /// @return Return true if finalized\r\n    function isFinalized(bytes32 question_id) \r\n    view public returns (bool) {\r\n        uint32 finalize_ts = questions[question_id].finalize_ts;\r\n        return ( !questions[question_id].is_pending_arbitration && (finalize_ts > UNANSWERED) && (finalize_ts <= uint32(block.timestamp)) );\r\n    }\r\n\r\n    /// @notice (Deprecated) Return the final answer to the specified question, or revert if there isn't one\r\n    /// @param question_id The ID of the question\r\n    /// @return The answer formatted as a bytes32\r\n    function getFinalAnswer(bytes32 question_id) \r\n        stateFinalized(question_id)\r\n    external view returns (bytes32) {\r\n        return questions[question_id].best_answer;\r\n    }\r\n\r\n    /// @notice Return the final answer to the specified question, or revert if there isn't one\r\n    /// @param question_id The ID of the question\r\n    /// @return The answer formatted as a bytes32\r\n    function resultFor(bytes32 question_id) \r\n        stateFinalized(question_id)\r\n    public view returns (bytes32) {\r\n        return questions[question_id].best_answer;\r\n    }\r\n\r\n    /// @notice Returns whether the question was answered before it had an answer, ie resolved to UNRESOLVED_ANSWER\r\n    /// @param question_id The ID of the question \r\n    function isSettledTooSoon(bytes32 question_id)\r\n    public view returns(bool) {\r\n        return (resultFor(question_id) == UNRESOLVED_ANSWER);\r\n    }\r\n\r\n    /// @notice Like resultFor(), but errors out if settled too soon, or returns the result of a replacement if it was reopened at the right time and settled\r\n    /// @param question_id The ID of the question \r\n    function resultForOnceSettled(bytes32 question_id)\r\n    external view returns(bytes32) {\r\n        bytes32 result = resultFor(question_id);\r\n        if (result == UNRESOLVED_ANSWER) {\r\n            // Try the replacement\r\n            bytes32 replacement_id = reopened_questions[question_id];\r\n            require(replacement_id != bytes32(0x0), \"Question was settled too soon and has not been reopened\");\r\n            // We only try one layer down rather than recursing to keep the gas costs predictable\r\n            result = resultFor(replacement_id);\r\n            require(result != UNRESOLVED_ANSWER, \"Question replacement was settled too soon and has not been reopened\");\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /// @notice Asks a new question reopening a previously-asked question that was settled too soon\r\n    /// @dev A special version of askQuestion() that replaces a previous question that was settled too soon\r\n    /// @param template_id The ID number of the template the question will use\r\n    /// @param question A string containing the parameters that will be passed into the template to make the question\r\n    /// @param arbitrator The arbitration contract that will have the final word on the answer if there is a dispute\r\n    /// @param timeout How long the contract should wait after the answer is changed before finalizing on that answer\r\n    /// @param opening_ts If set, the earliest time it should be possible to answer the question.\r\n    /// @param nonce A user-specified nonce used in the question ID. Change it to repeat a question.\r\n    /// @param min_bond The minimum bond that can be used to provide the first answer.\r\n    /// @param reopens_question_id The ID of the question this reopens\r\n    /// @return The ID of the newly-created question, created deterministically.\r\n    function reopenQuestion(uint256 template_id, string memory question, address arbitrator, uint32 timeout, uint32 opening_ts, uint256 nonce, uint256 min_bond, bytes32 reopens_question_id)\r\n        // stateNotCreated is enforced by the internal _askQuestion\r\n    public payable returns (bytes32) {\r\n\r\n        require(isSettledTooSoon(reopens_question_id), \"You can only reopen questions that resolved as settled too soon\");\r\n\r\n        bytes32 content_hash = keccak256(abi.encodePacked(template_id, opening_ts, question));\r\n\r\n        // A reopening must exactly match the original question, except for the nonce and the creator\r\n        require(content_hash == questions[reopens_question_id].content_hash, \"content hash mismatch\");\r\n        require(arbitrator == questions[reopens_question_id].arbitrator, \"arbitrator mismatch\");\r\n        require(timeout == questions[reopens_question_id].timeout, \"timeout mismatch\");\r\n        require(opening_ts == questions[reopens_question_id].opening_ts , \"opening_ts mismatch\");\r\n        require(min_bond == questions[reopens_question_id].min_bond, \"min_bond mismatch\");\r\n\r\n        // If the the question was itself reopening some previous question, you'll have to re-reopen the previous question first.\r\n        // This ensures the bounty can be passed on to the next attempt of the original question.\r\n        require(!reopener_questions[reopens_question_id], \"Question is already reopening a previous question\");\r\n\r\n        // A question can only be reopened once, unless the reopening was also settled too soon in which case it can be replaced\r\n        bytes32 existing_reopen_question_id = reopened_questions[reopens_question_id];\r\n\r\n        // Normally when we reopen a question we will take its bounty and pass it on to the reopened version.\r\n        bytes32 take_bounty_from_question_id = reopens_question_id;\r\n        // If the question has already been reopened but was again settled too soon, we can transfer its bounty to the next attempt.\r\n        if (existing_reopen_question_id != bytes32(0)) {\r\n            require(isSettledTooSoon(existing_reopen_question_id), \"Question has already been reopened\");\r\n            // We'll overwrite the reopening with our new question and move the bounty.\r\n            // Once that's done we'll detach the failed reopener and you'll be able to reopen that too if you really want, but without the bounty.\r\n            reopener_questions[existing_reopen_question_id] = false;\r\n            take_bounty_from_question_id = existing_reopen_question_id;\r\n        }\r\n\r\n        bytes32 question_id = askQuestionWithMinBond(template_id, question, arbitrator, timeout, opening_ts, nonce, min_bond);\r\n\r\n        reopened_questions[reopens_question_id] = question_id;\r\n        reopener_questions[question_id] = true;\r\n\r\n        questions[question_id].bounty = questions[take_bounty_from_question_id].bounty + questions[question_id].bounty;\r\n        questions[take_bounty_from_question_id].bounty = 0;\r\n\r\n        emit LogReopenQuestion(question_id, reopens_question_id);\r\n\r\n        return question_id;\r\n    }\r\n\r\n    /// @notice Return the final answer to the specified question, provided it matches the specified criteria.\r\n    /// @dev Reverts if the question is not finalized, or if it does not match the specified criteria.\r\n    /// @param question_id The ID of the question\r\n    /// @param content_hash The hash of the question content (template ID + opening time + question parameter string)\r\n    /// @param arbitrator The arbitrator chosen for the question (regardless of whether they are asked to arbitrate)\r\n    /// @param min_timeout The timeout set in the initial question settings must be this high or higher\r\n    /// @param min_bond The bond sent with the final answer must be this high or higher\r\n    /// @return The answer formatted as a bytes32\r\n    function getFinalAnswerIfMatches(\r\n        bytes32 question_id, \r\n        bytes32 content_hash, address arbitrator, uint32 min_timeout, uint256 min_bond\r\n    ) \r\n        stateFinalized(question_id)\r\n    external view returns (bytes32) {\r\n        require(content_hash == questions[question_id].content_hash, \"content hash must match\");\r\n        require(arbitrator == questions[question_id].arbitrator, \"arbitrator must match\");\r\n        require(min_timeout <= questions[question_id].timeout, \"timeout must be long enough\");\r\n        require(min_bond <= questions[question_id].bond, \"bond must be high enough\");\r\n        return questions[question_id].best_answer;\r\n    }\r\n\r\n    /// @notice Assigns the winnings (bounty and bonds) to everyone who gave the accepted answer\r\n    /// Caller must provide the answer history, in reverse order\r\n    /// @dev Works up the chain and assign bonds to the person who gave the right answer\r\n    /// If someone gave the winning answer earlier, they must get paid from the higher bond\r\n    /// That means we can't pay out the bond added at n until we have looked at n-1\r\n    /// The first answer is authenticated by checking against the stored history_hash.\r\n    /// One of the inputs to history_hash is the history_hash before it, so we use that to authenticate the next entry, etc\r\n    /// Once we get to a null hash we'll know we're done and there are no more answers.\r\n    /// Usually you would call the whole thing in a single transaction, but if not then the data is persisted to pick up later.\r\n    /// @param question_id The ID of the question\r\n    /// @param history_hashes Second-last-to-first, the hash of each history entry. (Final one should be empty).\r\n    /// @param addrs Last-to-first, the address of each answerer or commitment sender\r\n    /// @param bonds Last-to-first, the bond supplied with each answer or commitment\r\n    /// @param answers Last-to-first, each answer supplied, or commitment ID if the answer was supplied with commit->reveal\r\n    function claimWinnings(\r\n        bytes32 question_id, \r\n        bytes32[] memory history_hashes, address[] memory addrs, uint256[] memory bonds, bytes32[] memory answers\r\n    ) \r\n        stateFinalized(question_id)\r\n    public {\r\n\r\n        require(history_hashes.length > 0, \"at least one history hash entry must be provided\");\r\n\r\n        // These are only set if we split our claim over multiple transactions.\r\n        address payee = question_claims[question_id].payee; \r\n        uint256 last_bond = question_claims[question_id].last_bond; \r\n        uint256 queued_funds = question_claims[question_id].queued_funds; \r\n\r\n        // Starts as the hash of the final answer submitted. It'll be cleared when we're done.\r\n        // If we're splitting the claim over multiple transactions, it'll be the hash where we left off last time\r\n        bytes32 last_history_hash = questions[question_id].history_hash;\r\n\r\n        bytes32 best_answer = questions[question_id].best_answer;\r\n\r\n        uint256 i;\r\n        for (i = 0; i < history_hashes.length; i++) {\r\n        \r\n            // Check input against the history hash, and see which of 2 possible values of is_commitment fits.\r\n            bool is_commitment = _verifyHistoryInputOrRevert(last_history_hash, history_hashes[i], answers[i], bonds[i], addrs[i]);\r\n            \r\n            queued_funds = queued_funds + last_bond; \r\n            (queued_funds, payee) = _processHistoryItem(\r\n                question_id, best_answer, queued_funds, payee, \r\n                addrs[i], bonds[i], answers[i], is_commitment);\r\n \r\n            // Line the bond up for next time, when it will be added to somebody's queued_funds\r\n            last_bond = bonds[i];\r\n\r\n            // Burn (just leave in contract balance) a fraction of all bonds except the final one.\r\n            // This creates a cost to increasing your own bond, which could be used to delay resolution maliciously\r\n            if (last_bond != questions[question_id].bond) {\r\n                last_bond = last_bond - last_bond / BOND_CLAIM_FEE_PROPORTION;\r\n            }\r\n\r\n            last_history_hash = history_hashes[i];\r\n\r\n        }\r\n \r\n        if (last_history_hash != NULL_HASH) {\r\n            // We haven't yet got to the null hash (1st answer), ie the caller didn't supply the full answer chain.\r\n            // Persist the details so we can pick up later where we left off later.\r\n\r\n            // If we know who to pay we can go ahead and pay them out, only keeping back last_bond\r\n            // (We always know who to pay unless all we saw were unrevealed commits)\r\n            if (payee != NULL_ADDRESS) {\r\n                _payPayee(question_id, payee, queued_funds);\r\n                queued_funds = 0;\r\n            }\r\n\r\n            question_claims[question_id].payee = payee;\r\n            question_claims[question_id].last_bond = last_bond;\r\n            question_claims[question_id].queued_funds = queued_funds;\r\n        } else {\r\n            // There is nothing left below us so the payee can keep what remains\r\n            _payPayee(question_id, payee, queued_funds + last_bond);\r\n            delete question_claims[question_id];\r\n        }\r\n\r\n        questions[question_id].history_hash = last_history_hash;\r\n\r\n    }\r\n\r\n    function _payPayee(bytes32 question_id, address payee, uint256 value) \r\n    internal {\r\n        balanceOf[payee] = balanceOf[payee] + value;\r\n        emit LogClaim(question_id, payee, value);\r\n    }\r\n\r\n    function _verifyHistoryInputOrRevert(\r\n        bytes32 last_history_hash,\r\n        bytes32 history_hash, bytes32 answer, uint256 bond, address addr\r\n    )\r\n    internal pure returns (bool) {\r\n        if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, true)) ) {\r\n            return true;\r\n        }\r\n        if (last_history_hash == keccak256(abi.encodePacked(history_hash, answer, bond, addr, false)) ) {\r\n            return false;\r\n        } \r\n        revert(\"History input provided did not match the expected hash\");\r\n    }\r\n\r\n    function _processHistoryItem(\r\n        bytes32 question_id, bytes32 best_answer, \r\n        uint256 queued_funds, address payee, \r\n        address addr, uint256 bond, bytes32 answer, bool is_commitment\r\n    )\r\n    internal returns (uint256, address) {\r\n\r\n        // For commit-and-reveal, the answer history holds the commitment ID instead of the answer.\r\n        // We look at the referenced commitment ID and switch in the actual answer.\r\n        if (is_commitment) {\r\n            bytes32 commitment_id = answer;\r\n            // If it's a commit but it hasn't been revealed, it will always be considered wrong.\r\n            if (!commitments[commitment_id].is_revealed) {\r\n                delete commitments[commitment_id];\r\n                return (queued_funds, payee);\r\n            } else {\r\n                answer = commitments[commitment_id].revealed_answer;\r\n                delete commitments[commitment_id];\r\n            }\r\n        }\r\n\r\n        if (answer == best_answer) {\r\n\r\n            if (payee == NULL_ADDRESS) {\r\n\r\n                // The entry is for the first payee we come to, ie the winner.\r\n                // They get the question bounty.\r\n                payee = addr;\r\n\r\n                if (best_answer != UNRESOLVED_ANSWER && questions[question_id].bounty > 0) {\r\n                    _payPayee(question_id, payee, questions[question_id].bounty);\r\n                    questions[question_id].bounty = 0;\r\n                }\r\n\r\n            } else if (addr != payee) {\r\n\r\n                // Answerer has changed, ie we found someone lower down who needs to be paid\r\n\r\n                // The lower answerer will take over receiving bonds from higher answerer.\r\n                // They should also be paid the takeover fee, which is set at a rate equivalent to their bond. \r\n                // (This is our arbitrary rule, to give consistent right-answerers a defence against high-rollers.)\r\n\r\n                // There should be enough for the fee, but if not, take what we have.\r\n                // There's an edge case involving weird arbitrator behaviour where we may be short.\r\n                uint256 answer_takeover_fee = (queued_funds >= bond) ? bond : queued_funds;\r\n                // Settle up with the old (higher-bonded) payee\r\n                _payPayee(question_id, payee, queued_funds - answer_takeover_fee);\r\n\r\n                // Now start queued_funds again for the new (lower-bonded) payee\r\n                payee = addr;\r\n                queued_funds = answer_takeover_fee;\r\n\r\n            }\r\n\r\n        }\r\n\r\n        return (queued_funds, payee);\r\n\r\n    }\r\n\r\n    /// @notice Convenience function to assign bounties/bonds for multiple questions in one go, then withdraw all your funds.\r\n    /// Caller must provide the answer history for each question, in reverse order\r\n    /// @dev Can be called by anyone to assign bonds/bounties, but funds are only withdrawn for the user making the call.\r\n    /// @param question_ids The IDs of the questions you want to claim for\r\n    /// @param lengths The number of history entries you will supply for each question ID\r\n    /// @param hist_hashes In a single list for all supplied questions, the hash of each history entry.\r\n    /// @param addrs In a single list for all supplied questions, the address of each answerer or commitment sender\r\n    /// @param bonds In a single list for all supplied questions, the bond supplied with each answer or commitment\r\n    /// @param answers In a single list for all supplied questions, each answer supplied, or commitment ID \r\n    function claimMultipleAndWithdrawBalance(\r\n        bytes32[] memory question_ids, uint256[] memory lengths, \r\n        bytes32[] memory hist_hashes, address[] memory addrs, uint256[] memory bonds, bytes32[] memory answers\r\n    ) \r\n        stateAny() // The finalization checks are done in the claimWinnings function\r\n    public {\r\n        \r\n        uint256 qi;\r\n        uint256 i;\r\n        for (qi = 0; qi < question_ids.length; qi++) {\r\n            bytes32 qid = question_ids[qi];\r\n            uint256 ln = lengths[qi];\r\n            bytes32[] memory hh = new bytes32[](ln);\r\n            address[] memory ad = new address[](ln);\r\n            uint256[] memory bo = new uint256[](ln);\r\n            bytes32[] memory an = new bytes32[](ln);\r\n            uint256 j;\r\n            for (j = 0; j < ln; j++) {\r\n                hh[j] = hist_hashes[i];\r\n                ad[j] = addrs[i];\r\n                bo[j] = bonds[i];\r\n                an[j] = answers[i];\r\n                i++;\r\n            }\r\n            claimWinnings(qid, hh, ad, bo, an);\r\n        }\r\n        withdraw();\r\n    }\r\n\r\n    /// @notice Returns the questions's content hash, identifying the question content\r\n    /// @param question_id The ID of the question \r\n    function getContentHash(bytes32 question_id) \r\n    public view returns(bytes32) {\r\n        return questions[question_id].content_hash;\r\n    }\r\n\r\n    /// @notice Returns the arbitrator address for the question\r\n    /// @param question_id The ID of the question \r\n    function getArbitrator(bytes32 question_id) \r\n    public view returns(address) {\r\n        return questions[question_id].arbitrator;\r\n    }\r\n\r\n    /// @notice Returns the timestamp when the question can first be answered\r\n    /// @param question_id The ID of the question \r\n    function getOpeningTS(bytes32 question_id) \r\n    public view returns(uint32) {\r\n        return questions[question_id].opening_ts;\r\n    }\r\n\r\n    /// @notice Returns the timeout in seconds used after each answer\r\n    /// @param question_id The ID of the question \r\n    function getTimeout(bytes32 question_id) \r\n    public view returns(uint32) {\r\n        return questions[question_id].timeout;\r\n    }\r\n\r\n    /// @notice Returns the timestamp at which the question will be/was finalized\r\n    /// @param question_id The ID of the question \r\n    function getFinalizeTS(bytes32 question_id) \r\n    public view returns(uint32) {\r\n        return questions[question_id].finalize_ts;\r\n    }\r\n\r\n    /// @notice Returns whether the question is pending arbitration\r\n    /// @param question_id The ID of the question \r\n    function isPendingArbitration(bytes32 question_id) \r\n    public view returns(bool) {\r\n        return questions[question_id].is_pending_arbitration;\r\n    }\r\n\r\n    /// @notice Returns the current total unclaimed bounty\r\n    /// @dev Set back to zero once the bounty has been claimed\r\n    /// @param question_id The ID of the question \r\n    function getBounty(bytes32 question_id) \r\n    public view returns(uint256) {\r\n        return questions[question_id].bounty;\r\n    }\r\n\r\n    /// @notice Returns the current best answer\r\n    /// @param question_id The ID of the question \r\n    function getBestAnswer(bytes32 question_id) \r\n    public view returns(bytes32) {\r\n        return questions[question_id].best_answer;\r\n    }\r\n\r\n    /// @notice Returns the history hash of the question \r\n    /// @param question_id The ID of the question \r\n    /// @dev Updated on each answer, then rewound as each is claimed\r\n    function getHistoryHash(bytes32 question_id) \r\n    public view returns(bytes32) {\r\n        return questions[question_id].history_hash;\r\n    }\r\n\r\n    /// @notice Returns the highest bond posted so far for a question\r\n    /// @param question_id The ID of the question \r\n    function getBond(bytes32 question_id) \r\n    public view returns(uint256) {\r\n        return questions[question_id].bond;\r\n    }\r\n\r\n    /// @notice Returns the minimum bond that can answer the question\r\n    /// @param question_id The ID of the question\r\n    function getMinBond(bytes32 question_id)\r\n    public view returns(uint256) {\r\n        return questions[question_id].min_bond;\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"answer_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"}],\"name\":\"LogAnswerReveal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"LogCancelArbitration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"}],\"name\":\"LogFinalize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bounty_added\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogFundAnswerBounty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"}],\"name\":\"LogMinimumBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"history_hash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"is_commitment\",\"type\":\"bool\"}],\"name\":\"LogNewAnswer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"content_hash\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"created\",\"type\":\"uint256\"}],\"name\":\"LogNewQuestion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"question_text\",\"type\":\"string\"}],\"name\":\"LogNewTemplate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"LogNotifyOfArbitrationRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"reopened_question_id\",\"type\":\"bytes32\"}],\"name\":\"LogReopenQuestion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogSetQuestionFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"arbitrator_question_fees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"askQuestion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"}],\"name\":\"askQuestionWithMinBond\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"payee_if_wrong\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"last_history_hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"last_answer_or_commitment_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"last_answerer\",\"type\":\"address\"}],\"name\":\"assignWinnerAndSubmitAnswerByArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"cancelArbitration\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"question_ids\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256[]\",\"name\":\"lengths\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"hist_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bonds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"answers\",\"type\":\"bytes32[]\"}],\"name\":\"claimMultipleAndWithdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32[]\",\"name\":\"history_hashes\",\"type\":\"bytes32[]\"},{\"internalType\":\"address[]\",\"name\":\"addrs\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"bonds\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32[]\",\"name\":\"answers\",\"type\":\"bytes32[]\"}],\"name\":\"claimWinnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"commitments\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"reveal_ts\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"is_revealed\",\"type\":\"bool\"},{\"internalType\":\"bytes32\",\"name\":\"revealed_answer\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"content\",\"type\":\"string\"}],\"name\":\"createTemplate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"content\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"createTemplateAndAskQuestion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"fundAnswerBounty\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getArbitrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getBestAnswer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getBounty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getContentHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getFinalAnswer\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"content_hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"min_timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"}],\"name\":\"getFinalAnswerIfMatches\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getFinalizeTS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getHistoryHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getMinBond\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getOpeningTS\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"getTimeout\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"isFinalized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"isPendingArbitration\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"isSettledTooSoon\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"requester\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"max_previous\",\"type\":\"uint256\"}],\"name\":\"notifyOfArbitrationRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"question_claims\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"last_bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"queued_funds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"questions\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"content_hash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"finalize_ts\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"is_pending_arbitration\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"bounty\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"best_answer\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"history_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"template_id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"question\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"arbitrator\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"timeout\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"opening_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"min_bond\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"reopens_question_id\",\"type\":\"bytes32\"}],\"name\":\"reopenQuestion\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"reopened_questions\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"reopener_questions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"resultFor\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"}],\"name\":\"resultForOnceSettled\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setQuestionFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"max_previous\",\"type\":\"uint256\"}],\"name\":\"submitAnswer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"}],\"name\":\"submitAnswerByArbitrator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer_hash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"max_previous\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_answerer\",\"type\":\"address\"}],\"name\":\"submitAnswerCommitment\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"max_previous\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"answerer\",\"type\":\"address\"}],\"name\":\"submitAnswerFor\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"question_id\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"answer\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bond\",\"type\":\"uint256\"}],\"name\":\"submitAnswerReveal\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"template_hashes\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"templates\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RealityETH_v3_0", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://05531d2892fcdeb48472a864e59887b41c9670a9e5c69b4cabf85caa744b2557"}