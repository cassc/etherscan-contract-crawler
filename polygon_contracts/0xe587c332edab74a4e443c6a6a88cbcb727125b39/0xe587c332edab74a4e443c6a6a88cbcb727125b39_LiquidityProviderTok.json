{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"Constants.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @dev See GOVERNANCE.md for descriptions of fixed parameters and fees\\n */\\n\\nlibrary Constants {\\n  // 100 basis points/percent * 100 percent/total\\n  uint64 public constant basisPointsInTotal = 100 * 100;\\n\\n  uint64 public constant depositIndexNotSet = 2**64 - 1;\\n\\n  uint8 public constant liquidityProviderTokenDecimals = 18;\\n\\n  // 1 week at 3s/block\\n  uint256 public constant maxChainPropagationPeriod = (7 * 24 * 60 * 60) / 3;\\n\\n  // 20%\\n  uint64 public constant maxFeeBasisPoints = 20 * 100;\\n\\n  // Pool reserve balance ratio above which price dips below 1 pip and can no longer be represented\\n  uint64 public constant maxLiquidityPoolReserveRatio = 10**8;\\n\\n  // Pool reserve balance below which prices can no longer be represented with full pip precision\\n  uint64 public constant minLiquidityPoolReserveInPips = 10**8;\\n\\n  // 2%\\n  uint64 public constant maxPoolInputFeeBasisPoints = 2 * 100;\\n\\n  // 5%\\n  uint64 public constant maxPoolOutputAdjustmentBasisPoints = 5 * 100;\\n\\n  // 1%\\n  uint64 public constant maxPoolPriceCorrectionBasisPoints = 1 * 100;\\n\\n  // To convert integer pips to a fractional price shift decimal left by the pip precision of 8\\n  // decimals places\\n  uint64 public constant pipPriceMultiplier = 10**8;\\n\\n  uint8 public constant signatureHashVersion = 3;\\n}\\n\"\r\n    },\r\n    \"Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./IERC20Metadata.sol\\\";\\nimport \\\"./Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The defaut value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n\\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\\n        require(currentAllowance >= amount, \\\"ERC20: transfer amount exceeds allowance\\\");\\n        _approve(sender, _msgSender(), currentAllowance - amount);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        _approve(_msgSender(), spender, currentAllowance - subtractedValue);\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        uint256 senderBalance = _balances[sender];\\n        require(senderBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[sender] = senderBalance - amount;\\n        _balances[recipient] += amount;\\n\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _balances[account] = accountBalance - amount;\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\"\r\n    },\r\n    \"Enums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.8.4;\\n\\n/**\\n * @notice Enums definitions\\n */\\n\\n// Liquidity pools //\\n\\nenum LiquidityChangeOrigination { OnChain, OffChain }\\n\\nenum LiquidityChangeType { Addition, Removal }\\n\\nenum LiquidityChangeState { NotInitiated, Initiated, Executed }\\n\\n// Order book //\\n\\nenum OrderSelfTradePrevention {\\n  // Decrement and cancel\\n  dc,\\n  // Cancel oldest\\n  co,\\n  // Cancel newest\\n  cn,\\n  // Cancel both\\n  cb\\n}\\n\\nenum OrderSide { Buy, Sell }\\n\\nenum OrderTimeInForce {\\n  // Good until cancelled\\n  gtc,\\n  // Good until time\\n  gtt,\\n  // Immediate or cancel\\n  ioc,\\n  // Fill or kill\\n  fok\\n}\\n\\nenum OrderType {\\n  Market,\\n  Limit,\\n  LimitMaker,\\n  StopLoss,\\n  StopLossLimit,\\n  TakeProfit,\\n  TakeProfitLimit\\n}\\n\\n// Withdrawals //\\n\\nenum WithdrawalType { BySymbol, ByAddress }\\n\"\r\n    },\r\n    \"IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"Interfaces.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.8.4;\\n\\nimport { Order, OrderBookTrade, Withdrawal } from './Structs.sol';\\n\\n/**\\n * @notice Interface of the ERC20 standard as defined in the EIP, but with no return values for\\n * transfer and transferFrom. By asserting expected balance changes when calling these two methods\\n * we can safely ignore their return values. This allows support of non-compliant tokens that do not\\n * return a boolean. See https://github.com/ethereum/solidity/issues/4116\\n */\\ninterface IERC20 {\\n  /**\\n   * @notice Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint256);\\n\\n  /**\\n   * @notice Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\\n   * we ignore this and rely on asserting balance changes instead\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint256 amount) external;\\n\\n  /**\\n   * @notice Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender)\\n    external\\n    view\\n    returns (uint256);\\n\\n  /**\\n   * @notice Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint256 amount) external returns (bool);\\n\\n  /**\\n   * @notice Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Most implementing contracts return a boolean value indicating whether the operation succeeded, but\\n   * we ignore this and rely on asserting balance changes instead\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint256 amount\\n  ) external;\\n\\n  /**\\n   * @notice Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n  /**\\n   * @notice Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @notice Interface to Custodian contract. Used by Exchange and Governance contracts for internal\\n * delegate calls\\n */\\ninterface ICustodian {\\n  /**\\n   * @notice ETH can only be sent by the Exchange\\n   */\\n  receive() external payable;\\n\\n  /**\\n   * @notice Withdraw any asset and amount to a target wallet\\n   *\\n   * @dev No balance checking performed\\n   *\\n   * @param wallet The wallet to which assets will be returned\\n   * @param asset The address of the asset to withdraw (native asset or ERC-20 contract)\\n   * @param quantityInAssetUnits The quantity in asset units to withdraw\\n   */\\n  function withdraw(\\n    address payable wallet,\\n    address asset,\\n    uint256 quantityInAssetUnits\\n  ) external;\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Exchange contract\\n   *\\n   * @return The address of the currently whitelisted Exchange contract\\n   */\\n  function loadExchange() external view returns (address);\\n\\n  /**\\n   * @notice Sets a new Exchange contract address\\n   *\\n   * @param newExchange The address of the new whitelisted Exchange contract\\n   */\\n  function setExchange(address newExchange) external;\\n\\n  /**\\n   * @notice Load address of the currently whitelisted Governance contract\\n   *\\n   * @return The address of the currently whitelisted Governance contract\\n   */\\n  function loadGovernance() external view returns (address);\\n\\n  /**\\n   * @notice Sets a new Governance contract address\\n   *\\n   * @param newGovernance The address of the new whitelisted Governance contract\\n   */\\n  function setGovernance(address newGovernance) external;\\n}\\n\\n/**\\n * @notice Interface to Whistler Exchange contract\\n *\\n * @dev Used for lazy balance migrations from old to new Exchange after upgrade\\n */\\ninterface IExchange {\\n  /**\\n   * @notice Load a wallet's balance by asset address, in pips\\n   *\\n   * @param wallet The wallet address to load the balance for. Can be different from `msg.sender`\\n   * @param assetAddress The asset address to load the wallet's balance for\\n   *\\n   * @return The quantity denominated in pips of asset at `assetAddress` currently deposited by `wallet`\\n   */\\n  function loadBalanceInPipsByAddress(address wallet, address assetAddress)\\n    external\\n    view\\n    returns (uint64);\\n\\n  /**\\n   * @notice Load the address of the Custodian contract\\n   *\\n   * @return The address of the Custodian contract\\n   */\\n  function loadCustodian() external view returns (ICustodian);\\n}\\n\\ninterface ILiquidityProviderToken {\\n  function custodian() external returns (ICustodian);\\n\\n  function baseAssetAddress() external returns (address);\\n\\n  function quoteAssetAddress() external returns (address);\\n\\n  function baseAssetSymbol() external returns (string memory);\\n\\n  function quoteAssetSymbol() external returns (string memory);\\n\\n  function token0() external returns (address);\\n\\n  function token1() external returns (address);\\n\\n  function burn(\\n    address wallet,\\n    uint256 liquidity,\\n    uint256 baseAssetQuantityInAssetUnits,\\n    uint256 quoteAssetQuantityInAssetUnits,\\n    address to\\n  ) external;\\n\\n  function mint(\\n    address wallet,\\n    uint256 liquidity,\\n    uint256 baseAssetQuantityInAssetUnits,\\n    uint256 quoteAssetQuantityInAssetUnits,\\n    address to\\n  ) external;\\n\\n  function reverseAssets() external;\\n}\\n\\ninterface IWETH9 is IERC20 {\\n  receive() external payable;\\n\\n  function deposit() external payable;\\n\\n  function withdraw(uint256 wad) external;\\n}\\n\"\r\n    },\r\n    \"LiquidityProviderToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.8.4;\\n\\nimport { Address } from './Address.sol';\\nimport { ERC20 } from './ERC20.sol';\\n\\nimport { Constants } from './Constants.sol';\\nimport {\\n  ICustodian,\\n  IExchange,\\n  IERC20,\\n  ILiquidityProviderToken\\n} from './Interfaces.sol';\\n\\n/**\\n * @notice Liquidity Provider ERC-20 token contract\\n *\\n * @dev Reference OpenZeppelin implementation with whitelisted minting and burning\\n */\\ncontract LiquidityProviderToken is ERC20, ILiquidityProviderToken {\\n  // Used to whitelist Exchange-only functions by loading address of current Exchange from Custodian\\n  ICustodian public override custodian;\\n\\n  // Base and quote asset addresses provided only for informational purposes\\n  address public override baseAssetAddress;\\n  address public override quoteAssetAddress;\\n  string public override baseAssetSymbol;\\n  string public override quoteAssetSymbol;\\n\\n  /**\\n   * @notice Emitted when the Exchange mints new LP tokens to a wallet via `mint`\\n   */\\n  event Mint(\\n    address indexed sender,\\n    uint256 baseAssetQuantityInAssetUnits,\\n    uint256 quoteAssetQuantityInAssetUnits\\n  );\\n  /**\\n   * @notice Emitted when the Exchange burns a wallet's LP tokens via `burn`\\n   */\\n  event Burn(\\n    address indexed sender,\\n    uint256 baseAssetQuantityInAssetUnits,\\n    uint256 quoteAssetQuantityInAssetUnits,\\n    address indexed to\\n  );\\n\\n  modifier onlyExchange() {\\n    require(msg.sender == custodian.loadExchange(), 'Caller is not Exchange');\\n    _;\\n  }\\n\\n  /**\\n   * @notice Instantiate a new `LiquidityProviderToken` contract\\n   *\\n   * @dev Should be called by the Exchange via a CREATE2 op to generate stable deterministic\\n   * addresses and setup whitelist for `onlyExchange`-restricted functions. Asset addresses and\\n   * symbols are stored for informational purposes\\n   *\\n   * @param _baseAssetAddress The base asset address\\n   * @param _quoteAssetAddress The quote asset address\\n   * @param _baseAssetSymbol The base asset symbol\\n   * @param _quoteAssetSymbol The quote asset symbol\\n   */\\n\\n  constructor(\\n    address _baseAssetAddress,\\n    address _quoteAssetAddress,\\n    string memory _baseAssetSymbol,\\n    string memory _quoteAssetSymbol\\n  ) ERC20('', 'IDEX-LP') {\\n    custodian = IExchange(msg.sender).loadCustodian();\\n    require(address(custodian) != address(0x0), 'Invalid Custodian address');\\n\\n    // Assets cannot be equal\\n    require(\\n      _baseAssetAddress != _quoteAssetAddress,\\n      'Assets must be different'\\n    );\\n\\n    // Each asset must be the native asset or contract\\n    require(\\n      _baseAssetAddress == address(0x0) ||\\n        Address.isContract(_baseAssetAddress),\\n      'Invalid base asset'\\n    );\\n    require(\\n      _quoteAssetAddress == address(0x0) ||\\n        Address.isContract(_quoteAssetAddress),\\n      'Invalid quote asset'\\n    );\\n\\n    baseAssetAddress = _baseAssetAddress;\\n    quoteAssetAddress = _quoteAssetAddress;\\n    baseAssetSymbol = _baseAssetSymbol;\\n    quoteAssetSymbol = _quoteAssetSymbol;\\n  }\\n\\n  /**\\n   * @notice Returns the name of the token\\n   */\\n  function name() public view override returns (string memory) {\\n    return\\n      string(\\n        abi.encodePacked('IDEX LP: ', baseAssetSymbol, '-', quoteAssetSymbol)\\n      );\\n  }\\n\\n  /**\\n   * @notice Returns the address of the base-quote pair asset with the lower sort order\\n   */\\n  function token0() external view override returns (address) {\\n    return\\n      baseAssetAddress < quoteAssetAddress\\n        ? baseAssetAddress\\n        : quoteAssetAddress;\\n  }\\n\\n  /**\\n   * @notice Returns the address of the base-quote pair asset with the higher sort order\\n   */\\n  function token1() external view override returns (address) {\\n    return\\n      baseAssetAddress < quoteAssetAddress\\n        ? quoteAssetAddress\\n        : baseAssetAddress;\\n  }\\n\\n  /**\\n   * @notice Burns LP tokens by removing them from `wallet`'s balance and total supply\\n   */\\n  function burn(\\n    address wallet,\\n    uint256 liquidity,\\n    uint256 baseAssetQuantityInAssetUnits,\\n    uint256 quoteAssetQuantityInAssetUnits,\\n    address to\\n  ) external override onlyExchange {\\n    _burn(address(custodian), liquidity);\\n\\n    emit Burn(\\n      wallet,\\n      baseAssetQuantityInAssetUnits,\\n      quoteAssetQuantityInAssetUnits,\\n      to\\n    );\\n  }\\n\\n  /**\\n   * @notice Mints LP tokens by adding them to `wallet`'s balance and total supply\\n   */\\n  function mint(\\n    address wallet,\\n    uint256 liquidity,\\n    uint256 baseAssetQuantityInAssetUnits,\\n    uint256 quoteAssetQuantityInAssetUnits,\\n    address to\\n  ) external override onlyExchange {\\n    _mint(to, liquidity);\\n\\n    emit Mint(\\n      wallet,\\n      baseAssetQuantityInAssetUnits,\\n      quoteAssetQuantityInAssetUnits\\n    );\\n  }\\n\\n  /**\\n   * @notice Reverses the asset pair represented by this token by swapping `baseAssetAddress` with\\n   * `quoteAssetAddress` and `baseAssetSymbol` with `quoteAssetSymbol`\\n   */\\n  function reverseAssets() external override onlyExchange {\\n    // Assign swapped values to intermediate values first as Solidity won't allow multiple storage\\n    // writes in a single statement\\n    (\\n      address _baseAssetAddress,\\n      address _quoteAssetAddress,\\n      string memory _baseAssetSymbol,\\n      string memory _quoteAssetSymbol\\n    ) =\\n      (quoteAssetAddress, baseAssetAddress, quoteAssetSymbol, baseAssetSymbol);\\n    (baseAssetAddress, quoteAssetAddress, baseAssetSymbol, quoteAssetSymbol) = (\\n      _baseAssetAddress,\\n      _quoteAssetAddress,\\n      _baseAssetSymbol,\\n      _quoteAssetSymbol\\n    );\\n  }\\n}\\n\"\r\n    },\r\n    \"Structs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-only\\n\\npragma solidity 0.8.4;\\n\\nimport { ILiquidityProviderToken, IWETH9 } from './Interfaces.sol';\\nimport {\\n  LiquidityChangeOrigination,\\n  OrderSelfTradePrevention,\\n  OrderSide,\\n  OrderTimeInForce,\\n  OrderType,\\n  WithdrawalType\\n} from './Enums.sol';\\n\\n/**\\n * @notice Struct definitions\\n */\\n\\n/**\\n * @notice State tracking for a hybrid liquidity pool\\n *\\n * @dev Base and quote asset decimals are denormalized here to avoid extra loads from\\n * `AssetRegistry.Storage`\\n */\\nstruct LiquidityPool {\\n  // Flag to distinguish from empty struct\\n  bool exists;\\n  uint64 baseAssetReserveInPips;\\n  uint8 baseAssetDecimals;\\n  uint64 quoteAssetReserveInPips;\\n  uint8 quoteAssetDecimals;\\n  ILiquidityProviderToken liquidityProviderToken;\\n}\\n\\n/**\\n * @dev Internal struct capturing user-initiated liquidity addition request parameters\\n */\\nstruct LiquidityAddition {\\n  // Must equal `Constants.signatureHashVersion`\\n  uint8 signatureHashVersion;\\n  // Distinguishes between liquidity additions initated on- or off- chain\\n  LiquidityChangeOrigination origination;\\n  // UUIDv1 unique to wallet\\n  uint128 nonce;\\n  address wallet;\\n  address assetA;\\n  address assetB;\\n  uint256 amountADesired;\\n  uint256 amountBDesired;\\n  uint256 amountAMin;\\n  uint256 amountBMin;\\n  address to;\\n  uint256 deadline;\\n  bytes signature;\\n}\\n\\n/**\\n * @notice Internally used struct, return type from `LiquidityPools.addLiquidity`\\n */\\nstruct LiquidityAdditionDepositResult {\\n  string assetASymbol;\\n  uint64 assetAQuantityInPips;\\n  uint64 assetANewExchangeBalanceInPips;\\n  uint256 assetANewExchangeBalanceInAssetUnits;\\n  string assetBSymbol;\\n  uint64 assetBQuantityInPips;\\n  uint64 assetBNewExchangeBalanceInPips;\\n  uint256 assetBNewExchangeBalanceInAssetUnits;\\n}\\n\\n/**\\n * @notice Internally used struct, return type from `LiquidityPools.removeLiquidity`\\n */\\nstruct LiquidityRemovalDepositResult {\\n  address assetAddress;\\n  string assetSymbol;\\n  uint64 assetQuantityInPips;\\n  uint64 assetNewExchangeBalanceInPips;\\n  uint256 assetNewExchangeBalanceInAssetUnits;\\n}\\n\\n/**\\n * @dev Internal struct capturing user-initiated liquidity removal request parameters\\n */\\nstruct LiquidityRemoval {\\n  // Must equal `Constants.signatureHashVersion`\\n  uint8 signatureHashVersion;\\n  // Distinguishes between liquidity additions initated on- or off- chain\\n  LiquidityChangeOrigination origination;\\n  uint128 nonce;\\n  address wallet;\\n  address assetA;\\n  address assetB;\\n  uint256 liquidity;\\n  uint256 amountAMin;\\n  uint256 amountBMin;\\n  address payable to;\\n  uint256 deadline;\\n  bytes signature;\\n}\\n\\n/**\\n * @notice Argument type to `Exchange.executeAddLiquidity` and `Exchange.executeRemoveLiquidity`\\n */\\nstruct LiquidityChangeExecution {\\n  address baseAssetAddress;\\n  address quoteAssetAddress;\\n  uint64 liquidityInPips;\\n  // Gross amount including fees of base asset executed\\n  uint64 grossBaseQuantityInPips;\\n  // Gross amount including fees of quote asset executed\\n  uint64 grossQuoteQuantityInPips;\\n  // Net amount of base asset sent to pool for additions or received by wallet for removals\\n  uint64 netBaseQuantityInPips;\\n  // Net amount of quote asset sent to pool for additions or received by wallet for removals\\n  uint64 netQuoteQuantityInPips;\\n}\\n\\n/**\\n * @notice Internally used struct, argument type to `LiquidityPoolAdmin.migrateLiquidityPool`\\n */\\nstruct LiquidityMigration {\\n  address token0;\\n  address token1;\\n  bool isToken1Quote;\\n  uint256 desiredLiquidity;\\n  address to;\\n  IWETH9 WETH;\\n}\\n\\n/**\\n * @notice Internally used struct capturing wallet order nonce invalidations created via `invalidateOrderNonce`\\n */\\nstruct NonceInvalidation {\\n  bool exists;\\n  uint64 timestampInMs;\\n  uint256 effectiveBlockNumber;\\n}\\n\\n/**\\n * @notice Return type for `Exchange.loadAssetBySymbol`, and `Exchange.loadAssetByAddress`; also\\n * used internally by `AssetRegistry`\\n */\\nstruct Asset {\\n  // Flag to distinguish from empty struct\\n  bool exists;\\n  // The asset's address\\n  address assetAddress;\\n  // The asset's symbol\\n  string symbol;\\n  // The asset's decimal precision\\n  uint8 decimals;\\n  // Flag set when asset registration confirmed. Asset deposits, trades, or withdrawals only\\n  // allowed if true\\n  bool isConfirmed;\\n  // Timestamp as ms since Unix epoch when isConfirmed was asserted\\n  uint64 confirmedTimestampInMs;\\n}\\n\\n/**\\n * @notice Argument type for `Exchange.executeOrderBookTrade` and `Hashing.getOrderWalletHash`\\n */\\nstruct Order {\\n  // Must equal `Constants.signatureHashVersion`\\n  uint8 signatureHashVersion;\\n  // UUIDv1 unique to wallet\\n  uint128 nonce;\\n  // Wallet address that placed order and signed hash\\n  address walletAddress;\\n  // Type of order\\n  OrderType orderType;\\n  // Order side wallet is on\\n  OrderSide side;\\n  // Order quantity in base or quote asset terms depending on isQuantityInQuote flag\\n  uint64 quantityInPips;\\n  // Is quantityInPips in quote terms\\n  bool isQuantityInQuote;\\n  // For limit orders, price in decimal pips * 10^8 in quote terms\\n  uint64 limitPriceInPips;\\n  // For stop orders, stop loss or take profit price in decimal pips * 10^8 in quote terms\\n  uint64 stopPriceInPips;\\n  // Optional custom client order ID\\n  string clientOrderId;\\n  // TIF option specified by wallet for order\\n  OrderTimeInForce timeInForce;\\n  // STP behavior specified by wallet for order\\n  OrderSelfTradePrevention selfTradePrevention;\\n  // Cancellation time specified by wallet for GTT TIF order\\n  uint64 cancelAfter;\\n  // The ECDSA signature of the order hash as produced by Hashing.getOrderWalletHash\\n  bytes walletSignature;\\n}\\n\\n/**\\n * @notice Argument type for `Exchange.executeOrderBookTrade` specifying execution parameters for matching orders\\n */\\nstruct OrderBookTrade {\\n  // Base asset symbol\\n  string baseAssetSymbol;\\n  // Quote asset symbol\\n  string quoteAssetSymbol;\\n  // Base asset address\\n  address baseAssetAddress;\\n  // Quote asset address\\n  address quoteAssetAddress;\\n  // Gross amount including fees of base asset executed\\n  uint64 grossBaseQuantityInPips;\\n  // Gross amount including fees of quote asset executed\\n  uint64 grossQuoteQuantityInPips;\\n  // Net amount of base asset received by buy side wallet after fees\\n  uint64 netBaseQuantityInPips;\\n  // Net amount of quote asset received by sell side wallet after fees\\n  uint64 netQuoteQuantityInPips;\\n  // Asset address for liquidity maker's fee\\n  address makerFeeAssetAddress;\\n  // Asset address for liquidity taker's fee\\n  address takerFeeAssetAddress;\\n  // Fee paid by liquidity maker\\n  uint64 makerFeeQuantityInPips;\\n  // Fee paid by liquidity taker, inclusive of gas fees\\n  uint64 takerFeeQuantityInPips;\\n  // Execution price of trade in decimal pips * 10^8 in quote terms\\n  uint64 priceInPips;\\n  // Which side of the order (buy or sell) the liquidity maker was on\\n  OrderSide makerSide;\\n}\\n\\n/**\\n * @notice Argument type for `Exchange.executePoolTrade` specifying execution parameters for an\\n * order against pool liquidity\\n */\\nstruct PoolTrade {\\n  // Base asset symbol\\n  string baseAssetSymbol;\\n  // Quote asset symbol\\n  string quoteAssetSymbol;\\n  // Base asset address\\n  address baseAssetAddress;\\n  // Quote asset address\\n  address quoteAssetAddress;\\n  // Gross amount including fees of base asset executed\\n  uint64 grossBaseQuantityInPips;\\n  // Gross amount including fees of quote asset executed\\n  uint64 grossQuoteQuantityInPips;\\n  // If wallet is buy side, net amount of quote input to pool used to calculate output; otherwise,\\n  // net amount of base asset leaving pool\\n  uint64 netBaseQuantityInPips;\\n  // If wallet is buy side, net amount of base input to pool used to calculate output; otherwise,\\n  // net amount of quote asset leaving pool\\n  uint64 netQuoteQuantityInPips;\\n  // Fee paid by liquidity taker to pool from sent asset\\n  uint64 takerPoolFeeQuantityInPips;\\n  // Fee paid by liquidity taker to fee wallet from sent asset\\n  uint64 takerProtocolFeeQuantityInPips;\\n  // Fee paid by liquidity taker to fee wallet from received asset\\n  uint64 takerGasFeeQuantityInPips;\\n  // Fee paid by liquidity taker sell to pool taken from pool's quote asset output\\n  uint64 takerPriceCorrectionFeeQuantityInPips;\\n}\\n\\nstruct HybridTrade {\\n  OrderBookTrade orderBookTrade;\\n  PoolTrade poolTrade;\\n  // Fee paid by liquidity taker to fee wallet from received asset\\n  uint64 takerGasFeeQuantityInPips;\\n}\\n\\n/**\\n * @notice Argument type for `Exchange.withdraw` and `Hashing.getWithdrawalWalletHash`\\n */\\nstruct Withdrawal {\\n  // Distinguishes between withdrawals by asset symbol or address\\n  WithdrawalType withdrawalType;\\n  // UUIDv1 unique to wallet\\n  uint128 nonce;\\n  // Address of wallet to which funds will be returned\\n  address payable walletAddress;\\n  // Asset symbol\\n  string assetSymbol;\\n  // Asset address\\n  address assetAddress; // Used when assetSymbol not specified\\n  // Withdrawal quantity\\n  uint64 grossQuantityInPips;\\n  // Gas fee deducted from withdrawn quantity to cover dispatcher tx costs\\n  uint64 gasFeeInPips;\\n  // Not currently used but reserved for future use. Must be true\\n  bool autoDispatchEnabled;\\n  // The ECDSA signature of the withdrawal hash as produced by Hashing.getWithdrawalWalletHash\\n  bytes walletSignature;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1\r\n    },\r\n    \"evmVersion\": \"berlin\",\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"libraries\": {\r\n      \"Exchange.sol\": {\r\n        \"AssetRegistry\": \"0xc2f05d03915E7c2D9038830F7888c97e351dd3dB\",\r\n        \"Depositing\": \"0x116310b243dd287d4285d0e8a34ce3d4adb63dac\",\r\n        \"LiquidityPoolAdmin\": \"0x7a246e4434dd31df784bb88d3443e309e3143adc\",\r\n        \"LiquidityPools\": \"0x0f2c07f4ecc6c9d74d16e735d2a59d00985b1962\",\r\n        \"NonceInvalidations\": \"0x6c539e6143f70408076f35d19e7e549850c021ad\",\r\n        \"Trading\": \"0x4d3250014ea4ecddd857fad48c3d64d2e4f037e1\",\r\n        \"Withdrawing\": \"0xb3af24eeac0ee8b6f5798f8a75e3ecd51b18deb2\"\r\n      },\r\n      \"AssetRegistry.sol\": {\r\n        \"AssetRegistry\": \"0xc2f05d03915E7c2D9038830F7888c97e351dd3dB\"\r\n      },\r\n      \"Depositing.sol\": {\r\n        \"Depositing\": \"0x116310b243dd287d4285d0e8a34ce3d4adb63dac\"\r\n      },\r\n      \"LiquidityPoolAdmin.sol\": {\r\n        \"LiquidityPoolAdmin\": \"0x7a246e4434dd31df784bb88d3443e309e3143adc\"\r\n      },\r\n      \"LiquidityPools.sol\": {\r\n        \"LiquidityPools\": \"0x0f2c07f4ecc6c9d74d16e735d2a59d00985b1962\"\r\n      },\r\n      \"NonceInvalidations.sol\": {\r\n        \"NonceInvalidations\": \"0x6c539e6143f70408076f35d19e7e549850c021ad\"\r\n      },\r\n      \"Trading.sol\": {\r\n        \"Trading\": \"0x4d3250014ea4ecddd857fad48c3d64d2e4f037e1\"\r\n      },\r\n      \"Withdrawing.sol\": {\r\n        \"Withdrawing\": \"0xb3af24eeac0ee8b6f5798f8a75e3ecd51b18deb2\"\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_baseAssetAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_quoteAssetAddress\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"_baseAssetSymbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_quoteAssetSymbol\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAssetQuantityInAssetUnits\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAssetQuantityInAssetUnits\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"baseAssetQuantityInAssetUnits\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"quoteAssetQuantityInAssetUnits\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAssetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseAssetSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseAssetQuantityInAssetUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAssetQuantityInAssetUnits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"custodian\",\"outputs\":[{\"internalType\":\"contract ICustodian\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"baseAssetQuantityInAssetUnits\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"quoteAssetQuantityInAssetUnits\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteAssetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"quoteAssetSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reverseAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LiquidityProviderToken", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "1", "ConstructorArguments": "0000000000000000000000007ceb23fd6bc0add59e62ac25578270cff1b9f6190000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa84174000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000003455448000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000045553444300000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://e2f34b0302d85fe79c347e6e92720d5490e0344999118c2a4d470fe48aa3071f"}