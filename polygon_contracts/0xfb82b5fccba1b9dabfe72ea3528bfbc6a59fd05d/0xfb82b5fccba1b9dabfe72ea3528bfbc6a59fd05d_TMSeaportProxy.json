{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/lib/1inch/IAggregationExecutor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\n/// @title Interface for making arbitrary calls during swap\\r\\ninterface IAggregationExecutor {\\r\\n    /// @notice propagates information about original msg.sender and executes arbitrary data\\r\\n    function execute(address msgSender) external payable; // 0x4b64e492\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/1inch/IAggregationRouterV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\nimport \\\"./IAggregationExecutor.sol\\\";\\r\\nimport \\\"./IERC20.sol\\\";\\r\\nimport \\\"./SwapData.sol\\\";\\r\\n\\r\\ninterface IAggregationRouterV5 {\\r\\n    function swap(\\r\\n        IAggregationExecutor executor,\\r\\n        SwapDescription calldata desc,\\r\\n        bytes calldata permit,\\r\\n        bytes calldata data\\r\\n    ) external payable returns (uint256 returnAmount, uint256 spentAmount);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/1inch/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\r\\n\\r\\npragma solidity ^0.8.1;\\r\\n\\r\\n/**\\r\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\r\\n */\\r\\ninterface IERC20 {\\r\\n    /**\\r\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\r\\n     * another (`to`).\\r\\n     *\\r\\n     * Note that `value` may be zero.\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n\\r\\n    /**\\r\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\r\\n     * a call to {approve}. `value` is the new allowance.\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 value\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens in existence.\\r\\n     */\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the amount of tokens owned by `account`.\\r\\n     */\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Returns the remaining number of tokens that `spender` will be\\r\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\r\\n     * zero by default.\\r\\n     *\\r\\n     * This value changes when {approve} or {transferFrom} are called.\\r\\n     */\\r\\n    function allowance(address owner, address spender)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\r\\n     * that someone may use both the old and the new allowance by unfortunate\\r\\n     * transaction ordering. One possible solution to mitigate this race\\r\\n     * condition is to first reduce the spender's allowance to 0 and set the\\r\\n     * desired value afterwards:\\r\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\r\\n     *\\r\\n     * Emits an {Approval} event.\\r\\n     */\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\r\\n     * allowance mechanism. `amount` is then deducted from the caller's\\r\\n     * allowance.\\r\\n     *\\r\\n     * Returns a boolean value indicating whether the operation succeeded.\\r\\n     *\\r\\n     * Emits a {Transfer} event.\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 amount\\r\\n    ) external returns (bool);\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/lib/1inch/SwapData.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\nimport \\\"./IERC20.sol\\\";\\r\\n\\r\\n\\r\\nstruct SwapDescription {\\r\\n    IERC20 srcToken;\\r\\n    IERC20 dstToken;\\r\\n    address payable srcReceiver;\\r\\n    address payable dstReceiver;\\r\\n    uint256 amount;\\r\\n    uint256 minReturnAmount;\\r\\n    uint256 flags;\\r\\n}\\r\\n\\r\\n\\r\\n\"\r\n    },\r\n    \"contracts/lib/seaport/SeaportEnums.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nenum OrderType {\\r\\n    // 0: no partial fills, anyone can execute\\r\\n    FULL_OPEN,\\r\\n\\r\\n    // 1: partial fills supported, anyone can execute\\r\\n    PARTIAL_OPEN,\\r\\n\\r\\n    // 2: no partial fills, only offerer or zone can execute\\r\\n    FULL_RESTRICTED,\\r\\n\\r\\n    // 3: partial fills supported, only offerer or zone can execute\\r\\n    PARTIAL_RESTRICTED,\\r\\n\\r\\n    // 4: contract order type\\r\\n    CONTRACT\\r\\n}\\r\\n\\r\\nenum ItemType {\\r\\n    // 0: ETH on mainnet, MATIC on polygon, etc.\\r\\n    NATIVE,\\r\\n\\r\\n    // 1: ERC20 items (ERC777 and ERC20 analogues could also technically work)\\r\\n    ERC20,\\r\\n\\r\\n    // 2: ERC721 items\\r\\n    ERC721,\\r\\n\\r\\n    // 3: ERC1155 items\\r\\n    ERC1155,\\r\\n\\r\\n    // 4: ERC721 items where a number of tokenIds are supported\\r\\n    ERC721_WITH_CRITERIA,\\r\\n\\r\\n    // 5: ERC1155 items where a number of ids are supported\\r\\n    ERC1155_WITH_CRITERIA\\r\\n}\\r\\n\\r\\nenum Side {\\r\\n    // 0: Items that can be spent\\r\\n    OFFER,\\r\\n\\r\\n    // 1: Items that must be received\\r\\n    CONSIDERATION\\r\\n}\"\r\n    },\r\n    \"contracts/lib/seaport/SeaportInterface.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.13;\\r\\nimport \\\"./SeaportStructs.sol\\\";\\r\\n\\r\\n\\r\\ninterface SeaportInterface {\\r\\n  \\r\\nfunction fulfillAdvancedOrder(\\r\\n        AdvancedOrder calldata advancedOrder,\\r\\n        CriteriaResolver[] calldata criteriaResolvers,\\r\\n        bytes32 fulfillerConduitKey,\\r\\n        address recipient\\r\\n    ) external payable returns (bool fulfilled);\\r\\n\\r\\n}\"\r\n    },\r\n    \"contracts/lib/seaport/SeaportStructs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\nimport \\\"./SeaportEnums.sol\\\";\\r\\npragma solidity ^0.8.13;\\r\\n\\r\\nstruct AdvancedOrder {\\r\\n    OrderParameters parameters;\\r\\n    uint120 numerator;\\r\\n    uint120 denominator;\\r\\n    bytes signature;\\r\\n    bytes extraData;\\r\\n}\\r\\n\\r\\nstruct OrderParameters {\\r\\n    address offerer; // 0x00\\r\\n    address zone; // 0x20\\r\\n    OfferItem[] offer; // 0x40\\r\\n    ConsiderationItem[] consideration; // 0x60\\r\\n    OrderType orderType; // 0x80\\r\\n    uint256 startTime; // 0xa0\\r\\n    uint256 endTime; // 0xc0\\r\\n    bytes32 zoneHash; // 0xe0\\r\\n    uint256 salt; // 0x100\\r\\n    bytes32 conduitKey; // 0x120\\r\\n    uint256 totalOriginalConsiderationItems; // 0x140\\r\\n    // offer.length                          // 0x160\\r\\n}\\r\\n\\r\\nstruct OfferItem {\\r\\n    ItemType itemType;\\r\\n    address token;\\r\\n    uint256 identifierOrCriteria;\\r\\n    uint256 startAmount;\\r\\n    uint256 endAmount;\\r\\n}\\r\\n\\r\\nstruct ConsiderationItem {\\r\\n    ItemType itemType;\\r\\n    address token;\\r\\n    uint256 identifierOrCriteria;\\r\\n    uint256 startAmount;\\r\\n    uint256 endAmount;\\r\\n    address payable recipient;\\r\\n}\\r\\n\\r\\nstruct CriteriaResolver {\\r\\n    uint256 orderIndex;\\r\\n    Side side;\\r\\n    uint256 index;\\r\\n    uint256 identifier;\\r\\n    bytes32[] criteriaProof;\\r\\n}\"\r\n    },\r\n    \"contracts/TMSeaportProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.18;\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\nimport \\\"./lib/1inch/IAggregationRouterV5.sol\\\";\\nimport \\\"./lib/seaport/SeaportInterface.sol\\\";\\n\\ncontract TMSeaportProxy is Ownable {\\n    SeaportInterface seaport;\\n    IAggregationRouterV5 oneInch;\\n    address private constant NativeAddress =\\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n\\n    error InsufficientBalance(\\n        address token,\\n        uint256 available,\\n        uint256 required\\n    );\\n    error WrongInput();\\n\\n    constructor(SeaportInterface _seaport, IAggregationRouterV5 _1inch) {\\n        seaport = _seaport;\\n        oneInch = _1inch;\\n    }\\n\\n    function changeSeaport(SeaportInterface _seaport) external onlyOwner {\\n        seaport = _seaport;\\n    }\\n\\n    function changeOneInch(IAggregationRouterV5 _1inch) external onlyOwner {\\n        oneInch = _1inch;\\n    }\\n\\n    function swapToFulfill(\\n        AdvancedOrder calldata advancedOrder,\\n        CriteriaResolver[] calldata criteriaResolvers,\\n        bytes32 fulfillerConduitKey,\\n        address recipient,\\n        bytes calldata swapData\\n    ) external payable {\\n        // decode data\\n        (\\n            IAggregationExecutor executor,\\n            SwapDescription memory desc,\\n            ,\\n            bytes memory executeData\\n        ) = abi.decode(\\n                swapData[4:],\\n                (IAggregationExecutor, SwapDescription, bytes, bytes)\\n            );\\n\\n        // process native and erc20 token\\n        uint256 nativeAmount = 0;\\n        if (address(desc.srcToken) == NativeAddress) {\\n            nativeAmount = desc.amount;\\n            if (nativeAmount > msg.value)\\n                revert InsufficientBalance(\\n                    NativeAddress,\\n                    msg.value,\\n                    nativeAmount\\n                );\\n        } else {\\n            desc.srcToken.transferFrom(msg.sender, address(this), desc.amount);\\n            desc.srcToken.approve(address(oneInch), desc.amount);\\n        }\\n\\n        // check consideration items\\n        ConsiderationItem[] memory considerations = advancedOrder\\n            .parameters\\n            .consideration;\\n        uint256 fulfillAmount = 0;\\n        for (uint i = 0; i < considerations.length; i++) {\\n            if (\\n                considerations[i].token != address(desc.dstToken) ||\\n                considerations[i].startAmount != considerations[i].endAmount\\n            ) {\\n                revert WrongInput();\\n            }\\n            fulfillAmount += considerations[i].endAmount;\\n        }\\n        fulfillAmount =\\n            (fulfillAmount * advancedOrder.numerator) /\\n            advancedOrder.denominator;\\n        //swap to consideration token\\n\\n        (uint256 returnAmount, ) = oneInch.swap{value: nativeAmount}(\\n            executor,\\n            desc,\\n            \\\"\\\",\\n            executeData\\n        );\\n\\n        if (returnAmount < fulfillAmount) {\\n            revert InsufficientBalance(\\n                address(desc.dstToken),\\n                returnAmount,\\n                fulfillAmount\\n            );\\n        }\\n\\n        desc.dstToken.approve(address(seaport), fulfillAmount);\\n\\n        // fulfill order!\\n        seaport.fulfillAdvancedOrder(\\n            advancedOrder,\\n            criteriaResolvers,\\n            fulfillerConduitKey,\\n            recipient\\n        );\\n        if (returnAmount > fulfillAmount)\\n            desc.dstToken.transfer(msg.sender, returnAmount - fulfillAmount);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 300\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract SeaportInterface\",\"name\":\"_seaport\",\"type\":\"address\"},{\"internalType\":\"contract IAggregationRouterV5\",\"name\":\"_1inch\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"WrongInput\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract IAggregationRouterV5\",\"name\":\"_1inch\",\"type\":\"address\"}],\"name\":\"changeOneInch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract SeaportInterface\",\"name\":\"_seaport\",\"type\":\"address\"}],\"name\":\"changeSeaport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"offerer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"zone\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct OfferItem[]\",\"name\":\"offer\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"enum ItemType\",\"name\":\"itemType\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"identifierOrCriteria\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endAmount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient\",\"type\":\"address\"}],\"internalType\":\"struct ConsiderationItem[]\",\"name\":\"consideration\",\"type\":\"tuple[]\"},{\"internalType\":\"enum OrderType\",\"name\":\"orderType\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"zoneHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"salt\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"conduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"totalOriginalConsiderationItems\",\"type\":\"uint256\"}],\"internalType\":\"struct OrderParameters\",\"name\":\"parameters\",\"type\":\"tuple\"},{\"internalType\":\"uint120\",\"name\":\"numerator\",\"type\":\"uint120\"},{\"internalType\":\"uint120\",\"name\":\"denominator\",\"type\":\"uint120\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"extraData\",\"type\":\"bytes\"}],\"internalType\":\"struct AdvancedOrder\",\"name\":\"advancedOrder\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"orderIndex\",\"type\":\"uint256\"},{\"internalType\":\"enum Side\",\"name\":\"side\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"identifier\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"criteriaProof\",\"type\":\"bytes32[]\"}],\"internalType\":\"struct CriteriaResolver[]\",\"name\":\"criteriaResolvers\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"fulfillerConduitKey\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"}],\"name\":\"swapToFulfill\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TMSeaportProxy", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "300", "ConstructorArguments": "00000000000000000000000000000000000000adc04c56bf30ac9d3c0aaf14dc0000000000000000000000001111111254eeb25477b68fb85ed929f73a960582", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}