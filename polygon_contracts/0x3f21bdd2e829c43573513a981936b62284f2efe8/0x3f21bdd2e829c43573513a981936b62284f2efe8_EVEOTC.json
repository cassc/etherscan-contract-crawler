{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.12;\r\n\r\n/**\r\n * Interface to communicate with aggregator oracles in Chainlink\r\n * https://docs.chain.link/getting-started/consuming-data-feeds\r\n */\r\ninterface AggregatorV3Interface {\r\n  function decimals() external view returns (uint8);\r\n\r\n  function description() external view returns (string memory);\r\n\r\n  function version() external view returns (uint256);\r\n\r\n  // getRoundData and latestRoundData should both raise \"No data present\"\r\n  // if they do not have data to report, instead of returning unset values\r\n  // which could be misinterpreted as actual reported values.\r\n  function getRoundData(uint80 _roundId)\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n\r\n  function latestRoundData()\r\n    external\r\n    view\r\n    returns (\r\n      uint80 roundId,\r\n      int256 answer,\r\n      uint256 startedAt,\r\n      uint256 updatedAt,\r\n      uint80 answeredInRound\r\n    );\r\n}\r\n\r\n/**\r\n * @title Owner\r\n * @dev Set & change owner\r\n */\r\ncontract Owner {\r\n\r\n    address private owner;\r\n    \r\n    // event for EVM logging\r\n    event OwnerSet(address indexed oldOwner, address indexed newOwner);\r\n    \r\n    // modifier to check if caller is owner\r\n    modifier isOwner() {\r\n        // If the first argument of 'require' evaluates to 'false', execution terminates and all\r\n        // changes to the state and to Ether balances are reverted.\r\n        // This used to consume all gas in old EVM versions, but not anymore.\r\n        // It is often a good idea to use 'require' to check if functions are called correctly.\r\n        // As a second argument, you can also provide an explanation about what went wrong.\r\n        require(msg.sender == owner, \"Caller is not owner\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Set contract deployer as owner\r\n     */\r\n    constructor(address _owner) {\r\n        owner = _owner;\r\n        emit OwnerSet(address(0), owner);\r\n    }\r\n\r\n    /**\r\n     * @dev Change owner\r\n     * @param newOwner address of new owner\r\n     */\r\n    function changeOwner(address newOwner) public isOwner {\r\n        emit OwnerSet(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Return owner address \r\n     * @return address of owner\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return owner;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * Staking smart contract interface\r\n */\r\ninterface IEVEOTCStakes {\r\n    function getSmartDiscount(address user) external view returns (uint8, uint8);\r\n}\r\n\r\n/**\r\n * Token Handler for Trades\r\n *\r\n * There are three types of tokens depending on how do they get their USD price:\r\n * \r\n * 1) Using a chainlink aggregator (this is the preferred option, because it is cheap and is included by default in the chainlink oracles system)\r\n * 2) Using a custom chainlink oracle, this is the most expensive option because the system will be charged 0.1 LINK for every query to the \r\n *    external (CoinMarketCap) API\r\n * 3) The system admin or token owner can set the price of the token manually\r\n *\r\n * The system also differenciate user tokens (added by end users) from system tokens (added by system administrator)\r\n *\r\n * User tokens price is always manually set\r\n *\r\n */\r\ncontract EVEOTCTokens is Owner, ReentrancyGuard {\r\n\r\n    // Token Object for coins available in the system\r\n    // This tokens are added by admins\r\n    struct Token {\r\n        address token;                  // the token address\r\n        uint256 cmc_index;              // coinmarketcap api index\r\n        address chanlink_aggregator;    // chainlink oracle\r\n        uint256 manual_entry_price;     // price if set manually, minimum price has to be > 0\r\n        uint256 last_update;            // last update\r\n        uint256 last_price;             // last price\r\n    }\r\n\r\n    // Total set of tokens\r\n    Token[] public tokens;\r\n    uint256 public tokens_length;\r\n\r\n    // the index of the token in the tokens array\r\n    // the if the value is 0 means it does not exists, if the value is > 0 then the index is token_indexes_plus1[address] - 1\r\n    // this is useful to avoid looping the tokens array to find the index of an existing token\r\n    mapping (address => uint256) internal token_indexes_plus1;\r\n\r\n    // system tokens list if they are enabled or not\r\n    mapping (address => bool) public tokens_enabled;\r\n\r\n    // Token Object for coins available in the system\r\n    // This tokens are added by regular users\r\n    struct UserToken {\r\n        address token;              // the token address\r\n        address owner;              // the first user that added this token\r\n        uint256 manual_entry_price; // price if set manually\r\n        uint256 last_update;        // last update\r\n    }\r\n\r\n    // external chainlink custom API manager (used to connect with coinmarketcap)\r\n    address public oracle_api;\r\n\r\n    OTCChainLinkOracle oracleAPIContract;\r\n\r\n    event USDPriceCustomAPI(address token, uint256 price);\r\n    event USDPriceAggregator(address token, uint256 price);\r\n    event USDPriceManualEntry(address token, uint256 price);\r\n\r\n    /**\r\n     * @param _owner owner of the contract\r\n     * @param _oracle_api external oracle to communicate with custom API\r\n     */\r\n    constructor(address _owner, address _oracle_api) \r\n        Owner(_owner) {\r\n        oracle_api = _oracle_api;\r\n        oracleAPIContract = OTCChainLinkOracle(oracle_api);\r\n    }\r\n\r\n    // return a regular array index from 0 to n-1\r\n    // if the token doesn't exists it returns -1\r\n    function token_indexes(address _add) external view returns(int index) {\r\n        return int(token_indexes_plus1[_add]) - 1;\r\n    }\r\n\r\n    // set admin parameters\r\n    function rootSet(address _oracle_api) external isOwner {\r\n        oracle_api = _oracle_api;\r\n        oracleAPIContract = OTCChainLinkOracle(oracle_api);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Add or replace system tokens\r\n     * \r\n     * Network: Goerli\r\n     * Aggregator: ETH/USD\r\n     * Address: 0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\r\n     *\r\n     * Polygon aggregagtors\r\n     * https://docs.chain.link/docs/matic-addresses/\r\n     *   BNB Price: 0x82a6c4AF830caa6c97bb504425f6A66165C2c26e\r\n     *\r\n     */\r\n    function addTokenData(address _token, uint256 _cmc_index, address _aggregator, uint256 _price) public isOwner {\r\n        \r\n        require(_token != address(0), \"OTC: cannot add the zero address\");\r\n\r\n        require(_cmc_index > 0 || _aggregator != address(0) || _price > 0, \"OTC: cannot add a token without a pricing mechanism\");\r\n\r\n        // find the position of the token in the tokens array\r\n        uint256 _the_index = token_indexes_plus1[_token];\r\n\r\n        // at this point _the_index is 0 (non existing token) or token existing in the tokens array in the position _the_index + 1\r\n\r\n        // add the token if it doesn't exists, update if it does exists\r\n        Token memory _the_token = Token(\r\n            _token,\r\n            _cmc_index,\r\n            _aggregator,\r\n            _price,\r\n            block.timestamp,\r\n            _price\r\n        );\r\n\r\n        if (_the_index == 0) {\r\n            tokens.push(_the_token);\r\n            _the_index = tokens.length - 1;\r\n\r\n            // we keep track of the token index to avoid loops in arrays\r\n            token_indexes_plus1[_token] = tokens.length; // we need to add 1 to index, because 0 means not existing token\r\n\r\n            tokens_length = tokens.length;\r\n        } else {\r\n            _the_index--; // we reduce 1 to the index because we added 1 to the token index in the lines before\r\n            tokens[_the_index] = _the_token;\r\n        }\r\n\r\n        // at this point _the_index is the real position in the tokens array \r\n\r\n        // enable token either way, found or not\r\n        tokens_enabled[tokens[_the_index].token] = true;\r\n\r\n        if (_price>0) {\r\n            emit USDPriceManualEntry(_token, _price);\r\n        }\r\n\r\n    }\r\n\r\n    // enable / disable tokens\r\n    // _i: tokens array position\r\n    // _enabled: true or false for enabled / disabled\r\n    function changeTokenStatus(uint256 _i, bool _enabled) external isOwner {\r\n        tokens_enabled[tokens[_i].token] = _enabled;\r\n    }\r\n\r\n    // _i: tokens array position\r\n    // _manual_entry_price: new manual price\r\n    function changeTokenPrice(uint256 _i, uint256 _manual_entry_price) external isOwner {\r\n        tokens[_i].manual_entry_price = _manual_entry_price;\r\n    }\r\n\r\n    // get the best usd price estimation without updating the chain state and without spending LINK\r\n    function getColdUSDPrice(address _token) public view returns (uint256 price) {\r\n\r\n        // Is a system token?\r\n        if (tokens_enabled[_token]) {\r\n\r\n            // find the index\r\n            uint256 _token_index = token_indexes_plus1[_token];\r\n            \r\n            if (_token_index == 0) return 0; // 0 in token_indexes_plus1 means not existing token\r\n\r\n            // if _token_index is > 0 then we need to substract 1 to get the real array position of the token in the tokens array\r\n            _token_index--;\r\n\r\n            // the price reference is CMC? if so return the las used custom api oracle price\r\n            if (tokens[_token_index].cmc_index > 0) {\r\n                return oracleAPIContract.usd_prices(tokens[_token_index].cmc_index);\r\n            // there is a chainlink oracle for this token? if so return the oracle price\r\n            } else if (tokens[_token_index].chanlink_aggregator != address(0)) {\r\n                return getAggregatorUSDPrice(tokens[_token_index].chanlink_aggregator);\r\n            // default to manual entry price\r\n            } else {\r\n                return tokens[_token_index].manual_entry_price;\r\n            }\r\n\r\n        // default to 0\r\n        } else {\r\n            return 0;\r\n        }\r\n\r\n    }\r\n\r\n    // get usd price of any token and if it is a custom oracle price get update the price from oracle (spending LINK)\r\n    function getUSDPrice(address _token) public returns (uint256 price) {\r\n\r\n        // Get the index of the token in the system tokens array, if exists\r\n\r\n        // Is a system token?\r\n        if (tokens_enabled[_token]) {\r\n\r\n            // find the index\r\n            uint256 _token_index = token_indexes_plus1[_token];\r\n            \r\n            if (_token_index == 0) return 0; // 0 in token_indexes_plus1 means not existing token\r\n\r\n            // if _token_index is > 0 then we need to substract 1 to get the real array position of the token in the tokens array\r\n            _token_index--;\r\n\r\n            // the price reference is CMC? if so return the custom api oracle price\r\n            if (tokens[_token_index].cmc_index > 0) {\r\n                tokens[_token_index].last_price = getAPIUSDPrice(tokens[_token_index].cmc_index);\r\n                tokens[_token_index].last_update = block.timestamp;\r\n                emit USDPriceCustomAPI(_token, tokens[_token_index].last_price);\r\n                return tokens[_token_index].last_price;\r\n            // there is a chainlink oracle for this token? if so return the oracle price\r\n            } else if (tokens[_token_index].chanlink_aggregator != address(0)) {\r\n                tokens[_token_index].last_price = getAggregatorUSDPrice(tokens[_token_index].chanlink_aggregator);\r\n                tokens[_token_index].last_update = block.timestamp;\r\n                emit USDPriceAggregator(_token, tokens[_token_index].last_price);\r\n                return tokens[_token_index].last_price;\r\n            // default to manual entry price\r\n            } else {\r\n                return tokens[_token_index].manual_entry_price;\r\n            }\r\n\r\n        } else {\r\n            require(false, \"OTC: Token is not enabled\");\r\n        }\r\n    }\r\n\r\n    // get usd price of a chainlink default oracle\r\n    function getAggregatorUSDPrice(address _aggregator) public view returns (uint256) {\r\n        AggregatorV3Interface priceFeed;\r\n        priceFeed = AggregatorV3Interface(_aggregator);\r\n        (, int price,,,) = priceFeed.latestRoundData();\r\n        // transform the price to the decimals based on the aggregator decimals function\r\n\r\n        uint256 ret = uint(price) * (10 ** 8) / (10 ** AggregatorV3Interface(_aggregator).decimals());\r\n\r\n        return ret;\r\n    }\r\n\r\n    // get usd price of a token using a custom api call\r\n    function getAPIUSDPrice(uint256 _cmc_index) internal view returns (uint256 price) {\r\n        return (oracleAPIContract.usd_prices(_cmc_index));\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * This is the main contract for the EVE Exchange\r\n */\r\ncontract EVEOTC is EVEOTCTokens {\r\n    \r\n    // commission to pay by liquidity providers in the provided token\r\n    // those are percentages with two decimals, example: 50 means 0,5%, 300 means 3%\r\n    uint32 public commission_smart_trades_sell;\r\n    uint32 public commission_smart_trades_buy;\r\n\r\n    // staking smart contract\r\n    IEVEOTCStakes public stakes;\r\n\r\n    // wallet of the owner to receive funds\r\n    address public owner_wallet;\r\n\r\n    /**\r\n     * Trade offer\r\n     */\r\n    struct Offer {\r\n        address owner;  // the liquidity provider\r\n        address from;   // token on sale\r\n        address[] to;   // tokens receiveed\r\n        uint256 available;  // original amount\r\n        uint256 filled;     // amount sold\r\n        uint256 surplus;    // excess paid by the seller to cover commission expenses\r\n        uint256 filled_surplus;  // amount of the surplus paid in commissions\r\n        uint256 price;      // if > 0 is a custom price in USD (including 8 decimals in the value), if 0 means a market price\r\n        uint256 discount;   // discount percentage for smart trades\r\n        uint256 premium;    // premium percentage\r\n        uint256 time;       // vesting duration in days\r\n        bool    active;     // if the trade is active or not\r\n        bool    custom_token; // if the offer is selling an unknown token\r\n    }\r\n\r\n    // all system offers, historical and active\r\n    Offer[] public trades;\r\n\r\n    // selling commission at the moment of Offer creation, per each offer index\r\n    mapping(uint256 => uint16) public trades_commission_sell;\r\n\r\n    event NewOffer(\r\n        uint256 index,\r\n        address owner,\r\n        address from,\r\n        address[] to,\r\n        uint256 available,\r\n        uint256 surplus,\r\n        uint256 price,\r\n        uint256 discount,\r\n        uint256 premium,\r\n        uint256 time,\r\n        bool custom_token\r\n    );\r\n\r\n    event CancelOffer(\r\n        uint256 offer_index,\r\n        uint256 amount_returned,\r\n        address owner\r\n    );\r\n\r\n    // Offer purchase by the buyer\r\n    struct Purchase {\r\n        uint256 offer_index;  // reference to Offer\r\n        address from;         // token bought\r\n        address to;           // token used for payment\r\n        uint256 amount;       // total amount bought, excluding premium price\r\n        uint256 withdrawn;    // amount withdrawn by buyer\r\n        uint256 timestamp;\r\n        address buyer;\r\n        bool    paid;         // it is paid or not, if it is a smart trade is paid by default\r\n    }\r\n\r\n    // all purchases\r\n    Purchase[] public smart_trades_purchases;\r\n\r\n    event NewPurchase (\r\n        uint256 purchase_index,\r\n        uint256 offer_index,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 total_payment,\r\n        address buyer\r\n    );\r\n\r\n    event PurchaseWithdraw (\r\n        uint256 purchase_index,\r\n        uint256 offer_index,\r\n        uint256 withdrawn,\r\n        address buyer,\r\n        address token,\r\n        uint256 admin_commission\r\n    );\r\n\r\n    event NewPremium (\r\n        uint256 purchase_index,\r\n        uint256 offer_index,\r\n        address from,\r\n        address to,\r\n        uint256 premium,\r\n        address buyer\r\n    );\r\n\r\n    // emergency variable used to pause exchange activity\r\n    bool public paused;\r\n\r\n    /**\r\n     * @param _owner smart contract owner\r\n     * @param _oracle_api oracle to connect with CMC API to get prices\r\n     */\r\n    constructor(address _owner, address _oracle_api) EVEOTCTokens(_owner, _oracle_api) {\r\n        owner_wallet = _owner;\r\n    }\r\n\r\n    /**\r\n     * Add a system token\r\n     */\r\n    function addToken(address _token, uint256 _cmc_index, address _aggregator, uint256 _price) public {\r\n        super.addTokenData(_token, _cmc_index, _aggregator, _price);\r\n        getUSDPrice(_token);\r\n    }\r\n\r\n    /**\r\n     * Set the admin wallet \r\n     * \r\n     * @param _wallet the new wallet\r\n     *\r\n     */\r\n    function walletSet(address _wallet) public isOwner {\r\n        require(_wallet != address(0), \"OTC: cannot set the zero address\");\r\n        owner_wallet = _wallet;\r\n    }\r\n\r\n    /**\r\n     * Set the admin commissions \r\n     * \r\n     * @param _commission_smart_trades_sell commission to charge to sellers on a smart trade\r\n     * @param _commission_smart_trades_buy commission to charge to buyers on a smart trade\r\n     *\r\n     */\r\n    function commissionSet(\r\n        uint16 _commission_smart_trades_sell, \r\n        uint16 _commission_smart_trades_buy\r\n    ) public isOwner {\r\n        // validate that commissions are not greater than 100%\r\n        require(_commission_smart_trades_sell <= 10000, \"Smart trades seller commission cannot be greater than 100\");\r\n        require(_commission_smart_trades_buy <= 10000, \"Smart trades buyer commission cannot be greater than 100\");\r\n        // update contract parameters\r\n        commission_smart_trades_sell = _commission_smart_trades_sell;\r\n        commission_smart_trades_buy = _commission_smart_trades_buy;\r\n    }\r\n\r\n    /**\r\n     * Set the contract to use for staking\r\n     * this will be used to determine discounts to apply\r\n     */\r\n    function stakingContractSet(IEVEOTCStakes _stakes) external isOwner {\r\n        stakes = _stakes;\r\n    }\r\n\r\n    /**\r\n     * Low level function to get the to array inside an offer\r\n     */\r\n    function trades_to_query(uint256 _index) external view returns (address[] memory to) {\r\n        return trades[_index].to;\r\n    }\r\n\r\n    /**\r\n     * Functions to get length of arrays\r\n     */\r\n\r\n    function trades_length() external view returns(uint256 index) { return trades.length; }\r\n\r\n    /**\r\n     * calculate the surplus from the seller to pay commissions\r\n     * if the seller has a staking active then he does not pay commissions\r\n     */\r\n\r\n    function surplus(uint256 _available) public view returns (uint256 _surplus, uint16 _commission_sell) {\r\n        \r\n        // discount on commissions\r\n        uint8 stake_discount_seller = 0;\r\n        \r\n        // the commission\r\n        uint256 commission_sell = 0;\r\n\r\n        // calculates the commission at the moment of sale, to consider if the user has an active stake / discount\r\n        commission_sell = commission_smart_trades_sell;\r\n        (stake_discount_seller,) = stakes.getSmartDiscount(msg.sender);\r\n\r\n        if (stake_discount_seller > 0) {\r\n            // if commission is 30 (%) and the discount is 50 (%) then the commission is 30 * (100 - 50) / 100 = 30 * 50 / 100 = 1500 / 100 = 15\r\n            // if commission is 30 (%) and the discount is 10 (%) then the commission is 30 * (100 - 10) / 100 = 30 * 90 / 100 = 2700 / 100 = 27\r\n            commission_sell = commission_sell * (100 - stake_discount_seller) / 100;\r\n        }\r\n\r\n        // commission is a percentage with two decimals: 50 means 0,5%\r\n        return (_available * commission_sell / 10000, uint16(commission_sell));\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Create a token sale offer\r\n     * The seller needs to approve the amount \"available\" plus the commission\r\n     * The record of the contracts will record only the available amount\r\n     * the surplus will be stored for commission payment purposes\r\n     *\r\n     * @param _from token on sale\r\n     * @param _to tokens receiveed\r\n     * @param _available original amount for sale\r\n     * @param _price Custom Price or Strike price\r\n     *               If smart_trade is true, then, if > 0 is a custom price in USD (including 8 decimals in the value), if 0 means a market price\r\n     *               If smart_trade is false, then this is the strike price\r\n     * @param _discount discount percentage for smart trades\r\n     * @param _premium premium percentage or premium price, depending if it is a smart trade or not\r\n     * @param _time vesting duration in seconds or expiration day\r\n     *              If smart_trade is true, then this is the vesting duration in seconds\r\n     *              If smart_trade is false, then this is an expiration date / time\r\n     *\r\n     */\r\n    function addOffer(address _from, address[] memory _to, uint256 _available, uint256 _price, uint256 _discount, \r\n                      uint256 _premium, uint256 _time) external nonReentrant isNotPaused {\r\n\r\n        require(_available > 0, \"OTC: Offer has to be greater than 0\");\r\n        require(_discount < 100, \"OTC: discount has to be lower than 100\");\r\n\r\n        // validate all tokens, token for selling has to be a system token, or a custom token with a price set\r\n        require(tokens_enabled[_from] || (_from != address(0) && _price > 0), \"OTC: Token on sale is not enabled\");\r\n\r\n        // If the token is not enable it means it is a custom token\r\n        bool is_a_custom_token = !tokens_enabled[_from];\r\n\r\n        for (uint256 i; i < _to.length; i++) {\r\n            require(tokens_enabled[_to[i]], \"OTC: Payment token is not enabled\");\r\n        }\r\n\r\n        // calculate the surplus from the seller to pay commissions\r\n        (uint256 _surplus, uint16 _commission_sell) = surplus(_available);\r\n\r\n        // lock the funds of the offer plus the surplus to pay commissions to admin\r\n        require(IERC20(_from).transferFrom(msg.sender, address(this), _available + _surplus), \"OTC: error transfering token funds\");\r\n\r\n        // add the offer to the record list\r\n        trades.push(Offer(msg.sender, _from, _to, _available, 0, _surplus, 0, _price, _discount, _premium, _time, true, is_a_custom_token));\r\n\r\n        // add the offer index to all mappings\r\n        uint256 index = trades.length - 1;\r\n\r\n        // keep track of the original commissions\r\n        trades_commission_sell[index] = _commission_sell;\r\n        \r\n        emit NewOffer(index, msg.sender, _from, _to, _available, _surplus, _price, _discount, _premium, _time, is_a_custom_token);\r\n\r\n    }\r\n\r\n    /**\r\n     * Cancel an existing offer and return the funds to the owner\r\n     * @param _index the index in the offer array\r\n     */\r\n    function cancelTrade(uint256 _index) external nonReentrant {\r\n\r\n        // validate owner of the trade\r\n        require(trades[_index].owner == msg.sender, \"OTC: caller is not the owner of the trade\");\r\n\r\n        require(trades[_index].active, \"OTC: trade is already canceled\");\r\n\r\n        // return remaining amount + surplus\r\n        uint256 amount_returned = trades[_index].available - trades[_index].filled + trades[_index].surplus - trades[_index].filled_surplus;\r\n        if (amount_returned > 0) {\r\n            require(IERC20(trades[_index].from).transfer(msg.sender, amount_returned), \"OTC: error canceling offer\");\r\n        }\r\n\r\n        trades[_index].active = false;\r\n\r\n        emit CancelOffer(_index, amount_returned, msg.sender);\r\n\r\n    }\r\n\r\n    /**\r\n     * Validate if there is enough amount and that the payment token is included in an offer\r\n     */\r\n    function validateTrade(uint256 _index, address _to, uint256 _amount) internal view {\r\n\r\n        // validate that this amount is under the limits available of the offer\r\n        require(trades[_index].available - trades[_index].filled >= _amount, \"OTC: not enough amount in the offer\");\r\n\r\n        // validate that this token is valid\r\n        bool token_found = false;\r\n        for (uint256 i; i < trades[_index].to.length; i++) {\r\n            if (trades[_index].to[i] == _to) {\r\n                token_found = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        require(token_found, \"OTC: token not found in the selected offer\");\r\n\r\n    }\r\n\r\n    /**\r\n     *\r\n     * Estimate the total payment for a smart trade, considering the usd price and decimal numbers of each token\r\n     *     @param _index: index in the trades array\r\n     *     @param _to: address of the token used for payment, must be previously approved\r\n     *     @param _sell_token_price: the price in USD of the token being sold\r\n     *     @param _pay_token_price: the price in USD of the token used for payments\r\n     *     @param _amount: amount to buy\r\n     *\r\n     * Returns a pair with the total payment and the commission to pay\r\n     *\r\n     */\r\n    function calculateTotalPayment(uint256 _index, address _to, uint256 _sell_token_price, uint256 _pay_token_price, uint256 _amount) \r\n        internal view returns(uint256 total_payment) {\r\n\r\n        // avoid division by zero if price is zero\r\n        if (_pay_token_price == 0) return 0;\r\n\r\n        uint256 sell_token_discount_price = _sell_token_price;\r\n        \r\n        // substract a discount to the price\r\n        if (trades[_index].discount > 0) {\r\n            sell_token_discount_price -= ((_sell_token_price * trades[_index].discount) / 100);\r\n        // add a premium to the price\r\n        } else if (trades[_index].premium > 0) {\r\n            sell_token_discount_price += ((_sell_token_price * trades[_index].premium) / 100);\r\n        }\r\n\r\n        uint256 _total_payment = (_amount * sell_token_discount_price * 10 ** IERC20(_to).decimals()) / 10 ** IERC20(trades[_index].from).decimals() / _pay_token_price;\r\n\r\n        // returns the estimated total payment with the calculated commission\r\n        return _total_payment;\r\n\r\n    }\r\n\r\n    /**\r\n     * Estimate the price a customer has to pay for a smart trade\r\n     *     @param _index: index in the trades array\r\n     *     @param _to: address of the token used for payment\r\n     *     @param _amount: to buy\r\n     *\r\n     * Returns the commission and payment separately\r\n     *\r\n     */\r\n    function splitEstimateSmartTrade(uint256 _index, address _to, uint256 _amount) public view returns (uint256 payment, uint256 commission) {\r\n\r\n        // get the price of the offer and calculate the payment amount in the payment token\r\n\r\n        // it is a custom price in USD?\r\n        uint256 sell_token_price = 0;\r\n        if (trades[_index].price > 0) {\r\n            // take this as a reference price of the selling token\r\n            sell_token_price = trades[_index].price;\r\n        // it is not a custom price?\r\n        } else {\r\n            // get the price in USD of the selling soken\r\n            sell_token_price = getColdUSDPrice(trades[_index].from);\r\n        }\r\n\r\n        // get the price of the payment token\r\n        uint256 pay_token_price = getColdUSDPrice(_to);\r\n\r\n        // calculate the payment amount\r\n        uint256 _payment_amount = calculateTotalPayment(_index, _to, sell_token_price, pay_token_price, _amount);\r\n\r\n        return (_payment_amount, _payment_amount * getCommissionBuySender() / 10000);\r\n\r\n    }\r\n\r\n    /**\r\n     * Estimate the price a customer has to pay for a smart trade\r\n     *     @param _index: index in the trades array\r\n     *     @param _to: address of the token used for payment\r\n     *     @param _amount: to buy\r\n     */\r\n    function estimateSmartTrade(uint256 _index, address _to, uint256 _amount) external view returns (uint256 total_payment) {\r\n        (uint256 _payment, uint256 _commission) = splitEstimateSmartTrade(_index, _to, _amount);\r\n        return _payment + _commission;\r\n    }\r\n\r\n    /**\r\n     * A customer can buy a smart trade\r\n     *     @param _index: index in the trades array\r\n     *     @param _to: address of the token used for payment, must be previously approved\r\n     *     @param _amount: to buy\r\n     */\r\n    function buySmartTrade(uint256 _index, address _to, uint256 _amount) external nonReentrant isNotPaused {\r\n\r\n        // validate parameters\r\n        validateTrade(_index, _to, _amount);\r\n\r\n        // get the price of the offer and calculate the payment amount in the payment token\r\n\r\n        // it is a custom price in USD?\r\n        uint256 sell_token_price = 0;\r\n        if (trades[_index].price > 0) {\r\n            // take this as a reference price of the selling token\r\n            sell_token_price = trades[_index].price;\r\n        // it is not a custom price?\r\n        } else {\r\n            // get the price in USD of the selling soken\r\n            sell_token_price = getUSDPrice(trades[_index].from);\r\n        }\r\n\r\n        require(sell_token_price > 0, \"OTC: Cannot buy a free token\");\r\n\r\n        // get the price of the payment token\r\n        uint256 pay_token_price = getUSDPrice(_to);\r\n\r\n        require(pay_token_price > 0, \"OTC: Cannot pay with a free token\");\r\n\r\n        // calculate the payment amount\r\n        uint256 _total_payment = calculateTotalPayment(_index, _to, sell_token_price, pay_token_price, _amount);\r\n\r\n        // The buyer pays 100% of the price in the selected token to the offer owner\r\n        require(IERC20(_to).transferFrom(msg.sender, trades[_index].owner, _total_payment), \"OTC: error doing the payment\");\r\n\r\n        // If the seller has to pay commissions:\r\n        // the seller pays the commission based on the commission set at the moment of transaction\r\n        // this is to avoid liquidity errors in case the admin changes the commission in the middle\r\n        uint256 _admin_commission = _amount * trades_commission_sell[_index] / 10000;\r\n        \r\n        // the seller pays commission to the contract owner / admin\r\n        if (_admin_commission > 0) {\r\n            require(IERC20(trades[_index].from).transfer(owner_wallet, _admin_commission), \"OTC: error paying commissions to owner\");\r\n            trades[_index].filled_surplus += _admin_commission;\r\n        }\r\n\r\n        // the buyer pays commission to the contract owner / admin\r\n        require(IERC20(_to).transferFrom(msg.sender, owner_wallet, _total_payment * getCommissionBuySender() / 10000), \"OTC: error paying buying commissions to owner\");\r\n\r\n        // The buyer got assigned the amount bought\r\n        smart_trades_purchases.push(Purchase(_index, trades[_index].from, _to, _amount, 0, block.timestamp, msg.sender, true));\r\n\r\n        // the smart trade filled amount is updated, the funds are reserved        \r\n        trades[_index].filled += _amount;\r\n\r\n        // if there is no more available close the active trade\r\n        if (trades[_index].filled == trades[_index].available) {\r\n            trades[_index].active = false;\r\n        }\r\n\r\n        uint256 smart_trades_purchases_index = smart_trades_purchases.length - 1;\r\n\r\n        emit NewPurchase (\r\n            smart_trades_purchases_index,\r\n            _index,\r\n            trades[_index].from, \r\n            _to, \r\n            _amount,\r\n            _total_payment,\r\n            msg.sender\r\n        );\r\n\r\n    }\r\n\r\n    /**\r\n     * return the maximum amount of tokens a buyer can withdraw at the moment from a smart trade\r\n     */\r\n    function getPurchasedWithdrawableTokens(uint256 _purchased_index) public view returns(uint256 _amount) {\r\n\r\n        // elapsed: get the number of seconds elapsed since the purchase\r\n        uint256 elapsed = block.timestamp - smart_trades_purchases[_purchased_index].timestamp;\r\n\r\n        // time: get the number of seconds of the vesting\r\n        uint256 _vesting_time = trades[smart_trades_purchases[_purchased_index].offer_index].time;\r\n\r\n        // if elapsed time is greater than the time of vesting, get the maximum time of vesting as the elapsed time\r\n        if (elapsed > _vesting_time) {\r\n            elapsed = _vesting_time;\r\n        }\r\n\r\n        // if not vesting time, the available to withdraw is the full amount\r\n        uint256 available = smart_trades_purchases[_purchased_index].amount;\r\n        if (_vesting_time > 0) {\r\n            // if vesting time, then amount available: elapsed * amount bought / time \r\n            available = elapsed * smart_trades_purchases[_purchased_index].amount / _vesting_time;\r\n        }\r\n\r\n        // minus already withdrawn\r\n        return available - smart_trades_purchases[_purchased_index].withdrawn;\r\n\r\n    }\r\n\r\n    /**\r\n     * withdraw tokens bought in smart trades (by buyer), it withdraw the available vesting amount\r\n     */\r\n    function getPurchasedTokens(uint256 _purchased_index) external nonReentrant isNotPaused {\r\n\r\n        // validate that the purchase belongs to sender\r\n        require(smart_trades_purchases[_purchased_index].buyer == msg.sender, \"OTC: caller is not the buyer\");\r\n\r\n        // validate that the amount to withdraw is greater than 0\r\n        uint256 available_to_withdraw = getPurchasedWithdrawableTokens(_purchased_index);\r\n        require(available_to_withdraw > 0, \"OTC: there are no more funds to withdraw\");\r\n\r\n        // withdraw tokens, minus admin commission\r\n        require(IERC20(smart_trades_purchases[_purchased_index].from).transfer(msg.sender, available_to_withdraw), \"OTC: error doing the withdraw\");\r\n\r\n        // update amount withdrawn\r\n        smart_trades_purchases[_purchased_index].withdrawn += available_to_withdraw;\r\n\r\n        emit PurchaseWithdraw (\r\n            _purchased_index,\r\n            smart_trades_purchases[_purchased_index].offer_index,\r\n            available_to_withdraw,\r\n            msg.sender,\r\n            smart_trades_purchases[_purchased_index].from,\r\n            0\r\n        );\r\n\r\n    }\r\n\r\n    // Internal function to return the commission of the buyer considering the staking discount\r\n    function getCommissionBuySender() internal view returns (uint256 commission_buy) {\r\n\r\n        (, uint8 stake_discount_buyer) = stakes.getSmartDiscount(msg.sender);\r\n\r\n        if (stake_discount_buyer > 0) {\r\n            return commission_smart_trades_buy * (100 - stake_discount_buyer) / 100;\r\n        } else {\r\n            return commission_smart_trades_buy;\r\n        }\r\n\r\n    }\r\n\r\n    /**************************************************************************************************\r\n     *\r\n     *   E M E R G E N C Y   F U N C T I O N S\r\n     *\r\n     **************************************************************************************************/\r\n\r\n    /**\r\n     * Pause smart contract trading activity\r\n     */\r\n    function pause() public isOwner {\r\n        paused = true;\r\n    }\r\n\r\n    /**\r\n     * Resume smart contract trading activity\r\n     */\r\n    function unpause() public isOwner {\r\n        paused = false;\r\n    }\r\n\r\n    /**\r\n     * modifier to check if the contract is paused\r\n     */ \r\n    modifier isNotPaused() {\r\n        require(!paused, \"Smart Contract activity is paused\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\nabstract contract OTCChainLinkOracle {\r\n    mapping(uint256 => uint256) public usd_prices;\r\n    mapping(uint256 => uint256) public usd_prices_last;\r\n    function refreshAPIUSDPrice(uint256 _cmc_index) public {}\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_oracle_api\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offer_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount_returned\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"CancelOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"custom_token\",\"type\":\"bool\"}],\"name\":\"NewOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchase_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offer_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"NewPremium\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchase_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offer_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"total_payment\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"NewPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"purchase_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"offer_index\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"admin_commission\",\"type\":\"uint256\"}],\"name\":\"PurchaseWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"USDPriceAggregator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"USDPriceCustomAPI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"USDPriceManualEntry\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_to\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"addOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cmc_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_cmc_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"addTokenData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"buySmartTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"cancelTrade\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_manual_entry_price\",\"type\":\"uint256\"}],\"name\":\"changeTokenPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_i\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"changeTokenStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_commission_smart_trades_sell\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_commission_smart_trades_buy\",\"type\":\"uint16\"}],\"name\":\"commissionSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commission_smart_trades_buy\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commission_smart_trades_sell\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"estimateSmartTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"total_payment\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_aggregator\",\"type\":\"address\"}],\"name\":\"getAggregatorUSDPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getColdUSDPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_purchased_index\",\"type\":\"uint256\"}],\"name\":\"getPurchasedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_purchased_index\",\"type\":\"uint256\"}],\"name\":\"getPurchasedWithdrawableTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getUSDPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracle_api\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner_wallet\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_oracle_api\",\"type\":\"address\"}],\"name\":\"rootSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"smart_trades_purchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"offer_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"paid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"splitEstimateSmartTrade\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"payment\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"commission\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"contract IEVEOTCStakes\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IEVEOTCStakes\",\"name\":\"_stakes\",\"type\":\"address\"}],\"name\":\"stakingContractSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_available\",\"type\":\"uint256\"}],\"name\":\"surplus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_surplus\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_commission_sell\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"token_indexes\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"index\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cmc_index\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"chanlink_aggregator\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"manual_entry_price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_update\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"last_price\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens_enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokens_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trades\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"available\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"filled\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"surplus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"filled_surplus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"discount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"premium\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"custom_token\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"trades_commission_sell\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"trades_length\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"trades_to_query\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"to\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"walletSet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "EVEOTC", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000e829e55cfbf21ac6dc0b8bd29e3a22326d3acd9d000000000000000000000000f733fe63763980bcb192eaf4439e9667319d92fb", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://f3fca19349fe53ceba1a2cead4cb0542845e3ccd90e715318ea1e5a0a55fa940"}