{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/tokens/ORN.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity 0.8.1;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\\n/**\\n * @dev Interface of the ERC2612 standard as defined in the EIP.\\n *\\n * Adds the {permit} method, which can be used to change one's\\n * {IERC20-allowance} without having to send a transaction, by signing a\\n * message. This allows users to spend tokens without having to hold Ether.\\n *\\n * See https://eips.ethereum.org/EIPS/eip-2612.\\n */\\ninterface IERC2612 {\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\\n     * given `owner`'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n}\\n\\n/// @dev Wrapped ERC-20 v10 (WERC10) is an ERC-20 ERC-20 wrapper. You can `deposit` ERC-20 and obtain an WERC10 balance which can then be operated as an ERC-20 token. You can\\n/// `withdraw` ERC-20 from WERC10, which will then burn WERC10 token in your wallet. The amount of WERC10 token in any wallet is always identical to the\\n/// balance of ERC-20 deposited minus the ERC-20 withdrawn with that specific wallet.\\ninterface IWERC10 is IERC20, IERC2612 {\\n\\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WERC10 token,\\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\\n    /// Emits {Approval} event.\\n    /// Returns boolean value indicating whether operation succeeded.\\n    /// For more information on approveAndCall format, see https://github.com/ethereum/EIPs/issues/677.\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external returns (bool);\\n\\n    /// @dev Moves `value` WERC10 token from caller's account to account (`to`),\\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\\n    /// A transfer to `address(0)` triggers an ERC-20 withdraw matching the sent WERC10 token in favor of caller.\\n    /// Emits {Transfer} event.\\n    /// Returns boolean value indicating whether operation succeeded.\\n    /// Requirements:\\n    ///   - caller account must have at least `value` WERC10 token.\\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\\n    function transferAndCall(address to, uint value, bytes calldata data) external returns (bool);\\n}\\n\\ninterface ITransferReceiver {\\n    function onTokenTransfer(address, uint, bytes calldata) external returns (bool);\\n}\\n\\ninterface IApprovalReceiver {\\n    function onTokenApproval(address, uint, bytes calldata) external returns (bool);\\n}\\n\\nlibrary Address {\\n    function isContract(address account) internal view returns (bool) {\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\\n}\\n\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint value) internal {\\n        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    function safeApprove(IERC20 token, address spender, uint value) internal {\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n    function callOptionalReturn(IERC20 token, bytes memory data) private {\\n        require(address(token).isContract(), \\\"SafeERC20: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        require(success, \\\"SafeERC20: low-level call failed\\\");\\n\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\\n/// @dev Wrapped Ether v10 (WERC10) is an Ether (ETH) ERC-20 wrapper. You can `deposit` ETH and obtain an WERC10 balance which can then be operated as an ERC-20 token. You can\\n/// `withdraw` ETH from WERC10, which will then burn WERC10 token in your wallet. The amount of WERC10 token in any wallet is always identical to the\\n/// balance of ETH deposited minus the ETH withdrawn with that specific wallet.\\ncontract ORN is IWERC10 {\\n    using SafeERC20 for IERC20;\\n    string public name;\\n    string public symbol;\\n    uint8  public immutable decimals;\\n\\n    bytes32 public constant PERMIT_TYPEHASH = keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant TRANSFER_TYPEHASH = keccak256(\\\"Transfer(address owner,address to,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public immutable DOMAIN_SEPARATOR;\\n\\n    /// @dev Records amount of WERC10 token owned by account.\\n    mapping (address => uint256) public override balanceOf;\\n    uint256 private _totalSupply;\\n\\n    address private _oldOwner;\\n    address private _newOwner;\\n    uint256 private _newOwnerEffectiveTime;\\n\\n\\n    modifier onlyOwner() {\\n        require(msg.sender == owner(), \\\"only owner\\\");\\n        _;\\n    }\\n\\n    function owner() public view returns (address) {\\n        if (block.timestamp >= _newOwnerEffectiveTime) {\\n            return _newOwner;\\n        }\\n        return _oldOwner;\\n    }\\n\\n\\n    function changeOwner(address newOwner) public onlyOwner returns (bool) {\\n        require(newOwner != address(0), \\\"new owner is the zero address\\\");\\n        _oldOwner = owner();\\n        _newOwner = newOwner;\\n        _newOwnerEffectiveTime = block.timestamp + 2*24*3600;\\n        emit LogChangeOwner(_oldOwner, _newOwner, _newOwnerEffectiveTime);\\n        return true;\\n    }\\n\\n    function mint(address account, uint256 amount) public onlyOwner returns (bool) {\\n        _mint(account, amount);\\n        emit LogMint(account, amount);\\n        return true;\\n    }\\n\\n    function burn(uint256 amount) public returns (bool) {\\n        _burn(msg.sender, amount);\\n        emit LogBurn(msg.sender, amount);\\n        return true;\\n    }\\n\\n    /// @dev Records current ERC2612 nonce for account. This value must be included whenever signature is generated for {permit}.\\n    /// Every successful call to {permit} increases account's nonce by one. This prevents signature from being used multiple times.\\n    mapping (address => uint256) public override nonces;\\n\\n    /// @dev Records number of WERC10 token that account (second) will be allowed to spend on behalf of another account (first) through {transferFrom}.\\n    mapping (address => mapping (address => uint256)) public override allowance;\\n\\n    event LogChangeOwner(address indexed oldOwner, address indexed newOwner, uint indexed effectiveTime);\\n    event LogMint(address indexed account, uint amount);\\n    event LogBurn(address indexed account, uint amount);\\n\\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, address _owner) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        _newOwner = _owner;\\n        _newOwnerEffectiveTime = block.timestamp;\\n\\n        uint256 chainId;\\n        assembly {chainId := chainid()}\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(name)),\\n                keccak256(bytes(\\\"1\\\")),\\n                chainId,\\n                address(this)));\\n    }\\n\\n    /// @dev Returns the total supply of WERC10 token as the ETH held in this contract.\\n    function totalSupply() external view override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _totalSupply += amount;\\n        balanceOf[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        balanceOf[account] -= amount;\\n        _totalSupply -= amount;\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WERC10 token.\\n    /// Emits {Approval} event.\\n    /// Returns boolean value indicating whether operation succeeded.\\n    function approve(address spender, uint256 value) external override returns (bool) {\\n        // _approve(msg.sender, spender, value);\\n        allowance[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n\\n        return true;\\n    }\\n\\n    /// @dev Sets `value` as allowance of `spender` account over caller account's WERC10 token,\\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\\n    /// Emits {Approval} event.\\n    /// Returns boolean value indicating whether operation succeeded.\\n    /// For more information on approveAndCall format, see https://github.com/ethereum/EIPs/issues/677.\\n    function approveAndCall(address spender, uint256 value, bytes calldata data) external override returns (bool) {\\n        // _approve(msg.sender, spender, value);\\n        allowance[msg.sender][spender] = value;\\n        emit Approval(msg.sender, spender, value);\\n\\n        return IApprovalReceiver(spender).onTokenApproval(msg.sender, value, data);\\n    }\\n\\n    /// @dev Sets `value` as allowance of `spender` account over `owner` account's WERC10 token, given `owner` account's signed approval.\\n    /// Emits {Approval} event.\\n    /// Requirements:\\n    ///   - `deadline` must be timestamp in future.\\n    ///   - `v`, `r` and `s` must be valid `secp256k1` signature from `owner` account over EIP712-formatted function arguments.\\n    ///   - the signature must use `owner` account's current nonce (see {nonces}).\\n    ///   - the signer cannot be zero address and must be `owner` account.\\n    /// For more information on signature format, see https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section].\\n    /// WERC10 token implementation adapted from https://github.com/albertocuestacanada/ERC20Permit/blob/master/contracts/ERC20Permit.sol.\\n    function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {\\n        require(block.timestamp <= deadline, \\\"WERC10: Expired permit\\\");\\n\\n        bytes32 hashStruct = keccak256(\\n            abi.encode(\\n                PERMIT_TYPEHASH,\\n                target,\\n                spender,\\n                value,\\n                nonces[target]++,\\n                deadline));\\n\\n        require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\\n\\n        // _approve(owner, spender, value);\\n        allowance[target][spender] = value;\\n        emit Approval(target, spender, value);\\n    }\\n\\n    function transferWithPermit(address target, address to, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external returns (bool) {\\n        require(block.timestamp <= deadline, \\\"WERC10: Expired permit\\\");\\n\\n        bytes32 hashStruct = keccak256(\\n            abi.encode(\\n                TRANSFER_TYPEHASH,\\n                target,\\n                to,\\n                value,\\n                nonces[target]++,\\n                deadline));\\n\\n        require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));\\n\\n        require(to != address(0) || to != address(this));\\n\\n        uint256 balance = balanceOf[target];\\n        require(balance >= value, \\\"WERC10: transfer amount exceeds balance\\\");\\n\\n        balanceOf[target] = balance - value;\\n        balanceOf[to] += value;\\n        emit Transfer(target, to, value);\\n\\n        return true;\\n    }\\n\\n    function verifyEIP712(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {\\n        bytes32 hash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                hashStruct));\\n        address signer = ecrecover(hash, v, r, s);\\n        return (signer != address(0) && signer == target);\\n    }\\n\\n    function verifyPersonalSign(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {\\n        bytes32 hash = prefixed(hashStruct);\\n        address signer = ecrecover(hash, v, r, s);\\n        return (signer != address(0) && signer == target);\\n    }\\n\\n    // Builds a prefixed hash to mimic the behavior of eth_sign.\\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /// @dev Moves `value` WERC10 token from caller's account to account (`to`).\\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WERC10 token in favor of caller.\\n    /// Emits {Transfer} event.\\n    /// Returns boolean value indicating whether operation succeeded.\\n    /// Requirements:\\n    ///   - caller account must have at least `value` WERC10 token.\\n    function transfer(address to, uint256 value) external override returns (bool) {\\n        require(to != address(0) || to != address(this));\\n        uint256 balance = balanceOf[msg.sender];\\n        require(balance >= value, \\\"WERC10: transfer amount exceeds balance\\\");\\n\\n        balanceOf[msg.sender] = balance - value;\\n        balanceOf[to] += value;\\n        emit Transfer(msg.sender, to, value);\\n\\n        return true;\\n    }\\n\\n    /// @dev Moves `value` WERC10 token from account (`from`) to account (`to`) using allowance mechanism.\\n    /// `value` is then deducted from caller account's allowance, unless set to `type(uint256).max`.\\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WERC10 token in favor of caller.\\n    /// Emits {Approval} event to reflect reduced allowance `value` for caller account to spend from account (`from`),\\n    /// unless allowance is set to `type(uint256).max`\\n    /// Emits {Transfer} event.\\n    /// Returns boolean value indicating whether operation succeeded.\\n    /// Requirements:\\n    ///   - `from` account must have at least `value` balance of WERC10 token.\\n    ///   - `from` account must have approved caller to spend at least `value` of WERC10 token, unless `from` and caller are the same account.\\n    function transferFrom(address from, address to, uint256 value) external override returns (bool) {\\n        require(to != address(0) || to != address(this));\\n        if (from != msg.sender) {\\n            // _decreaseAllowance(from, msg.sender, value);\\n            uint256 allowed = allowance[from][msg.sender];\\n            if (allowed != type(uint256).max) {\\n            require(allowed >= value, \\\"WERC10: request exceeds allowance\\\");\\n            uint256 reduced = allowed - value;\\n            allowance[from][msg.sender] = reduced;\\n            emit Approval(from, msg.sender, reduced);\\n            }\\n        }\\n\\n        uint256 balance = balanceOf[from];\\n        require(balance >= value, \\\"WERC10: transfer amount exceeds balance\\\");\\n\\n        balanceOf[from] = balance - value;\\n        balanceOf[to] += value;\\n        emit Transfer(from, to, value);\\n\\n        return true;\\n    }\\n\\n    /// @dev Moves `value` WERC10 token from caller's account to account (`to`),\\n    /// after which a call is executed to an ERC677-compliant contract with the `data` parameter.\\n    /// A transfer to `address(0)` triggers an ETH withdraw matching the sent WERC10 token in favor of caller.\\n    /// Emits {Transfer} event.\\n    /// Returns boolean value indicating whether operation succeeded.\\n    /// Requirements:\\n    ///   - caller account must have at least `value` WERC10 token.\\n    /// For more information on transferAndCall format, see https://github.com/ethereum/EIPs/issues/677.\\n    function transferAndCall(address to, uint value, bytes calldata data) external override returns (bool) {\\n        require(to != address(0) || to != address(this));\\n\\n        uint256 balance = balanceOf[msg.sender];\\n        require(balance >= value, \\\"WERC10: transfer amount exceeds balance\\\");\\n\\n        balanceOf[msg.sender] = balance - value;\\n        balanceOf[to] += value;\\n        emit Transfer(msg.sender, to, value);\\n\\n        return ITransferReceiver(to).onTokenTransfer(msg.sender, value, data);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_decimals\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogBurn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"effectiveTime\",\"type\":\"uint256\"}],\"name\":\"LogChangeOwner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRANSFER_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"transferWithPermit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ORN", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c0000000000000000000000000000000000000000000000000000000000000000800000000000000000000000009af34bf26c2e2930f29ef737ffb49fbb3f1f888000000000000000000000000000000000000000000000000000000000000000e4f72696f6e2050726f746f636f6c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034f524e0000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}