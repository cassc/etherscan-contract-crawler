{"SourceCode": "//SPDX-License-Identifier: MIT\r\npragma solidity 0.8.4;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(\r\n        address sender,\r\n        address recipient,\r\n        uint256 amount\r\n    ) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module which allows children to implement an emergency stop\r\n * mechanism that can be triggered by an authorized account.\r\n *\r\n * This module is used through inheritance. It will make available the\r\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\r\n * the functions of your contract. Note that they will not be pausable by\r\n * simply including this module, only once the modifiers are put in place.\r\n */\r\nabstract contract Pausable is Context {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor() {\r\n        _paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        _requireNotPaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        _requirePaused();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is paused.\r\n     */\r\n    function _requireNotPaused() internal view virtual {\r\n        require(!paused(), \"Pausable: paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the contract is not paused.\r\n     */\r\n    function _requirePaused() internal view virtual {\r\n        require(paused(), \"Pausable: not paused\");\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function _pause() internal virtual whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function _unpause() internal virtual whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title LensportAuction\r\n * @author Lensport + Avo Labs. (Modified auction contract by that was originally written by Avo Labs)\r\n *\r\n **/\r\n\r\ncontract LensportAuction is Ownable, Pausable, ReentrancyGuard {\r\n    // When someone signs a message, the message must include a nonce which is greater\r\n    // than this value. This is to prevent someone from submitting the same signed transacation twice.\r\n    mapping(address => uint256) public sigTransactionNonce;\r\n\r\n    mapping(address => mapping(uint256 => Auction)) public nftContractAuctions;\r\n    //Each Auction is unique to each NFT (contract + id pairing).\r\n    struct Auction {\r\n        // Map token ID to\r\n        uint32 bidIncreasePercentage;\r\n        uint64 auctionEnd;\r\n        uint128 minPrice;\r\n        uint128 buyNowPrice;\r\n        uint128 nftHighestBid;\r\n        address nftHighestBidder;\r\n        address nftSeller;\r\n        address whitelistedBuyer;   // The seller can specify a whitelisted address for a sale (this is effectively a direct sale).\r\n        address nftRecipient;       // The bidder can specify a recipient for the NFT if their bid is successful.\r\n        address ERC20Token;         // The seller can specify an ERC20 token that can be used to bid or purchase the NFT.\r\n        address[] feeRecipients;\r\n        uint32[] feePercentages;\r\n    }\r\n\r\n    mapping(address => mapping(uint256 => mapping(address => Offer))) public nftOffers;\r\n    mapping(address => mapping(address => Offer)) public collectionOffers;\r\n    // Can change how auction is now to be more like original\r\n    struct Offer {\r\n        uint64 expiration;\r\n        uint128 amount;\r\n        address ERC20Token;\r\n    }\r\n\r\n    /*\r\n     * Default values that are used if not specified by the NFT seller.\r\n     */\r\n    uint32 public defaultBidIncreasePercentage;\r\n    uint32 public minimumSettableIncreasePercentage;\r\n    address public defaultERC20Token;\r\n\r\n    address public marketplaceFeeRecipient;\r\n    uint256 public marketplaceFeePercentage;\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551           EVENTS            \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    event NftAuctionCreated(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address nftSeller,\r\n        address erc20Token,\r\n        uint128 minPrice,\r\n        uint128 buyNowPrice,\r\n        uint64 auctionEnd,\r\n        uint32 bidIncreasePercentage,\r\n        address[] feeRecipients,\r\n        uint32[] feePercentages\r\n    );\r\n\r\n    event SaleCreated(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address nftSeller,\r\n        address erc20Token,\r\n        uint128 buyNowPrice,\r\n        address whitelistedBuyer,\r\n        address[] feeRecipients,\r\n        uint32[] feePercentages\r\n    );\r\n\r\n    event BidMade(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address bidder,\r\n        address erc20Token,\r\n        uint256 tokenAmount\r\n    );\r\n\r\n    event OfferMade(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address bidder,\r\n        uint64 expiration,\r\n        uint128 tokenAmount,\r\n        address erc20Token\r\n    );\r\n\r\n    event OfferWithdrawn(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address bidder\r\n    );\r\n\r\n    event OfferTaken(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address nftSeller,\r\n        address nftRecipient,\r\n        uint128 tokenAmount,\r\n        address erc20Token\r\n    );\r\n\r\n    event CollectionOfferMade(\r\n        address nftContractAddress,\r\n        address bidder,\r\n        uint64 expiration,\r\n        uint128 tokenAmount,\r\n        address erc20Token\r\n    );\r\n\r\n    event CollectionOfferWithdrawn(\r\n        address nftContractAddress,\r\n        address bidder\r\n    );\r\n\r\n    event CollectionOfferTaken(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address nftSeller,\r\n        address nftRecipient,\r\n        uint128 tokenAmount,\r\n        address erc20Token\r\n    );\r\n\r\n    event AuctionPeriodUpdated(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        uint64 auctionEndPeriod\r\n    );\r\n\r\n    event NFTTransferredAndSellerPaid(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address nftSeller,\r\n        address erc20Token,\r\n        uint128 nftHighestBid,\r\n        address nftHighestBidder,\r\n        address nftRecipient\r\n    );\r\n\r\n    event AuctionSettled(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address auctionSettler\r\n    );\r\n\r\n    event AuctionWithdrawn(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address nftOwner\r\n    );\r\n\r\n    event BidWithdrawn(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address highestBidder\r\n    );\r\n\r\n    event WhitelistedBuyerUpdated(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        address newWhitelistedBuyer\r\n    );\r\n\r\n    event MinimumPriceUpdated(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        uint256 newMinPrice\r\n    );\r\n\r\n    event BuyNowPriceUpdated(\r\n        address nftContractAddress,\r\n        uint256 tokenId,\r\n        uint128 newBuyNowPrice\r\n    );\r\n    event HighestBidTaken(address nftContractAddress, uint256 tokenId);\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END             \u2551\r\n      \u2551            EVENTS           \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551          MODIFIERS          \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    modifier auctionOngoing(address _nftContractAddress, uint256 _tokenId) {\r\n        require(\r\n            _isAuctionOngoing(_nftContractAddress, _tokenId),\r\n            \"Auction has ended\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier priceGreaterThanZero(uint256 _price) {\r\n        require(_price > 0, \"Price cannot be 0\");\r\n        _;\r\n    }\r\n\r\n    modifier minPriceDoesNotExceedLimit(\r\n        uint128 _buyNowPrice,\r\n        uint128 _minPrice\r\n    ) {\r\n        require(\r\n            _buyNowPrice == 0 || _buyNowPrice >= _minPrice,\r\n            \"MinPrice > buyNowPrice\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier notNftSeller(address _nftContractAddress, uint256 _tokenId) {\r\n        require(\r\n            msg.sender !=\r\n                nftContractAuctions[_nftContractAddress][_tokenId].nftSeller,\r\n            \"Owner cannot bid on own NFT\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyNftSeller(address _nftContractAddress, uint256 _tokenId, address _user) {\r\n        require(_user == nftContractAuctions[_nftContractAddress][_tokenId].nftSeller,\r\n            \"Only nft seller\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyNftOwner(address _nftContractAddress, uint256 _tokenId, address _user) {\r\n        require(IERC721(_nftContractAddress).ownerOf(_tokenId) == _user, \r\n            \"Only nft owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * The bid amount was either equal the buyNowPrice or it must be higher than the previous\r\n     * bid by the specified bid increase percentage.\r\n     */\r\n    modifier bidAmountMeetsBidRequirements(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint128 _tokenAmount\r\n    ) {\r\n        require(\r\n            _doesBidMeetBidRequirements(\r\n                _nftContractAddress,\r\n                _tokenId,\r\n                _tokenAmount\r\n            ),\r\n            \"Not enough funds to bid on NFT\"\r\n        );\r\n        _;\r\n    }\r\n    // check if the highest bidder can purchase this NFT.\r\n    modifier onlyApplicableBuyer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    ) {\r\n        require(\r\n            !_isWhitelistedSale(_nftContractAddress, _tokenId) ||\r\n                nftContractAuctions[_nftContractAddress][_tokenId]\r\n                    .whitelistedBuyer ==\r\n                msg.sender,\r\n            \"Only the whitelisted buyer\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier minimumBidNotMade(address _nftContractAddress, uint256 _tokenId) {\r\n        require(\r\n            !_isMinimumBidMade(_nftContractAddress, _tokenId),\r\n            \"The auction has a valid bid made\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /*\r\n     * Payment is accepted if the payment is made in the ERC20 token specified by the seller.\r\n     * Early bids on NFTs not yet up for auction must be made in ETH.\r\n     */\r\n    modifier paymentAccepted(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _tokenAmount\r\n    ) {\r\n        require(\r\n            _isPaymentAccepted(\r\n                _nftContractAddress,\r\n                _tokenId,\r\n                _erc20Token,\r\n                _tokenAmount\r\n            ),\r\n            \"Bid to be in specified ERC20/Eth\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isAuctionOver(address _nftContractAddress, uint256 _tokenId) {\r\n        require(\r\n            !_isAuctionOngoing(_nftContractAddress, _tokenId),\r\n            \"Auction is not yet over\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier notZeroAddress(address _address) {\r\n        require(_address != address(0), \"Cannot specify 0 address\");\r\n        _;\r\n    }\r\n\r\n    modifier isFeePercentagesLessThanMaximum(uint32[] memory _feePercentages) {\r\n        uint32 totalPercent;\r\n        for (uint256 i = 0; i < _feePercentages.length; i++) {\r\n            totalPercent = totalPercent + _feePercentages[i];\r\n        }\r\n        require(totalPercent <= 10000, \"Fee percentages exceed maximum\");\r\n        _;\r\n    }\r\n\r\n    modifier correctFeeRecipientsAndPercentages(\r\n        uint256 _recipientsLength,\r\n        uint256 _percentagesLength\r\n    ) {\r\n        require(\r\n            _recipientsLength == _percentagesLength,\r\n            \"Recipients != percentages\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier isNotASale(address _nftContractAddress, uint256 _tokenId) {\r\n        require(\r\n            !_isASale(_nftContractAddress, _tokenId),\r\n            \"Not applicable for a sale\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END             \u2551\r\n      \u2551          MODIFIERS          \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n    // constructor\r\n    constructor(address _defaultERC20Token) {\r\n        defaultERC20Token = _defaultERC20Token;\r\n        \r\n        defaultBidIncreasePercentage = 100;\r\n        minimumSettableIncreasePercentage = 100;\r\n    }\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551    AUCTION CHECK FUNCTIONS   \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    function _isAuctionOngoing(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint64 auctionEndTimestamp = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].auctionEnd;\r\n        //if the auctionEnd is set to 0, the auction is technically on-going, however\r\n        //the minimum bid price (minPrice) has not yet been met.\r\n        return (auctionEndTimestamp == 0 ||\r\n            block.timestamp < auctionEndTimestamp);\r\n    }\r\n\r\n    /*\r\n     * Check if a bid has been made. This is applicable in the early bid scenario\r\n     * to ensure that if an auction is created after an early bid, the auction\r\n     * begins appropriately or is settled if the buy now price is met.\r\n     */\r\n    function _isABidMade(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftHighestBid > 0);\r\n    }\r\n\r\n    /*\r\n     *if the minPrice is set by the seller, check that the highest bid meets or exceeds that price.\r\n     */\r\n    function _isMinimumBidMade(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint128 minPrice = nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .minPrice;\r\n        return\r\n            minPrice > 0 &&\r\n            (nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid >=\r\n                minPrice);\r\n    }\r\n\r\n    /*\r\n     * If the buy now price is set by the seller, check that the highest bid meets that price.\r\n     */\r\n    function _isBuyNowPriceMet(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint128 buyNowPrice = nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .buyNowPrice;\r\n        return\r\n            buyNowPrice > 0 &&\r\n            nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid >=\r\n            buyNowPrice;\r\n    }\r\n\r\n    /*\r\n     * Check that a bid is applicable for the purchase of the NFT.\r\n     * In the case of a sale: the bid needs to meet the buyNowPrice.\r\n     * In the case of an auction: the bid needs to be a % higher than the previous bid.\r\n     */\r\n    function _doesBidMeetBidRequirements(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint128 _tokenAmount\r\n    ) internal view returns (bool) {\r\n        uint128 buyNowPrice = nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .buyNowPrice;\r\n        //if buyNowPrice is met, ignore increase percentage\r\n        if (buyNowPrice > 0 && _tokenAmount >= buyNowPrice) {\r\n            return true;\r\n        }\r\n        //if the NFT is up for auction, the bid needs to be a % higher than the previous bid\r\n        uint256 bidIncreaseAmount = (nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBid *\r\n            (10000 +\r\n                _getBidIncreasePercentage(_nftContractAddress, _tokenId))) /\r\n            10000;\r\n        return (_tokenAmount >= bidIncreaseAmount);\r\n    }\r\n\r\n    /*\r\n     * An NFT is up for sale if the buyNowPrice is set, but the minPrice is not set.\r\n     * Therefore the only way to conclude the NFT sale is to meet the buyNowPrice.\r\n     */\r\n    function _isASale(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (nftContractAuctions[_nftContractAddress][_tokenId].buyNowPrice >\r\n            0 &&\r\n            nftContractAuctions[_nftContractAddress][_tokenId].minPrice == 0);\r\n    }\r\n\r\n    function _isWhitelistedSale(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .whitelistedBuyer != address(0));\r\n    }\r\n\r\n    /*\r\n     * The highest bidder is allowed to purchase the NFT if\r\n     * no whitelisted buyer is set by the NFT seller.\r\n     * Otherwise, the highest bidder must equal the whitelisted buyer.\r\n     */\r\n    function _isHighestBidderAllowedToPurchaseNFT(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    ) internal view returns (bool) {\r\n        return\r\n            (!_isWhitelistedSale(_nftContractAddress, _tokenId)) ||\r\n            _isHighestBidderWhitelisted(_nftContractAddress, _tokenId);\r\n    }\r\n\r\n    function _isHighestBidderWhitelisted(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    ) internal view returns (bool) {\r\n        return (nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftHighestBidder ==\r\n            nftContractAuctions[_nftContractAddress][_tokenId]\r\n                .whitelistedBuyer);\r\n    }\r\n\r\n    /**\r\n     * Payment is accepted in the following scenarios:\r\n     * (1) Auction already created - can accept Specified Token\r\n     * (2) Auction not created\r\n     * (3) Cannot make a zero bid (no Token amount)\r\n     */\r\n    function _isPaymentAccepted(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _bidERC20Token,\r\n        uint128 _tokenAmount\r\n    ) internal view returns (bool) {\r\n        address auctionERC20Token = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].ERC20Token;\r\n        return\r\n            msg.value == 0 &&\r\n            auctionERC20Token == _bidERC20Token &&\r\n            _tokenAmount > 0;\r\n    }\r\n\r\n    /*\r\n     * Returns the percentage of the total bid (used to calculate fee payments)\r\n     */\r\n    function _getPortionOfBid(uint256 _totalBid, uint256 _percentage)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (_totalBid * (_percentage)) / 10000;\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551    AUCTION CHECK FUNCTIONS   \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551    DEFAULT GETTER FUNCTIONS  \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /*****************************************************************\r\n     * These functions check if the applicable auction parameter has *\r\n     * been set by the NFT seller. If not, return the default value. *\r\n     *****************************************************************/\r\n\r\n    function _getBidIncreasePercentage(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    ) internal view returns (uint32) {\r\n        uint32 bidIncreasePercentage = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].bidIncreasePercentage;\r\n\r\n        if (bidIncreasePercentage == 0) {\r\n            return defaultBidIncreasePercentage;\r\n        } else {\r\n            return bidIncreasePercentage;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * The default value for the NFT recipient is the highest bidder\r\n     */\r\n    function _getNftRecipient(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n        view\r\n        returns (address)\r\n    {\r\n        address nftRecipient = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftRecipient;\r\n\r\n        if (nftRecipient == address(0)) {\r\n            return\r\n                nftContractAuctions[_nftContractAddress][_tokenId]\r\n                    .nftHighestBidder;\r\n        } else {\r\n            return nftRecipient;\r\n        }\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551    DEFAULT GETTER FUNCTIONS  \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551  TRANSFER NFTS TO CONTRACT   \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    function _transferNftToAuctionContract(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    ) internal {\r\n        address _nftSeller = nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftSeller;\r\n        if (IERC721(_nftContractAddress).ownerOf(_tokenId) == _nftSeller) {\r\n            IERC721(_nftContractAddress).transferFrom(\r\n                _nftSeller,\r\n                address(this),\r\n                _tokenId\r\n            );\r\n            require(\r\n                IERC721(_nftContractAddress).ownerOf(_tokenId) == address(this),\r\n                \"nft transfer failed\"\r\n            );\r\n        } else {\r\n            require(\r\n                IERC721(_nftContractAddress).ownerOf(_tokenId) == address(this),\r\n                \"Seller doesn't own NFT\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551  TRANSFER NFTS TO CONTRACT   \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551       AUCTION CREATION       \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    /**\r\n     * Setup parameters applicable to all auctions and whitelised sales:\r\n     * -> ERC20 Token for payment (if specified by the seller) : _erc20Token\r\n     * -> minimum price : _minPrice\r\n     * -> buy now price : _buyNowPrice\r\n     * -> the nft seller: msg.sender\r\n     * -> The fee recipients & their respective percentages for a sucessful auction/sale\r\n     */\r\n    function _setupAuction(\r\n        address _user,\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _minPrice,\r\n        uint128 _buyNowPrice,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages\r\n    )\r\n        internal\r\n        minPriceDoesNotExceedLimit(_buyNowPrice, _minPrice)\r\n        correctFeeRecipientsAndPercentages(\r\n            _feeRecipients.length,\r\n            _feePercentages.length\r\n        )\r\n        isFeePercentagesLessThanMaximum(_feePercentages)\r\n    {\r\n        if (_erc20Token != address(0)) {\r\n            nftContractAuctions[_nftContractAddress][_tokenId]\r\n                .ERC20Token = _erc20Token;\r\n        }\r\n        else {\r\n            nftContractAuctions[_nftContractAddress][_tokenId]\r\n                .ERC20Token = defaultERC20Token;\r\n        }\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .feeRecipients = _feeRecipients;\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .feePercentages = _feePercentages;\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .buyNowPrice = _buyNowPrice;\r\n        nftContractAuctions[_nftContractAddress][_tokenId].minPrice = _minPrice;\r\n        nftContractAuctions[_nftContractAddress][_tokenId].nftSeller = _user;\r\n    }\r\n\r\n    function _createNewNftAuction(\r\n        address _user,\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _minPrice,\r\n        uint128 _buyNowPrice,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages\r\n    ) internal {\r\n        // Sending the NFT to this contract\r\n        _setupAuction(\r\n            _user,\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _erc20Token,\r\n            _minPrice,\r\n            _buyNowPrice,\r\n            _feeRecipients,\r\n            _feePercentages\r\n        );\r\n        emit NftAuctionCreated(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _user,\r\n            _erc20Token,\r\n            _minPrice,\r\n            _buyNowPrice,\r\n            nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .auctionEnd,\r\n            _getBidIncreasePercentage(_nftContractAddress, _tokenId),\r\n            _feeRecipients,\r\n            _feePercentages\r\n        );\r\n        _updateOngoingAuction(_nftContractAddress, _tokenId);\r\n    }\r\n\r\n    function createNewNftAuction(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _minPrice,\r\n        uint128 _buyNowPrice,\r\n        uint32 _auctionBidPeriod, // How long the auction/buy now lasts.\r\n        uint32 _bidIncreasePercentage,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    )\r\n        external\r\n    {\r\n        require(_minPrice > 0, \"Price cannot be 0\");\r\n        require(\r\n            _bidIncreasePercentage >= minimumSettableIncreasePercentage,\r\n            \"Bid increase percentage too low\"\r\n        );\r\n        require(\r\n            _user == IERC721(_nftContractAddress).ownerOf(_tokenId),\r\n            \"Sender doesn't own NFT\"\r\n        );\r\n\r\n        // There already is an active auction so reset auction and bids.\r\n        if (\r\n            nftContractAuctions[_nftContractAddress][_tokenId].nftSeller != address(0)\r\n        ) {\r\n            _resetAuction(_nftContractAddress, _tokenId);\r\n            _resetBids(_nftContractAddress, _tokenId);\r\n        }\r\n\r\n        verifyUserCreateAuction(_nftContractAddress, _tokenId, _user, _nonce, _sig);\r\n\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .auctionEnd = _auctionBidPeriod + uint64(block.timestamp);\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .bidIncreasePercentage = _bidIncreasePercentage;\r\n        _createNewNftAuction(\r\n            _user,\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _erc20Token,\r\n            _minPrice,\r\n            _buyNowPrice,\r\n            _feeRecipients,\r\n            _feePercentages\r\n        );\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551       AUCTION CREATION       \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551            SALES             \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    /********************************************************************\r\n     * Allows for a standard sale mechanism where the NFT seller can    *\r\n     * can select an address to be whitelisted. This address is then    *\r\n     * allowed to make a bid on the NFT. No other address can bid on    *\r\n     * the NFT.                                                         *\r\n     ********************************************************************/\r\n    function _setupSale(\r\n        address _user,\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _buyNowPrice,\r\n        address _whitelistedBuyer,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages\r\n    )\r\n        internal\r\n        correctFeeRecipientsAndPercentages(\r\n            _feeRecipients.length,\r\n            _feePercentages.length\r\n        )\r\n        isFeePercentagesLessThanMaximum(_feePercentages)\r\n    {\r\n        if (_erc20Token != address(0)) {\r\n            nftContractAuctions[_nftContractAddress][_tokenId]\r\n                .ERC20Token = _erc20Token;\r\n        }\r\n        else {\r\n            nftContractAuctions[_nftContractAddress][_tokenId]\r\n                .ERC20Token = defaultERC20Token;\r\n        }\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .feeRecipients = _feeRecipients;\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .feePercentages = _feePercentages;\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .buyNowPrice = _buyNowPrice;\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .whitelistedBuyer = _whitelistedBuyer;\r\n        nftContractAuctions[_nftContractAddress][_tokenId].nftSeller = _user;\r\n    }\r\n\r\n    function createSale(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _buyNowPrice,\r\n        address _whitelistedBuyer,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    )\r\n        external\r\n        nonReentrant()\r\n        priceGreaterThanZero(_buyNowPrice)\r\n    {\r\n\r\n        verifyUserCreateSale(_nftContractAddress, _tokenId, _user, _nonce, _sig);\r\n\r\n        require(\r\n            (nftContractAuctions[_nftContractAddress][_tokenId].nftSeller != _user || _isAuctionOngoing(_nftContractAddress, _tokenId) == false),\r\n            \"Auction already started by owner\"\r\n        );\r\n        require(\r\n            _user == IERC721(_nftContractAddress).ownerOf(_tokenId),\r\n            \"Sender doesn't own NFT\"\r\n        );\r\n\r\n        if (\r\n            nftContractAuctions[_nftContractAddress][_tokenId].nftSeller != address(0)\r\n        ) {\r\n            _resetAuction(_nftContractAddress, _tokenId);\r\n            _resetBids(_nftContractAddress, _tokenId);\r\n        }\r\n\r\n        _setupSale(\r\n            _user,\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _erc20Token,\r\n            _buyNowPrice,\r\n            _whitelistedBuyer,\r\n            _feeRecipients,\r\n            _feePercentages\r\n        );\r\n\r\n        emit SaleCreated(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _user,\r\n            _erc20Token,\r\n            _buyNowPrice,\r\n            _whitelistedBuyer,\r\n            _feeRecipients,\r\n            _feePercentages\r\n        );\r\n        //check if buyNowPrice is meet and conclude sale, otherwise reverse the early bid\r\n        if (_isABidMade(_nftContractAddress, _tokenId)) {\r\n            if (\r\n                //we only revert the underbid if the seller specifies a different\r\n                //whitelisted buyer to the highest bidder\r\n                _isHighestBidderAllowedToPurchaseNFT(\r\n                    _nftContractAddress,\r\n                    _tokenId\r\n                )\r\n            ) {\r\n                if (_isBuyNowPriceMet(_nftContractAddress, _tokenId)) {\r\n                    _transferNftToAuctionContract(\r\n                        _nftContractAddress,\r\n                        _tokenId\r\n                    );\r\n                    _transferNftAndPaySeller(_nftContractAddress, _tokenId);\r\n                }\r\n            } else {\r\n                _reverseAndResetPreviousBid(_nftContractAddress, _tokenId);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551            SALES             \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551       OFFER FUNCTIONS        \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    function makeOffer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint64 _expiration,\r\n        uint128 _amount,\r\n        address _erc20Token\r\n    )\r\n        external\r\n        notNftSeller(_nftContractAddress, _tokenId)\r\n    {\r\n        require(_amount != 0);\r\n        require(_expiration > block.timestamp);\r\n        require(_erc20Token != address(0));\r\n        nftOffers[_nftContractAddress][_tokenId][msg.sender].expiration = _expiration;\r\n        nftOffers[_nftContractAddress][_tokenId][msg.sender].amount = _amount;\r\n        nftOffers[_nftContractAddress][_tokenId][msg.sender].ERC20Token = _erc20Token;\r\n        emit OfferMade(_nftContractAddress, _tokenId, msg.sender, _expiration, _amount, _erc20Token);\r\n    }\r\n\r\n    function withdrawOffer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    )\r\n        external\r\n    {\r\n        require(nftOffers[_nftContractAddress][_tokenId][msg.sender].amount != 0);\r\n        delete nftOffers[_nftContractAddress][_tokenId][msg.sender];\r\n        emit OfferWithdrawn(_nftContractAddress, _tokenId, msg.sender);\r\n    }\r\n\r\n    function takeOffer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _bidder,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages,\r\n        address _user,\r\n        uint256 _nonce, \r\n        bytes memory _sig\r\n    )\r\n        external\r\n        nonReentrant()\r\n        onlyNftOwner(_nftContractAddress, _tokenId, _user)\r\n    {\r\n        verifyUserTakeOffer(_nftContractAddress, _tokenId, _bidder, _user, _nonce, _sig);\r\n        require(nftOffers[_nftContractAddress][_tokenId][_bidder].expiration >= block.timestamp, \"Offer expired.\");\r\n\r\n        // Can't take an offer if the minimum bid has already been made\r\n        require(!_isMinimumBidMade(_nftContractAddress, _tokenId));\r\n\r\n        IERC721(_nftContractAddress).transferFrom(\r\n            _user,\r\n            _bidder,\r\n            _tokenId\r\n        );\r\n        require(\r\n            IERC721(_nftContractAddress).ownerOf(_tokenId) == _bidder,\r\n            \"nft transfer failed\"\r\n        );\r\n\r\n        uint128 amount = nftOffers[_nftContractAddress][_tokenId][_bidder].amount;\r\n        address erc20Token = nftOffers[_nftContractAddress][_tokenId][_bidder].ERC20Token;\r\n        _payFeesAndSellerForOffer(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _user,\r\n            amount,\r\n            _bidder,\r\n            _feeRecipients,\r\n            _feePercentages\r\n        );\r\n\r\n        delete nftOffers[_nftContractAddress][_tokenId][_bidder];\r\n        _resetBids(_nftContractAddress, _tokenId);\r\n        _resetAuction(_nftContractAddress, _tokenId);\r\n\r\n        emit OfferTaken(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _user,\r\n            _bidder,\r\n            amount,\r\n            erc20Token\r\n        );\r\n    }\r\n\r\n    function makeCollectionOffer(\r\n        address _nftContractAddress,\r\n        uint64 _expiration,\r\n        uint128 _amount,\r\n        address _erc20Token\r\n    )\r\n        external\r\n    {\r\n        require(_amount != 0);\r\n        require(_expiration > block.timestamp);\r\n        require(_erc20Token != address(0));\r\n        collectionOffers[_nftContractAddress][msg.sender].expiration = _expiration;\r\n        collectionOffers[_nftContractAddress][msg.sender].amount = _amount;\r\n        collectionOffers[_nftContractAddress][msg.sender].ERC20Token = _erc20Token;\r\n        emit CollectionOfferMade(_nftContractAddress, msg.sender, _expiration, _amount, _erc20Token);\r\n    }\r\n\r\n    function withdrawCollectionOffer(\r\n        address _nftContractAddress\r\n    )\r\n        external\r\n    {\r\n        require(collectionOffers[_nftContractAddress][msg.sender].amount != 0);\r\n        delete collectionOffers[_nftContractAddress][msg.sender];\r\n        emit CollectionOfferWithdrawn(_nftContractAddress, msg.sender);\r\n    }\r\n\r\n    function takeCollectionOffer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _bidder,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages,\r\n        address _user,\r\n        uint256 _nonce, \r\n        bytes memory _sig\r\n    )\r\n        external\r\n        nonReentrant()\r\n        onlyNftOwner(_nftContractAddress, _tokenId, _user)\r\n    {\r\n        verifyUserTakeCollectionOffer(_nftContractAddress, _tokenId, _bidder, _user, _nonce, _sig);\r\n        require(collectionOffers[_nftContractAddress][_bidder].expiration >= block.timestamp, \"Offer expired.\");\r\n\r\n        // Can't take an offer if the minimum bid has already been made on an active auction\r\n        require(!_isMinimumBidMade(_nftContractAddress, _tokenId));\r\n\r\n        IERC721(_nftContractAddress).transferFrom(\r\n            _user,\r\n            _bidder,\r\n            _tokenId\r\n        );\r\n        require(\r\n            IERC721(_nftContractAddress).ownerOf(_tokenId) == _bidder,\r\n            \"nft transfer failed\"\r\n        );\r\n\r\n        uint128 amount = collectionOffers[_nftContractAddress][_bidder].amount;\r\n        address erc20Token = collectionOffers[_nftContractAddress][_bidder].ERC20Token;\r\n        _payFeesAndSellerForCollectionOffer(\r\n            _nftContractAddress,\r\n            _user,\r\n            amount,\r\n            _bidder,\r\n            _feeRecipients,\r\n            _feePercentages\r\n        );\r\n\r\n        delete collectionOffers[_nftContractAddress][_bidder];\r\n        _resetBids(_nftContractAddress, _tokenId);\r\n        _resetAuction(_nftContractAddress, _tokenId);\r\n\r\n        emit OfferTaken(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _user,\r\n            _bidder,\r\n            amount,\r\n            erc20Token\r\n        );\r\n        emit CollectionOfferTaken(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _user,\r\n            _bidder,\r\n            amount,\r\n            erc20Token\r\n        );\r\n    }\r\n\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551            OFFER             \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551        BID FUNCTIONS        \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    /********************************************************************\r\n     * Make bids with an ERC20 Token specified by the NFT seller.*\r\n     * Additionally, a buyer can pay the asking price to conclude a sale*\r\n     * of an NFT.                                                      *\r\n     ********************************************************************/\r\n\r\n    function _makeBid(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _tokenAmount\r\n    )\r\n        internal\r\n        notNftSeller(_nftContractAddress, _tokenId)\r\n        paymentAccepted(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _erc20Token,\r\n            _tokenAmount\r\n        )\r\n        bidAmountMeetsBidRequirements(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _tokenAmount\r\n        )\r\n    {\r\n        _reversePreviousBidAndUpdateHighestBid(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _tokenAmount\r\n        );\r\n        emit BidMade(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            msg.sender,\r\n            _erc20Token,\r\n            _tokenAmount\r\n        );\r\n        _updateOngoingAuction(_nftContractAddress, _tokenId);\r\n    }\r\n\r\n    function makeBid(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _tokenAmount\r\n    )\r\n        external\r\n        auctionOngoing(_nftContractAddress, _tokenId)\r\n        onlyApplicableBuyer(_nftContractAddress, _tokenId)\r\n    {\r\n        _makeBid(_nftContractAddress, _tokenId, _erc20Token, _tokenAmount);\r\n    }\r\n\r\n    function makeCustomBid(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _erc20Token,\r\n        uint128 _tokenAmount,\r\n        address _nftRecipient\r\n    )\r\n        external\r\n        auctionOngoing(_nftContractAddress, _tokenId)\r\n        notZeroAddress(_nftRecipient)\r\n        onlyApplicableBuyer(_nftContractAddress, _tokenId)\r\n    {\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftRecipient = _nftRecipient;\r\n        _makeBid(_nftContractAddress, _tokenId, _erc20Token, _tokenAmount);\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551        BID FUNCTIONS         \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551       UPDATE AUCTION         \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    /***************************************************************\r\n     * Settle an auction or sale if the buyNowPrice is met or set  *\r\n     *  auction period to begin if the minimum price has been met. *\r\n     ***************************************************************/\r\n    function _updateOngoingAuction(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    ) \r\n        internal \r\n        nonReentrant()\r\n    {\r\n        if (_isBuyNowPriceMet(_nftContractAddress, _tokenId)) {\r\n            _transferNftToAuctionContract(_nftContractAddress, _tokenId);\r\n            _transferNftAndPaySeller(_nftContractAddress, _tokenId);\r\n            return;\r\n        }\r\n        //min price not set, nft not up for auction yet\r\n        if (_isMinimumBidMade(_nftContractAddress, _tokenId)) {\r\n            _transferNftToAuctionContract(_nftContractAddress, _tokenId);\r\n            _updateAuctionEnd(_nftContractAddress, _tokenId);\r\n        }\r\n    }\r\n\r\n    function _updateAuctionEnd(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n    {\r\n        // The auction length is set if it hasn't been set yet.\r\n        if (nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd < uint64(block.timestamp) + 600 && \r\n            nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd != 0\r\n        ) {\r\n            // In last 10 minutes, extend it by another 10 if a bid is made.\r\n            nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd += 600;\r\n        }\r\n        \r\n        emit AuctionPeriodUpdated(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd\r\n        );\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551       UPDATE AUCTION         \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551       RESET FUNCTIONS        \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    /*\r\n     * Reset all auction related parameters for an NFT.\r\n     * This effectively removes an NFT as an item up for auction\r\n     */\r\n    function _resetAuction(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n    {\r\n        nftContractAuctions[_nftContractAddress][_tokenId].minPrice = 0;\r\n        nftContractAuctions[_nftContractAddress][_tokenId].buyNowPrice = 0;\r\n        nftContractAuctions[_nftContractAddress][_tokenId].auctionEnd = 0;\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .bidIncreasePercentage = 0;\r\n        nftContractAuctions[_nftContractAddress][_tokenId].nftSeller = address(\r\n            0\r\n        );\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .whitelistedBuyer = address(0);\r\n        nftContractAuctions[_nftContractAddress][_tokenId].ERC20Token = address(\r\n            0\r\n        );\r\n    }\r\n\r\n    /*\r\n     * Reset all bid related parameters for an NFT.\r\n     * This effectively sets an NFT as having no active bids.\r\n     */\r\n    function _resetBids(address _nftContractAddress, uint256 _tokenId)\r\n        internal\r\n    {\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftHighestBidder = address(0);\r\n        nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid = 0;\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftRecipient = address(0);\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551       RESET FUNCTIONS        \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551         UPDATE BIDS          \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /******************************************************************\r\n     * Internal functions that update bid parameters and reverse bids *\r\n     * to ensure contract only holds the highest bid.                 *\r\n     ******************************************************************/\r\n    function _updateHighestBid(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint128 _tokenAmount\r\n    ) internal {\r\n        address auctionERC20Token = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].ERC20Token;\r\n        IERC20(auctionERC20Token).transferFrom(\r\n            msg.sender,\r\n            address(this),\r\n            _tokenAmount\r\n        );\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftHighestBid = _tokenAmount;\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftHighestBidder = msg.sender;\r\n    }\r\n\r\n    function _reverseAndResetPreviousBid(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    ) internal {\r\n        address nftHighestBidder = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBidder;\r\n\r\n        uint128 nftHighestBid = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBid;\r\n        _resetBids(_nftContractAddress, _tokenId);\r\n\r\n        _payout(_nftContractAddress, _tokenId, nftHighestBidder, nftHighestBid);\r\n    }\r\n\r\n    function _reversePreviousBidAndUpdateHighestBid(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint128 _tokenAmount\r\n    ) internal {\r\n        address prevNftHighestBidder = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBidder;\r\n\r\n        uint256 prevNftHighestBid = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBid;\r\n        _updateHighestBid(_nftContractAddress, _tokenId, _tokenAmount);\r\n\r\n        if (prevNftHighestBidder != address(0)) {\r\n            _payout(\r\n                _nftContractAddress,\r\n                _tokenId,\r\n                prevNftHighestBidder,\r\n                prevNftHighestBid\r\n            );\r\n        }\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551         UPDATE BIDS          \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551  TRANSFER NFT & PAY SELLER   \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    function _transferNftAndPaySeller(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId\r\n    ) \r\n        internal \r\n    {\r\n        address _nftSeller = nftContractAuctions[_nftContractAddress][_tokenId].nftSeller;\r\n        address _nftHighestBidder = nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBidder;\r\n        address _nftRecipient = _getNftRecipient(_nftContractAddress, _tokenId);\r\n        uint128 _nftHighestBid = nftContractAuctions[_nftContractAddress][_tokenId].nftHighestBid;\r\n        address _erc20Token = nftContractAuctions[_nftContractAddress][_tokenId].ERC20Token;\r\n        _resetBids(_nftContractAddress, _tokenId);\r\n\r\n        _payFeesAndSeller(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _nftSeller,\r\n            _nftHighestBid\r\n        );\r\n        IERC721(_nftContractAddress).transferFrom(\r\n            address(this),\r\n            _nftRecipient,\r\n            _tokenId\r\n        );\r\n\r\n        _resetAuction(_nftContractAddress, _tokenId);\r\n        emit NFTTransferredAndSellerPaid(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _nftSeller,\r\n            _erc20Token,\r\n            _nftHighestBid,\r\n            _nftHighestBidder,\r\n            _nftRecipient\r\n        );\r\n    }\r\n\r\n    function _payFeesAndSeller(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _nftSeller,\r\n        uint256 _highestBid\r\n    ) \r\n        internal \r\n    {\r\n        uint256 feesPaid;\r\n        for (\r\n            uint256 i = 0;\r\n            i <\r\n            nftContractAuctions[_nftContractAddress][_tokenId]\r\n                .feeRecipients\r\n                .length;\r\n            i++\r\n        ) {\r\n            uint256 fee = _getPortionOfBid(\r\n                _highestBid,\r\n                nftContractAuctions[_nftContractAddress][_tokenId]\r\n                    .feePercentages[i]\r\n            );\r\n            feesPaid = feesPaid + fee;\r\n            _payout(\r\n                _nftContractAddress,\r\n                _tokenId,\r\n                nftContractAuctions[_nftContractAddress][_tokenId]\r\n                    .feeRecipients[i],\r\n                fee\r\n            );\r\n        }\r\n        if (marketplaceFeePercentage != 0) {\r\n            uint256 marketplaceFee = _getPortionOfBid(\r\n                _highestBid,\r\n                marketplaceFeePercentage\r\n            );\r\n            feesPaid = feesPaid + marketplaceFee;\r\n            _payout(\r\n                _nftContractAddress,\r\n                _tokenId,\r\n                marketplaceFeeRecipient,\r\n                marketplaceFee\r\n            );\r\n        }\r\n        _payout(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _nftSeller,\r\n            (_highestBid - feesPaid)\r\n        );\r\n    }\r\n\r\n    function _payout(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _recipient,\r\n        uint256 _amount\r\n    ) internal {\r\n        address auctionERC20Token = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].ERC20Token;\r\n        IERC20(auctionERC20Token).transfer(_recipient, _amount);\r\n    }\r\n\r\n    function _offerPayout(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _recipient,\r\n        uint256 _amount,\r\n        address _bidder\r\n    ) internal {\r\n        address offerERC20Token = nftOffers[_nftContractAddress][_tokenId][_bidder].ERC20Token;\r\n        IERC20(offerERC20Token).transferFrom(_bidder, _recipient, _amount);\r\n    }\r\n\r\n    function _payFeesAndSellerForOffer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _nftSeller,\r\n        uint256 _offerAmount,\r\n        address _bidder,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages\r\n    ) \r\n        internal \r\n    {\r\n        uint256 feesPaid;\r\n        for (uint256 i = 0; i < _feeRecipients.length; i++ ) {\r\n            uint256 fee = _getPortionOfBid(\r\n                _offerAmount,\r\n                _feePercentages[i]\r\n            );\r\n            feesPaid = feesPaid + fee;\r\n            _offerPayout(\r\n                _nftContractAddress,\r\n                _tokenId,\r\n                _feeRecipients[i],\r\n                fee,\r\n                _bidder\r\n            );\r\n        }\r\n        if (marketplaceFeePercentage != 0) {\r\n            uint256 marketplaceFee = _getPortionOfBid(\r\n                _offerAmount,\r\n                marketplaceFeePercentage\r\n            );\r\n            feesPaid = feesPaid + marketplaceFee;\r\n            _offerPayout(\r\n                _nftContractAddress,\r\n                _tokenId,\r\n                marketplaceFeeRecipient,\r\n                marketplaceFee,\r\n                _bidder\r\n            );\r\n        }\r\n        _offerPayout(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _nftSeller,\r\n            (_offerAmount - feesPaid),\r\n            _bidder\r\n        );\r\n    }\r\n\r\n    function _collectionOfferPayout(\r\n        address _nftContractAddress,\r\n        address _recipient,\r\n        uint256 _amount,\r\n        address _bidder\r\n    ) internal {\r\n        address offerERC20Token = collectionOffers[_nftContractAddress][_bidder].ERC20Token;\r\n        IERC20(offerERC20Token).transferFrom(_bidder, _recipient, _amount);\r\n    }\r\n    \r\n    function _payFeesAndSellerForCollectionOffer(\r\n        address _nftContractAddress,\r\n        address _nftSeller,\r\n        uint256 _offerAmount,\r\n        address _bidder,\r\n        address[] memory _feeRecipients,\r\n        uint32[] memory _feePercentages\r\n    ) \r\n        internal \r\n    {\r\n        uint256 feesPaid;\r\n        for (uint256 i = 0; i < _feeRecipients.length; i++ ) {\r\n            uint256 fee = _getPortionOfBid(\r\n                _offerAmount,\r\n                _feePercentages[i]\r\n            );\r\n            feesPaid = feesPaid + fee;\r\n            _collectionOfferPayout(\r\n                _nftContractAddress,\r\n                _feeRecipients[i],\r\n                fee,\r\n                _bidder\r\n            );\r\n        }\r\n        if (marketplaceFeePercentage != 0) {\r\n            uint256 marketplaceFee = _getPortionOfBid(\r\n                _offerAmount,\r\n                marketplaceFeePercentage\r\n            );\r\n            feesPaid = feesPaid + marketplaceFee;\r\n            _collectionOfferPayout(\r\n                _nftContractAddress,\r\n                marketplaceFeeRecipient,\r\n                marketplaceFee,\r\n                _bidder\r\n            );\r\n        }\r\n        _collectionOfferPayout(\r\n            _nftContractAddress,\r\n            _nftSeller,\r\n            (_offerAmount - feesPaid),\r\n            _bidder\r\n        );\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551  TRANSFER NFT & PAY SELLER   \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551      SETTLE & WITHDRAW       \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    function settleAuction(address _nftContractAddress, uint256 _tokenId)\r\n        external\r\n        nonReentrant()\r\n        isAuctionOver(_nftContractAddress, _tokenId)\r\n    {\r\n        _transferNftAndPaySeller(_nftContractAddress, _tokenId);\r\n        emit AuctionSettled(_nftContractAddress, _tokenId, msg.sender);\r\n    }\r\n\r\n    function withdrawAuction(address _nftContractAddress, uint256 _tokenId, address _user, uint256 _nonce, bytes memory _sig)\r\n        external\r\n    {\r\n        verifyUserWithdrawAuction(_nftContractAddress, _tokenId, _user, _nonce, _sig);\r\n\r\n        //only the NFT owner can prematurely close and auction\r\n        require(\r\n            IERC721(_nftContractAddress).ownerOf(_tokenId) == _user,\r\n            \"Not NFT owner\"\r\n        );\r\n        _resetAuction(_nftContractAddress, _tokenId);\r\n        _resetBids(_nftContractAddress, _tokenId);\r\n        emit AuctionWithdrawn(_nftContractAddress, _tokenId, _user);\r\n    }\r\n\r\n    function withdrawBid(address _nftContractAddress, uint256 _tokenId)\r\n        external\r\n        minimumBidNotMade(_nftContractAddress, _tokenId)\r\n    {\r\n        address nftHighestBidder = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBidder;\r\n        require(msg.sender == nftHighestBidder, \"Cannot withdraw funds\");\r\n\r\n        uint128 nftHighestBid = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBid;\r\n        _resetBids(_nftContractAddress, _tokenId);\r\n\r\n        _payout(_nftContractAddress, _tokenId, nftHighestBidder, nftHighestBid);\r\n\r\n        emit BidWithdrawn(_nftContractAddress, _tokenId, msg.sender);\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551      SETTLE & WITHDRAW       \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551       UPDATE AUCTION         \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    function updateWhitelistedBuyer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _newWhitelistedBuyer,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) external onlyNftSeller(_nftContractAddress, _tokenId, _user) {\r\n        require(_isASale(_nftContractAddress, _tokenId), \"Not a sale\");\r\n\r\n        verifyUserUpdateWhitelistedBuyer(_nftContractAddress, _tokenId, _newWhitelistedBuyer, _user, _nonce, _sig);\r\n\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .whitelistedBuyer = _newWhitelistedBuyer;\r\n        // If an underbid is by a non whitelisted buyer, reverse that bid\r\n        address nftHighestBidder = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBidder;\r\n        uint128 nftHighestBid = nftContractAuctions[_nftContractAddress][\r\n            _tokenId\r\n        ].nftHighestBid;\r\n        if (nftHighestBid > 0 && !(nftHighestBidder == _newWhitelistedBuyer)) {\r\n            //we only revert the underbid if the seller specifies a different\r\n            //whitelisted buyer to the highest bider\r\n\r\n            _resetBids(_nftContractAddress, _tokenId);\r\n\r\n            _payout(\r\n                _nftContractAddress,\r\n                _tokenId,\r\n                nftHighestBidder,\r\n                nftHighestBid\r\n            );\r\n        }\r\n\r\n        emit WhitelistedBuyerUpdated(\r\n            _nftContractAddress,\r\n            _tokenId,\r\n            _newWhitelistedBuyer\r\n        );\r\n    }\r\n\r\n    function updateMinimumPrice(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint128 _newMinPrice,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    )\r\n        external\r\n        onlyNftSeller(_nftContractAddress, _tokenId, _user)\r\n        minimumBidNotMade(_nftContractAddress, _tokenId)\r\n        minPriceDoesNotExceedLimit(\r\n            nftContractAuctions[_nftContractAddress][_tokenId].buyNowPrice,\r\n            _newMinPrice\r\n        )\r\n    {\r\n        require(_newMinPrice > 0, \"Price cannot be 0\");\r\n        require(\r\n            !_isASale(_nftContractAddress, _tokenId),\r\n            \"Not applicable for a sale\"\r\n        );\r\n\r\n        verifyUserUpdateMinimumPrice(_nftContractAddress, _tokenId, _newMinPrice, _user, _nonce, _sig);\r\n\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .minPrice = _newMinPrice;\r\n\r\n        emit MinimumPriceUpdated(_nftContractAddress, _tokenId, _newMinPrice);\r\n\r\n        if (_isMinimumBidMade(_nftContractAddress, _tokenId)) {\r\n            _transferNftToAuctionContract(_nftContractAddress, _tokenId);\r\n            _updateAuctionEnd(_nftContractAddress, _tokenId);\r\n        }\r\n    }\r\n\r\n    function updateBuyNowPrice(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint128 _newBuyNowPrice,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    )\r\n        external\r\n        nonReentrant()\r\n        onlyNftSeller(_nftContractAddress, _tokenId, _user)\r\n        priceGreaterThanZero(_newBuyNowPrice)\r\n        minPriceDoesNotExceedLimit(\r\n            _newBuyNowPrice,\r\n            nftContractAuctions[_nftContractAddress][_tokenId].minPrice\r\n        )\r\n    {\r\n        verifyUserUpdateBuyNowPrice(_nftContractAddress, _tokenId, _newBuyNowPrice, _user, _nonce, _sig);\r\n        nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .buyNowPrice = _newBuyNowPrice;\r\n        emit BuyNowPriceUpdated(_nftContractAddress, _tokenId, _newBuyNowPrice);\r\n        if (_isBuyNowPriceMet(_nftContractAddress, _tokenId)) {\r\n            _transferNftToAuctionContract(_nftContractAddress, _tokenId);\r\n            _transferNftAndPaySeller(_nftContractAddress, _tokenId);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * The NFT seller can opt to end an auction by taking the current highest bid.\r\n     */\r\n    function takeHighestBid(\r\n            address _nftContractAddress, \r\n            uint256 _tokenId, \r\n            address _user,\r\n            uint256 _nonce, \r\n            bytes memory _sig\r\n        )\r\n        external\r\n        nonReentrant()\r\n        onlyNftSeller(_nftContractAddress, _tokenId, _user)\r\n    {\r\n        verifyUserTakeHighestBid(_nftContractAddress, _tokenId, _user, _nonce, _sig);\r\n        require(\r\n            _isABidMade(_nftContractAddress, _tokenId),\r\n            \"cannot payout 0 bid\"\r\n        );\r\n        _transferNftToAuctionContract(_nftContractAddress, _tokenId);\r\n        _transferNftAndPaySeller(_nftContractAddress, _tokenId);\r\n        emit HighestBidTaken(_nftContractAddress, _tokenId);\r\n    }\r\n\r\n    /*\r\n     * Query the owner of an NFT deposited for auction\r\n     */\r\n    function ownerOfNFT(address _nftContractAddress, uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (address)\r\n    {\r\n        address nftSeller = nftContractAuctions[_nftContractAddress][_tokenId]\r\n            .nftSeller;\r\n        require(nftSeller != address(0), \"NFT not deposited\");\r\n\r\n        return nftSeller;\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551       UPDATE AUCTION         \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n           SIGNATURE VERIFICATION    \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n\r\n    function recover(bytes32 hash, bytes memory sig) public pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        //Check the signature length\r\n        if (sig.length != 65) {\r\n        return (address(0));\r\n        }\r\n\r\n        // Divide the signature in r, s and v variables\r\n        assembly {\r\n        r := mload(add(sig, 32))\r\n        s := mload(add(sig, 64))\r\n        v := byte(0, mload(add(sig, 96)))\r\n        }\r\n\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n        v += 27;\r\n        }\r\n\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            return ecrecover(hash, v, r, s);\r\n        }\r\n    }\r\n\r\n    function verifyUserCreateAuction(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashCreateAuctionTransaction(address(this), _nftContractAddress, _tokenId, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    function verifyUserCreateSale(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashCreateSaleTransaction(address(this), _nftContractAddress, _tokenId, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    function verifyUserWithdrawAuction(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashWithdrawAuctionTransaction(address(this), _nftContractAddress, _tokenId, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    function verifyUserUpdateWhitelistedBuyer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _newWhitelistedBuyer,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashUpdateWhitelistedBuyerTransaction(address(this), _nftContractAddress, _tokenId, _newWhitelistedBuyer, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    function verifyUserUpdateMinimumPrice(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint128 _newMinPrice,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashUpdateMinimumPriceTransaction(address(this), _nftContractAddress, _tokenId, _newMinPrice, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    function verifyUserUpdateBuyNowPrice(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        uint128 _newBuyNowPrice,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashUpdateBuyNowPriceTransaction(address(this), _nftContractAddress, _tokenId, _newBuyNowPrice, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    function verifyUserTakeHighestBid(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashTakeHighestBidTransaction(address(this), _nftContractAddress, _tokenId, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    function verifyUserTakeOffer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _bidder,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashTakeOfferTransaction(address(this), _nftContractAddress, _tokenId, _bidder, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    function verifyUserTakeCollectionOffer(\r\n        address _nftContractAddress,\r\n        uint256 _tokenId,\r\n        address _bidder,\r\n        address _user,\r\n        uint256 _nonce,\r\n        bytes memory _sig\r\n    ) internal\r\n    {\r\n        if (_sig.length > 0) {\r\n            address signer = recover(HashTransaction.hashTakeCollectionOfferTransaction(address(this), _nftContractAddress, _tokenId, _bidder, _user, _nonce), _sig);\r\n            require(_nonce > sigTransactionNonce[signer], \"NonceErr\");\r\n            sigTransactionNonce[signer] = _nonce;\r\n            require(signer == _user, \"ApproveErr1\");\r\n        }\r\n        else {\r\n            require(msg.sender == _user, \"ApproveErr2\");\r\n        }\r\n    }\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551             END              \u2551\r\n      \u2551   Signature  Verification    \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    /**********************************/\r\n    /*\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\r\n      \u2551    Set Contract Defaults     \u2551\r\n      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d*/\r\n    /**********************************/\r\n\r\n    function setDefaultERC20Token(address defaultTokenAddress) public onlyOwner\r\n    {\r\n        defaultERC20Token = defaultTokenAddress;\r\n    }\r\n\r\n    function setMarketplaceFeeRecipient(address recipient) public onlyOwner\r\n    {\r\n        marketplaceFeeRecipient = recipient;\r\n    }\r\n\r\n    function setMarketplaceFeePercentage(uint256 feePercentage) public onlyOwner\r\n    {\r\n        marketplaceFeePercentage = feePercentage;\r\n    }   \r\n}\r\n\r\nlibrary HashTransaction {\r\n    bytes32 private constant EIP712_DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\r\n    bytes32 private constant CREATE_AUCTION_TYPEHASH = keccak256(\"CreateAuction(address nftContractAddress,uint256 tokenId,address user,uint256 nonce)\");\r\n    bytes32 private constant CREATE_SALE_TYPEHASH = keccak256(\"CreateSale(address nftContractAddress,uint256 tokenId,address user,uint256 nonce)\");\r\n    bytes32 private constant WITHDRAW_AUCTION_TYPEHASH = keccak256(\"WithdrawAuction(address nftContractAddress,uint256 tokenId,address user,uint256 nonce)\");\r\n    bytes32 private constant UPDATE_WHITELISTED_BUYER_TYPEHASH = keccak256(\"UpdateWhitelistedBuyer(address nftContractAddress,uint256 tokenId,address newWhitelistedBuyer,address user,uint256 nonce)\");\r\n    bytes32 private constant UPDATE_MINIMUM_PRICE_TYPEHASH = keccak256(\"UpdateMinimumPrice(address nftContractAddress,uint256 tokenId,uint128 newMinPrice,address user,uint256 nonce)\");\r\n    bytes32 private constant UPDATE_BUY_NOW_PRICE_TYPEHASH = keccak256(\"UpdateBuyNowPrice(address nftContractAddress,uint256 tokenId,uint128 newBuyNowPrice,address user,uint256 nonce)\");\r\n    bytes32 private constant TAKE_HIGHEST_BID_TYPEHASH = keccak256(\"TakeHighestBid(address nftContractAddress,uint256 tokenId,address user,uint256 nonce)\");\r\n    bytes32 private constant TAKE_OFFER_TYPEHASH = keccak256(\"TakeOffer(address nftContractAddress,uint256 tokenId,address bidder,address user,uint256 nonce)\");\r\n    bytes32 private constant TAKE_COLLECTION_OFFER_TYPEHASH = keccak256(\"TakeCollectionOffer(address nftContractAddress,uint256 tokenId,address bidder,address user,uint256 nonce)\");\r\n    uint256 constant chainId = 137;\r\n\r\n    function getDomainSeperator(address verifyingContract) public pure returns (bytes32) {\r\n        bytes32 DOMAIN_SEPARATOR = keccak256(abi.encode(\r\n                EIP712_DOMAIN_TYPEHASH,\r\n                keccak256(bytes(\"Lensport Marketplace Domain\")),    // name\r\n                keccak256(bytes(\"7\")),                              // version\r\n                chainId,\r\n                verifyingContract\r\n            ));\r\n        return DOMAIN_SEPARATOR;\r\n    }\r\n\r\n    function hashCreateAuctionTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(CREATE_AUCTION_TYPEHASH, nftContractAddress, tokenId, user, nonce))));\r\n    }\r\n\r\n    function hashCreateSaleTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(CREATE_SALE_TYPEHASH, nftContractAddress, tokenId, user, nonce))));\r\n    }\r\n\r\n    function hashWithdrawAuctionTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(WITHDRAW_AUCTION_TYPEHASH, nftContractAddress, tokenId, user, nonce))));\r\n    }\r\n\r\n    function hashUpdateWhitelistedBuyerTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, address newWhitelistedBuyer, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(UPDATE_WHITELISTED_BUYER_TYPEHASH, nftContractAddress, tokenId, newWhitelistedBuyer, user, nonce))));\r\n    }\r\n\r\n    function hashUpdateMinimumPriceTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, uint128 newMinPrice, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(UPDATE_MINIMUM_PRICE_TYPEHASH, nftContractAddress, tokenId, newMinPrice, user, nonce))));\r\n    }\r\n\r\n    function hashUpdateBuyNowPriceTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, uint128 newBuyNowPrice, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(UPDATE_BUY_NOW_PRICE_TYPEHASH, nftContractAddress, tokenId, newBuyNowPrice, user, nonce))));\r\n    }\r\n\r\n    function hashTakeHighestBidTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(TAKE_HIGHEST_BID_TYPEHASH, nftContractAddress, tokenId, user, nonce))));\r\n    }\r\n\r\n    function hashTakeOfferTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, address bidder, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(TAKE_OFFER_TYPEHASH, nftContractAddress, tokenId, bidder, user, nonce))));\r\n    }\r\n\r\n    function hashTakeCollectionOfferTransaction(address verifyingContract, address nftContractAddress, uint256 tokenId, address bidder, address user, uint256 nonce) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", getDomainSeperator(verifyingContract), keccak256(abi.encode(TAKE_COLLECTION_OFFER_TYPEHASH, nftContractAddress, tokenId, bidder, user, nonce))));\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultERC20Token\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"auctionEndPeriod\",\"type\":\"uint64\"}],\"name\":\"AuctionPeriodUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"auctionSettler\",\"type\":\"address\"}],\"name\":\"AuctionSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftOwner\",\"type\":\"address\"}],\"name\":\"AuctionWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"BidMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"highestBidder\",\"type\":\"address\"}],\"name\":\"BidWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"newBuyNowPrice\",\"type\":\"uint128\"}],\"name\":\"BuyNowPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"tokenAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"}],\"name\":\"CollectionOfferMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftSeller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"tokenAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"}],\"name\":\"CollectionOfferTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"CollectionOfferWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"HighestBidTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newMinPrice\",\"type\":\"uint256\"}],\"name\":\"MinimumPriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftSeller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"nftHighestBid\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftHighestBidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftRecipient\",\"type\":\"address\"}],\"name\":\"NFTTransferredAndSellerPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftSeller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"minPrice\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"buyNowPrice\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"auctionEnd\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"bidIncreasePercentage\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"feeRecipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"feePercentages\",\"type\":\"uint32[]\"}],\"name\":\"NftAuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"tokenAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"}],\"name\":\"OfferMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftSeller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftRecipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"tokenAmount\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"}],\"name\":\"OfferTaken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"}],\"name\":\"OfferWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftSeller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"erc20Token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint128\",\"name\":\"buyNowPrice\",\"type\":\"uint128\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"whitelistedBuyer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"feeRecipients\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint32[]\",\"name\":\"feePercentages\",\"type\":\"uint32[]\"}],\"name\":\"SaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"nftContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newWhitelistedBuyer\",\"type\":\"address\"}],\"name\":\"WhitelistedBuyerUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collectionOffers\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_minPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"_buyNowPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint32\",\"name\":\"_auctionBidPeriod\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_bidIncreasePercentage\",\"type\":\"uint32\"},{\"internalType\":\"address[]\",\"name\":\"_feeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_feePercentages\",\"type\":\"uint32[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"createNewNftAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_buyNowPrice\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_whitelistedBuyer\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_feeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_feePercentages\",\"type\":\"uint32[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"createSale\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultBidIncreasePercentage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultERC20Token\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_tokenAmount\",\"type\":\"uint128\"}],\"name\":\"makeBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"_expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_erc20Token\",\"type\":\"address\"}],\"name\":\"makeCollectionOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_erc20Token\",\"type\":\"address\"},{\"internalType\":\"uint128\",\"name\":\"_tokenAmount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_nftRecipient\",\"type\":\"address\"}],\"name\":\"makeCustomBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"_expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"_amount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_erc20Token\",\"type\":\"address\"}],\"name\":\"makeOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplaceFeePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"marketplaceFeeRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minimumSettableIncreasePercentage\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftContractAuctions\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"bidIncreasePercentage\",\"type\":\"uint32\"},{\"internalType\":\"uint64\",\"name\":\"auctionEnd\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"minPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"buyNowPrice\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"nftHighestBid\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"nftHighestBidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftSeller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"whitelistedBuyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nftOffers\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"expiration\",\"type\":\"uint64\"},{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"ERC20Token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOfNFT\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"hash\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defaultTokenAddress\",\"type\":\"address\"}],\"name\":\"setDefaultERC20Token\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feePercentage\",\"type\":\"uint256\"}],\"name\":\"setMarketplaceFeePercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setMarketplaceFeeRecipient\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"settleAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"sigTransactionNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bidder\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_feeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_feePercentages\",\"type\":\"uint32[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"takeCollectionOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"takeHighestBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_bidder\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_feeRecipients\",\"type\":\"address[]\"},{\"internalType\":\"uint32[]\",\"name\":\"_feePercentages\",\"type\":\"uint32[]\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"takeOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_newBuyNowPrice\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"updateBuyNowPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"_newMinPrice\",\"type\":\"uint128\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"updateMinimumPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_newWhitelistedBuyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"updateWhitelistedBuyer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"withdrawAuction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawBid\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"}],\"name\":\"withdrawCollectionOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_nftContractAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"withdrawOffer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "LensportAuction", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270", "EVMVersion": "Default", "Library": "HashTransaction:fc3083f3b29e66fab69417da0dee2c14aaf73f77", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://dfad7c81fc8793af71286a19fa28969b424b93d4dbc6ef009bb69ba794c1b7df"}