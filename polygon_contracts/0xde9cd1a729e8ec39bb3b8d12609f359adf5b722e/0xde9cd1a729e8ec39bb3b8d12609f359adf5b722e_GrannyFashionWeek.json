{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/GrannyFashionWeek.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\n// author: backside.\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\"; // Import Ownable\\n\\nimport \\\"@openzeppelin/contracts/token/ERC721/IERC721.sol\\\"; // Import the IERC721 interface\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\"; // Import the ERC20 interface\\n\\ncontract GrannyFashionWeek is Ownable {\\n\\n    // Set Internal Variable for the Grannies Contract Address\\n    address internal _grannyContractAddress = 0xf1083498A5513fcD17a27809C9A669C2ED6B1e74;\\n\\n    // Create Private Instance for Granny Contract Address\\n    IERC721 private _grannyContractInstance = IERC721(_grannyContractAddress);\\n\\n    // Struct that Keeps All Important data of the Current Fashion Show\\n    struct FashionShowData {\\n        uint256 ticketPrice;\\n        address ticketPaymentCurrency;\\n        uint256 showStartsAt;\\n        uint256 showEndsAt;\\n        uint256[] allGranniesAtTheShow;\\n        uint256[] granniesThatVoted;\\n    }\\n\\n    // Set Public Variable to Access and Store Fashion Show Data in\\n    FashionShowData public currentFashionShow;\\n\\n    // Keep Track of each Grannies' hasVoted Status\\n    mapping(uint256 => bool) public hasGrannyVoted;\\n\\n    // Keep Count of how Many Votes each Granny Received\\n    mapping(uint256 => uint256) public voteCountByGrannyId;\\n\\n    // Create Public Variable for Winning Grannies (multiple grannies if tie)\\n    uint256[] public winningGranniesOfPreviousShow;\\n\\n    // Create Public Array for Winning Wallets (multiple wallets if tie)\\n    address[] public winningWalletsOfPreviousShow;\\n\\n    // Empty Constructor\\n    constructor() {}\\n\\n    // External Function to be Called By Contract Owner to Organize a Fashion Show\\n    function organizeFashionShow(address _paymentAddress, uint256 _ticketPrice, uint256 _fashionShowDurationInSeconds) external onlyOwner {\\n\\n        // Check if Previous Show ended\\n        require(block.timestamp > currentFashionShow.showEndsAt, \\\"There is a Fashion Show already Going on..\\\");\\n\\n        // Store Event Data\\n        currentFashionShow = FashionShowData({\\n            ticketPrice: _ticketPrice,\\n            ticketPaymentCurrency: _paymentAddress,\\n            showStartsAt: block.timestamp,\\n            showEndsAt: block.timestamp + _fashionShowDurationInSeconds,\\n            allGranniesAtTheShow: new uint256[](0), // Empty Array\\n            granniesThatVoted: new uint256[](0) // Empty Array\\n        });\\n    }\\n\\n    // External Function for Granny Holders to Send their Grannies to the Fashion Show\\n    function enterFashionShow(uint256[] memory _grannyIds) external {\\n\\n        // Check if Show is Active\\n        require(block.timestamp < currentFashionShow.showEndsAt, \\\"You can't enter after the Show has Already Ended..\\\");\\n        require(block.timestamp > currentFashionShow.showStartsAt, \\\"You can't enter before the Show has Started..\\\");\\n\\n        // Loop over GrannyIds Array to see if Caller Owns all Grannies\\n        for (uint i = 0; i < _grannyIds.length; i++) {\\n\\n            // Check if Caller Owns Each Granny\\n            require(msg.sender == _grannyContractInstance.ownerOf(_grannyIds[i]), \\\"You Don't Own the Granny that you want to Enter the Show with..\\\");\\n        }\\n\\n        // Create Instance for ERC20 Payment Token\\n        IERC20 _paymentCurrencyInstance = IERC20(currentFashionShow.ticketPaymentCurrency);\\n        \\n        // Calculate Payment for (all) Ticket(s)\\n        uint256 _ticketPriceTotal = currentFashionShow.ticketPrice * _grannyIds.length;\\n\\n        // Check if Payment Transfer Succeeded\\n        require(_paymentCurrencyInstance.transferFrom(msg.sender, owner(), _ticketPriceTotal), \\\"Payment to Enter Fashion Show Failed..\\\");\\n\\n        // Loop over Grannies Array to Send them to the Show\\n        for (uint i = 0; i < _grannyIds.length; i++) {\\n\\n            // Add each Granny to the GranniesAtTheShow Array\\n            currentFashionShow.allGranniesAtTheShow.push(_grannyIds[i]);\\n        }        \\n    }\\n\\n    // External Function for People to Vote on Grannies during the Show\\n    function voteForGranny(uint256[] memory _votingGrannyIds, uint256 _bestDressedGranny) external {\\n\\n        // Check if Show is Active\\n        require(block.timestamp < currentFashionShow.showEndsAt, \\\"You can't Vote after the Show has Already Ended..\\\");\\n        require(block.timestamp > currentFashionShow.showStartsAt, \\\"You can't Vote before the Show has Started..\\\");\\n\\n        // Check if the Granny they to Vote for is At the Show\\n        require(checkIfGrannyIsAtTheShow(_bestDressedGranny), \\\"The Granny you want to Cast your Vote for is not on the Catwalk..\\\");\\n\\n        // Loop over _votingGrannyIds Array to Check whether Caller owns Them and to see if They can Vote\\n        for (uint i = 0; i < _votingGrannyIds.length; i++) {\\n\\n            // Check if Granny is in GranniesYetToVote Array\\n            require(!hasGrannyVoted[_votingGrannyIds[i]], \\\"This Granny has Already Voted..\\\");\\n\\n            // Check if Caller owns this Granny - Indirectly checks if Granny Exists too\\n            require(msg.sender == _grannyContractInstance.ownerOf(_votingGrannyIds[i]), \\\"You Don't Own the Granny you want to Vote with..\\\");\\n\\n            // Check if the Granny doesn't try to Vote for Herself\\n            require((_bestDressedGranny != _votingGrannyIds[i]), \\\"Your Granny can't Vote for Herself..\\\");\\n\\n            // Update hasGrannyVoted Mapping for Granny in Question\\n            hasGrannyVoted[_votingGrannyIds[i]] = true;\\n\\n            // Add each Granny to the GranniesAtTheShow Array\\n            currentFashionShow.granniesThatVoted.push(_votingGrannyIds[i]);\\n        }\\n\\n        // Add Votes to voteCount of best Dressed Granny\\n        voteCountByGrannyId[_bestDressedGranny] += _votingGrannyIds.length;\\n    }\\n\\n    // Private Function that Checks if the Granny that the User wants to vote for is Present at the Catwalk\\n    function checkIfGrannyIsAtTheShow(uint256 _grannyWeWantToVoteFor) private view returns (bool) {\\n\\n        // Loop over allGranniesAtTheShow to see if Granny that we Want to vote in is Signed up and on the Catwalk\\n        for (uint i = 0; i < currentFashionShow.allGranniesAtTheShow.length; i++) {\\n\\n            // Wait until we Encounter the Granny in the List\\n            if (_grannyWeWantToVoteFor == currentFashionShow.allGranniesAtTheShow[i]) {\\n\\n                // Return True\\n                return true;\\n            }\\n        }\\n\\n        // Return False\\n        return false;\\n\\n    }\\n\\n\\n    // External Function for Owner to Call and End the Current Fashion Show\\n    function shutDownFashionShow() external onlyOwner {\\n\\n        // 0. Make sure Fashion show has Ended\\n        require(block.timestamp > currentFashionShow.showEndsAt, \\\"Current Show is still Active\\\");\\n\\n        // 1. Loop over allGranniesAtTheShow\\n        for (uint i = 0; i < currentFashionShow.allGranniesAtTheShow.length; i++) {\\n\\n            // 1.1 Reset each Grannies voteStatus to false\\n            hasGrannyVoted[currentFashionShow.allGranniesAtTheShow[i]] = false;\\n        }\\n\\n        // 3. Get and Store the Winners Data\\n        returnGrannyWithMostVotes();\\n\\n        \\n        // 2. Loop over all existing GrannyIds to reset their received voteCounts\\n        for (uint256 i = 1; i <= 990; i++) {\\n\\n            // 2.1 Reset receivedVotes for all existing Grannies\\n            voteCountByGrannyId[i] = 0;\\n        }\\n    }\\n\\n    // Public Function to Identifies and Returns the Grannies with their Respective Wallets that won the Show\\n    function returnGrannyWithMostVotes() private {\\n\\n        // Initialize Function Variables\\n        uint256 biggestVoteCount = 0;\\n        uint256[] memory winningGrannies;\\n        address[] memory winningWallets;\\n\\n        // Loop Over all Grannies at The Show\\n        for (uint i = 0; i < currentFashionShow.allGranniesAtTheShow.length; i++) {\\n\\n            // Get Respective Granny Id and her VoteCount\\n            uint256 grannyId = currentFashionShow.allGranniesAtTheShow[i];\\n            uint256 voteCountOfThisGranny = voteCountByGrannyId[grannyId];\\n\\n            // Check if this Grannies Vote Count Exceeds Previously Biggest voteCount\\n            if (voteCountOfThisGranny > biggestVoteCount) {\\n\\n                // Reset Biggest voteCount\\n                biggestVoteCount = voteCountOfThisGranny;\\n\\n                // Reset List Length\\n                winningGrannies = new uint256[](1);\\n                winningWallets = new address[](1);\\n\\n                // Add this Granny to the List\\n                winningGrannies[0] = grannyId;\\n\\n                // Add this Grannies Owner to the List\\n                winningWallets[0] = _grannyContractInstance.ownerOf(grannyId);\\n\\n            // Check if we Found a Granny with Similar voteCount\\n            } else if (voteCountOfThisGranny == biggestVoteCount) {\\n\\n                // Get Current Length of winningGrannies\\n                uint256 arrayLength = winningGrannies.length;\\n\\n                // Update Length of Array\\n                uint256[] memory updatedWinningGrannies = new uint256[](arrayLength + 1);\\n                address[] memory updatedWinningWallets = new address[](arrayLength + 1);\\n\\n                // Loop over updatedWinningGrannies Array to Append its\\n                for (uint j = 0; j < arrayLength; j++) {\\n\\n                    // Copy Values from Old Array\\n                    updatedWinningGrannies[j] = winningGrannies[j];\\n                    updatedWinningWallets[j] = winningWallets[j];\\n                }\\n\\n                // Update Last Added Granny\\n                updatedWinningGrannies[arrayLength] = grannyId;\\n\\n                // Update Last Added Wallet\\n                updatedWinningWallets[arrayLength] = _grannyContractInstance.ownerOf(grannyId);\\n\\n\\n                // Copy new Values over to Old Arrays\\n                winningGrannies = updatedWinningGrannies;\\n                winningWallets = updatedWinningWallets;\\n            }\\n        }\\n\\n        // Store the Values\\n        winningGranniesOfPreviousShow = winningGrannies;\\n        winningWalletsOfPreviousShow = winningWallets;\\n    }\\n\\n\\n    // Public Function to see All Grannies Participating at the Show\\n    function returnGranniesAtTheShow() public view returns (uint256[] memory) {\\n\\n        // Return Grannies at the Show\\n        return currentFashionShow.allGranniesAtTheShow;\\n    }\\n\\n    // Public Function to Get Event Data\\n    function returnFashionShowInformation() public view returns (FashionShowData memory) {\\n\\n        // Return\\n        return currentFashionShow;\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"currentFashionShow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ticketPaymentCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"showStartsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"showEndsAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_grannyIds\",\"type\":\"uint256[]\"}],\"name\":\"enterFashionShow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"hasGrannyVoted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fashionShowDurationInSeconds\",\"type\":\"uint256\"}],\"name\":\"organizeFashionShow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnFashionShowInformation\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ticketPrice\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"ticketPaymentCurrency\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"showStartsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"showEndsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"allGranniesAtTheShow\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"granniesThatVoted\",\"type\":\"uint256[]\"}],\"internalType\":\"struct GrannyFashionWeek.FashionShowData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"returnGranniesAtTheShow\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"shutDownFashionShow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voteCountByGrannyId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_votingGrannyIds\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_bestDressedGranny\",\"type\":\"uint256\"}],\"name\":\"voteForGranny\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winningGranniesOfPreviousShow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winningWalletsOfPreviousShow\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "GrannyFashionWeek", "CompilerVersion": "v0.8.9+commit.e5eed63a", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}