{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/templates/ERC20TemplateEnterprise.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\nimport \\\"../interfaces/IERC721Template.sol\\\";\\nimport \\\"../interfaces/IERC20Template.sol\\\";\\nimport \\\"../interfaces/IFactoryRouter.sol\\\";\\nimport \\\"../interfaces/IFixedRateExchange.sol\\\";\\nimport \\\"../interfaces/IDispenser.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\nimport \\\"../utils/ERC20Roles.sol\\\";\\n\\n/**\\n * @title DatatokenTemplate\\n *\\n * @dev ERC20TemplateEnterprise is an ERC20 compliant token template\\n *      Used by the factory contract as a bytecode reference to\\n *      deploy new Datatokens.\\n * IMPORTANT CHANGES:\\n *  - buyFromFreAndOrder function:  one call to buy a DT from the minting capable FRE, startOrder and burn the DT\\n *  - buyFromDispenserAndOrder function:  one call to fetch a DT from the Dispenser, startOrder and burn the DT\\n *  - creation of pools is not allowed\\n */\\ncontract ERC20TemplateEnterprise is\\n    ERC20(\\\"test\\\", \\\"testSymbol\\\"),\\n    ERC20Roles,\\n    ERC20Burnable,\\n    ReentrancyGuard\\n{\\n    using SafeMath for uint256;\\n    using SafeERC20 for IERC20;\\n    string private _name;\\n    string private _symbol;\\n    uint256 private _cap;\\n    uint8 private constant _decimals = 18;\\n    bool private initialized = false;\\n    address private _erc721Address;\\n    address private paymentCollector;\\n    address private publishMarketFeeAddress;\\n    address private publishMarketFeeToken;\\n    uint256 private publishMarketFeeAmount;\\n    \\n    uint256 public constant BASE = 1e18;\\n    \\n\\n    // EIP 2612 SUPPORT\\n    bytes32 public DOMAIN_SEPARATOR;\\n    // keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\n    mapping(address => uint256) public nonces;\\n    address public router;\\n    \\n    struct fixedRate{\\n        address contractAddress;\\n        bytes32 id;\\n    }\\n    fixedRate[] fixedRateExchanges;\\n    address[] dispensers;\\n\\n    struct providerFee{\\n        address providerFeeAddress;\\n        address providerFeeToken; // address of the token \\n        uint256 providerFeeAmount; // amount to be transfered to provider\\n        uint8 v; // v of provider signed message\\n        bytes32 r; // r of provider signed message\\n        bytes32 s; // s of provider signed message\\n        uint256 validUntil; //validity expresses in unix timestamp\\n        bytes providerData; //data encoded by provider   \\n    }\\n\\n    struct consumeMarketFee{\\n        address consumeMarketFeeAddress;\\n        address consumeMarketFeeToken; // address of the token marketplace wants to add fee on top\\n        uint256 consumeMarketFeeAmount; // amount to be transfered to marketFeeCollector\\n    }\\n\\n    event OrderStarted(\\n        address indexed consumer,\\n        address payer,\\n        uint256 amount,\\n        uint256 serviceIndex,\\n        uint256 timestamp,\\n        address indexed publishMarketAddress,\\n        uint256 blockNumber\\n    );\\n\\n    event OrderReused(\\n            bytes32 orderTxId,\\n            address caller,\\n            uint256 timestamp,\\n            uint256 number\\n    );\\n\\n    event OrderExecuted( \\n        address indexed providerAddress,\\n        address indexed consumerAddress,\\n        bytes32 orderTxId,\\n        bytes providerData,\\n        bytes providerSignature,\\n        bytes consumerData,\\n        bytes consumerSignature,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n    \\n    // emited for every order\\n    event PublishMarketFee(\\n        address indexed PublishMarketFeeAddress,\\n        address indexed PublishMarketFeeToken,\\n        uint256 PublishMarketFeeAmount\\n    );\\n\\n    // emited for every order\\n    event ConsumeMarketFee(\\n        address indexed consumeMarketFeeAddress,\\n        address indexed consumeMarketFeeToken,\\n        uint256 consumeMarketFeeAmount\\n    );\\n\\n    event PublishMarketFeeChanged(\\n        address caller,\\n        address PublishMarketFeeAddress,\\n        address PublishMarketFeeToken,\\n        uint256 PublishMarketFeeAmount\\n    );\\n\\n    event ProviderFee(\\n        address indexed providerFeeAddress,\\n        address indexed providerFeeToken, \\n        uint256 providerFeeAmount,\\n        bytes providerData,\\n        uint8 v, \\n        bytes32 r, \\n        bytes32 s,\\n        uint256 validUntil\\n    );\\n\\n    event MinterProposed(address currentMinter, address newMinter);\\n\\n    event MinterApproved(address currentMinter, address newMinter);\\n\\n    event NewFixedRate(bytes32 exchangeId, address indexed owner, address exchangeContract, address indexed baseToken);\\n    event NewDispenser(address dispenserContract);\\n    \\n    event NewPaymentCollector(\\n        address indexed caller,\\n        address indexed _newPaymentCollector,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n\\n    modifier onlyNotInitialized() {\\n        require(\\n            !initialized,\\n            \\\"ERC20Template: token instance already initialized\\\"\\n        );\\n        _;\\n    }\\n    modifier onlyNFTOwner() {\\n        require(\\n            msg.sender == IERC721Template(_erc721Address).ownerOf(1),\\n            \\\"ERC20Template: not NFTOwner\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyPublishingMarketFeeAddress() {\\n        require(\\n            msg.sender == publishMarketFeeAddress,\\n            \\\"ERC20Template: not publishMarketFeeAddress\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier onlyERC20Deployer() {\\n        require(\\n            IERC721Template(_erc721Address)\\n                .getPermissions(msg.sender)\\n                .deployERC20 || IERC721Template(_erc721Address).ownerOf(1) == msg.sender,\\n            \\\"ERC20Template: NOT DEPLOYER ROLE\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * @dev initialize\\n     *      Called prior contract initialization (e.g creating new Datatoken instance)\\n     *      Calls private _initialize function. Only if contract is not initialized.\\n     * @param strings_ refers to an array of strings\\n     *                      [0] = name token\\n     *                      [1] = symbol\\n     * @param addresses_ refers to an array of addresses passed by user\\n     *                     [0]  = minter account who can mint datatokens (can have multiple minters)\\n     *                     [1]  = paymentCollector initial paymentCollector for this DT\\n     *                     [2]  = publishing Market Address\\n     *                     [3]  = publishing Market Fee Token\\n     * @param factoryAddresses_ refers to an array of addresses passed by the factory\\n     *                     [0]  = erc721Address\\n     *                     [1]  = router address\\n     *\\n     * @param uints_  refers to an array of uints\\n     *                     [0] = cap_ the total ERC20 cap\\n     *                     [1] = publishing Market Fee Amount\\n     * @param bytes_  refers to an array of bytes\\n     *                     Currently not used, usefull for future templates\\n     */\\n    function initialize(\\n        string[] calldata strings_,\\n        address[] calldata addresses_,\\n        address[] calldata factoryAddresses_,\\n        uint256[] calldata uints_,\\n        bytes[] calldata bytes_\\n    ) external onlyNotInitialized returns (bool) {\\n        return\\n            _initialize(\\n                strings_,\\n                addresses_,\\n                factoryAddresses_,\\n                uints_,\\n                bytes_\\n            );\\n    }\\n\\n    /**\\n     * @dev _initialize\\n     *      Private function called on contract initialization.\\n     * @param strings_ refers to an array of strings\\n     *                      [0] = name token\\n     *                      [1] = symbol\\n     * @param addresses_ refers to an array of addresses passed by user\\n     *                     [0]  = minter account who can mint datatokens (can have multiple minters)\\n     *                     [1]  = paymentCollector initial paymentCollector for this DT\\n     *                     [2]  = publishing Market Address\\n     *                     [3]  = publishing Market Fee Token\\n     * @param factoryAddresses_ refers to an array of addresses passed by the factory\\n     *                     [0]  = erc721Address\\n     *                     [1]  = router address\\n     *\\n     * @param uints_  refers to an array of uints\\n     *                     [0] = cap_ the total ERC20 cap\\n     *                     [1] = publishing Market Fee Amount\\n     * param bytes_  refers to an array of bytes\\n     *                     Currently not used, usefull for future templates\\n     */\\n    function _initialize(\\n        string[] memory strings_,\\n        address[] memory addresses_,\\n        address[] memory factoryAddresses_,\\n        uint256[] memory uints_,\\n        bytes[] memory\\n    ) private returns (bool) {\\n        address erc721Address = factoryAddresses_[0];\\n        router = factoryAddresses_[1];\\n        require(\\n            erc721Address != address(0),\\n            \\\"ERC20Template: Invalid minter,  zero address\\\"\\n        );\\n\\n        require(\\n            router != address(0),\\n            \\\"ERC20Template: Invalid router, zero address\\\"\\n        );\\n\\n        require(uints_[0] != 0, \\\"DatatokenTemplate: Invalid cap value\\\");\\n        _cap = uints_[0];\\n        _name = strings_[0];\\n        _symbol = strings_[1];\\n        _erc721Address = erc721Address;\\n        \\n        initialized = true;\\n        // add a default minter, similar to what happens with manager in the 721 contract\\n        _addMinter(addresses_[0]);\\n        if (addresses_[1] != address(0)) {\\n            _setPaymentCollector(addresses_[1]);\\n            emit NewPaymentCollector(\\n                msg.sender,\\n                addresses_[1],\\n                block.timestamp,\\n                block.number\\n            );\\n        }\\n        publishMarketFeeAddress = addresses_[2];\\n        publishMarketFeeToken = addresses_[3];\\n        publishMarketFeeAmount = uints_[1];\\n        emit PublishMarketFeeChanged(\\n            msg.sender,\\n            publishMarketFeeAddress,\\n            publishMarketFeeToken,\\n            publishMarketFeeAmount\\n        );\\n        uint256 chainId;\\n        assembly {\\n            chainId := chainid()\\n        }\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\n                    \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n                ),\\n                keccak256(bytes(_name)),\\n                keccak256(bytes(\\\"1\\\")), // version, could be any other value\\n                chainId,\\n                address(this)\\n            )\\n        );\\n\\n        return initialized;\\n    }\\n\\n    /**\\n     * @dev createFixedRate\\n     *      Creates a new FixedRateExchange setup.\\n     * @param fixedPriceAddress fixedPriceAddress\\n     * @param addresses array of addresses [baseToken,owner,marketFeeCollector]\\n     * @param uints array of uints [baseTokenDecimals,datatokenDecimals, fixedRate, marketFee, withMint]\\n     * @return exchangeId\\n     */\\n    function createFixedRate(\\n        address fixedPriceAddress,\\n        address[] memory addresses,\\n        uint256[] memory uints\\n    ) external onlyERC20Deployer nonReentrant returns (bytes32 exchangeId) {\\n        //force FRE allowedSwapper to this contract address. no one else can swap\\n        addresses[3] = address(this);\\n        if (uints[4] > 0) _addMinter(fixedPriceAddress);\\n        exchangeId = IFactoryRouter(router).deployFixedRate(\\n            fixedPriceAddress,\\n            addresses,\\n            uints\\n        );\\n        emit NewFixedRate(exchangeId, addresses[1], fixedPriceAddress, addresses[0]);\\n        fixedRateExchanges.push(fixedRate(fixedPriceAddress,exchangeId));\\n    }\\n\\n    /**\\n     * @dev createDispenser\\n     *      Creates a new Dispenser\\n     * @param _dispenser dispenser contract address\\n     * @param maxTokens - max tokens to dispense\\n     * @param maxBalance - max balance of requester.\\n     * @param withMint - with MinterRole\\n     * param allowedSwapper have it here for compat reasons, will be overwritten\\n     */\\n    function createDispenser(\\n        address _dispenser,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        bool withMint,\\n        address\\n    ) external onlyERC20Deployer nonReentrant {\\n        // add dispenser contract as minter if withMint == true\\n        if (withMint) _addMinter(_dispenser);\\n        dispensers.push(_dispenser);\\n        emit NewDispenser(_dispenser);\\n        IFactoryRouter(router).deployDispenser(\\n            _dispenser,\\n            address(this),\\n            maxTokens,\\n            maxBalance,\\n            msg.sender,\\n            address(this)\\n        );\\n    }\\n\\n    /**\\n     * @dev mint\\n     *      Only the minter address can call it.\\n     *      msg.value should be higher than zero and gt or eq minting fee\\n     * @param account refers to an address that token is going to be minted to.\\n     * @param value refers to amount of tokens that is going to be minted.\\n     */\\n    function mint(address account, uint256 value) external {\\n        require(permissions[msg.sender].minter, \\\"ERC20Template: NOT MINTER\\\");\\n        require(\\n            totalSupply().add(value) <= _cap,\\n            \\\"DatatokenTemplate: cap exceeded\\\"\\n        );\\n        _mint(account, value);\\n    }\\n\\n    /**\\n     * @dev _checkProviderFee\\n     *      Checks if a providerFee structure is valid, signed and \\n     *      transfers fee to providerAddress\\n     * @param _providerFee providerFee structure\\n     */\\n    function _checkProviderFee(providerFee calldata _providerFee) internal{\\n        // check if they are signed\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n        bytes32 message = keccak256(\\n            abi.encodePacked(prefix,\\n                keccak256(\\n                    abi.encodePacked(\\n                        _providerFee.providerData,\\n                        _providerFee.providerFeeAddress,\\n                        _providerFee.providerFeeToken,\\n                        _providerFee.providerFeeAmount,\\n                        _providerFee.validUntil\\n                    )\\n                )\\n            )\\n        );\\n        address signer = ecrecover(message, _providerFee.v, _providerFee.r, _providerFee.s);\\n        require(signer == _providerFee.providerFeeAddress, \\\"Invalid provider fee\\\");\\n        emit ProviderFee(\\n            _providerFee.providerFeeAddress,\\n            _providerFee.providerFeeToken,\\n            _providerFee.providerFeeAmount,\\n            _providerFee.providerData,\\n            _providerFee.v,\\n            _providerFee.r,\\n            _providerFee.s,\\n            _providerFee.validUntil\\n        );\\n        // skip fee if amount == 0 or feeToken == 0x0 address or feeAddress == 0x0 address\\n        // Requires approval for the providerFeeToken of providerFeeAmount\\n        if (\\n            _providerFee.providerFeeAmount > 0 &&\\n            _providerFee.providerFeeToken != address(0) &&\\n            _providerFee.providerFeeAddress != address(0)\\n        ) {\\n            uint256 OPCFee = IFactoryRouter(router).getOPCProviderFee();\\n            uint256 OPCcut = 0;\\n            if(OPCFee > 0)\\n                OPCcut = _providerFee.providerFeeAmount.mul(OPCFee).div(BASE);\\n            uint256 providerCut = _providerFee.providerFeeAmount.sub(OPCcut);\\n            _pullUnderlying(_providerFee.providerFeeToken,msg.sender,\\n                address(this),\\n                _providerFee.providerFeeAmount);\\n            IERC20(_providerFee.providerFeeToken).safeTransfer(\\n                _providerFee.providerFeeAddress,\\n                providerCut\\n            );\\n            if(OPCcut > 0){\\n              IERC20(_providerFee.providerFeeToken).safeTransfer(\\n                IFactoryRouter(router).getOPCCollector(),\\n                OPCcut\\n            );  \\n            }\\n        }\\n    }\\n    /**\\n     * @dev startOrder\\n     *      called by payer or consumer prior ordering a service consume on a marketplace.\\n     *      Requires previous approval of consumeFeeToken and publishMarketFeeToken\\n     * @param consumer is the consumer address (payer could be different address)\\n     * @param serviceIndex service index in the metadata\\n     * @param _providerFee provider fee\\n     * @param _consumeMarketFee consume market fee\\n     */\\n    function startOrder(\\n        address consumer,\\n        uint256 serviceIndex,\\n        providerFee calldata _providerFee,\\n        consumeMarketFee calldata _consumeMarketFee\\n    ) public {\\n        uint256 amount = 1e18; // we always pay 1 DT. No more, no less\\n        require(\\n            balanceOf(msg.sender) >= amount,\\n            \\\"Not enough datatokens to start Order\\\"\\n        );\\n        emit OrderStarted(\\n            consumer,\\n            msg.sender,\\n            amount,\\n            serviceIndex,\\n            block.timestamp,\\n            publishMarketFeeAddress,\\n            block.number\\n        );\\n        // publishMarketFee\\n        // Requires approval for the publishMarketFeeToken of publishMarketFeeAmount\\n        // skip fee if amount == 0 or feeToken == 0x0 address or feeAddress == 0x0 address\\n        if (\\n            publishMarketFeeAmount > 0 &&\\n            publishMarketFeeToken != address(0) &&\\n            publishMarketFeeAddress != address(0)\\n        ) {\\n            _pullUnderlying(publishMarketFeeToken,msg.sender,\\n                publishMarketFeeAddress,\\n                publishMarketFeeAmount);\\n            emit PublishMarketFee(\\n                publishMarketFeeAddress,\\n                publishMarketFeeToken,\\n                publishMarketFeeAmount\\n            );\\n        }\\n\\n        // consumeMarketFee\\n        // Requires approval for the FeeToken \\n        // skip fee if amount == 0 or feeToken == 0x0 address or feeAddress == 0x0 address\\n        if (\\n            _consumeMarketFee.consumeMarketFeeAmount > 0 &&\\n            _consumeMarketFee.consumeMarketFeeToken != address(0) &&\\n            _consumeMarketFee.consumeMarketFeeAddress != address(0)\\n        ) {\\n            _pullUnderlying(_consumeMarketFee.consumeMarketFeeToken,msg.sender,\\n                _consumeMarketFee.consumeMarketFeeAddress,\\n                _consumeMarketFee.consumeMarketFeeAmount);\\n            emit ConsumeMarketFee(\\n                _consumeMarketFee.consumeMarketFeeAddress,\\n                _consumeMarketFee.consumeMarketFeeToken,\\n                _consumeMarketFee.consumeMarketFeeAmount\\n            );\\n        }\\n\\n        _checkProviderFee(_providerFee);\\n        \\n        burn(amount);\\n    }\\n\\n    /**\\n     * @dev reuseOrder\\n     *      called by payer or consumer having a valid order, but with expired provider access\\n     *      Pays the provider fee again, but it will not require a new datatoken payment\\n     *      Requires previous approval of provider fee.\\n     * @param orderTxId previous valid order\\n     * @param _providerFee provider feee\\n     */\\n    function reuseOrder(\\n        bytes32 orderTxId,\\n        providerFee calldata _providerFee\\n    ) external {\\n        emit OrderReused(\\n            orderTxId,\\n            msg.sender,\\n            block.timestamp,\\n            block.number\\n        );\\n        _checkProviderFee(_providerFee);\\n    }\\n\\n    /**\\n     * @dev addMinter\\n     *      Only ERC20Deployer (at 721 level) can update.\\n     *      There can be multiple minters\\n     * @param _minter new minter address\\n     */\\n\\n    function addMinter(address _minter) external onlyERC20Deployer {\\n        _addMinter(_minter);\\n    }\\n\\n    /**\\n     * @dev removeMinter\\n     *      Only ERC20Deployer (at 721 level) can update.\\n     *      There can be multiple minters\\n     * @param _minter minter address to remove\\n     */\\n\\n    function removeMinter(address _minter) external onlyERC20Deployer {\\n        _removeMinter(_minter);\\n    }\\n\\n    /**\\n     * @dev addPaymentManager (can set who's going to collect fee when consuming orders)\\n     *      Only ERC20Deployer (at 721 level) can update.\\n     *      There can be multiple paymentCollectors\\n     * @param _paymentManager new minter address\\n     */\\n\\n    function addPaymentManager(address _paymentManager)\\n        external\\n        onlyERC20Deployer\\n    {\\n        _addPaymentManager(_paymentManager);\\n    }\\n\\n    /**\\n     * @dev removePaymentManager\\n     *      Only ERC20Deployer (at 721 level) can update.\\n     *      There can be multiple paymentManagers\\n     * @param _paymentManager _paymentManager address to remove\\n     */\\n\\n    function removePaymentManager(address _paymentManager)\\n        external\\n        onlyERC20Deployer\\n    {\\n        _removePaymentManager(_paymentManager);\\n    }\\n\\n    /**\\n     * @dev setData\\n     *      Only ERC20Deployer (at 721 level) can call it.\\n     *      This function allows to store data with a preset key (keccak256(ERC20Address)) into NFT 725 Store\\n     * @param _value data to be set with this key\\n     */\\n\\n    function setData(bytes calldata _value) external onlyERC20Deployer {\\n        bytes32 key = keccak256(abi.encodePacked(address(this)));\\n        IERC721Template(_erc721Address).setDataERC20(key, _value);\\n    }\\n\\n    /**\\n     * @dev cleanPermissions()\\n     *      Only NFT Owner (at 721 level) can call it.\\n     *      This function allows to remove all minters, feeManagers and reset the paymentCollector\\n     *\\n     */\\n\\n    function cleanPermissions() external onlyNFTOwner {\\n        _internalCleanPermissions();\\n    }\\n\\n    /**\\n     * @dev cleanFrom721()\\n     *      OnlyNFT(721) Contract can call it.\\n     *      This function allows to remove all minters, feeManagers and reset the paymentCollector\\n     *       This function is used when transferring an NFT to a new owner,\\n     * so that permissions at ERC20level (minter,feeManager,paymentCollector) can be reset.\\n     *\\n     */\\n    function cleanFrom721() external {\\n        require(\\n            msg.sender == _erc721Address,\\n            \\\"ERC20Template: NOT 721 Contract\\\"\\n        );\\n        _internalCleanPermissions();\\n        \\n    }\\n    \\n    function _internalCleanPermissions() internal {\\n        uint256 totalLen = fixedRateExchanges.length + dispensers.length;\\n        uint256 curentLen = 0;\\n        address[] memory previousMinters=new address[](totalLen);\\n        // loop though fixedrates, empty and preserve the minter rols if exists\\n        uint256 i;\\n        for(i=0; i<fixedRateExchanges.length; i++) {\\n                IFixedRateExchange fre = IFixedRateExchange(fixedRateExchanges[i].contractAddress);\\n                (\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    uint256 dtBalance,\\n                    uint256 btBalance,\\n                    bool withMint\\n                ) = fre.getExchange(fixedRateExchanges[i].id);\\n                if(btBalance>0)\\n                    fre.collectBT(fixedRateExchanges[i].id, btBalance);\\n                if(dtBalance>0)\\n                    fre.collectDT(fixedRateExchanges[i].id, dtBalance);\\n                // add it to the list of minters\\n                if(isMinter(fixedRateExchanges[i].contractAddress) && withMint == true){\\n                    previousMinters[curentLen]=fixedRateExchanges[i].contractAddress;\\n                    curentLen++;\\n                }\\n        }\\n        // loop though dispenser and preserve the minter rols if exists\\n        for(i=0; i<dispensers.length; i++) {\\n                IDispenser(dispensers[i]).ownerWithdraw(address(this));\\n                if(isMinter(dispensers[i])){\\n                    previousMinters[curentLen]=dispensers[i];\\n                    curentLen++;\\n                }\\n        }\\n        // clear all permisions\\n         _cleanPermissions();\\n        // set collector to 0\\n        paymentCollector = address(0);\\n        // add existing minter roles for fixedrate & dispensers\\n        for(i=0; i<curentLen; i++) {\\n            _addMinter(previousMinters[i]);\\n        }\\n        \\n    }\\n    /**\\n     * @dev setPaymentCollector\\n     *      Only feeManager can call it\\n     *      This function allows to set a newPaymentCollector (receives DT when consuming)\\n            If not set the paymentCollector is the NFT Owner\\n     * @param _newPaymentCollector new fee collector \\n     */\\n\\n    function setPaymentCollector(address _newPaymentCollector) external {\\n        //we allow _newPaymentCollector = address(0), because it means that the collector is nft owner\\n        require(\\n            permissions[msg.sender].paymentManager ||\\n                IERC721Template(_erc721Address).getPermissions(msg.sender).deployERC20 || \\n                IERC721Template(_erc721Address).ownerOf(1)==msg.sender,\\n            \\\"ERC20Template: NOT PAYMENT MANAGER or OWNER\\\"\\n        );\\n        _setPaymentCollector(_newPaymentCollector);\\n        emit NewPaymentCollector(\\n            msg.sender,\\n            _newPaymentCollector,\\n            block.timestamp,\\n            block.number\\n        );\\n    }\\n\\n    /**\\n     * @dev _setPaymentCollector\\n     * @param _newPaymentCollector new fee collector\\n     */\\n\\n    function _setPaymentCollector(address _newPaymentCollector) internal {\\n        paymentCollector = _newPaymentCollector;\\n    }\\n\\n    /**\\n     * @dev getPublishingMarketFee\\n     *      Get publishingMarket Fee\\n     *      This function allows to get the current fee set by the publishing market\\n     */\\n    function getPublishingMarketFee()\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            uint256\\n        )\\n    {\\n        return (\\n            publishMarketFeeAddress,\\n            publishMarketFeeToken,\\n            publishMarketFeeAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev setPublishingMarketFee\\n     *      Only publishMarketFeeAddress can call it\\n     *      This function allows to set the fee required by the publisherMarket\\n     * @param _publishMarketFeeAddress  new _publishMarketFeeAddress\\n     * @param _publishMarketFeeToken new _publishMarketFeeToken\\n     * @param _publishMarketFeeAmount new fee amount\\n     */\\n    function setPublishingMarketFee(\\n        address _publishMarketFeeAddress,\\n        address _publishMarketFeeToken,\\n        uint256 _publishMarketFeeAmount\\n    ) external onlyPublishingMarketFeeAddress {\\n        require(\\n            _publishMarketFeeAddress != address(0),\\n            \\\"Invalid _publishMarketFeeAddress address\\\"\\n        );\\n        require(\\n            _publishMarketFeeToken != address(0),\\n            \\\"Invalid _publishMarketFeeToken address\\\"\\n        );\\n        publishMarketFeeAddress = _publishMarketFeeAddress;\\n        publishMarketFeeToken = _publishMarketFeeToken;\\n        publishMarketFeeAmount = _publishMarketFeeAmount;\\n        emit PublishMarketFeeChanged(\\n            msg.sender,\\n            _publishMarketFeeAddress,\\n            _publishMarketFeeToken,\\n            _publishMarketFeeAmount\\n        );\\n    }\\n\\n    /**\\n     * @dev getId\\n     *      Return template id in case we need different ABIs. \\n     *      If you construct your own template, please make sure to change the hardcoded value\\n     */\\n    function getId() pure public returns (uint8) {\\n        return 2;\\n    }\\n\\n    /**\\n     * @dev name\\n     *      It returns the token name.\\n     * @return Datatoken name.\\n     */\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev symbol\\n     *      It returns the token symbol.\\n     * @return Datatoken symbol.\\n     */\\n    function symbol() public view override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev getERC721Address\\n     *      It returns the parent ERC721\\n     * @return ERC721 address.\\n     */\\n    function getERC721Address() public view returns (address) {\\n        return _erc721Address;\\n    }\\n\\n    /**\\n     * @dev decimals\\n     *      It returns the token decimals.\\n     *      how many supported decimal points\\n     * @return Datatoken decimals.\\n     */\\n    function decimals() public pure override returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev cap\\n     *      it returns the capital.\\n     * @return Datatoken cap.\\n     */\\n    function cap() external view returns (uint256) {\\n        return _cap;\\n    }\\n\\n    /**\\n     * @dev isInitialized\\n     *      It checks whether the contract is initialized.\\n     * @return true if the contract is initialized.\\n     */\\n\\n    function isInitialized() external view returns (bool) {\\n        return initialized;\\n    }\\n\\n    /**\\n     * @dev permit\\n     *      used for signed approvals, see ERC20Template test for more details\\n     * @param owner user who signed the message\\n     * @param spender spender\\n     * @param value token amount\\n     * @param deadline deadline after which signed message is no more valid\\n     * @param v parameters from signed message\\n     * @param r parameters from signed message\\n     * @param s parameters from signed message\\n     */\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external {\\n        require(deadline >= block.number, \\\"ERC20DT: EXPIRED\\\");\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(\\n                    abi.encode(\\n                        PERMIT_TYPEHASH,\\n                        owner,\\n                        spender,\\n                        value,\\n                        nonces[owner]++,\\n                        deadline\\n                    )\\n                )\\n            )\\n        );\\n        address recoveredAddress = ecrecover(digest, v, r, s);\\n        require(\\n            recoveredAddress != address(0) && recoveredAddress == owner,\\n            \\\"ERC20DT: INVALID_SIGNATURE\\\"\\n        );\\n        _approve(owner, spender, value);\\n    }\\n\\n    /**\\n     * @dev getAddressLength\\n     *      It returns the array lentgh\\n            @param array address array we want to get length\\n     * @return length\\n     */\\n\\n    function getAddressLength(address[] memory array)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return array.length;\\n    }\\n\\n    /**\\n     * @dev getUintLength\\n     *      It returns the array lentgh\\n            @param array uint array we want to get length\\n     * @return length\\n     */\\n\\n    function getUintLength(uint256[] memory array)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return array.length;\\n    }\\n\\n    /**\\n     * @dev getBytesLength\\n     *      It returns the array lentgh\\n            @param array bytes32 array we want to get length\\n     * @return length\\n     */\\n\\n    function getBytesLength(bytes32[] memory array)\\n        private\\n        pure\\n        returns (uint256)\\n    {\\n        return array.length;\\n    }\\n\\n    /**\\n     * @dev getPaymentCollector\\n     *      It returns the current paymentCollector\\n     * @return paymentCollector address\\n     */\\n\\n    function getPaymentCollector() public view returns (address) {\\n        if (paymentCollector == address(0)) {\\n            return IERC721Template(_erc721Address).ownerOf(1);\\n        } else {\\n            return paymentCollector;\\n        }\\n    }\\n\\n    /**\\n     * @dev fallback function\\n     *      this is a default fallback function in which receives\\n     *      the collected ether.\\n     */\\n    fallback() external payable {}\\n\\n    /**\\n     * @dev receive function\\n     *      this is a default receive function in which receives\\n     *      the collected ether.\\n     */\\n    receive() external payable {}\\n    \\n    /**\\n     * @dev withdrawETH\\n     *      transfers all the accumlated ether the collector account\\n     */\\n    function withdrawETH() external payable {\\n        payable(getPaymentCollector()).transfer(address(this).balance);\\n    }\\n\\n    struct OrderParams {\\n        address consumer;\\n        uint256 serviceIndex;\\n        providerFee _providerFee;\\n        consumeMarketFee _consumeMarketFee;\\n    }\\n    struct FreParams {\\n        address exchangeContract;\\n        bytes32 exchangeId;\\n        uint256 maxBaseTokenAmount;\\n        uint256 swapMarketFee;\\n        address marketFeeAddress;\\n    }\\n\\n    /**\\n     * @dev buyFromFreAndOrder\\n     *      Buys 1 DT from the FRE and then startsOrder, while burning that DT\\n     */\\n    function buyFromFreAndOrder(\\n        OrderParams calldata _orderParams,\\n        FreParams calldata _freParams\\n    ) external nonReentrant{\\n        // get exchange info\\n        IFixedRateExchange fre=IFixedRateExchange(_freParams.exchangeContract);\\n        (\\n            ,\\n            address datatoken,\\n            ,\\n            address baseToken,\\n            ,\\n            ,\\n            ,\\n            ,\\n            ,\\n            ,\\n            ,\\n\\n        ) = fre.getExchange(_freParams.exchangeId);\\n        require(\\n            datatoken == address(this),\\n            \\\"This FixedRate is not providing this DT\\\"\\n        );\\n        // get token amounts needed\\n        (\\n            uint256 baseTokenAmount\\n            ,\\n            ,\\n            ,\\n\\n        ) = fre.calcBaseInGivenOutDT(\\n                    _freParams.exchangeId,\\n                    1e18,  // we always take 1 DT\\n                    _freParams.swapMarketFee\\n                );\\n        require(\\n            baseTokenAmount <= _freParams.maxBaseTokenAmount,\\n            \\\"FixedRateExchange: Too many base tokens\\\"\\n        );\\n\\n        //transfer baseToken to us first\\n        _pullUnderlying(baseToken,msg.sender,\\n                address(this),\\n                baseTokenAmount);\\n        //approve FRE to spend baseTokens\\n        IERC20(baseToken).safeIncreaseAllowance(\\n            _freParams.exchangeContract,\\n            baseTokenAmount\\n        );\\n        //buy DT\\n        fre.buyDT(\\n            _freParams.exchangeId,\\n            1e18, // we always take 1 dt\\n            baseTokenAmount,\\n            _freParams.marketFeeAddress,\\n            _freParams.swapMarketFee\\n        );\\n        require(\\n            balanceOf(address(this)) >= 1e18,\\n            \\\"Unable to buy DT from FixedRate\\\"\\n        );\\n        //we need the following because startOrder expects msg.sender to have dt\\n        _transfer(address(this), msg.sender, 1e18);\\n        //startOrder and burn it\\n        startOrder(_orderParams.consumer, _orderParams.serviceIndex,\\n        _orderParams._providerFee, _orderParams._consumeMarketFee);\\n        // collect the basetoken from fixedrate and sent it\\n        (\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    ,\\n                    uint256 btBalance,\\n        ) = fre.getExchange(_freParams.exchangeId);\\n        if(btBalance>0)\\n            fre.collectBT(_freParams.exchangeId, btBalance);\\n                \\n    }\\n\\n    /**\\n     * @dev buyFromDispenserAndOrder\\n     *      Gets DT from dispenser and then startsOrder, while burning that DT\\n     */\\n    function buyFromDispenserAndOrder(\\n        OrderParams calldata _orderParams,\\n        address dispenserContract\\n    ) external nonReentrant {\\n        uint256 amount = 1e18;\\n        //get DT\\n        IDispenser(dispenserContract).dispense(\\n            address(this),\\n            amount,\\n            msg.sender\\n        );\\n        require(\\n            balanceOf(address(msg.sender)) >= amount,\\n            \\\"Unable to get DT from Dispenser\\\"\\n        );\\n        //startOrder and burn it\\n        startOrder(_orderParams.consumer, _orderParams.serviceIndex,\\n        _orderParams._providerFee, _orderParams._consumeMarketFee);\\n    }\\n\\n    /**\\n    * @dev isERC20Deployer\\n    *      returns true if address has deployERC20 role\\n    */\\n    function isERC20Deployer(address user) public view returns(bool){\\n        return(IERC721Template(_erc721Address).getPermissions(user).deployERC20);\\n    }\\n\\n    /**\\n     * @dev getFixedRates\\n     *      Returns the list of fixedRateExchanges created for this datatoken\\n     */\\n    function getFixedRates() public view returns(fixedRate[] memory) {\\n        return(fixedRateExchanges);\\n    }\\n    /**\\n     * @dev getDispensers\\n     *      Returns the list of dispensers created for this datatoken\\n     */\\n    function getDispensers() public view returns(address[] memory) {\\n        return(dispensers);\\n    }\\n\\n     function _pullUnderlying(\\n        address erc20,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        uint256 balanceBefore = IERC20(erc20).balanceOf(to);\\n        IERC20(erc20).safeTransferFrom(from, to, amount);\\n        require(IERC20(erc20).balanceOf(to) >= balanceBefore.add(amount),\\n                    \\\"Transfer amount is too low\\\");\\n    }\\n\\n    /**\\n     * @dev orderExecuted\\n     *      Providers should call this to prove order execution\\n     * @param orderTxId order tx\\n     * @param providerData provider data\\n     * @param providerSignature provider signature\\n     * @param consumerData consumer data\\n     * @param consumerSignature consumer signature\\n     * @param consumerAddress consumer address\\n     */\\n    function orderExecuted(\\n        bytes32 orderTxId,\\n        bytes calldata providerData,\\n        bytes calldata providerSignature,\\n        bytes calldata consumerData,\\n        bytes calldata consumerSignature,\\n        address consumerAddress\\n    ) external {\\n        require(msg.sender != consumerAddress, \\\"Provider cannot be the consumer\\\");\\n        bytes memory prefix = \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\";\\n        bytes32 providerHash = keccak256(\\n            abi.encodePacked(prefix,\\n                keccak256(\\n                    abi.encodePacked(\\n                        orderTxId,\\n                        providerData\\n                    )\\n                )\\n            )\\n        );\\n        require(_ecrecovery(providerHash, providerSignature) == msg.sender, \\\"Provider signature check failed\\\");\\n        bytes32 consumerHash = keccak256(\\n            abi.encodePacked(prefix,\\n                keccak256(\\n                    abi.encodePacked(\\n                        consumerData\\n                    )\\n                )\\n            )\\n        );\\n        require(_ecrecovery(consumerHash, consumerSignature) == consumerAddress, \\\"Consumer signature check failed\\\");\\n        emit OrderExecuted(msg.sender, consumerAddress ,orderTxId, providerData, providerSignature,\\n                consumerData, consumerSignature, block.timestamp, block.number);\\n    }\\n\\n\\n\\n    function _ecrecovery(bytes32 hash, bytes memory sig) pure internal returns (address) {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        if (sig.length != 65) {\\n          return address(0);\\n        }\\n        assembly {\\n          r := mload(add(sig, 32))\\n        s := mload(add(sig, 64))\\n        v := and(mload(add(sig, 65)), 255)\\n        }\\n        if (v < 27) {\\n          v += 27;\\n        }   \\n        if (v != 27 && v != 28) {\\n        return address(0);\\n        }\\n        return ecrecover(hash, v, r, s);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC721Template.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\n\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Template {\\n    \\n    enum RolesType {\\n        Manager,\\n        DeployERC20,\\n        UpdateMetadata,\\n        Store\\n    }\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed approved,\\n        uint256 indexed tokenId\\n    );\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n    event MetadataCreated(\\n        address indexed createdBy,\\n        uint8 state,\\n        string decryptorUrl,\\n        bytes flags,\\n        bytes data,\\n        string metaDataDecryptorAddress,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n    event MetadataUpdated(\\n        address indexed updatedBy,\\n        uint8 state,\\n        string decryptorUrl,\\n        bytes flags,\\n        bytes data,\\n        string metaDataDecryptorAddress,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function name() external view returns (string memory);\\n\\n    function symbol() external view returns (string memory);\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    function isERC20Deployer(address acount) external view returns (bool);\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, \\n     * it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, \\n     * it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId)\\n        external\\n        view\\n        returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, \\n     * it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    // function safeTransferFrom(\\n    //     address from,\\n    //     address to,\\n    //     uint256 tokenId,\\n    //     bytes calldata data\\n    // ) external;\\n    function transferFrom(address from, address to) external;\\n\\n    function initialize(\\n        address admin,\\n        string calldata name,\\n        string calldata symbol,\\n        address erc20Factory,\\n        address additionalERC20Deployer,\\n        address additionalMetaDataUpdater,\\n        string calldata tokenURI,\\n        bool transferable\\n    ) external returns (bool);\\n\\n     struct Roles {\\n        bool manager;\\n        bool deployERC20;\\n        bool updateMetadata;\\n        bool store;\\n    }\\n\\n    struct metaDataProof {\\n        address validatorAddress;\\n        uint8 v; // v of validator signed message\\n        bytes32 r; // r of validator signed message\\n        bytes32 s; // s of validator signed message\\n    }\\n    function getPermissions(address user) external view returns (Roles memory);\\n\\n    function setDataERC20(bytes32 _key, bytes calldata _value) external;\\n    function setMetaData(uint8 _metaDataState, string calldata _metaDataDecryptorUrl\\n        , string calldata _metaDataDecryptorAddress, bytes calldata flags, \\n        bytes calldata data,bytes32 _metaDataHash, metaDataProof[] memory _metadataProofs) external;\\n    function getMetaData() external view returns (string memory, string memory, uint8, bool);\\n\\n    function createERC20(\\n        uint256 _templateIndex,\\n        string[] calldata strings,\\n        address[] calldata addresses,\\n        uint256[] calldata uints,\\n        bytes[] calldata bytess\\n    ) external returns (address);\\n\\n\\n    function removeFromCreateERC20List(address _allowedAddress) external;\\n    function addToCreateERC20List(address _allowedAddress) external;\\n    function addToMetadataList(address _allowedAddress) external;\\n    function removeFromMetadataList(address _allowedAddress) external;\\n    function getId() pure external returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IERC20Template.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IERC20Template {\\n    struct RolesERC20 {\\n        bool minter;\\n        bool feeManager;\\n    }\\n    struct providerFee{\\n        address providerFeeAddress;\\n        address providerFeeToken; // address of the token marketplace wants to add fee on top\\n        uint256 providerFeeAmount; // amount to be transfered to marketFeeCollector\\n        uint8 v; // v of provider signed message\\n        bytes32 r; // r of provider signed message\\n        bytes32 s; // s of provider signed message\\n        uint256 validUntil; //validity expresses in unix timestamp\\n        bytes providerData; //data encoded by provider\\n    }\\n    struct consumeMarketFee{\\n        address consumeMarketFeeAddress;\\n        address consumeMarketFeeToken; // address of the token marketplace wants to add fee on top\\n        uint256 consumeMarketFeeAmount; // amount to be transfered to marketFeeCollector\\n    }\\n    function initialize(\\n        string[] calldata strings_,\\n        address[] calldata addresses_,\\n        address[] calldata factoryAddresses_,\\n        uint256[] calldata uints_,\\n        bytes[] calldata bytes_\\n    ) external returns (bool);\\n    \\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function decimals() external pure returns (uint8);\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function cap() external view returns (uint256);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function allowance(address owner, address spender)\\n        external\\n        view\\n        returns (uint256);\\n\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 value\\n    ) external returns (bool);\\n\\n    function mint(address account, uint256 value) external;\\n    \\n    function isMinter(address account) external view returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\n    function nonces(address owner) external view returns (uint256);\\n\\n    function permissions(address user)\\n        external\\n        view\\n        returns (RolesERC20 memory);\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    function cleanFrom721() external;\\n\\n    function deployPool(\\n        uint256[] memory ssParams,\\n        uint256[] memory swapFees,\\n        address[] memory addresses \\n    ) external returns (address);\\n\\n    function createFixedRate(\\n        address fixedPriceAddress,\\n        address[] memory addresses,\\n        uint[] memory uints\\n    ) external returns (bytes32);\\n    function createDispenser(\\n        address _dispenser,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        bool withMint,\\n        address allowedSwapper) external;\\n        \\n    function getPublishingMarketFee() external view returns (address , address, uint256);\\n    function setPublishingMarketFee(\\n        address _publishMarketFeeAddress, address _publishMarketFeeToken, uint256 _publishMarketFeeAmount\\n    ) external;\\n\\n     function startOrder(\\n        address consumer,\\n        uint256 serviceIndex,\\n        providerFee calldata _providerFee,\\n        consumeMarketFee calldata _consumeMarketFee\\n     ) external;\\n\\n     function reuseOrder(\\n        bytes32 orderTxId,\\n        providerFee calldata _providerFee\\n    ) external;\\n  \\n    function burn(uint256 amount) external;\\n    function burnFrom(address account, uint256 amount) external;\\n    function getERC721Address() external view returns (address);\\n    function isERC20Deployer(address user) external view returns(bool);\\n    function getPools() external view returns(address[] memory);\\n    struct fixedRate{\\n        address contractAddress;\\n        bytes32 id;\\n    }\\n    function getFixedRates() external view returns(fixedRate[] memory);\\n    function getDispensers() external view returns(address[] memory);\\n    function getId() pure external returns (uint8);\\n    function getPaymentCollector() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/IFactoryRouter.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IFactoryRouter {\\n    function deployPool(\\n        address[2] calldata tokens, // [datatokenAddress, baseTokenAddress]\\n        uint256[] calldata ssParams,\\n        uint256[] calldata swapFees,\\n        address[] calldata addresses\\n    ) external returns (address);\\n\\n    function deployFixedRate(\\n        address fixedPriceAddress,\\n        address[] calldata addresses,\\n        uint256[] calldata uints\\n    ) external returns (bytes32 exchangeId);\\n\\n    function getOPCFee(address baseToken) external view returns (uint256);\\n    function getOPCFees() external view returns (uint256,uint256);\\n    function getOPCConsumeFee() external view returns (uint256);\\n    function getOPCProviderFee() external view returns (uint256);\\n\\n    function getMinVestingPeriod() external view returns (uint256);\\n    function deployDispenser(\\n        address _dispenser,\\n        address datatoken,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        address owner,\\n        address allowedSwapper\\n    ) external;\\n\\n    function isApprovedToken(address) external view returns(bool);\\n    function getApprovedTokens() external view returns(address[] memory);\\n    function isSSContract(address) external view returns(bool);\\n    function getSSContracts() external view returns(address[] memory);\\n    function isFixedRateContract(address) external view returns(bool);\\n    function getFixedRatesContracts() external view returns(address[] memory);\\n    function isDispenserContract(address) external view returns(bool);\\n    function getDispensersContracts() external view returns(address[] memory);\\n    function isPoolTemplate(address) external view returns(bool);\\n    function getPoolTemplates() external view returns(address[] memory);\\n\\n    struct Stakes {\\n        address poolAddress;\\n        uint256 tokenAmountIn;\\n        uint256 minPoolAmountOut;\\n    }\\n    function stakeBatch(Stakes[] calldata) external;\\n\\n    enum operationType {\\n        SwapExactIn,\\n        SwapExactOut,\\n        FixedRate,\\n        Dispenser\\n    }\\n\\n    struct Operations {\\n        bytes32 exchangeIds; // used for fixedRate or dispenser\\n        address source; // pool, dispenser or fixed rate address\\n        operationType operation; // type of operation: enum operationType\\n        address tokenIn; // token in address, only for pools\\n        uint256 amountsIn; // ExactAmount In for swapExactIn operation, maxAmount In for swapExactOut\\n        address tokenOut; // token out address, only for pools\\n        uint256 amountsOut; // minAmountOut for swapExactIn or exactAmountOut for swapExactOut\\n        uint256 maxPrice; // maxPrice, only for pools\\n        uint256 swapMarketFee;\\n        address marketFeeAddress;\\n    }\\n    function buyDTBatch(Operations[] calldata) external;\\n    function updateOPCCollector(address _opcCollector) external;\\n    function getOPCCollector() view external returns (address);\\n}\"\r\n    },\r\n    \"contracts/interfaces/IFixedRateExchange.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IFixedRateExchange {\\n    function createWithDecimals(\\n        address datatoken,\\n        address[] calldata addresses, // [baseToken,owner,marketFeeCollector]\\n        uint256[] calldata uints // [baseTokenDecimals,datatokenDecimals, fixedRate, marketFee]\\n    ) external returns (bytes32 exchangeId);\\n\\n    function buyDT(bytes32 exchangeId, uint256 datatokenAmount,\\n        uint256 maxBaseTokenAmount, address consumeMarketAddress, uint256 consumeMarketSwapFeeAmount) external;\\n    function sellDT(bytes32 exchangeId, uint256 datatokenAmount,\\n        uint256 minBaseTokenAmount, address consumeMarketAddress, uint256 consumeMarketSwapFeeAmount) external;\\n\\n    function getAllowedSwapper(bytes32 exchangeId) external view returns (address allowedSwapper);\\n    function getExchange(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            address exchangeOwner,\\n            address datatoken,\\n            uint256 dtDecimals,\\n            address baseToken,\\n            uint256 btDecimals,\\n            uint256 fixedRate,\\n            bool active,\\n            uint256 dtSupply,\\n            uint256 btSupply,\\n            uint256 dtBalance,\\n            uint256 btBalance,\\n            bool withMint\\n            //address allowedSwapper\\n        );\\n\\n    function getFeesInfo(bytes32 exchangeId)\\n        external\\n        view\\n        returns (\\n            uint256 marketFee,\\n            address marketFeeCollector,\\n            uint256 opcFee,\\n            uint256 marketFeeAvailable,\\n            uint256 oceanFeeAvailable\\n        );\\n\\n    function isActive(bytes32 exchangeId) external view returns (bool);\\n\\n    function calcBaseInGivenOutDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 consumeMarketSwapFeeAmount)\\n        external\\n        view\\n        returns (\\n            uint256 baseTokenAmount,\\n            uint256 oceanFeeAmount,\\n            uint256 publishMarketFeeAmount,\\n            uint256 consumeMarketFeeAmount\\n        );\\n    function calcBaseOutGivenInDT(bytes32 exchangeId, uint256 datatokenAmount, uint256 consumeMarketSwapFeeAmount)\\n        external\\n        view\\n        returns (\\n            uint256 baseTokenAmount,\\n            uint256 oceanFeeAmount,\\n            uint256 publishMarketFeeAmount,\\n            uint256 consumeMarketFeeAmount\\n        );\\n    function updateMarketFee(bytes32 exchangeId, uint256 _newMarketFee) external;\\n    function updateMarketFeeCollector(bytes32 exchangeId, address _newMarketCollector) external;\\n    function setAllowedSwapper(bytes32 exchangeId, address newAllowedSwapper) external;\\n    function getId() pure external returns (uint8);\\n    function collectBT(bytes32 exchangeId, uint256 amount) external;\\n    function collectDT(bytes32 exchangeId, uint256 amount) external;\\n}\"\r\n    },\r\n    \"contracts/interfaces/IDispenser.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ninterface IDispenser {\\n    \\n    function status(address datatoken)\\n    external\\n    view\\n    returns (\\n        bool active,\\n        address owner,\\n        bool isMinter,\\n        uint256 maxTokens,\\n        uint256 maxBalance,\\n        uint256 balance,\\n        address allowedSwapper\\n    );\\n    \\n    function create(\\n        address datatoken,uint256 maxTokens, uint256 maxBalance, address owner, address allowedSwapper) external;\\n    function activate(address datatoken,uint256 maxTokens, uint256 maxBalance) external;\\n    \\n    function deactivate(address datatoken) external;\\n    \\n    function dispense(address datatoken, uint256 amount, address destination) external payable;\\n    \\n    function ownerWithdraw(address datatoken) external;\\n    function setAllowedSwapper(address datatoken, address newAllowedSwapper) external;\\n    function getId() pure external returns (uint8);\\n    \\n}\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = _allowances[owner][spender];\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n        }\\n        _balances[to] += amount;\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        _balances[account] += amount;\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n        }\\n        _totalSupply -= amount;\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../ERC20.sol\\\";\\nimport \\\"../../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        _spendAllowance(account, _msgSender(), amount);\\n        _burn(account, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/math/SafeMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n// CAUTION\\n// This version of SafeMath should only be used with Solidity 0.8 or later,\\n// because it relies on the compiler's built in overflow checks.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations.\\n *\\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\\n * now has built in overflow checking.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            uint256 c = a + b;\\n            if (c < a) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b > a) return (false, 0);\\n            return (true, a - b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n            // benefit is lost if 'b' is also tested.\\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n            if (a == 0) return (true, 0);\\n            uint256 c = a * b;\\n            if (c / a != b) return (false, 0);\\n            return (true, c);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a / b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        unchecked {\\n            if (b == 0) return (false, 0);\\n            return (true, a % b);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a + b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a * b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b <= a, errorMessage);\\n            return a - b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a / b;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            require(b > 0, errorMessage);\\n            return a % b;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/utils/ERC20Roles.sol\": {\r\n      \"content\": \"pragma solidity 0.8.12;\\n// Copyright BigchainDB GmbH and Ocean Protocol contributors\\n// SPDX-License-Identifier: (Apache-2.0 AND CC-BY-4.0)\\n// Code is Apache-2.0 and docs are CC-BY-4.0\\n\\ncontract ERC20Roles {\\n    \\n    \\n    mapping(address => RolesERC20) public permissions;\\n\\n    address[] public authERC20;\\n\\n    struct RolesERC20 {\\n        bool minter;\\n        bool paymentManager; \\n    }\\n\\n    event AddedMinter(\\n        address indexed user,\\n        address indexed signer,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n    event RemovedMinter(\\n        address indexed user,\\n        address indexed signer,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n\\n    /**\\n    * @dev getPermissions\\n    *      Returns list of roles for an user\\n    * @param user user address\\n    */\\n    function getPermissions(address user) public view returns (RolesERC20 memory) {\\n        return permissions[user];\\n    }\\n\\n    /**\\n     * @dev isMinter\\n     *      Check if an address has the minter role\\n     * @param account refers to an address that is checked\\n     */\\n    function isMinter(address account) public view returns (bool) {\\n        return (permissions[account].minter);\\n    }\\n\\n    \\n    /**\\n    * @dev _addMinter\\n    *      Internal function to add minter role to an user.\\n    * @param _minter user address\\n    */\\n    function _addMinter(address _minter) internal {\\n        if(_minter != address(0)){\\n            RolesERC20 storage user = permissions[_minter];\\n            require(user.minter == false, \\\"ERC20Roles:  ALREADY A MINTER\\\");\\n            user.minter = true;\\n            _pushToAuthERC20(_minter);\\n            emit AddedMinter(_minter,msg.sender,block.timestamp,block.number);\\n        }\\n    }\\n\\n    /**\\n    * @dev _removeMinter\\n    *      Internal function to remove minter role from an user.\\n    * @param _minter user address\\n    */\\n    function _removeMinter(address _minter) internal {\\n        RolesERC20 storage user = permissions[_minter];\\n        user.minter = false;\\n        emit RemovedMinter(_minter,msg.sender,block.timestamp,block.number);\\n        _SafeRemoveFromAuthERC20(_minter);\\n    }\\n\\n    event AddedPaymentManager(\\n        address indexed user,\\n        address indexed signer,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n    event RemovedPaymentManager(\\n        address indexed user,\\n        address indexed signer,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n\\n    /**\\n    * @dev _addPaymentManager\\n    *      Internal function to add paymentManager role to an user.\\n    * @param _paymentCollector user address\\n    */\\n    function _addPaymentManager(address _paymentCollector) internal {\\n        if(_paymentCollector != address(0)){\\n            RolesERC20 storage user = permissions[_paymentCollector];\\n            require(user.paymentManager == false, \\\"ERC20Roles:  ALREADY A FEE MANAGER\\\");\\n            user.paymentManager = true;\\n            _pushToAuthERC20(_paymentCollector);\\n            emit AddedPaymentManager(_paymentCollector,msg.sender,block.timestamp,block.number);\\n        }\\n    }\\n\\n    /**\\n    * @dev _removePaymentManager\\n    *      Internal function to remove paymentManager role from an user.\\n    * @param _paymentCollector user address\\n    */\\n    function _removePaymentManager(address _paymentCollector) internal {\\n        RolesERC20 storage user = permissions[_paymentCollector];\\n        user.paymentManager = false;\\n        emit RemovedPaymentManager(_paymentCollector,msg.sender,block.timestamp,block.number);\\n        _SafeRemoveFromAuthERC20(_paymentCollector);\\n    }\\n\\n\\n    \\n\\n   \\n    event CleanedPermissions(\\n        address indexed signer,\\n        uint256 timestamp,\\n        uint256 blockNumber\\n    );\\n\\n    \\n    function _cleanPermissions() internal {\\n        \\n        for (uint256 i = 0; i < authERC20.length; i++) {\\n            RolesERC20 storage user = permissions[authERC20[i]];\\n            user.minter = false;\\n            user.paymentManager = false;\\n\\n        }\\n        \\n        delete authERC20;\\n        emit CleanedPermissions(msg.sender,block.timestamp,block.number);\\n        \\n    }\\n\\n\\n\\n        /**\\n    * @dev _pushToAuthERC20\\n    *      Checks authERC20 array and adds the user address if does not exists\\n    * @param user address to be checked\\n    */\\n    function _pushToAuthERC20(address user) internal {\\n        uint256 i;\\n        for (i = 0; i < authERC20.length; i++) {\\n            if(authERC20[i] == user) break;\\n        }\\n        if(i == authERC20.length){\\n            // element was not found\\n            authERC20.push(user);\\n        }\\n    }\\n\\n    /**\\n    * @dev _SafeRemoveFromAuthERC20\\n    *      Checks if user has any roles left, and if not, it will remove it from auth array\\n    * @param user address to be checked and removed\\n    */\\n    function _SafeRemoveFromAuthERC20(address user) internal {\\n        RolesERC20 storage userRoles = permissions[user];\\n        if (userRoles.minter == false &&\\n            userRoles.paymentManager == false\\n        ){\\n            uint256 i;\\n            for (i = 0; i < authERC20.length; i++) {\\n                if(authERC20[i] == user) break;\\n            }\\n            if(i < authERC20.length){\\n                authERC20[i] = authERC20[authERC20.length -1];\\n                authERC20.pop();\\n            }\\n        }\\n    }\\n    \\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"AddedMinter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"AddedPaymentManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"CleanedPermissions\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consumeMarketFeeAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consumeMarketFeeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"}],\"name\":\"ConsumeMarketFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentMinter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"MinterApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"currentMinter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newMinter\",\"type\":\"address\"}],\"name\":\"MinterProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dispenserContract\",\"type\":\"address\"}],\"name\":\"NewDispenser\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchangeContract\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"baseToken\",\"type\":\"address\"}],\"name\":\"NewFixedRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_newPaymentCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"NewPaymentCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"providerAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consumerAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderTxId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"providerData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"providerSignature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"consumerData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"consumerSignature\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"OrderExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"orderTxId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"OrderReused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"serviceIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"publishMarketAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"OrderStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"providerFeeAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"providerFeeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"providerFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"providerData\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"}],\"name\":\"ProviderFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"PublishMarketFeeAddress\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"PublishMarketFeeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"PublishMarketFeeAmount\",\"type\":\"uint256\"}],\"name\":\"PublishMarketFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"PublishMarketFeeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"PublishMarketFeeToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"PublishMarketFeeAmount\",\"type\":\"uint256\"}],\"name\":\"PublishMarketFeeChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"RemovedMinter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"RemovedPaymentManager\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"BASE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentManager\",\"type\":\"address\"}],\"name\":\"addPaymentManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"authERC20\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"serviceIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"providerFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"providerFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"providerFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"providerData\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC20TemplateEnterprise.providerFee\",\"name\":\"_providerFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"consumeMarketFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"consumeMarketFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20TemplateEnterprise.consumeMarketFee\",\"name\":\"_consumeMarketFee\",\"type\":\"tuple\"}],\"internalType\":\"struct ERC20TemplateEnterprise.OrderParams\",\"name\":\"_orderParams\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"dispenserContract\",\"type\":\"address\"}],\"name\":\"buyFromDispenserAndOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"serviceIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"providerFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"providerFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"providerFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"providerData\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC20TemplateEnterprise.providerFee\",\"name\":\"_providerFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"consumeMarketFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"consumeMarketFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20TemplateEnterprise.consumeMarketFee\",\"name\":\"_consumeMarketFee\",\"type\":\"tuple\"}],\"internalType\":\"struct ERC20TemplateEnterprise.OrderParams\",\"name\":\"_orderParams\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"exchangeContract\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxBaseTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"swapMarketFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"marketFeeAddress\",\"type\":\"address\"}],\"internalType\":\"struct ERC20TemplateEnterprise.FreParams\",\"name\":\"_freParams\",\"type\":\"tuple\"}],\"name\":\"buyFromFreAndOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cleanFrom721\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"cleanPermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_dispenser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"maxTokens\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxBalance\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withMint\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"createDispenser\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"fixedPriceAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"addresses\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"uints\",\"type\":\"uint256[]\"}],\"name\":\"createFixedRate\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"exchangeId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDispensers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getERC721Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFixedRates\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"id\",\"type\":\"bytes32\"}],\"internalType\":\"struct ERC20TemplateEnterprise.fixedRate[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getId\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPaymentCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getPermissions\",\"outputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"minter\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"paymentManager\",\"type\":\"bool\"}],\"internalType\":\"struct ERC20Roles.RolesERC20\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPublishingMarketFee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"strings_\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"factoryAddresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"uints_\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes[]\",\"name\":\"bytes_\",\"type\":\"bytes[]\"}],\"name\":\"initialize\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isERC20Deployer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isInitialized\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderTxId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"providerData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"providerSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"consumerData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"consumerSignature\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"consumerAddress\",\"type\":\"address\"}],\"name\":\"orderExecuted\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"permissions\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"minter\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"paymentManager\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_minter\",\"type\":\"address\"}],\"name\":\"removeMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_paymentManager\",\"type\":\"address\"}],\"name\":\"removePaymentManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"orderTxId\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"providerFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"providerFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"providerFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"providerData\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC20TemplateEnterprise.providerFee\",\"name\":\"_providerFee\",\"type\":\"tuple\"}],\"name\":\"reuseOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"router\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_value\",\"type\":\"bytes\"}],\"name\":\"setData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newPaymentCollector\",\"type\":\"address\"}],\"name\":\"setPaymentCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_publishMarketFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_publishMarketFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_publishMarketFeeAmount\",\"type\":\"uint256\"}],\"name\":\"setPublishingMarketFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"consumer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"serviceIndex\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"providerFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"providerFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"providerFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"validUntil\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"providerData\",\"type\":\"bytes\"}],\"internalType\":\"struct ERC20TemplateEnterprise.providerFee\",\"name\":\"_providerFee\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"consumeMarketFeeAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"consumeMarketFeeToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"consumeMarketFeeAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct ERC20TemplateEnterprise.consumeMarketFee\",\"name\":\"_consumeMarketFee\",\"type\":\"tuple\"}],\"name\":\"startOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ERC20TemplateEnterprise", "CompilerVersion": "v0.8.12+commit.f00d7308", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}