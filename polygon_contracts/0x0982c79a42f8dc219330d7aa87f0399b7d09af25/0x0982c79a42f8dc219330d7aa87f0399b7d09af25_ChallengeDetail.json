{"SourceCode": "// File: Challenge/IChallengeFee.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.16;\r\n\r\n/**\r\n * @dev Interface for the ChallengeFee contract.\r\n */\r\ninterface IChallengeFee {\r\n    /**\r\n     * @dev Retrieves the current amount fee settings.\r\n     * @return successFee The current amount of success fee.\r\n     * @return failFee The current amount of fail fee.\r\n     */\r\n    function getAmountFee()\r\n        external\r\n        view\r\n        returns (uint8 successFee, uint8 failFee);\r\n}\r\n\r\n// File: Challenge/IGacha.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.16;\r\n\r\ninterface IGacha {\r\n    /**\r\n    * @dev This function generates random rewards for a challenge, based on the given _dataStep array.\r\n    * @param _challengeAddress The address of the challenge for which rewards are being generated.\r\n    * @param _dataStep An array of step data used to calculate the rewards.\r\n    * @return A boolean indicating whether the rewards were generated successfully.\r\n    */\r\n    function randomRewards(address _challengeAddress, uint256[] memory _dataStep) external returns(bool);\r\n}\r\n// File: Challenge/IERC165.sol\r\n\r\n\r\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\r\n\r\npragma solidity ^0.8.16;\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n// File: Challenge/IERC1155.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    function nextTokenIdToMint() external view returns(uint256);\r\n}\r\n\r\n// File: Challenge/TransferHelper.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.7;\r\n\r\n/**\r\n    helper methods for interacting with ERC20 tokens that do not consistently return true/false\r\n    with the addition of a transfer function to send eth or an erc20 token\r\n*/\r\nlibrary TransferHelper {\r\n    function safeApprove(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x095ea7b3, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: APPROVE_FAILED\"\r\n        );\r\n    }\r\n\r\n    function saveTransferEth(\r\n        address payable recipient, \r\n        uint256 amount\r\n    ) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    function safeMintNFT1155(\r\n        address token,\r\n        address account, \r\n        uint256 id, \r\n        uint256 amount, \r\n        bytes memory dataValue\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x280f4e28, account, id, amount, dataValue)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: MINT_NFT1155_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(\r\n        address token,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa9059cbb, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FAILED\"\r\n        );\r\n    }\r\n    \r\n    function safeApproveForAllNFT1155(\r\n        address token,\r\n        address operator,\r\n        bool approved\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa22cb465, operator, approved)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: APPROVE_NFT1155_FAILED\"\r\n        );\r\n    }\r\n    \r\n    function safeTransferNFT1155(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes memory dataValue\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xf242432a, from, to, id, amount, dataValue)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_NFT1155_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeMintNFT(\r\n        address token,\r\n        address to\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x40d097c3, to)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: MINT_NFT_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeApproveForAll(\r\n        address token,\r\n        address to,\r\n        bool value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0xa22cb465, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: APPROVE_FAILED\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) internal {\r\n        (bool success, bytes memory data) = token.call(\r\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\r\n        );\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper: TRANSFER_FROM_FAILED\"\r\n        );\r\n    }\r\n\r\n    // sends ETH or an erc20 token\r\n    function safeTransferBaseToken(\r\n        address token,\r\n        address payable to,\r\n        uint256 value,\r\n        bool isERC20\r\n    ) internal {\r\n        if (!isERC20) {\r\n            to.transfer(value);\r\n        } else {\r\n            (bool success, bytes memory data) = token.call(\r\n                abi.encodeWithSelector(0xa9059cbb, to, value)\r\n            );\r\n            require(\r\n                success && (data.length == 0 || abi.decode(data, (bool))),\r\n                \"TransferHelper: TRANSFER_FAILED\"\r\n            );\r\n        }\r\n    }\r\n}\r\n\r\n// File: Challenge/IExerciseSupplementNFT.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IExerciseSupplementNFT {\r\n    /**\r\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n     */\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n     */\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed approved,\r\n        uint256 indexed tokenId\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n     */\r\n    event ApprovalForAll(\r\n        address indexed owner,\r\n        address indexed operator,\r\n        bool approved\r\n    );\r\n\r\n    /**\r\n     * @dev Returns the number of tokens in ``owner``'s account.\r\n     */\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @dev Returns the owner of the `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must exist and be owned by `from`.\r\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Transfers `tokenId` token from `from` to `to`.\r\n     *\r\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\r\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\r\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `from` cannot be the zero address.\r\n     * - `to` cannot be the zero address.\r\n     * - `tokenId` token must be owned by `from`.\r\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n     * The approval is cleared when the token is transferred.\r\n     *\r\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The caller must own the token or be an approved operator.\r\n     * - `tokenId` must exist.\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address to, uint256 tokenId) external;\r\n\r\n    /**\r\n     * @dev Approve or remove `operator` as an operator for the caller.\r\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The `operator` cannot be the caller.\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns the account approved for `tokenId` token.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `tokenId` must exist.\r\n     */\r\n    function getApproved(\r\n        uint256 tokenId\r\n    ) external view returns (address operator);\r\n\r\n    /**\r\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n     *\r\n     * See {setApprovalForAll}\r\n     */\r\n    function isApprovedForAll(\r\n        address owner,\r\n        address operator\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the ERC-20 token symbol.\r\n     */\r\n    function symbol() external view returns (string memory);\r\n\r\n    /**\r\n     * @dev Returns an array of addresses of registered ERC-20 token contracts.\r\n     */\r\n    function getErc20ListAddress() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Returns an array of addresses of registered NFT contracts.\r\n     */\r\n    function getNftListAddress() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @dev Returns the address of the contract for setting fees.\r\n     */\r\n    function feeSettingAddress() external view returns (address);\r\n\r\n    /**\r\n     * @dev Mint an NFT with specified parameters.\r\n     * @param _goal The target goal amount.\r\n     * @param _duration The duration of the challenge.\r\n     * @param _dayRequired The number of days required for the challenge.\r\n     * @param _createByToken The address of the creator of the token.\r\n     * @param _totalReward The total reward amount.\r\n     * @param _awardReceiversPercent The percentage of the reward to award to receivers.\r\n     * @param _awardReceivers The address of the reward receivers.\r\n     * @param _challenger The address of the challenger.\r\n     * @return The address and token ID of the new NFT.\r\n     */\r\n    function safeMintNFT(\r\n        uint256 _goal,\r\n        uint256 _duration,\r\n        uint256 _dayRequired,\r\n        address _createByToken,\r\n        uint256 _totalReward,\r\n        uint256 _awardReceiversPercent,\r\n        address _awardReceivers,\r\n        address _challenger\r\n    ) external returns (address, uint256);\r\n\r\n    /**\r\n     * @dev Returns true if the given address is an NFT contract.\r\n     * @param nftAddress The address to check.\r\n     * @return True if the given address is an NFT contract, false otherwise.\r\n     */\r\n    function typeNfts(address nftAddress) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the next token ID to be minted.\r\n     * @return The next token ID to be minted.\r\n     */\r\n    function nextTokenIdToMint() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the address of the receiver of a specified NFT's history.\r\n     * @param tokenId The ID of the NFT.\r\n     * @param to The address of the receiver.\r\n     * @return The address of the receiver of the specified NFT's history.\r\n     */\r\n    function getHistoryNFT(\r\n        uint256 tokenId,\r\n        address to\r\n    ) external view returns (address);\r\n\r\n    /**\r\n     * This function returns the address of the NFT wallet that was previously set by the contract owner.\r\n     * @return The address of the NFT wallet.\r\n     */\r\n    function returnedNFTWallet() external view returns (address);\r\n\r\n    /**\r\n     * @dev Check the validity of a provided signature.\r\n     * @param _day An array of uint256 values representing days.\r\n     * @param _stepIndex An array of uint256 values representing step indices.\r\n     * @param _data A tuple of two uint64 values.\r\n     * @param _signature The signature to be validated.\r\n     * @notice This function is used to verify the authenticity of a provided signature\r\n     *         based on certain criteria, including the provided data and time window.\r\n     *         It is an external function to allow external contracts to perform signature verification.\r\n     */\r\n    function checkValidSignature(\r\n        uint256[] memory _day,\r\n        uint256[] memory _stepIndex,\r\n        uint64[2] memory _data,\r\n        bytes memory _signature\r\n    ) external;\r\n}\r\n\r\n// File: Challenge/IERC721Receiver.sol\r\n\r\n\r\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n * from ERC721 asset contracts.\r\n */\r\ninterface IERC721Receiver {\r\n    /**\r\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\r\n     * by `operator` from `from`, this function is called.\r\n     *\r\n     * It must return its Solidity selector to confirm the token transfer.\r\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\r\n     *\r\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n// File: Challenge/IERC20.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.16;\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the ERC-20 token symbol.\r\n     */\r\n    function symbol() external view returns(string memory);\r\n}\r\n// File: Challenge/ChallengeDetail.sol\r\n\r\n\r\n\r\npragma solidity ^0.8.16;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract ChallengeDetail is IERC721Receiver {\r\n    /** @param ChallengeState currentState of challenge:\r\n         1 : in processs\r\n         2 : success\r\n         3 : failed\r\n         4 : gave up\r\n         5 : closed\r\n    */\r\n    enum ChallengeState {\r\n        PROCESSING,\r\n        SUCCESS,\r\n        FAILED,\r\n        GAVE_UP,\r\n        CLOSED\r\n    }\r\n\r\n    /** @dev returnedNFTWallet received NFT when Success\r\n     */\r\n    address private returnedNFTWallet;\r\n\r\n    /** @dev erc20ListAddress list address of erc-20 contract.\r\n     */\r\n    address[] private erc20ListAddress;\r\n\r\n    /** @dev erc721Address address of erc-721 contract.\r\n     */\r\n    address[] public erc721Address;\r\n\r\n    /** @dev sponsor sponsor of challenge.\r\n     */\r\n    address payable public sponsor;\r\n\r\n    /** @dev challenger challenger of challenge.\r\n     */\r\n    address payable public challenger;\r\n\r\n    /** @dev feeAddress feeAddress of challenge.\r\n     */\r\n    address payable private feeAddress;\r\n\r\n    /** @dev awardReceivers list of receivers when challenge success and fail, start by success list.\r\n     */\r\n    address payable[] private awardReceivers;\r\n\r\n    /** @dev awardReceiversApprovals list of award for receivers when challenge success and fail, start by success list.\r\n     */\r\n    uint256[] private awardReceiversApprovals;\r\n\r\n    /** @dev historyData number of steps each day in challenge.\r\n     */\r\n    uint256[] historyData;\r\n\r\n    /** @dev historyDate date in challenge.\r\n     */\r\n    uint256[] historyDate;\r\n\r\n    /** @dev index index to split array receivers.\r\n     */\r\n    uint256 private index;\r\n\r\n    uint256 public indexNft;\r\n\r\n    /** @dev totalReward total reward receiver can receive in challenge.\r\n     */\r\n    uint256 public totalReward;\r\n\r\n    /** @dev gasFee coin for challenger transaction fee. Transfer for challenger when create challenge.\r\n     */\r\n    uint256 private gasFee;\r\n\r\n    /** @dev serverSuccessFee coin for sever when challenge success.\r\n     */\r\n    uint256 private serverSuccessFee;\r\n\r\n    /** @dev serverFailureFee coin for sever when challenge fail.\r\n     */\r\n    uint256 private serverFailureFee;\r\n\r\n    /** @dev duration duration of challenge from start to end time.\r\n     */\r\n    uint256 public duration;\r\n\r\n    /** @dev startTime startTime of challenge.\r\n     */\r\n    uint256 public startTime;\r\n\r\n    /** @dev endTime endTime of challenge.\r\n     */\r\n    uint256 public endTime;\r\n\r\n    /** @dev dayRequired number of day which challenger need to finish challenge.\r\n     */\r\n    uint256 public dayRequired;\r\n\r\n    /** @dev goal number of steps which challenger need to finish in day.\r\n     */\r\n    uint256 public goal;\r\n\r\n    /** @dev currentStatus currentStatus of challenge.\r\n     */\r\n    uint256 currentStatus;\r\n\r\n    /** @dev sumAwardSuccess sumAwardSuccess of challenge.\r\n     */\r\n    uint256 sumAwardSuccess;\r\n\r\n    /** @dev sumAwardFail sumAwardFail of challenge.\r\n     */\r\n    uint256 sumAwardFail;\r\n\r\n    /** @dev sequence submit daily result count number of challenger.\r\n     */\r\n    uint256 sequence;\r\n\r\n    /** @dev allowGiveUp challenge allow give up or not.\r\n     */\r\n    bool[] public allowGiveUp;\r\n\r\n    /** @dev isFinished challenge finish or not.\r\n     */\r\n    bool public isFinished;\r\n\r\n    /** @dev isSuccess challenge success or not.\r\n     */\r\n    bool public isSuccess;\r\n\r\n    /** @dev choiceAwardToSponsor all award will go to sponsor wallet when challenger give up or not.\r\n     */\r\n    bool private choiceAwardToSponsor;\r\n\r\n    /** @dev selectGiveUpStatus challenge need be give up one time.\r\n     */\r\n    bool selectGiveUpStatus;\r\n\r\n    /** @dev approvalSuccessOf get amount of coin an `address` can receive when ckhallenge success.\r\n     */\r\n    mapping(address => uint256) private approvalSuccessOf;\r\n\r\n    /** @dev approvalFailOf get amount of coin an `address` can receive when challenge fail.\r\n     */\r\n    mapping(address => uint256) private approvalFailOf;\r\n\r\n    /** @dev stepOn get step on a day.\r\n     */\r\n    mapping(uint256 => uint256) private stepOn;\r\n\r\n    // Instance of the ChallengeState contract\r\n    ChallengeState private stateInstance;\r\n\r\n    // Array of percentages for award receivers\r\n    uint256[] private awardReceiversPercent;\r\n\r\n    // Mapping of award receivers to the index of their awarded tokens\r\n    mapping(address => uint256[]) private awardTokenReceivers;\r\n\r\n    // Array of balances of all tokens\r\n    uint256[] private listBalanceAllToken;\r\n\r\n    // Array of amounts of tokens to be received by each token receiver\r\n    uint256[] private amountTokenToReceiverList;\r\n\r\n    // Total balance of the base token\r\n    uint256 public totalBalanceBaseToken;\r\n\r\n    // Address of the creator of the token\r\n    address public createByToken;\r\n\r\n    // Represents the amount of success fee in percentage.\r\n    uint8 private amountSuccessFee;\r\n\r\n    // Represents the amount of fail fee in percentage.\r\n    uint8 private amountFailFee;\r\n\r\n    /**\r\n     * @dev Emitted when the daily result is sent.\r\n     * @param currentStatus The current status of the daily result.\r\n     */\r\n    event SendDailyResult(uint256 indexed currentStatus);\r\n\r\n    /**\r\n     * @dev Event emitted when a transfer of tokens is executed.\r\n     * @param to Address of the receiver of the tokens.\r\n     * @param valueSend Amount of tokens transferred.\r\n     */\r\n    event FundTransfer(address indexed to, uint256 indexed valueSend);\r\n\r\n    /**\r\n     * @dev Emitted when a participant gives up on the challenge.\r\n     * @param from The address of the participant who gave up.\r\n     */\r\n    event GiveUp(address indexed from);\r\n\r\n    /**\r\n     * @dev Emitted when a challenge is closed, indicating whether the challenge was successful or not.\r\n     * @param challengeStatus A boolean flag indicating whether the challenge was successful or not.\r\n     */\r\n    event CloseChallenge(bool indexed challengeStatus);\r\n\r\n    /**\r\n     * @dev Action should be called in challenge time.\r\n     */\r\n    modifier onTime() {\r\n        require(block.timestamp >= startTime, \"Challenge has not started yet\");\r\n        require(block.timestamp <= endTime, \"Challenge was finished\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Action should be called in required time.\r\n     */\r\n    modifier onTimeSendResult() {\r\n        require(block.timestamp <= endTime + 2 days, \"Challenge was finished\");\r\n        require(block.timestamp >= startTime, \"Challenge has not started yet\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Action should be called after challenge finish.\r\n     */\r\n    modifier afterFinish() {\r\n        require(\r\n            block.timestamp > endTime + 2 days,\r\n            \"Challenge has not finished yet\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Action should be called when challenge is running.\r\n     */\r\n    modifier available() {\r\n        require(!isFinished, \"Challenge was finished\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Action should be called when challenge was allowed give up.\r\n     */\r\n    modifier canGiveUp() {\r\n        require(allowGiveUp[0], \"Can not give up\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev User only call give up one time.\r\n     */\r\n    modifier notSelectGiveUp() {\r\n        require(!selectGiveUpStatus, \"This challenge was give up\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Action only called from stakeholders.\r\n     */\r\n    modifier onlyStakeHolders() {\r\n        require(\r\n            msg.sender == challenger || msg.sender == sponsor,\r\n            \"Only stakeholders can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Action only called from challenger.\r\n     */\r\n    modifier onlyChallenger() {\r\n        require(\r\n            msg.sender == challenger,\r\n            \"Only challenger can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev verify challenge success or not before close.\r\n     */\r\n    modifier availableForClose() {\r\n        require(!isSuccess && !isFinished, \"Cant call\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor function for creating a new challenge.\r\n     * @param _stakeHolders Array of addresses of the stakeholders participating in the challenge.\r\n     * @param _createByToken The address of the token used to create this challenge.\r\n     * @param _erc721Address Array of addresses of the ERC721 tokens used in the challenge.\r\n     * @param _primaryRequired Array of values representing the primary requirements for each ERC721 token in the challenge.\r\n     * @param _awardReceivers Array of addresses of the receivers who will receive awards if the challenge succeeds.\r\n     * @param _index The index of the current award receiver.\r\n     * @param _allowGiveUp Array of boolean values indicating whether each stakeholder can give up the challenge or not.\r\n     * @param _gasData Array of gas data values for executing the smart contract functions in the challenge.\r\n     * @param _allAwardToSponsorWhenGiveUp A boolean value indicating whether all awards should be given to the sponsor when the challenge is given up.\r\n     * @param _awardReceiversPercent Array of percentage values representing the percentage of awards that each award receiver will receive.\r\n     * @param _totalAmount The total amount of tokens locked in the challenge.\r\n     */\r\n    constructor(\r\n        address payable[] memory _stakeHolders,\r\n        address _createByToken,\r\n        address[] memory _erc721Address,\r\n        uint256[] memory _primaryRequired,\r\n        address payable[] memory _awardReceivers,\r\n        uint256 _index,\r\n        bool[] memory _allowGiveUp,\r\n        uint256[] memory _gasData,\r\n        bool _allAwardToSponsorWhenGiveUp,\r\n        uint256[] memory _awardReceiversPercent,\r\n        uint256 _totalAmount\r\n    ) payable {\r\n        require(_allowGiveUp.length == 3, \"Invalid allow give up\"); // Checking if _allowGiveUp array length is 3.\r\n\r\n        if (_allowGiveUp[1]) {\r\n            require(msg.value == _totalAmount, \"Invalid award\"); // Checking if msg.value is equal to _totalAmount when _allowGiveUp[1] is true.\r\n        }\r\n\r\n        uint256 i;\r\n\r\n        require(_index > 0, \"Invalid value\"); // Checking if _index is greater than 0.\r\n\r\n        _totalAmount = _totalAmount - _gasData[2]; // Subtracting _gasData[2] from _totalAmount.\r\n\r\n        uint256[] memory awardReceiversApprovalsTamp = new uint256[](\r\n            _awardReceiversPercent.length\r\n        ); // Creating a new array with length equal to _awardReceiversPercent length.\r\n\r\n        for (uint256 j = 0; j < _awardReceiversPercent.length; j++) {\r\n            awardReceiversApprovalsTamp[j] =\r\n                (_awardReceiversPercent[j] * _totalAmount) /\r\n                100; // Calculating the award amount for each receiver.\r\n        }\r\n\r\n        require(\r\n            _awardReceivers.length == awardReceiversApprovalsTamp.length,\r\n            \"Invalid lists\"\r\n        ); // Checking if _awardReceivers length is equal to awardReceiversApprovalsTamp length.\r\n\r\n        for (i = 0; i < _index; i++) {\r\n            require(awardReceiversApprovalsTamp[i] > 0, \"Invalid value0\"); // Checking if the award amount for each receiver is greater than 0.\r\n            approvalSuccessOf[_awardReceivers[i]] = awardReceiversApprovalsTamp[\r\n                i\r\n            ]; // Setting the award amount for successful participants.\r\n            sumAwardSuccess = sumAwardSuccess + awardReceiversApprovalsTamp[i]; // Summing up the award amounts for successful participants.\r\n        }\r\n\r\n        for (i = _index; i < _awardReceivers.length; i++) {\r\n            require(awardReceiversApprovalsTamp[i] > 0, \"Invalid value1\"); // Checking if the award amount for each receiver is greater than 0.\r\n            approvalFailOf[_awardReceivers[i]] = awardReceiversApprovalsTamp[i]; // Setting the award amount for failed participants.\r\n            sumAwardFail = sumAwardFail + awardReceiversApprovalsTamp[i]; // Summing up the award amounts for failed participants.\r\n        }\r\n\r\n        sponsor = _stakeHolders[0]; // Setting the sponsor address.\r\n        challenger = _stakeHolders[1]; // Setting the challenger address.\r\n        feeAddress = _stakeHolders[2]; // Setting the fee address.\r\n        erc721Address = _erc721Address; // Setting the ERC721 contract address.\r\n        erc20ListAddress = IExerciseSupplementNFT(_erc721Address[0])\r\n            .getErc20ListAddress(); // Getting the ERC20 list address from the ERC721 contract.\r\n        returnedNFTWallet = IExerciseSupplementNFT(_erc721Address[0])\r\n            .returnedNFTWallet(); // Get the address of the returned NFT wallet from the ExerciseSupplementNFT contract\r\n        duration = _primaryRequired[0]; // Setting the duration of the challenge.\r\n        startTime = _primaryRequired[1]; // Setting the start time of the challenge.\r\n        endTime = _primaryRequired[2]; // Setting the end time of the challenge.\r\n        goal = _primaryRequired[3]; // Setting the goal of the challenge.\r\n        dayRequired = _primaryRequired[4]; // Setting the required number of days for the challenge.\r\n        stateInstance = ChallengeState.PROCESSING; // Setting the challenge state to PROCESSING.\r\n        awardReceivers = _awardReceivers; // Setting the list of award receivers.\r\n        awardReceiversApprovals = awardReceiversApprovalsTamp; // Setting the awardReceiversApprovals\r\n        awardReceiversPercent = _awardReceiversPercent; // Assigning the award percentage to the contract variable\r\n        index = _index; // Assigning the index value to the contract variable\r\n        gasFee = _gasData[2]; // Assigning the gas fee to the contract variable\r\n        createByToken = _createByToken; // Assigning the create by token value to the contract variable\r\n\r\n        // get amoutn base fee\r\n        (amountSuccessFee, amountFailFee) = IChallengeFee(\r\n            IExerciseSupplementNFT(_erc721Address[0]).feeSettingAddress()\r\n        ).getAmountFee();\r\n\r\n        totalReward = _totalAmount; // Assigning the total reward to the contract variable\r\n        allowGiveUp = _allowGiveUp; // Assigning the allow give up value to the contract variable\r\n\r\n        // Checking if give up is allowed and all awards should be given to the sponsor, then set the choiceAwardToSponsor variable to true\r\n        if (_allowGiveUp[0] && _allAwardToSponsorWhenGiveUp)\r\n            choiceAwardToSponsor = true;\r\n\r\n        // Transferring the gas fee from the challenger to the contract and emitting an event\r\n        tranferCoinNative(challenger, gasFee);\r\n        emit FundTransfer(challenger, gasFee);\r\n    }\r\n\r\n    /**\r\n     * @dev This function allows the contract to receive native currency of the network.\r\n     * It checks if the sale is finished, and if it is, it transfers the native coins to the sender.\r\n     * @notice This function is triggered automatically when native coins are sent to the contract address.\r\n     */\r\n    receive() external payable {\r\n        if (isFinished) {\r\n            // Check if the sale is finished\r\n            tranferCoinNative(payable(msg.sender), msg.value); // Transfer the native coins to the sender\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Send daily results to update contract activities.\r\n     * @param _day An array of uint256 values representing days.\r\n     * @param _stepIndex An array of uint256 values representing step indices.\r\n     * @param _data A tuple of two uint64 values.\r\n     * @param _signature The signature to be validated.\r\n     * @param _listGachaAddress An array of addresses representing Gacha contract addresses.\r\n     * @param _listNFTAddress An array of addresses representing NFT contract addresses.\r\n     * @param _listIndexNFT An array of arrays representing NFT indices.\r\n     * @param _listSenderAddress An array of arrays representing sender addresses.\r\n     * @param _statusTypeNft An array of boolean values representing NFT status types.\r\n     * @notice This function is used to send daily results for updating contract activities.\r\n     *         It requires specific roles (onlyChallenger) and enforces timing constraints (onTimeSendResult).\r\n     *         It processes various input data related to Gacha and NFT contracts to update activities.\r\n     *         The provided signature is validated to ensure the authenticity of the data.\r\n     * @dev This function can only be called by authorized challengers within a specific time frame.\r\n     */\r\n    function sendDailyResult(\r\n        uint256[] memory _day,\r\n        uint256[] memory _stepIndex,\r\n        uint64[2] memory _data,\r\n        bytes calldata _signature,\r\n        address[] memory _listGachaAddress,\r\n        address[] memory _listNFTAddress,\r\n        uint256[][] memory _listIndexNFT,\r\n        address[][] memory _listSenderAddress,\r\n        bool[] memory _statusTypeNft\r\n    ) public available onTimeSendResult onlyChallenger {\r\n        // Call the checkValidSignature function on the first ERC721 contract address\r\n        IExerciseSupplementNFT(erc721Address[0]).checkValidSignature(\r\n            _day,\r\n            _stepIndex,\r\n            _data,\r\n            _signature\r\n        );\r\n\r\n        // Loop through each day and update the step count data\r\n        for (uint256 i = 0; i < _day.length; i++) {\r\n            // Check if the step count data for this day has already been updated\r\n            require(\r\n                stepOn[_day[i]] == 0,\r\n                \"This day's data had already updated\"\r\n            );\r\n            // Update the step count data for this day\r\n            stepOn[_day[i]] = _stepIndex[i];\r\n            // Add the updated step count data to the history\r\n            historyDate.push(_day[i]);\r\n            historyData.push(_stepIndex[i]);\r\n            // Check if the step count for this day meets the goal and the challenge has not been completed yet\r\n            if (_stepIndex[i] >= goal && currentStatus < dayRequired) {\r\n                // Increment the current status of the challenge\r\n                currentStatus = currentStatus + 1;\r\n            }\r\n        }\r\n\r\n        // Increment the sequence of updates\r\n        sequence = sequence + _day.length;\r\n\r\n        // Check if the challenge has failed due to too many missed days\r\n        if (sequence - currentStatus > duration - dayRequired) {\r\n            stateInstance = ChallengeState.FAILED;\r\n            // Transfer funds to the receiver addresses for the failed challenge\r\n            transferToListReceiverFail(\r\n                _listNFTAddress,\r\n                _listIndexNFT,\r\n                _listSenderAddress,\r\n                _statusTypeNft\r\n            );\r\n        } else {\r\n            // Check if the challenge has been completed successfully\r\n            if (currentStatus >= dayRequired) {\r\n                stateInstance = ChallengeState.SUCCESS;\r\n                // Transfer funds to the receiver addresses for the successful challenge\r\n                transferToListReceiverSuccess(\r\n                    _listNFTAddress,\r\n                    _listIndexNFT,\r\n                    _statusTypeNft\r\n                );\r\n            }\r\n        }\r\n\r\n        // Loop through each gacha instance and invoke random rewards\r\n        for (uint256 i = 0; i < _listGachaAddress.length; i++) {\r\n            IGacha(_listGachaAddress[i]).randomRewards(\r\n                address(this),\r\n                _stepIndex\r\n            );\r\n        }\r\n\r\n        // Emit an event for the current status of the challenge\r\n        emit SendDailyResult(currentStatus);\r\n    }\r\n\r\n    /**\r\n     * @dev Give up function to handle NFT transfers when a user decides to give up.\r\n     * @param _listNFTAddress An array of NFT contract addresses.\r\n     * @param _listIndexNFT An array of arrays containing indices of NFTs to transfer.\r\n     * @param _listSenderAddress An array of arrays containing sender addresses for each NFT.\r\n     * @param _statusTypeNft An array indicating the status type of each NFT.\r\n     */\r\n    function giveUp(\r\n        address[] memory _listNFTAddress,\r\n        uint256[][] memory _listIndexNFT,\r\n        address[][] memory _listSenderAddress,\r\n        bool[] memory _statusTypeNft\r\n    ) external canGiveUp notSelectGiveUp onTime available onlyStakeHolders {\r\n        updateRewardSuccessAndfail();\r\n\r\n        uint256 remainningAmountFee = uint256(100) - amountFailFee;\r\n\r\n        uint256 amount = (address(this).balance * remainningAmountFee) / 100;\r\n\r\n        if (choiceAwardToSponsor) {\r\n            tranferCoinNative(sponsor, amount);\r\n            for (uint256 i = 0; i < erc20ListAddress.length; i++) {\r\n                uint256 realBalanceToken = getBalanceTokenOfContract(\r\n                    erc20ListAddress[i],\r\n                    address(this)\r\n                );\r\n                if (remainningAmountFee > 0 && realBalanceToken > 0) {\r\n                    TransferHelper.safeTransfer(\r\n                        erc20ListAddress[i],\r\n                        sponsor,\r\n                        (listBalanceAllToken[i] * remainningAmountFee) / 100\r\n                    );\r\n                }\r\n            }\r\n\r\n            emit FundTransfer(sponsor, amount);\r\n        } else {\r\n            uint256 amountToReceiverList = (amount * currentStatus) /\r\n                dayRequired;\r\n\r\n            tranferCoinNative(sponsor, amount - amountToReceiverList);\r\n\r\n            for (uint256 i = 0; i < erc20ListAddress.length; i++) {\r\n                uint256 amountTokenToReceiver;\r\n                uint256 totalTokenRewardSubtractFee = (listBalanceAllToken[i] *\r\n                    remainningAmountFee) / 100;\r\n\r\n                if (\r\n                    getBalanceTokenOfContract(\r\n                        erc20ListAddress[i],\r\n                        address(this)\r\n                    ) > 0\r\n                ) {\r\n                    amountTokenToReceiver =\r\n                        (totalTokenRewardSubtractFee * currentStatus) /\r\n                        dayRequired;\r\n\r\n                    uint256 amountNativeToSponsor = totalTokenRewardSubtractFee -\r\n                            amountTokenToReceiver;\r\n\r\n                    TransferHelper.safeTransfer(\r\n                        erc20ListAddress[i],\r\n                        sponsor,\r\n                        amountNativeToSponsor\r\n                    );\r\n\r\n                    amountTokenToReceiverList.push(amountTokenToReceiver);\r\n                }\r\n            }\r\n\r\n            for (uint256 i = 0; i < index; i++) {\r\n                if (amount > 0) {\r\n                    tranferCoinNative(\r\n                        awardReceivers[i],\r\n                        (approvalSuccessOf[awardReceivers[i]] *\r\n                            amountToReceiverList) / amount\r\n                    );\r\n                }\r\n\r\n                for (uint256 j = 0; j < erc20ListAddress.length; j++) {\r\n                    if (\r\n                        getBalanceTokenOfContract(\r\n                            erc20ListAddress[j],\r\n                            address(this)\r\n                        ) > 0\r\n                    ) {\r\n                        uint256 amountTokenTmp = (awardTokenReceivers[\r\n                            erc20ListAddress[j]\r\n                        ][i] * amountTokenToReceiverList[j]) /\r\n                            ((listBalanceAllToken[j] * remainningAmountFee) /\r\n                                100);\r\n\r\n                        TransferHelper.safeTransfer(\r\n                            erc20ListAddress[j],\r\n                            awardReceivers[i],\r\n                            amountTokenTmp\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        transferNFTForSenderWhenFailed(\r\n            _listNFTAddress,\r\n            _listIndexNFT,\r\n            _listSenderAddress,\r\n            _statusTypeNft\r\n        );\r\n\r\n        tranferCoinNative(feeAddress, serverFailureFee);\r\n        emit FundTransfer(feeAddress, serverFailureFee);\r\n\r\n        isFinished = true;\r\n        selectGiveUpStatus = true;\r\n        stateInstance = ChallengeState.GAVE_UP;\r\n        emit GiveUp(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Closes the challenge and performs necessary actions for handling the failure scenario.\r\n     * @param _listNFTAddress The list of NFT contract addresses.\r\n     * @param _listIndexNFT The list of NFT indices for each address.\r\n     * @param _listSenderAddress The list of sender addresses for each NFT.\r\n     * @param _statusTypeNft The status of each NFT (true for ERC721, false for ERC1155).\r\n     */\r\n    function closeChallenge(\r\n        address[] memory _listNFTAddress,\r\n        uint256[][] memory _listIndexNFT,\r\n        address[][] memory _listSenderAddress,\r\n        bool[] memory _statusTypeNft\r\n    ) external onlyStakeHolders afterFinish availableForClose {\r\n        // Transfer NFTs and handle failure scenario for receivers\r\n        transferToListReceiverFail(\r\n            _listNFTAddress,\r\n            _listIndexNFT,\r\n            _listSenderAddress,\r\n            _statusTypeNft\r\n        );\r\n\r\n        // Update challenge state to CLOSED\r\n        stateInstance = ChallengeState.CLOSED;\r\n\r\n        // Emit event to indicate the challenge is closed\r\n        emit CloseChallenge(false);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw tokens on completion function to handle the withdrawal of tokens and NFTs on completion of a task.\r\n     * @param _listTokenErc20 An array of ERC20 token contract addresses.\r\n     * @param _listNFTAddress An array of NFT contract addresses.\r\n     * @param _listIndexNFT An array of arrays containing indices of NFTs to transfer.\r\n     * @param _statusTypeNft An array indicating the status type of each NFT.\r\n     */\r\n    function withdrawTokensOnCompletion(\r\n        address[] memory _listTokenErc20,\r\n        address[] memory _listNFTAddress,\r\n        uint256[][] memory _listIndexNFT,\r\n        bool[] memory _statusTypeNft\r\n    ) external {\r\n        require(isFinished, \"The challenge has not yet been finished\");\r\n        require(\r\n            returnedNFTWallet == msg.sender,\r\n            \"Only returned nft wallet address\"\r\n        );\r\n\r\n        // Transfer ERC20 tokens\r\n        for (uint256 i = 0; i < _listTokenErc20.length; i++) {\r\n            address tokenErc20 = _listTokenErc20[i];\r\n            uint256 balanceErc20 = IERC20(tokenErc20).balanceOf(address(this));\r\n\r\n            TransferHelper.safeTransfer(\r\n                tokenErc20,\r\n                returnedNFTWallet,\r\n                balanceErc20\r\n            );\r\n        }\r\n\r\n        transferNFTForSenderWhenFinish(\r\n            _listNFTAddress,\r\n            _listIndexNFT,\r\n            _statusTypeNft,\r\n            returnedNFTWallet\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer NFTs to a list of receivers successfully.\r\n     * @param _listNFTAddress An array of NFT contract addresses.\r\n     * @param _listIndexNFT An array of arrays containing indices of NFTs to transfer.\r\n     * @param _statusTypeNft An array indicating the status type of each NFT.\r\n     */\r\n    function transferToListReceiverSuccess(\r\n        address[] memory _listNFTAddress,\r\n        uint256[][] memory _listIndexNFT,\r\n        bool[] memory _statusTypeNft\r\n    ) private {\r\n        updateRewardSuccessAndfail();\r\n\r\n        tranferCoinNative(feeAddress, serverSuccessFee);\r\n        emit FundTransfer(feeAddress, serverSuccessFee);\r\n\r\n        for (uint256 i = 0; i < index; i++) {\r\n            tranferCoinNative(\r\n                awardReceivers[i],\r\n                approvalSuccessOf[awardReceivers[i]]\r\n            );\r\n\r\n            for (uint256 j = 0; j < erc20ListAddress.length; j++) {\r\n                if (\r\n                    getBalanceTokenOfContract(\r\n                        erc20ListAddress[j],\r\n                        address(this)\r\n                    ) > 0\r\n                ) {\r\n                    TransferHelper.safeTransfer(\r\n                        erc20ListAddress[j],\r\n                        awardReceivers[i],\r\n                        awardTokenReceivers[erc20ListAddress[j]][i]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        if (allowGiveUp[2]) {\r\n            address currentAddressNftUse;\r\n            (currentAddressNftUse, indexNft) = IExerciseSupplementNFT(\r\n                erc721Address[0]\r\n            ).safeMintNFT(\r\n                    goal,\r\n                    duration,\r\n                    dayRequired,\r\n                    createByToken,\r\n                    totalReward,\r\n                    awardReceiversPercent[0],\r\n                    address(awardReceivers[0]),\r\n                    address(challenger)\r\n                );\r\n            erc721Address.push(currentAddressNftUse);\r\n        }\r\n\r\n        transferNFTForSenderWhenFinish(\r\n            _listNFTAddress,\r\n            _listIndexNFT,\r\n            _statusTypeNft,\r\n            challenger\r\n        );\r\n\r\n        isSuccess = true;\r\n        isFinished = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers NFTs and handles the failure scenario for the list of receivers.\r\n     * @param _listNFTAddress The list of NFT contract addresses.\r\n     * @param _listIndexNFT The list of NFT indices for each address.\r\n     * @param _listSenderAddress The list of sender addresses for each NFT.\r\n     * @param _statusTypeNft The status of each NFT (true for ERC721, false for ERC1155).\r\n     */\r\n    function transferToListReceiverFail(\r\n        address[] memory _listNFTAddress,\r\n        uint256[][] memory _listIndexNFT,\r\n        address[][] memory _listSenderAddress,\r\n        bool[] memory _statusTypeNft\r\n    ) private {\r\n        updateRewardSuccessAndfail();\r\n\r\n        // Transfer server failure fee to fee address\r\n        tranferCoinNative(feeAddress, serverFailureFee);\r\n        emit FundTransfer(feeAddress, serverFailureFee);\r\n\r\n        // Transfer rewards and tokens to all receivers\r\n        for (uint256 i = index; i < awardReceivers.length; i++) {\r\n            // Transfer ETH rewards to receiver\r\n            tranferCoinNative(\r\n                awardReceivers[i],\r\n                approvalFailOf[awardReceivers[i]]\r\n            );\r\n\r\n            // Transfer ERC20 token rewards to receiver\r\n            for (uint256 j = 0; j < erc20ListAddress.length; j++) {\r\n                if (\r\n                    getBalanceTokenOfContract(\r\n                        erc20ListAddress[j],\r\n                        address(this)\r\n                    ) > 0\r\n                ) {\r\n                    TransferHelper.safeTransfer(\r\n                        erc20ListAddress[j],\r\n                        awardReceivers[i],\r\n                        awardTokenReceivers[erc20ListAddress[j]][i]\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        // Transfer NFTs to their original owners\r\n        transferNFTForSenderWhenFailed(\r\n            _listNFTAddress,\r\n            _listIndexNFT,\r\n            _listSenderAddress,\r\n            _statusTypeNft\r\n        );\r\n\r\n        // Emit event and mark challenge as finished\r\n        emit CloseChallenge(false);\r\n        isFinished = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer NFTs back to the sender when the task is finished.\r\n     * @param _listNFTAddress An array of NFT contract addresses.\r\n     * @param _listIndexNFT An array of arrays containing indices of NFTs to transfer.\r\n     * @param _statusTypeNft An array indicating the status type of each NFT.\r\n     * @param _receiveAddress The address to receive the transferred NFTs.\r\n     */\r\n    function transferNFTForSenderWhenFinish(\r\n        address[] memory _listNFTAddress,\r\n        uint256[][] memory _listIndexNFT,\r\n        bool[] memory _statusTypeNft,\r\n        address _receiveAddress\r\n    ) private {\r\n        // Iterate through the list of ERC721 contracts\r\n        for (uint256 i = 0; i < _listNFTAddress.length; i++) {\r\n            if (_statusTypeNft[i]) {\r\n                for (uint256 j = 0; j < _listIndexNFT[i].length; j++) {\r\n                    // Transfer the NFT to the sender\r\n                    TransferHelper.safeTransferFrom(\r\n                        _listNFTAddress[i],\r\n                        address(this),\r\n                        _receiveAddress,\r\n                        _listIndexNFT[i][j]\r\n                    );\r\n                }\r\n            } else {\r\n                for (uint256 j = 0; j < _listIndexNFT[i].length; j++) {\r\n                    uint256 balanceTokenERC1155 = IERC1155(_listNFTAddress[i])\r\n                        .balanceOf(address(this), _listIndexNFT[i][j]);\r\n                    // Encode data transfer token\r\n                    bytes memory extraData = abi.encode(\r\n                        address(this),\r\n                        _receiveAddress,\r\n                        _listIndexNFT[i][j],\r\n                        balanceTokenERC1155\r\n                    );\r\n\r\n                    // Transfer the NFT to the sender\r\n                    TransferHelper.safeTransferNFT1155(\r\n                        _listNFTAddress[i],\r\n                        address(this),\r\n                        _receiveAddress,\r\n                        _listIndexNFT[i][j],\r\n                        balanceTokenERC1155,\r\n                        extraData\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer NFTs back to the sender when the task fails.\r\n     * @param _listNFTAddress An array of NFT contract addresses.\r\n     * @param _listIndexNFT An array of arrays containing indices of NFTs to transfer.\r\n     * @param _listSenderAddress An array of arrays containing sender addresses for each NFT.\r\n     * @param _statusTypeNft An array indicating the status type of each NFT.\r\n     */\r\n    function transferNFTForSenderWhenFailed(\r\n        address[] memory _listNFTAddress,\r\n        uint256[][] memory _listIndexNFT,\r\n        address[][] memory _listSenderAddress,\r\n        bool[] memory _statusTypeNft\r\n    ) private {\r\n        // Iterate through the list of ERC721 contracts\r\n        for (uint256 i = 0; i < _listNFTAddress.length; i++) {\r\n            if (_statusTypeNft[i]) {\r\n                for (uint256 j = 0; j < _listIndexNFT[i].length; j++) {\r\n                    // Transfer the NFT to the sender\r\n                    TransferHelper.safeTransferFrom(\r\n                        _listNFTAddress[i],\r\n                        address(this),\r\n                        _listSenderAddress[i][j],\r\n                        _listIndexNFT[i][j]\r\n                    );\r\n                }\r\n            } else {\r\n                uint256 lengthListIndexNFT = _listIndexNFT[i].length / 2;\r\n                for (uint256 j = 0; j < lengthListIndexNFT; j++) {\r\n                    uint256 balanceTokenERC1155 = _listIndexNFT[i][\r\n                        j + lengthListIndexNFT\r\n                    ];\r\n\r\n                    // Encode data transfer token\r\n                    bytes memory extraData = abi.encode(\r\n                        address(this),\r\n                        _listSenderAddress[i][j],\r\n                        _listIndexNFT[i][j],\r\n                        balanceTokenERC1155\r\n                    );\r\n\r\n                    // Transfer the NFT to the sender\r\n                    TransferHelper.safeTransferNFT1155(\r\n                        _listNFTAddress[i],\r\n                        address(this),\r\n                        _listSenderAddress[i][j],\r\n                        _listIndexNFT[i][j],\r\n                        balanceTokenERC1155,\r\n                        extraData\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Update reward for successful and failed challenges\r\n    function updateRewardSuccessAndfail() private {\r\n        // Update balance Matic and token\r\n        uint256 coinNativeBalance = address(this).balance;\r\n\r\n        if (coinNativeBalance > 0) {\r\n            serverSuccessFee = (coinNativeBalance * amountSuccessFee) / (100);\r\n            serverFailureFee = (coinNativeBalance * amountFailFee) / (100);\r\n\r\n            for (uint256 i = 0; i < awardReceivers.length; i++) {\r\n                approvalSuccessOf[awardReceivers[i]] =\r\n                    (awardReceiversPercent[i] * coinNativeBalance) /\r\n                    100;\r\n                sumAwardSuccess =\r\n                    (awardReceiversPercent[i] * coinNativeBalance) /\r\n                    100;\r\n            }\r\n\r\n            for (uint256 i = index; i < awardReceivers.length; i++) {\r\n                approvalFailOf[awardReceivers[i]] =\r\n                    (awardReceiversPercent[i] * coinNativeBalance) /\r\n                    100;\r\n                sumAwardFail =\r\n                    (awardReceiversPercent[i] * coinNativeBalance) /\r\n                    100;\r\n            }\r\n        }\r\n        // Get total balance of base token in contract\r\n        totalBalanceBaseToken = getContractBalance();\r\n\r\n        // Loop through all ERC20 tokens in list\r\n        for (uint256 i = 0; i < erc20ListAddress.length; i++) {\r\n            // Get balance of current ERC20 token\r\n            listBalanceAllToken.push(\r\n                IERC20(erc20ListAddress[i]).balanceOf(address(this))\r\n            );\r\n\r\n            // Check if contract holds any balance of current ERC20 token\r\n            if (\r\n                getBalanceTokenOfContract(erc20ListAddress[i], address(this)) >\r\n                0\r\n            ) {\r\n                // Loop through all award receivers percentage\r\n                for (uint256 j = 0; j < awardReceiversPercent.length; j++) {\r\n                    // Calculate the amount of ERC20 token to award to current receiver\r\n                    uint256 awardAmount = (awardReceiversPercent[j] *\r\n                        IERC20(erc20ListAddress[i]).balanceOf(address(this))) /\r\n                        100;\r\n                    // Add the award amount to receiver's balance for current ERC20 token\r\n                    awardTokenReceivers[erc20ListAddress[i]].push(awardAmount);\r\n                }\r\n\r\n                // Transfer fee of current ERC20 token to fee address as fee\r\n                uint256 realAmountFee = (listBalanceAllToken[i] *\r\n                    amountFailFee) / (100);\r\n                if (realAmountFee > 0) {\r\n                    TransferHelper.safeTransfer(\r\n                        erc20ListAddress[i],\r\n                        feeAddress,\r\n                        realAmountFee\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Returns the owner of the specified ERC721 token.\r\n    function getOwnerOfNft(\r\n        address _erc721Address,\r\n        uint256 _index\r\n    ) private view returns (address) {\r\n        return IExerciseSupplementNFT(_erc721Address).ownerOf(_index);\r\n    }\r\n\r\n    // Returns the balance of the contract in the native currency (ether).\r\n    function getContractBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // Returns the history of the challenge as an array of dates and corresponding data values.\r\n    function getChallengeHistory()\r\n        external\r\n        view\r\n        returns (uint256[] memory date, uint256[] memory data)\r\n    {\r\n        return (historyDate, historyData);\r\n    }\r\n\r\n    // Returns the current state of the challenge as an enumerated value.\r\n    function getState() external view returns (ChallengeState) {\r\n        return stateInstance;\r\n    }\r\n\r\n    // Check if the contract has enough balance to transfer\r\n    function tranferCoinNative(address payable from, uint256 value) private {\r\n        if (getContractBalance() >= value) {\r\n            // If the contract has enough balance, transfer the ETH to the 'from' address\r\n            TransferHelper.saveTransferEth(from, value);\r\n        }\r\n    }\r\n\r\n    // Private function to get balance of a specific ERC20 token in the contract\r\n    function getBalanceTokenOfContract(\r\n        address _erc20Address,\r\n        address _fromAddress\r\n    ) private view returns (uint256) {\r\n        return IERC20(_erc20Address).balanceOf(_fromAddress);\r\n    }\r\n\r\n    // Private function to compare two strings\r\n    function compareStrings(\r\n        string memory a,\r\n        string memory b\r\n    ) private pure returns (bool) {\r\n        return (keccak256(abi.encodePacked((a))) ==\r\n            keccak256(abi.encodePacked((b))));\r\n    }\r\n\r\n    // Public function to return all ERC20 token contract addresses\r\n    function allContractERC20() external view returns (address[] memory) {\r\n        return erc20ListAddress;\r\n    }\r\n\r\n    // Return information about the current challenge\r\n    function getChallengeInfo()\r\n        external\r\n        view\r\n        returns (\r\n            uint256 challengeCleared,\r\n            uint256 challengeDayRequired,\r\n            uint256 daysRemained\r\n        )\r\n    {\r\n        return (\r\n            currentStatus, // The current status of the challenge\r\n            dayRequired, // The number of days required to complete the challenge\r\n            dayRequired - (currentStatus) // The number of days remaining in the challenge\r\n        );\r\n    }\r\n\r\n    // Return the array of award receiver percentages\r\n    function getAwardReceiversPercent() public view returns (uint256[] memory) {\r\n        return (awardReceiversPercent);\r\n    }\r\n\r\n    // Return the array of token balances for each token in the contract\r\n    function getBalanceToken() public view returns (uint256[] memory) {\r\n        return listBalanceAllToken;\r\n    }\r\n\r\n    /**\r\n     * This function returns the address of an award receiver at the specified index.\r\n     * If _isAddressSuccess is false, it returns the address of the award receiver who did not approve the transaction.\r\n     * If _isAddressSuccess is true, it returns the address of the award receiver who approved the transaction.\r\n     */\r\n    function getAwardReceiversAtIndex(\r\n        uint256 _index,\r\n        bool _isAddressSuccess\r\n    ) public view returns (address) {\r\n        // If _isAddressSuccess is false, return the address of the award receiver who did not approve the transaction.\r\n        if (!_isAddressSuccess) {\r\n            return awardReceivers[_index + index];\r\n        }\r\n        // If _isAddressSuccess is true, return the address of the award receiver who approved the transaction.\r\n        return awardReceivers[_index];\r\n    }\r\n\r\n    /**\r\n     * @dev onERC721Received.\r\n     */\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes memory\r\n    ) external virtual override returns (bytes4) {\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    /**\r\n     * @dev onERC1155Received.\r\n     */\r\n    function onERC1155Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        uint256,\r\n        bytes memory\r\n    ) public pure returns (bytes4) {\r\n        return this.onERC1155Received.selector;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"_stakeHolders\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"_createByToken\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"_erc721Address\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_primaryRequired\",\"type\":\"uint256[]\"},{\"internalType\":\"address payable[]\",\"name\":\"_awardReceivers\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bool[]\",\"name\":\"_allowGiveUp\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_gasData\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"_allAwardToSponsorWhenGiveUp\",\"type\":\"bool\"},{\"internalType\":\"uint256[]\",\"name\":\"_awardReceiversPercent\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_totalAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"challengeStatus\",\"type\":\"bool\"}],\"name\":\"CloseChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"valueSend\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"}],\"name\":\"GiveUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"currentStatus\",\"type\":\"uint256\"}],\"name\":\"SendDailyResult\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"allContractERC20\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allowGiveUp\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challenger\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_listNFTAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"_listIndexNFT\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"_listSenderAddress\",\"type\":\"address[][]\"},{\"internalType\":\"bool[]\",\"name\":\"_statusTypeNft\",\"type\":\"bool[]\"}],\"name\":\"closeChallenge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createByToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"dayRequired\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"erc721Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_index\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_isAddressSuccess\",\"type\":\"bool\"}],\"name\":\"getAwardReceiversAtIndex\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAwardReceiversPercent\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalanceToken\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChallengeHistory\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"date\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"data\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChallengeInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"challengeCleared\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"challengeDayRequired\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"daysRemained\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getState\",\"outputs\":[{\"internalType\":\"enum ChallengeDetail.ChallengeState\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_listNFTAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"_listIndexNFT\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"_listSenderAddress\",\"type\":\"address[][]\"},{\"internalType\":\"bool[]\",\"name\":\"_statusTypeNft\",\"type\":\"bool[]\"}],\"name\":\"giveUp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"indexNft\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isFinished\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSuccess\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_day\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_stepIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"uint64[2]\",\"name\":\"_data\",\"type\":\"uint64[2]\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"},{\"internalType\":\"address[]\",\"name\":\"_listGachaAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_listNFTAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"_listIndexNFT\",\"type\":\"uint256[][]\"},{\"internalType\":\"address[][]\",\"name\":\"_listSenderAddress\",\"type\":\"address[][]\"},{\"internalType\":\"bool[]\",\"name\":\"_statusTypeNft\",\"type\":\"bool[]\"}],\"name\":\"sendDailyResult\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sponsor\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalBalanceBaseToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_listTokenErc20\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_listNFTAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[][]\",\"name\":\"_listIndexNFT\",\"type\":\"uint256[][]\"},{\"internalType\":\"bool[]\",\"name\":\"_statusTypeNft\",\"type\":\"bool[]\"}],\"name\":\"withdrawTokensOnCompletion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "ChallengeDetail", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000160000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000002e00000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000034000000000000000000000000000000000000000000000000000000000000003c000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000440000000000000000000000000000000000000000000000000002386f26fc1000000000000000000000000000000000000000000000000000000000000000000030000000000000000000000004e447d8c831406e28128321fcda0bad603ca125d0000000000000000000000004e447d8c831406e28128321fcda0bad603ca125d000000000000000000000000e906c97a940911b92159629b89dbe75d55df567c000000000000000000000000000000000000000000000000000000000000000100000000000000000000000055285eccef5487e87c5980c880131acadde7767c0000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000004b00000000000000000000000000000000000000000000000000000000652f803a00000000000000000000000000000000000000000000000000000000659181ef000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000460000000000000000000000000000000000000000000000000000000000000002000000000000000000000000e400dac7164a042288eaa9fe5cd63f9f974c30a60000000000000000000000004e447d8c831406e28128321fcda0bad603ca125d000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000b5e620f480000000000000000000000000000000000000000000000000000000b5e620f480000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000620000000000000000000000000000000000000000000000000000000000000062", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://6c45c0b7dcf416f449f42e763f3b0cd543a4f55b896f6e03fc54c25f11f64723"}