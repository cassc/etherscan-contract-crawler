{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\n// File: @openzeppelin/contracts/utils/Context.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/*\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n// File: @openzeppelin/contracts/access/Ownable.sol\r\n\r\npragma solidity ^0.8.0;\r\n\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _setOwner(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _setOwner(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    function _setOwner(address newOwner) private {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n// File: TechTokenVestingComp2.sol\r\n\r\npragma solidity 0.8.0;\r\n\r\n\r\ninterface ERC20 {\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n}\r\n\r\n/*\r\nInspired by and based on following vesting contract:\r\nhttps://gist.github.com/rstormsf/7cfb0c6b7a835c0c67b4a394b4fd9383\r\n*/\r\ncontract TechTokenVestingComp2 is Ownable {\r\n\r\n    event GrantAdded(address indexed recipient, uint256 grantId);\r\n    event GrantTokensClaimed(address indexed recipient, uint256 amountClaimed);\r\n    event GrantRemoved(address recipient, uint256 amountVested, uint256 amountNotVested);\r\n    event ChangedAdmin(address admin);\r\n\r\n    enum VGroup{VGroup1,\r\n                VGroup2,\r\n                VGroup3,\r\n                VGroup4,\r\n                VGroup5,\r\n                VGroup6,\r\n                VGroup7,\r\n                VGroup8,\r\n                Vgroup9}\r\n\r\n    struct Grant {\r\n        uint256 startTime;\r\n        uint256 amount;\r\n        uint16 vestingDuration; // In months\r\n        uint16 vestingCliff;    // In months\r\n        uint16 daysClaimed;\r\n        address recipient;\r\n        uint256 totalClaimed;\r\n    }\r\n\r\n    // Category of Vesting Group    \r\n    struct VestingGroup {\r\n        uint8 vestingDuration; // In months\r\n        uint8 vestingCliff; // In months\r\n        uint8 percent_tSupply;  // percent of total supply \r\n    }\r\n\r\n    mapping (uint256 => Grant) public tokenGrants;\r\n    mapping (address => uint[]) private activeGrants;\r\n    mapping (VGroup => VestingGroup) private parameter; // Enum mapped to Struct\r\n\r\n    address public admin;\r\n    uint256 public totalVestingCount = 1;\r\n    ERC20 public immutable techToken;\r\n    uint24 constant internal SECONDS_PER_DAY = 86400;\r\n\r\n    /// @notice There are two admin roles - admin and owner\r\n    /// in case of need/risk, owner can substitute/change admin\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin || msg.sender == owner(), \"Not Admin\");\r\n        _;\r\n    }\r\n    modifier onlyValidAddress(address _recipient) {\r\n        require(_recipient != address(0) && _recipient != address(this) && _recipient != address(techToken), \"not valid _recipient\");\r\n        _;\r\n    }\r\n\r\n    constructor(ERC20 _techToken)  {\r\n        require(address(_techToken) != address(0), \"invalid token address\");\r\n        admin = msg.sender;\r\n        techToken = _techToken;\r\n    }\r\n\r\n    /// @notice Add vesting parameters for specific VestingGroup into mapping \"parameters\"\r\n    /// Needs to be called before calling addTokenGrant\r\n    function addVestingGroupParameter(VGroup _name, \r\n                            uint8 _vestingDurationInMonths, \r\n                            uint8 _vestingCliffInMonths, \r\n                            uint8 _percent) \r\n                            external onlyAdmin{\r\n        require(_vestingDurationInMonths >= _vestingCliffInMonths, \"Duration < Cliff\");\r\n        parameter[_name] = VestingGroup(_vestingDurationInMonths, _vestingCliffInMonths, _percent);\r\n    }\r\n\r\n    /// @notice Add one or more token grants\r\n    /// The amount of tokens here needs to be preapproved for this TokenVesting contract before calling this function\r\n    /// @param _recipient Address of the token grant recipient\r\n    /// @param _name Vesting group name, which is mapped to its specific parameters \r\n    /// @param _startTime Grant start time in seconds (unix timestamp)\r\n    /// @param _amount Total number of tokens in grant\r\n    function addTokenGrant(address[] calldata _recipient, \r\n                            VGroup[] calldata _name, \r\n                           uint256[] calldata _startTime,\r\n                           uint256[] calldata _amount)\r\n                            external onlyAdmin {\r\n        require(_recipient.length <= 200, \"Limit of 200 grants in one call exceeded\");\r\n        require(_recipient.length == _name.length, \"Different array length\");\r\n        require(_recipient.length == _startTime.length, \"Different array length\");\r\n        require(_recipient.length == _amount.length, \"Different array length\");\r\n        \r\n        for(uint i=0;i<_recipient.length;i++) {\r\n            require(_amount[i] > 0, \"Amount <= 0\");\r\n\r\n            Grant memory grant = Grant({\r\n                startTime: _startTime[i] == 0 ? currentTime() : _startTime[i],\r\n                amount: _amount[i],\r\n                vestingDuration: parameter[_name[i]].vestingDuration,\r\n                vestingCliff: parameter[_name[i]].vestingCliff,\r\n                daysClaimed: 0,\r\n                totalClaimed: 0,\r\n                recipient: _recipient[i]\r\n            });\r\n\r\n            tokenGrants[totalVestingCount] = grant;\r\n            activeGrants[_recipient[i]].push(totalVestingCount);\r\n\r\n            // Transfer the grant tokens under the control of the vesting contract\r\n            require(techToken.transferFrom(msg.sender, address(this), _amount[i]), \"transfer failed\");\r\n\r\n            emit GrantAdded(_recipient[i], totalVestingCount);\r\n            totalVestingCount++;    //grantId\r\n        }\r\n    }\r\n\r\n    /// @notice Allows a grant recipient to claim their vested tokens. Errors if no tokens have vested\r\n    /// It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\r\n    function claimVestedTokens(uint256 _grantId) external {\r\n        uint16 timeVested;\r\n        uint256 amountVested;\r\n        (timeVested, amountVested) = calculateGrantClaim(_grantId);\r\n        require(amountVested > 0, \"amountVested is 0\");\r\n\r\n        Grant storage tokenGrant = tokenGrants[_grantId];\r\n        tokenGrant.daysClaimed = uint16(tokenGrant.daysClaimed+(timeVested));\r\n        tokenGrant.totalClaimed = uint256(tokenGrant.totalClaimed+(amountVested));\r\n\r\n        require(techToken.transfer(tokenGrant.recipient, amountVested), \"token transfer failed\");\r\n        emit GrantTokensClaimed(tokenGrant.recipient, amountVested);\r\n    }\r\n\r\n    function claimVestedTokensMulti(uint[] calldata _grantIDs) external onlyAdmin\r\n    {\r\n        uint16 timeVested;\r\n        uint256 amountVested;\r\n\r\n        for (uint i = 0; i < _grantIDs.length; i++) {\r\n            (timeVested, amountVested) = calculateGrantClaim(_grantIDs[i]);\r\n\r\n            if (amountVested > 0) {\r\n                Grant storage tokenGrant = tokenGrants[_grantIDs[i]];\r\n                tokenGrant.daysClaimed = uint16(tokenGrant.daysClaimed+(timeVested));\r\n                tokenGrant.totalClaimed = uint256(tokenGrant.totalClaimed+(amountVested));\r\n        \r\n                require(techToken.transfer(tokenGrant.recipient, amountVested), \"token transfer failed\");\r\n                emit GrantTokensClaimed(tokenGrant.recipient, amountVested);\r\n            }\r\n        }   \r\n    }\r\n\r\n    function claimVestedTokensAll() external onlyAdmin\r\n    {\r\n        uint16 timeVested;\r\n        uint256 amountVested;\r\n\r\n        for (uint _grantId = 1; _grantId <= totalVestingCount; _grantId++) {\r\n            (timeVested, amountVested) = calculateGrantClaim(_grantId);\r\n\r\n            if (amountVested > 0) {\r\n                Grant storage tokenGrant = tokenGrants[_grantId];\r\n                tokenGrant.daysClaimed = uint16(tokenGrant.daysClaimed+(timeVested));\r\n                tokenGrant.totalClaimed = uint256(tokenGrant.totalClaimed+(amountVested));\r\n        \r\n                require(techToken.transfer(tokenGrant.recipient, amountVested), \"token transfer failed\");\r\n                emit GrantTokensClaimed(tokenGrant.recipient, amountVested);\r\n            }\r\n        }   \r\n    }\r\n\r\n    /// @notice Terminate token grant transferring all vested tokens to the `_grantId`\r\n    /// and returning all non-vested tokens to the Admin\r\n    /// Secured to the Admin only\r\n    /// @param _grantId grantId of the token grant recipient\r\n    function removeTokenGrant(uint256 _grantId) \r\n        external \r\n        onlyAdmin\r\n    {\r\n        Grant storage tokenGrant = tokenGrants[_grantId];\r\n        address recipient = tokenGrant.recipient;\r\n        uint16 timeVested;\r\n        uint256 amountVested;\r\n        (timeVested, amountVested) = calculateGrantClaim(_grantId);\r\n\r\n        uint256 amountNotVested = (tokenGrant.amount-(tokenGrant.totalClaimed))-(amountVested);\r\n\r\n        tokenGrant.startTime = 0;\r\n        tokenGrant.amount = 0;\r\n        tokenGrant.vestingDuration = 0;\r\n        tokenGrant.vestingCliff = 0;\r\n        tokenGrant.daysClaimed = 0;\r\n        tokenGrant.totalClaimed = 0;\r\n        tokenGrant.recipient = address(0);\r\n\r\n        if (amountVested > 0) require(techToken.transfer(recipient, amountVested), \"token transfer failed\"); \r\n        if (amountNotVested > 0) require(techToken.transfer(owner(), amountNotVested), \"transfer of not-vested tokens failed\");\r\n    \r\n        // Non-vested tokens remain in smart contract\r\n        // They can be withdrawn only using addTokenGrant \r\n        // if (amountNotVested > 0) require(techToken.transfer(msg.sender, amountNotVested), \"token transfer failed\");\r\n\r\n        emit GrantRemoved(recipient, amountVested, amountNotVested);\r\n    }\r\n\r\n    function changeAdmin(address _newAdmin) \r\n        external \r\n        onlyOwner\r\n        onlyValidAddress(_newAdmin)\r\n    {\r\n        admin = _newAdmin;\r\n        emit ChangedAdmin(_newAdmin);\r\n    }\r\n\r\n    function getActiveGrants(address _recipient) public view returns(uint256[] memory){\r\n        return activeGrants[_recipient];\r\n    }\r\n\r\n    /// @notice Calculate the vested and unclaimed months and tokens available for `_grantId` to claim\r\n    /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\r\n    /// Returns (0, 0) if cliff has not been reached\r\n    function calculateGrantClaim(uint256 _grantId) public view returns (uint16, uint256) {\r\n        Grant storage tokenGrant = tokenGrants[_grantId];\r\n\r\n        // For grants created with a future start date, that hasn't been reached, return 0, 0\r\n        if (currentTime() < tokenGrant.startTime) {\r\n            return (0, 0);\r\n        }\r\n\r\n        // Check cliff was reached\r\n        uint elapsedTime = currentTime()-(tokenGrant.startTime);\r\n        uint elapsedDays = elapsedTime/(SECONDS_PER_DAY);\r\n\r\n        if (elapsedDays < tokenGrant.vestingCliff*(30)) {\r\n            return (uint16(elapsedDays), 0);\r\n        }\r\n\r\n        // If over vesting duration, all tokens vested\r\n        if (elapsedDays >= tokenGrant.vestingDuration*(30)) {\r\n            uint256 remainingGrant = tokenGrant.amount-(tokenGrant.totalClaimed);\r\n            return (tokenGrant.vestingDuration, remainingGrant);\r\n        } else {\r\n            uint16 timeVested = uint16(elapsedDays-(tokenGrant.daysClaimed));\r\n            uint256 amountVestedPerDay = tokenGrant.amount/(uint256(tokenGrant.vestingDuration*(30)));\r\n            uint256 amountVested = uint256(timeVested*(amountVestedPerDay));\r\n            return (timeVested, amountVested);\r\n        }\r\n    }\r\n\r\n    function currentTime() public view returns(uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function tokensVestedPerDay(uint256 _grantId) public view returns(uint256) {\r\n        Grant memory tokenGrant = tokenGrants[_grantId];\r\n        return tokenGrant.amount/(uint256(tokenGrant.vestingDuration*(30)));\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"_techToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"ChangedAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"grantId\",\"type\":\"uint256\"}],\"name\":\"GrantAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountVested\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountNotVested\",\"type\":\"uint256\"}],\"name\":\"GrantRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountClaimed\",\"type\":\"uint256\"}],\"name\":\"GrantTokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_recipient\",\"type\":\"address[]\"},{\"internalType\":\"enum TechTokenVestingComp2.VGroup[]\",\"name\":\"_name\",\"type\":\"uint8[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_startTime\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"addTokenGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum TechTokenVestingComp2.VGroup\",\"name\":\"_name\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_vestingDurationInMonths\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_vestingCliffInMonths\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"_percent\",\"type\":\"uint8\"}],\"name\":\"addVestingGroupParameter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_grantId\",\"type\":\"uint256\"}],\"name\":\"calculateGrantClaim\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_grantId\",\"type\":\"uint256\"}],\"name\":\"claimVestedTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimVestedTokensAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_grantIDs\",\"type\":\"uint256[]\"}],\"name\":\"claimVestedTokensMulti\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"getActiveGrants\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_grantId\",\"type\":\"uint256\"}],\"name\":\"removeTokenGrant\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"techToken\",\"outputs\":[{\"internalType\":\"contract ERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenGrants\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"vestingDuration\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"vestingCliff\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"daysClaimed\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalClaimed\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_grantId\",\"type\":\"uint256\"}],\"name\":\"tokensVestedPerDay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalVestingCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "TechTokenVestingComp2", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006286a9e6f7e745a6d884561d88f94542d6715698", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://d2b9df13c8eddb0a63618739b45dee04b09d043fbfcb2bce67bcea8543bfbe46"}