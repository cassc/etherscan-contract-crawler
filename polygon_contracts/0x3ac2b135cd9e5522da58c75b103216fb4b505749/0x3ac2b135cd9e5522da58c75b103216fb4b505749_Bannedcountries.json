{"SourceCode": "pragma solidity 0.6.2;\n\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n\ncontract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() external view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(isOwner(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Returns true if the caller is the current owner.\n     */\n    function isOwner() public view returns (bool) {\n        return _msgSender() == _owner;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() external virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n\ninterface ICompliance {\n\n    /**\n    *  this event is emitted when the Agent has been added on the allowedList of this Compliance.\n    *  the event is emitted by the Compliance constructor and by the addTokenAgent function\n    *  `_agentAddress` is the address of the Agent to add\n    */\n    event TokenAgentAdded(address _agentAddress);\n\n    /**\n    *  this event is emitted when the Agent has been removed from the agent list of this Compliance.\n    *  the event is emitted by the Compliance constructor and by the removeTokenAgent function\n    *  `_agentAddress` is the address of the Agent to remove\n    */\n    event TokenAgentRemoved(address _agentAddress);\n\n    /**\n    *  this event is emitted when a token has been bound to the compliance contract\n    *  the event is emitted by the bindToken function\n    *  `_token` is the address of the token to bind\n    */\n    event TokenBound(address _token);\n\n    /**\n    *  this event is emitted when a token has been unbound from the compliance contract\n    *  the event is emitted by the unbindToken function\n    *  `_token` is the address of the token to unbind\n    */\n    event TokenUnbound(address _token);\n\n    /**\n    *  @dev Returns true if the Address is in the list of token agents\n    *  @param _agentAddress address of this agent\n    */\n    function isTokenAgent(address _agentAddress) external view returns (bool);\n\n    /**\n    *  @dev Returns true if the address given corresponds to a token that is bound with the Compliance contract\n    *  @param _token address of the token\n    */\n    function isTokenBound(address _token) external view returns (bool);\n\n    /**\n     *  @dev adds an agent to the list of token agents\n     *  @param _agentAddress address of the agent to be added\n     *  Emits a TokenAgentAdded event\n     */\n    function addTokenAgent(address _agentAddress) external;\n\n    /**\n    *  @dev remove Agent from the list of token agents\n    *  @param _agentAddress address of the agent to be removed (must be added first)\n    *  Emits a TokenAgentRemoved event\n    */\n    function removeTokenAgent(address _agentAddress) external;\n\n    /**\n     *  @dev binds a token to the compliance contract\n     *  @param _token address of the token to bind\n     *  Emits a TokenBound event\n     */\n    function bindToken(address _token) external;\n\n    /**\n    *  @dev unbinds a token from the compliance contract\n    *  @param _token address of the token to unbind\n    *  Emits a TokenUnbound event\n    */\n    function unbindToken(address _token) external;\n\n\n    /**\n     *  @dev checks that the transfer is compliant.\n     *  default compliance always returns true\n     *  READ ONLY FUNCTION, this function cannot be used to increment\n     *  counters, emit events, ...\n     *  @param _from The address of the sender\n     *  @param _to The address of the receiver\n     *  @param _amount The amount of tokens involved in the transfer\n     */\n    function canTransfer(address _from, address _to, uint256 _amount) external view returns (bool);\n\n    /**\n     *  @dev function called whenever tokens are transferred\n     *  from one wallet to another\n     *  this function can update state variables in the compliance contract\n     *  these state variables being used by `canTransfer` to decide if a transfer\n     *  is compliant or not depending on the values stored in these state variables and on\n     *  the parameters of the compliance smart contract\n     *  @param _from The address of the sender\n     *  @param _to The address of the receiver\n     *  @param _amount The amount of tokens involved in the transfer\n     */\n    function transferred(address _from, address _to, uint256 _amount) external;\n\n    /**\n     *  @dev function called whenever tokens are created\n     *  on a wallet\n     *  this function can update state variables in the compliance contract\n     *  these state variables being used by `canTransfer` to decide if a transfer\n     *  is compliant or not depending on the values stored in these state variables and on\n     *  the parameters of the compliance smart contract\n     *  @param _to The address of the receiver\n     *  @param _amount The amount of tokens involved in the transfer\n     */\n    function created(address _to, uint256 _amount) external;\n\n    /**\n     *  @dev function called whenever tokens are destroyed\n     *  this function can update state variables in the compliance contract\n     *  these state variables being used by `canTransfer` to decide if a transfer\n     *  is compliant or not depending on the values stored in these state variables and on\n     *  the parameters of the compliance smart contract\n     *  @param _from The address of the receiver\n     *  @param _amount The amount of tokens involved in the transfer\n     */\n    function destroyed(address _from, uint256 _amount) external;\n\n    /**\n     *  @dev function used to transfer the ownership of the compliance contract\n     *  to a new owner, giving him access to the `OnlyOwner` functions implemented on the contract\n     *  @param newOwner The address of the new owner of the compliance contract\n     *  This function can only be called by the owner of the compliance contract\n     *  emits an `OwnershipTransferred` event\n     */\n    function transferOwnershipOnComplianceContract(address newOwner) external;\n}\n\ninterface IIdentityRegistry {\n    /**\n    *  @dev Returns the onchainID of an investor.\n    *  @param _userAddress The wallet of the investor\n    */\n    function identity(address _userAddress) external view returns (address);\n\n    /**\n    *  @dev Returns the country code of an investor.\n    *  @param _userAddress The wallet of the investor\n    */\n    function investorCountry(address _userAddress) external view returns (uint16);\n}\n\ninterface IToken {\n    /**\n    *  @dev Returns the Identity Registry linked to the token\n    */\n    function identityRegistry() external view returns (IIdentityRegistry);\n}\n\nabstract contract BasicCompliance is Ownable, ICompliance {\n\n    /// Mapping between agents and their statuses\n    mapping(address => bool) private _tokenAgentsList;\n\n    /// Mapping of tokens linked to the compliance contract\n    IToken _tokenBound;\n\n    /**\n     * @dev Throws if called by any address that is not a token bound to the compliance.\n     */\n    modifier onlyToken() {\n        require(isToken(), \"error : this address is not a token bound to the compliance contract\");\n        _;\n    }\n\n    /**\n    *  @dev Returns the ONCHAINID (Identity) of the _userAddress\n    *  @param _userAddress Address of the wallet\n    */\n    function _getIdentity(address _userAddress) internal view returns (address) {\n        return address(_tokenBound.identityRegistry().identity(_userAddress));\n    }\n\n    function _getCountry(address _userAddress) internal view returns (uint16) {\n        return _tokenBound.identityRegistry().investorCountry(_userAddress);\n    }\n\n    /**\n    *  @dev See {ICompliance-isTokenAgent}.\n    */\n    function isTokenAgent(address _agentAddress) public override view returns (bool) {\n        if (!_tokenAgentsList[_agentAddress]) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n    *  @dev See {ICompliance-isTokenBound}.\n    */\n    function isTokenBound(address _token) public override view returns (bool) {\n        if (_token != address(_tokenBound)){\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     *  @dev See {ICompliance-addTokenAgent}.\n     */\n    function addTokenAgent(address _agentAddress) external override onlyOwner {\n        require(!_tokenAgentsList[_agentAddress], \"This Agent is already registered\");\n        _tokenAgentsList[_agentAddress] = true;\n        emit TokenAgentAdded(_agentAddress);\n    }\n\n    /**\n    *  @dev See {ICompliance-isTokenAgent}.\n    */\n    function removeTokenAgent(address _agentAddress) external override onlyOwner {\n        require(_tokenAgentsList[_agentAddress], \"This Agent is not registered yet\");\n        _tokenAgentsList[_agentAddress] = false;\n        emit TokenAgentRemoved(_agentAddress);\n    }\n\n    /**\n     *  @dev See {ICompliance-bindToken}.\n     */\n    function bindToken(address _token) external override onlyOwner {\n        require(_token != address(_tokenBound), \"This token is already bound\");\n        _tokenBound = IToken(_token);\n        emit TokenBound(_token);\n    }\n\n    /**\n    *  @dev See {ICompliance-unbindToken}.\n    */\n    function unbindToken(address _token) external override onlyOwner {\n        require(_token == address(_tokenBound), \"This token is not bound yet\");\n        delete _tokenBound;\n        emit TokenUnbound(_token);\n    }\n\n    /**\n    *  @dev Returns true if the sender corresponds to a token that is bound with the Compliance contract\n    */\n    function isToken() internal view returns (bool) {\n        return isTokenBound(msg.sender);\n    }\n\n    /**\n    *  @dev See {ICompliance-transferOwnershipOnComplianceContract}.\n    */\n    function transferOwnershipOnComplianceContract(address newOwner) external override onlyOwner {\n        transferOwnership(newOwner);\n    }\n\n}\n\n\n\nabstract contract CountryRestrictions is BasicCompliance {\n\n    /**\n     *  this event is emitted whenever a Country has been restricted.\n     *  the event is emitted by 'addCountryRestriction' and 'batchRestrictCountries' functions.\n     *  `_country` is the numeric ISO 3166-1 of the restricted country.\n     */\n    event AddedRestrictedCountry(uint16 _country);\n\n    /**\n     *  this event is emitted whenever a Country has been unrestricted.\n     *  the event is emitted by 'removeCountryRestriction' and 'batchUnrestrictCountries' functions.\n     *  `_country` is the numeric ISO 3166-1 of the unrestricted country.\n     */\n    event RemovedRestrictedCountry(uint16 _country);\n\n    /// Mapping between country and their restriction status\n    mapping(uint16 => bool) private _restrictedCountries;\n\n    /**\n    *  @dev Returns true if country is Restricted\n    *  @param _country, numeric ISO 3166-1 standard of the country to be checked\n    */\n    function isCountryRestricted(uint16 _country) public view returns (bool) {\n        return (_restrictedCountries[_country]);\n    }\n\n    /**\n    *  @dev Adds country restriction.\n    *  Identities from those countries will be forbidden to manipulate Tokens linked to this Compliance.\n    *  @param _country Country to be restricted, should be expressed by following numeric ISO 3166-1 standard\n    *  Only the owner of the Compliance smart contract can call this function\n    *  emits an `AddedRestrictedCountry` event\n    */\n    function addCountryRestriction(uint16 _country) public onlyOwner {\n        _restrictedCountries[_country] = true;\n        emit AddedRestrictedCountry(_country);\n    }\n\n    /**\n     *  @dev Removes country restriction.\n     *  Identities from those countries will again be authorised to manipulate Tokens linked to this Compliance.\n     *  @param _country Country to be unrestricted, should be expressed by following numeric ISO 3166-1 standard\n     *  Only the owner of the Compliance smart contract can call this function\n     *  emits an `RemovedRestrictedCountry` event\n     */\n    function removeCountryRestriction(uint16 _country) public onlyOwner {\n        _restrictedCountries[_country] = false;\n        emit RemovedRestrictedCountry(_country);\n    }\n\n    /**\n    *  @dev Adds countries restriction in batch.\n    *  Identities from those countries will be forbidden to manipulate Tokens linked to this Compliance.\n    *  @param _countries Countries to be restricted, should be expressed by following numeric ISO 3166-1 standard\n    *  Only the owner of the Compliance smart contract can call this function\n    *  emits an `AddedRestrictedCountry` event\n    */\n    function batchRestrictCountries(uint16[] memory _countries) public onlyOwner {\n        for (uint i = 0; i < _countries.length; i++) {\n            _restrictedCountries[_countries[i]] = true;\n            emit AddedRestrictedCountry(_countries[i]);\n        }\n    }\n\n    /**\n     *  @dev Removes countries restriction in batch.\n     *  Identities from those countries will again be authorised to manipulate Tokens linked to this Compliance.\n     *  @param _countries Countries to be unrestricted, should be expressed by following numeric ISO 3166-1 standard\n     *  Only the owner of the Compliance smart contract can call this function\n     *  emits an `RemovedRestrictedCountry` event\n     */\n    function batchUnrestrictCountries(uint16[] memory _countries) public onlyOwner {\n        for (uint i = 0; i < _countries.length; i++) {\n            _restrictedCountries[_countries[i]] = false;\n            emit RemovedRestrictedCountry(_countries[i]);\n        }\n    }\n\n    function transferActionOnCountryRestrictions(address _from, address _to, uint256 _value) internal {}\n\n    function creationActionOnCountryRestrictions(address _to, uint256 _value) internal {}\n\n    function destructionActionOnCountryRestrictions(address _from, uint256 _value) internal {}\n\n\n    function complianceCheckOnCountryRestrictions (address _from, address _to, uint256 _value)\n    internal view returns (bool) {\n        uint16 receiverCountry = _getCountry(_to);\n        address senderIdentity = _getIdentity(_from);\n        if (isCountryRestricted(receiverCountry)) {\n            return false;\n        }\n        return true;\n    }\n}\n\n\ncontract Bannedcountries is CountryRestrictions {\n    uint[] public features;\n\n    constructor () public {\n        features = [1];\n\n        uint16[] memory restrictedCountries = new uint16[](11);\n        uint16[11] memory inputRestrictedCountries = [uint16(4), 112,70,108,178,180,364,368,408,706,760];\n        for (uint i = 0; i < inputRestrictedCountries.length; i++) {\n            restrictedCountries[i] = inputRestrictedCountries[i];\n        }\n        batchRestrictCountries(restrictedCountries);\n    }\n\n    function getFeatures() public view returns(uint[] memory) {\n        return features;\n    }\n\n    /**\n    *  @dev See {ICompliance-transferred}.\n    */\n    function transferred(address _from, address _to, uint256 _value) external onlyToken override {\n        transferActionOnCountryRestrictions(_from, _to, _value);\n    }\n\n    /**\n    *  @dev See {ICompliance-created}.\n    */\n    function created(address _to, uint256 _value) external onlyToken override {\n        creationActionOnCountryRestrictions(_to, _value);\n    }\n\n    /**\n     *  @dev See {ICompliance-destroyed}.\n     */\n    function destroyed(address _from, uint256 _value) external onlyToken override {\n        destructionActionOnCountryRestrictions(_from, _value);\n    }\n\n    /**\n     *  @dev See {ICompliance-canTransfer}.\n     */\n    function canTransfer(address _from, address _to, uint256 _value) external view override returns (bool) {\n        if (!complianceCheckOnCountryRestrictions(_from, _to, _value)) {\n            return false;\n        }\n\n        return true;\n    }\n}\n", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"AddedRestrictedCountry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"RemovedRestrictedCountry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_agentAddress\",\"type\":\"address\"}],\"name\":\"TokenAgentAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_agentAddress\",\"type\":\"address\"}],\"name\":\"TokenAgentRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"TokenBound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"TokenUnbound\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"addCountryRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agentAddress\",\"type\":\"address\"}],\"name\":\"addTokenAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_countries\",\"type\":\"uint16[]\"}],\"name\":\"batchRestrictCountries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16[]\",\"name\":\"_countries\",\"type\":\"uint16[]\"}],\"name\":\"batchUnrestrictCountries\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"bindToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"canTransfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"created\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"destroyed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"features\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeatures\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"isCountryRestricted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agentAddress\",\"type\":\"address\"}],\"name\":\"isTokenAgent\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"isTokenBound\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_country\",\"type\":\"uint16\"}],\"name\":\"removeCountryRestriction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_agentAddress\",\"type\":\"address\"}],\"name\":\"removeTokenAgent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnershipOnComplianceContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferred\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"unbindToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Bannedcountries", "CompilerVersion": "v0.6.2+commit.bacdbe57", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU LGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}