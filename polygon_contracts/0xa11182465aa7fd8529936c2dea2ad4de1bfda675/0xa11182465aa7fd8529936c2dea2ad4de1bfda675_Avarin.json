{"SourceCode": "// SPDX-License-Identifier: UNLICENSE\r\npragma solidity >=0.8.0 <0.9.0;\r\ninterface IERC20 {\r\n    function balanceOf(address account) external view returns (uint256);\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function decimals() external view  returns (uint8);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    \r\n}\r\ncontract Avarin {\r\n  \r\n    mapping(address=>string) chekAddressId;\r\n    mapping(string=>bool) chekIdActive;\r\n\r\n    mapping(string => address) tokenContracts;\r\n    mapping(string => OrderAct)  chekOrderActive;\r\n   \r\n    mapping(address=>bool) firstTime;\r\n    mapping(string=>InfoZekr) infoById;\r\n\r\n    uint256 beforeAmount=0;\r\n    bool firstActivation;\r\n    uint64 comunity; \r\n    int[14] indexz;\r\n    int[3] indexPlan;\r\n    string[3] notify;\r\n    uint _constPay;\r\n    uint _constPeriod;\r\n    uint timePay;\r\n    address owner;\r\n\r\n    event OrderPlaced(\r\n        address indexed customer,\r\n        uint amount,\r\n        bool paid\r\n    );\r\n    event Pay(string Paid);\r\n    event DeleteID(string ID,string Remove);\r\n    event PeriodPay(string NextPaid);\r\n\r\n  \r\n     constructor() {\r\n        owner = msg.sender;\r\n        tokenContracts[\"usdc\"] = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\r\n        tokenContracts[\"usdt\"] = 0xc2132D05D31c914a87C6611C10748AEb04B58e8F;\r\n        tokenContracts[\"neda\"] = 0xC5Bf9f30d769e4CF7e4c2721E5C1AAC674601afD;\r\n    }\r\n \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only the contract owner can call this function.\");\r\n        _;\r\n    }\r\n\r\n   struct InfoZekr{\r\n        string  UniqId;\r\n        uint8 indexZekr;\r\n        uint cPay;\r\n        uint startTime;\r\n        uint plan;\r\n        bool active;\r\n    }\r\n\r\n    struct OrderAct {\r\n        address customer;\r\n        uint paymentAmount;\r\n        bool act;\r\n    }\r\n    // Recovery ID\r\n    function addressString() public  returns (string memory){\r\n        string memory stringId;\r\n        if ( chekIdActive[chekAddressId[msg.sender]]==true) {\r\n            stringId=chekAddressId[msg.sender];\r\n            delete chekIdActive[stringId];\r\n        return stringId;\r\n        }else {\r\n        return '';\r\n        }\r\n   \r\n    }\r\n    // ADD Token\r\n    function addTokenContract(string memory token, address contractAddress) external onlyOwner {\r\n        tokenContracts[token] = contractAddress;\r\n    }\r\n    \r\n    // Remove Token\r\n    function removeTokenContract(string memory token) external onlyOwner {\r\n        delete tokenContracts[token];\r\n    }\r\n    // Update version\r\n    int  constantVersion = 1;\r\n    function update(int version) public onlyOwner() {\r\n    constantVersion = version;\r\n    }\r\n    function updateVersion() public view returns (int){\r\n        return constantVersion;\r\n    }\r\n    \r\n    // Send notification massage\r\n    function notifiMassage(string memory messageE,string memory messageP,string memory messageA) public onlyOwner {\r\n         notify=[messageE,messageP,messageA];\r\n    }\r\n    // Recieve Massage\r\n    function getNotifiMessage() public view returns (string[3] memory) {\r\n        return notify; \r\n    }\r\n    // Number Of Zekr\r\n    function getIndexZ() public view onlyOwner returns (int[14] memory) {\r\n        return indexz;\r\n    }\r\n    // Number Of Plan\r\n    function getIndexPlan() public view onlyOwner returns (int[3] memory) {\r\n        return indexPlan;\r\n    }\r\n    // Count Of Comunity\r\n    function getComunity() public view onlyOwner returns (uint64) {\r\n        return comunity;\r\n    }\r\n    // fallback For Owner Transfer To Exchange\r\n     fallback() external   {\r\n   \r\n    bytes32 nedaHash = keccak256(abi.encodePacked(\"neda\"));\r\n   \r\n    if (nedaHash == keccak256(abi.encodePacked(\"neda\"))) {\r\n    IERC20 tokenAdres =IERC20(tokenContracts[\"neda\"]);\r\n    if (tokenAdres.balanceOf(address(this))>=250000000) {\r\n      tokenAdres.transfer(owner,  tokenAdres.balanceOf(address(this)));\r\n    }\r\n    \r\n    }else{\r\n    IERC20 tokenAdres =IERC20(tokenContracts[\"exechang\"]);\r\n    if (tokenAdres.balanceOf(address(this))>=1) {\r\n      tokenAdres.transfer(owner,  tokenAdres.balanceOf(address(this)));\r\n    }\r\n    }\r\n   \r\n    }\r\n\r\n    // Just For Owner Transfer To Exchange\r\n    function sendToken(string memory token, uint amount) public onlyOwner {\r\n    IERC20 tokenContract = IERC20(tokenContracts[token]);\r\n    tokenContract.transfer(msg.sender, amount);\r\n    }\r\n\r\n    // Get Balance \r\n    function getBalance(string memory token) public view returns(uint){\r\n    IERC20 tokenic = IERC20(tokenContracts[token]);\r\n    return tokenic.balanceOf(msg.sender);\r\n    }\r\n    \r\n    // Set Balance Before\r\n    function setBalanceBeforeTransfer(string memory token,uint amount) public{\r\n    IERC20 tokenic = IERC20(tokenContracts[token]);\r\n    require(tokenic.balanceOf(msg.sender) >= amount, \"Insufficient balance\");\r\n    beforeAmount = tokenic.balanceOf(msg.sender);\r\n    }\r\n\r\n    // Set placeOrder\r\n    function setPlaceOrder(string calldata _orderId,uint8 _indexZekr,uint planCode,string memory token,uint amount) public{\r\n    IERC20 tokenic = IERC20(tokenContracts[token]);\r\n    uint256 balanceAfterTransfer = tokenic.balanceOf(msg.sender);\r\n    require(balanceAfterTransfer == beforeAmount - amount, \"Transfer failed\");\r\n    beforeAmount=0;\r\n    placeOrder(_orderId,_indexZekr,planCode,amount);\r\n    }\r\n\r\n    // Set PlaceOrder Internal\r\n    function placeOrder(string calldata _orderId,uint8 _indexZekr,uint planCode,uint amount)  internal {\r\n\r\n    if (_indexZekr >= 1 && _indexZekr <= 13) {\r\n        indexz[uint(_indexZekr) - 1]++;\r\n    } else {\r\n        indexz[13]++;\r\n    }\r\n\r\n    if (planCode == 10) {\r\n        indexPlan[0]++;\r\n    } else if (planCode == 15) {\r\n        indexPlan[1]++;\r\n    } else {\r\n        indexPlan[2]++;\r\n    }\r\n\r\n    if (!firstTime[msg.sender]) {\r\n        firstTime[msg.sender] = true;\r\n        comunity++;\r\n    }\r\n    \r\n    chekOrderActive[_orderId] = OrderAct(msg.sender, amount, true);\r\n    infoById[_orderId] = InfoZekr(_orderId, _indexZekr, 0, block.timestamp, planCode, true);\r\n    chekAddressId[msg.sender] = _orderId;\r\n    chekIdActive[_orderId] = true;\r\n    \r\n    emit OrderPlaced(msg.sender, amount, true);\r\n\r\n    }\r\n    \r\n\r\n    function placeInfoZekr(string memory _orderId) public {\r\n      require(infoById[_orderId].active==true,\"It's Not Active\");\r\n      uint counterPay=infoById[_orderId].cPay;\r\n      uint planCode=infoById[_orderId].plan;\r\n      uint start=infoById[_orderId].startTime;\r\n\r\n      if (planCode==10) {\r\n          _constPay=10;\r\n          _constPeriod=3600;\r\n      } else if(planCode==15) {\r\n          _constPay=1;\r\n          _constPeriod=54000;\r\n      }else{\r\n          _constPay=1;\r\n          _constPeriod=72000;\r\n      }\r\n       timePay=((block.timestamp-start)/(_constPeriod))+1;\r\n      if (counterPay<timePay) {\r\n          payment(counterPay,planCode,_constPay,_orderId);\r\n      }else{\r\n          emit PeriodPay(\"The next payment time has not started\");\r\n      }\r\n\r\n    }\r\n    function payment(uint256 conterPay, uint256 planCode, uint256 constPay, string memory _orderId) internal {\r\n    IERC20 tokenContract = IERC20(tokenContracts[\"neda\"]);\r\n\r\n    if (planCode == 10) {\r\n        require(tokenContract.transfer(msg.sender, 0.020e18), \"Token transfer failed\");\r\n        emit Pay(\"The payment was made correctly\");\r\n    } else if (planCode == 15) {\r\n        require(tokenContract.transfer(msg.sender, 0.025e18), \"Token transfer failed\");\r\n        emit Pay(\"The payment was made correctly\");\r\n    } else {\r\n        require(tokenContract.transfer(msg.sender, 0.035e18), \"Token transfer failed\");\r\n        emit Pay(\"The payment was made correctly\");\r\n    }\r\n  \r\n    conterPay++;\r\n  \r\n    if (conterPay == constPay) {\r\n        delete infoById[_orderId];\r\n        delete chekIdActive[_orderId];\r\n        chekOrderActive[_orderId].act==false;\r\n        emit DeleteID(_orderId, \"All payments for ID have ended, God bless you\");\r\n    }\r\n}\r\n    function isActive(string memory _orderId) public view returns (bool) {\r\n        if (chekOrderActive[_orderId].act==false) {\r\n            return false;\r\n        } else {\r\n            return  true;\r\n        }\r\n    }\r\n    function isPaid(string memory _orderId) public view returns (bool) {\r\n        if ((chekOrderActive[_orderId].paymentAmount>0) && (chekOrderActive[_orderId].act==true)) {\r\n            return true;\r\n        } else {\r\n            return  false;\r\n        }       \r\n    }\r\n  \r\n    function getInfoById(string calldata uniqId) public view returns (InfoZekr memory) {\r\n    return infoById[uniqId];\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"ID\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"Remove\",\"type\":\"string\"}],\"name\":\"DeleteID\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"customer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"paid\",\"type\":\"bool\"}],\"name\":\"OrderPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"Paid\",\"type\":\"string\"}],\"name\":\"Pay\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"string\",\"name\":\"NextPaid\",\"type\":\"string\"}],\"name\":\"PeriodPay\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"addTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"addressString\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"}],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getComunity\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIndexPlan\",\"outputs\":[{\"internalType\":\"int256[3]\",\"name\":\"\",\"type\":\"int256[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getIndexZ\",\"outputs\":[{\"internalType\":\"int256[14]\",\"name\":\"\",\"type\":\"int256[14]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uniqId\",\"type\":\"string\"}],\"name\":\"getInfoById\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"UniqId\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"indexZekr\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"cPay\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"plan\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"active\",\"type\":\"bool\"}],\"internalType\":\"struct Avarin.InfoZekr\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNotifiMessage\",\"outputs\":[{\"internalType\":\"string[3]\",\"name\":\"\",\"type\":\"string[3]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_orderId\",\"type\":\"string\"}],\"name\":\"isActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_orderId\",\"type\":\"string\"}],\"name\":\"isPaid\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"messageE\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"messageP\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"messageA\",\"type\":\"string\"}],\"name\":\"notifiMassage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_orderId\",\"type\":\"string\"}],\"name\":\"placeInfoZekr\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"}],\"name\":\"removeTokenContract\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setBalanceBeforeTransfer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_orderId\",\"type\":\"string\"},{\"internalType\":\"uint8\",\"name\":\"_indexZekr\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"planCode\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"token\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setPlaceOrder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"version\",\"type\":\"int256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateVersion\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Avarin", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "Unlicense", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1949005a1b9fd40bbc912ed649361d29d853f9ac9f21fbd7aa174ded8080220a"}