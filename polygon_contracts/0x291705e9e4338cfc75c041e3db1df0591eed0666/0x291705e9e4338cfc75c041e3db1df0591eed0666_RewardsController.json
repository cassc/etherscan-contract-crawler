{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"settings\": {\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 10000\r\n    },\r\n    \"remappings\": [],\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/math/SafeCast.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/PostConstruct.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\n/// @notice Simple contract exposing a modifier used on setup functions\\n/// to prevent them from being called more than once\\n/// @author Solid World DAO\\nabstract contract PostConstruct {\\n    error AlreadyInitialized();\\n\\n    bool private _initialized;\\n\\n    modifier postConstruct() {\\n        if (_initialized) {\\n            revert AlreadyInitialized();\\n        }\\n        _initialized = true;\\n        _;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/rewards/IEACAggregatorProxy.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.7.6 <0.9.0;\\n\\ninterface IEACAggregatorProxy {\\n    function decimals() external view returns (uint8);\\n\\n    function latestAnswer() external view returns (int);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/rewards/IRewardsController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"./IRewardsDistributor.sol\\\";\\nimport \\\"../../libraries/RewardsDataTypes.sol\\\";\\n\\n/// @title IRewardsController\\n/// @author Aave\\n/// @notice Defines the basic interface for a Rewards Controller.\\ninterface IRewardsController is IRewardsDistributor {\\n    error UnauthorizedClaimer(address claimer, address user);\\n    error NotSolidStaking(address sender);\\n    error InvalidRewardOracle(address reward, address rewardOracle);\\n\\n    /// @dev Emitted when a new address is whitelisted as claimer of rewards on behalf of a user\\n    /// @param user The address of the user\\n    /// @param claimer The address of the claimer\\n    event ClaimerSet(address indexed user, address indexed claimer);\\n\\n    /// @dev Emitted when rewards are claimed\\n    /// @param user The address of the user rewards has been claimed on behalf of\\n    /// @param reward The address of the token reward is claimed\\n    /// @param to The address of the receiver of the rewards\\n    /// @param claimer The address of the claimer\\n    /// @param amount The amount of rewards claimed\\n    event RewardsClaimed(\\n        address indexed user,\\n        address indexed reward,\\n        address indexed to,\\n        address claimer,\\n        uint amount\\n    );\\n\\n    /// @dev Emitted when the reward oracle is updated\\n    /// @param reward The address of the token reward\\n    /// @param rewardOracle The address of oracle\\n    event RewardOracleUpdated(address indexed reward, address indexed rewardOracle);\\n\\n    /// @param rewardsVault The address of the account that secures ERC20 rewards.\\n    event RewardsVaultUpdated(address indexed rewardsVault);\\n\\n    /// @param solidStaking Used to fetch the total amount staked and the stake of an user for a given asset\\n    event SolidStakingUpdated(address indexed solidStaking);\\n\\n    /// @dev Whitelists an address to claim the rewards on behalf of another address\\n    /// @param user The address of the user\\n    /// @param claimer The address of the claimer\\n    function setClaimer(address user, address claimer) external;\\n\\n    /// @dev Sets an Aave Oracle contract to enforce rewards with a source of value.\\n    /// @notice At the moment of reward configuration, the Incentives Controller performs\\n    /// a check to see if the reward asset oracle is compatible with IEACAggregator proxy.\\n    /// This check is enforced for integrators to be able to show incentives at\\n    /// the current Aave UI without the need to setup an external price registry\\n    /// @param reward The address of the reward to set the price aggregator\\n    /// @param rewardOracle The address of price aggregator that follows IEACAggregatorProxy interface\\n    function setRewardOracle(address reward, IEACAggregatorProxy rewardOracle) external;\\n\\n    /// @param rewardsVault The address of the account that secures ERC20 rewards.\\n    function setRewardsVault(address rewardsVault) external;\\n\\n    /// @param solidStaking Used to fetch the total amount staked and the stake of an user for a given asset\\n    function setSolidStaking(address solidStaking) external;\\n\\n    /// @dev Get the price aggregator oracle address\\n    /// @param reward The address of the reward\\n    /// @return The price oracle of the reward\\n    function getRewardOracle(address reward) external view returns (address);\\n\\n    /// @return Account that secures ERC20 rewards.\\n    function getRewardsVault() external view returns (address);\\n\\n    /// @dev Returns the whitelisted claimer for a certain address (0x0 if not set)\\n    /// @param user The address of the user\\n    /// @return The claimer address\\n    function getClaimer(address user) external view returns (address);\\n\\n    /// @dev Configure assets to incentivize with an emission of rewards per second until the end of distribution.\\n    /// @param config The assets configuration input, the list of structs contains the following fields:\\n    ///   uint104 emissionPerSecond: The emission per second following rewards unit decimals.\\n    ///   uint256 totalStaked: The total amount staked of the asset\\n    ///   uint40 distributionEnd: The end of the distribution of the incentives for an asset\\n    ///   address asset: The asset address to incentivize\\n    ///   address reward: The reward token address\\n    ///   IEACAggregatorProxy rewardOracle: The Price Oracle of a reward to visualize the incentives at the UI Frontend.\\n    ///                                     Must follow Chainlink Aggregator IEACAggregatorProxy interface to be compatible.\\n    function configureAssets(RewardsDataTypes.DistributionConfig[] memory config) external;\\n\\n    /// @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.\\n    /// @param asset The incentivized asset address\\n    /// @param user The address of the user whose asset balance has changed\\n    /// @param oldUserStake The amount of assets staked by the user, prior to stake change\\n    /// @param oldTotalStaked The total amount staked of the asset, prior to stake change\\n    function handleUserStakeChanged(\\n        address asset,\\n        address user,\\n        uint oldUserStake,\\n        uint oldTotalStaked\\n    ) external;\\n\\n    /// @dev Claims all rewards for a user to the desired address, on all the assets of the pool, accumulating the pending rewards\\n    /// @param assets The list of assets to check eligible distributions before claiming rewards\\n    /// @param to The address that will be receiving the rewards\\n    /// @return rewardsList List of addresses of the reward tokens\\n    /// @return claimedAmounts List that contains the claimed amount per reward, following same order as \\\"rewardList\\\"\\n    function claimAllRewards(address[] calldata assets, address to)\\n        external\\n        returns (address[] memory rewardsList, uint[] memory claimedAmounts);\\n\\n    /// @dev Claims all rewards for a user on behalf, on all the assets of the pool, accumulating the pending rewards. The caller must\\n    /// be whitelisted via \\\"allowClaimOnBehalf\\\" function by the RewardsAdmin role manager\\n    /// @param assets The list of assets to check eligible distributions before claiming rewards\\n    /// @param user The address to check and claim rewards\\n    /// @param to The address that will be receiving the rewards\\n    /// @return rewardsList List of addresses of the reward tokens\\n    /// @return claimedAmounts List that contains the claimed amount per reward, following same order as \\\"rewardsList\\\"\\n    function claimAllRewardsOnBehalf(\\n        address[] calldata assets,\\n        address user,\\n        address to\\n    ) external returns (address[] memory rewardsList, uint[] memory claimedAmounts);\\n\\n    /// @dev Claims all reward for msg.sender, on all the assets of the pool, accumulating the pending rewards\\n    /// @param assets The list of assets to check eligible distributions before claiming rewards\\n    /// @return rewardsList List of addresses of the reward tokens\\n    /// @return claimedAmounts List that contains the claimed amount per reward, following same order as \\\"rewardsList\\\"\\n    function claimAllRewardsToSelf(address[] calldata assets)\\n        external\\n        returns (address[] memory rewardsList, uint[] memory claimedAmounts);\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/rewards/IRewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\n/// @title IRewardsDistributor\\n/// @author Aave\\n/// @notice Defines the basic interface for a Rewards Distributor.\\ninterface IRewardsDistributor {\\n    error NotEmissionManager(address sender);\\n    error InvalidInput();\\n    error InvalidAssetDecimals(address asset);\\n    error IndexOverflow(uint newIndex);\\n    error DistributionNonExistent(address asset, address reward);\\n\\n    /// @param asset The address of the incentivized asset\\n    /// @param reward The address of the reward token\\n    error UpdateDistributionNotApplicable(address asset, address reward);\\n\\n    /// @dev Emitted when the configuration of the rewards of an asset is updated.\\n    /// @param asset The address of the incentivized asset\\n    /// @param reward The address of the reward token\\n    /// @param oldEmission The old emissions per second value of the reward distribution\\n    /// @param newEmission The new emissions per second value of the reward distribution\\n    /// @param oldDistributionEnd The old end timestamp of the reward distribution\\n    /// @param newDistributionEnd The new end timestamp of the reward distribution\\n    /// @param assetIndex The index of the asset distribution\\n    event AssetConfigUpdated(\\n        address indexed asset,\\n        address indexed reward,\\n        uint oldEmission,\\n        uint newEmission,\\n        uint oldDistributionEnd,\\n        uint newDistributionEnd,\\n        uint assetIndex\\n    );\\n\\n    /// @dev Emitted when rewards of an asset are accrued on behalf of a user.\\n    /// @param asset The address of the incentivized asset\\n    /// @param reward The address of the reward token\\n    /// @param user The address of the user that rewards are accrued on behalf of\\n    /// @param assetIndex The index of the asset distribution\\n    /// @param userIndex The index of the asset distribution on behalf of the user\\n    /// @param rewardsAccrued The amount of rewards accrued\\n    event Accrued(\\n        address indexed asset,\\n        address indexed reward,\\n        address indexed user,\\n        uint assetIndex,\\n        uint userIndex,\\n        uint rewardsAccrued\\n    );\\n\\n    /// @dev Emitted when the emission manager address is updated.\\n    /// @param oldEmissionManager The address of the old emission manager\\n    /// @param newEmissionManager The address of the new emission manager\\n    event EmissionManagerUpdated(address indexed oldEmissionManager, address indexed newEmissionManager);\\n\\n    /// @dev Sets the end date for the distribution\\n    /// @param asset The asset to incentivize\\n    /// @param reward The reward token that incentives the asset\\n    /// @param newDistributionEnd The end date of the incentivization, in unix time format\\n    function setDistributionEnd(\\n        address asset,\\n        address reward,\\n        uint32 newDistributionEnd\\n    ) external;\\n\\n    /// @dev Sets the emission per second of a set of reward distributions\\n    /// @param asset The asset is being incentivized\\n    /// @param rewards List of reward addresses are being distributed\\n    /// @param newEmissionsPerSecond List of new reward emissions per second\\n    function setEmissionPerSecond(\\n        address asset,\\n        address[] calldata rewards,\\n        uint88[] calldata newEmissionsPerSecond\\n    ) external;\\n\\n    /// @dev Updates weekly reward distributions\\n    /// @param assets List of incentivized assets getting updated\\n    /// @param rewards List of reward tokens getting updated\\n    /// @param rewardAmounts List of carbon reward amounts getting distributed\\n    function updateCarbonRewardDistribution(\\n        address[] calldata assets,\\n        address[] calldata rewards,\\n        uint[] calldata rewardAmounts\\n    ) external;\\n\\n    /// @param asset The incentivized asset\\n    /// @param reward The reward token of the incentivized asset\\n    /// @return true, if distribution can be updated for the asset - reward pair\\n    function canUpdateCarbonRewardDistribution(address asset, address reward) external view returns (bool);\\n\\n    /// @dev Gets the end date for the distribution\\n    /// @param asset The incentivized asset\\n    /// @param reward The reward token of the incentivized asset\\n    /// @return The timestamp with the end of the distribution, in unix time format\\n    function getDistributionEnd(address asset, address reward) external view returns (uint);\\n\\n    /// @dev Returns the index of a user on a reward distribution\\n    /// @param user Address of the user\\n    /// @param asset The incentivized asset\\n    /// @param reward The reward token of the incentivized asset\\n    /// @return The current user asset index, not including new distributions\\n    function getUserIndex(\\n        address user,\\n        address asset,\\n        address reward\\n    ) external view returns (uint);\\n\\n    /// @dev Returns the configuration of the distribution reward for a certain asset\\n    /// @param asset The incentivized asset\\n    /// @param reward The reward token of the incentivized asset\\n    /// @return The index of the asset distribution\\n    /// @return The emission per second of the reward distribution\\n    /// @return The timestamp of the last update of the index\\n    /// @return The timestamp of the distribution end\\n    function getRewardDistribution(address asset, address reward)\\n        external\\n        view\\n        returns (\\n            uint,\\n            uint,\\n            uint,\\n            uint\\n        );\\n\\n    /// @dev Returns the list of available reward token addresses of an incentivized asset\\n    /// @param asset The incentivized asset\\n    /// @return List of rewards addresses of the input asset\\n    function getRewardsByAsset(address asset) external view returns (address[] memory);\\n\\n    /// @dev Returns the list of available reward addresses\\n    /// @return List of rewards supported in this contract\\n    function getAllRewards() external view returns (address[] memory);\\n\\n    /// @dev Returns the accrued rewards balance of a user, not including virtually accrued rewards since last distribution.\\n    /// @param user The address of the user\\n    /// @param reward The address of the reward token\\n    /// @return Unclaimed rewards, not including new distributions\\n    function getAccruedRewardAmountForUser(address user, address reward) external view returns (uint);\\n\\n    /// @dev Returns a single rewards balance of a user, including virtually accrued and unrealized claimable rewards.\\n    /// @param assets List of incentivized assets to check eligible distributions\\n    /// @param user The address of the user\\n    /// @param reward The address of the reward token\\n    /// @return The rewards amount\\n    function getUnclaimedRewardAmountForUserAndAssets(\\n        address[] calldata assets,\\n        address user,\\n        address reward\\n    ) external view returns (uint);\\n\\n    /// @dev Returns a list all rewards of a user, including already accrued and unrealized claimable rewards\\n    /// @param assets List of incentivized assets to check eligible distributions\\n    /// @param user The address of the user\\n    /// @return The list of reward addresses\\n    /// @return The list of unclaimed amount of rewards\\n    function getAllUnclaimedRewardAmountsForUserAndAssets(address[] calldata assets, address user)\\n        external\\n        view\\n        returns (address[] memory, uint[] memory);\\n\\n    /// @dev Returns the decimals of an asset to calculate the distribution delta\\n    /// @param asset The address to retrieve decimals\\n    /// @return The decimals of an underlying asset\\n    function getAssetDecimals(address asset) external view returns (uint8);\\n\\n    /// @dev Returns the address of the emission manager\\n    /// @return The address of the EmissionManager\\n    function getEmissionManager() external view returns (address);\\n\\n    /// @dev Updates the address of the emission manager\\n    /// @param emissionManager The address of the new EmissionManager\\n    function setEmissionManager(address emissionManager) external;\\n}\\n\"\r\n    },\r\n    \"contracts/interfaces/staking/ISolidStakingViewActions.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.16;\\n\\n/// @title Permissionless view actions\\n/// @notice Contains view functions that can be called by anyone\\n/// @author Solid World DAO\\ninterface ISolidStakingViewActions {\\n    /// @dev Computes the amount of tokens that the `account` has staked\\n    /// @param token the token to check\\n    /// @param account the account to check\\n    /// @return the amount of `token` tokens that the `account` has staked\\n    function balanceOf(address token, address account) external view returns (uint);\\n\\n    /// @dev Computes the total amount of tokens that have been staked\\n    /// @param token the token to check\\n    /// @return the total amount of `token` tokens that have been staked\\n    function totalStaked(address token) external view returns (uint);\\n\\n    /// @dev Returns the list of tokens that can be staked\\n    /// @return the list of tokens that can be staked\\n    function getTokens() external view returns (address[] memory);\\n\\n    /// @return whether the specified token requires msg.sender to be KYCed before staking\\n    function isKYCRequired(address token) external view returns (bool);\\n\\n    /// @return The address controlling timelocked functions (e.g. KYC requirement changes)\\n    function getTimelockController() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/GPv2SafeERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: LGPL-3.0-or-later\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/// @title Gnosis Protocol v2 Safe ERC20 Transfer Library\\n/// @author Gnosis Developers\\n/// @dev Gas-efficient version of Openzeppelin's SafeERC20 contract.\\nlibrary GPv2SafeERC20 {\\n    /// @dev Wrapper around a call to the ERC20 function `transfer` that reverts\\n    /// also when the token returns `false`.\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        bytes4 selector_ = token.transfer.selector;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, selector_)\\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(add(freeMemoryPointer, 36), value)\\n\\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        require(getLastTransferResult(token), \\\"GPv2: failed transfer\\\");\\n    }\\n\\n    /// @dev Wrapper around a call to the ERC20 function `transferFrom` that\\n    /// reverts also when the token returns `false`.\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        bytes4 selector_ = token.transferFrom.selector;\\n\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let freeMemoryPointer := mload(0x40)\\n            mstore(freeMemoryPointer, selector_)\\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff))\\n            mstore(add(freeMemoryPointer, 68), value)\\n\\n            if iszero(call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)) {\\n                returndatacopy(0, 0, returndatasize())\\n                revert(0, returndatasize())\\n            }\\n        }\\n\\n        require(getLastTransferResult(token), \\\"GPv2: failed transferFrom\\\");\\n    }\\n\\n    /// @dev Verifies that the last return was a successful `transfer*` call.\\n    /// This is done by checking that the return data is either empty, or\\n    /// is a valid ABI encoded boolean.\\n    function getLastTransferResult(IERC20 token) private view returns (bool success) {\\n        // NOTE: Inspecting previous return data requires assembly. Note that\\n        // we write the return data to memory 0 in the case where the return\\n        // data size is 32, this is OK since the first 64 bytes of memory are\\n        // reserved by Solidy as a scratch space that can be used within\\n        // assembly blocks.\\n        // <https://docs.soliditylang.org/en/v0.7.6/internals/layout_in_memory.html>\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            /// @dev Revert with an ABI encoded Solidity error with a message\\n            /// that fits into 32-bytes.\\n            ///\\n            /// An ABI encoded Solidity error has the following memory layout:\\n            ///\\n            /// ------------+----------------------------------\\n            ///  byte range | value\\n            /// ------------+----------------------------------\\n            ///  0x00..0x04 |        selector(\\\"Error(string)\\\")\\n            ///  0x04..0x24 |      string offset (always 0x20)\\n            ///  0x24..0x44 |                    string length\\n            ///  0x44..0x64 | string value, padded to 32-bytes\\n            function revertWithMessage(length, message) {\\n                mstore(0x00, \\\"\\\\x08\\\\xc3\\\\x79\\\\xa0\\\")\\n                mstore(0x04, 0x20)\\n                mstore(0x24, length)\\n                mstore(0x44, message)\\n                revert(0x00, 0x64)\\n            }\\n\\n            switch returndatasize()\\n            // Non-standard ERC20 transfer without return.\\n            case 0 {\\n                // NOTE: When the return data size is 0, verify that there\\n                // is code at the address. This is done in order to maintain\\n                // compatibility with Solidity calling conventions.\\n                // <https://docs.soliditylang.org/en/v0.7.6/control-structures.html#external-function-calls>\\n                if iszero(extcodesize(token)) {\\n                    revertWithMessage(20, \\\"GPv2: not a contract\\\")\\n                }\\n\\n                success := 1\\n            }\\n            // Standard ERC20 transfer returning boolean success value.\\n            case 32 {\\n                returndatacopy(0, 0, returndatasize())\\n\\n                // NOTE: For ABI encoding v1, any non-zero value is accepted\\n                // as `true` for a boolean. In order to stay compatible with\\n                // OpenZeppelin's `SafeERC20` library which is known to work\\n                // with the existing ERC20 implementation we care about,\\n                // make sure we return success for any non-zero return value\\n                // from the `transfer*` call.\\n                success := iszero(iszero(mload(0)))\\n            }\\n            default {\\n                revertWithMessage(31, \\\"GPv2: malformed transfer result\\\")\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/libraries/RewardsDataTypes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"../interfaces/rewards/IEACAggregatorProxy.sol\\\";\\n\\nlibrary RewardsDataTypes {\\n    struct DistributionConfig {\\n        uint88 emissionPerSecond;\\n        uint totalStaked;\\n        uint32 distributionEnd;\\n        address asset;\\n        address reward;\\n        IEACAggregatorProxy rewardOracle;\\n    }\\n\\n    struct AssetStakedAmounts {\\n        address asset;\\n        uint userStake;\\n        uint totalStaked;\\n    }\\n\\n    struct AssetData {\\n        mapping(address => RewardDistribution) rewardDistribution;\\n        mapping(uint128 => address) availableRewards;\\n        uint128 availableRewardsCount;\\n        uint8 decimals;\\n    }\\n\\n    struct RewardDistribution {\\n        uint104 index;\\n        uint88 emissionPerSecond;\\n        uint32 lastUpdateTimestamp;\\n        uint32 distributionEnd;\\n        mapping(address => UserReward) userReward;\\n    }\\n\\n    struct UserReward {\\n        uint104 index;\\n        uint128 accrued;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/RewardsController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\n\\nimport \\\"./RewardsDistributor.sol\\\";\\nimport \\\"../interfaces/rewards/IRewardsController.sol\\\";\\nimport \\\"../PostConstruct.sol\\\";\\nimport \\\"../libraries/GPv2SafeERC20.sol\\\";\\n\\ncontract RewardsController is IRewardsController, RewardsDistributor, PostConstruct {\\n    /// @dev user => claimer\\n    mapping(address => address) internal _authorizedClaimers;\\n\\n    /// @dev reward => rewardOracle\\n    mapping(address => IEACAggregatorProxy) internal _rewardOracle;\\n\\n    /// @dev Account that secures ERC20 rewards.\\n    /// @dev It must approve `RewardsController` to spend the rewards it holds.\\n    address internal REWARDS_VAULT;\\n\\n    modifier onlyAuthorizedClaimers(address claimer, address user) {\\n        if (_authorizedClaimers[user] != claimer && address(solidStakingViewActions) != claimer) {\\n            revert UnauthorizedClaimer(claimer, user);\\n        }\\n        _;\\n    }\\n\\n    function setup(\\n        address _solidStakingViewActions,\\n        address rewardsVault,\\n        address emissionManager\\n    ) external postConstruct {\\n        _setSolidStaking(_solidStakingViewActions);\\n        _setRewardsVault(rewardsVault);\\n        _setEmissionManager(emissionManager);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function getRewardsVault() external view returns (address) {\\n        return REWARDS_VAULT;\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function getClaimer(address user) external view returns (address) {\\n        return _authorizedClaimers[user];\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function getRewardOracle(address reward) external view returns (address) {\\n        return address(_rewardOracle[reward]);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function configureAssets(RewardsDataTypes.DistributionConfig[] memory config)\\n        external\\n        onlyEmissionManager\\n    {\\n        for (uint i; i < config.length; i++) {\\n            config[i].totalStaked = solidStakingViewActions.totalStaked(config[i].asset);\\n            _setRewardOracle(config[i].reward, config[i].rewardOracle);\\n        }\\n        _configureAssets(config);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function setRewardOracle(address reward, IEACAggregatorProxy rewardOracle) external onlyEmissionManager {\\n        _setRewardOracle(reward, rewardOracle);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function setClaimer(address user, address caller) external onlyEmissionManager {\\n        _authorizedClaimers[user] = caller;\\n        emit ClaimerSet(user, caller);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function setRewardsVault(address rewardsVault) external onlyEmissionManager {\\n        _setRewardsVault(rewardsVault);\\n    }\\n\\n    function setSolidStaking(address solidStaking) external onlyEmissionManager {\\n        _setSolidStaking(solidStaking);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function handleUserStakeChanged(\\n        address asset,\\n        address user,\\n        uint oldUserStake,\\n        uint oldTotalStaked\\n    ) external {\\n        if (msg.sender != address(solidStakingViewActions)) {\\n            revert NotSolidStaking(msg.sender);\\n        }\\n\\n        _updateAllRewardDistributionsAndUserRewardsForAsset(asset, user, oldUserStake, oldTotalStaked);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function claimAllRewards(address[] calldata assets, address to)\\n        external\\n        returns (address[] memory rewardsList, uint[] memory claimedAmounts)\\n    {\\n        if (to == address(0)) {\\n            revert InvalidInput();\\n        }\\n\\n        return _claimAllRewards(assets, msg.sender, msg.sender, to);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function claimAllRewardsOnBehalf(\\n        address[] calldata assets,\\n        address user,\\n        address to\\n    )\\n        external\\n        onlyAuthorizedClaimers(msg.sender, user)\\n        returns (address[] memory rewardsList, uint[] memory claimedAmounts)\\n    {\\n        if (to == address(0) || user == address(0)) {\\n            revert InvalidInput();\\n        }\\n\\n        return _claimAllRewards(assets, msg.sender, user, to);\\n    }\\n\\n    /// @inheritdoc IRewardsController\\n    function claimAllRewardsToSelf(address[] calldata assets)\\n        external\\n        returns (address[] memory rewardsList, uint[] memory claimedAmounts)\\n    {\\n        return _claimAllRewards(assets, msg.sender, msg.sender, msg.sender);\\n    }\\n\\n    /// @inheritdoc RewardsDistributor\\n    function _getAssetStakedAmounts(address[] calldata assets, address user)\\n        internal\\n        view\\n        override\\n        returns (RewardsDataTypes.AssetStakedAmounts[] memory assetStakedAmounts)\\n    {\\n        assetStakedAmounts = new RewardsDataTypes.AssetStakedAmounts[](assets.length);\\n        for (uint i; i < assets.length; i++) {\\n            assetStakedAmounts[i].asset = assets[i];\\n            assetStakedAmounts[i].userStake = solidStakingViewActions.balanceOf(assets[i], user);\\n            assetStakedAmounts[i].totalStaked = solidStakingViewActions.totalStaked(assets[i]);\\n        }\\n        return assetStakedAmounts;\\n    }\\n\\n    /// @dev Claims all accrued rewards for a user on behalf, for the specified asset, accumulating the pending rewards.\\n    /// @param assets List of assets to check eligible distributions before claiming rewards\\n    /// @param claimer Address of the claimer on behalf of user\\n    /// @param user Address to check and claim rewards\\n    /// @param to Address that will be receiving the rewards\\n    /// @return\\n    ///   rewardsList List of reward addresses\\n    ///   claimedAmount List of claimed amounts, follows \\\"rewardsList\\\" items order\\n    function _claimAllRewards(\\n        address[] calldata assets,\\n        address claimer,\\n        address user,\\n        address to\\n    ) internal returns (address[] memory rewardsList, uint[] memory claimedAmounts) {\\n        uint rewardsListLength = _rewardsList.length;\\n        rewardsList = new address[](rewardsListLength);\\n        claimedAmounts = new uint[](rewardsListLength);\\n\\n        _updateAllRewardDistributionsAndUserRewardsForAssets(user, _getAssetStakedAmounts(assets, user));\\n\\n        for (uint i; i < assets.length; i++) {\\n            address asset = assets[i];\\n            for (uint j; j < rewardsListLength; j++) {\\n                if (rewardsList[j] == address(0)) {\\n                    rewardsList[j] = _rewardsList[j];\\n                }\\n                uint rewardAmount = _assetData[asset]\\n                    .rewardDistribution[rewardsList[j]]\\n                    .userReward[user]\\n                    .accrued;\\n                if (rewardAmount != 0) {\\n                    claimedAmounts[j] += rewardAmount;\\n                    _assetData[asset].rewardDistribution[rewardsList[j]].userReward[user].accrued = 0;\\n                }\\n            }\\n        }\\n        for (uint i; i < rewardsListLength; i++) {\\n            _transferRewards(to, rewardsList[i], claimedAmounts[i]);\\n            emit RewardsClaimed(user, rewardsList[i], to, claimer, claimedAmounts[i]);\\n        }\\n        return (rewardsList, claimedAmounts);\\n    }\\n\\n    /// @dev Function to transfer rewards to the desired account\\n    /// @param to Account address to send the rewards\\n    /// @param reward Address of the reward token\\n    /// @param amount Amount of rewards to transfer\\n    function _transferRewards(\\n        address to,\\n        address reward,\\n        uint amount\\n    ) internal {\\n        GPv2SafeERC20.safeTransferFrom(IERC20(reward), REWARDS_VAULT, to, amount);\\n    }\\n\\n    /// @dev Update the Price Oracle of a reward token. The Price Oracle must follow Chainlink IEACAggregatorProxy interface.\\n    /// @notice The Price Oracle of a reward is used for displaying correct data about the incentives at the UI frontend.\\n    /// @param reward The address of the reward token\\n    /// @param rewardOracle The address of the price oracle\\n    function _setRewardOracle(address reward, IEACAggregatorProxy rewardOracle) internal {\\n        if (rewardOracle.latestAnswer() <= 0) {\\n            revert InvalidRewardOracle(reward, address(rewardOracle));\\n        }\\n\\n        _rewardOracle[reward] = rewardOracle;\\n        emit RewardOracleUpdated(reward, address(rewardOracle));\\n    }\\n\\n    function _setRewardsVault(address rewardsVault) internal {\\n        REWARDS_VAULT = rewardsVault;\\n        emit RewardsVaultUpdated(rewardsVault);\\n    }\\n\\n    function _setSolidStaking(address solidStaking) internal {\\n        solidStakingViewActions = ISolidStakingViewActions(solidStaking);\\n        emit SolidStakingUpdated(solidStaking);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/rewards/RewardsDistributor.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.16;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\n\\nimport \\\"../interfaces/rewards/IRewardsDistributor.sol\\\";\\nimport \\\"../libraries/RewardsDataTypes.sol\\\";\\nimport \\\"../interfaces/staking/ISolidStakingViewActions.sol\\\";\\n\\nabstract contract RewardsDistributor is IRewardsDistributor {\\n    using SafeCast for uint;\\n\\n    // asset => AssetData\\n    mapping(address => RewardsDataTypes.AssetData) internal _assetData;\\n    // reward => enabled\\n    mapping(address => bool) internal _isRewardEnabled;\\n\\n    address[] internal _rewardsList;\\n    address[] internal _assetsList;\\n    address internal _emissionManager;\\n\\n    /// @dev Used to fetch the total amount staked and the stake of an user for a given asset\\n    ISolidStakingViewActions public solidStakingViewActions;\\n\\n    modifier onlyEmissionManager() {\\n        if (msg.sender != _emissionManager) {\\n            revert NotEmissionManager(msg.sender);\\n        }\\n        _;\\n    }\\n\\n    modifier distributionExists(address asset, address reward) {\\n        RewardsDataTypes.RewardDistribution storage rewardDistribution = _assetData[asset].rewardDistribution[\\n            reward\\n        ];\\n        uint decimals = _assetData[asset].decimals;\\n        if (decimals == 0 || rewardDistribution.lastUpdateTimestamp == 0) {\\n            revert DistributionNonExistent(asset, reward);\\n        }\\n        _;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getRewardDistribution(address asset, address reward)\\n        public\\n        view\\n        returns (\\n            uint,\\n            uint,\\n            uint,\\n            uint\\n        )\\n    {\\n        return (\\n            _assetData[asset].rewardDistribution[reward].index,\\n            _assetData[asset].rewardDistribution[reward].emissionPerSecond,\\n            _assetData[asset].rewardDistribution[reward].lastUpdateTimestamp,\\n            _assetData[asset].rewardDistribution[reward].distributionEnd\\n        );\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getDistributionEnd(address asset, address reward) external view returns (uint) {\\n        return _assetData[asset].rewardDistribution[reward].distributionEnd;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getRewardsByAsset(address asset) external view returns (address[] memory) {\\n        uint128 rewardsCount = _assetData[asset].availableRewardsCount;\\n        address[] memory rewards = new address[](rewardsCount);\\n\\n        for (uint128 i; i < rewardsCount; i++) {\\n            rewards[i] = _assetData[asset].availableRewards[i];\\n        }\\n        return rewards;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getAllRewards() external view returns (address[] memory) {\\n        return _rewardsList;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getUserIndex(\\n        address user,\\n        address asset,\\n        address reward\\n    ) public view returns (uint) {\\n        return _assetData[asset].rewardDistribution[reward].userReward[user].index;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getAccruedRewardAmountForUser(address user, address reward) external view returns (uint) {\\n        uint totalAccrued;\\n        for (uint i; i < _assetsList.length; i++) {\\n            totalAccrued += _assetData[_assetsList[i]].rewardDistribution[reward].userReward[user].accrued;\\n        }\\n\\n        return totalAccrued;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getUnclaimedRewardAmountForUserAndAssets(\\n        address[] calldata assets,\\n        address user,\\n        address reward\\n    ) external view returns (uint unclaimedAmount) {\\n        RewardsDataTypes.AssetStakedAmounts[] memory assetStakedAmounts = _getAssetStakedAmounts(\\n            assets,\\n            user\\n        );\\n\\n        for (uint i; i < assetStakedAmounts.length; i++) {\\n            if (assetStakedAmounts[i].userStake == 0) {\\n                unclaimedAmount += _assetData[assetStakedAmounts[i].asset]\\n                    .rewardDistribution[reward]\\n                    .userReward[user]\\n                    .accrued;\\n            } else {\\n                unclaimedAmount +=\\n                    _computePendingRewardAmountForUser(user, reward, assetStakedAmounts[i]) +\\n                    _assetData[assetStakedAmounts[i].asset]\\n                        .rewardDistribution[reward]\\n                        .userReward[user]\\n                        .accrued;\\n            }\\n        }\\n\\n        return unclaimedAmount;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getAllUnclaimedRewardAmountsForUserAndAssets(address[] calldata assets, address user)\\n        external\\n        view\\n        returns (address[] memory rewardsList, uint[] memory unclaimedAmounts)\\n    {\\n        RewardsDataTypes.AssetStakedAmounts[] memory assetStakedAmounts = _getAssetStakedAmounts(\\n            assets,\\n            user\\n        );\\n        rewardsList = new address[](_rewardsList.length);\\n        unclaimedAmounts = new uint[](rewardsList.length);\\n\\n        for (uint i; i < assetStakedAmounts.length; i++) {\\n            for (uint r; r < rewardsList.length; r++) {\\n                rewardsList[r] = _rewardsList[r];\\n                unclaimedAmounts[r] += _assetData[assetStakedAmounts[i].asset]\\n                    .rewardDistribution[rewardsList[r]]\\n                    .userReward[user]\\n                    .accrued;\\n\\n                if (assetStakedAmounts[i].userStake == 0) {\\n                    continue;\\n                }\\n                unclaimedAmounts[r] += _computePendingRewardAmountForUser(\\n                    user,\\n                    rewardsList[r],\\n                    assetStakedAmounts[i]\\n                );\\n            }\\n        }\\n        return (rewardsList, unclaimedAmounts);\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function setDistributionEnd(\\n        address asset,\\n        address reward,\\n        uint32 newDistributionEnd\\n    ) external onlyEmissionManager distributionExists(asset, reward) {\\n        uint oldDistributionEnd = _setDistributionEnd(asset, reward, newDistributionEnd);\\n        uint index = _assetData[asset].rewardDistribution[reward].index;\\n\\n        emit AssetConfigUpdated(\\n            asset,\\n            reward,\\n            _assetData[asset].rewardDistribution[reward].emissionPerSecond,\\n            _assetData[asset].rewardDistribution[reward].emissionPerSecond,\\n            oldDistributionEnd,\\n            newDistributionEnd,\\n            index\\n        );\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function setEmissionPerSecond(\\n        address asset,\\n        address[] calldata rewards,\\n        uint88[] calldata newEmissionsPerSecond\\n    ) external onlyEmissionManager {\\n        if (rewards.length != newEmissionsPerSecond.length) {\\n            revert InvalidInput();\\n        }\\n\\n        for (uint i; i < rewards.length; i++) {\\n            (uint oldEmissionPerSecond, uint newIndex, uint distributionEnd) = _setEmissionPerSecond(\\n                asset,\\n                rewards[i],\\n                newEmissionsPerSecond[i]\\n            );\\n\\n            emit AssetConfigUpdated(\\n                asset,\\n                rewards[i],\\n                oldEmissionPerSecond,\\n                newEmissionsPerSecond[i],\\n                distributionEnd,\\n                distributionEnd,\\n                newIndex\\n            );\\n        }\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function updateCarbonRewardDistribution(\\n        address[] calldata assets,\\n        address[] calldata rewards,\\n        uint[] calldata rewardAmounts\\n    ) external onlyEmissionManager {\\n        if (assets.length != rewards.length || rewards.length != rewardAmounts.length) {\\n            revert InvalidInput();\\n        }\\n\\n        for (uint i; i < assets.length; i++) {\\n            if (!_canUpdateCarbonRewardDistribution(assets[i], rewards[i])) {\\n                revert UpdateDistributionNotApplicable(assets[i], rewards[i]);\\n            }\\n\\n            uint32 newDistributionEnd = _computeNewCarbonRewardDistributionEnd(assets[i], rewards[i]);\\n            uint88 newEmissionsPerSecond = uint88(rewardAmounts[i] / (newDistributionEnd - block.timestamp));\\n\\n            (uint oldEmissionPerSecond, uint newIndex, ) = _setEmissionPerSecond(\\n                assets[i],\\n                rewards[i],\\n                newEmissionsPerSecond\\n            );\\n            uint oldDistributionEnd = _setDistributionEnd(assets[i], rewards[i], newDistributionEnd);\\n            emit AssetConfigUpdated(\\n                assets[i],\\n                rewards[i],\\n                oldEmissionPerSecond,\\n                newEmissionsPerSecond,\\n                oldDistributionEnd,\\n                newDistributionEnd,\\n                newIndex\\n            );\\n        }\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getAssetDecimals(address asset) external view returns (uint8) {\\n        return _assetData[asset].decimals;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function getEmissionManager() external view returns (address) {\\n        return _emissionManager;\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function setEmissionManager(address emissionManager) external onlyEmissionManager {\\n        _setEmissionManager(emissionManager);\\n    }\\n\\n    /// @inheritdoc IRewardsDistributor\\n    function canUpdateCarbonRewardDistribution(address asset, address reward)\\n        external\\n        view\\n        distributionExists(asset, reward)\\n        returns (bool)\\n    {\\n        return _canUpdateCarbonRewardDistribution(asset, reward);\\n    }\\n\\n    function _canUpdateCarbonRewardDistribution(address asset, address reward) internal view returns (bool) {\\n        uint32 currentDistributionEnd = _assetData[asset].rewardDistribution[reward].distributionEnd;\\n        uint32 nextDistributionEnd = _computeNewCarbonRewardDistributionEnd(asset, reward);\\n\\n        bool isInitializedDistribution = currentDistributionEnd != 0;\\n        bool isBetweenDistributions = block.timestamp >= currentDistributionEnd &&\\n            block.timestamp < nextDistributionEnd;\\n\\n        return isInitializedDistribution && isBetweenDistributions;\\n    }\\n\\n    function _computeNewCarbonRewardDistributionEnd(address asset, address reward)\\n        internal\\n        view\\n        returns (uint32 newDistributionEnd)\\n    {\\n        uint32 currentDistributionEnd = _assetData[asset].rewardDistribution[reward].distributionEnd;\\n\\n        newDistributionEnd = currentDistributionEnd + 1 weeks;\\n    }\\n\\n    /// @dev Configure the _assetData for a specific emission\\n    /// @param distributionConfig The array of each asset configuration\\n    function _configureAssets(RewardsDataTypes.DistributionConfig[] memory distributionConfig) internal {\\n        for (uint i; i < distributionConfig.length; i++) {\\n            uint8 decimals = IERC20Metadata(distributionConfig[i].asset).decimals();\\n\\n            if (decimals == 0) {\\n                revert InvalidAssetDecimals(distributionConfig[i].asset);\\n            }\\n\\n            if (_assetData[distributionConfig[i].asset].decimals == 0) {\\n                _assetsList.push(distributionConfig[i].asset);\\n            }\\n\\n            _assetData[distributionConfig[i].asset].decimals = decimals;\\n\\n            RewardsDataTypes.RewardDistribution storage rewardDistribution = _assetData[\\n                distributionConfig[i].asset\\n            ].rewardDistribution[distributionConfig[i].reward];\\n\\n            if (rewardDistribution.lastUpdateTimestamp == 0) {\\n                uint128 rewardCount = _assetData[distributionConfig[i].asset].availableRewardsCount;\\n                _assetData[distributionConfig[i].asset].availableRewards[rewardCount] = distributionConfig[i]\\n                    .reward;\\n                _assetData[distributionConfig[i].asset].availableRewardsCount++;\\n            }\\n\\n            if (_isRewardEnabled[distributionConfig[i].reward] == false) {\\n                _isRewardEnabled[distributionConfig[i].reward] = true;\\n                _rewardsList.push(distributionConfig[i].reward);\\n            }\\n\\n            (uint newAssetIndex, ) = _updateRewardDistribution(\\n                rewardDistribution,\\n                distributionConfig[i].totalStaked,\\n                10**decimals\\n            );\\n\\n            uint88 oldEmissionsPerSecond = rewardDistribution.emissionPerSecond;\\n            uint32 oldDistributionEnd = rewardDistribution.distributionEnd;\\n            rewardDistribution.emissionPerSecond = distributionConfig[i].emissionPerSecond;\\n            rewardDistribution.distributionEnd = distributionConfig[i].distributionEnd;\\n\\n            emit AssetConfigUpdated(\\n                distributionConfig[i].asset,\\n                distributionConfig[i].reward,\\n                oldEmissionsPerSecond,\\n                distributionConfig[i].emissionPerSecond,\\n                oldDistributionEnd,\\n                distributionConfig[i].distributionEnd,\\n                newAssetIndex\\n            );\\n        }\\n    }\\n\\n    /// @dev Updates rewards distribution and user rewards for all rewards configured for the specified assets\\n    /// @param user The address of the user\\n    /// @param assetStakedAmounts List of structs with the user stake and total staked of a set of assets\\n    function _updateAllRewardDistributionsAndUserRewardsForAssets(\\n        address user,\\n        RewardsDataTypes.AssetStakedAmounts[] memory assetStakedAmounts\\n    ) internal {\\n        for (uint i; i < assetStakedAmounts.length; i++) {\\n            _updateAllRewardDistributionsAndUserRewardsForAsset(\\n                assetStakedAmounts[i].asset,\\n                user,\\n                assetStakedAmounts[i].userStake,\\n                assetStakedAmounts[i].totalStaked\\n            );\\n        }\\n    }\\n\\n    /// @dev Updates rewards distribution and user rewards for all rewards configured for the specified asset\\n    /// @dev When call origin is (un)staking, `userStake` and `totalStaked` are prior to the (un)stake action\\n    /// @dev When call origin is rewards claiming, `userStake` and `totalStaked` are current values\\n    /// @param asset The address of the incentivized asset\\n    /// @param user The user address\\n    /// @param userStake The amount of assets staked by the user\\n    /// @param totalStaked The total amount staked of the asset\\n    function _updateAllRewardDistributionsAndUserRewardsForAsset(\\n        address asset,\\n        address user,\\n        uint userStake,\\n        uint totalStaked\\n    ) internal {\\n        uint assetUnit;\\n        uint numAvailableRewards = _assetData[asset].availableRewardsCount;\\n        unchecked {\\n            assetUnit = 10**_assetData[asset].decimals;\\n        }\\n\\n        if (numAvailableRewards == 0) {\\n            return;\\n        }\\n        unchecked {\\n            for (uint128 r; r < numAvailableRewards; r++) {\\n                address reward = _assetData[asset].availableRewards[r];\\n                RewardsDataTypes.RewardDistribution storage rewardDistribution = _assetData[asset]\\n                    .rewardDistribution[reward];\\n\\n                (uint newAssetIndex, bool rewardDistributionUpdated) = _updateRewardDistribution(\\n                    rewardDistribution,\\n                    totalStaked,\\n                    assetUnit\\n                );\\n\\n                (uint rewardsAccrued, bool userRewardUpdated) = _updateUserReward(\\n                    rewardDistribution,\\n                    user,\\n                    userStake,\\n                    newAssetIndex,\\n                    assetUnit\\n                );\\n\\n                if (rewardDistributionUpdated || userRewardUpdated) {\\n                    emit Accrued(asset, reward, user, newAssetIndex, newAssetIndex, rewardsAccrued);\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Updates the state of the distribution for the specified reward\\n    /// @param rewardDistribution Storage pointer to the distribution reward config\\n    /// @param totalStaked The total amount staked of the asset\\n    /// @param assetUnit One unit of asset (10**decimals)\\n    /// @return The new distribution index\\n    /// @return True if the index was updated, false otherwise\\n    function _updateRewardDistribution(\\n        RewardsDataTypes.RewardDistribution storage rewardDistribution,\\n        uint totalStaked,\\n        uint assetUnit\\n    ) internal returns (uint, bool) {\\n        (uint oldIndex, uint newIndex) = _computeNewAssetIndex(rewardDistribution, totalStaked, assetUnit);\\n        bool indexUpdated;\\n        if (newIndex != oldIndex) {\\n            if (newIndex > type(uint104).max) {\\n                revert IndexOverflow(newIndex);\\n            }\\n\\n            indexUpdated = true;\\n\\n            rewardDistribution.index = uint104(newIndex);\\n            rewardDistribution.lastUpdateTimestamp = block.timestamp.toUint32();\\n        } else {\\n            rewardDistribution.lastUpdateTimestamp = block.timestamp.toUint32();\\n        }\\n\\n        return (newIndex, indexUpdated);\\n    }\\n\\n    /// @dev Updates the state of the distribution for the specific user\\n    /// @param rewardDistribution Storage pointer to the distribution reward config\\n    /// @param user The address of the user\\n    /// @param userStake The amount of assets staked by the user\\n    /// @param newAssetIndex The new index of the asset distribution\\n    /// @param assetUnit One unit of asset (10**decimals)\\n    /// @return The rewards accrued since the last update\\n    function _updateUserReward(\\n        RewardsDataTypes.RewardDistribution storage rewardDistribution,\\n        address user,\\n        uint userStake,\\n        uint newAssetIndex,\\n        uint assetUnit\\n    ) internal returns (uint, bool) {\\n        uint userIndex = rewardDistribution.userReward[user].index;\\n        uint rewardsAccrued;\\n        bool dataUpdated;\\n        if ((dataUpdated = userIndex != newAssetIndex)) {\\n            if (newAssetIndex > type(uint104).max) {\\n                revert IndexOverflow(newAssetIndex);\\n            }\\n\\n            rewardDistribution.userReward[user].index = uint104(newAssetIndex);\\n            if (userStake != 0) {\\n                rewardsAccrued = _computeAccruedRewardAmount(userStake, newAssetIndex, userIndex, assetUnit);\\n\\n                rewardDistribution.userReward[user].accrued += rewardsAccrued.toUint128();\\n            }\\n        }\\n        return (rewardsAccrued, dataUpdated);\\n    }\\n\\n    /// @dev Calculates the pending (not yet accrued) reward amount since the last user action\\n    /// @param user The address of the user\\n    /// @param reward The address of the reward token\\n    /// @param assetStakedAmounts struct with the user stake and total staked of the incentivized asset\\n    /// @return The pending rewards for the user since the last user action\\n    function _computePendingRewardAmountForUser(\\n        address user,\\n        address reward,\\n        RewardsDataTypes.AssetStakedAmounts memory assetStakedAmounts\\n    ) internal view returns (uint) {\\n        RewardsDataTypes.RewardDistribution storage rewardDistribution = _assetData[assetStakedAmounts.asset]\\n            .rewardDistribution[reward];\\n        uint assetUnit = 10**_assetData[assetStakedAmounts.asset].decimals;\\n        (, uint nextIndex) = _computeNewAssetIndex(\\n            rewardDistribution,\\n            assetStakedAmounts.totalStaked,\\n            assetUnit\\n        );\\n\\n        return\\n            _computeAccruedRewardAmount(\\n                assetStakedAmounts.userStake,\\n                nextIndex,\\n                rewardDistribution.userReward[user].index,\\n                assetUnit\\n            );\\n    }\\n\\n    /// @dev Internal function for the calculation of user's rewards on a distribution\\n    /// @param userStake The amount of assets staked by the user on a distribution\\n    /// @param assetIndex Current index of the asset reward distribution\\n    /// @param userIndex Index stored for the user, representing his staking moment\\n    /// @param assetUnit One unit of asset (10**decimals)\\n    /// @return accruedRewardAmount The accrued reward amount\\n    function _computeAccruedRewardAmount(\\n        uint userStake,\\n        uint assetIndex,\\n        uint userIndex,\\n        uint assetUnit\\n    ) internal pure returns (uint accruedRewardAmount) {\\n        accruedRewardAmount = userStake * (assetIndex - userIndex);\\n\\n        assembly {\\n            accruedRewardAmount := div(accruedRewardAmount, assetUnit)\\n        }\\n    }\\n\\n    /// @dev Calculates the next value of an specific distribution index, with validations\\n    /// @param totalStaked The total amount staked of the asset\\n    /// @param assetUnit One unit of asset (10**decimals)\\n    /// @return The new index.\\n    function _computeNewAssetIndex(\\n        RewardsDataTypes.RewardDistribution storage rewardDistribution,\\n        uint totalStaked,\\n        uint assetUnit\\n    ) internal view returns (uint, uint) {\\n        uint oldIndex = rewardDistribution.index;\\n        uint distributionEnd = rewardDistribution.distributionEnd;\\n        uint emissionPerSecond = rewardDistribution.emissionPerSecond;\\n        uint lastUpdateTimestamp = rewardDistribution.lastUpdateTimestamp;\\n\\n        if (\\n            emissionPerSecond == 0 ||\\n            totalStaked == 0 ||\\n            lastUpdateTimestamp == block.timestamp ||\\n            lastUpdateTimestamp >= distributionEnd\\n        ) {\\n            return (oldIndex, oldIndex);\\n        }\\n\\n        uint currentTimestamp = block.timestamp > distributionEnd ? distributionEnd : block.timestamp;\\n        uint timeDelta = currentTimestamp - lastUpdateTimestamp;\\n        uint firstTerm = emissionPerSecond * timeDelta * assetUnit;\\n        assembly {\\n            firstTerm := div(firstTerm, totalStaked)\\n        }\\n        return (oldIndex, (firstTerm + oldIndex));\\n    }\\n\\n    /// @dev Get user stake and total staked of all the assets specified by the assets parameter\\n    /// @param assets List of assets to retrieve user stake and total staked\\n    /// @param user Address of the user\\n    /// @return assetStakedAmounts contains a list of structs with user stake and total staked of the given assets\\n    function _getAssetStakedAmounts(address[] calldata assets, address user)\\n        internal\\n        view\\n        virtual\\n        returns (RewardsDataTypes.AssetStakedAmounts[] memory assetStakedAmounts);\\n\\n    /// @dev Updates the address of the emission manager\\n    /// @param emissionManager The address of the new EmissionManager\\n    function _setEmissionManager(address emissionManager) internal {\\n        address previousEmissionManager = _emissionManager;\\n        _emissionManager = emissionManager;\\n        emit EmissionManagerUpdated(previousEmissionManager, emissionManager);\\n    }\\n\\n    function _setEmissionPerSecond(\\n        address asset,\\n        address reward,\\n        uint88 newEmissionsPerSecond\\n    )\\n        internal\\n        returns (\\n            uint oldEmissionPerSecond,\\n            uint newIndex,\\n            uint distributionEnd\\n        )\\n    {\\n        RewardsDataTypes.AssetData storage assetConfig = _assetData[asset];\\n        RewardsDataTypes.RewardDistribution storage rewardDistribution = _assetData[asset].rewardDistribution[\\n            reward\\n        ];\\n        uint decimals = assetConfig.decimals;\\n        if (decimals == 0 || rewardDistribution.lastUpdateTimestamp == 0) {\\n            revert DistributionNonExistent(asset, reward);\\n        }\\n\\n        distributionEnd = rewardDistribution.distributionEnd;\\n\\n        (newIndex, ) = _updateRewardDistribution(\\n            rewardDistribution,\\n            solidStakingViewActions.totalStaked(asset),\\n            10**decimals\\n        );\\n\\n        oldEmissionPerSecond = rewardDistribution.emissionPerSecond;\\n        rewardDistribution.emissionPerSecond = newEmissionsPerSecond;\\n    }\\n\\n    function _setDistributionEnd(\\n        address asset,\\n        address reward,\\n        uint32 newDistributionEnd\\n    ) internal returns (uint oldDistributionEnd) {\\n        oldDistributionEnd = _assetData[asset].rewardDistribution[reward].distributionEnd;\\n        _assetData[asset].rewardDistribution[reward].distributionEnd = newDistributionEnd;\\n    }\\n}\\n\"\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"name\":\"AlreadyInitialized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"DistributionNonExistent\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newIndex\",\"type\":\"uint256\"}],\"name\":\"IndexOverflow\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"InvalidAssetDecimals\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardOracle\",\"type\":\"address\"}],\"name\":\"InvalidRewardOracle\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotEmissionManager\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"NotSolidStaking\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"UnauthorizedClaimer\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"UpdateDistributionNotApplicable\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"userIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rewardsAccrued\",\"type\":\"uint256\"}],\"name\":\"Accrued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldEmission\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newEmission\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldDistributionEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newDistributionEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"assetIndex\",\"type\":\"uint256\"}],\"name\":\"AssetConfigUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"}],\"name\":\"ClaimerSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldEmissionManager\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newEmissionManager\",\"type\":\"address\"}],\"name\":\"EmissionManagerUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardOracle\",\"type\":\"address\"}],\"name\":\"RewardOracleUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"rewardsVault\",\"type\":\"address\"}],\"name\":\"RewardsVaultUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"solidStaking\",\"type\":\"address\"}],\"name\":\"SolidStakingUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"canUpdateCarbonRewardDistribution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimAllRewards\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"rewardsList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"claimedAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claimAllRewardsOnBehalf\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"rewardsList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"claimedAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"name\":\"claimAllRewardsToSelf\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"rewardsList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"claimedAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint88\",\"name\":\"emissionPerSecond\",\"type\":\"uint88\"},{\"internalType\":\"uint256\",\"name\":\"totalStaked\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"distributionEnd\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"contract IEACAggregatorProxy\",\"name\":\"rewardOracle\",\"type\":\"address\"}],\"internalType\":\"struct RewardsDataTypes.DistributionConfig[]\",\"name\":\"config\",\"type\":\"tuple[]\"}],\"name\":\"configureAssets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"getAccruedRewardAmountForUser\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAllRewards\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getAllUnclaimedRewardAmountsForUserAndAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"rewardsList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"unclaimedAmounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getAssetDecimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getClaimer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"getDistributionEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEmissionManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"getRewardDistribution\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"getRewardOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getRewardsByAsset\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRewardsVault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"getUnclaimedRewardAmountForUserAndAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"unclaimedAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"}],\"name\":\"getUserIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"oldUserStake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"oldTotalStaked\",\"type\":\"uint256\"}],\"name\":\"handleUserStakeChanged\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"setClaimer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"newDistributionEnd\",\"type\":\"uint32\"}],\"name\":\"setDistributionEnd\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"emissionManager\",\"type\":\"address\"}],\"name\":\"setEmissionManager\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"rewards\",\"type\":\"address[]\"},{\"internalType\":\"uint88[]\",\"name\":\"newEmissionsPerSecond\",\"type\":\"uint88[]\"}],\"name\":\"setEmissionPerSecond\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"reward\",\"type\":\"address\"},{\"internalType\":\"contract IEACAggregatorProxy\",\"name\":\"rewardOracle\",\"type\":\"address\"}],\"name\":\"setRewardOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rewardsVault\",\"type\":\"address\"}],\"name\":\"setRewardsVault\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"solidStaking\",\"type\":\"address\"}],\"name\":\"setSolidStaking\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_solidStakingViewActions\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardsVault\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"emissionManager\",\"type\":\"address\"}],\"name\":\"setup\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"solidStakingViewActions\",\"outputs\":[{\"internalType\":\"contract ISolidStakingViewActions\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"rewards\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"}],\"name\":\"updateCarbonRewardDistribution\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "RewardsController", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "10000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": ""}