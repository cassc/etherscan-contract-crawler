{"SourceCode": "// Forge - Contract\r\n//\r\n// Distrubtion of Forge Token is as follows:\r\n// 25% of Forge Token is Auctioned in the ForgeAuctions Contract which distributes tokens to users who use 0xBitcoin to buy tokens in fair price. Each auction lasts ~3 days. Using the Auctions contract\r\n// +\r\n// 25% of Forge Token is distributed as Liquidiy Pool rewards in the ForgeRewards Contract which distributes tokens to users who deposit the SpiritSwap Liquidity Pool tokens into the LPRewards contract.\r\n// +\r\n// 50% of Forge Token is distributed using Forge Contract(this Contract) which distributes tokens to users by using Proof of work. Computers solve a complicated problem to gain tokens!\r\n//\r\n// = 100% Of the Token is distributed to the users! No dev fee or premine!\r\n//\r\n// All distributions happen fairly using Bitcoins model of distribution using reward halvings and difficulty adjustments.  Distribution happens over 100 years!  \r\n// 100%  on-chain, decentralized, trustless, ownerless contracts*!\r\n//   The harder it is mined the less tokens that are awarded.\r\n// Network: Polygon Chain \r\n// ChainID = 89\r\n//\r\n//\r\n// Name: Forge\r\n// Symbol: Fge\r\n// Decimals: 18 \r\n//\r\n// Total supply: 42,000,001.000000000000000000\r\n//   =\r\n// 21,000,000 Mined over 100+ years using Bitcoins Distrubtion halvings every 4 years. Uses Proof-oF-Work to distribute the tokens. Public Miner is available.  Uses this contract.\r\n//   +\r\n// 10,500,000 Auctioned over 100+ years into 4 day auctions split fairly among all buyers. ALL 0xBitcoin proceeds go into THIS contract which it fairly distributes to miners.  Uses the ForgeAuctions contract\r\n//   +\r\n// 10,500,000 tokens goes to Liquidity Providers of the token over 100+ year using Bitcoins distribution!  Helps prevent LP losses!  Uses the ForgeRewards Contract\r\n//\r\n//  =\r\n//\r\n// 42,000,001 Tokens is the max Supply\r\n//      \r\n// 66% of the 0xBitcoin Token from this contract goes to the Miner to pay for the transaction cost and if the token grows enough earn 0xBitcoin per mint!!\r\n// 33% of the 0xBitcoin TOken from this contract goes to the Liquidity Providers via ForgeRewards Contract.  Helps prevent Impermant Loss! Larger Liquidity!\r\n//\r\n// No premine, dev cut, or advantage taken at launch. Public miner available at launch.  100% of the token is given away fairly over 100+ years using Bitcoins model!\r\n//\r\n// Send this contract any ERC20 token and it will become instantly mineable and able to distribute using proof-of-work for 1 year!!!!\r\n//\r\n//Viva la Mineables!!! Send this contract any ERC20 complient token (Wrapped NFTs incoming!) and we will fairly to miners and Holders(\r\n//  Each Mint prints (1/10000) of any ERC20.\r\n//pThirdDifficulty allows for the difficulty to be cut in a third.  So difficulty 10,000 becomes 3,333.  Costs 333 Fantom  Makes mining 3x easier\r\n//* 1 tokens in LP are burned to create the LP pool.\r\n//\r\n// Credits: 0xBitcoin, Vether, Synethix\r\n//* Except for Staking Rewards additional cryptocurrencies\r\n\r\n\r\npragma solidity ^0.8.11;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event TransferOwnership(address _from, address _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit TransferOwnership(address(0), msg.sender);\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"only owner\");\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _owner) internal onlyOwner {\r\n        emit TransferOwnership(owner, _owner);\r\n        owner = _owner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\nlibrary IsContract {\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        bytes32 codehash;\r\n        /* solium-disable-next-line */\r\n        assembly { codehash := extcodehash(_addr) }\r\n        return codehash != bytes32(0) && codehash != bytes32(0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470);\r\n    }\r\n}\r\n\r\n// File: contracts/utils/SafeMath.sol\r\n\r\nlibrary SafeMath2 {\r\n    function add(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        uint256 z = x + y;\r\n        require(z >= x, \"Add overflow\");\r\n        return z;\r\n    }\r\n\r\n    function sub(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(x >= y, \"Sub underflow\");\r\n        return x - y;\r\n    }\r\n\r\n    function mult(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        if (x == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 z = x * y;\r\n        require(z / x == y, \"Mult overflow\");\r\n        return z;\r\n    }\r\n\r\n    function div(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        return x / y;\r\n    }\r\n\r\n    function divRound(uint256 x, uint256 y) internal pure returns (uint256) {\r\n        require(y != 0, \"Div by zero\");\r\n        uint256 r = x / y;\r\n        if (x % y != 0) {\r\n            r = r + 1;\r\n        }\r\n\r\n        return r;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/Math.sol\r\n\r\nlibrary ExtendedMath2 {\r\n\r\n\r\n    //return the smaller of the two inputs (a or b)\r\n    function limitLessThan(uint a, uint b) internal pure returns (uint c) {\r\n\r\n        if(a > b) return b;\r\n\r\n        return a;\r\n\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns (uint256);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    \r\n}\r\n\r\n\r\n// File: contracts/commons/AddressMinHeap.sol\r\n\r\n\r\n\r\nabstract contract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes memory data) virtual public;\r\n}\r\n\r\n\r\n//Main contract\r\n\r\ncontract Forge is Ownable, IERC20, ApproveAndCallFallBack {\r\n\tuint constant public targetTime = 60 * 48;\r\n    uint public multipler = 0;\r\n// SUPPORTING CONTRACTS\r\n    address public AddressAuction;\r\n    address public AddressLPReward;\r\n    address public AddressZeroXBTC;\r\n//Events\r\n    using SafeMath2 for uint256;\r\n    using ExtendedMath2 for uint;\r\n    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\r\n    event MegaMint(address indexed from, uint epochCount, bytes32 newChallengeNumber, uint NumberOfTokensMinted, uint256 TokenMultipler);\r\n\r\n// Managment events\r\n    uint256 override public totalSupply = 42000001000000000000000000;\r\n    bytes32 private constant BALANCE_KEY = keccak256(\"balance\");\r\n\r\n    //BITCOIN INITALIZE Start\r\n\t\r\n    uint _totalSupply = 21000000000000000000000000;\r\n    uint public latestDifficultyPeriodStarted2 = block.timestamp;\r\n    uint public epochCount = 0;//number of 'blocks' mined\r\n\r\n    uint public _BLOCKS_PER_READJUSTMENT = 256;\r\n\r\n    //a little number\r\n    uint public  _MINIMUM_TARGET = 2**16;\r\n    \r\n    uint public  _MAXIMUM_TARGET = 2**234;\r\n    uint public miningTarget = _MAXIMUM_TARGET.div(200000000000*25);  //1000 million difficulty to start until i enable mining\r\n    \r\n    bytes32 public challengeNumber = blockhash(block.number - 1);   //generate a new one when a new reward is minted\r\n    uint public rewardEra = 0;\r\n    uint public maxSupplyForEra = (_totalSupply - _totalSupply.div( 2**(rewardEra + 1)));\r\n    uint public reward_amount = 0;\r\n    \r\n    //Stuff for Functions\r\n    uint oldecount = 0;\r\n    uint public previousBlockTime  =  block.timestamp;\r\n    uint oneEthUnit =    1000000000000000000;\r\n    uint one8unit   =              100000000;\r\n    uint public Token2Per=           1000000;\r\n    uint Token2Min=                       88;\r\n    uint public tokensMinted;\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n    uint give0xBTC = 0;\r\n    uint give = 1;\r\n    // metadata\r\n    string public name = \"Forge\";\r\n    string public constant symbol = \"Fge\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    uint256 lastrun = block.timestamp;\r\n    uint public latestDifficultyPeriodStarted = block.number;\r\n    bool initeds = false;\r\n    \r\n    // mint 1 token to setup LPs\r\n\t    constructor() public {\r\n    balances[msg.sender] = 1000000000000000000;\r\n    emit Transfer(address(0), msg.sender, 1000000000000000000);\r\n\t}\r\n\r\n    function zinit(address AuctionAddress2, address LPGuild2, address _ZeroXBTCAddress) public onlyOwner{\r\n        uint x = 21000000000000000000000000; \r\n        // Only init once\r\n        assert(!initeds);\r\n        initeds = true;\r\n\t    previousBlockTime = block.timestamp;\r\n\t    reward_amount = (100 * 10**uint(decimals) ).div( 2**rewardEra );\r\n    \trewardEra = 0;\r\n\t    tokensMinted = 0;\r\n\t    epochCount = 0;\r\n    \tminingTarget = _MAXIMUM_TARGET.div(1); //5000000 = 31gh/s @ 7 min for FPGA mining\r\n        latestDifficultyPeriodStarted2 = block.timestamp;\r\n    \t_startNewMiningEpoch();\r\n        // Init contract variables and mint\r\n        balances[AuctionAddress2] = x/2;\r\n\t\r\n        emit Transfer(address(0), AuctionAddress2, x/2);\r\n\t\r\n    \tAddressAuction = AuctionAddress2;\r\n        AddressLPReward = payable(LPGuild2);\r\n        AddressZeroXBTC = _ZeroXBTCAddress;\r\n\t\r\n        oldecount = epochCount;\r\n\t\r\n\t\tsetOwner(address(0));\r\n     \r\n    }\r\n\r\n\r\n\r\n\t///\r\n\t// Managment\r\n\t///\r\n\r\n\tfunction ARewardSender() public {\r\n\t\t//runs every _BLOCKS_PER_READJUSTMENT / 4\r\n\r\n\t\tuint256 runs = block.timestamp - lastrun;\r\n\r\n\t\tuint256 epochsPast = epochCount - oldecount; //actually epoch\r\n\t\tuint256 runsperepoch = runs / epochsPast;\r\n\r\n\t\treward_amount = (100 * 10**uint(decimals)).div( 2**rewardEra );\r\n\t\tuint256 x = (runsperepoch * 888).divRound(targetTime);\r\n\t\tuint256 ratio = x * 100 / 888;\r\n\t\tuint256 totalOwed;\r\n\t\t\r\n\t\t if(ratio < 200){\r\n\t\t\ttotalOwed = (61001200 * (x ** 2 )).div(888**2) + (40861500 * x).div(888) ;\r\n\t\t }else {\r\n\t\t\ttotalOwed = (340000000);\r\n\t\t} \r\n\r\n\t\tif(IERC20(AddressZeroXBTC).balanceOf(address(this)) > (30 * 2 * (Token2Per * _BLOCKS_PER_READJUSTMENT)/4)){  // at least enough blocks to rerun this function for both LPRewards and Users\r\n\t\t\tIERC20(AddressZeroXBTC).transfer(AddressLPReward, ((epochsPast) * totalOwed * Token2Per * give0xBTC).div(2 * 100000000));\r\n\t\t\tgive0xBTC = 1 * give;\r\n\t\t}else{\r\n\t\t\tgive0xBTC = 0;\r\n\t\t}\r\n\t\toldecount = epochCount; //actually epoch\r\n\r\n\t\tlastrun = block.timestamp;\r\n\t}\r\n\r\n\r\n\t//comability function\r\n\tfunction mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success) {\r\n\t\tmintTo(nonce, challenge_digest, msg.sender);\r\n\t}\r\n\r\n\r\n\tfunction mintTo(uint256 nonce, bytes32 challenge_digest,  address mintTo) public returns (uint256 owed) {\r\n\r\n\t\tbytes32 digest =  keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\r\n\r\n\t\t//the challenge digest must match the expected\r\n\t\trequire(digest == challenge_digest, \"Old challenge_digest or wrong challenge_digest\");\r\n\r\n\t\t//the digest must be smaller than the target\r\n\t\trequire(uint256(digest) < miningTarget, \"Digest must be smaller than miningTarget\");\r\n\t\t_startNewMiningEpoch();\r\n\r\n\t\trequire(block.timestamp > previousBlockTime, \"No same second solves\");\r\n\r\n\t\t//uint diff = block.timestamp - previousBlockTime;\r\n\t\tuint256 x = ((block.timestamp - previousBlockTime) * 888) / targetTime;\r\n\t\tuint ratio = x * 100 / 888;\r\n\t\tuint totalOwed = 0;\r\n\t\tif(ratio < 314){\r\n\t\t\ttotalOwed = (61001200 * (x ** 2 )).div(888 ** 2)+ (40861500 * x).div(888);\r\n\t\t}else {\r\n\t\t\ttotalOwed = (x * 100000000).div(888) + (350000000);\r\n\t\t} \r\n\r\n\r\n\t\tbalances[mintTo] = balances[mintTo].add((reward_amount * totalOwed).div(100000000));\r\n\t\tbalances[AddressLPReward] = balances[AddressLPReward].add((reward_amount * totalOwed).div(100000000 * 2));\r\n\t\t\t\t\r\n\t\ttokensMinted = tokensMinted.add((reward_amount * totalOwed).div(100000000));\r\n\t\tpreviousBlockTime = block.timestamp;\r\n\r\n\t\tif(give0xBTC > 0){\r\n\t\t\tif(ratio < 200){\r\n\t\t\t\tIERC20(AddressZeroXBTC).transfer(mintTo, (totalOwed * Token2Per * give0xBTC).div(100000000));\r\n\t\t\t}else{\r\n\t\t\t\tIERC20(AddressZeroXBTC).transfer(mintTo, (34 * Token2Per * give0xBTC).div(10));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\temit Mint(msg.sender, (reward_amount * totalOwed).div(100000000), epochCount, challengeNumber );\r\n\r\n\t\treturn totalOwed;\r\n\r\n\t}\r\n\r\n\r\n\tfunction mintTokensArrayTo(uint256 nonce, bytes32 challenge_digest, address[] memory ExtraFunds, address[] memory MintTo) public returns (uint256 owed) {\r\n\t\tuint256 totalOd = mintTo(nonce,challenge_digest, MintTo[0]);\r\n\t\trequire(totalOd > 0, \"mint issue\");\r\n\r\n\t\trequire(MintTo.length == ExtraFunds.length + 1,\"MintTo has to have an extra address compared to ExtraFunds\");\r\n\t\tuint xy=0;\r\n\t\tfor(xy = 0; xy< ExtraFunds.length; xy++)\r\n\t\t{\r\n\t\t\tif(epochCount % (2**(xy+1)) != 0){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trequire(ExtraFunds[xy] != address(this) && ExtraFunds[xy] != AddressZeroXBTC, \"No base printing of tokens\");\r\n\t\t\tfor(uint y=xy+1; y< ExtraFunds.length; y++){\r\n\t\t\t\trequire(ExtraFunds[y] != ExtraFunds[xy], \"No printing The same tokens\");\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tuint256 totalOwed = 0;\r\n\t\tuint256 TotalOwned = 0;\r\n\t\tfor(uint x=0; x<xy; x++)\r\n\t\t{\r\n\t\t\t//epoch count must evenly dividable by 2^n in order to get extra mints. \r\n\t\t\t//ex. epoch 2 = 1 extramint, epoch 4 = 2 extra, epoch 8 = 3 extra mints, epoch 16 = 4 extra mints w/ a divRound for the 4th mint(allows small balance token minting aka NFTs)\r\n\t\t\tif(epochCount % (2**(x+1)) == 0){\r\n\t\t\t\tTotalOwned = IERC20(ExtraFunds[x]).balanceOf(address(this));\r\n\t\t\t\tif(TotalOwned != 0){\r\n\t\t\t\t\tif( x % 3 == 0 && x != 0){\r\n\t\t\t\t\t\ttotalOwed = (TotalOwned * totalOd).divRound(100000000 * 2500);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\ttotalOwed = (TotalOwned * totalOd).div(100000000 * 2500 );\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t    IERC20(ExtraFunds[x]).transfer(MintTo[x+1], totalOwed);\r\n\t\t\t}\r\n        }\r\n        \t\r\n\t\temit MegaMint(msg.sender, epochCount, challengeNumber, xy, totalOd );\r\n\r\n\t\treturn totalOd;\r\n\r\n    }\r\n\r\n\r\n\tfunction mintTokensSameAddress(uint256 nonce, bytes32 challenge_digest, address[] memory ExtraFunds, address MintTo) public returns (bool success) {\r\n\t\taddress[] memory dd = new address[](ExtraFunds.length + 1); \r\n\r\n\t\tfor(uint x=0; x< (ExtraFunds.length + 1); x++)\r\n\t\t{\r\n\t\t\tdd[x] = MintTo;\r\n\t\t}\r\n\t\t\r\n\t\tmintTokensArrayTo(nonce, challenge_digest, ExtraFunds, dd);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction empty_mintTo(uint256 nonce, bytes32 challenge_digest, address[] memory ExtraFunds, address[] memory MintTo) public returns (uint256 owed) {\r\n\t\tbytes32 digest =  keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\r\n\r\n\t\t//the challenge digest must match the expected\r\n\t\trequire(digest == challenge_digest, \"Old challenge_digest or wrong challenge_digest\");\r\n\r\n\t\t//the digest must be smaller than the target\r\n\t\trequire(uint256(digest) < miningTarget, \"Digest must be smaller than miningTarget\");\r\n\t\t_startNewMiningEpoch();\r\n\r\n\t\trequire(block.timestamp > previousBlockTime, \"No same second solves\");\r\n\t\trequire(MintTo.length == ExtraFunds.length,\"MintTo has to have same number of addressses as ExtraFunds\");\r\n\t\tuint xy=0;\r\n\t\tfor(xy = 0; xy< ExtraFunds.length; xy++)\r\n\t\t{\r\n\t\t\tif(epochCount % (2**(xy+1)) != 0){\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\trequire(ExtraFunds[xy] != address(this) && ExtraFunds[xy] != AddressZeroXBTC, \"No base printing of tokens\");\r\n\t\t\tfor(uint y=xy+1; y< ExtraFunds.length; y++){\r\n\t\t\t\trequire(ExtraFunds[y] != ExtraFunds[xy], \"No printing The same tokens\");\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 x = ((block.timestamp - previousBlockTime) * 888) / targetTime;\r\n\t\tuint ratio = x * 100 / 888;\r\n\t\tuint totalIN = 0;\r\n\t\tif(ratio < 314){\r\n\t\t\ttotalIN = (61001200 * (x ** 2 )).div(888 ** 2)+ (40861500 * x).div(888);\r\n\t\t}else {\r\n\t\t\ttotalIN = (x * 100000000).div(888) + (350000000);\r\n\t\t} \r\n\t\trequire(totalIN > 0, \"mint issue\");\r\n\t\tuint256 totalOwed;\r\n\t\tuint256 TotalOwned;\r\n\t\tfor(uint x=0; x<xy; x++)\r\n\t\t{\r\n\t\t\t//epoch count must evenly dividable by 2^n in order to get extra mints. \r\n\t\t\t//ex. epoch 2 = 1 extramint, epoch 4 = 2 extra, epoch 8 = 3 extra mints, epoch 16 = 4 extra mints w/ a divRound for the 4th mint(allows small balance token minting aka NFTs)\r\n\t\t\tif(epochCount % (2**(x+1)) == 0){\r\n\t\t\t\tTotalOwned = IERC20(ExtraFunds[x]).balanceOf(address(this));\r\n\t\t\t\tif(TotalOwned != 0){\r\n\t\t\t\t\tif( x % 3 == 0 && x != 0){\r\n\t\t\t\t\t\ttotalOwed = (TotalOwned * totalIN).divRound(100000000 * 2500);\r\n\t\t\t\t\t}else{\r\n\t\t\t\t\t\ttotalOwed = (TotalOwned * totalIN).div(100000000 * 2500 );\r\n\t\t\t\t    }\r\n\t\t\t    IERC20(ExtraFunds[x]).transfer(MintTo[x], totalOwed);\r\n\t\t\t    }\r\n            }\r\n        }\r\n\r\n\t\tpreviousBlockTime = block.timestamp;\r\n\t\treturn totalIN;   \r\n\t}\r\n\r\n\r\n\r\n\tfunction _startNewMiningEpoch() internal {\r\n\r\n\r\n\t\t//if max supply for the era will be exceeded next reward round then enter the new era before that happens\r\n\t\t//59 is the final reward era, almost all tokens minted\r\n\t\tif( tokensMinted.add(reward_amount) > maxSupplyForEra && rewardEra < 60)\r\n\t\t{\r\n\t\t\trewardEra = rewardEra + 1;\r\n\t\t\tmaxSupplyForEra = _totalSupply - _totalSupply.div( 2**(rewardEra + 1));\r\n\t\t}\r\n\r\n\t\t//set the next minted supply at which the era will change\r\n\t\t// total supply of MINED tokens is 21000000000000000000000000  because of 16 decimal places\r\n\r\n\t\tepochCount = epochCount.add(1);\r\n\r\n\t\t//every so often, readjust difficulty. Dont readjust when deploying\r\n\t\tif((epochCount) % (_BLOCKS_PER_READJUSTMENT / 4) == 0)\r\n\t\t{\r\n\t\t\tARewardSender();\r\n\t\t\tmaxSupplyForEra = _totalSupply - _totalSupply.div( 2**(rewardEra + 1));\r\n\r\n\t\t\tif((epochCount % _BLOCKS_PER_READJUSTMENT== 0))\r\n\t\t\t{\r\n\t\t\t\tmultipler = (IERC20(AddressZeroXBTC).balanceOf(address(this)) / (2000 * 10 ** 8));\r\n\t\t\t\tif(( IERC20(AddressZeroXBTC).balanceOf(address(this)) / Token2Per) <= (10000 + 10000*(multipler))) //chosen to give keep 250 days payouts in reserve at current payout\r\n\t\t\t\t{\r\n\t\t\t\t\tif(Token2Per.div(2) > Token2Min)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tToken2Per = Token2Per.div(2);\r\n\t\t\t\t\t}\r\n\t\t\t\t}else{\r\n\t\t\t\t\tToken2Per = Token2Per.mult(3);\r\n\t\t\t\t}\r\n\t\t\t\t_reAdjustDifficulty();\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tchallengeNumber = blockhash(block.number - 1);\r\n\t}\r\n\r\n\r\n\tfunction _reAdjustDifficulty() internal {\r\n\t\tuint256 blktimestamp = block.timestamp;\r\n\t\tuint TimeSinceLastDifficultyPeriod2 = blktimestamp - latestDifficultyPeriodStarted2;\r\n\r\n\t\tuint adjusDiffTargetTime = targetTime *  _BLOCKS_PER_READJUSTMENT; //36 min per block 60 sec * 12\r\n\r\n\t\t//if there were less eth blocks passed in time than expected\r\n\t\tif( TimeSinceLastDifficultyPeriod2 < adjusDiffTargetTime )\r\n\t\t{\r\n\t\t\tuint excess_block_pct = (adjusDiffTargetTime.mult(100)).div( TimeSinceLastDifficultyPeriod2 );\r\n\t\t\tgive = 1;\r\n\t\t\tuint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(1000);\r\n\t\t\t//make it harder \r\n\t\t\tminingTarget = miningTarget.sub(miningTarget.div(2000).mult(excess_block_pct_extra));   //by up to 50 %\r\n\t\t}else{\r\n\t\t\tuint shortage_block_pct = (TimeSinceLastDifficultyPeriod2.mult(100)).div( adjusDiffTargetTime );\r\n\t\t\tgive = 2;\r\n\t\t\tuint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(1000); //always between 0 and 1000\r\n\t\t\t//make it easier\r\n\t\t\tminingTarget = miningTarget.add(miningTarget.div(500).mult(shortage_block_pct_extra));   //by up to 200 %\r\n\t\t}\r\n\r\n\t\tlatestDifficultyPeriodStarted2 = blktimestamp;\r\n\t\tlatestDifficultyPeriodStarted = block.number;\r\n\t\tif(miningTarget < _MINIMUM_TARGET) //very difficult\r\n\t\t{\r\n\t\t\tminingTarget = _MINIMUM_TARGET;\r\n\t\t}\r\n\t\tif(miningTarget > _MAXIMUM_TARGET) //very easy\r\n\t\t{\r\n\t\t\tminingTarget = _MAXIMUM_TARGET;\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\r\n\t\t//42 m coins total\r\n\t\t// = \r\n\t\t//21 million proof of work\r\n\t\t// + \r\n\t\t//10.5 million proof of burn\r\n\t\t// +\r\n\t\t//10.5 million rewards for Liquidity Providers\r\n\r\n\r\n\t//help debug mining software\r\n\tfunction checkMintSolution(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number, uint testTarget) public view returns (bool success) {\r\n\t\tbytes32 digest = bytes32(keccak256(abi.encodePacked(challenge_number,msg.sender,nonce)));\r\n\t\tif(uint256(digest) > testTarget) revert();\r\n\r\n\t\treturn (digest == challenge_digest);\r\n\t}\r\n\r\n\r\n\t//this is a recent ethereum block hash, used to prevent pre-mining future blocks\r\n\tfunction getChallengeNumber() public view returns (bytes32) {\r\n\r\n\t\treturn challengeNumber;\r\n\r\n\t}\r\n\r\n\r\n\t//the number of zeroes the digest of the PoW solution requires.  Auto adjusts\r\n\tfunction getMiningDifficulty() public view returns (uint) {\r\n\r\n\t\treturn _MAXIMUM_TARGET.div(miningTarget);\r\n\t}\r\n\r\n\r\n\tfunction getMiningTarget() public view returns (uint) {\r\n\r\n\t\treturn miningTarget;\r\n\r\n\t}\r\n\r\n\r\n\tfunction getMiningMinted() public view returns (uint) {\r\n\r\n\t\treturn tokensMinted;\r\n\r\n\t}\r\n\r\n\r\n\t//21m coins total\r\n\t//reward begins at 150 and is cut in half every reward era (as tokens are mined)\r\n\tfunction getMiningReward() public view returns (uint) {\r\n\t\t//once we get half way thru the coins, only get 25 per block\r\n\t\t//every reward era, the reward amount halves.\r\n\r\n\t\treturn (100 * 10**uint(decimals) ).div( 2**rewardEra ) ;\r\n\r\n\t\t}\r\n\r\n\r\n\tfunction getEpoch() public view returns (uint) {\r\n\r\n\t\treturn epochCount ;\r\n\r\n\t}\r\n\r\n\r\n\t//help debug mining software\r\n\tfunction getMintDigest(uint256 nonce, bytes32 challenge_digest, bytes32 challenge_number) public view returns (bytes32 digesttest) {\r\n\r\n\t\tbytes32 digest =  keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\r\n\r\n\t\treturn digest;\r\n\r\n\t}\r\n\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\t\t// Get the token balance for account `tokenOwner`\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\tfunction balanceOf(address tokenOwner) public override view returns (uint balance) {\r\n\r\n\t\treturn balances[tokenOwner];\r\n\r\n\t}\r\n\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\t\t// Transfer the balance from token owner's account to `to` account\r\n\r\n\t\t// - Owner's account must have sufficient balance to transfer\r\n\r\n\t\t// - 0 value transfers are allowed\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\r\n\tfunction transfer(address to, uint tokens) public override returns (bool success) {\r\n\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(tokens);\r\n\t\tbalances[to] = balances[to].add(tokens);\r\n\r\n\t\temit Transfer(msg.sender, to, tokens);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\t\t// Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n\r\n\t\t// from the token owner's account\r\n\r\n\t\t//\r\n\r\n\t\t// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n\r\n\t\t// recommends that there are no checks for the approval double-spend attack\r\n\r\n\t\t// as this should be implemented in user interfaces\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\r\n\tfunction approve(address spender, uint tokens) public override returns (bool success) {\r\n\r\n\t\tallowed[msg.sender][spender] = tokens;\r\n\r\n\t\temit Approval(msg.sender, spender, tokens);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\t\t// Transfer `tokens` from the `from` account to the `to` account\r\n\r\n\t\t//\r\n\r\n\t\t// The calling account must already have sufficient tokens approve(...)-d\r\n\r\n\t\t// for spending from the `from` account and\r\n\r\n\t\t// - From account must have sufficient balance to transfer\r\n\r\n\t\t// - Spender must have sufficient allowance to transfer\r\n\r\n\t\t// - 0 value transfers are allowed\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\r\n\tfunction transferFrom(address from, address to, uint tokens) public override returns (bool success) {\r\n\r\n\t\tbalances[from] = balances[from].sub(tokens);\r\n\t\tallowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n\t\tbalances[to] = balances[to].add(tokens);\r\n\r\n\t\temit Transfer(from, to, tokens);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\t\t// Returns the amount of tokens approved by the owner that can be\r\n\r\n\t\t// transferred to the spender's account\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\r\n\tfunction allowance(address tokenOwner, address spender) public override view returns (uint remaining) {\r\n\r\n\t\treturn allowed[tokenOwner][spender];\r\n\r\n\t}\r\n\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\t\t// Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n\r\n\t\t// from the token owner's account. The `spender` contract function\r\n\r\n\t\t// `receiveApproval(...)` is then executed\r\n\r\n\t\t// ------------------------------------------------------------------------\r\n\r\n\r\n\tfunction receiveApproval(address from, uint256 tokens, address token, bytes memory data) public override{\r\n\r\n\t\trequire(token == address(this));\r\n\t\tIERC20(address(this)).transfer(from, tokens);  \r\n\t}\r\n\r\n\r\n\t  //Do not allow ETH to enter\r\n\treceive() external payable {\r\n\r\n\t\trevert();\r\n\t}\r\n\r\n\r\n\tfallback() external payable {\r\n\r\n\t\trevert();\r\n\t}\r\n}\r\n\r\n/*\r\n*\r\n* MIT License\r\n* ===========\r\n*\r\n* Copyright (c) 2022 Forge\r\n*\r\n* Permission is hereby granted, free of charge, to any person obtaining a copy\r\n* of this software and associated documentation files (the \"Software\"), to deal\r\n* in the Software without restriction, including without limitation the rights\r\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n* copies of the Software, and to permit persons to whom the Software is\r\n* furnished to do so, subject to the following conditions:\r\n*\r\n* The above copyright notice and this permission notice shall be included in all\r\n* copies or substantial portions of the Software.   \r\n*\r\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n*/", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newChallengeNumber\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"NumberOfTokensMinted\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"TokenMultipler\",\"type\":\"uint256\"}],\"name\":\"MegaMint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"newChallengeNumber\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"ARewardSender\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AddressAuction\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AddressLPReward\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"AddressZeroXBTC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"Token2Per\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_BLOCKS_PER_READJUSTMENT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAXIMUM_TARGET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MINIMUM_TARGET\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"remaining\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"challengeNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_number\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"testTarget\",\"type\":\"uint256\"}],\"name\":\"checkMintSolution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"ExtraFunds\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"MintTo\",\"type\":\"address[]\"}],\"name\":\"empty_mintTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"epochCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChallengeNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getEpoch\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMiningTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_number\",\"type\":\"bytes32\"}],\"name\":\"getMintDigest\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"digesttest\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestDifficultyPeriodStarted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latestDifficultyPeriodStarted2\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxSupplyForEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"miningTarget\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"mintTo\",\"type\":\"address\"}],\"name\":\"mintTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"ExtraFunds\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"MintTo\",\"type\":\"address[]\"}],\"name\":\"mintTokensArrayTo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"owed\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"ExtraFunds\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"MintTo\",\"type\":\"address\"}],\"name\":\"mintTokensSameAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"multipler\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousBlockTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardEra\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reward_amount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"targetTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"AuctionAddress2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"LPGuild2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ZeroXBTCAddress\",\"type\":\"address\"}],\"name\":\"zinit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Forge", "CompilerVersion": "v0.8.11+commit.d7f03943", "OptimizationUsed": "1", "Runs": "99999", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://bb03436d9d65562d4e1d802ec17043fb29bc5e7165ef1bc37d740d60a44194e7"}