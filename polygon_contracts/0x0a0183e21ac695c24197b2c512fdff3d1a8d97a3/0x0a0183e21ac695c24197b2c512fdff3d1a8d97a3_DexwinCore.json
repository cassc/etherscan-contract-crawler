{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@opengsn/contracts/src/ERC2771Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable no-inline-assembly\\npragma solidity >=0.6.9;\\n\\nimport \\\"./interfaces/IERC2771Recipient.sol\\\";\\n\\n/**\\n * @title The ERC-2771 Recipient Base Abstract Class - Implementation\\n *\\n * @notice Note that this contract was called `BaseRelayRecipient` in the previous revision of the GSN.\\n *\\n * @notice A base contract to be inherited by any contract that want to receive relayed transactions.\\n *\\n * @notice A subclass must use `_msgSender()` instead of `msg.sender`.\\n */\\nabstract contract ERC2771Recipient is IERC2771Recipient {\\n\\n    /*\\n     * Forwarder singleton we accept calls from\\n     */\\n    address private _trustedForwarder;\\n\\n    /**\\n     * :warning: **Warning** :warning: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.\\n     * @notice Method is not a required method to allow Recipients to trust multiple Forwarders. Not recommended yet.\\n     * @return forwarder The address of the Forwarder contract that is being used.\\n     */\\n    function getTrustedForwarder() public virtual view returns (address forwarder){\\n        return _trustedForwarder;\\n    }\\n\\n    function _setTrustedForwarder(address _forwarder) internal {\\n        _trustedForwarder = _forwarder;\\n    }\\n\\n    /// @inheritdoc IERC2771Recipient\\n    function isTrustedForwarder(address forwarder) public virtual override view returns(bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    /// @inheritdoc IERC2771Recipient\\n    function _msgSender() internal override virtual view returns (address ret) {\\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\\n            // At this point we know that the sender is a trusted forwarder,\\n            // so we trust that the last bytes of msg.data are the verified sender address.\\n            // extract sender address from the end of msg.data\\n            assembly {\\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\\n            }\\n        } else {\\n            ret = msg.sender;\\n        }\\n    }\\n\\n    /// @inheritdoc IERC2771Recipient\\n    function _msgData() internal override virtual view returns (bytes calldata ret) {\\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\\n            return msg.data[0:msg.data.length-20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@opengsn/contracts/src/interfaces/IERC2771Recipient.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\n/**\\n * @title The ERC-2771 Recipient Base Abstract Class - Declarations\\n *\\n * @notice A contract must implement this interface in order to support relayed transaction.\\n *\\n * @notice It is recommended that your contract inherits from the ERC2771Recipient contract.\\n */\\nabstract contract IERC2771Recipient {\\n\\n    /**\\n     * :warning: **Warning** :warning: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.\\n     * @param forwarder The address of the Forwarder contract that is being used.\\n     * @return isTrustedForwarder `true` if the Forwarder is trusted to forward relayed transactions by this Recipient.\\n     */\\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\\n\\n    /**\\n     * @notice Use this method the contract anywhere instead of msg.sender to support relayed transactions.\\n     * @return sender The real sender of this call.\\n     * For a call that came through the Forwarder the real sender is extracted from the last 20 bytes of the `msg.data`.\\n     * Otherwise simply returns `msg.sender`.\\n     */\\n    function _msgSender() internal virtual view returns (address);\\n\\n    /**\\n     * @notice Use this method in the contract instead of `msg.data` when difference matters (hashing, signature, etc.)\\n     * @return data The real `msg.data` of this call.\\n     * For a call that came through the Forwarder, the real sender address was appended as the last 20 bytes\\n     * of the `msg.data` - so this method will strip those 20 bytes off.\\n     * Otherwise (if the call was made directly and not through the forwarder) simply returns `msg.data`.\\n     */\\n    function _msgData() internal virtual view returns (bytes calldata);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/DexwinCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\r\\npragma solidity ^0.8.17;\\r\\n\\r\\nimport \\\"@opengsn/contracts/src/ERC2771Recipient.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts/security/ReentrancyGuard.sol\\\";\\r\\n\\r\\ninterface IERC20 {\\r\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\r\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    function balanceOf(address account) external view returns (uint256);\\r\\n\\r\\n    function transfer(address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function allowance(address owner, address spender) external view returns (uint256);\\r\\n\\r\\n    function approve(address spender, uint256 amount) external returns (bool);\\r\\n\\r\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\r\\n\\r\\n    function name() external returns (string memory);\\r\\n}\\r\\n\\r\\ncontract DexwinCore is ERC2771Recipient, ReentrancyGuard {\\r\\n    /* State Variables */\\r\\n\\r\\n    /* Core Variables */\\r\\n    mapping(address => bool) private s_coreOwner;\\r\\n    //address private s_coreOwner;\\r\\n\\r\\n    mapping(address => bool) private s_allowedTokens;\\r\\n    mapping(address => address) private s_baseProvider;\\r\\n    mapping(address => address) private s_randomProvider;\\r\\n\\r\\n    //Individual\\r\\n    // user => token => amount\\r\\n    mapping(address => mapping(address => uint256)) private s_userBalance;\\r\\n    mapping(address => mapping(address => uint256)) private s_userTips;\\r\\n    mapping(address => mapping(address => uint256)) private s_userStaked;\\r\\n    mapping(address => mapping(address => uint256)) private s_houseLiquidity;\\r\\n    mapping(address => mapping(address => uint256)) private s_payout;\\r\\n\\r\\n    // Totals\\r\\n    // token => total\\r\\n    mapping(address => uint256) private s_totalUserFunds;\\r\\n    mapping(address => uint256) private s_totalUserTips;\\r\\n    mapping(address => uint256) private s_totalStaked;\\r\\n    mapping(address => uint256) private s_totalHL;\\r\\n    mapping(address => uint256) private s_totalPayout;\\r\\n\\r\\n    //user => token => id\\r\\n    mapping(address => mapping(address => uint256)) private s_providerToId;\\r\\n    mapping(address => address[]) private s_tokenToLiquidityProvider;\\r\\n    mapping(address => uint256) public tokenToLiquidityProviderCount;\\r\\n\\r\\n    /* Events */\\r\\n    event SetCoreOwnership(address indexed owner, bool indexed status);\\r\\n    event BaseProvider(address indexed token, address indexed oldBaseDepositor, address indexed newBaseDepositor);\\r\\n    event Deposit(address indexed token, address indexed sender, uint256 indexed amount);\\r\\n    event Tips(address indexed tipper, address indexed receiver, address indexed token, uint256 amount);\\r\\n    event Withdrawal(address indexed token, address indexed withdrawee, uint256 indexed amount);\\r\\n    event HouseLiquidityDeposit(address indexed token, address indexed depositer, uint256 indexed amount);\\r\\n    event Liquidated(address indexed token, address indexed liquidator, uint256 indexed amount);\\r\\n\\r\\n    constructor(address owner) {\\r\\n        s_coreOwner[owner] = true;\\r\\n        emit SetCoreOwnership(owner, true);\\r\\n    }\\r\\n\\r\\n    modifier onlyCoreOwner() {\\r\\n        if (!s_coreOwner[_msgSender()]) {\\r\\n            revert(\\\"Core__OnlyOwnerMethod\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier isTokenValid(address token) {\\r\\n        if (!s_allowedTokens[token]) {\\r\\n            revert(\\\"Core__TokenNotUsed\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    modifier amountIsValid(uint256 amount) {\\r\\n        if (!(amount > 0)) {\\r\\n            revert(\\\"Core__AmountIsInvalid\\\");\\r\\n        }\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /*State changing methods*/\\r\\n\\r\\n    /*setting trusted forwarder for meta tx eip 2771*/\\r\\n    function setTrustedForwarder(address _trustedForwarder) external onlyCoreOwner {\\r\\n        _setTrustedForwarder(_trustedForwarder);\\r\\n    }\\r\\n\\r\\n    function setCoreOwnership(address _newOwner) external onlyCoreOwner {\\r\\n        _setCoreOwnership(_newOwner);\\r\\n    }\\r\\n\\r\\n    function _setCoreOwnership(address _newOwner) internal {\\r\\n        if (_newOwner == address(0)) {\\r\\n            revert(\\\"Core_InvalidAddress\\\");\\r\\n        }\\r\\n        s_coreOwner[_newOwner] = true;\\r\\n        emit SetCoreOwnership(_newOwner, true);\\r\\n    }\\r\\n\\r\\n    function disableCoreOwnership(address _owner) external onlyCoreOwner {\\r\\n        _disableCoreOwnership(_owner);\\r\\n    }\\r\\n\\r\\n    function _disableCoreOwnership(address _owner) internal {\\r\\n        if (_owner == address(0)) revert(\\\"Core_InvalidAddress\\\");\\r\\n        if (_msgSender() != _owner) revert(\\\"Only Owner\\\");\\r\\n        s_coreOwner[_owner] = false;\\r\\n        emit SetCoreOwnership(_owner, false);\\r\\n    }\\r\\n\\r\\n    function addTokens(address _token) external onlyCoreOwner {\\r\\n        s_allowedTokens[_token] = true;\\r\\n    }\\r\\n\\r\\n    function disableToken(address _token) external onlyCoreOwner isTokenValid(_token) {\\r\\n        s_allowedTokens[_token] = false;\\r\\n    }\\r\\n\\r\\n    function setBaseProvider(address baseProvider, address token) external onlyCoreOwner isTokenValid(token) {\\r\\n        if (baseProvider == address(0)) {\\r\\n            revert(\\\"Core_InvalidAddress\\\");\\r\\n        }\\r\\n        address oldBaseProvider = s_baseProvider[token];\\r\\n        s_baseProvider[token] = baseProvider;\\r\\n        emit BaseProvider(token, oldBaseProvider, baseProvider);\\r\\n    }\\r\\n\\r\\n    function getRandomProvider(address token, uint256 randomWord) external onlyCoreOwner isTokenValid(token) returns (address) {\\r\\n        uint256 randomProviderIndex = randomWord % getLiquidtyProvidersCount(token);\\r\\n        s_randomProvider[token] = getLiquidtyProvidersAddress(token, randomProviderIndex);\\r\\n        return s_randomProvider[token];\\r\\n    }\\r\\n\\r\\n    receive() external payable onlyCoreOwner {}\\r\\n\\r\\n    fallback() external payable onlyCoreOwner {}\\r\\n\\r\\n    function deposit(address _token, uint256 amount) public isTokenValid(_token) amountIsValid(amount) {\\r\\n        IERC20 token = IERC20(_token);\\r\\n        s_userBalance[_msgSender()][_token] += amount;\\r\\n        s_totalUserFunds[_token] += amount;\\r\\n        bool success = token.transferFrom(_msgSender(), address(this), amount);\\r\\n        if (!success) revert(\\\"Core__TransferFailed\\\");\\r\\n        emit Deposit(_token, _msgSender(), amount);\\r\\n    }\\r\\n\\r\\n    function depositTips(address receiver, address _token, uint256 amount) public isTokenValid(_token) amountIsValid(amount) {\\r\\n        IERC20 token = IERC20(_token);\\r\\n        s_userTips[receiver][_token] += amount;\\r\\n        s_totalUserTips[_token] += amount;\\r\\n        bool success = token.transferFrom(_msgSender(), address(this), amount);\\r\\n        if (!success) revert(\\\"Core__UTipsFailed\\\");\\r\\n        emit Tips(_msgSender(), receiver, _token, amount);\\r\\n    }\\r\\n\\r\\n    function sendTips(address receiver, address _token, uint256 amount) public isTokenValid(_token) amountIsValid(amount) {\\r\\n        if (amount > s_userBalance[_msgSender()][_token]) revert(\\\"Tips Greater than bal\\\");\\r\\n        s_userTips[receiver][_token] += amount;\\r\\n        s_totalUserTips[_token] += amount;\\r\\n        s_userBalance[_msgSender()][_token] -= amount;\\r\\n        s_totalUserFunds[_token] -= amount;\\r\\n        emit Tips(_msgSender(), receiver, _token, amount);\\r\\n    }\\r\\n\\r\\n    function depositHL(address _token, uint256 amount) public isTokenValid(_token) amountIsValid(amount) {\\r\\n        IERC20 token = IERC20(_token);\\r\\n        if (s_houseLiquidity[_msgSender()][_token] == 0) {\\r\\n            s_tokenToLiquidityProvider[_token].push(_msgSender());\\r\\n            tokenToLiquidityProviderCount[_token]++;\\r\\n            s_providerToId[_msgSender()][_token] = tokenToLiquidityProviderCount[_token];\\r\\n        }\\r\\n        s_houseLiquidity[_msgSender()][_token] += amount;\\r\\n        s_totalHL[_token] += amount;\\r\\n        bool success = token.transferFrom(_msgSender(), address(this), amount);\\r\\n        if (!success) revert(\\\"Core__TransferFailed\\\");\\r\\n        emit HouseLiquidityDeposit(_token, _msgSender(), amount);\\r\\n    }\\r\\n\\r\\n    function withdraw(address _token, uint256 amount) public nonReentrant isTokenValid(_token) amountIsValid(amount) {\\r\\n        if (s_userBalance[_msgSender()][_token] >= amount) {\\r\\n            IERC20 token = IERC20(_token);\\r\\n            s_userBalance[_msgSender()][_token] -= amount;\\r\\n            s_totalUserFunds[_token] -= amount;\\r\\n            bool success = token.transfer(_msgSender(), amount);\\r\\n            if (!success) revert(\\\"Core__TransferFailed\\\");\\r\\n            emit Withdrawal(_token, _msgSender(), amount);\\r\\n        } else {\\r\\n            revert(\\\"Core__WithdrawAmtGreaterThanBalance\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function withdrawHL(address _token, uint256 amount) public nonReentrant isTokenValid(_token) amountIsValid(amount) {\\r\\n        if (s_houseLiquidity[_msgSender()][_token] >= amount) {\\r\\n            IERC20 token = IERC20(_token);\\r\\n\\r\\n            if (s_houseLiquidity[_msgSender()][_token] == amount) {\\r\\n                uint256 index = s_providerToId[_msgSender()][_token] - 1;\\r\\n                address provider = s_tokenToLiquidityProvider[_token][index];\\r\\n                if (_msgSender() == provider) {\\r\\n                    delete s_tokenToLiquidityProvider[_token][index];\\r\\n                }\\r\\n            }\\r\\n            s_houseLiquidity[_msgSender()][_token] -= amount;\\r\\n            s_totalHL[_token] -= amount;\\r\\n            bool success = token.transfer(_msgSender(), amount);\\r\\n            if (!success) revert(\\\"Core__TransferFailed\\\");\\r\\n            emit Liquidated(_token, _msgSender(), amount);\\r\\n        } else {\\r\\n            revert(\\\"Core__WithdrawAmtGreaterThanBalance\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /* Methods called in Ops contract */\\r\\n\\r\\n    function handleBalance(address account, address token, uint256 amount, uint256 operator) external onlyCoreOwner isTokenValid(token) {\\r\\n        if (operator == 1) {\\r\\n            s_userBalance[account][token] += amount;\\r\\n            s_totalUserFunds[token] += amount;\\r\\n        } else if (operator == 0) {\\r\\n            s_userBalance[account][token] -= amount;\\r\\n            s_totalUserFunds[token] -= amount;\\r\\n        } else {\\r\\n            revert(\\\"Core_InvalidOperator\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function handleUserTips(address account, address token, uint256 amount, uint256 operator) external onlyCoreOwner isTokenValid(token) {\\r\\n        if (operator == 1) {\\r\\n            s_userTips[account][token] += amount;\\r\\n            s_totalUserTips[token] += amount;\\r\\n        } else if (operator == 0) {\\r\\n            s_userTips[account][token] -= amount;\\r\\n            s_totalUserTips[token] -= amount;\\r\\n        } else {\\r\\n            revert(\\\"Core_InvalidOperator\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function handleStakes(address account, address token, uint256 amount, uint256 operator) external onlyCoreOwner isTokenValid(token) {\\r\\n        if (operator == 1) {\\r\\n            s_userStaked[account][token] += amount;\\r\\n            s_totalStaked[token] += amount;\\r\\n        } else if (operator == 0) {\\r\\n            s_userStaked[account][token] -= amount;\\r\\n            s_totalStaked[token] -= amount;\\r\\n        } else {\\r\\n            revert(\\\"Core_InvalidOperator\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function handleHL(address depositer, address token, uint256 amount, uint256 operator) external onlyCoreOwner isTokenValid(token) {\\r\\n        if (operator == 1) {\\r\\n            s_houseLiquidity[depositer][token] += amount;\\r\\n            s_totalHL[token] += amount;\\r\\n        } else if (operator == 0) {\\r\\n            s_houseLiquidity[depositer][token] -= amount;\\r\\n            s_totalHL[token] -= amount;\\r\\n        } else {\\r\\n            revert(\\\"Core_InvalidOperator\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function handlePayout(address account, address token, uint256 amount, uint256 operator) external onlyCoreOwner isTokenValid(token) {\\r\\n        if (operator == 1) {\\r\\n            s_payout[account][token] += amount;\\r\\n            s_totalPayout[token] += amount;\\r\\n        } else if (operator == 0) {\\r\\n            s_payout[account][token] -= amount;\\r\\n            s_totalPayout[token] -= amount;\\r\\n        } else {\\r\\n            revert(\\\"Core_InvalidOperator\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // Gettor Functions\\r\\n\\r\\n    function getCoreOwner(address owner) public view returns (bool) {\\r\\n        return s_coreOwner[owner];\\r\\n    }\\r\\n\\r\\n    function getAllowedTokens(address token) public view returns (bool) {\\r\\n        return s_allowedTokens[token];\\r\\n    }\\r\\n\\r\\n    function getBaseProvider(address token) public view isTokenValid(token) returns (address) {\\r\\n        return s_baseProvider[token];\\r\\n    }\\r\\n\\r\\n    function getLiquidtyProvidersCount(address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return tokenToLiquidityProviderCount[token];\\r\\n    }\\r\\n\\r\\n    function getLiquidtyProvidersId(address account, address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_providerToId[account][token];\\r\\n    }\\r\\n\\r\\n    function getLiquidtyProvidersAddress(address token, uint256 index) public view isTokenValid(token) returns (address) {\\r\\n        return s_tokenToLiquidityProvider[token][index];\\r\\n    }\\r\\n\\r\\n    function getUserBalance(address account, address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_userBalance[account][token];\\r\\n    }\\r\\n\\r\\n    function getTotalFunds(address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_totalUserFunds[token];\\r\\n    }\\r\\n\\r\\n    function getUserTips(address account, address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_userTips[account][token];\\r\\n    }\\r\\n\\r\\n    function getTotalUserTips(address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_totalUserTips[token];\\r\\n    }\\r\\n\\r\\n    function getUserStaked(address account, address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_userStaked[account][token];\\r\\n    }\\r\\n\\r\\n    function getTotalStakes(address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_totalStaked[token];\\r\\n    }\\r\\n\\r\\n    function getDepositerHLBalance(address depositer, address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_houseLiquidity[depositer][token];\\r\\n    }\\r\\n\\r\\n    function getTotalHL(address token) public view isTokenValid(token) returns (uint256) {\\r\\n        return s_totalHL[token];\\r\\n    }\\r\\n\\r\\n    function getProviderPayout(address account, address token) public view returns (uint256) {\\r\\n        return s_payout[account][token];\\r\\n    }\\r\\n\\r\\n    function getTotalPayout(address token) public view returns (uint256) {\\r\\n        return s_totalPayout[token];\\r\\n    }\\r\\n\\r\\n    function getBalancedStatus(address token) public view isTokenValid(token) returns (bool) {\\r\\n        uint256 contractBal = IERC20(token).balanceOf(address(this));\\r\\n        return contractBal == s_totalUserFunds[token] + s_totalUserTips[token] + s_totalStaked[token] + s_totalHL[token] + s_totalPayout[token];\\r\\n    }\\r\\n}\\r\\n////Mainnet\\r\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldBaseDepositor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newBaseDepositor\",\"type\":\"address\"}],\"name\":\"BaseProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"depositer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"HouseLiquidityDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Liquidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"bool\",\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"SetCoreOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tipper\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Tips\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"withdrawee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositHL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"disableCoreOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"disableToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getAllowedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBalancedStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getBaseProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getCoreOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getDepositerHLBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getLiquidtyProvidersAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLiquidtyProvidersCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getLiquidtyProvidersId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getProviderPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"randomWord\",\"type\":\"uint256\"}],\"name\":\"getRandomProvider\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTotalFunds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTotalHL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTotalPayout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTotalStakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTotalUserTips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTrustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getUserTips\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"}],\"name\":\"handleBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"depositer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"}],\"name\":\"handleHL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"}],\"name\":\"handlePayout\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"}],\"name\":\"handleStakes\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"operator\",\"type\":\"uint256\"}],\"name\":\"handleUserTips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendTips\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"baseProvider\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"setBaseProvider\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setCoreOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_trustedForwarder\",\"type\":\"address\"}],\"name\":\"setTrustedForwarder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToLiquidityProviderCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawHL\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "DexwinCore", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000003dbb1579009c992d9aafd8f524e1b19374c5f6cd", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}