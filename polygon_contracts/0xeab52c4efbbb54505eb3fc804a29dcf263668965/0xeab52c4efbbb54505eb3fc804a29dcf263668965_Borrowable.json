{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"./impermax-x-uniswapv2-core/contracts/ImpermaxERC20.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\n// This contract is basically UniswapV2ERC20 with small modifications\\n// src: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol\\n\\ncontract ImpermaxERC20 {\\n\\tusing SafeMath for uint;\\n\\t\\n\\tstring public name;\\n\\tstring public symbol;\\n\\tuint8 public decimals = 18;\\n\\tuint public totalSupply;\\n\\tmapping(address => uint) public balanceOf;\\n\\tmapping(address => mapping(address => uint)) public allowance;\\n\\t\\n\\tbytes32 public DOMAIN_SEPARATOR;\\n\\tmapping(address => uint) public nonces;\\n\\t\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\n\\n\\tconstructor() public {}\\t\\n\\t\\n\\tfunction _setName(string memory _name, string memory _symbol) internal {\\n\\t\\tname = _name;\\n\\t\\tsymbol = _symbol;\\n\\t\\tuint chainId;\\n\\t\\tassembly {\\n\\t\\t\\tchainId := chainid\\n\\t\\t}\\n\\t\\tDOMAIN_SEPARATOR = keccak256(\\n\\t\\t\\tabi.encode(\\n\\t\\t\\t\\tkeccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n\\t\\t\\t\\tkeccak256(bytes(_name)),\\n\\t\\t\\t\\tkeccak256(bytes(\\\"1\\\")),\\n\\t\\t\\t\\tchainId,\\n\\t\\t\\t\\taddress(this)\\n\\t\\t\\t)\\n\\t\\t);\\n\\t}\\n\\n\\tfunction _mint(address to, uint value) internal {\\n\\t\\ttotalSupply = totalSupply.add(value);\\n\\t\\tbalanceOf[to] = balanceOf[to].add(value);\\n\\t\\temit Transfer(address(0), to, value);\\n\\t}\\n\\n\\tfunction _burn(address from, uint value) internal {\\n\\t\\tbalanceOf[from] = balanceOf[from].sub(value);\\n\\t\\ttotalSupply = totalSupply.sub(value);\\n\\t\\temit Transfer(from, address(0), value);\\n\\t}\\n\\n\\tfunction _approve(address owner, address spender, uint value) private {\\n\\t\\tallowance[owner][spender] = value;\\n\\t\\temit Approval(owner, spender, value);\\n\\t}\\n\\n\\tfunction _transfer(address from, address to, uint value) internal {\\n\\t\\tbalanceOf[from] = balanceOf[from].sub(value, \\\"Impermax: TRANSFER_TOO_HIGH\\\");\\n\\t\\tbalanceOf[to] = balanceOf[to].add(value);\\n\\t\\temit Transfer(from, to, value);\\n\\t}\\n\\n\\tfunction approve(address spender, uint value) external returns (bool) {\\n\\t\\t_approve(msg.sender, spender, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transfer(address to, uint value) external returns (bool) {\\n\\t\\t_transfer(msg.sender, to, value);\\n\\t\\treturn true;\\n\\t}\\n\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool) {\\n\\t\\tif (allowance[from][msg.sender] != uint(-1)) {\\n\\t\\t\\tallowance[from][msg.sender] = allowance[from][msg.sender].sub(value, \\\"Impermax: TRANSFER_NOT_ALLOWED\\\");\\n\\t\\t}\\n\\t\\t_transfer(from, to, value);\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tfunction _checkSignature(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s, bytes32 typehash) internal {\\n\\t\\trequire(deadline >= block.timestamp, \\\"Impermax: EXPIRED\\\");\\n\\t\\tbytes32 digest = keccak256(\\n\\t\\t\\tabi.encodePacked(\\n\\t\\t\\t\\t'\\\\x19\\\\x01',\\n\\t\\t\\t\\tDOMAIN_SEPARATOR,\\n\\t\\t\\t\\tkeccak256(abi.encode(typehash, owner, spender, value, nonces[owner]++, deadline))\\n\\t\\t\\t)\\n\\t\\t);\\n\\t\\taddress recoveredAddress = ecrecover(digest, v, r, s);\\n\\t\\trequire(recoveredAddress != address(0) && recoveredAddress == owner, \\\"Impermax: INVALID_SIGNATURE\\\");\\t\\n\\t}\\n\\n\\t// keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\tbytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n\\t\\t_checkSignature(owner, spender, value, deadline, v, r, s, PERMIT_TYPEHASH);\\n\\t\\t_approve(owner, spender, value);\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/libraries/SafeMath.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\\n// Subject to the MIT license.\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"SafeMath: subtraction underflow\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     * - Subtraction cannot underflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, errorMessage);\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"SafeMath: division by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers.\\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        // Solidity only automatically asserts when dividing by 0\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"SafeMath: modulo by zero\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * Reverts with custom message when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/BAllowance.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./BStorage.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\n\\ncontract BAllowance is PoolToken, BStorage {\\t\\n\\n\\tevent BorrowApproval(address indexed owner, address indexed spender, uint256 value);\\n\\n\\tfunction _borrowApprove(address owner, address spender, uint256 value) private {\\n\\t\\tborrowAllowance[owner][spender] = value;\\n\\t\\temit BorrowApproval(owner, spender, value);\\n\\t}\\n\\t\\n\\tfunction borrowApprove(address spender, uint256 value) external returns (bool) {\\n\\t\\t_borrowApprove(msg.sender, spender, value);\\n\\t\\treturn true;\\n\\t}\\n\\t\\n\\tfunction _checkBorrowAllowance(address owner, address spender, uint256 value) internal {\\n\\t\\tuint _borrowAllowance = borrowAllowance[owner][spender];\\n\\t\\tif (spender != owner && _borrowAllowance != uint256(-1)) {\\n\\t\\t\\trequire(_borrowAllowance >= value, \\\"Impermax: BORROW_NOT_ALLOWED\\\");\\n\\t\\t\\tborrowAllowance[owner][spender] = _borrowAllowance - value;\\n\\t\\t}\\t\\n\\t}\\n\\n\\t// keccak256(\\\"BorrowPermit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\tbytes32 public constant BORROW_PERMIT_TYPEHASH = 0xf6d86ed606f871fa1a557ac0ba607adce07767acf53f492fb215a1a4db4aea6f;\\n\\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\\n\\t\\t_checkSignature(owner, spender, value, deadline, v, r, s, BORROW_PERMIT_TYPEHASH);\\n\\t\\t_borrowApprove(owner, spender, value);\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/BStorage.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\ncontract BStorage {\\n\\n\\taddress public collateral;\\n\\n\\tmapping (address => mapping (address => uint256)) public borrowAllowance;\\n\\t\\n\\tstruct BorrowSnapshot {\\n\\t\\tuint112 principal;\\t\\t// amount in underlying when the borrow was last updated\\n\\t\\tuint112 interestIndex;\\t// borrow index when borrow was last updated\\n\\t}\\n\\tmapping(address => BorrowSnapshot) internal borrowBalances;\\t\\n\\n\\t// use one memory slot\\n\\tuint112 public borrowIndex = 1e18;\\n\\tuint112 public totalBorrows;\\n\\tuint32 public accrualTimestamp = uint32(block.timestamp % 2**32);\\t\\n\\n\\tuint public exchangeRateLast;\\n\\t\\t\\n\\t// use one memory slot\\n\\tuint48 public borrowRate;\\n\\tuint48 public kinkBorrowRate = 3.1709792e9; //10% per year\\n\\tuint32 public rateUpdateTimestamp = uint32(block.timestamp % 2**32);\\n\\n\\tuint public reserveFactor = 0.10e18; //10%\\n\\tuint public kinkUtilizationRate = 0.70e18; //70%\\n\\tuint public adjustSpeed = 0.5787037e12; //5% per day\\n\\taddress public borrowTracker;\\n\\n    function safe112(uint n) internal pure returns (uint112) {\\n        require(n < 2**112, \\\"Impermax: SAFE112\\\");\\n        return uint112(n);\\n    }\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/PoolToken.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./ImpermaxERC20.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IPoolToken.sol\\\";\\nimport \\\"./libraries/SafeMath.sol\\\";\\n\\ncontract PoolToken is IPoolToken, ImpermaxERC20 {\\n   \\tuint internal constant initialExchangeRate = 1e18;\\n\\taddress public underlying;\\n\\taddress public factory;\\n\\tuint public totalBalance;\\n\\tuint public constant MINIMUM_LIQUIDITY = 1000;\\n\\t\\n\\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\\n\\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\\n\\tevent Sync(uint totalBalance);\\n\\t\\n\\t/*** Initialize ***/\\n\\t\\n\\t// called once by the factory\\n\\tfunction _setFactory() external {\\n\\t\\trequire(factory == address(0), \\\"Impermax: FACTORY_ALREADY_SET\\\");\\n\\t\\tfactory = msg.sender;\\n\\t}\\n\\t\\n\\t/*** PoolToken ***/\\n\\t\\n\\tfunction _update() internal {\\n\\t\\ttotalBalance = IERC20(underlying).balanceOf(address(this));\\n\\t\\temit Sync(totalBalance);\\n\\t}\\n\\n\\tfunction exchangeRate() public returns (uint) \\n\\t{\\n\\t\\tuint _totalSupply = totalSupply; // gas savings\\n\\t\\tuint _totalBalance = totalBalance; // gas savings\\n\\t\\tif (_totalSupply == 0 || _totalBalance == 0) return initialExchangeRate;\\n\\t\\treturn _totalBalance.mul(1e18).div(_totalSupply);\\n\\t}\\n\\t\\n\\t// this low-level function should be called from another contract\\n\\tfunction mint(address minter) external nonReentrant update returns (uint mintTokens) {\\n\\t\\tuint balance = IERC20(underlying).balanceOf(address(this));\\n\\t\\tuint mintAmount = balance.sub(totalBalance);\\n\\t\\tmintTokens = mintAmount.mul(1e18).div(exchangeRate());\\n\\n\\t\\tif(totalSupply == 0) {\\n\\t\\t\\t// permanently lock the first MINIMUM_LIQUIDITY tokens\\n\\t\\t\\tmintTokens = mintTokens.sub(MINIMUM_LIQUIDITY);\\n\\t\\t\\t_mint(address(0), MINIMUM_LIQUIDITY);\\n\\t\\t}\\n\\t\\trequire(mintTokens > 0, \\\"Impermax: MINT_AMOUNT_ZERO\\\");\\n\\t\\t_mint(minter, mintTokens);\\n\\t\\temit Mint(msg.sender, minter, mintAmount, mintTokens);\\n\\t}\\n\\n\\t// this low-level function should be called from another contract\\n\\tfunction redeem(address redeemer) external nonReentrant update returns (uint redeemAmount) {\\n\\t\\tuint redeemTokens = balanceOf[address(this)];\\n\\t\\tredeemAmount = redeemTokens.mul(exchangeRate()).div(1e18);\\n\\n\\t\\trequire(redeemAmount > 0, \\\"Impermax: REDEEM_AMOUNT_ZERO\\\");\\n\\t\\trequire(redeemAmount <= totalBalance, \\\"Impermax: INSUFFICIENT_CASH\\\");\\n\\t\\t_burn(address(this), redeemTokens);\\n\\t\\t_safeTransfer(redeemer, redeemAmount);\\n\\t\\temit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\t\\t\\n\\t}\\n\\n\\t// force real balance to match totalBalance\\n\\tfunction skim(address to) external nonReentrant {\\n\\t\\t_safeTransfer(to, IERC20(underlying).balanceOf(address(this)).sub(totalBalance));\\n\\t}\\n\\n\\t// force totalBalance to match real balance\\n\\tfunction sync() external nonReentrant update {}\\n\\t\\n\\t/*** Utilities ***/\\n\\t\\n\\t// same safe transfer function used by UniSwapV2 (with fixed underlying)\\n\\tbytes4 private constant SELECTOR = bytes4(keccak256(bytes(\\\"transfer(address,uint256)\\\")));\\n\\tfunction _safeTransfer(address to, uint amount) internal {\\n\\t\\t(bool success, bytes memory data) = underlying.call(abi.encodeWithSelector(SELECTOR, to, amount));\\n\\t\\trequire(success && (data.length == 0 || abi.decode(data, (bool))), \\\"Impermax: TRANSFER_FAILED\\\");\\n\\t}\\n\\t\\n\\t// prevents a contract from calling itself, directly or indirectly.\\n\\tbool internal _notEntered = true;\\n\\tmodifier nonReentrant() {\\n\\t\\trequire(_notEntered, \\\"Impermax: REENTERED\\\");\\n\\t\\t_notEntered = false;\\n\\t\\t_;\\n\\t\\t_notEntered = true;\\n\\t}\\n\\t\\n\\t// update totalBalance with current balance\\n\\tmodifier update() {\\n\\t\\t_;\\n\\t\\t_update();\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IERC20 {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IPoolToken.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IPoolToken {\\n\\n\\t/*** Impermax ERC20 ***/\\n\\t\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\n\\t\\n\\tfunction name() external pure returns (string memory);\\n\\tfunction symbol() external pure returns (string memory);\\n\\tfunction decimals() external pure returns (uint8);\\n\\tfunction totalSupply() external view returns (uint);\\n\\tfunction balanceOf(address owner) external view returns (uint);\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\n\\tfunction approve(address spender, uint value) external returns (bool);\\n\\tfunction transfer(address to, uint value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\n\\t\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\tfunction nonces(address owner) external view returns (uint);\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\t\\n\\t/*** Pool Token ***/\\n\\t\\n\\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\\n\\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\\n\\tevent Sync(uint totalBalance);\\n\\t\\n\\tfunction underlying() external view returns (address);\\n\\tfunction factory() external view returns (address);\\n\\tfunction totalBalance() external view returns (uint);\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n\\tfunction exchangeRate() external returns (uint);\\n\\tfunction mint(address minter) external returns (uint mintTokens);\\n\\tfunction redeem(address redeemer) external returns (uint redeemAmount);\\n\\tfunction skim(address to) external;\\n\\tfunction sync() external;\\n\\t\\n\\tfunction _setFactory() external;\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/CDeployer.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./Collateral.sol\\\";\\nimport \\\"./interfaces/ICDeployer.sol\\\";\\n\\n/*\\n * This contract is used by the Factory to deploy Collateral(s)\\n * The bytecode would be too long to fit in the Factory\\n */\\n \\ncontract CDeployer is ICDeployer {\\n\\tconstructor () public {}\\n\\t\\n\\tfunction deployCollateral(address uniswapV2Pair) external returns (address collateral) {\\n\\t\\tbytes memory bytecode = type(Collateral).creationCode;\\n\\t\\tbytes32 salt = keccak256(abi.encodePacked(msg.sender, uniswapV2Pair));\\n\\t\\tassembly {\\n\\t\\t\\tcollateral := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n\\t\\t}\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/Collateral.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./CStorage.sol\\\";\\nimport \\\"./CSetter.sol\\\";\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\nimport \\\"./interfaces/ICollateral.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"./interfaces/ISimpleUniswapOracle.sol\\\";\\nimport \\\"./interfaces/IImpermaxCallee.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./libraries/UQ112x112.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\n\\ncontract Collateral is ICollateral, PoolToken, CStorage, CSetter {\\n    using UQ112x112 for uint224;\\n\\t\\n\\tconstructor() public {}\\n\\t\\n\\t/*** Collateralization Model ***/\\n\\n\\t// returns the prices of borrowable0's and borrowable1's underlyings with collateral's underlying as denom\\n\\tfunction getPrices() public returns (uint price0, uint price1) {\\n\\t\\t(uint224 twapPrice112x112,) = ISimpleUniswapOracle(simpleUniswapOracle).getResult(underlying);\\n\\t\\t(uint112 reserve0, uint112 reserve1,) = IUniswapV2Pair(underlying).getReserves();\\n\\t\\tuint256 collateralTotalSupply = IUniswapV2Pair(underlying).totalSupply();\\n\\t\\t\\n\\t\\tuint224 currentPrice112x112 = UQ112x112.encode(reserve1).uqdiv(reserve0);\\n\\t\\tuint256 adjustmentSquared = uint256(twapPrice112x112).mul(2**32).div(currentPrice112x112);\\n\\t\\tuint256 adjustment = Math.sqrt(adjustmentSquared.mul(2**32));\\n\\n\\t\\tuint256 currentBorrowable0Price = uint256(collateralTotalSupply).mul(1e18).div(reserve0*2);\\n\\t\\tuint256 currentBorrowable1Price = uint256(collateralTotalSupply).mul(1e18).div(reserve1*2);\\n\\t\\t\\n\\t\\tprice0 = currentBorrowable0Price.mul(adjustment).div(2**32);\\n\\t\\tprice1 = currentBorrowable1Price.mul(2**32).div(adjustment);\\n\\t\\t\\n\\t\\t/*\\n\\t\\t * Price calculation errors may happen in some edge pairs where\\n\\t\\t * reserve0 / reserve1 is close to 2**112 or 1/2**112\\n\\t\\t * We're going to prevent users from using pairs at risk from the UI\\n\\t\\t */\\n\\t\\trequire(price0 > 100, \\\"Impermax: PRICE_CALCULATION_ERROR\\\");\\n\\t\\trequire(price1 > 100, \\\"Impermax: PRICE_CALCULATION_ERROR\\\");\\n\\t}\\n\\t\\n\\t// returns liquidity in  collateral's underlying\\n\\tfunction _calculateLiquidity(uint amountCollateral, uint amount0, uint amount1) internal returns (uint liquidity, uint shortfall) {\\n\\t\\tuint _safetyMarginSqrt = safetyMarginSqrt;\\n\\t\\t(uint price0, uint price1) = getPrices();\\n\\t\\t\\n\\t\\tuint a = amount0.mul(price0).div(1e18);\\n\\t\\tuint b = amount1.mul(price1).div(1e18);\\n\\t\\tif(a < b) (a, b) = (b, a);\\n\\t\\ta = a.mul(_safetyMarginSqrt).div(1e18);\\n\\t\\tb = b.mul(1e18).div(_safetyMarginSqrt);\\n\\t\\tuint collateralNeeded = a.add(b).mul(liquidationIncentive).div(1e18);\\t\\t\\n\\n\\t\\tif(amountCollateral >= collateralNeeded){\\n\\t\\t\\treturn (amountCollateral - collateralNeeded, 0);\\n\\t\\t} else {\\n\\t\\t\\treturn (0, collateralNeeded - amountCollateral);\\n\\t\\t}\\n\\t}\\n\\n\\t/*** ERC20 ***/\\n\\t\\n\\tfunction _transfer(address from, address to, uint value) internal {\\n\\t\\trequire(tokensUnlocked(from, value), \\\"Impermax: INSUFFICIENT_LIQUIDITY\\\");\\n\\t\\tsuper._transfer(from, to, value);\\n\\t}\\n\\t\\n\\tfunction tokensUnlocked(address from, uint value) public returns (bool) {\\n\\t\\tuint _balance = balanceOf[from];\\n\\t\\tif (value > _balance) return false;\\n\\t\\tuint finalBalance = _balance - value;\\n\\t\\tuint amountCollateral = finalBalance.mul(exchangeRate()).div(1e18);\\n\\t\\tuint amount0 = IBorrowable(borrowable0).borrowBalance(from);\\n\\t\\tuint amount1 = IBorrowable(borrowable1).borrowBalance(from);\\n\\t\\t(, uint shortfall) = _calculateLiquidity(amountCollateral, amount0, amount1);\\n\\t\\treturn shortfall == 0;\\n\\t}\\n\\t\\n\\t/*** Collateral ***/\\n\\t\\n\\tfunction accountLiquidityAmounts(address borrower, uint amount0, uint amount1) public returns (uint liquidity, uint shortfall) {\\n\\t\\tif (amount0 == uint(-1)) amount0 = IBorrowable(borrowable0).borrowBalance(borrower);\\n\\t\\tif (amount1 == uint(-1)) amount1 = IBorrowable(borrowable1).borrowBalance(borrower);\\n\\t\\tuint amountCollateral = balanceOf[borrower].mul(exchangeRate()).div(1e18);\\n\\t\\treturn _calculateLiquidity(amountCollateral, amount0, amount1);\\n\\t}\\n\\t\\n\\tfunction accountLiquidity(address borrower) public returns (uint liquidity, uint shortfall) {\\n\\t\\treturn accountLiquidityAmounts(borrower, uint(-1), uint(-1));\\n\\t}\\n\\t\\n\\tfunction canBorrow(address borrower, address borrowable, uint accountBorrows) public returns (bool) {\\n\\t\\taddress _borrowable0 = borrowable0;\\n\\t\\taddress _borrowable1 = borrowable1;\\n\\t\\trequire(borrowable == _borrowable0 || borrowable == _borrowable1, \\\"Impermax: INVALID_BORROWABLE\\\" );\\n\\t\\tuint amount0 = borrowable == _borrowable0 ? accountBorrows : uint(-1);\\n\\t\\tuint amount1 = borrowable == _borrowable1 ? accountBorrows : uint(-1);\\n\\t\\t(, uint shortfall) = accountLiquidityAmounts(borrower, amount0, amount1);\\n\\t\\treturn shortfall == 0;\\n\\t}\\n\\t\\n\\t// this function must be called from borrowable0 or borrowable1\\n\\tfunction seize(address liquidator, address borrower, uint repayAmount) external returns (uint seizeTokens) {\\n\\t\\trequire(msg.sender == borrowable0 || msg.sender == borrowable1, \\\"Impermax: UNAUTHORIZED\\\");\\n\\t\\t\\n\\t\\t(, uint shortfall) = accountLiquidity(borrower);\\n\\t\\trequire(shortfall > 0, \\\"Impermax: INSUFFICIENT_SHORTFALL\\\");\\n\\t\\t\\n\\t\\tuint price;\\n\\t\\tif (msg.sender == borrowable0) (price, ) = getPrices();\\n\\t\\telse  (, price) = getPrices();\\n\\t\\t\\n\\t\\tseizeTokens = repayAmount.mul(liquidationIncentive).div(1e18).mul(price).div( exchangeRate() );\\n\\t\\t\\n\\t\\tbalanceOf[borrower] = balanceOf[borrower].sub(seizeTokens, \\\"Impermax: LIQUIDATING_TOO_MUCH\\\");\\n\\t\\tbalanceOf[liquidator] = balanceOf[liquidator].add(seizeTokens);\\n\\t\\temit Transfer(borrower, liquidator, seizeTokens);\\n\\t}\\n\\n\\t// this low-level function should be called from another contract\\n\\tfunction flashRedeem(address redeemer, uint redeemAmount, bytes calldata data) external nonReentrant update {\\n\\t\\trequire(redeemAmount <= totalBalance, \\\"Impermax: INSUFFICIENT_CASH\\\");\\n\\t\\t\\n\\t\\t// optimistically transfer funds\\n\\t\\t_safeTransfer(redeemer, redeemAmount);\\n\\t\\tif (data.length > 0) IImpermaxCallee(redeemer).impermaxRedeem(msg.sender, redeemAmount, data);\\n\\t\\t\\n\\t\\tuint redeemTokens = balanceOf[address(this)];\\n\\t\\tuint declaredRedeemTokens = redeemAmount.mul(1e18).div( exchangeRate() ).add(1); // rounded up\\n\\t\\trequire(redeemTokens >= declaredRedeemTokens, \\\"Impermax: INSUFFICIENT_REDEEM_TOKENS\\\");\\n\\t\\t\\n\\t\\t_burn(address(this), redeemTokens);\\n\\t\\temit Redeem(msg.sender, redeemer, redeemAmount, redeemTokens);\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/CStorage.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n\\ncontract CStorage {\\n\\taddress public borrowable0;\\n\\taddress public borrowable1;\\n\\taddress public simpleUniswapOracle;\\n\\tuint public safetyMarginSqrt = 1.58113883e18; //safetyMargin: 250%\\n\\tuint public liquidationIncentive = 1.04e18; //4%\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/CSetter.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./CStorage.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"./interfaces/ISimpleUniswapOracle.sol\\\";\\n\\ncontract CSetter is PoolToken, CStorage {\\n\\n\\tuint public constant SAFETY_MARGIN_SQRT_MIN = 1.00e18; //safetyMargin: 100%\\n\\tuint public constant SAFETY_MARGIN_SQRT_MAX = 1.58113884e18; //safetyMargin: 250%\\n\\tuint public constant LIQUIDATION_INCENTIVE_MIN = 1.00e18; //100%\\n\\tuint public constant LIQUIDATION_INCENTIVE_MAX = 1.05e18; //105%\\n\\n\\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\\n\\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\\n\\t\\n\\t// called once by the factory at the time of deployment\\n\\tfunction _initialize (\\n\\t\\tstring calldata _name,\\n\\t\\tstring calldata _symbol,\\n\\t\\taddress _underlying, \\n\\t\\taddress _borrowable0, \\n\\t\\taddress _borrowable1\\n\\t) external {\\n\\t\\trequire(msg.sender == factory, \\\"Impermax: UNAUTHORIZED\\\"); // sufficient check\\n\\t\\t_setName(_name, _symbol);\\n\\t\\tunderlying = _underlying;\\n\\t\\tborrowable0 = _borrowable0;\\n\\t\\tborrowable1 = _borrowable1;\\n\\t\\tsimpleUniswapOracle = IFactory(factory).simpleUniswapOracle();\\n\\t}\\n\\n\\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external nonReentrant {\\n\\t\\t_checkSetting(newSafetyMarginSqrt, SAFETY_MARGIN_SQRT_MIN, SAFETY_MARGIN_SQRT_MAX);\\n\\t\\tsafetyMarginSqrt = newSafetyMarginSqrt;\\n\\t\\temit NewSafetyMargin(newSafetyMarginSqrt);\\n\\t}\\n\\n\\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external nonReentrant {\\n\\t\\t_checkSetting(newLiquidationIncentive, LIQUIDATION_INCENTIVE_MIN, LIQUIDATION_INCENTIVE_MAX);\\n\\t\\tliquidationIncentive = newLiquidationIncentive;\\n\\t\\temit NewLiquidationIncentive(newLiquidationIncentive);\\n\\t}\\n\\t\\n\\tfunction _checkSetting(uint parameter, uint min, uint max) internal view {\\n\\t\\t_checkAdmin();\\n\\t\\trequire(parameter >= min, \\\"Impermax: INVALID_SETTING\\\");\\n\\t\\trequire(parameter <= max, \\\"Impermax: INVALID_SETTING\\\");\\n\\t}\\n\\t\\n\\tfunction _checkAdmin() internal view {\\n\\t\\trequire(msg.sender == IFactory(factory).admin(), \\\"Impermax: UNAUTHORIZED\\\");\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IFactory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IFactory {\\n\\tevent LendingPoolInitialized(address indexed uniswapV2Pair, address indexed token0, address indexed token1,\\n\\t\\taddress collateral, address borrowable0, address borrowable1, uint lendingPoolId);\\n\\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\tevent NewAdmin(address oldAdmin, address newAdmin);\\n\\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\\n\\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\\n\\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\\n\\t\\n\\tfunction admin() external view returns (address);\\n\\tfunction pendingAdmin() external view returns (address);\\n\\tfunction reservesAdmin() external view returns (address);\\n\\tfunction reservesPendingAdmin() external view returns (address);\\n\\tfunction reservesManager() external view returns (address);\\n\\n\\tfunction getLendingPool(address uniswapV2Pair) external view returns (\\n\\t\\tbool initialized, \\n\\t\\tuint24 lendingPoolId, \\n\\t\\taddress collateral, \\n\\t\\taddress borrowable0, \\n\\t\\taddress borrowable1\\n\\t);\\n\\tfunction allLendingPools(uint) external view returns (address uniswapV2Pair);\\n\\tfunction allLendingPoolsLength() external view returns (uint);\\n\\t\\n\\tfunction bDeployer() external view returns (address);\\n\\tfunction cDeployer() external view returns (address);\\n\\tfunction simpleUniswapOracle() external view returns (address);\\n\\n\\tfunction createCollateral(address uniswapV2Pair) external returns (address collateral);\\n\\tfunction createBorrowable0(address uniswapV2Pair) external returns (address borrowable0);\\n\\tfunction createBorrowable1(address uniswapV2Pair) external returns (address borrowable1);\\n\\tfunction initializeLendingPool(address uniswapV2Pair) external;\\n\\n\\tfunction _setPendingAdmin(address newPendingAdmin) external;\\n\\tfunction _acceptAdmin() external;\\n\\tfunction _setReservesPendingAdmin(address newPendingAdmin) external;\\n\\tfunction _acceptReservesAdmin() external;\\n\\tfunction _setReservesManager(address newReservesManager) external;\\n}\\n\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/ISimpleUniswapOracle.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ISimpleUniswapOracle {\\n\\tevent PriceUpdate(address indexed pair, uint256 priceCumulative, uint32 blockTimestamp, bool lastIsA);\\n\\tfunction MIN_T() external pure returns (uint32);\\n\\tfunction getBlockTimestamp() external view returns (uint32);\\n\\tfunction getPair(address uniswapV2Pair) external view returns (\\n\\t\\tuint256 priceCumulativeA,\\n\\t\\tuint256 priceCumulativeB,\\n\\t\\tuint32 updateA,\\n\\t\\tuint32 updateB,\\n\\t\\tbool lastIsA,\\n\\t\\tbool initialized\\n\\t);\\n\\tfunction initialize(address uniswapV2Pair) external;\\n\\tfunction getResult(address uniswapV2Pair) external returns (uint224 price, uint32 T);\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IBorrowable.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBorrowable {\\n\\n\\t/*** Impermax ERC20 ***/\\n\\t\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\n\\t\\n\\tfunction name() external pure returns (string memory);\\n\\tfunction symbol() external pure returns (string memory);\\n\\tfunction decimals() external pure returns (uint8);\\n\\tfunction totalSupply() external view returns (uint);\\n\\tfunction balanceOf(address owner) external view returns (uint);\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\n\\tfunction approve(address spender, uint value) external returns (bool);\\n\\tfunction transfer(address to, uint value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\n\\t\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\tfunction nonces(address owner) external view returns (uint);\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\t\\n\\t/*** Pool Token ***/\\n\\t\\n\\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\\n\\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\\n\\tevent Sync(uint totalBalance);\\n\\t\\n\\tfunction underlying() external view returns (address);\\n\\tfunction factory() external view returns (address);\\n\\tfunction totalBalance() external view returns (uint);\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n\\tfunction exchangeRate() external returns (uint);\\n\\tfunction mint(address minter) external returns (uint mintTokens);\\n\\tfunction redeem(address redeemer) external returns (uint redeemAmount);\\n\\tfunction skim(address to) external;\\n\\tfunction sync() external;\\n\\t\\n\\tfunction _setFactory() external;\\n\\t\\n\\t/*** Borrowable ***/\\n\\n\\tevent BorrowApproval(address indexed owner, address indexed spender, uint value);\\n\\tevent Borrow(address indexed sender, address indexed borrower, address indexed receiver, uint borrowAmount, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\\n\\tevent Liquidate(address indexed sender, address indexed borrower, address indexed liquidator, uint seizeTokens, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\\n\\t\\n\\tfunction BORROW_FEE() external pure returns (uint);\\n\\tfunction collateral() external view returns (address);\\n\\tfunction reserveFactor() external view returns (uint);\\n\\tfunction exchangeRateLast() external view returns (uint);\\n\\tfunction borrowIndex() external view returns (uint);\\n\\tfunction totalBorrows() external view returns (uint);\\n\\tfunction borrowAllowance(address owner, address spender) external view returns (uint);\\n\\tfunction borrowBalance(address borrower) external view returns (uint);\\t\\n\\tfunction borrowTracker() external view returns (address);\\n\\t\\n\\tfunction BORROW_PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\tfunction borrowApprove(address spender, uint256 value) external returns (bool);\\n\\tfunction borrowPermit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\tfunction borrow(address borrower, address receiver, uint borrowAmount, bytes calldata data) external;\\n\\tfunction liquidate(address borrower, address liquidator) external returns (uint seizeTokens);\\n\\tfunction trackBorrow(address borrower) external;\\n\\t\\n\\t/*** Borrowable Interest Rate Model ***/\\n\\n\\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\tevent CalculateKink(uint kinkRate);\\n\\tevent CalculateBorrowRate(uint borrowRate);\\n\\t\\n\\tfunction KINK_BORROW_RATE_MAX() external pure returns (uint);\\n\\tfunction KINK_BORROW_RATE_MIN() external pure returns (uint);\\n\\tfunction KINK_MULTIPLIER() external pure returns (uint);\\n\\tfunction borrowRate() external view returns (uint);\\n\\tfunction kinkBorrowRate() external view returns (uint);\\n\\tfunction kinkUtilizationRate() external view returns (uint);\\n\\tfunction adjustSpeed() external view returns (uint);\\n\\tfunction rateUpdateTimestamp() external view returns (uint32);\\n\\tfunction accrualTimestamp() external view returns (uint32);\\n\\t\\n\\tfunction accrueInterest() external;\\n\\t\\n\\t/*** Borrowable Setter ***/\\n\\n\\tevent NewReserveFactor(uint newReserveFactor);\\n\\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\\n\\tevent NewAdjustSpeed(uint newAdjustSpeed);\\n\\tevent NewBorrowTracker(address newBorrowTracker);\\n\\n\\tfunction RESERVE_FACTOR_MAX() external pure returns (uint);\\n\\tfunction KINK_UR_MIN() external pure returns (uint);\\n\\tfunction KINK_UR_MAX() external pure returns (uint);\\n\\tfunction ADJUST_SPEED_MIN() external pure returns (uint);\\n\\tfunction ADJUST_SPEED_MAX() external pure returns (uint);\\n\\t\\n\\tfunction _initialize (\\n\\t\\tstring calldata _name, \\n\\t\\tstring calldata _symbol,\\n\\t\\taddress _underlying, \\n\\t\\taddress _collateral\\n\\t) external;\\n\\tfunction _setReserveFactor(uint newReserveFactor) external;\\n\\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external;\\n\\tfunction _setAdjustSpeed(uint newAdjustSpeed) external;\\n\\tfunction _setBorrowTracker(address newBorrowTracker) external;\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/ICollateral.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ICollateral {\\n\\n\\t/*** Impermax ERC20 ***/\\n\\t\\n\\tevent Transfer(address indexed from, address indexed to, uint value);\\n\\tevent Approval(address indexed owner, address indexed spender, uint value);\\n\\t\\n\\tfunction name() external pure returns (string memory);\\n\\tfunction symbol() external pure returns (string memory);\\n\\tfunction decimals() external pure returns (uint8);\\n\\tfunction totalSupply() external view returns (uint);\\n\\tfunction balanceOf(address owner) external view returns (uint);\\n\\tfunction allowance(address owner, address spender) external view returns (uint);\\n\\tfunction approve(address spender, uint value) external returns (bool);\\n\\tfunction transfer(address to, uint value) external returns (bool);\\n\\tfunction transferFrom(address from, address to, uint value) external returns (bool);\\n\\t\\n\\tfunction DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\tfunction PERMIT_TYPEHASH() external pure returns (bytes32);\\n\\tfunction nonces(address owner) external view returns (uint);\\n\\tfunction permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\t\\n\\t/*** Pool Token ***/\\n\\t\\n\\tevent Mint(address indexed sender, address indexed minter, uint mintAmount, uint mintTokens);\\n\\tevent Redeem(address indexed sender, address indexed redeemer, uint redeemAmount, uint redeemTokens);\\n\\tevent Sync(uint totalBalance);\\n\\t\\n\\tfunction underlying() external view returns (address);\\n\\tfunction factory() external view returns (address);\\n\\tfunction totalBalance() external view returns (uint);\\n\\tfunction MINIMUM_LIQUIDITY() external pure returns (uint);\\n\\n\\tfunction exchangeRate() external returns (uint);\\n\\tfunction mint(address minter) external returns (uint mintTokens);\\n\\tfunction redeem(address redeemer) external returns (uint redeemAmount);\\n\\tfunction skim(address to) external;\\n\\tfunction sync() external;\\n\\t\\n\\tfunction _setFactory() external;\\n\\t\\n\\t/*** Collateral ***/\\n\\t\\n\\tfunction borrowable0() external view returns (address);\\n\\tfunction borrowable1() external view returns (address);\\n\\tfunction simpleUniswapOracle() external view returns (address);\\n\\tfunction safetyMarginSqrt() external view returns (uint);\\n\\tfunction liquidationIncentive() external view returns (uint);\\n\\t\\n\\tfunction getPrices() external returns (uint price0, uint price1);\\n\\tfunction tokensUnlocked(address from, uint value) external returns (bool);\\n\\tfunction accountLiquidityAmounts(address account, uint amount0, uint amount1) external returns (uint liquidity, uint shortfall);\\n\\tfunction accountLiquidity(address account) external returns (uint liquidity, uint shortfall);\\n\\tfunction canBorrow(address account, address borrowable, uint accountBorrows) external returns (bool);\\n\\tfunction seize(address liquidator, address borrower, uint repayAmount) external returns (uint seizeTokens);\\n\\tfunction flashRedeem(address redeemer, uint redeemAmount, bytes calldata data) external;\\n\\t\\n\\t/*** Collateral Setter ***/\\n\\t\\n\\tevent NewSafetyMargin(uint newSafetyMarginSqrt);\\n\\tevent NewLiquidationIncentive(uint newLiquidationIncentive);\\n\\n\\tfunction SAFETY_MARGIN_SQRT_MIN() external pure returns (uint);\\n\\tfunction SAFETY_MARGIN_SQRT_MAX() external pure returns (uint);\\n\\tfunction LIQUIDATION_INCENTIVE_MIN() external pure returns (uint);\\n\\tfunction LIQUIDATION_INCENTIVE_MAX() external pure returns (uint);\\n\\t\\n\\tfunction _initialize (\\n\\t\\tstring calldata _name, \\n\\t\\tstring calldata _symbol,\\n\\t\\taddress _underlying, \\n\\t\\taddress _borrowable0, \\n\\t\\taddress _borrowable1\\n\\t) external;\\n\\tfunction _setSafetyMarginSqrt(uint newSafetyMarginSqrt) external;\\n\\tfunction _setLiquidationIncentive(uint newLiquidationIncentive) external;\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IImpermaxCallee.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IImpermaxCallee {\\n    function impermaxBorrow(address sender, address borrower, uint borrowAmount, bytes calldata data) external;\\n    function impermaxRedeem(address sender, uint redeemAmount, bytes calldata data) external;\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function decimals() external view returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\t\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n\\n    function price0CumulativeLast() external view returns (uint);\\n}\\n\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/libraries/UQ112x112.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\\n// src: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/UQ112x112.sol\\n\\n// range: [0, 2**112 - 1]\\n// resolution: 1 / 2**112\\n\\nlibrary UQ112x112 {\\n    uint224 constant Q112 = 2**112;\\n\\n    // encode a uint112 as a UQ112x112\\n    function encode(uint112 y) internal pure returns (uint224 z) {\\n        z = uint224(y) * Q112; // never overflows\\n    }\\n\\n    // divide a UQ112x112 by a uint112, returning a UQ112x112\\n    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {\\n        z = x / uint224(y);\\n    }\\n}\\n\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/libraries/Math.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\n// a library for performing various math operations\\n// forked from: https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/libraries/Math.sol\\n\\nlibrary Math {\\n    function min(uint x, uint y) internal pure returns (uint z) {\\n        z = x < y ? x : y;\\n    }\\n\\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\n    function sqrt(uint y) internal pure returns (uint z) {\\n        if (y > 3) {\\n            z = y;\\n            uint x = y / 2 + 1;\\n            while (x < z) {\\n                z = x;\\n                x = (y / x + x) / 2;\\n            }\\n        } else if (y != 0) {\\n            z = 1;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/ICDeployer.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface ICDeployer {\\n\\tfunction deployCollateral(address uniswapV2Pair) external returns (address collateral);\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/BSetter.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./BStorage.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\n\\ncontract BSetter is PoolToken, BStorage {\\n\\n\\tuint public constant RESERVE_FACTOR_MAX = 0.20e18; //20%\\n\\tuint public constant KINK_UR_MIN = 0.50e18; //50%\\n\\tuint public constant KINK_UR_MAX = 0.99e18; //99%\\n\\tuint public constant ADJUST_SPEED_MIN = 0.05787037e12; //0.5% per day\\n\\tuint public constant ADJUST_SPEED_MAX = 5.787037e12; //50% per day\\n\\n\\tevent NewReserveFactor(uint newReserveFactor);\\n\\tevent NewKinkUtilizationRate(uint newKinkUtilizationRate);\\n\\tevent NewAdjustSpeed(uint newAdjustSpeed);\\n\\tevent NewBorrowTracker(address newBorrowTracker);\\n\\t\\n\\t// called once by the factory at time of deployment\\n\\tfunction _initialize (\\n\\t\\tstring calldata _name, \\n\\t\\tstring calldata _symbol,\\n\\t\\taddress _underlying, \\n\\t\\taddress _collateral\\n\\t) external {\\n\\t\\trequire(msg.sender == factory, \\\"Impermax: UNAUTHORIZED\\\"); // sufficient check\\n\\t\\t_setName(_name, _symbol);\\n\\t\\tunderlying = _underlying;\\n\\t\\tcollateral = _collateral;\\n\\t\\texchangeRateLast = initialExchangeRate;\\n\\t}\\n\\t\\n\\tfunction _setReserveFactor(uint newReserveFactor) external nonReentrant {\\n\\t\\t_checkSetting(newReserveFactor, 0, RESERVE_FACTOR_MAX);\\n\\t\\treserveFactor = newReserveFactor;\\n\\t\\temit NewReserveFactor(newReserveFactor);\\n\\t}\\n\\n\\tfunction _setKinkUtilizationRate(uint newKinkUtilizationRate) external nonReentrant {\\n\\t\\t_checkSetting(newKinkUtilizationRate, KINK_UR_MIN, KINK_UR_MAX);\\n\\t\\tkinkUtilizationRate = newKinkUtilizationRate;\\n\\t\\temit NewKinkUtilizationRate(newKinkUtilizationRate);\\n\\t}\\n\\n\\tfunction _setAdjustSpeed(uint newAdjustSpeed) external nonReentrant {\\n\\t\\t_checkSetting(newAdjustSpeed, ADJUST_SPEED_MIN, ADJUST_SPEED_MAX);\\n\\t\\tadjustSpeed = newAdjustSpeed;\\n\\t\\temit NewAdjustSpeed(newAdjustSpeed);\\n\\t}\\n\\n\\tfunction _setBorrowTracker(address newBorrowTracker) external nonReentrant {\\n\\t\\t_checkAdmin();\\n\\t\\tborrowTracker = newBorrowTracker;\\n\\t\\temit NewBorrowTracker(newBorrowTracker);\\n\\t}\\n\\t\\n\\tfunction _checkSetting(uint parameter, uint min, uint max) internal view {\\n\\t\\t_checkAdmin();\\n\\t\\trequire(parameter >= min, \\\"Impermax: INVALID_SETTING\\\");\\n\\t\\trequire(parameter <= max, \\\"Impermax: INVALID_SETTING\\\");\\n\\t}\\n\\t\\n\\tfunction _checkAdmin() internal view {\\n\\t\\trequire(msg.sender == IFactory(factory).admin(), \\\"Impermax: UNAUTHORIZED\\\");\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/Borrowable.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./PoolToken.sol\\\";\\nimport \\\"./BAllowance.sol\\\";\\nimport \\\"./BInterestRateModel.sol\\\";\\nimport \\\"./BSetter.sol\\\";\\nimport \\\"./BStorage.sol\\\";\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\nimport \\\"./interfaces/ICollateral.sol\\\";\\nimport \\\"./interfaces/IImpermaxCallee.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"./interfaces/IBorrowTracker.sol\\\";\\nimport \\\"./libraries/Math.sol\\\";\\n\\ncontract Borrowable is IBorrowable, PoolToken, BStorage, BSetter, BInterestRateModel, BAllowance {\\n\\n\\tuint public constant BORROW_FEE = 0.001e18; //0.1%\\n\\n\\tevent Borrow(address indexed sender, address indexed borrower, address indexed receiver, uint borrowAmount, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\\n\\tevent Liquidate(address indexed sender, address indexed borrower, address indexed liquidator, uint seizeTokens, uint repayAmount, uint accountBorrowsPrior, uint accountBorrows, uint totalBorrows);\\n\\t\\t\\n\\tconstructor() public {}\\n\\n\\t/*** PoolToken ***/\\n\\t\\n\\tfunction _update() internal {\\n\\t\\tsuper._update();\\n\\t\\t_calculateBorrowRate();\\n\\t}\\n\\t\\n\\tfunction _mintReserves(uint _exchangeRate, uint _totalSupply) internal returns (uint) {\\n\\t\\tuint _exchangeRateLast = exchangeRateLast;\\n\\t\\tif (_exchangeRate > _exchangeRateLast) {\\n\\t\\t\\tuint _exchangeRateNew = _exchangeRate.sub( _exchangeRate.sub(_exchangeRateLast).mul(reserveFactor).div(1e18) );\\n\\t\\t\\tuint liquidity = _totalSupply.mul(_exchangeRate).div(_exchangeRateNew).sub(_totalSupply);\\n\\t\\t\\tif (liquidity == 0) return _exchangeRate;\\n\\t\\t\\taddress reservesManager = IFactory(factory).reservesManager();\\n\\t\\t\\t_mint(reservesManager, liquidity);\\n\\t\\t\\texchangeRateLast = _exchangeRateNew;\\n\\t\\t\\treturn _exchangeRateNew;\\n\\t\\t}\\n\\t\\telse return _exchangeRate;\\n\\t}\\n\\t\\n\\tfunction exchangeRate() public accrue returns (uint)\\t{\\n\\t\\tuint _totalSupply = totalSupply;\\n\\t\\tuint _actualBalance = totalBalance.add(totalBorrows);\\n\\t\\tif (_totalSupply == 0 || _actualBalance == 0) return initialExchangeRate;\\n\\t\\tuint _exchangeRate = _actualBalance.mul(1e18).div(_totalSupply);\\n\\t\\treturn _mintReserves(_exchangeRate, _totalSupply);\\n\\t}\\n\\t\\n\\t// force totalBalance to match real balance\\n\\tfunction sync() external nonReentrant update accrue {}\\n\\t\\n\\t/*** Borrowable ***/\\n\\n\\t// this is the stored borrow balance; the current borrow balance may be slightly higher\\n\\tfunction borrowBalance(address borrower) public view returns (uint) {\\n\\t\\tBorrowSnapshot memory borrowSnapshot = borrowBalances[borrower];\\n\\t\\tif (borrowSnapshot.interestIndex == 0) return 0; // not initialized\\n\\t\\treturn uint(borrowSnapshot.principal).mul(borrowIndex).div(borrowSnapshot.interestIndex);\\n\\t}\\n\\t\\n\\tfunction _trackBorrow(address borrower, uint accountBorrows, uint _borrowIndex) internal {\\n\\t\\taddress _borrowTracker = borrowTracker;\\n\\t\\tif (_borrowTracker == address(0)) return;\\n\\t\\tIBorrowTracker(_borrowTracker).trackBorrow(borrower, accountBorrows, _borrowIndex);\\n\\t}\\n\\t\\n\\tfunction _updateBorrow(address borrower, uint borrowAmount, uint repayAmount) private returns (uint accountBorrowsPrior, uint accountBorrows, uint _totalBorrows) {\\n\\t\\taccountBorrowsPrior = borrowBalance(borrower);\\n\\t\\tif (borrowAmount == repayAmount) return (accountBorrowsPrior, accountBorrowsPrior, totalBorrows);\\n\\t\\tuint112 _borrowIndex = borrowIndex;\\n\\t\\tif (borrowAmount > repayAmount) {\\n\\t\\t\\tBorrowSnapshot storage borrowSnapshot = borrowBalances[borrower];\\n\\t\\t\\tuint increaseAmount = borrowAmount - repayAmount;\\n\\t\\t\\taccountBorrows = accountBorrowsPrior.add(increaseAmount);\\n\\t\\t\\tborrowSnapshot.principal = safe112(accountBorrows);\\n\\t\\t\\tborrowSnapshot.interestIndex = _borrowIndex;\\n\\t\\t\\t_totalBorrows = uint(totalBorrows).add(increaseAmount);\\t\\n\\t\\t\\ttotalBorrows = safe112(_totalBorrows);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tBorrowSnapshot storage borrowSnapshot = borrowBalances[borrower];\\n\\t\\t\\tuint decreaseAmount = repayAmount - borrowAmount;\\t\\t\\n\\t\\t\\taccountBorrows = accountBorrowsPrior > decreaseAmount ? accountBorrowsPrior - decreaseAmount : 0;\\n\\t\\t\\tborrowSnapshot.principal = safe112(accountBorrows);\\n\\t\\t\\tif(accountBorrows == 0) {\\n\\t\\t\\t\\tborrowSnapshot.interestIndex = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tborrowSnapshot.interestIndex = _borrowIndex;\\n\\t\\t\\t}\\n\\t\\t\\tuint actualDecreaseAmount = accountBorrowsPrior.sub(accountBorrows);\\n\\t\\t\\t_totalBorrows = totalBorrows; // gas savings\\n\\t\\t\\t_totalBorrows = _totalBorrows > actualDecreaseAmount ? _totalBorrows - actualDecreaseAmount : 0;\\n\\t\\t\\ttotalBorrows = safe112(_totalBorrows);\\t\\t\\t\\n\\t\\t}\\n\\t\\t_trackBorrow(borrower, accountBorrows, _borrowIndex);\\n\\t}\\n\\t\\n\\t// this low-level function should be called from another contract\\n\\tfunction borrow(address borrower, address receiver, uint borrowAmount, bytes calldata data) external nonReentrant update accrue {\\t\\t\\n\\t\\tuint _totalBalance = totalBalance;\\n\\t\\trequire(borrowAmount <= _totalBalance, \\\"Impermax: INSUFFICIENT_CASH\\\");\\n\\t\\t_checkBorrowAllowance(borrower, msg.sender, borrowAmount);\\n\\t\\t\\n\\t\\t// optimistically transfer funds\\n\\t\\tif (borrowAmount > 0) _safeTransfer(receiver, borrowAmount);\\n\\t\\tif (data.length > 0) IImpermaxCallee(receiver).impermaxBorrow(msg.sender, borrower, borrowAmount, data);\\n\\t\\tuint balance = IERC20(underlying).balanceOf(address(this));\\n\\t\\t\\n\\t\\tuint borrowFee = borrowAmount.mul(BORROW_FEE).div(1e18);\\n\\t\\tuint adjustedBorrowAmount = borrowAmount.add(borrowFee);\\n\\t\\tuint repayAmount = balance.add(borrowAmount).sub(_totalBalance);\\n\\t\\t(uint accountBorrowsPrior, uint accountBorrows, uint _totalBorrows) = _updateBorrow(borrower, adjustedBorrowAmount, repayAmount);\\n\\t\\t\\n\\t\\tif(adjustedBorrowAmount > repayAmount) require(\\n\\t\\t\\tICollateral(collateral).canBorrow(borrower, address(this), accountBorrows),\\n\\t\\t\\t\\\"Impermax: INSUFFICIENT_LIQUIDITY\\\"\\n\\t\\t);\\n\\t\\t\\n\\t\\temit Borrow(msg.sender, borrower, receiver, borrowAmount, repayAmount, accountBorrowsPrior, accountBorrows, _totalBorrows);\\n\\t}\\n\\n\\t// this low-level function should be called from another contract\\n\\tfunction liquidate(address borrower, address liquidator) external nonReentrant update accrue returns (uint seizeTokens) {\\n\\t\\tuint balance = IERC20(underlying).balanceOf(address(this));\\n\\t\\tuint repayAmount = balance.sub(totalBalance);\\t\\t\\n\\t\\t\\n\\t\\tuint actualRepayAmount = Math.min(borrowBalance(borrower), repayAmount);\\n\\t\\tseizeTokens = ICollateral(collateral).seize(liquidator, borrower, actualRepayAmount);\\t\\n\\t\\t(uint accountBorrowsPrior, uint accountBorrows, uint _totalBorrows) = _updateBorrow(borrower, 0, repayAmount);\\n\\t\\t\\n\\t\\temit Liquidate(msg.sender, borrower, liquidator, seizeTokens, repayAmount, accountBorrowsPrior, accountBorrows, _totalBorrows);\\n\\t}\\n\\t\\n\\tfunction trackBorrow(address borrower) external {\\n\\t\\t_trackBorrow(borrower, borrowBalance(borrower), borrowIndex);\\n\\t}\\n\\t\\n\\tmodifier accrue() {\\n\\t\\taccrueInterest();\\n\\t\\t_;\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/BInterestRateModel.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./BStorage.sol\\\";\\nimport \\\"./PoolToken.sol\\\";\\n\\ncontract BInterestRateModel is PoolToken, BStorage {\\n\\n\\t// When utilization is 100% borrowRate is kinkBorrowRate * KINK_MULTIPLIER\\n\\t// kinkBorrowRate relative adjustment per second belongs to [1-adjustSpeed, 1+adjustSpeed*(KINK_MULTIPLIER-1)]\\n\\tuint public constant KINK_MULTIPLIER = 5;\\n\\tuint public constant KINK_BORROW_RATE_MAX = 31.7097920e9; //100% per year\\n\\tuint public constant KINK_BORROW_RATE_MIN = 0.31709792e9; //1% per year\\n\\n\\tevent AccrueInterest(uint interestAccumulated, uint borrowIndex, uint totalBorrows);\\n\\tevent CalculateKinkBorrowRate(uint kinkBorrowRate);\\n\\tevent CalculateBorrowRate(uint borrowRate);\\n\\t\\t\\n\\tfunction _calculateBorrowRate() internal {\\n\\t\\tuint _kinkUtilizationRate = kinkUtilizationRate;\\t\\t\\n\\t\\tuint _adjustSpeed = adjustSpeed;\\n\\t\\tuint _borrowRate = borrowRate;\\t\\n\\t\\tuint _kinkBorrowRate = kinkBorrowRate;\\n\\t\\tuint32 _rateUpdateTimestamp = rateUpdateTimestamp;\\t\\t\\n\\t\\n\\t\\t// update kinkBorrowRate using previous borrowRate\\n\\t\\tuint32 timeElapsed = getBlockTimestamp() - _rateUpdateTimestamp; // underflow is desired\\n\\t\\tif(timeElapsed > 0) {\\n\\t\\t\\trateUpdateTimestamp = getBlockTimestamp();\\n\\t\\t\\tuint adjustFactor;\\n\\t\\t\\t\\n\\t\\t\\tif (_borrowRate < _kinkBorrowRate) {\\n\\t\\t\\t\\t// never overflows, _kinkBorrowRate is never 0\\n\\t\\t\\t\\tuint tmp = (_kinkBorrowRate - _borrowRate) * 1e18 / _kinkBorrowRate * _adjustSpeed * timeElapsed / 1e18;\\n\\t\\t\\t\\tadjustFactor = tmp > 1e18 ? 0 : 1e18 - tmp;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\t// never overflows, _kinkBorrowRate is never 0\\n\\t\\t\\t\\tuint tmp = (_borrowRate - _kinkBorrowRate) * 1e18 / _kinkBorrowRate * _adjustSpeed * timeElapsed / 1e18;\\n\\t\\t\\t\\tadjustFactor = tmp + 1e18;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\t// never overflows\\n\\t\\t\\t_kinkBorrowRate = _kinkBorrowRate * adjustFactor / 1e18;\\n\\t\\t\\tif(_kinkBorrowRate > KINK_BORROW_RATE_MAX) _kinkBorrowRate = KINK_BORROW_RATE_MAX;\\n\\t\\t\\tif(_kinkBorrowRate < KINK_BORROW_RATE_MIN) _kinkBorrowRate = KINK_BORROW_RATE_MIN;\\n\\n\\t\\t\\tkinkBorrowRate = uint48(_kinkBorrowRate);\\n\\t\\t\\temit CalculateKinkBorrowRate(_kinkBorrowRate);\\n\\t\\t}\\n\\t\\t\\n\\t\\tuint _utilizationRate;\\n\\t\\t{ // avoid stack to deep\\n\\t\\tuint _totalBorrows = totalBorrows; // gas savings\\n\\t\\tuint _actualBalance = totalBalance.add(_totalBorrows);\\n\\t\\t_utilizationRate = (_actualBalance == 0) ? 0 : _totalBorrows * 1e18 / _actualBalance;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// update borrowRate using the new kinkBorrowRate\\t\\n\\t\\tif(_utilizationRate <= _kinkUtilizationRate) {\\n\\t\\t\\t// never overflows, _kinkUtilizationRate is never 0\\n\\t\\t\\t_borrowRate = _kinkBorrowRate * _utilizationRate / _kinkUtilizationRate;\\n\\t\\t} else {\\n\\t\\t\\t// never overflows, _kinkUtilizationRate is always < 1e18\\n\\t\\t\\tuint overUtilization = (_utilizationRate - _kinkUtilizationRate) * 1e18 / (1e18 - _kinkUtilizationRate);\\n\\t\\t\\t// never overflows\\n\\t\\t\\t_borrowRate = ((KINK_MULTIPLIER - 1) * overUtilization + 1e18) * _kinkBorrowRate / 1e18;\\n\\t\\t}\\n\\t\\tborrowRate = uint48(_borrowRate);\\n\\t\\temit CalculateBorrowRate(_borrowRate);\\n\\t}\\n\\t\\n\\t// applies accrued interest to total borrows and reserves\\n\\tfunction accrueInterest() public {\\n\\t\\tuint _borrowIndex = borrowIndex;\\n\\t\\tuint _totalBorrows = totalBorrows;\\n\\t\\tuint32 _accrualTimestamp = accrualTimestamp;\\n\\t\\t\\n\\t\\tuint32 blockTimestamp = getBlockTimestamp();\\n\\t\\tif (_accrualTimestamp == blockTimestamp) return;\\n\\t\\tuint32 timeElapsed = blockTimestamp - _accrualTimestamp; // underflow is desired\\n\\t\\taccrualTimestamp = blockTimestamp;\\n\\t\\t\\n\\t\\tuint interestFactor = uint(borrowRate).mul(timeElapsed);\\t\\n\\t\\tuint interestAccumulated = interestFactor.mul(_totalBorrows).div(1e18);\\n\\t\\t_totalBorrows = _totalBorrows.add( interestAccumulated );\\n\\t\\t_borrowIndex = _borrowIndex.add( interestFactor.mul(_borrowIndex).div(1e18) );\\n\\t\\n\\t\\tborrowIndex = safe112(_borrowIndex);\\n\\t\\ttotalBorrows = safe112(_totalBorrows);\\n\\t\\temit AccrueInterest(interestAccumulated, _borrowIndex, _totalBorrows);\\n\\t}\\n\\t\\t\\n\\tfunction getBlockTimestamp() public view returns (uint32) {\\n\\t\\treturn uint32(block.timestamp % 2**32);\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IBorrowTracker.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBorrowTracker {\\n\\tfunction trackBorrow(address borrower, uint borrowBalance, uint borrowIndex) external;\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/BDeployer.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./Borrowable.sol\\\";\\nimport \\\"./interfaces/IBDeployer.sol\\\";\\n\\n/*\\n * This contract is used by the Factory to deploy Borrowable(s)\\n * The bytecode would be too long to fit in the Factory\\n */\\n\\ncontract BDeployer is IBDeployer {\\n\\tconstructor () public {}\\n\\t\\n\\tfunction deployBorrowable(address uniswapV2Pair, uint8 index) external returns (address borrowable) {\\n\\t\\tbytes memory bytecode = type(Borrowable).creationCode;\\n\\t\\tbytes32 salt = keccak256(abi.encodePacked(msg.sender, uniswapV2Pair, index));\\n\\t\\tassembly {\\n\\t\\t\\tborrowable := create2(0, add(bytecode, 32), mload(bytecode), salt)\\n\\t\\t}\\n\\t}\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IBDeployer.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IBDeployer {\\n\\tfunction deployBorrowable(address uniswapV2Pair, uint8 index) external returns (address borrowable);\\n}\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/Factory.sol\": {\r\n      \"content\": \"pragma solidity =0.5.16;\\n\\nimport \\\"./interfaces/IFactory.sol\\\";\\nimport \\\"./interfaces/IBDeployer.sol\\\";\\nimport \\\"./interfaces/IBorrowable.sol\\\";\\nimport \\\"./interfaces/ICDeployer.sol\\\";\\nimport \\\"./interfaces/ICollateral.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"./interfaces/ISimpleUniswapOracle.sol\\\";\\n\\ncontract Factory is IFactory {\\n\\taddress public admin;\\n\\taddress public pendingAdmin;\\n\\taddress public reservesAdmin;\\n\\taddress public reservesPendingAdmin;\\n\\taddress public reservesManager;\\n\\t\\t\\n\\tstruct LendingPool {\\n\\t\\tbool initialized;\\n\\t\\tuint24 lendingPoolId;\\n\\t\\taddress collateral;\\n\\t\\taddress borrowable0;\\n\\t\\taddress borrowable1;\\n\\t}\\n\\tmapping(address => LendingPool) public getLendingPool; // get by UniswapV2Pair\\n\\taddress[] public allLendingPools; // address of the UniswapV2Pair\\n\\tfunction allLendingPoolsLength() external view returns (uint) {\\n\\t\\treturn allLendingPools.length;\\n\\t}\\n\\t\\n\\tIBDeployer public bDeployer;\\n\\tICDeployer public cDeployer;\\n\\tISimpleUniswapOracle public simpleUniswapOracle;\\n\\t\\n\\tevent LendingPoolInitialized(address indexed uniswapV2Pair, address indexed token0, address indexed token1,\\n\\t\\taddress collateral, address borrowable0, address borrowable1, uint lendingPoolId);\\n\\tevent NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\\n\\tevent NewAdmin(address oldAdmin, address newAdmin);\\n\\tevent NewReservesPendingAdmin(address oldReservesPendingAdmin, address newReservesPendingAdmin);\\n\\tevent NewReservesAdmin(address oldReservesAdmin, address newReservesAdmin);\\n\\tevent NewReservesManager(address oldReservesManager, address newReservesManager);\\n\\t\\n\\tconstructor(address _admin, address _reservesAdmin, IBDeployer _bDeployer, ICDeployer _cDeployer, ISimpleUniswapOracle _simpleUniswapOracle) public {\\n\\t\\tadmin = _admin;\\n\\t\\treservesAdmin = _reservesAdmin;\\n\\t\\tbDeployer = _bDeployer;\\n\\t\\tcDeployer = _cDeployer;\\n\\t\\tsimpleUniswapOracle = _simpleUniswapOracle;\\n\\t\\temit NewAdmin(address(0), _admin);\\n\\t\\temit NewReservesAdmin(address(0), _reservesAdmin);\\n\\t}\\n\\t\\n\\tfunction _getTokens(address uniswapV2Pair) private view returns (address token0, address token1) {\\n\\t\\ttoken0 = IUniswapV2Pair(uniswapV2Pair).token0();\\n\\t\\ttoken1 = IUniswapV2Pair(uniswapV2Pair).token1();\\n\\t}\\n\\t\\n\\tfunction _createLendingPool(address uniswapV2Pair) private {\\n\\t\\tif (getLendingPool[uniswapV2Pair].lendingPoolId != 0) return;\\n\\t\\tallLendingPools.push(uniswapV2Pair);\\t\\t\\n\\t\\tgetLendingPool[uniswapV2Pair] = LendingPool(false, uint24(allLendingPools.length), address(0), address(0), address(0));\\n\\t}\\n\\t\\n\\tfunction createCollateral(address uniswapV2Pair) external returns (address collateral) {\\n\\t\\t_getTokens(uniswapV2Pair);\\n\\t\\trequire(getLendingPool[uniswapV2Pair].collateral == address(0), \\\"Impermax: ALREADY_EXISTS\\\");\\t\\t\\n\\t\\tcollateral = cDeployer.deployCollateral(uniswapV2Pair);\\n\\t\\tICollateral(collateral)._setFactory();\\n\\t\\t_createLendingPool(uniswapV2Pair);\\n\\t\\tgetLendingPool[uniswapV2Pair].collateral = collateral;\\n\\t}\\n\\t\\n\\tfunction createBorrowable0(address uniswapV2Pair) external returns (address borrowable0) {\\n\\t\\t_getTokens(uniswapV2Pair);\\n\\t\\trequire(getLendingPool[uniswapV2Pair].borrowable0 == address(0), \\\"Impermax: ALREADY_EXISTS\\\");\\t\\t\\n\\t\\tborrowable0 = bDeployer.deployBorrowable(uniswapV2Pair, 0);\\n\\t\\tIBorrowable(borrowable0)._setFactory();\\n\\t\\t_createLendingPool(uniswapV2Pair);\\n\\t\\tgetLendingPool[uniswapV2Pair].borrowable0 = borrowable0;\\n\\t}\\n\\t\\n\\tfunction createBorrowable1(address uniswapV2Pair) external returns (address borrowable1) {\\n\\t\\t_getTokens(uniswapV2Pair);\\n\\t\\trequire(getLendingPool[uniswapV2Pair].borrowable1 == address(0), \\\"Impermax: ALREADY_EXISTS\\\");\\t\\t\\n\\t\\tborrowable1 = bDeployer.deployBorrowable(uniswapV2Pair, 1);\\n\\t\\tIBorrowable(borrowable1)._setFactory();\\n\\t\\t_createLendingPool(uniswapV2Pair);\\n\\t\\tgetLendingPool[uniswapV2Pair].borrowable1 = borrowable1;\\n\\t}\\n\\t\\n\\tfunction initializeLendingPool(address uniswapV2Pair) external {\\n\\t\\t(address token0, address token1) = _getTokens(uniswapV2Pair);\\n\\t\\tLendingPool memory lPool = getLendingPool[uniswapV2Pair];\\n\\t\\trequire(!lPool.initialized, \\\"Impermax: ALREADY_INITIALIZED\\\");\\n\\t\\t\\n\\t\\trequire(lPool.collateral != address(0), \\\"Impermax: COLLATERALIZABLE_NOT_CREATED\\\");\\n\\t\\trequire(lPool.borrowable0 != address(0), \\\"Impermax: BORROWABLE0_NOT_CREATED\\\");\\n\\t\\trequire(lPool.borrowable1 != address(0), \\\"Impermax: BORROWABLE1_NOT_CREATED\\\");\\n\\t\\t\\n\\t\\t(,,,,,bool oracleInitialized) = simpleUniswapOracle.getPair(uniswapV2Pair);\\n\\t\\tif (!oracleInitialized) simpleUniswapOracle.initialize(uniswapV2Pair);\\n\\t\\t\\n\\t\\tICollateral(lPool.collateral)._initialize(\\\"Impermax Collateral\\\", \\\"imxC\\\", uniswapV2Pair, lPool.borrowable0, lPool.borrowable1);\\n\\t\\tIBorrowable(lPool.borrowable0)._initialize(\\\"Impermax Borrowable\\\", \\\"imxB\\\", token0, lPool.collateral);\\n\\t\\tIBorrowable(lPool.borrowable1)._initialize(\\\"Impermax Borrowable\\\", \\\"imxB\\\", token1, lPool.collateral);\\n\\t\\t\\n\\t\\tgetLendingPool[uniswapV2Pair].initialized = true;\\n\\t\\temit LendingPoolInitialized(uniswapV2Pair, token0, token1, lPool.collateral, lPool.borrowable0, lPool.borrowable1, lPool.lendingPoolId);\\n\\t}\\n\\t\\n\\tfunction _setPendingAdmin(address newPendingAdmin) external {\\n\\t\\trequire(msg.sender == admin, \\\"Impermax: UNAUTHORIZED\\\");\\n\\t\\taddress oldPendingAdmin = pendingAdmin;\\n\\t\\tpendingAdmin = newPendingAdmin;\\n\\t\\temit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\\n\\t}\\n\\n\\tfunction _acceptAdmin() external {\\n\\t\\trequire(msg.sender == pendingAdmin, \\\"Impermax: UNAUTHORIZED\\\");\\n\\t\\taddress oldAdmin = admin;\\n\\t\\taddress oldPendingAdmin = pendingAdmin;\\n\\t\\tadmin = pendingAdmin;\\n\\t\\tpendingAdmin = address(0);\\n\\t\\temit NewAdmin(oldAdmin, admin);\\n\\t\\temit NewPendingAdmin(oldPendingAdmin, address(0));\\n\\t}\\n\\t\\n\\tfunction _setReservesPendingAdmin(address newReservesPendingAdmin) external {\\n\\t\\trequire(msg.sender == reservesAdmin, \\\"Impermax: UNAUTHORIZED\\\");\\n\\t\\taddress oldReservesPendingAdmin = reservesPendingAdmin;\\n\\t\\treservesPendingAdmin = newReservesPendingAdmin;\\n\\t\\temit NewReservesPendingAdmin(oldReservesPendingAdmin, newReservesPendingAdmin);\\n\\t}\\n\\n\\tfunction _acceptReservesAdmin() external {\\n\\t\\trequire(msg.sender == reservesPendingAdmin, \\\"Impermax: UNAUTHORIZED\\\");\\n\\t\\taddress oldReservesAdmin = reservesAdmin;\\n\\t\\taddress oldReservesPendingAdmin = reservesPendingAdmin;\\n\\t\\treservesAdmin = reservesPendingAdmin;\\n\\t\\treservesPendingAdmin = address(0);\\n\\t\\temit NewReservesAdmin(oldReservesAdmin, reservesAdmin);\\n\\t\\temit NewReservesPendingAdmin(oldReservesPendingAdmin, address(0));\\n\\t}\\n\\n\\tfunction _setReservesManager(address newReservesManager) external {\\n\\t\\trequire(msg.sender == reservesAdmin, \\\"Impermax: UNAUTHORIZED\\\");\\n\\t\\taddress oldReservesManager = reservesManager;\\n\\t\\treservesManager = newReservesManager;\\n\\t\\temit NewReservesManager(oldReservesManager, newReservesManager);\\n\\t}\\n}\\n\"\r\n    },\r\n    \"./impermax-x-uniswapv2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 999999\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"interestAccumulated\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"AccrueInterest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrowsPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Borrow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"BorrowApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowRate\",\"type\":\"uint256\"}],\"name\":\"CalculateBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kinkRate\",\"type\":\"uint256\"}],\"name\":\"CalculateKink\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"kinkBorrowRate\",\"type\":\"uint256\"}],\"name\":\"CalculateKinkBorrowRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"repayAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrowsPrior\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"accountBorrows\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"}],\"name\":\"Liquidate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAdjustSpeed\",\"type\":\"uint256\"}],\"name\":\"NewAdjustSpeed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBorrowTracker\",\"type\":\"address\"}],\"name\":\"NewBorrowTracker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newKinkUtilizationRate\",\"type\":\"uint256\"}],\"name\":\"NewKinkUtilizationRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReserveFactor\",\"type\":\"uint256\"}],\"name\":\"NewReserveFactor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"redeemTokens\",\"type\":\"uint256\"}],\"name\":\"Redeem\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADJUST_SPEED_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADJUST_SPEED_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BORROW_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BORROW_PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_BORROW_RATE_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_BORROW_RATE_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_UR_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KINK_UR_MIN\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_LIQUIDITY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVE_FACTOR_MAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"string\",\"name\":\"_name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_underlying\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_collateral\",\"type\":\"address\"}],\"name\":\"_initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newAdjustSpeed\",\"type\":\"uint256\"}],\"name\":\"_setAdjustSpeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"newBorrowTracker\",\"type\":\"address\"}],\"name\":\"_setBorrowTracker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_setFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newKinkUtilizationRate\",\"type\":\"uint256\"}],\"name\":\"_setKinkUtilizationRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newReserveFactor\",\"type\":\"uint256\"}],\"name\":\"_setReserveFactor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accrualTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"accrueInterest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adjustSpeed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"borrowAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"borrowAllowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"borrowApprove\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"borrowBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowIndex\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"borrowPermit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowRate\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"borrowTracker\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateral\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRateLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBlockTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkBorrowRate\",\"outputs\":[{\"internalType\":\"uint48\",\"name\":\"\",\"type\":\"uint48\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"kinkUtilizationRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"liquidator\",\"type\":\"address\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"minter\",\"type\":\"address\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"mintTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rateUpdateTimestamp\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"redeemer\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"redeemAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveFactor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"skim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sync\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBorrows\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"\",\"type\":\"uint112\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"trackBorrow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"underlying\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Borrowable", "CompilerVersion": "v0.5.16+commit.9c3226ce", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "", "EVMVersion": "istanbul", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://99abf930eaca13ec309e81a3d68a76931f2f678ef0c3db9233b8cfbaba64659c"}