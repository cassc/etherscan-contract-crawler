{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/StakeELF_SpecialCase.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n\\nimport \\\"./security/PausableV2.sol\\\";\\nimport \\\"./token/IERC20.sol\\\";\\nimport \\\"./utils/IELFCore.sol\\\";\\nimport \\\"./utils/IStakeELF.sol\\\";\\n\\ncontract StakeELF_SpecialCase is PausableV2 {\\n    IELFCore immutable ELFCore;\\n    IERC20 immutable ROE;\\n    IStakeELF oldStakeELF;\\n    uint256 public totalEggs;\\n\\n    struct EGG {\\n        uint256 id;\\n        uint256 t; //stake timestamp\\n        uint256 i; //corresponding index of prices when EGG is created/withdrawn\\n        uint256 price;\\n        uint256 bornAt;\\n        uint256 gene;\\n        uint256 rewardStartingPoint; // the time when this egg can earn reward\\n        uint256 lastWithdrawTime;\\n        bool expired;\\n        bool withdrawn;\\n    }\\n\\n    uint256 constant denominator = 8760; // hours per year\\n    uint256 constant unit = 3600; //seconds per hour;\\n    uint256 constant noRewardTime = 1 days;\\n    uint256 constant maxStakingPeriod = 365 days;\\n    uint256 constant extraRewardUnit = 1 days;\\n\\n    /// @dev extraRewardTable[i] means the extra reward of ith day.\\n    mapping(uint256 => uint256) public extraRewardTable;\\n\\n    /// @dev Operators who can set APR.\\n    address[] ops;\\n    mapping(address => bool) isOp;\\n\\n    /// @dev Accumulated damage done to altars. Its value lies between [0,90].\\n    mapping(address => uint256) public altar;\\n\\n    /// @dev 9 attributes, price/APR.\\n    uint256[2][9][] prices;\\n\\n    /// @dev Mapping index of array prices to timestamp it was created.\\n    mapping(uint256 => uint256) public tPrices;\\n\\n    /// @dev Eggs staked by address.\\n    mapping(address => EGG[]) public eggs;\\n\\n    /// @dev specialWithdraw counter.\\n    mapping(address => uint256) public calculateCount;\\n\\n    /// @dev specialWithdraw roe value. Ignore alter value.\\n    mapping(address => uint256) public accumulatedReward;\\n\\n    mapping(address => uint256) public firstCalculateTime;\\n\\n    mapping(address => bool) public isMigrate;\\n\\n    event ExtraRewardTableChanged(address indexed sender, uint256 t, uint256 day, uint256 value);\\n\\n    /// @dev Should be fired whenever new term is added to array prices.\\n    event PriceChanged(address indexed sender, uint256 t, uint256[2][9] p);\\n\\n    /// @dev Fire whenever someone stake an egg.\\n    event Staking(address indexed staker, uint256 indexed id, uint256 t);\\n\\n    /// @dev Fire whenever someone claim his/her reward.\\n    event Withdrawing(address indexed staker, uint256 amount, uint256 t, uint256 altarDamage);\\n\\n    /// @dev Fire whenever someone migrate his/her eggs from old contract to new contract.\\n    /// @param target The target address of old contract.\\n    /// @param owner The owner address of new contract.\\n    /// @param fromIndex The index of eggs to be migrated. fromIndex should from 0.\\n    /// @param toIndex The index of eggs to be migrated. If the user egg length is 162, the toIndex should be 161\\n    /// @param migrateTime The timestamp of migration.\\n    /// @param altarPercentage The altar percentage of the user.\\n    /// @param ids The ids of eggs to be migrated.\\n    event Migrated(\\n        address indexed target,\\n        address indexed owner,\\n        uint256 fromIndex,\\n        uint256 toIndex,\\n        uint256 migrateTime,\\n        uint256 altarPercentage,\\n        uint256[] ids\\n    );\\n\\n    constructor(address ELF, address _ROE, address oldAddress) {\\n        ELFCore = IELFCore(ELF);\\n        ROE = IERC20(_ROE);\\n        oldStakeELF = IStakeELF(oldAddress);\\n    }\\n\\n    modifier needPricesSet() {\\n        require(tPrices[0] != 0, \\\"price not set\\\");\\n        _;\\n    }\\n\\n    function getOps() external view returns (address[] memory res) {\\n        return ops;\\n    }\\n\\n    function transferELF(address to, uint256 id) external onlySuperAdmin {\\n        ELFCore.transferFrom(address(this), to, id);\\n    }\\n\\n    function transferROE(address to, uint256 amount) external onlySuperAdmin {\\n        ROE.transfer(to, amount);\\n    }\\n\\n    function setOps(address op, bool tf) external onlySuperAdmin {\\n        if (isOp[op] != tf) {\\n            isOp[op] = tf;\\n            if (tf) {\\n                ops.push(op);\\n            } else {\\n                // remove element from ops\\n                uint256 i;\\n                uint256 l = ops.length;\\n                while (i < l) {\\n                    if (ops[i] == op) break;\\n                    i++;\\n                }\\n                ops[i] = ops[l - 1];\\n                ops.pop();\\n            }\\n        }\\n    }\\n\\n    function setExtraRewardTable(uint256 day, uint256 value) external {\\n        require(isOp[msg.sender], NO_PERMISSION);\\n        extraRewardTable[day] = value;\\n        emit ExtraRewardTableChanged(msg.sender, block.timestamp, day, value);\\n    }\\n\\n    function setPrices(uint256[2][9] calldata p) external {\\n        require(isOp[msg.sender], NO_PERMISSION);\\n        uint256 t = block.timestamp;\\n        tPrices[prices.length] = t;\\n        prices.push(p);\\n        emit PriceChanged(msg.sender, t, p);\\n    }\\n\\n    function getPrices(uint256 i) external view returns (uint256[2][9] memory res) {\\n        return prices[i];\\n    }\\n\\n    /// @dev The unit of res is %.\\n    function getYearlyReward() external view returns (uint256 res) {\\n        uint256 index = prices.length - 1;\\n        for (uint256 i; i < 9; i++) {\\n            res = res + prices[index][i][1];\\n        }\\n        res /= 9;\\n        res += calculateExtraRewardPercentage(365 * extraRewardUnit);\\n    }\\n\\n    function userStakeEggs(address addr) external view returns (uint256 res) {\\n        return eggs[addr].length;\\n    }\\n\\n    function stake(uint256[] calldata ids) external needPricesSet whenNotPaused {\\n        uint256 l = ids.length;\\n        require(eggs[msg.sender].length + l <= 100, \\\"One address stake limit is 100\\\");\\n        uint256 t = block.timestamp;\\n        uint256 pricesIndex = prices.length - 1;\\n        totalEggs = l + totalEggs;\\n        for (uint256 i = 0; i < l;) {\\n            uint256 id = ids[i];\\n            require(msg.sender == ELFCore.ownerOf(id), NO_PERMISSION);\\n            require(!ELFCore.isHatched(id), \\\"egg hatched\\\");\\n            (,,, uint256 gene, uint256 bornAt,) = ELFCore.gainELF(id);\\n            uint256 rewardStartingPoint;\\n            if (bornAt < t + noRewardTime) rewardStartingPoint = t + noRewardTime;\\n            else rewardStartingPoint = bornAt;\\n            EGG memory _EGG = EGG({\\n                id: id,\\n                t: t,\\n                i: pricesIndex,\\n                price: prices[pricesIndex][gene - 1][0],\\n                bornAt: bornAt,\\n                gene: gene,\\n                rewardStartingPoint: rewardStartingPoint,\\n                lastWithdrawTime: 0,\\n                expired: false,\\n                withdrawn: false\\n            });\\n\\n            eggs[msg.sender].push(_EGG);\\n            ELFCore.transferFrom(msg.sender, address(this), id);\\n            emit Staking(msg.sender, id, t);\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (altar[msg.sender] <= 10 * l) altar[msg.sender] = 0;\\n        else altar[msg.sender] -= 10 * l;\\n    }\\n\\n    function getWithdrawValue(address addr) external view needPricesSet returns (uint256 amount, uint256 t) {\\n        t = block.timestamp;\\n        EGG[] memory _eggs = eggs[addr];\\n        uint256 l = _eggs.length;\\n\\n        for (uint256 i = 0; i < l;) {\\n            //iterate through all eggs.\\n            EGG memory _egg = _eggs[i];\\n            uint256 rewardStartingPoint = _egg.rewardStartingPoint;\\n            uint256 totalTime;\\n            if (!_egg.withdrawn) {\\n                //staking reward + extra reward\\n                if (t <= rewardStartingPoint) totalTime = 0;\\n                else totalTime = t - rewardStartingPoint; //the total seconds caller can earn reward\\n                if (totalTime >= unit) {\\n                    if (totalTime >= maxStakingPeriod) totalTime = maxStakingPeriod;\\n                    amount += calculateExtraRewardPercentage(totalTime) * _egg.price / 100;\\n                }\\n            } else if (!_egg.expired) {\\n                //only staking reward\\n                if (t - rewardStartingPoint >= maxStakingPeriod) {\\n                    totalTime = rewardStartingPoint + maxStakingPeriod - _egg.lastWithdrawTime;\\n                } else {\\n                    totalTime = t - _egg.lastWithdrawTime;\\n                }\\n            }\\n            (uint256 eggAmount,,) = stakingReward(totalTime, _egg);\\n            amount += eggAmount;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        amount = amount * (100 - altar[addr]) / 100;\\n    }\\n\\n    /// @dev The unit of returnd value percentage is %.\\n    function getAverageWithdrawPercentage(address addr)\\n        external\\n        view\\n        needPricesSet\\n        returns (uint256 percentage, uint256 t)\\n    {\\n        t = block.timestamp;\\n        EGG[] memory _eggs = eggs[addr];\\n        uint256 count;\\n        uint256 maxExtraRewardPercentage = calculateExtraRewardPercentage(365 * extraRewardUnit);\\n        uint256 l = _eggs.length;\\n\\n        for (uint256 i = 0; i < l;) {\\n            //iterate through all eggs.\\n            EGG memory _egg = _eggs[i];\\n            uint256 rewardStartingPoint = _egg.rewardStartingPoint;\\n            if (!_egg.withdrawn) {\\n                //staking reward + extra reward\\n                if (t >= rewardStartingPoint + unit) {\\n                    percentage += maxExtraRewardPercentage + prices[prices.length - 1][_egg.gene - 1][1];\\n                    count++;\\n                }\\n            } else if (!_egg.expired) {\\n                //only staking reward\\n                percentage += prices[prices.length - 1][_egg.gene - 1][1];\\n                count++;\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        if (count == 0) percentage = 0;\\n        else percentage = percentage * (100 - altar[addr]) / 100 / count;\\n    }\\n\\n    function getWithdrawDiff(address addr) external view needPricesSet returns (uint256 diff, uint256 t) {\\n        t = block.timestamp;\\n        EGG[] memory _eggs = eggs[addr];\\n        uint256 amount;\\n        uint256 maxExtraRewardPercentage = calculateExtraRewardPercentage(365 * extraRewardUnit);\\n        uint256 l = _eggs.length;\\n\\n        for (uint256 i = 0; i < l;) {\\n            //iterate through all eggs.\\n            EGG memory _egg = _eggs[i];\\n            uint256 rewardStartingPoint = _egg.rewardStartingPoint;\\n            uint256 totalTime;\\n            if (!_egg.withdrawn) {\\n                //staking reward + extra reward\\n                if (t <= rewardStartingPoint) totalTime = 0;\\n                else totalTime = t - rewardStartingPoint; //the total seconds caller can earn reward\\n                if (totalTime >= unit) {\\n                    if (totalTime >= maxStakingPeriod) totalTime = maxStakingPeriod;\\n                    uint256 extraReward = calculateExtraRewardPercentage(totalTime) * _egg.price / 100;\\n                    amount += extraReward;\\n                    diff += maxExtraRewardPercentage * _egg.price / 100 - extraReward;\\n                }\\n            } else if (!_egg.expired) {\\n                //only staking reward\\n                if (t - rewardStartingPoint >= maxStakingPeriod) {\\n                    totalTime = rewardStartingPoint + maxStakingPeriod - _egg.lastWithdrawTime;\\n                } else {\\n                    totalTime = t - _egg.lastWithdrawTime;\\n                }\\n            }\\n            (uint256 eggAmount,,) = stakingReward(totalTime, _egg);\\n            amount += eggAmount;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        diff = diff + amount * altar[addr] / 100;\\n    }\\n\\n    /// @dev Unit of returnd value res is %.\\n    function calculateExtraRewardPercentage(uint256 totalTime) internal view returns (uint256 res) {\\n        uint256 l = totalTime / extraRewardUnit;\\n        for (uint256 i = 1; i < l + 1;) {\\n            res += extraRewardTable[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function stakingReward(uint256 totalTime, EGG memory egg)\\n        internal\\n        view\\n        returns (uint256 amount, uint256 indexOfPrices, uint256 tempLastWithdrawTime)\\n    {\\n        uint256 accumulatedTime; // accumulated seconds whose reward have been calculated\\n        indexOfPrices = egg.i;\\n        uint256 rewardStartingPoint = egg.rewardStartingPoint;\\n        tempLastWithdrawTime = egg.lastWithdrawTime;\\n        while (totalTime - accumulatedTime >= unit) {\\n            //iterate through terms of prices\\n            uint256 unitDiff;\\n            if (tPrices[indexOfPrices + 1] == 0) {\\n                //next term of prices does not exist\\n                unitDiff = (totalTime - accumulatedTime) / unit;\\n                accumulatedTime = totalTime;\\n                amount = amount + egg.price * prices[indexOfPrices][egg.gene - 1][1] / 100 * unitDiff / denominator;\\n            } else {\\n                //next term of prices exists\\n                uint256 secondDiff;\\n                if (tPrices[indexOfPrices + 1] < rewardStartingPoint) {\\n                    indexOfPrices++;\\n                    continue;\\n                }\\n                if (tempLastWithdrawTime == 0) secondDiff = tPrices[indexOfPrices + 1] - rewardStartingPoint;\\n                else secondDiff = tPrices[indexOfPrices + 1] - tempLastWithdrawTime;\\n                uint256 remainder = secondDiff % unit;\\n                secondDiff = secondDiff - remainder;\\n\\n                if (accumulatedTime + secondDiff > totalTime) {\\n                    unitDiff = (totalTime - accumulatedTime) / unit;\\n                    accumulatedTime = totalTime;\\n                    amount = amount + egg.price * prices[indexOfPrices][egg.gene - 1][1] / 100 * unitDiff / denominator;\\n                } else {\\n                    unitDiff = secondDiff / unit;\\n                    if (remainder != 0 && accumulatedTime + secondDiff + unit <= totalTime) unitDiff++;\\n                    accumulatedTime += unitDiff * unit;\\n                    amount = amount + egg.price * prices[indexOfPrices][egg.gene - 1][1] / 100 * unitDiff / denominator;\\n                    indexOfPrices++;\\n                }\\n            }\\n            if (tempLastWithdrawTime == 0) tempLastWithdrawTime = rewardStartingPoint + unitDiff * unit;\\n            else tempLastWithdrawTime += unitDiff * unit;\\n        }\\n    }\\n\\n    function specialCalculate() external whenNotPaused needPricesSet {\\n        EGG[] memory _eggs = eggs[msg.sender];\\n        uint256 l = _eggs.length;\\n        require(l != 0, \\\"no egg\\\");\\n        uint256 maxCount = l % 100 != 0 ? l / 100 + 1 : l / 100;\\n        uint256 currentCount = calculateCount[msg.sender];\\n        require(maxCount != currentCount, \\\"withdraw before calculation\\\");\\n        uint256 startAt = currentCount * 100;\\n        uint256 endAt = currentCount == maxCount - 1 ? l : startAt + 100;\\n        calculateCount[msg.sender]++;\\n        uint256 amount;\\n        uint256 t;\\n        if (currentCount == 0) {\\n            t = block.timestamp;\\n            firstCalculateTime[msg.sender] = t;\\n        } else {\\n            t = firstCalculateTime[msg.sender];\\n        }\\n        for (uint256 i = startAt; i < endAt;) {\\n            //iterate through part of eggs.\\n            EGG memory _egg = _eggs[i];\\n            uint256 rewardStartingPoint = _egg.rewardStartingPoint;\\n            uint256 totalTime;\\n            if (!_egg.withdrawn) {\\n                //staking reward + extra reward\\n                if (t <= rewardStartingPoint) totalTime = 0;\\n                else totalTime = t - rewardStartingPoint; //the total seconds caller can earn reward\\n                if (totalTime >= unit) {\\n                    eggs[msg.sender][i].withdrawn = true;\\n                    if (totalTime >= maxStakingPeriod) {\\n                        eggs[msg.sender][i].expired = true;\\n                        totalTime = maxStakingPeriod;\\n                    }\\n                    amount += calculateExtraRewardPercentage(totalTime) * _egg.price / 100;\\n                }\\n            } else if (!_egg.expired) {\\n                //only staking reward\\n                if (t - rewardStartingPoint >= maxStakingPeriod) {\\n                    eggs[msg.sender][i].expired = true;\\n                    totalTime = rewardStartingPoint + maxStakingPeriod - _egg.lastWithdrawTime;\\n                } else {\\n                    totalTime = t - _egg.lastWithdrawTime;\\n                }\\n            }\\n            (uint256 eggAmount, uint256 indexOfPrices, uint256 tempLastWithdrawTime) = stakingReward(totalTime, _egg);\\n            amount += eggAmount;\\n            eggs[msg.sender][i].i = indexOfPrices;\\n            eggs[msg.sender][i].lastWithdrawTime = tempLastWithdrawTime;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        accumulatedReward[msg.sender] += amount;\\n    }\\n\\n    function specialWithdraw() external whenNotPaused needPricesSet {\\n        uint256 l = eggs[msg.sender].length;\\n        require(l != 0, \\\"no egg\\\");\\n        uint256 maxCount = l % 100 != 0 ? l / 100 + 1 : l / 100;\\n        require(maxCount == calculateCount[msg.sender], \\\"calculate count not enough\\\");\\n        calculateCount[msg.sender] = 0;\\n        uint256 amount = accumulatedReward[msg.sender];\\n        accumulatedReward[msg.sender] = 0;\\n        uint256 t = block.timestamp;\\n        if (amount > 0) {\\n            uint256 altarTemp = altar[msg.sender];\\n            amount = amount * (100 - altarTemp) / 100;\\n            require(ROE.balanceOf(address(this)) >= amount, \\\"contract ROE not enough\\\");\\n            altarTemp = altarTemp + t % 8 + 3;\\n            if (altarTemp > 90) altarTemp = 90;\\n            altar[msg.sender] = altarTemp;\\n            ROE.transfer(msg.sender, amount);\\n            emit Withdrawing(msg.sender, amount, t, 100 - altarTemp);\\n        }\\n    }\\n\\n    /// @dev Migrate target's eggs from old contract to specific user.\\n    /// @param user The user address.\\n    /// @param fromIndex The index of eggs to be migrated. fromIndex starts from 0.\\n    /// @param toIndex The index of eggs to be migrated. If user egg length is 162, the toIndex should be 162\\n    function migrate(address user, uint256 fromIndex, uint256 toIndex) external whenNotPaused {\\n        require(isOp[msg.sender], NO_PERMISSION);\\n        require(!isMigrate[user], \\\"Already Migrated\\\");\\n        uint256 eggsLength = oldStakeELF.userStakeEggs(user);\\n        require(toIndex <= eggsLength, \\\"Out of range : toIndex\\\");\\n        if (toIndex == eggsLength) isMigrate[user] = true;\\n        uint256[] memory ids = new uint256[](eggsLength);\\n\\n        for (uint256 i = fromIndex; i < toIndex;) {\\n            EGG memory eggData = _fetchEggData(user, i);\\n\\n            EGG memory egg = EGG({\\n                id: eggData.id,\\n                t: eggData.t,\\n                i: eggData.i,\\n                price: eggData.price,\\n                bornAt: eggData.bornAt,\\n                gene: eggData.gene,\\n                rewardStartingPoint: eggData.rewardStartingPoint,\\n                lastWithdrawTime: eggData.lastWithdrawTime,\\n                expired: eggData.expired,\\n                withdrawn: eggData.withdrawn\\n            });\\n\\n            eggs[user].push(egg);\\n\\n            // set id to ids for the event\\n            ids[i] = eggData.id;\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        // Set Altar\\n        if (eggsLength >= 100) {\\n            altar[user] = 0;\\n        } else if (eggsLength >= 92) {\\n            uint256 temp = 10 * (100 - eggsLength);\\n            if (temp < oldStakeELF.altar(user)) altar[user] = temp;\\n        } else {\\n            altar[user] = oldStakeELF.altar(user);\\n        }\\n\\n        emit Migrated(user, user, fromIndex, toIndex, block.timestamp, altar[user], ids);\\n    }\\n\\n    function _fetchEggData(address user, uint256 index) internal view returns (EGG memory) {\\n        (\\n            uint256 id,\\n            uint256 t,\\n            uint256 indexOfPrice,\\n            uint256 price,\\n            uint256 bornAt,\\n            uint256 gene,\\n            uint256 rewardStartingPoint\\n        ) = oldStakeELF.eggs(user, index);\\n\\n        uint256 lastWithdrawTime = oldStakeELF.lastWithdrawTime(user, index);\\n        bool expired = oldStakeELF.expired(user, index);\\n        bool withdrawn = oldStakeELF.withdrawn(user, index);\\n\\n        return EGG({\\n            id: id,\\n            t: t,\\n            i: indexOfPrice,\\n            price: price,\\n            bornAt: bornAt,\\n            gene: gene,\\n            rewardStartingPoint: rewardStartingPoint,\\n            lastWithdrawTime: lastWithdrawTime,\\n            expired: expired,\\n            withdrawn: withdrawn\\n        });\\n    }\\n\\n    function setHistoryPrices(uint256[2][9] calldata p, uint256 t) external {\\n        require(isOp[msg.sender], NO_PERMISSION);\\n        tPrices[prices.length] = t;\\n        prices.push(p);\\n        emit PriceChanged(msg.sender, t, p);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/security/PausableV2.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\nimport \\\"./AccessControlV2.sol\\\";\\r\\n\\r\\ncontract PausableV2 is AccessControlV2 {\\r\\n    /// @dev Error message.\\r\\n    string constant PAUSED = \\\"paused\\\";\\r\\n    string constant NOT_PAUSED = \\\"not paused\\\";\\r\\n\\r\\n    /// @dev Keeps track whether the contract is paused. When this is true, most actions are blocked.\\r\\n    bool public paused = false;\\r\\n\\r\\n    /// @dev Modifier to allow actions only when the contract is not paused\\r\\n    modifier whenNotPaused() {\\r\\n        require(!paused, PAUSED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Modifier to allow actions only when the contract is paused\\r\\n    modifier whenPaused() {\\r\\n        require(paused, NOT_PAUSED);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Called by superAdmin to pause the contract. Used when something goes wrong\\r\\n    ///  and we need to limit damage.\\r\\n    function pause() external onlySuperAdmin whenNotPaused {\\r\\n        paused = true;\\r\\n    }\\r\\n\\r\\n    /// @dev Unpauses the smart contract. Can only be called by the superAdmin.\\r\\n    function unpause() external onlySuperAdmin whenPaused {\\r\\n        paused = false;\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/IERC20.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ninterface IERC20 {\\r\\n\\r\\n    /// MUST trigger when tokens are transferred, including zero value transfers.\\r\\n    /// A token contract which creates new tokens SHOULD trigger a Transfer event with \\r\\n    ///  the _from address set to 0x0 when tokens are created.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\\r\\n\\r\\n    /// MUST trigger on any successful call to approve(address _spender, uint256 _value).\\r\\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\\r\\n\\r\\n    /// Returns the total token supply.\\r\\n    function totalSupply() external view returns (uint256);\\r\\n\\r\\n    /// Returns the account balance of another account with address _owner.\\r\\n    function balanceOf(address _owner) external view returns (uint256 balance);\\r\\n\\r\\n    /// Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. \\r\\n    /// The function SHOULD throw if the message caller\u2019s account balance does not have enough tokens to spend.\\r\\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\\r\\n    function transfer(address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n    /// Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.\\r\\n    /// The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. \\r\\n    /// This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies. \\r\\n    /// The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism.\\r\\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\\r\\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\\r\\n\\r\\n    /// Allows _spender to withdraw from your account multiple times, up to the _value amount. \\r\\n    /// If this function is called again it overwrites the current allowance with _value.\\r\\n    function approve(address _spender, uint256 _value) external returns (bool success);\\r\\n\\r\\n    /// Returns the amount which _spender is still allowed to withdraw from _owner.\\r\\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\\r\\n}\"\r\n    },\r\n    \"contracts/utils/IELFCore.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n\\nimport '../token/IERC721.sol';\\n\\ninterface IELFCore is IERC721{\\n\\n    function isHatched(uint256 _tokenId) external view returns (bool res);\\n    function gainELF(uint _tokenId) external view returns (uint label, uint dad, uint mom, uint gene, uint bornAt, uint[] memory children);\\n}\"\r\n    },\r\n    \"contracts/utils/IStakeELF.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\n\\ninterface IStakeELF {\\n    function altar(address user) external view returns (uint256);\\n    function eggs(address user, uint256 index)\\n        external\\n        view\\n        returns (\\n            uint256 id,\\n            uint256 t,\\n            uint256 i,\\n            uint256 price,\\n            uint256 bornAt,\\n            uint256 gene,\\n            uint256 rewardStartingPoint\\n        );\\n    function userStakeEggs(address user) external view returns (uint256);\\n    function lastWithdrawTime(address user, uint256 index) external view returns (uint256);\\n    function expired(address user, uint256 index) external view returns (bool);\\n    function withdrawn(address user, uint256 index) external view returns (bool);\\n\\n    function setPrices(uint256[2][9] calldata p) external;\\n    function stake(uint256[] calldata ids) external;\\n    function withdraw() external;\\n}\\n\"\r\n    },\r\n    \"contracts/security/AccessControlV2.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\ncontract AccessControlV2 {\\r\\n    /// @dev Error message.\\r\\n    string constant NO_PERMISSION = \\\"no permission\\\";\\r\\n    string constant INVALID_ADDRESS = \\\"invalid address\\\";\\r\\n    string constant UNAUTHORIZED_ADDRESS = \\\"Ownable: unauthorized account\\\";\\r\\n\\r\\n    /// @dev Owner tpye of \\\"SuperAdmin\\\" & \\\"Admin\\\".\\r\\n    enum Type {\\r\\n        SuperAdmin,\\r\\n        Admin\\r\\n    }\\r\\n\\r\\n    /// @dev Administrator with highest authority. Should be a multisig wallet.\\r\\n    address payable superAdmin;\\r\\n    /// @dev Administrator of this contract.\\r\\n    address payable admin;\\r\\n\\r\\n    /// @dev Pending administrator of this contract.\\r\\n    address payable _pendingAdmin;\\r\\n    address payable _pendingSuperAdmin;\\r\\n\\r\\n    /// @dev Throws if called by any account other than the superAdmin.\\r\\n    modifier onlySuperAdmin() {\\r\\n        require(msg.sender == superAdmin, NO_PERMISSION);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @dev Throws if called by any account other than the admin.\\r\\n    modifier onlyAdmin() {\\r\\n        require(msg.sender == admin, NO_PERMISSION);\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\r\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\r\\n\\r\\n    /// Sets the original admin and superAdmin of the contract to the sender account.\\r\\n    constructor() {\\r\\n        superAdmin = payable(msg.sender);\\r\\n        admin = payable(msg.sender);\\r\\n    }\\r\\n\\r\\n    fallback() external {}\\r\\n\\r\\n    function pendingOwner() public view virtual returns (address, address) {\\r\\n        return (_pendingSuperAdmin, _pendingAdmin);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the current superAdmin to change superAdmin.\\r\\n    /// @param addr The address to transfer the right of superAdmin to.\\r\\n    function changeSuperAdmin(address payable addr) external onlySuperAdmin {\\r\\n        require(addr != payable(address(0)), INVALID_ADDRESS);\\r\\n        _pendingSuperAdmin = addr;\\r\\n        emit OwnershipTransferStarted(superAdmin, addr);\\r\\n    }\\r\\n\\r\\n    /// @dev Allows the current superAdmin to change admin.\\r\\n    /// @param addr The address to transfer the right of admin to.\\r\\n    function changeAdmin(address payable addr) external onlySuperAdmin {\\r\\n        require(addr != payable(address(0)), INVALID_ADDRESS);\\r\\n        _pendingAdmin = addr;\\r\\n        emit OwnershipTransferStarted(admin, addr);\\r\\n    }\\r\\n\\r\\n    function acceptSuperAdmin() public virtual {\\r\\n        address sender = msg.sender;\\r\\n        require(_pendingSuperAdmin == sender, UNAUTHORIZED_ADDRESS);\\r\\n        _pendingSuperAdmin = payable(address(0));\\r\\n        _transferOwner(Type.SuperAdmin, payable(sender));\\r\\n    }\\r\\n\\r\\n    function acceptAdmin() public virtual {\\r\\n        address sender = msg.sender;\\r\\n        require(_pendingAdmin == sender, UNAUTHORIZED_ADDRESS);\\r\\n        _pendingAdmin = payable(address(0));\\r\\n        _transferOwner(Type.Admin, payable(sender));\\r\\n    }\\r\\n\\r\\n    function _transferOwner(Type ownerType, address payable newOwner) internal virtual {\\r\\n        address oldOwner;\\r\\n        if (ownerType == Type.SuperAdmin) {\\r\\n            oldOwner = superAdmin;\\r\\n            superAdmin = newOwner;\\r\\n        } else if (ownerType == Type.Admin) {\\r\\n            oldOwner = admin;\\r\\n            admin = newOwner;\\r\\n        }\\r\\n\\r\\n        emit OwnershipTransferred(oldOwner, newOwner);\\r\\n    }\\r\\n\\r\\n    /// @dev Called by superAdmin to withdraw balance.\\r\\n    function withdrawBalance(uint256 amount) external onlySuperAdmin {\\r\\n        superAdmin.transfer(amount);\\r\\n    }\\r\\n}\\r\\n\"\r\n    },\r\n    \"contracts/token/IERC721.sol\": {\r\n      \"content\": \"pragma solidity >=0.8.0 <0.9.0;\\r\\n\\r\\n/// @title ERC-721 Non-Fungible Token Standard\\r\\n/// @dev See https://eips.ethereum.org/EIPS/eip-721\\r\\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\\r\\ninterface IERC721 /* is ERC165 */ {\\r\\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\\r\\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\\r\\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\\r\\n    ///  may be created and assigned without emitting Transfer. At the time of\\r\\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\\r\\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when the approved address for an NFT is changed or\\r\\n    ///  reaffirmed. The zero address indicates there is no approved address.\\r\\n    ///  When a Transfer event emits, this also indicates that the approved\\r\\n    ///  address for that NFT (if any) is reset to none.\\r\\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\\r\\n\\r\\n    /// @dev This emits when an operator is enabled or disabled for an owner.\\r\\n    ///  The operator can manage all NFTs of the owner.\\r\\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\\r\\n\\r\\n    /// @notice Count all NFTs assigned to an owner\\r\\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\\r\\n    ///  function throws for queries about the zero address.\\r\\n    /// @param _owner An address for whom to query the balance\\r\\n    /// @return The number of NFTs owned by `_owner`, possibly zero\\r\\n    function balanceOf(address _owner) external view returns (uint256);\\r\\n\\r\\n    /// @notice Find the owner of an NFT\\r\\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\\r\\n    ///  about them do throw.\\r\\n    /// @param _tokenId The identifier for an NFT\\r\\n    /// @return The address of the owner of the NFT\\r\\n    function ownerOf(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\\r\\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\\r\\n    ///  `onERC721Received` on `_to` and throws if the return value is not\\r\\n    ///  `bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"))`.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    /// @param data Additional data with no specified format, sent in call to `_to`\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;\\r\\n\\r\\n    /// @notice Transfers the ownership of an NFT from one address to another address\\r\\n    /// @dev This works identically to the other function with an extra data parameter,\\r\\n    ///  except this function just sets data to \\\"\\\".\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\\r\\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\\r\\n    ///  THEY MAY BE PERMANENTLY LOST\\r\\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\\r\\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\\r\\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\\r\\n    ///  `_tokenId` is not a valid NFT.\\r\\n    /// @param _from The current owner of the NFT\\r\\n    /// @param _to The new owner\\r\\n    /// @param _tokenId The NFT to transfer\\r\\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Change or reaffirm the approved address for an NFT\\r\\n    /// @dev The zero address indicates there is no approved address.\\r\\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\\r\\n    ///  operator of the current owner.\\r\\n    /// @param _approved The new approved NFT controller\\r\\n    /// @param _tokenId The NFT to approve\\r\\n    function approve(address _approved, uint256 _tokenId) external payable;\\r\\n\\r\\n    /// @notice Enable or disable approval for a third party (\\\"operator\\\") to manage\\r\\n    ///  all of `msg.sender`'s assets\\r\\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\\r\\n    ///  multiple operators per owner.\\r\\n    /// @param _operator Address to add to the set of authorized operators\\r\\n    /// @param _approved True if the operator is approved, false to revoke approval\\r\\n    function setApprovalForAll(address _operator, bool _approved) external;\\r\\n\\r\\n    /// @notice Get the approved address for a single NFT\\r\\n    /// @dev Throws if `_tokenId` is not a valid NFT.\\r\\n    /// @param _tokenId The NFT to find the approved address for\\r\\n    /// @return The approved address for this NFT, or the zero address if there is none\\r\\n    function getApproved(uint256 _tokenId) external view returns (address);\\r\\n\\r\\n    /// @notice Query if an address is an authorized operator for another address\\r\\n    /// @param _owner The address that owns the NFTs\\r\\n    /// @param _operator The address that acts on behalf of the owner\\r\\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\\r\\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\\r\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ELF\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ROE\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"oldAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ExtraRewardTableChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"migrateTime\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"altarPercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"Migrated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[2][9]\",\"name\":\"p\",\"type\":\"uint256[2][9]\"}],\"name\":\"PriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"Staking\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"altarDamage\",\"type\":\"uint256\"}],\"name\":\"Withdrawing\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"acceptAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accumulatedReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"altar\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"calculateCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bornAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gene\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardStartingPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastWithdrawTime\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"expired\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extraRewardTable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"firstCalculateTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getAverageWithdrawPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOps\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"res\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getPrices\",\"outputs\":[{\"internalType\":\"uint256[2][9]\",\"name\":\"res\",\"type\":\"uint256[2][9]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWithdrawDiff\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"diff\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getWithdrawValue\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getYearlyReward\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isMigrate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"fromIndex\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toIndex\",\"type\":\"uint256\"}],\"name\":\"migrate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"day\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setExtraRewardTable\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2][9]\",\"name\":\"p\",\"type\":\"uint256[2][9]\"},{\"internalType\":\"uint256\",\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"setHistoryPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"op\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"tf\",\"type\":\"bool\"}],\"name\":\"setOps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[2][9]\",\"name\":\"p\",\"type\":\"uint256[2][9]\"}],\"name\":\"setPrices\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialCalculate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"specialWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferELF\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferROE\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"userStakeEggs\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"res\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "StakeELF_SpecialCase", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000fcd60b2d8acbc3869cbe1ddcda60d0a92da2d4cb0000000000000000000000001dc43be95b7a05987f1261cb388c129bb53ea5990000000000000000000000006d0afb5fbddcfddc1318c8959bb8cde8114aa2e1", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}