{"SourceCode": "// SPDX-License-Identifier: MIT\r\n  pragma solidity 0.8.18;\r\n\r\n  library SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two unsigned integers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n      // benefit is lost if 'b' is also tested.\r\n      // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n\r\n      uint256 c = a * b;\r\n      require(c / a == b, \"SafeMath#mul: OVERFLOW\");\r\n\r\n      return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      // Solidity only automatically asserts when dividing by 0\r\n      require(b > 0, \"SafeMath#div: DIVISION_BY_ZERO\");\r\n      uint256 c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n      return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      require(b <= a, \"SafeMath#sub: UNDERFLOW\");\r\n      uint256 c = a - b;\r\n\r\n      return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two unsigned integers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      uint256 c = a + b;\r\n      require(c >= a, \"SafeMath#add: OVERFLOW\");\r\n\r\n      return c; \r\n    }\r\n\r\n    /**\r\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      require(b != 0, \"SafeMath#mod: DIVISION_BY_ZERO\");\r\n      return a % b;\r\n    }\r\n\r\n  }\r\n\r\n  abstract contract Context {\r\n      function _msgSender() internal view virtual returns (address) {\r\n          return msg.sender;\r\n      }\r\n\r\n      function _msgData() internal view virtual returns (bytes calldata) {\r\n          return msg.data;\r\n      }\r\n  }\r\n\r\n  /**\r\n   * @dev Contract module which provides a basic access control mechanism, where\r\n   * there is an account (an owner) that can be granted exclusive access to\r\n   * specific functions.\r\n   *\r\n   * This module is used through inheritance. It will make available the modifier\r\n   * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n   * the owner.\r\n   */\r\n  abstract contract Ownable is Context {\r\n      address private _owner;\r\n\r\n      event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n      /**\r\n       * @dev Initializes the contract setting the deployer as the initial owner.\r\n       */\r\n      constructor() {\r\n          _setOwner(_msgSender());\r\n      }\r\n\r\n      /**\r\n       * @dev Returns the address of the current owner.\r\n       */\r\n      function owner() public view virtual returns (address) {\r\n          return _owner;\r\n      }\r\n\r\n      /**\r\n       * @dev Throws if called by any account other than the owner.\r\n       */\r\n      modifier onlyOwner() {\r\n          require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n          _;\r\n      }\r\n\r\n      /**\r\n       * @dev Leaves the contract without owner. It will not be possible to call\r\n       * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n       *\r\n       * NOTE: Renouncing ownership will leave the contract without an owner,\r\n       * thereby removing any functionality that is only available to the owner.\r\n       */\r\n      function renounceOwnership() public virtual onlyOwner {\r\n          _setOwner(address(0));\r\n      }\r\n\r\n      /**\r\n       * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n       * Can only be called by the current owner.\r\n       */\r\n      function transferOwnership(address newOwner) public virtual onlyOwner {\r\n          require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n          _setOwner(newOwner);\r\n      }\r\n\r\n      function _setOwner(address newOwner) private {\r\n          address oldOwner = _owner;\r\n          _owner = newOwner;\r\n          emit OwnershipTransferred(oldOwner, newOwner);\r\n      }\r\n  }\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\r\n        external\r\n        view\r\n        returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must be have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount,\r\n        bytes calldata data\r\n    ) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n  interface LinkTokenInterface {\r\n\r\n    function allowance(\r\n      address owner,\r\n      address spender\r\n    )\r\n      external\r\n      view\r\n      returns (\r\n        uint256 remaining\r\n      );\r\n\r\n    function approve(\r\n      address spender,\r\n      uint256 value\r\n    )\r\n      external\r\n      returns (\r\n        bool success\r\n      );\r\n\r\n    function balanceOf(\r\n      address owner\r\n    )\r\n      external\r\n      view\r\n      returns (\r\n        uint256 balance\r\n      );\r\n\r\n    function decimals()\r\n      external\r\n      view\r\n      returns (\r\n        uint8 decimalPlaces\r\n      );\r\n\r\n    function decreaseApproval(\r\n      address spender,\r\n      uint256 addedValue\r\n    )\r\n      external\r\n      returns (\r\n        bool success\r\n      );\r\n\r\n    function increaseApproval(\r\n      address spender,\r\n      uint256 subtractedValue\r\n    ) external;\r\n\r\n    function name()\r\n      external\r\n      view\r\n      returns (\r\n        string memory tokenName\r\n      );\r\n\r\n    function symbol()\r\n      external\r\n      view\r\n      returns (\r\n        string memory tokenSymbol\r\n      );\r\n\r\n    function totalSupply()\r\n      external\r\n      view\r\n      returns (\r\n        uint256 totalTokensIssued\r\n      );\r\n\r\n    function transfer(\r\n      address to,\r\n      uint256 value\r\n    )\r\n      external\r\n      returns (\r\n        bool success\r\n      );\r\n\r\n    function transferAndCall(\r\n      address to,\r\n      uint256 value,\r\n      bytes calldata data\r\n    )\r\n      external\r\n      returns (\r\n        bool success\r\n      );\r\n\r\n    function transferFrom(\r\n      address from,\r\n      address to,\r\n      uint256 value\r\n    )\r\n      external\r\n      returns (\r\n        bool success\r\n      );\r\n\r\n  }\r\n\r\n  contract VRFRequestIDBase {\r\n\r\n    /**\r\n     * @notice returns the seed which is actually input to the VRF coordinator\r\n     *\r\n     * @dev To prevent repetition of VRF output due to repetition of the\r\n     * @dev user-supplied seed, that seed is combined in a hash with the\r\n     * @dev user-specific nonce, and the address of the consuming contract. The\r\n     * @dev risk of repetition is mostly mitigated by inclusion of a blockhash in\r\n     * @dev the final seed, but the nonce does protect against repetition in\r\n     * @dev requests which are included in a single block.\r\n     *\r\n     * @param _userSeed VRF seed input provided by user\r\n     * @param _requester Address of the requesting contract\r\n     * @param _nonce User-specific nonce at the time of the request\r\n     */\r\n    function makeVRFInputSeed(\r\n      bytes32 _keyHash,\r\n      uint256 _userSeed,\r\n      address _requester,\r\n      uint256 _nonce\r\n    )\r\n      internal\r\n      pure\r\n      returns (\r\n        uint256\r\n      )\r\n    {\r\n      return uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the id for this request\r\n     * @param _keyHash The serviceAgreement ID to be used for this request\r\n     * @param _vRFInputSeed The seed to be passed directly to the VRF\r\n     * @return The id for this request\r\n     *\r\n     * @dev Note that _vRFInputSeed is not the seed passed by the consuming\r\n     * @dev contract, but the one generated by makeVRFInputSeed\r\n     */\r\n    function makeRequestId(\r\n      bytes32 _keyHash,\r\n      uint256 _vRFInputSeed\r\n    )\r\n      internal\r\n      pure\r\n      returns (\r\n        bytes32\r\n      )\r\n    {\r\n      return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\r\n    }\r\n  }\r\n  /** ****************************************************************************\r\n   * @notice Interface for contracts using VRF randomness\r\n   * *****************************************************************************\r\n   * @dev PURPOSE\r\n   *\r\n   * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\r\n   * @dev to Vera the verifier in such a way that Vera can be sure he's not\r\n   * @dev making his output up to suit himself. Reggie provides Vera a public key\r\n   * @dev to which he knows the secret key. Each time Vera provides a seed to\r\n   * @dev Reggie, he gives back a value which is computed completely\r\n   * @dev deterministically from the seed and the secret key.\r\n   *\r\n   * @dev Reggie provides a proof by which Vera can verify that the output was\r\n   * @dev correctly computed once Reggie tells it to her, but without that proof,\r\n   * @dev the output is indistinguishable to her from a uniform random sample\r\n   * @dev from the output space.\r\n   *\r\n   * @dev The purpose of this contract is to make it easy for unrelated contracts\r\n   * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\r\n   * @dev simple access to a verifiable source of randomness.\r\n   * *****************************************************************************\r\n   * @dev USAGE\r\n   *\r\n   * @dev Calling contracts must inherit from VRFConsumerBase, and can\r\n   * @dev initialize VRFConsumerBase's attributes in their constructor as\r\n   * @dev shown:\r\n   *\r\n   * @dev   contract VRFConsumer {\r\n   * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\r\n   * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\r\n   * @dev         <initialization with other arguments goes here>\r\n   * @dev       }\r\n   * @dev   }\r\n   *\r\n   * @dev The oracle will have given you an ID for the VRF keypair they have\r\n   * @dev committed to (let's call it keyHash), and have told you the minimum LINK\r\n   * @dev price for VRF service. Make sure your contract has sufficient LINK, and\r\n   * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\r\n   * @dev want to generate randomness from.\r\n   *\r\n   * @dev Once the VRFCoordinator has received and validated the oracle's response\r\n   * @dev to your request, it will call your contract's fulfillRandomness method.\r\n   *\r\n   * @dev The randomness argument to fulfillRandomness is the actual random value\r\n   * @dev generated from your seed.\r\n   *\r\n   * @dev The requestId argument is generated from the keyHash and the seed by\r\n   * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\r\n   * @dev requests open, you can use the requestId to track which seed is\r\n   * @dev associated with which randomness. See VRFRequestIDBase.sol for more\r\n   * @dev details. (See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\r\n   * @dev if your contract could have multiple requests in flight simultaneously.)\r\n   *\r\n   * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\r\n   * @dev differ. (Which is critical to making unpredictable randomness! See the\r\n   * @dev next section.)\r\n   *\r\n   * *****************************************************************************\r\n   * @dev SECURITY CONSIDERATIONS\r\n   *\r\n   * @dev A method with the ability to call your fulfillRandomness method directly\r\n   * @dev could spoof a VRF response with any random value, so it's critical that\r\n   * @dev it cannot be directly called by anything other than this base contract\r\n   * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\r\n   *\r\n   * @dev For your users to trust that your contract's random behavior is free\r\n   * @dev from malicious interference, it's best if you can write it so that all\r\n   * @dev behaviors implied by a VRF response are executed *during* your\r\n   * @dev fulfillRandomness method. If your contract must store the response (or\r\n   * @dev anything derived from it) and use it later, you must ensure that any\r\n   * @dev user-significant behavior which depends on that stored value cannot be\r\n   * @dev manipulated by a subsequent VRF request.\r\n   *\r\n   * @dev Similarly, both miners and the VRF oracle itself have some influence\r\n   * @dev over the order in which VRF responses appear on the blockchain, so if\r\n   * @dev your contract could have multiple VRF requests in flight simultaneously,\r\n   * @dev you must ensure that the order in which the VRF responses arrive cannot\r\n   * @dev be used to manipulate your contract's user-significant behavior.\r\n   *\r\n   * @dev Since the ultimate input to the VRF is mixed with the block hash of the\r\n   * @dev block in which the request is made, user-provided seeds have no impact\r\n   * @dev on its economic security properties. They are only included for API\r\n   * @dev compatability with previous versions of this contract.\r\n   *\r\n   * @dev Since the block hash of the block which contains the requestRandomness\r\n   * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\r\n   * @dev miner could, in principle, fork the blockchain to evict the block\r\n   * @dev containing the request, forcing the request to be included in a\r\n   * @dev different block with a different hash, and therefore a different input\r\n   * @dev to the VRF. However, such an attack would incur a substantial economic\r\n   * @dev cost. This cost scales with the number of blocks the VRF oracle waits\r\n   * @dev until it calls responds to a request.\r\n   */\r\n  abstract contract VRFConsumerBase is VRFRequestIDBase {\r\n\r\n    /**\r\n     * @notice fulfillRandomness handles the VRF response. Your contract must\r\n     * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\r\n     * @notice principles to keep in mind when implementing your fulfillRandomness\r\n     * @notice method.\r\n     *\r\n     * @dev VRFConsumerBase expects its subcontracts to have a method with this\r\n     * @dev signature, and will call it once it has verified the proof\r\n     * @dev associated with the randomness. (It is triggered via a call to\r\n     * @dev rawFulfillRandomness, below.)\r\n     *\r\n     * @param requestId The Id initially returned by requestRandomness\r\n     * @param randomness the VRF output\r\n     */\r\n    function fulfillRandomness(\r\n      bytes32 requestId,\r\n      uint256 randomness\r\n    )\r\n      internal\r\n      virtual;\r\n\r\n    /**\r\n     * @dev In order to keep backwards compatibility we have kept the user\r\n     * seed field around. We remove the use of it because given that the blockhash\r\n     * enters later, it overrides whatever randomness the used seed provides.\r\n     * Given that it adds no security, and can easily lead to misunderstandings,\r\n     * we have removed it from usage and can now provide a simpler API.\r\n     */\r\n    uint256 constant private USER_SEED_PLACEHOLDER = 0;\r\n\r\n    /**\r\n     * @notice requestRandomness initiates a request for VRF output given _seed\r\n     *\r\n     * @dev The fulfillRandomness method receives the output, once it's provided\r\n     * @dev by the Oracle, and verified by the vrfCoordinator.\r\n     *\r\n     * @dev The _keyHash must already be registered with the VRFCoordinator, and\r\n     * @dev the _fee must exceed the fee specified during registration of the\r\n     * @dev _keyHash.\r\n     *\r\n     * @dev The _seed parameter is vestigial, and is kept only for API\r\n     * @dev compatibility with older versions. It can't *hurt* to mix in some of\r\n     * @dev your own randomness, here, but it's not necessary because the VRF\r\n     * @dev oracle will mix the hash of the block containing your request into the\r\n     * @dev VRF seed it ultimately uses.\r\n     *\r\n     * @param _keyHash ID of public key against which randomness is generated\r\n     * @param _fee The amount of LINK to send with the request\r\n     *\r\n     * @return requestId unique ID for this request\r\n     *\r\n     * @dev The returned requestId can be used to distinguish responses to\r\n     * @dev concurrent requests. It is passed as the first argument to\r\n     * @dev fulfillRandomness.\r\n     */\r\n    function requestRandomness(\r\n      bytes32 _keyHash,\r\n      uint256 _fee\r\n    )\r\n      internal\r\n      returns (\r\n        bytes32 requestId\r\n      )\r\n    {\r\n      LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, USER_SEED_PLACEHOLDER));\r\n      // This is the seed passed to VRFCoordinator. The oracle will mix this with\r\n      // the hash of the block containing this request to obtain the seed/input\r\n      // which is finally passed to the VRF cryptographic machinery.\r\n      uint256 vRFSeed  = makeVRFInputSeed(_keyHash, USER_SEED_PLACEHOLDER, address(this), nonces[_keyHash]);\r\n      // nonces[_keyHash] must stay in sync with\r\n      // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\r\n      // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest).\r\n      // This provides protection against the user repeating their input seed,\r\n      // which would result in a predictable/duplicate output, if multiple such\r\n      // requests appeared in the same block.\r\n      nonces[_keyHash] = nonces[_keyHash] + 1;\r\n      return makeRequestId(_keyHash, vRFSeed);\r\n    }\r\n\r\n    LinkTokenInterface immutable internal LINK;\r\n    address immutable private vrfCoordinator;\r\n\r\n    // Nonces for each VRF key from which randomness has been requested.\r\n    //\r\n    // Must stay in sync with VRFCoordinator[_keyHash][this]\r\n    mapping(bytes32 /* keyHash */ => uint256 /* nonce */) private nonces;\r\n\r\n    /**\r\n     * @param _vrfCoordinator address of VRFCoordinator contract\r\n     * @param _link address of LINK token contract\r\n     *\r\n     * @dev https://docs.chain.link/docs/link-token-contracts\r\n     */\r\n    constructor(\r\n      address _vrfCoordinator,\r\n      address _link\r\n    ) {\r\n      vrfCoordinator = _vrfCoordinator;\r\n      LINK = LinkTokenInterface(_link);\r\n    }\r\n\r\n    // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\r\n    // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\r\n    // the origin of the call\r\n    function rawFulfillRandomness(\r\n      bytes32 requestId,\r\n      uint256 randomness\r\n    )\r\n      external\r\n    {\r\n      require(msg.sender == vrfCoordinator, \"Only VRFCoordinator can fulfill\");\r\n      fulfillRandomness(requestId, randomness);\r\n    }\r\n  }\r\n\r\n  contract DNXILottery is VRFConsumerBase, Ownable {\r\n      \r\n      using SafeMath for uint256;\r\n      \r\n      uint256 public lotteryStart;\r\n      uint256 public lotteryEnd;\r\n      uint256 public totalNumberOfEntries;\r\n      uint256 public totalNumberOfTickets;\r\n      uint256 public numberOfWinners;\r\n\r\n      IERC1155 dnxiToken;\r\n      \r\n      bytes32 internal keyHash;\r\n      uint256 internal fee;\r\n\r\n      mapping(address => uint256) lotteryEntryIndex;\r\n      mapping(uint256 => address) lotteryEntryReversed;\r\n      mapping(uint256 => uint256) lotteryEntries;\r\n      mapping(uint256 => uint256) randomNumbers;\r\n      mapping(uint256 => address) winners;\r\n      uint256 randomCounts;\r\n      \r\n      address lotteryTreasury;\r\n\r\n      bool paused;\r\n      \r\n      constructor(uint256 _lotteryStart, uint256 _lotteryEnd, uint256 _numberOfWinners,  IERC1155 _dnxiToken) VRFConsumerBase(\r\n              0x3d2341ADb2D31f1c5530cDC622016af293177AE0, // VRF Coordinator\r\n              0xb0897686c545045aFc77CF20eC7A532E3120E0F1  // LINK Token\r\n          ) \r\n       {\r\n          keyHash = 0xf86195cf7690c55907b2b611ebb7343a6f649bff128701cc542f0569e2c549da;\r\n          fee = 0.0001 * 10 ** 18; // 0.1 LINK (Varies by network)\r\n          \r\n          lotteryStart = _lotteryStart;\r\n          lotteryEnd = _lotteryEnd;\r\n          totalNumberOfEntries = 0;\r\n          totalNumberOfTickets = 0;\r\n          numberOfWinners = _numberOfWinners;\r\n          paused = true;\r\n          \r\n          lotteryTreasury = address(owner());\r\n          \r\n          dnxiToken = _dnxiToken;\r\n      }\r\n      \r\n      function changeEndTime(uint256 endTime) public onlyOwner {\r\n          lotteryEnd = endTime;\r\n      }\r\n      function changeStartTime(uint256 startTime) public onlyOwner {\r\n          lotteryStart = startTime;\r\n      }\r\n      \r\n      function entry(uint256 _amount) public {\r\n          require (paused == false, \"E01\");\r\n          require (block.timestamp >= lotteryStart, \"E02\");\r\n          require (block.timestamp <= lotteryEnd, \"E03\");\r\n          require (_amount > 0, \"E04\");\r\n          bytes memory b = new bytes(0);\r\n          dnxiToken.safeTransferFrom(msg.sender, address(lotteryTreasury), 1, _amount, b);\r\n          \r\n          if (lotteryEntryIndex[msg.sender] == 0) {\r\n              totalNumberOfEntries = totalNumberOfEntries.add(1);\r\n              lotteryEntryIndex[msg.sender] = totalNumberOfEntries;\r\n              lotteryEntryReversed[totalNumberOfEntries] = msg.sender;\r\n              lotteryEntries[totalNumberOfEntries - 1] = 0;\r\n          }\r\n          \r\n          uint256 entryIndex = lotteryEntryIndex[msg.sender] - 1;\r\n          lotteryEntries[entryIndex] = lotteryEntries[entryIndex].add(_amount);\r\n          totalNumberOfTickets = totalNumberOfTickets.add(_amount);\r\n      }\r\n      \r\n      /** \r\n       * Requests randomness for distribution\r\n       */\r\n      function getRandomNumber() public onlyOwner returns (bytes32 requestId) {\r\n          require(LINK.balanceOf(address(this)) > fee, \"Not enough LINK - fill contract with faucet\");\r\n          return requestRandomness(keyHash, fee);\r\n      }\r\n      \r\n      function fulfillRandomness(bytes32 requestId, uint256 randomness) internal override {\r\n          randomNumbers[randomCounts] = randomness;\r\n          randomCounts = randomCounts.add(1);\r\n      }\r\n      \r\n      function getRandomAt(uint256 r) public view returns (uint256) {\r\n          return randomNumbers[r];\r\n      }\r\n      \r\n      \r\n      function pickWinners() public onlyOwner {\r\n          require(randomCounts >= numberOfWinners, \"E04\");\r\n          for (uint256 i = 0; i < numberOfWinners; i++) {\r\n              uint256 seed = randomNumbers[i];\r\n              uint256 winningTicketIndex = seed % totalNumberOfTickets;\r\n              uint256 countedIndex = 0;\r\n              address winner = address(0);\r\n              for (uint256 j = 0; j < totalNumberOfEntries; j++) {\r\n                  countedIndex = countedIndex.add(lotteryEntries[j]);\r\n                  if (countedIndex >= winningTicketIndex) {\r\n                      winner = lotteryEntryReversed[j+1];\r\n                      break;\r\n                  }\r\n              }\r\n              winners[i] = winner;\r\n          }\r\n      }\r\n      \r\n      function setPaused(bool _paused) public onlyOwner {\r\n          paused = _paused;\r\n      }\r\n      \r\n      function getWinner(uint256 winnerId) public view returns (address) {\r\n          return winners[winnerId];\r\n      }\r\n      \r\n      function withdrawTickets() onlyOwner external {\r\n          bytes memory b = new bytes(0);\r\n          dnxiToken.safeTransferFrom(address(this), address(lotteryTreasury), 1, totalNumberOfTickets, b);\r\n      }\r\n      \r\n      function withdrawFees() onlyOwner external {\r\n          require(payable(msg.sender).send(address(this).balance));\r\n      }\r\n      \r\n      function getTicketsAmountForAddress(address _user) public view returns (uint256) {\r\n          return lotteryEntries[lotteryEntryIndex[_user]-1];\r\n      }\r\n      \r\n      function getTotalEntries() public view returns (uint256) {\r\n          return totalNumberOfTickets;\r\n      }\r\n  }", "ABI": "[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lotteryStart\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_lotteryEnd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_numberOfWinners\",\"type\":\"uint256\"},{\"internalType\":\"contract IERC1155\",\"name\":\"_dnxiToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"changeEndTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"changeStartTime\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"entry\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"r\",\"type\":\"uint256\"}],\"name\":\"getRandomAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getRandomNumber\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"getTicketsAmountForAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTotalEntries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"winnerId\",\"type\":\"uint256\"}],\"name\":\"getWinner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryEnd\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lotteryStart\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfWinners\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pickWinners\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"randomness\",\"type\":\"uint256\"}],\"name\":\"rawFulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNumberOfEntries\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalNumberOfTickets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawTickets\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "DNXILottery", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000006462651000000000000000000000000000000000000000000000000000000000648a1c400000000000000000000000000000000000000000000000000000000000000064000000000000000000000000e97bf54cc139b88c533759dfb16b2bd73dca8264", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://3d809c7805e3809c288e45d9469489d6647b3de1306768d067d572df87b91483"}