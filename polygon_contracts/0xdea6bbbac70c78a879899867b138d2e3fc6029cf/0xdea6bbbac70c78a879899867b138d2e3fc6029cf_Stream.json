{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nlibrary Address {\r\n    /**\r\n     * @dev The ETH balance of the account is not enough to perform the operation.\r\n     */\r\n    error AddressInsufficientBalance(address account);\r\n\r\n    /**\r\n     * @dev There's no code at `target` (it is not a contract).\r\n     */\r\n    error AddressEmptyCode(address target);\r\n\r\n    /**\r\n     * @dev A call to an address target failed. The target may have reverted.\r\n     */\r\n    error FailedInnerCall();\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        if (address(this).balance < amount) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        if (!success) {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason or custom error, it is bubbled\r\n     * up by this function (like regular Solidity function calls). However, if\r\n     * the call reverted with no returned reason, this function reverts with a\r\n     * {FailedInnerCall} error.\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        if (address(this).balance < value) {\r\n            revert AddressInsufficientBalance(address(this));\r\n        }\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\r\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\r\n     * unsuccessful call.\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata\r\n    ) internal view returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            // only check if target is a contract if the call was successful and the return data is empty\r\n            // otherwise we already know that it was a contract\r\n            if (returndata.length == 0 && target.code.length == 0) {\r\n                revert AddressEmptyCode(target);\r\n            }\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\r\n     * revert reason or with a default {FailedInnerCall} error.\r\n     */\r\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\r\n        if (!success) {\r\n            _revert(returndata);\r\n        } else {\r\n            return returndata;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\r\n     */\r\n    function _revert(bytes memory returndata) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert FailedInnerCall();\r\n        }\r\n    }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n    using Address for address;\r\n\r\n    /**\r\n     * @dev An operation with an ERC20 token failed.\r\n     */\r\n    error SafeERC20FailedOperation(address token);\r\n\r\n    /**\r\n     * @dev Indicates a failed `decreaseAllowance` request.\r\n     */\r\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\r\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\r\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\r\n        uint256 oldAllowance = token.allowance(address(this), spender);\r\n        forceApprove(token, spender, oldAllowance + value);\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\r\n     * value, non-reverting calls are assumed to be successful.\r\n     */\r\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\r\n        unchecked {\r\n            uint256 currentAllowance = token.allowance(address(this), spender);\r\n            if (currentAllowance < requestedDecrease) {\r\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\r\n            }\r\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\r\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\r\n     * to be set to zero before setting it to a non-zero value, such as USDT.\r\n     */\r\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\r\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\r\n\r\n        if (!_callOptionalReturnBool(token, approvalCall)) {\r\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\r\n            _callOptionalReturn(token, approvalCall);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n        // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n        bytes memory returndata = address(token).functionCall(data);\r\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\r\n            revert SafeERC20FailedOperation(address(token));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     *\r\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\r\n     */\r\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\r\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\r\n        // and not revert is the subcall reverts.\r\n\r\n        (bool success, bytes memory returndata) = address(token).call(data);\r\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the value of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\r\n     * caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 value) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\r\n     * allowance mechanism. `value` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\r\n}\r\n\r\n/*\r\n**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n *\r\n * ==== Security Considerations\r\n *\r\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\r\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\r\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\r\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\r\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\r\n * generally recommended is:\r\n *\r\n * ```solidity\r\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\r\n *     doThing(..., value);\r\n * }\r\n *\r\n * function doThing(..., uint256 value) public {\r\n *     token.safeTransferFrom(msg.sender, address(this), value);\r\n *     ...\r\n * }\r\n * ```\r\n *\r\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\r\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\r\n * {SafeERC20-safeTransferFrom}).\r\n *\r\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\r\n * contracts should have entry points that don't rely on permit.\r\n */\r\ninterface IERC20PermitDAI {\r\n    /**\r\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     *\r\n     * CAUTION: See Security Considerations above.\r\n     */\r\n\r\n    function permit(\r\n        address holder,\r\n        address spender,\r\n        uint256 nonce,\r\n        uint256 expiry,\r\n        bool allowed,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n    \r\n\r\n    /**\r\n     * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n    function nonces(address owner) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n    // solhint-disable-next-line func-name-mixedcase\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n\r\n// interface of the History contract - dataBase\r\n\r\ninterface IHistory {\r\n\r\n    function getStreamToken(uint _id) external view returns (address);\r\n\r\n    struct WithDraw {\r\n        uint256 amount;\r\n        uint256 timeW;\r\n    }\r\n\r\n    struct StreamHistory {\r\n\r\n        uint256 deposit;\r\n        \r\n        uint64 startTime;\r\n        uint64 stopTime;\r\n        uint64 blockTime;\r\n        uint64 cancelTime;\r\n\r\n        uint256 recipientAmountOnCancel;\r\n\r\n        address sender;\r\n        uint32 numberOfWithdraws;\r\n\r\n        address recipient;\r\n        uint8 status; //1 canceled, 2 paused\r\n        uint8 whoCancel;\r\n\r\n        string purpose;\r\n\r\n    }\r\n\r\n    function addUserId(address _user, uint256 _id) external;\r\n\r\n    struct StreamDetails {\r\n        address tokenAddress;\r\n        uint256 deposit;\r\n        address recipient;\r\n        address sender;\r\n        uint64[3] time;\r\n        uint8 whoCancel;\r\n    } \r\n \r\n    function addStream(uint256 streamId, StreamDetails calldata streamDetails, string memory title) external;\r\n\r\n\r\n    function addWithdraw(uint256 _id, uint256 _amount) external;\r\n\r\n    function addCancel(uint256 _id, uint256 _amount) external;\r\n\r\n    function getHistoryStream(uint256 _id) external view returns (StreamHistory memory streamHistory);\r\n}\r\n\r\nabstract contract IERC2771Recipient {\r\n\r\n    /**\r\n     * :warning: **Warning** :warning: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.\r\n     * @param forwarder The address of the Forwarder contract that is being used.\r\n     * @return isTrustedForwarder `true` if the Forwarder is trusted to forward relayed transactions by this Recipient.\r\n     */\r\n    function isTrustedForwarder(address forwarder) public virtual view returns (bool);\r\n\r\n    /**\r\n     * @notice Use this method the contract anywhere instead of msg.sender to support relayed transactions.\r\n     * @return sender The real sender of this call.\r\n     * For a call that came through the Forwarder the real sender is extracted from the last 20 bytes of the `msg.data`.\r\n     * Otherwise simply returns `msg.sender`.\r\n     */\r\n    function _msgSender() internal virtual view returns (address);\r\n\r\n    /**\r\n     * @notice Use this method in the contract instead of `msg.data` when difference matters (hashing, signature, etc.)\r\n     * @return data The real `msg.data` of this call.\r\n     * For a call that came through the Forwarder, the real sender address was appended as the last 20 bytes\r\n     * of the `msg.data` - so this method will strip those 20 bytes off.\r\n     * Otherwise (if the call was made directly and not through the forwarder) simply returns `msg.data`.\r\n     */\r\n    function _msgData() internal virtual view returns (bytes calldata);\r\n}\r\n\r\n// abstract contract Context {\r\n//     function _msgSender() internal view virtual returns (address) {\r\n//         return msg.sender;\r\n//     }\r\n\r\n//     function _msgData() internal view virtual returns (bytes calldata) {\r\n//         return msg.data;\r\n//     }\r\n// }\r\n\r\nabstract contract ERC2771Recipient is IERC2771Recipient {\r\n\r\n    /*\r\n     * Forwarder singleton we accept calls from\r\n     */\r\n    address private _trustedForwarder;\r\n\r\n    /**\r\n     * :warning: **Warning** :warning: The Forwarder can have a full control over your Recipient. Only trust verified Forwarder.\r\n     * @notice Method is not a required method to allow Recipients to trust multiple Forwarders. Not recommended yet.\r\n     * @return forwarder The address of the Forwarder contract that is being used.\r\n     */\r\n    function getTrustedForwarder() public virtual view returns (address forwarder){\r\n        return _trustedForwarder;\r\n    }\r\n\r\n    function _setTrustedForwarder(address _forwarder) internal {\r\n        _trustedForwarder = _forwarder;\r\n    }\r\n\r\n    /// @inheritdoc IERC2771Recipient\r\n    function isTrustedForwarder(address forwarder) public virtual override view returns (bool) {\r\n        return forwarder == _trustedForwarder;\r\n    }\r\n\r\n    /// @inheritdoc IERC2771Recipient\r\n    function _msgSender() internal override virtual view returns (address ret) {\r\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\r\n            // At this point we know that the sender is a trusted forwarder,\r\n            // so we trust that the last bytes of msg.data are the verified sender address.\r\n            // extract sender address from the end of msg.data\r\n            assembly {\r\n                ret := shr(96, calldataload(sub(calldatasize(), 20)))\r\n            }\r\n        } else {\r\n            ret = msg.sender;\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IERC2771Recipient\r\n    function _msgData() internal override virtual view returns (bytes calldata ret) {\r\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\r\n            return msg.data[0 : msg.data.length - 20];\r\n        } else {\r\n            return msg.data;\r\n        }\r\n    }\r\n}\r\n\r\n\r\nabstract contract Ownable is ERC2771Recipient {\r\n\r\n\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nabstract contract Pausable is Ownable {\r\n    /**\r\n     * @dev Emitted when the pause is triggered by `account`.\r\n     */\r\n    event Paused(address account);\r\n\r\n    /**\r\n     * @dev Emitted when the pause is lifted by `account`.\r\n     */\r\n    event Unpaused(address account);\r\n\r\n    bool private _paused;\r\n\r\n    /**\r\n     * @dev Initializes the contract in unpaused state.\r\n     */\r\n    constructor () {\r\n        //_paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the contract is paused, and false otherwise.\r\n     */\r\n    function paused() public view virtual returns (bool) {\r\n        return _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Pausable: paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Pausable: not paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Triggers stopped state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must not be paused.\r\n     */\r\n    function pause() external onlyOwner whenNotPaused {\r\n        _paused = true;\r\n        emit Paused(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Returns to normal state.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - The contract must be paused.\r\n     */\r\n    function unpause() external onlyOwner whenPaused {\r\n        _paused = false;\r\n        emit Unpaused(_msgSender());\r\n    }\r\n}\r\n\r\n/**\r\n *  @title  Stream payments gasless base contract \r\n *  @notice Users can create steams in stable coins.\r\n *          Users can:\r\n *          - stream tokens\r\n *          - use batch streams\r\n *          - stop stream\r\n *          - withdraw from stream\r\n */\r\n\r\n\r\ncontract Stream is Pausable {\r\n\r\n    using SafeERC20 for IERC20;\r\n\r\n    /*****************/\r\n    /*** Variables ***/\r\n    /*****************/\r\n\r\n    /**\r\n     * @notice  Fee balance.\r\n     */\r\n    uint256 public contractFeeBalance;\r\n    /**\r\n     * @notice  Next stream Id.\r\n     */\r\n    uint256 public nextStreamId;\r\n    /**\r\n     * @notice Version number.\r\n     */\r\n    string public versionRecipient = \"3.0.0\";\r\n    /**\r\n     * @notice  History contract interface.\r\n     */\r\n    IHistory public  history;\r\n    /**\r\n     * @notice  ERC20 Permit contract interface.\r\n     */\r\n    IERC20PermitDAI public Ierc20permitdai;\r\n\r\n    /***********************/\r\n    /*** State Variables ***/\r\n    /***********************/\r\n\r\n    /// @dev Mapping `Id => Stream info`.\r\n    mapping(uint256 => Stream) private streams;\r\n\r\n    /*******************/\r\n    /*** Constructor ***/\r\n    /*******************/\r\n    /*\r\n     *  @notice Deploys the Stream contract.\r\n     *  @param _history address of the history contract which will be saved all parameters of users streams.\r\n     *  @param _nextStreamId Id number of the first stream.\r\n     *  @param _forwarder address of the forwarder contract for meta transactions.\r\n     */\r\n\r\n    constructor(address _history, uint _nextStreamId, address forwarder)  {\r\n        require(_history != address(0), \"zero address\");\r\n        require(_nextStreamId != 0, \"Stream id is zero\");\r\n        history = IHistory(_history);\r\n        nextStreamId = _nextStreamId;\r\n        _setTrustedForwarder(forwarder);\r\n    }\r\n\r\n    /*****************/\r\n    /*** Modifiers ***/\r\n    /*****************/\r\n\r\n    modifier onlySenderOrRecipient(uint256 streamId) {\r\n        IHistory.StreamHistory memory s = IHistory(history).getHistoryStream(streamId);\r\n\r\n        require(\r\n            _msgSender() == s.sender || _msgSender() == s.recipient,\r\n            \"caller is not the sender/recipient\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyRecipient(uint256 streamId) {\r\n        IHistory.StreamHistory memory s = IHistory(history).getHistoryStream(streamId);\r\n        require(_msgSender() == s.recipient,\r\n            \"caller is not the recipient\"\r\n        );\r\n        _;\r\n    }\r\n\r\n\r\n    modifier streamExists(uint256 streamId) {\r\n        require(streams[streamId].isEntity, \"stream does not exist\");\r\n        _;\r\n    }\r\n\r\n    // Structs\r\n    struct Stream {\r\n        uint256 ratePerSecond;\r\n        uint256 remainingBalance;\r\n        uint256 remainder;\r\n        bool isEntity;\r\n    }\r\n\r\n\r\n    struct CreateStreamLocalVars {\r\n\r\n        uint256 duration;\r\n        uint256 ratePerSecond;\r\n    }\r\n\r\n    struct BalanceOfLocalVars {\r\n\r\n        uint256 recipientBalance;\r\n        uint256 withdrawalAmount;\r\n        uint256 senderBalance;\r\n    }\r\n\r\n    // Events\r\n\r\n    event withdrawFee(\r\n        uint256 amount,\r\n        address indexed reciver\r\n    );\r\n\r\n\r\n    address public bank;\r\n\r\n    function setBank(address _newBank) external onlyOwner {\r\n        bank = _newBank;\r\n    }\r\n\r\n\r\n    \r\n\r\n    struct Sig {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    mapping (address => bool) public acceptToken;\r\n\r\n    function addTokenForStream(address _token) external onlyOwner{\r\n        require( _token != address(0));\r\n        require(acceptToken[_token] == false);\r\n        acceptToken[_token] = true;\r\n    }\r\n\r\n    function removeToken (address _token) external onlyOwner{\r\n        require(acceptToken[_token]);\r\n        acceptToken[_token] = false;\r\n    }\r\n\r\n    address public daiTokenAddress = 0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063;\r\n\r\n    // IHistory.StreamHistory memory s = IHistory(history).getHistoryStream(streamId)\r\n\r\n    function createStream(IHistory.StreamDetails calldata streamDetails, Sig calldata sig, string memory title) whenNotPaused public {\r\n        uint fee = feeCharge(streamDetails.deposit);\r\n\r\n        //uint256 realDeposit = streamDetails.deposit + fee;\r\n        require(streamDetails.deposit >= 1e16, \"Wrong deposit\");\r\n\r\n\r\n        unchecked{\r\n            contractFeeBalance = contractFeeBalance + fee;\r\n        }\r\n        require (streamDetails.sender == _msgSender(), \"Wrong sender\");\r\n        require (acceptToken[streamDetails.tokenAddress], \"Wrong token\");\r\n        require(streamDetails.whoCancel < 4, \"Invalid input\");\r\n        require(streamDetails.recipient != address(0), \"stream to the zero address\");\r\n        require(streamDetails.recipient != address(this), \"stream to the contract itself\");\r\n        require(streamDetails.recipient != _msgSender(), \"stream to the caller\");\r\n        require(streamDetails.deposit != 0, \"deposit is zero\");\r\n        require(streamDetails.time[0] >= block.timestamp, \"startTime before block.timestamp\");\r\n        require(streamDetails.time[1] > streamDetails.time[0], \"Invalid stop/start time\");\r\n        require(streamDetails.time[2] == 0 || streamDetails.time[2] <= streamDetails.time[0], \"Invalid blockTime\");\r\n\r\n        IERC20 token = IERC20(streamDetails.tokenAddress);\r\n\r\n        if (daiTokenAddress == streamDetails.tokenAddress) {\r\n            \r\n            Ierc20permitdai = IERC20PermitDAI(streamDetails.tokenAddress);\r\n            uint nonce = Ierc20permitdai.nonces(_msgSender());\r\n            \r\n            Ierc20permitdai.permit(_msgSender(), address(this), nonce, block.timestamp + 15, true, sig.v, sig.r, sig.s);\r\n        }\r\n\r\n        \r\n\r\n        else revert();\r\n        \r\n        token.safeTransferFrom(msg.sender, address(this), streamDetails.deposit);\r\n        token.safeTransferFrom(msg.sender, bank, fee);// TODO SUCEESS\r\n        \r\n        CreateStreamLocalVars memory vars;\r\n\r\n        unchecked{\r\n            vars.duration = streamDetails.time[1] - streamDetails.time[0];\r\n        }\r\n\r\n        /* Without this, the rate per second would be zero. */\r\n        require(streamDetails.deposit >= vars.duration, \"deposit smaller than time delta\");\r\n\r\n        uint256 rem;// remainder\r\n\r\n        if (streamDetails.deposit % vars.duration == 0) {\r\n            rem = 0;\r\n        }\r\n\r\n        else {\r\n            rem = streamDetails.deposit % vars.duration;\r\n        }\r\n\r\n        vars.ratePerSecond = streamDetails.deposit / vars.duration;\r\n\r\n        /* Create and store the stream object. */\r\n        uint256 streamId = nextStreamId;\r\n        streams[streamId] = Stream({\r\n            remainingBalance: streamDetails.deposit,\r\n            isEntity: true,\r\n            ratePerSecond: vars.ratePerSecond,\r\n            remainder: rem\r\n\r\n        });\r\n\r\n        /* Increment the next stream id. */\r\n        unchecked{\r\n            nextStreamId = nextStreamId + 1;\r\n        }\r\n\r\n        \r\n\r\n        addToHistory(\r\n            streamId,\r\n            streamDetails,\r\n            title\r\n            \r\n        );\r\n\r\n        \r\n    }\r\n\r\n    \r\n   \r\n\r\n    uint public feeRate = 100;\r\n\r\n    function changeFeeRate(uint _newFeeRate) external onlyOwner {\r\n        require(feeRate <= 2000, \"FeeRate too large\");\r\n        feeRate = _newFeeRate;\r\n    }\r\n\r\n\r\n    function feeCharge(uint256 deposit) public view returns (uint256){//TODO change to internal\r\n        return deposit * feeRate / 10000;\r\n    }\r\n\r\n\r\n    function addToHistory(uint256 streamId, IHistory.StreamDetails calldata streamDetails, string memory title) internal {\r\n        IHistory(history).addStream(\r\n            streamId,\r\n            streamDetails,\r\n            title\r\n        );\r\n    }\r\n\r\n\r\n    function noContracts(address _sender) internal view {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_sender)\r\n        }\r\n        require(size == 0, \"No contracts\");\r\n    }\r\n\r\n\r\n    function getStream(uint256 id) external view returns (Stream memory stream){\r\n        return streams[id];\r\n    }\r\n\r\n    // 92262 gas 60148\r\n    function cancelStream(uint256 streamId)\r\n    external\r\n    streamExists(streamId)\r\n    onlySenderOrRecipient(streamId)\r\n    returns (bool)\r\n    {\r\n\r\n        cancelStreamInternal(streamId);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function cancelStreamInternal(uint256 streamId) private {\r\n\r\n        IHistory.StreamHistory memory s = IHistory(history).getHistoryStream(streamId);\r\n        address streamToken = IHistory(history).getStreamToken(streamId);\r\n\r\n        require(s.blockTime <= block.timestamp, \"stream blocked\");\r\n        require(s.stopTime >= block.timestamp, \"stream finished\");\r\n\r\n\r\n        if (_msgSender() == s.sender && s.whoCancel != 1 && s.whoCancel != 3) {\r\n            revert();\r\n        }\r\n        if (_msgSender() == s.recipient && s.whoCancel != 2 && s.whoCancel != 3) {\r\n            revert();\r\n        }\r\n\r\n\r\n        address tokenAddress = streamToken;\r\n        IERC20 token = IERC20(tokenAddress);\r\n\r\n        uint256 senderBalance = balanceOf(streamId, s.sender);\r\n        uint256 recipientBalance = balanceOf(streamId, s.recipient);\r\n\r\n\r\n        history.addCancel(streamId, recipientBalance);\r\n\r\n        delete streams[streamId];\r\n\r\n\r\n        if (recipientBalance != 0) {\r\n            token.safeTransfer(s.recipient, recipientBalance);\r\n            \r\n        }\r\n\r\n\r\n        if (senderBalance != 0) {\r\n            token.safeTransfer(s.sender, senderBalance);\r\n           \r\n        }\r\n\r\n    }\r\n\r\n    function balanceOf(uint256 streamId, address who) public view streamExists(streamId) returns (uint256 balance) {\r\n        IHistory.StreamHistory memory s = IHistory(history).getHistoryStream(streamId);\r\n        Stream memory stream = streams[streamId];\r\n        BalanceOfLocalVars memory vars;\r\n\r\n        uint256 delta = deltaOf(streamId);\r\n        vars.recipientBalance = delta * stream.ratePerSecond + stream.remainder;\r\n\r\n        /*\r\n         * If the stream `balance` does not equal `deposit`, it means there have been withdrawals.\r\n         * We have to subtract the total amount withdrawn from the amount of money that has been\r\n         * streamed until now.\r\n         */\r\n        if (s.deposit > stream.remainingBalance) {\r\n            vars.withdrawalAmount = s.deposit - stream.remainingBalance;\r\n\r\n            vars.recipientBalance = vars.recipientBalance - vars.withdrawalAmount;\r\n\r\n        }\r\n\r\n        if (who == s.recipient) return vars.recipientBalance;\r\n        if (who == s.sender) {\r\n            vars.senderBalance = stream.remainingBalance - vars.recipientBalance;\r\n\r\n            return vars.senderBalance;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Calculate current stream time\r\n    function deltaOf(uint256 streamId) internal view streamExists(streamId) returns (uint256 delta) {\r\n\r\n        IHistory.StreamHistory memory s = IHistory(history).getHistoryStream(streamId);\r\n\r\n        if (block.timestamp <= s.startTime) return 0;\r\n\r\n        if (block.timestamp < s.stopTime) return block.timestamp - s.startTime;\r\n\r\n        return s.stopTime - s.startTime;\r\n    }\r\n\r\n    /*******************************/\r\n    /*** External View Functions ***/\r\n    /*******************************/\r\n\r\n    /**************************/\r\n    /*** Internal Functions ***/\r\n    /**************************/\r\n\r\n\r\n    function withdrawFromStream(uint256 streamId, uint256 amount)\r\n    external\r\n        //whenNotPaused\r\n    streamExists(streamId)\r\n    onlyRecipient(streamId)\r\n    returns (bool)\r\n    {\r\n        require(amount != 0, \"amount is zero\");\r\n\r\n\r\n        IHistory.StreamHistory memory s = IHistory(history).getHistoryStream(streamId);\r\n        address streamToken = IHistory(history).getStreamToken(streamId);\r\n        require(s.startTime <= block.timestamp, \"stream not started\");\r\n        uint256 balance = balanceOf(streamId, s.recipient);\r\n\r\n        require(balance >= amount, \"amount exceeds the available balance\");\r\n        address recipient = s.recipient;\r\n        \r\n        withdrawFromStreamInternal(streamId, amount, recipient, streamToken);\r\n\r\n        history.addWithdraw(streamId, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdrawFromStreamInternal(uint256 streamId, uint256 amount, address recipient, address tokenAddress) internal {\r\n         \r\n        Stream memory stream = streams[streamId];\r\n        \r\n        uint256 rem2 = streams[streamId].remainder;\r\n        //streams[streamId].remainingBalance = stream.remainingBalance - amount;\r\n        streams[streamId].remainingBalance = stream.remainingBalance + rem2 - amount;// TODO check\r\n        streams[streamId].remainder = 0;\r\n\r\n        if (streams[streamId].remainingBalance == 0) delete streams[streamId];\r\n        IERC20 token = IERC20(tokenAddress);\r\n        token.safeTransfer(recipient, amount - 5e15);\r\n        token.safeTransfer(address(this), 5e15);\r\n        \r\n\r\n\r\n    }\r\n\r\n    /**************************/\r\n    /*** Admin   Functions  ***/\r\n    /**************************/\r\n\r\n    struct AdminWithdraw {\r\n        uint amount;\r\n        uint time;\r\n        address who;\r\n\r\n    }\r\n\r\n    uint public numberOfFeeWithdraws;\r\n    mapping(uint256 => AdminWithdraw) public withdraws;\r\n    // WithDraw fees  \r\n\r\n    function withdrawFeeForHolders(uint256 amount, address reciver) external onlyOwner returns (bool){\r\n        require(amount <= contractFeeBalance);\r\n        require(reciver != address(0));\r\n        require(amount > 0);\r\n        ++numberOfFeeWithdraws;\r\n\r\n        withdraws[numberOfFeeWithdraws] = AdminWithdraw({\r\n            amount: amount,\r\n            time: block.timestamp,\r\n            who: reciver\r\n\r\n        });\r\n\r\n        contractFeeBalance = contractFeeBalance - amount;\r\n        (bool success,) = reciver.call{value: amount}(\"\");\r\n        require(success, \"Failed to send Ether\");\r\n\r\n        emit withdrawFee(amount, reciver);\r\n        return true;\r\n    }\r\n\r\n// Batch streams\r\n    // function batchStream(\r\n\r\n    //     uint256[] calldata deposit,\r\n    //     address payable[] calldata recipient,\r\n    //     uint64[3][] calldata time,\r\n    //     uint8[] calldata whoCancel, \r\n    //     string[] memory title\r\n\r\n    //     ) external whenNotPaused returns (bool){\r\n\r\n    //    uint len = deposit.length;\r\n\r\n    //    require (len == recipient.length);\r\n    //    require (len == whoCancel.length);\r\n    //    require (len == time.length);\r\n    //    require (len == title.length);\r\n\r\n    //         for (uint i; i < len; ) {\r\n\r\n    //                 createStream\r\n    //                     (deposit[i],\r\n    //                     recipient [i],\r\n    //                     time[i][0],\r\n    //                     time[i][1], \r\n    //                     time[i][2], \r\n    //                     whoCancel[i], \r\n    //                     title[i]);\r\n\r\n    //                 unchecked { ++i; }\r\n    //         }\r\n\r\n    //     return true;\r\n    // }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_history\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_nextStreamId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"SafeERC20FailedOperation\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"reciver\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"Ierc20permitdai\",\"outputs\":[{\"internalType\":\"contract IERC20PermitDAI\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"acceptToken\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"addTokenForStream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bank\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"}],\"name\":\"cancelStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_newFeeRate\",\"type\":\"uint256\"}],\"name\":\"changeFeeRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractFeeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"uint64[3]\",\"name\":\"time\",\"type\":\"uint64[3]\"},{\"internalType\":\"uint8\",\"name\":\"whoCancel\",\"type\":\"uint8\"}],\"internalType\":\"struct IHistory.StreamDetails\",\"name\":\"streamDetails\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"internalType\":\"struct Stream.Sig\",\"name\":\"sig\",\"type\":\"tuple\"},{\"internalType\":\"string\",\"name\":\"title\",\"type\":\"string\"}],\"name\":\"createStream\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"daiTokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"feeCharge\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getStream\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"ratePerSecond\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainingBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"remainder\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isEntity\",\"type\":\"bool\"}],\"internalType\":\"struct Stream.Stream\",\"name\":\"stream\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTrustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"history\",\"outputs\":[{\"internalType\":\"contract IHistory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextStreamId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"numberOfFeeWithdraws\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newBank\",\"type\":\"address\"}],\"name\":\"setBank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"versionRecipient\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"reciver\",\"type\":\"address\"}],\"name\":\"withdrawFeeForHolders\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"streamId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFromStream\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdraws\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"who\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "Stream", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000c107ab6ebc7024a1e6123a5ab0d48d6af8a0e4c10000000000000000000000000000000000000000000000000000000000000001000000000000000000000000b2b5841dbef766d4b521221732f9b618fcf34a87", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://452928569d7a46ef1e9e3a8404c2279ea3736db068b917eb72a2a40bf41f7927"}