{"SourceCode": "// Sources flattened with hardhat v2.9.1 https://hardhat.org\r\n// SPDX-License-Identifier: AGPL-3.0-only\r\n\r\n// File @rari-capital/solmate/src/tokens/ERC20.sol@v6.2.0\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                  EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n\r\n// File @rari-capital/solmate/src/utils/ReentrancyGuard.sol@v6.2.0\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Gas optimized reentrancy protection for smart contracts.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\r\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\r\nabstract contract ReentrancyGuard {\r\n    uint256 private reentrancyStatus = 1;\r\n\r\n    modifier nonReentrant() {\r\n        require(reentrancyStatus == 1, \"REENTRANCY\");\r\n\r\n        reentrancyStatus = 2;\r\n\r\n        _;\r\n\r\n        reentrancyStatus = 1;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/libraries/RebaseLibrary.sol\r\n\r\npragma solidity ^0.8;\r\n\r\nstruct Rebase {\r\n    uint128 elastic;\r\n    uint128 base;\r\n}\r\n\r\n/// @notice A rebasing library\r\nlibrary RebaseLibrary {\r\n    /// @notice Calculates the base value in relationship to `elastic` and `total`.\r\n    function toBase(Rebase memory total, uint256 elastic) internal pure returns (uint256 base) {\r\n        if (total.elastic == 0) {\r\n            base = elastic;\r\n        } else {\r\n            base = (elastic * total.base) / total.elastic;\r\n        }\r\n    }\r\n\r\n    /// @notice Calculates the elastic value in relationship to `base` and `total`.\r\n    function toElastic(Rebase memory total, uint256 base) internal pure returns (uint256 elastic) {\r\n        if (total.base == 0) {\r\n            elastic = base;\r\n        } else {\r\n            elastic = (base * total.elastic) / total.base;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/IBentoBoxMinimal.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Minimal BentoBox vault interface.\r\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\r\ninterface IBentoBoxMinimal {\r\n    /// @notice Balance per ERC-20 token per account in shares.\r\n    function balanceOf(address, address) external view returns (uint256);\r\n\r\n    /// @dev Helper function to represent an `amount` of `token` in shares.\r\n    /// @param token The ERC-20 token.\r\n    /// @param amount The `token` amount.\r\n    /// @param roundUp If the result `share` should be rounded up.\r\n    /// @return share The token amount represented in shares.\r\n    function toShare(\r\n        address token,\r\n        uint256 amount,\r\n        bool roundUp\r\n    ) external view returns (uint256 share);\r\n\r\n    /// @dev Helper function to represent shares back into the `token` amount.\r\n    /// @param token The ERC-20 token.\r\n    /// @param share The amount of shares.\r\n    /// @param roundUp If the result should be rounded up.\r\n    /// @return amount The share amount back into native representation.\r\n    function toAmount(\r\n        address token,\r\n        uint256 share,\r\n        bool roundUp\r\n    ) external view returns (uint256 amount);\r\n\r\n    /// @notice Registers this contract so that users can approve it for BentoBox.\r\n    function registerProtocol() external;\r\n\r\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\r\n    /// @param token The ERC-20 token to deposit.\r\n    /// @param from which account to pull the tokens.\r\n    /// @param to which account to push the tokens.\r\n    /// @param amount Token amount in native representation to deposit.\r\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\r\n    /// @return amountOut The amount deposited.\r\n    /// @return shareOut The deposited amount represented in shares.\r\n    function deposit(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    /// @notice Withdraws an amount of `token` from a user account.\r\n    /// @param token_ The ERC-20 token to withdraw.\r\n    /// @param from which user to pull the tokens.\r\n    /// @param to which user to push the tokens.\r\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\r\n    /// @param share Like above, but `share` takes precedence over `amount`.\r\n    function withdraw(\r\n        address token_,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 share\r\n    ) external returns (uint256 amountOut, uint256 shareOut);\r\n\r\n    /// @notice Transfer shares from a user account to another one.\r\n    /// @param token The ERC-20 token to transfer.\r\n    /// @param from which user to pull the tokens.\r\n    /// @param to which user to push the tokens.\r\n    /// @param share The amount of `token` in shares.\r\n    function transfer(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 share\r\n    ) external;\r\n\r\n    /// @dev Reads the Rebase `totals`from storage for a given token\r\n    function totals(address token) external view returns (Rebase memory total);\r\n\r\n    /// @dev Approves users' BentoBox assets to a \"master\" contract.\r\n    function setMasterContractApproval(\r\n        address user,\r\n        address masterContract,\r\n        bool approved,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) external;\r\n}\r\n\r\n\r\n// File contracts/interfaces/IMasterDeployer.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Trident pool deployer interface.\r\ninterface IMasterDeployer {\r\n    function barFee() external view returns (uint256);\r\n\r\n    function barFeeTo() external view returns (address);\r\n\r\n    function bento() external view returns (address);\r\n\r\n    function migrator() external view returns (address);\r\n\r\n    function pools(address pool) external view returns (bool);\r\n\r\n    function deployPool(address factory, bytes calldata deployData) external returns (address);\r\n}\r\n\r\n\r\n// File contracts/interfaces/IPool.sol\r\n\r\npragma solidity >=0.5.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n/// @notice Trident pool interface.\r\ninterface IPool {\r\n    /// @notice Executes a swap from one token to another.\r\n    /// @dev The input tokens must've already been sent to the pool.\r\n    /// @param data ABI-encoded params that the pool requires.\r\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\r\n    function swap(bytes calldata data) external returns (uint256 finalAmountOut);\r\n\r\n    /// @notice Executes a swap from one token to another with a callback.\r\n    /// @dev This function allows borrowing the output tokens and sending the input tokens in the callback.\r\n    /// @param data ABI-encoded params that the pool requires.\r\n    /// @return finalAmountOut The amount of output tokens that were sent to the user.\r\n    function flashSwap(bytes calldata data) external returns (uint256 finalAmountOut);\r\n\r\n    /// @notice Mints liquidity tokens.\r\n    /// @param data ABI-encoded params that the pool requires.\r\n    /// @return liquidity The amount of liquidity tokens that were minted for the user.\r\n    function mint(bytes calldata data) external returns (uint256 liquidity);\r\n\r\n    /// @notice Burns liquidity tokens.\r\n    /// @dev The input LP tokens must've already been sent to the pool.\r\n    /// @param data ABI-encoded params that the pool requires.\r\n    /// @return withdrawnAmounts The amount of various output tokens that were sent to the user.\r\n    function burn(bytes calldata data) external returns (TokenAmount[] memory withdrawnAmounts);\r\n\r\n    /// @notice Burns liquidity tokens for a single output token.\r\n    /// @dev The input LP tokens must've already been sent to the pool.\r\n    /// @param data ABI-encoded params that the pool requires.\r\n    /// @return amountOut The amount of output tokens that were sent to the user.\r\n    function burnSingle(bytes calldata data) external returns (uint256 amountOut);\r\n\r\n    /// @return A unique identifier for the pool type.\r\n    function poolIdentifier() external pure returns (bytes32);\r\n\r\n    /// @return An array of tokens supported by the pool.\r\n    function getAssets() external view returns (address[] memory);\r\n\r\n    /// @notice Simulates a trade and returns the expected output.\r\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\r\n    /// @param data ABI-encoded params that the pool requires.\r\n    /// @return finalAmountOut The amount of output tokens that will be sent to the user if the trade is executed.\r\n    function getAmountOut(bytes calldata data) external view returns (uint256 finalAmountOut);\r\n\r\n    /// @notice Simulates a trade and returns the expected output.\r\n    /// @dev The pool does not need to include a trade simulator directly in itself - it can use a library.\r\n    /// @param data ABI-encoded params that the pool requires.\r\n    /// @return finalAmountIn The amount of input tokens that are required from the user if the trade is executed.\r\n    function getAmountIn(bytes calldata data) external view returns (uint256 finalAmountIn);\r\n\r\n    /// @dev This event must be emitted on all swaps.\r\n    event Swap(address indexed recipient, address indexed tokenIn, address indexed tokenOut, uint256 amountIn, uint256 amountOut);\r\n\r\n    /// @dev This struct frames output tokens for burns.\r\n    struct TokenAmount {\r\n        address token;\r\n        uint256 amount;\r\n    }\r\n}\r\n\r\n\r\n// File contracts/interfaces/ITridentCallee.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Trident pool callback interface.\r\ninterface ITridentCallee {\r\n    function tridentSwapCallback(bytes calldata data) external;\r\n\r\n    function tridentMintCallback(bytes calldata data) external;\r\n}\r\n\r\n\r\n// File contracts/libraries/TridentMath.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Trident sqrt helper library.\r\nlibrary TridentMath {\r\n    /// @dev Modified from Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\r\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\r\n        assembly {\r\n            // Start off with z at 1.\r\n            z := 1\r\n\r\n            // Used below to help find a nearby power of 2.\r\n            let y := x\r\n\r\n            // Find the lowest power of 2 that is at least sqrt(x).\r\n            if iszero(lt(y, 0x100000000000000000000000000000000)) {\r\n                y := shr(128, y) // Like dividing by 2 ** 128.\r\n                z := shl(64, z) // Like multiplying by 2 ** 64.\r\n            }\r\n            if iszero(lt(y, 0x10000000000000000)) {\r\n                y := shr(64, y) // Like dividing by 2 ** 64.\r\n                z := shl(32, z) // Like multiplying by 2 ** 32.\r\n            }\r\n            if iszero(lt(y, 0x100000000)) {\r\n                y := shr(32, y) // Like dividing by 2 ** 32.\r\n                z := shl(16, z) // Like multiplying by 2 ** 16.\r\n            }\r\n            if iszero(lt(y, 0x10000)) {\r\n                y := shr(16, y) // Like dividing by 2 ** 16.\r\n                z := shl(8, z) // Like multiplying by 2 ** 8.\r\n            }\r\n            if iszero(lt(y, 0x100)) {\r\n                y := shr(8, y) // Like dividing by 2 ** 8.\r\n                z := shl(4, z) // Like multiplying by 2 ** 4.\r\n            }\r\n            if iszero(lt(y, 0x10)) {\r\n                y := shr(4, y) // Like dividing by 2 ** 4.\r\n                z := shl(2, z) // Like multiplying by 2 ** 2.\r\n            }\r\n            if iszero(lt(y, 0x8)) {\r\n                // Equivalent to 2 ** z.\r\n                z := shl(1, z)\r\n            }\r\n\r\n            // Shifting right by 1 is like dividing by 2.\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n            z := shr(1, add(z, div(x, z)))\r\n\r\n            // Compute a rounded down version of z.\r\n            let zRoundDown := div(x, z)\r\n\r\n            // If zRoundDown is smaller, use it.\r\n            if lt(zRoundDown, z) {\r\n                z := zRoundDown\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/pool/constant-product/ConstantProductPool.sol\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\n\r\n\r\n\r\n/// @dev Custom Errors\r\nerror ZeroAddress();\r\nerror IdenticalAddress();\r\nerror InvalidSwapFee();\r\nerror InvalidAmounts();\r\nerror InsufficientLiquidityMinted();\r\nerror InvalidOutputToken();\r\nerror InvalidInputToken();\r\nerror PoolUninitialized();\r\nerror InsufficientAmountIn();\r\nerror Overflow();\r\n\r\n/// @notice Trident exchange pool template with constant product formula for swapping between an ERC-20 token pair.\r\n/// @dev The reserves are stored as bento shares.\r\n///      The curve is applied to shares as well. This pool does not care about the underlying amounts.\r\ncontract ConstantProductPool is IPool, ERC20, ReentrancyGuard {\r\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\r\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed recipient);\r\n    event Sync(uint256 reserve0, uint256 reserve1);\r\n\r\n    uint256 internal constant MINIMUM_LIQUIDITY = 1000;\r\n\r\n    uint8 internal constant PRECISION = 112;\r\n    uint256 internal constant MAX_FEE = 10000; // @dev 100%.\r\n    uint256 internal constant MAX_FEE_SQUARE = 100000000;\r\n    uint256 public immutable swapFee;\r\n    uint256 internal immutable MAX_FEE_MINUS_SWAP_FEE;\r\n\r\n    address public immutable barFeeTo;\r\n    IBentoBoxMinimal public immutable bento;\r\n    IMasterDeployer public immutable masterDeployer;\r\n    address public immutable token0;\r\n    address public immutable token1;\r\n\r\n    uint256 public barFee;\r\n    uint256 public price0CumulativeLast;\r\n    uint256 public price1CumulativeLast;\r\n    uint256 public kLast;\r\n\r\n    uint112 internal reserve0;\r\n    uint112 internal reserve1;\r\n    uint32 internal blockTimestampLast;\r\n\r\n    bytes32 public constant override poolIdentifier = \"Trident:ConstantProduct\";\r\n\r\n    constructor(bytes memory _deployData, IMasterDeployer _masterDeployer) ERC20(\"Sushi LP Token\", \"SLP\", 18) {\r\n        (address _token0, address _token1, uint256 _swapFee, bool _twapSupport) = abi.decode(\r\n            _deployData,\r\n            (address, address, uint256, bool)\r\n        );\r\n\r\n        // Factory ensures that the tokens are sorted.\r\n        if (_token0 == address(0)) revert ZeroAddress();\r\n        if (_token0 == _token1) revert IdenticalAddress();\r\n        if (_swapFee > MAX_FEE) revert InvalidSwapFee();\r\n\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        swapFee = _swapFee;\r\n        // This is safe from underflow - `swapFee` cannot exceed `MAX_FEE` per previous check.\r\n        unchecked {\r\n            MAX_FEE_MINUS_SWAP_FEE = MAX_FEE - _swapFee;\r\n        }\r\n        barFee = _masterDeployer.barFee();\r\n        barFeeTo = _masterDeployer.barFeeTo();\r\n        bento = IBentoBoxMinimal(_masterDeployer.bento());\r\n        masterDeployer = _masterDeployer;\r\n        if (_twapSupport) blockTimestampLast = uint32(block.timestamp);\r\n    }\r\n\r\n    /// @dev Mints LP tokens - should be called via the router after transferring `bento` tokens.\r\n    /// The router must ensure that sufficient LP tokens are minted by using the return value.\r\n    function mint(bytes calldata data) public override nonReentrant returns (uint256 liquidity) {\r\n        address recipient = abi.decode(data, (address));\r\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\r\n        (uint256 balance0, uint256 balance1) = _balance();\r\n\r\n        uint256 computed = TridentMath.sqrt(balance0 * balance1);\r\n        uint256 amount0 = balance0 - _reserve0;\r\n        uint256 amount1 = balance1 - _reserve1;\r\n\r\n        (uint256 fee0, uint256 fee1) = _nonOptimalMintFee(amount0, amount1, _reserve0, _reserve1);\r\n        _reserve0 += uint112(fee0);\r\n        _reserve1 += uint112(fee1);\r\n\r\n        (uint256 _totalSupply, uint256 k) = _mintFee(_reserve0, _reserve1);\r\n\r\n        if (_totalSupply == 0) {\r\n            if (amount0 == 0 || amount1 == 0) revert InvalidAmounts();\r\n            liquidity = computed - MINIMUM_LIQUIDITY;\r\n            _mint(address(0), MINIMUM_LIQUIDITY);\r\n        } else {\r\n            uint256 kIncrease;\r\n            unchecked {\r\n                kIncrease = computed - k;\r\n            }\r\n            liquidity = (kIncrease * _totalSupply) / k;\r\n        }\r\n        if (liquidity == 0) revert InsufficientLiquidityMinted();\r\n        _mint(recipient, liquidity);\r\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\r\n        kLast = computed;\r\n        emit Mint(msg.sender, amount0, amount1, recipient);\r\n    }\r\n\r\n    /// @dev Burns LP tokens sent to this contract. The router must ensure that the user gets sufficient output tokens.\r\n    function burn(bytes calldata data) public override nonReentrant returns (IPool.TokenAmount[] memory withdrawnAmounts) {\r\n        (address recipient, bool unwrapBento) = abi.decode(data, (address, bool));\r\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\r\n        (uint256 balance0, uint256 balance1) = _balance();\r\n        uint256 liquidity = balanceOf[address(this)];\r\n\r\n        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);\r\n\r\n        uint256 amount0 = (liquidity * balance0) / _totalSupply;\r\n        uint256 amount1 = (liquidity * balance1) / _totalSupply;\r\n\r\n        _burn(address(this), liquidity);\r\n        _transfer(token0, amount0, recipient, unwrapBento);\r\n        _transfer(token1, amount1, recipient, unwrapBento);\r\n        // This is safe from underflow - amounts are lesser figures derived from balances.\r\n        unchecked {\r\n            balance0 -= amount0;\r\n            balance1 -= amount1;\r\n        }\r\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\r\n        kLast = TridentMath.sqrt(balance0 * balance1);\r\n\r\n        withdrawnAmounts = new TokenAmount[](2);\r\n        withdrawnAmounts[0] = TokenAmount({token: address(token0), amount: amount0});\r\n        withdrawnAmounts[1] = TokenAmount({token: address(token1), amount: amount1});\r\n        emit Burn(msg.sender, amount0, amount1, recipient);\r\n    }\r\n\r\n    /// @dev Burns LP tokens sent to this contract and swaps one of the output tokens for another\r\n    /// - i.e., the user gets a single token out by burning LP tokens.\r\n    function burnSingle(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\r\n        (address tokenOut, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\r\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\r\n        uint256 liquidity = balanceOf[address(this)];\r\n\r\n        (uint256 _totalSupply, ) = _mintFee(_reserve0, _reserve1);\r\n\r\n        uint256 amount0 = (liquidity * _reserve0) / _totalSupply;\r\n        uint256 amount1 = (liquidity * _reserve1) / _totalSupply;\r\n\r\n        kLast = TridentMath.sqrt((_reserve0 - amount0) * (_reserve1 - amount1));\r\n\r\n        _burn(address(this), liquidity);\r\n\r\n        // Swap one token for another\r\n        unchecked {\r\n            if (tokenOut == token1) {\r\n                // Swap `token0` for `token1`\r\n                // - calculate `amountOut` as if the user first withdrew balanced liquidity and then swapped `token0` for `token1`.\r\n                amount1 += _getAmountOut(amount0, _reserve0 - amount0, _reserve1 - amount1);\r\n                _transfer(token1, amount1, recipient, unwrapBento);\r\n                amountOut = amount1;\r\n                amount0 = 0;\r\n            } else {\r\n                // Swap `token1` for `token0`.\r\n                if (tokenOut != token0) revert InvalidOutputToken();\r\n                amount0 += _getAmountOut(amount1, _reserve1 - amount1, _reserve0 - amount0);\r\n                _transfer(token0, amount0, recipient, unwrapBento);\r\n                amountOut = amount0;\r\n                amount1 = 0;\r\n            }\r\n        }\r\n\r\n        (uint256 balance0, uint256 balance1) = _balance();\r\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\r\n\r\n        emit Burn(msg.sender, amount0, amount1, recipient);\r\n    }\r\n\r\n    /// @dev Swaps one token for another. The router must prefund this contract and ensure there isn't too much slippage.\r\n    function swap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\r\n        (address tokenIn, address recipient, bool unwrapBento) = abi.decode(data, (address, address, bool));\r\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\r\n        if (_reserve0 == 0) revert PoolUninitialized();\r\n        (uint256 balance0, uint256 balance1) = _balance();\r\n        uint256 amountIn;\r\n        address tokenOut;\r\n        unchecked {\r\n            if (tokenIn == token0) {\r\n                tokenOut = token1;\r\n                amountIn = balance0 - _reserve0;\r\n                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\r\n                balance1 -= amountOut;\r\n            } else {\r\n                if (tokenIn != token1) revert InvalidInputToken();\r\n                tokenOut = token0;\r\n                amountIn = balance1 - reserve1;\r\n                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\r\n                balance0 -= amountOut;\r\n            }\r\n        }\r\n        _transfer(tokenOut, amountOut, recipient, unwrapBento);\r\n        _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\r\n        emit Swap(recipient, tokenIn, tokenOut, amountIn, amountOut);\r\n    }\r\n\r\n    /// @dev Swaps one token for another. The router must support swap callbacks and ensure there isn't too much slippage.\r\n    function flashSwap(bytes calldata data) public override nonReentrant returns (uint256 amountOut) {\r\n        (address tokenIn, address recipient, bool unwrapBento, uint256 amountIn, bytes memory context) = abi.decode(\r\n            data,\r\n            (address, address, bool, uint256, bytes)\r\n        );\r\n        (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) = _getReserves();\r\n        if (_reserve0 == 0) revert PoolUninitialized();\r\n        unchecked {\r\n            if (tokenIn == token0) {\r\n                amountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\r\n                _transfer(token1, amountOut, recipient, unwrapBento);\r\n                ITridentCallee(msg.sender).tridentSwapCallback(context);\r\n                (uint256 balance0, uint256 balance1) = _balance();\r\n                if (balance0 - _reserve0 < amountIn) revert InsufficientAmountIn();\r\n                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\r\n                emit Swap(recipient, tokenIn, token1, amountIn, amountOut);\r\n            } else {\r\n                if (tokenIn != token1) revert InvalidInputToken();\r\n                amountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\r\n                _transfer(token0, amountOut, recipient, unwrapBento);\r\n                ITridentCallee(msg.sender).tridentSwapCallback(context);\r\n                (uint256 balance0, uint256 balance1) = _balance();\r\n                if (balance1 - _reserve1 < amountIn) revert InsufficientAmountIn();\r\n                _update(balance0, balance1, _reserve0, _reserve1, _blockTimestampLast);\r\n                emit Swap(recipient, tokenIn, token0, amountIn, amountOut);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Updates `barFee` for Trident protocol.\r\n    function updateBarFee() public {\r\n        barFee = masterDeployer.barFee();\r\n    }\r\n\r\n    function _getReserves()\r\n        internal\r\n        view\r\n        returns (\r\n            uint112 _reserve0,\r\n            uint112 _reserve1,\r\n            uint32 _blockTimestampLast\r\n        )\r\n    {\r\n        _reserve0 = reserve0;\r\n        _reserve1 = reserve1;\r\n        _blockTimestampLast = blockTimestampLast;\r\n    }\r\n\r\n    function _balance() internal view returns (uint256 balance0, uint256 balance1) {\r\n        balance0 = bento.balanceOf(token0, address(this));\r\n        balance1 = bento.balanceOf(token1, address(this));\r\n    }\r\n\r\n    function _update(\r\n        uint256 balance0,\r\n        uint256 balance1,\r\n        uint112 _reserve0,\r\n        uint112 _reserve1,\r\n        uint32 _blockTimestampLast\r\n    ) internal {\r\n        if (balance0 > type(uint112).max || balance1 > type(uint112).max) revert Overflow();\r\n        if (_blockTimestampLast == 0) {\r\n            // TWAP support is disabled for gas efficiency.\r\n            reserve0 = uint112(balance0);\r\n            reserve1 = uint112(balance1);\r\n        } else {\r\n            uint32 blockTimestamp = uint32(block.timestamp);\r\n            if (blockTimestamp != _blockTimestampLast && _reserve0 != 0 && _reserve1 != 0) {\r\n                unchecked {\r\n                    uint32 timeElapsed = blockTimestamp - _blockTimestampLast;\r\n                    uint256 price0 = (uint256(_reserve1) << PRECISION) / _reserve0;\r\n                    price0CumulativeLast += price0 * timeElapsed;\r\n                    uint256 price1 = (uint256(_reserve0) << PRECISION) / _reserve1;\r\n                    price1CumulativeLast += price1 * timeElapsed;\r\n                }\r\n            }\r\n            reserve0 = uint112(balance0);\r\n            reserve1 = uint112(balance1);\r\n            blockTimestampLast = blockTimestamp;\r\n        }\r\n        emit Sync(balance0, balance1);\r\n    }\r\n\r\n    function _mintFee(uint112 _reserve0, uint112 _reserve1) internal returns (uint256 _totalSupply, uint256 computed) {\r\n        _totalSupply = totalSupply;\r\n        uint256 _kLast = kLast;\r\n        if (_kLast != 0) {\r\n            computed = TridentMath.sqrt(uint256(_reserve0) * _reserve1);\r\n            if (computed > _kLast) {\r\n                // `barFee` % of increase in liquidity.\r\n                uint256 _barFee = barFee;\r\n                uint256 numerator = _totalSupply * (computed - _kLast) * _barFee;\r\n                uint256 denominator = (MAX_FEE - _barFee) * computed + _barFee * _kLast;\r\n                uint256 liquidity = numerator / denominator;\r\n\r\n                if (liquidity != 0) {\r\n                    _mint(barFeeTo, liquidity);\r\n                    _totalSupply += liquidity;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getAmountOut(\r\n        uint256 amountIn,\r\n        uint256 reserveAmountIn,\r\n        uint256 reserveAmountOut\r\n    ) internal view returns (uint256 amountOut) {\r\n        uint256 amountInWithFee = amountIn * MAX_FEE_MINUS_SWAP_FEE;\r\n        amountOut = (amountInWithFee * reserveAmountOut) / (reserveAmountIn * MAX_FEE + amountInWithFee);\r\n    }\r\n\r\n    function _getAmountIn(\r\n        uint256 amountOut,\r\n        uint256 reserveAmountIn,\r\n        uint256 reserveAmountOut\r\n    ) internal view returns (uint256 amountIn) {\r\n        amountIn = (reserveAmountIn * amountOut * MAX_FEE) / ((reserveAmountOut - amountOut) * MAX_FEE_MINUS_SWAP_FEE) + 1;\r\n    }\r\n\r\n    function _transfer(\r\n        address token,\r\n        uint256 shares,\r\n        address to,\r\n        bool unwrapBento\r\n    ) internal {\r\n        if (unwrapBento) {\r\n            bento.withdraw(token, address(this), to, 0, shares);\r\n        } else {\r\n            bento.transfer(token, address(this), to, shares);\r\n        }\r\n    }\r\n\r\n    /// @dev This fee is charged to cover for `swapFee` when users add unbalanced liquidity.\r\n    function _nonOptimalMintFee(\r\n        uint256 _amount0,\r\n        uint256 _amount1,\r\n        uint256 _reserve0,\r\n        uint256 _reserve1\r\n    ) internal view returns (uint256 token0Fee, uint256 token1Fee) {\r\n        if (_reserve0 == 0 || _reserve1 == 0) return (0, 0);\r\n        uint256 amount1Optimal = (_amount0 * _reserve1) / _reserve0;\r\n        if (amount1Optimal <= _amount1) {\r\n            token1Fee = (swapFee * (_amount1 - amount1Optimal)) / (2 * MAX_FEE);\r\n        } else {\r\n            uint256 amount0Optimal = (_amount1 * _reserve0) / _reserve1;\r\n            token0Fee = (swapFee * (_amount0 - amount0Optimal)) / (2 * MAX_FEE);\r\n        }\r\n    }\r\n\r\n    function getAssets() public view override returns (address[] memory assets) {\r\n        assets = new address[](2);\r\n        assets[0] = token0;\r\n        assets[1] = token1;\r\n    }\r\n\r\n    function getAmountOut(bytes calldata data) public view override returns (uint256 finalAmountOut) {\r\n        (address tokenIn, uint256 amountIn) = abi.decode(data, (address, uint256));\r\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();\r\n        if (tokenIn == token0) {\r\n            finalAmountOut = _getAmountOut(amountIn, _reserve0, _reserve1);\r\n        } else {\r\n            if (tokenIn != token1) revert InvalidInputToken();\r\n            finalAmountOut = _getAmountOut(amountIn, _reserve1, _reserve0);\r\n        }\r\n    }\r\n\r\n    function getAmountIn(bytes calldata data) public view override returns (uint256 finalAmountIn) {\r\n        (address tokenOut, uint256 amountOut) = abi.decode(data, (address, uint256));\r\n        (uint112 _reserve0, uint112 _reserve1, ) = _getReserves();\r\n        if (tokenOut == token1) {\r\n            finalAmountIn = _getAmountIn(amountOut, _reserve0, _reserve1);\r\n        } else {\r\n            if (tokenOut != token0) revert InvalidOutputToken();\r\n            finalAmountIn = _getAmountIn(amountOut, _reserve1, _reserve0);\r\n        }\r\n    }\r\n\r\n    /// @dev Returned values are in terms of BentoBox \"shares\".\r\n    function getReserves()\r\n        public\r\n        view\r\n        returns (\r\n            uint112 _reserve0,\r\n            uint112 _reserve1,\r\n            uint32 _blockTimestampLast\r\n        )\r\n    {\r\n        return _getReserves();\r\n    }\r\n\r\n    /// @dev Returned values are the native ERC20 token amounts.\r\n    function getNativeReserves()\r\n        public\r\n        view\r\n        returns (\r\n            uint256 _nativeReserve0,\r\n            uint256 _nativeReserve1,\r\n            uint32 _blockTimestampLast\r\n        )\r\n    {\r\n        (uint112 _reserve0, uint112 _reserve1, uint32 __blockTimestampLast) = _getReserves();\r\n        _nativeReserve0 = bento.toAmount(token0, _reserve0, false);\r\n        _nativeReserve1 = bento.toAmount(token1, _reserve1, false);\r\n        _blockTimestampLast = __blockTimestampLast;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_deployData\",\"type\":\"bytes\"},{\"internalType\":\"contract IMasterDeployer\",\"name\":\"_masterDeployer\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"IdenticalAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientAmountIn\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientLiquidityMinted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmounts\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInputToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidOutputToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSwapFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"Overflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PoolUninitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"name\":\"Swap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reserve1\",\"type\":\"uint256\"}],\"name\":\"Sync\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"barFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"barFeeTo\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"bento\",\"outputs\":[{\"internalType\":\"contract IBentoBoxMinimal\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"burn\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IPool.TokenAmount[]\",\"name\":\"withdrawnAmounts\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"burnSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"flashSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getAmountIn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalAmountIn\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getAmountOut\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"finalAmountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getAssets\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"assets\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNativeReserves\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_nativeReserve0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nativeReserve1\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"_blockTimestampLast\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getReserves\",\"outputs\":[{\"internalType\":\"uint112\",\"name\":\"_reserve0\",\"type\":\"uint112\"},{\"internalType\":\"uint112\",\"name\":\"_reserve1\",\"type\":\"uint112\"},{\"internalType\":\"uint32\",\"name\":\"_blockTimestampLast\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"kLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"masterDeployer\",\"outputs\":[{\"internalType\":\"contract IMasterDeployer\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"permit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolIdentifier\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price0CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"price1CumulativeLast\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"swapFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token0\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"token1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"updateBarFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "ConstantProductPool", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "999999", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000351447fc9bd20a917783e159e61e86edda0b018700000000000000000000000000000000000000000000000000000000000000800000000000000000000000004e78011ce80ee02d2c3e649fb657e458982578150000000000000000000000006bca3b77c1909ce1a4ba1a20d1103bde8d222e48000000000000000000000000000000000000000000000000000000000000001e0000000000000000000000000000000000000000000000000000000000000001", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://23b1b16732d5efbbde4fe9c09ad57bc5e282ee9d8115186daf2a0c35f79fae82"}