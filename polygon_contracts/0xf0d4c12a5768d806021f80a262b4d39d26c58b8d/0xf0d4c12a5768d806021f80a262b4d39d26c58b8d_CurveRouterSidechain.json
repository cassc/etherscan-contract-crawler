{"SourceCode": "# @version 0.3.7\r\n\r\n\"\"\"\r\n@title CurveRouterSidechainTricryptoMeta v1.0\r\n@author Curve.Fi\r\n@license Copyright (c) Curve.Fi, 2020-2023 - all rights reserved\r\n@notice Performs up to 5 swaps in a single transaction, can do estimations with get_dy and get_dx\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\n\r\ninterface StablePool:\r\n    def exchange(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def exchange_underlying(i: int128, j: int128, dx: uint256, min_dy: uint256): payable\r\n    def get_dy(i: int128, j: int128, amount: uint256) -> uint256: view\r\n    def get_dy_underlying(i: int128, j: int128, amount: uint256) -> uint256: view\r\n    def coins(i: uint256) -> address: view\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: int128) -> uint256: view\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256): nonpayable\r\n\r\ninterface CryptoPool:\r\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256): payable\r\n    def exchange_underlying(i: uint256, j: uint256, dx: uint256, min_dy: uint256): payable\r\n    def get_dy(i: uint256, j: uint256, amount: uint256) -> uint256: view\r\n    def get_dy_underlying(i: uint256, j: uint256, amount: uint256) -> uint256: view\r\n    def calc_withdraw_one_coin(token_amount: uint256, i: uint256) -> uint256: view\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: uint256, min_amount: uint256): nonpayable\r\n\r\ninterface CryptoPoolETH:\r\n    def exchange(i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool): payable\r\n\r\ninterface LendingBasePoolMetaZap:\r\n    def exchange_underlying(pool: address, i: int128, j: int128, dx: uint256, min_dy: uint256): nonpayable\r\n\r\ninterface CryptoMetaZap:\r\n    def get_dy(pool: address, i: uint256, j: uint256, dx: uint256) -> uint256: view\r\n    def exchange(pool: address, i: uint256, j: uint256, dx: uint256, min_dy: uint256, use_eth: bool): payable\r\n\r\ninterface StablePool2Coins:\r\n    def add_liquidity(amounts: uint256[2], min_mint_amount: uint256): payable\r\n    def calc_token_amount(amounts: uint256[2], is_deposit: bool) -> uint256: view\r\n\r\ninterface CryptoPool2Coins:\r\n    def calc_token_amount(amounts: uint256[2]) -> uint256: view\r\n\r\ninterface StablePool3Coins:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256): payable\r\n    def calc_token_amount(amounts: uint256[3], is_deposit: bool) -> uint256: view\r\n\r\ninterface CryptoPool3Coins:\r\n    def calc_token_amount(amounts: uint256[3]) -> uint256: view\r\n\r\ninterface StablePool4Coins:\r\n    def add_liquidity(amounts: uint256[4], min_mint_amount: uint256): payable\r\n    def calc_token_amount(amounts: uint256[4], is_deposit: bool) -> uint256: view\r\n\r\ninterface CryptoPool4Coins:\r\n    def calc_token_amount(amounts: uint256[4]) -> uint256: view\r\n\r\ninterface StablePool5Coins:\r\n    def add_liquidity(amounts: uint256[5], min_mint_amount: uint256): payable\r\n    def calc_token_amount(amounts: uint256[5], is_deposit: bool) -> uint256: view\r\n\r\ninterface CryptoPool5Coins:\r\n    def calc_token_amount(amounts: uint256[5]) -> uint256: view\r\n\r\ninterface LendingStablePool3Coins:\r\n    def add_liquidity(amounts: uint256[3], min_mint_amount: uint256, use_underlying: bool): payable\r\n    def remove_liquidity_one_coin(token_amount: uint256, i: int128, min_amount: uint256, use_underlying: bool) -> uint256: nonpayable\r\n\r\ninterface Llamma:\r\n    def get_dx(i: uint256, j: uint256, out_amount: uint256) -> uint256: view\r\n\r\ninterface WETH:\r\n    def deposit(): payable\r\n    def withdraw(_amount: uint256): nonpayable\r\n\r\ninterface stETH:\r\n    def submit(_refferer: address): payable\r\n\r\ninterface frxETHMinter:\r\n    def submit(): payable\r\n\r\ninterface wstETH:\r\n    def getWstETHByStETH(_stETHAmount: uint256) -> uint256: view\r\n    def getStETHByWstETH(_wstETHAmount: uint256) -> uint256: view\r\n    def wrap(_stETHAmount: uint256) -> uint256: nonpayable\r\n    def unwrap(_wstETHAmount: uint256) -> uint256: nonpayable\r\n\r\ninterface sfrxETH:\r\n    def convertToShares(assets: uint256) -> uint256: view\r\n    def convertToAssets(shares: uint256) -> uint256: view\r\n    def deposit(assets: uint256, receiver: address) -> uint256: nonpayable\r\n    def redeem(shares: uint256, receiver: address, owner: address) -> uint256: nonpayable\r\n\r\ninterface wBETH:\r\n    def deposit(referral: address): payable\r\n    def exchangeRate() -> uint256: view\r\n\r\n# SNX\r\ninterface Synthetix:\r\n    def exchangeAtomically(sourceCurrencyKey: bytes32, sourceAmount: uint256, destinationCurrencyKey: bytes32, trackingCode: bytes32, minAmount: uint256) -> uint256: nonpayable\r\n\r\ninterface SynthetixExchanger:\r\n    def getAmountsForAtomicExchange(sourceAmount: uint256, sourceCurrencyKey: bytes32, destinationCurrencyKey: bytes32) -> AtomicAmountAndFee: view\r\n\r\ninterface SynthetixAddressResolver:\r\n    def getAddress(name: bytes32) -> address: view\r\n\r\n# Calc zaps\r\ninterface StableCalc:\r\n    def calc_token_amount(pool: address, token: address, amounts: uint256[10], n_coins: uint256, deposit: bool, use_underlying: bool) -> uint256: view\r\n    def get_dx(pool: address, i: int128, j: int128, dy: uint256, n_coins: uint256) -> uint256: view\r\n    def get_dx_underlying(pool: address, i: int128, j: int128, dy: uint256, n_coins: uint256) -> uint256: view\r\n    def get_dx_meta(pool: address, i: int128, j: int128, dy: uint256, n_coins: uint256, base_pool: address) -> uint256: view\r\n    def get_dx_meta_underlying(pool: address, i: int128, j: int128, dy: uint256, n_coins: uint256, base_pool: address, base_token: address) -> uint256: view\r\n\r\ninterface CryptoCalc:\r\n    def get_dx(pool: address, i: uint256, j: uint256, dy: uint256, n_coins: uint256) -> uint256: view\r\n    def get_dx_meta_underlying(pool: address, i: uint256, j: uint256, dy: uint256, n_coins: uint256, base_pool: address, base_token: address) -> uint256: view\r\n    def get_dx_tricrypto_meta_underlying(pool: address, i: uint256, j: uint256, dy: uint256, n_coins: uint256, base_pool: address, base_token: address) -> uint256: view\r\n    def get_dx_double_meta_underlying(pool: address, i: uint256, j: uint256, dy: uint256, base_pool: address, base_pool_zap: address, base_pool2: address, base_token2: address) -> uint256: view\r\n\r\n\r\nstruct AtomicAmountAndFee:\r\n    amountReceived: uint256\r\n    fee: uint256\r\n    exchangeFeeRate: uint256\r\n\r\n\r\nevent Exchange:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    route: address[11]\r\n    swap_params: uint256[5][5]\r\n    pools: address[5]\r\n    in_amount: uint256\r\n    out_amount: uint256\r\n\r\n\r\nETH_ADDRESS: constant(address) = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\r\nWETH_ADDRESS: immutable(address)\r\n\r\n# Calc zaps\r\nSTABLE_CALC: immutable(StableCalc)\r\nCRYPTO_CALC: immutable(CryptoCalc)\r\n\r\nis_approved: HashMap[address, HashMap[address, bool]]\r\nis_tricrypto_meta: HashMap[address, bool]\r\n\r\n\r\n@external\r\n@payable\r\ndef __default__():\r\n    pass\r\n\r\n\r\n@external\r\ndef __init__( _weth: address, _stable_calc: address, _crypto_calc: address, _tricrypto_meta_pools: address[2]):\r\n    WETH_ADDRESS = _weth\r\n    STABLE_CALC = StableCalc(_stable_calc)\r\n    CRYPTO_CALC = CryptoCalc(_crypto_calc)\r\n\r\n    if _tricrypto_meta_pools[0] != empty(address):\r\n        self.is_tricrypto_meta[_tricrypto_meta_pools[0]] = True\r\n    if _tricrypto_meta_pools[1] != empty(address):\r\n        self.is_tricrypto_meta[_tricrypto_meta_pools[1]] = True\r\n\r\n\r\n@external\r\n@payable\r\n@nonreentrant('lock')\r\ndef exchange(\r\n    _route: address[11],\r\n    _swap_params: uint256[5][5],\r\n    _amount: uint256,\r\n    _expected: uint256,\r\n    _pools: address[5]=empty(address[5]),\r\n    _receiver: address=msg.sender\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Performs up to 5 swaps in a single transaction.\r\n    @dev Routing and swap params must be determined off-chain. This\r\n         functionality is designed for gas efficiency over ease-of-use.\r\n    @param _route Array of [initial token, pool or zap, token, pool or zap, token, ...]\r\n                  The array is iterated until a pool address of 0x00, then the last\r\n                  given token is transferred to `_receiver`\r\n    @param _swap_params Multidimensional array of [i, j, swap type, pool_type, n_coins] where\r\n                        i is the index of input token\r\n                        j is the index of output token\r\n\r\n                        The swap_type should be:\r\n                        1. for `exchange`,\r\n                        2. for `exchange_underlying`,\r\n                        3. for underlying exchange via zap: factory stable metapools with lending base pool `exchange_underlying`\r\n                           and factory crypto-meta pools underlying exchange (`exchange` method in zap)\r\n                        4. for coin -> LP token \"exchange\" (actually `add_liquidity`),\r\n                        5. for lending pool underlying coin -> LP token \"exchange\" (actually `add_liquidity`),\r\n                        6. for LP token -> coin \"exchange\" (actually `remove_liquidity_one_coin`)\r\n                        7. for LP token -> lending or fake pool underlying coin \"exchange\" (actually `remove_liquidity_one_coin`)\r\n                        8. for ETH <-> WETH, ETH -> stETH or ETH -> frxETH, stETH <-> wstETH, frxETH <-> sfrxETH, ETH -> wBETH\r\n\r\n                        pool_type: 1 - stable, 2 - crypto, 3 - tricrypto, 4 - llamma\r\n                        n_coins is the number of coins in pool\r\n    @param _amount The amount of input token (`_route[0]`) to be sent.\r\n    @param _expected The minimum amount received after the final swap.\r\n    @param _pools Array of pools for swaps via zap contracts. This parameter is only needed for swap_type = 3.\r\n    @param _receiver Address to transfer the final output token to.\r\n    @return Received amount of the final output token.\r\n    \"\"\"\r\n    input_token: address = _route[0]\r\n    output_token: address = empty(address)\r\n    amount: uint256 = _amount\r\n\r\n    # validate / transfer initial token\r\n    if input_token == ETH_ADDRESS:\r\n        assert msg.value == amount\r\n    else:\r\n        assert msg.value == 0\r\n        assert ERC20(input_token).transferFrom(msg.sender, self, amount, default_return_value=True)\r\n\r\n    for i in range(1, 6):\r\n        # 5 rounds of iteration to perform up to 5 swaps\r\n        swap: address = _route[i*2-1]\r\n        pool: address = _pools[i-1] # Only for Polygon meta-factories underlying swap (swap_type == 6)\r\n        output_token = _route[i*2]\r\n        params: uint256[5] = _swap_params[i-1]  # i, j, swap_type, pool_type, n_coins\r\n\r\n        if not self.is_approved[input_token][swap]:\r\n            assert ERC20(input_token).approve(swap, max_value(uint256), default_return_value=True, skip_contract_check=True)\r\n            self.is_approved[input_token][swap] = True\r\n\r\n        eth_amount: uint256 = 0\r\n        if input_token == ETH_ADDRESS:\r\n            eth_amount = amount\r\n        # perform the swap according to the swap type\r\n        if params[2] == 1:\r\n            if params[3] == 1:  # stable\r\n                StablePool(swap).exchange(convert(params[0], int128), convert(params[1], int128), amount, 0, value=eth_amount)\r\n            else:  # crypto, tricrypto or llamma\r\n                if input_token == ETH_ADDRESS or output_token == ETH_ADDRESS:\r\n                    CryptoPoolETH(swap).exchange(params[0], params[1], amount, 0, True, value=eth_amount)\r\n                else:\r\n                    CryptoPool(swap).exchange(params[0], params[1], amount, 0)\r\n        elif params[2] == 2:\r\n            if params[3] == 1:  # stable\r\n                StablePool(swap).exchange_underlying(convert(params[0], int128), convert(params[1], int128), amount, 0, value=eth_amount)\r\n            else:  # crypto or tricrypto\r\n                CryptoPool(swap).exchange_underlying(params[0], params[1], amount, 0, value=eth_amount)\r\n        elif params[2] == 3:  # SWAP IS ZAP HERE !!!\r\n            if params[3] == 1:  # stable\r\n                LendingBasePoolMetaZap(swap).exchange_underlying(pool, convert(params[0], int128), convert(params[1], int128), amount, 0)\r\n            else:  # crypto or tricrypto\r\n                use_eth: bool = input_token == ETH_ADDRESS or output_token == ETH_ADDRESS\r\n                CryptoMetaZap(swap).exchange(pool, params[0], params[1], amount, 0, use_eth, value=eth_amount)\r\n        elif params[2] == 4:\r\n            if params[4] == 2:\r\n                amounts: uint256[2] = [0, 0]\r\n                amounts[params[0]] = amount\r\n                StablePool2Coins(swap).add_liquidity(amounts, 0, value=eth_amount)\r\n            elif params[4] == 3:\r\n                amounts: uint256[3] = [0, 0, 0]\r\n                amounts[params[0]] = amount\r\n                StablePool3Coins(swap).add_liquidity(amounts, 0, value=eth_amount)\r\n            elif params[4] == 4:\r\n                amounts: uint256[4] = [0, 0, 0, 0]\r\n                amounts[params[0]] = amount\r\n                StablePool4Coins(swap).add_liquidity(amounts, 0, value=eth_amount)\r\n            elif params[4] == 5:\r\n                amounts: uint256[5] = [0, 0, 0, 0, 0]\r\n                amounts[params[0]] = amount\r\n                StablePool5Coins(swap).add_liquidity(amounts, 0, value=eth_amount)\r\n        elif params[2] == 5:\r\n            amounts: uint256[3] = [0, 0, 0]\r\n            amounts[params[0]] = amount\r\n            LendingStablePool3Coins(swap).add_liquidity(amounts, 0, True, value=eth_amount) # example: aave on Polygon\r\n        elif params[2] == 6:\r\n            if params[3] == 1:  # stable\r\n                StablePool(swap).remove_liquidity_one_coin(amount, convert(params[1], int128), 0)\r\n            else:  # crypto or tricrypto\r\n                CryptoPool(swap).remove_liquidity_one_coin(amount, params[1], 0)  # example: atricrypto3 on Polygon\r\n        elif params[2] == 7:\r\n            LendingStablePool3Coins(swap).remove_liquidity_one_coin(amount, convert(params[1], int128), 0, True) # example: aave on Polygon\r\n        elif params[2] == 8:\r\n            if input_token == ETH_ADDRESS and output_token == WETH_ADDRESS:\r\n                WETH(swap).deposit(value=amount)\r\n            elif input_token == WETH_ADDRESS and output_token == ETH_ADDRESS:\r\n                WETH(swap).withdraw(amount)\r\n            else:\r\n                raise \"Swap type 8 is only for ETH <-> WETH\"\r\n        else:\r\n            raise \"Bad swap type\"\r\n\r\n        # update the amount received\r\n        if output_token == ETH_ADDRESS:\r\n            amount = self.balance\r\n        else:\r\n            amount = ERC20(output_token).balanceOf(self)\r\n\r\n        # sanity check, if the routing data is incorrect we will have a 0 balance and that is bad\r\n        assert amount != 0, \"Received nothing\"\r\n\r\n        # check if this was the last swap\r\n        if i == 5 or _route[i*2+1] == empty(address):\r\n            break\r\n        # if there is another swap, the output token becomes the input for the next round\r\n        input_token = output_token\r\n\r\n    amount -= 1  # Change non-zero -> non-zero costs less gas than zero -> non-zero\r\n    assert amount >= _expected, \"Slippage\"\r\n\r\n    # transfer the final token to the receiver\r\n    if output_token == ETH_ADDRESS:\r\n        raw_call(_receiver, b\"\", value=amount)\r\n    else:\r\n        assert ERC20(output_token).transfer(_receiver, amount, default_return_value=True)\r\n\r\n    log Exchange(msg.sender, _receiver, _route, _swap_params, _pools, _amount, amount)\r\n\r\n    return amount\r\n\r\n\r\n@view\r\n@external\r\ndef get_dy(\r\n    _route: address[11],\r\n    _swap_params: uint256[5][5],\r\n    _amount: uint256,\r\n    _pools: address[5]=empty(address[5])\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Get amount of the final output token received in an exchange\r\n    @dev Routing and swap params must be determined off-chain. This\r\n         functionality is designed for gas efficiency over ease-of-use.\r\n    @param _route Array of [initial token, pool or zap, token, pool or zap, token, ...]\r\n                  The array is iterated until a pool address of 0x00, then the last\r\n                  given token is transferred to `_receiver`\r\n    @param _swap_params Multidimensional array of [i, j, swap type, pool_type, n_coins] where\r\n                        i is the index of input token\r\n                        j is the index of output token\r\n\r\n                        The swap_type should be:\r\n                        1. for `exchange`,\r\n                        2. for `exchange_underlying`,\r\n                        3. for underlying exchange via zap: factory stable metapools with lending base pool `exchange_underlying`\r\n                           and factory crypto-meta pools underlying exchange (`exchange` method in zap)\r\n                        4. for coin -> LP token \"exchange\" (actually `add_liquidity`),\r\n                        5. for lending pool underlying coin -> LP token \"exchange\" (actually `add_liquidity`),\r\n                        6. for LP token -> coin \"exchange\" (actually `remove_liquidity_one_coin`)\r\n                        7. for LP token -> lending or fake pool underlying coin \"exchange\" (actually `remove_liquidity_one_coin`)\r\n                        8. for ETH <-> WETH, ETH -> stETH or ETH -> frxETH, stETH <-> wstETH, frxETH <-> sfrxETH, ETH -> wBETH\r\n\r\n                        pool_type: 1 - stable, 2 - crypto, 3 - tricrypto, 4 - llamma\r\n                        n_coins is the number of coins in pool\r\n    @param _amount The amount of input token (`_route[0]`) to be sent.\r\n    @param _pools Array of pools for swaps via zap contracts. This parameter is only needed for swap_type = 3.\r\n    @return Expected amount of the final output token.\r\n    \"\"\"\r\n    input_token: address = _route[0]\r\n    output_token: address = empty(address)\r\n    amount: uint256 = _amount\r\n\r\n    for i in range(1, 6):\r\n        # 5 rounds of iteration to perform up to 5 swaps\r\n        swap: address = _route[i*2-1]\r\n        pool: address = _pools[i-1] # Only for Polygon meta-factories underlying swap (swap_type == 4)\r\n        output_token = _route[i * 2]\r\n        params: uint256[5] = _swap_params[i-1]  # i, j, swap_type, pool_type, n_coins\r\n\r\n        # Calc output amount according to the swap type\r\n        if params[2] == 1:\r\n            if params[3] == 1:  # stable\r\n                amount = StablePool(swap).get_dy(convert(params[0], int128), convert(params[1], int128), amount)\r\n            else:  # crypto or llamma\r\n                amount = CryptoPool(swap).get_dy(params[0], params[1], amount)\r\n        elif params[2] == 2:\r\n            if params[3] == 1:  # stable\r\n                amount = StablePool(swap).get_dy_underlying(convert(params[0], int128), convert(params[1], int128), amount)\r\n            else:  # crypto\r\n                amount = CryptoPool(swap).get_dy_underlying(params[0], params[1], amount)\r\n        elif params[2] == 3:  # SWAP IS ZAP HERE !!!\r\n            if params[3] == 1:  # stable\r\n                amount = StablePool(pool).get_dy_underlying(convert(params[0], int128), convert(params[1], int128), amount)\r\n            else:  # crypto\r\n                amount = CryptoMetaZap(swap).get_dy(pool, params[0], params[1], amount)\r\n        elif params[2] in [4, 5]:\r\n            if params[3] == 1: # stable\r\n                amounts: uint256[10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n                amounts[params[0]] = amount\r\n                amount = STABLE_CALC.calc_token_amount(swap, output_token, amounts, params[4], True, True)\r\n            else:\r\n                # Tricrypto pools have stablepool interface for calc_token_amount\r\n                if params[4] == 2:\r\n                    amounts: uint256[2] = [0, 0]\r\n                    amounts[params[0]] = amount\r\n                    if params[3] == 2:  # crypto\r\n                        amount = CryptoPool2Coins(swap).calc_token_amount(amounts)\r\n                    else:  # tricrypto\r\n                        amount = StablePool2Coins(swap).calc_token_amount(amounts, True)\r\n                elif params[4] == 3:\r\n                    amounts: uint256[3] = [0, 0, 0]\r\n                    amounts[params[0]] = amount\r\n                    if params[3] == 2:  # crypto\r\n                        amount = CryptoPool3Coins(swap).calc_token_amount(amounts)\r\n                    else:  # tricrypto\r\n                        amount = StablePool3Coins(swap).calc_token_amount(amounts, True)\r\n                elif params[4] == 4:\r\n                    amounts: uint256[4] = [0, 0, 0, 0]\r\n                    amounts[params[0]] = amount\r\n                    if params[3] == 2:  # crypto\r\n                        amount = CryptoPool4Coins(swap).calc_token_amount(amounts)\r\n                    else:  # tricrypto\r\n                        amount = StablePool4Coins(swap).calc_token_amount(amounts, True)\r\n                elif params[4] == 5:\r\n                    amounts: uint256[5] = [0, 0, 0, 0, 0]\r\n                    amounts[params[0]] = amount\r\n                    if params[3] == 2:  # crypto\r\n                        amount = CryptoPool5Coins(swap).calc_token_amount(amounts)\r\n                    else:  # tricrypto\r\n                        amount = StablePool5Coins(swap).calc_token_amount(amounts, True)\r\n        elif params[2] in [6, 7]:\r\n            if params[3] == 1:  # stable\r\n                amount = StablePool(swap).calc_withdraw_one_coin(amount, convert(params[1], int128))\r\n            else:  # crypto\r\n                amount = CryptoPool(swap).calc_withdraw_one_coin(amount, params[1])\r\n        elif params[2] == 8:\r\n            if input_token == WETH_ADDRESS or output_token == WETH_ADDRESS:\r\n                # ETH <--> WETH rate is 1:1\r\n                pass\r\n            else:\r\n                raise \"Swap type 8 is only for ETH <-> WETH\"\r\n        else:\r\n            raise \"Bad swap type\"\r\n\r\n        # check if this was the last swap\r\n        if i == 5 or _route[i*2+1] == empty(address):\r\n            break\r\n        # if there is another swap, the output token becomes the input for the next round\r\n        input_token = output_token\r\n\r\n    return amount - 1\r\n\r\n\r\n@view\r\n@external\r\ndef get_dx(\r\n    _route: address[11],\r\n    _swap_params: uint256[5][5],\r\n    _out_amount: uint256,\r\n    _pools: address[5],\r\n    _base_pools: address[5]=empty(address[5]),\r\n    _base_tokens: address[5]=empty(address[5]),\r\n    _second_base_pools: address[5]=empty(address[5]),\r\n    _second_base_tokens: address[5]=empty(address[5]),\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Calculate the input amount required to receive the desired output amount\r\n    @dev Routing and swap params must be determined off-chain. This\r\n         functionality is designed for gas efficiency over ease-of-use.\r\n    @param _route Array of [initial token, pool or zap, token, pool or zap, token, ...]\r\n                  The array is iterated until a pool address of 0x00, then the last\r\n                  given token is transferred to `_receiver`\r\n    @param _swap_params Multidimensional array of [i, j, swap type, pool_type, n_coins] where\r\n                        i is the index of input token\r\n                        j is the index of output token\r\n\r\n                        The swap_type should be:\r\n                        1. for `exchange`,\r\n                        2. for `exchange_underlying`,\r\n                        3. for underlying exchange via zap: factory stable metapools with lending base pool `exchange_underlying`\r\n                           and factory crypto-meta pools underlying exchange (`exchange` method in zap)\r\n                        4. for coin -> LP token \"exchange\" (actually `add_liquidity`),\r\n                        5. for lending pool underlying coin -> LP token \"exchange\" (actually `add_liquidity`),\r\n                        6. for LP token -> coin \"exchange\" (actually `remove_liquidity_one_coin`)\r\n                        7. for LP token -> lending or fake pool underlying coin \"exchange\" (actually `remove_liquidity_one_coin`)\r\n                        8. for ETH <-> WETH, ETH -> stETH or ETH -> frxETH, stETH <-> wstETH, frxETH <-> sfrxETH, ETH -> wBETH\r\n\r\n                        pool_type: 1 - stable, 2 - crypto, 3 - tricrypto, 4 - llamma\r\n                        n_coins is the number of coins in pool\r\n    @param _out_amount The desired amount of output coin to receive.\r\n    @param _pools Array of pools.\r\n    @param _base_pools Array of base pools (for meta pools).\r\n    @param _base_tokens Array of base lp tokens (for meta pools). Should be a zap address for double meta pools.\r\n    @param _second_base_pools Array of the second base pools (for double meta pools like crv/tricrypto and wmatic/tricrypto).\r\n    @param _second_base_tokens Array of the second base lp tokens (for double meta pools  like crv/tricrypto and wmatic/tricrypto).\r\n    @return Required amount of input token to send.\r\n    \"\"\"\r\n    amount: uint256 = _out_amount\r\n\r\n    for _i in range(1, 6):\r\n        # 5 rounds of iteration to perform up to 5 swaps\r\n        i: uint256 = 6 - _i\r\n        swap: address = _route[i*2-1]\r\n        if swap == empty(address):\r\n            continue\r\n        input_token: address = _route[(i - 1) * 2]\r\n        output_token: address = _route[i * 2]\r\n        pool: address = _pools[i-1]\r\n        base_pool: address = _base_pools[i-1]\r\n        base_token: address = _base_tokens[i-1]\r\n        second_base_pool: address = _second_base_pools[i-1]\r\n        second_base_token: address = _second_base_tokens[i-1]\r\n        params: uint256[5] = _swap_params[i-1]  # i, j, swap_type, pool_type, n_coins\r\n        n_coins: uint256 = params[4]\r\n\r\n\r\n        # Calc a required input amount according to the swap type\r\n        if params[2] == 1:\r\n            if params[3] == 1:  # stable\r\n                if base_pool == empty(address):  # non-meta\r\n                    amount = STABLE_CALC.get_dx(pool, convert(params[0], int128), convert(params[1], int128), amount, n_coins)\r\n                else:\r\n                    amount = STABLE_CALC.get_dx_meta(pool, convert(params[0], int128), convert(params[1], int128), amount, n_coins, base_pool)\r\n            elif params[3] in [2, 3]:  # crypto or tricrypto\r\n                amount = CRYPTO_CALC.get_dx(pool, params[0], params[1], amount, n_coins)\r\n            else:  # llamma\r\n                amount = Llamma(pool).get_dx(params[0], params[1], amount)\r\n        elif params[2] in [2, 3]:  # SWAP IS ZAP HERE !!!\r\n            if params[3] == 1:  # stable\r\n                if base_pool == empty(address):  # non-meta\r\n                    amount = STABLE_CALC.get_dx_underlying(pool, convert(params[0], int128), convert(params[1], int128), amount, n_coins)\r\n                else:\r\n                    amount = STABLE_CALC.get_dx_meta_underlying(pool, convert(params[0], int128), convert(params[1], int128), amount, n_coins, base_pool, base_token)\r\n            else:  # crypto\r\n                if second_base_pool != empty(address):  # double-meta\r\n                    # BASE_TOKEN IS BASE_POOL_ZAP HERE !!!\r\n                    amount = CRYPTO_CALC.get_dx_double_meta_underlying(pool, params[0], params[1], amount, base_pool, base_token, second_base_pool, second_base_token)\r\n                elif self.is_tricrypto_meta[pool]:\r\n                    amount = CRYPTO_CALC.get_dx_tricrypto_meta_underlying(pool, params[0], params[1], amount, n_coins, base_pool, base_token)\r\n                else:\r\n                    amount = CRYPTO_CALC.get_dx_meta_underlying(pool, params[0], params[1], amount, n_coins, base_pool, base_token)\r\n        elif params[2] in [4, 5]:\r\n            # This is not correct. Should be something like calc_add_one_coin. But tests say that it's precise enough.\r\n            if params[3] == 1:  # stable\r\n                amount = StablePool(swap).calc_withdraw_one_coin(amount, convert(params[0], int128))\r\n            else:  # crypto\r\n                amount = CryptoPool(swap).calc_withdraw_one_coin(amount, params[0])\r\n        elif params[2] in [6, 7]:\r\n            if params[3] == 1: # stable\r\n                amounts: uint256[10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n                amounts[params[1]] = amount\r\n                amount = STABLE_CALC.calc_token_amount(swap, input_token, amounts, n_coins, False, True)\r\n            else:\r\n                # Tricrypto pools have stablepool interface for calc_token_amount\r\n                if n_coins == 2:\r\n                    amounts: uint256[2] = [0, 0]\r\n                    amounts[params[1]] = amount\r\n                    if params[3] == 2:  # crypto\r\n                        amount = CryptoPool2Coins(swap).calc_token_amount(amounts)  # This is not correct\r\n                    else:  # tricrypto\r\n                        amount = StablePool2Coins(swap).calc_token_amount(amounts, False)\r\n                elif n_coins == 3:\r\n                    amounts: uint256[3] = [0, 0, 0]\r\n                    amounts[params[1]] = amount\r\n                    if params[3] == 2:  # crypto\r\n                        amount = CryptoPool3Coins(swap).calc_token_amount(amounts)  # This is not correct\r\n                    else:  # tricrypto\r\n                        amount = StablePool3Coins(swap).calc_token_amount(amounts, False)\r\n                elif n_coins == 4:\r\n                    amounts: uint256[4] = [0, 0, 0, 0]\r\n                    amounts[params[1]] = amount\r\n                    if params[3] == 2:  # crypto\r\n                        amount = CryptoPool4Coins(swap).calc_token_amount(amounts)  # This is not correct\r\n                    else:  # tricrypto\r\n                        amount = StablePool4Coins(swap).calc_token_amount(amounts, False)\r\n                elif n_coins == 5:\r\n                    amounts: uint256[5] = [0, 0, 0, 0, 0]\r\n                    amounts[params[1]] = amount\r\n                    if params[3] == 2:  # crypto\r\n                        amount = CryptoPool5Coins(swap).calc_token_amount(amounts)  # This is not correct\r\n                    else:  # tricrypto\r\n                        amount = StablePool5Coins(swap).calc_token_amount(amounts, False)\r\n        elif params[2] == 8:\r\n            if input_token == WETH_ADDRESS or output_token == WETH_ADDRESS:\r\n                # ETH <--> WETH rate is 1:1\r\n                pass\r\n            else:\r\n                raise \"Swap type 8 is only for ETH <-> WETH\"\r\n        else:\r\n            raise \"Bad swap type\"\r\n\r\n    return amount", "ABI": "[{\"name\":\"Exchange\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"route\",\"type\":\"address[11]\",\"indexed\":false},{\"name\":\"swap_params\",\"type\":\"uint256[5][5]\",\"indexed\":false},{\"name\":\"pools\",\"type\":\"address[5]\",\"indexed\":false},{\"name\":\"in_amount\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"out_amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"_weth\",\"type\":\"address\"},{\"name\":\"_stable_calc\",\"type\":\"address\"},{\"name\":\"_crypto_calc\",\"type\":\"address\"},{\"name\":\"_tricrypto_meta_pools\",\"type\":\"address[2]\"}],\"outputs\":[]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[5]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"payable\",\"type\":\"function\",\"name\":\"exchange\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_expected\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[5]\"},{\"name\":\"_receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dy\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[5]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_out_amount\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[5]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_out_amount\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[5]\"},{\"name\":\"_base_pools\",\"type\":\"address[5]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_out_amount\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[5]\"},{\"name\":\"_base_pools\",\"type\":\"address[5]\"},{\"name\":\"_base_tokens\",\"type\":\"address[5]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_out_amount\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[5]\"},{\"name\":\"_base_pools\",\"type\":\"address[5]\"},{\"name\":\"_base_tokens\",\"type\":\"address[5]\"},{\"name\":\"_second_base_pools\",\"type\":\"address[5]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_dx\",\"inputs\":[{\"name\":\"_route\",\"type\":\"address[11]\"},{\"name\":\"_swap_params\",\"type\":\"uint256[5][5]\"},{\"name\":\"_out_amount\",\"type\":\"uint256\"},{\"name\":\"_pools\",\"type\":\"address[5]\"},{\"name\":\"_base_pools\",\"type\":\"address[5]\"},{\"name\":\"_base_tokens\",\"type\":\"address[5]\"},{\"name\":\"_second_base_pools\",\"type\":\"address[5]\"},{\"name\":\"_second_base_tokens\",\"type\":\"address[5]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "CurveRouterSidechainTricryptoMeta v1.0", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000000d500b1d8e8ef31e21c99d1db9a6444d3adf1270000000000000000000000000ca8d0747b5573d69653c3ac22242e6341c36e4b4000000000000000000000000a72c85c258a81761433b4e8da60505fe3dd551cc00000000000000000000000092215849c439e1f8612b6646060b4e3e5ef822cc0000000000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": ""}