{"SourceCode": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity >=0.8.0;\r\n\r\n\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    \r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    \r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    \r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    \r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    \r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    \r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    \r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\nlibrary Address {\r\n    \r\n    function isContract(address account) internal view returns (bool) {\r\n        \r\n        \r\n        \r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    \r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    \r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCall(target, data, \"Address: low-level call failed\");\r\n    }\r\n\r\n    \r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    \r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    \r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    \r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        require(isContract(target), \"Address: static call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    \r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    \r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(isContract(target), \"Address: delegate call to non-contract\");\r\n\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResult(success, returndata, errorMessage);\r\n    }\r\n\r\n    \r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            \r\n            if (returndata.length > 0) {\r\n                \r\n                \r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(errorMessage);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface IERC721Receiver {\r\n    \r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\nlibrary Constants {\r\n\r\n  \r\n  uint256 internal constant PERCENT_PRECISION = 1e4;\r\n  uint256 public constant ADMIN_FEE_PERCENT = 10_00; \r\n\r\n  \r\n  uint8 public constant PLANET_LEVELS_NUMBER = 50;\r\n  uint8 public constant NEXT_PLANET_THRESHOLD = 30;\r\n\r\n  \r\n  uint256 public constant BUY_ENERGY_MIN_VALUE = 1.25 ether;\r\n  uint256 public constant TOKENS_WITHDRAW_LIMIT = 150_00; \r\n\r\n  uint256 public constant ENERGY_FOR_MATIC = 800;\r\n  uint256 public constant ENERGY_FOR_CRYSTAL = 110_00; \r\n\r\n  \r\n  uint256 public constant NFT_PRICE = 300 ether;\r\n  uint256 public constant NFT_MAX_SUPPLY = 10_000;\r\n\r\n}\r\n\r\nlibrary GameModels {\r\n\r\n  uint8 public constant REF_LEVELS_NUMBER = 7;\r\n\r\n  struct Player {\r\n    address referrer;\r\n    address[] referrals;\r\n    uint256[REF_LEVELS_NUMBER] referralsNumber;\r\n    uint256 turnover;\r\n    uint256[REF_LEVELS_NUMBER] turnoverLines;\r\n\r\n    uint256 invested;\r\n    uint256 referralRewardFromBuyEnergy;\r\n    uint256 referralRewardFromExchange;\r\n    uint256 withdrawn;\r\n    uint256 withdrawnCrystals;\r\n    uint256[2][REF_LEVELS_NUMBER] referralRewards;\r\n\r\n    \r\n    uint256 xp;\r\n    uint8 level;\r\n  }\r\n\r\n  struct PlayerBalance {\r\n    uint256 energy;\r\n    uint256 crystals;\r\n\r\n    uint256 lastCollectionTime;\r\n    uint256 lastRocketPushTime;\r\n  }\r\n\r\n}\r\n\r\ninterface IPancakeRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}\r\n\r\ninterface IPancakePair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}\r\n\r\ninterface ICommonInterface {\r\n\r\n  \r\n\r\n  function mint(address to, uint256 amount) external;\r\n\r\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\r\n\r\n  \r\n\r\n  function ownerOf(uint256 tokenId) external view returns (address);\r\n\r\n  function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n\r\n  \r\n\r\n  function level(uint256 tokenId) external view returns (uint8);\r\n\r\n  function markAsUsed(address playerAddr, uint256 tokenId) external;\r\n\r\n  function upgrade(address playerAddr, uint256 tokenId, uint8 toLevel) external;\r\n\r\n  function MATIC_RECEIVER_ADDRESS() external returns (address);\r\n\r\n}\r\n\r\nlibrary Events {\r\n\r\n  event Registration(\r\n    address indexed playerAddr,\r\n    address indexed referrerAddr,\r\n    uint256 registrationNumber,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event BuyEnergy(\r\n    address indexed playerAddr,\r\n    uint256 bnbAmount,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event ExchangeCrystals(\r\n    address indexed playerAddr,\r\n    uint256 crystals,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event ReferralReward(\r\n    address indexed receiverAddr,\r\n    address indexed payerAddr,\r\n    uint256 rewardAmount, \r\n    uint256 bnbAmount,\r\n    uint8 rewardType, \r\n    uint256 timestamp\r\n  );\r\n\r\n  event UpgradePlanet(\r\n    address indexed playerAddr,\r\n    uint8 indexed planetIdx,\r\n    uint8 boughtLevels,\r\n    uint8 resultLevel,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event AttachCharacter(\r\n    address indexed playerAddr,\r\n    uint256 tokenId,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event DetachCharacter(\r\n    address indexed playerAddr,\r\n    uint256 tokenId,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event UpgradeCharacter(\r\n    address indexed playerAddr,\r\n    uint256 indexed chracterTokenId,\r\n    uint8 toLevel\r\n  );\r\n\r\n  event RatingUpdate(\r\n    address indexed playerAddr,\r\n    uint256 rating,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event CollectResources(\r\n    address indexed playerAddr,\r\n    uint256 energy,\r\n    uint256 crystals,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event WithdrawCrystals(\r\n    address indexed playerAddr,\r\n    uint256 crystals,\r\n    uint256 bnbValue,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event PushRocket(\r\n    address indexed playerAddr,\r\n    uint256 timestamp\r\n  );\r\n\r\n  event CollectAchievementReward(\r\n    address indexed playerAddr,\r\n    uint8 indexed level,\r\n    uint256 timestamp\r\n  );\r\n\r\n}\r\n\r\ncontract Stellum is Ownable, IERC721Receiver {\r\n\r\n  uint8 public constant PLANETS_NUMBER = 8;\r\n  uint256[PLANETS_NUMBER] public PLANET_LEVEL_PRICE = [\r\n    1_000 ether,\r\n    2_700 ether,\r\n    7_500 ether,\r\n    20_000 ether,\r\n    55_000 ether,\r\n    145_000 ether,\r\n    400_000 ether,\r\n    1_000_000 ether\r\n  ];\r\n\r\n  uint8 public constant ACHIEVEMENTS_NUMBER = 12;\r\n  uint256[ACHIEVEMENTS_NUMBER] public ACHIEVEMENTS_XP = [\r\n    0,\r\n    50_000,\r\n    200_000,\r\n    500_000,\r\n    1_350_000,\r\n    3_225_000,\r\n    5_725_000,\r\n    8_850_000,\r\n    12_725_000,\r\n    23_500_000,\r\n    45_000_000,\r\n    80_000_000\r\n  ];\r\n\r\n  uint256[ACHIEVEMENTS_NUMBER] public ACHIEVEMENTS_REWARDS = [\r\n    0,\r\n    1_500 ether,\r\n    6_000 ether,\r\n    15_000 ether,\r\n    40_000 ether,\r\n    96_000 ether,\r\n    171_000 ether,\r\n    265_000 ether,\r\n    381_000 ether,\r\n    700_000 ether,\r\n    1_300_000 ether,\r\n    2_300_000 ether\r\n  ];\r\n\r\n  uint8 public constant CHARACTER_LEVELS = 20;\r\n  uint256[CHARACTER_LEVELS] public CHARACTER_LEVEL_UPGARE_PRICE_MATIC = [\r\n    300 ether, 0, 0, 0, 0,\r\n    0, 0, 0, 0, 0,\r\n    300 ether, 0, 0, 0, 600 ether,\r\n    0, 0, 0, 0, 1_500 ether\r\n  ];\r\n  uint256[CHARACTER_LEVELS] public CHARACTER_LEVEL_UPGARE_PRICE_CRYSTALS = [\r\n    0, 6_200 ether, 9_300 ether, 12_300 ether, 15_400 ether,\r\n    18_500 ether, 21_600 ether, 24_700 ether, 27_800 ether, 30_900 ether,\r\n    0, 39_900 ether, 49_700 ether, 60_500 ether, 0,\r\n    64_000 ether, 78_200 ether, 93_700 ether, 114_000 ether, 0\r\n  ];\r\n\r\n  uint8 public constant REFERRAL_LEVELS_NUMBER = 5;\r\n  uint8 public constant MAX_REFERRAL_LEVELS_NUMBER = 7;\r\n  uint256[MAX_REFERRAL_LEVELS_NUMBER] public REFERRAL_PERCENTS = [5_00, 2_00, 1_00, 1_00, 1_00, 1_00, 1_00]; \r\n\r\n  address immutable public DEFAULT_REFERRER;\r\n  address immutable public PROMOTION_ADDRESS;\r\n  address immutable public NFT_TOKEN_ADDRESS;\r\n  address immutable public ERC20_TOKEN_ADDRESS;\r\n  address public LP_TOKEN_ADDRESS; \r\n  address public QUICKSWAP_ROUTER_ADDRESS;\r\n  address public immutable WRAPPED_MATIC;\r\n\r\n  mapping(address => GameModels.Player) public players;\r\n  mapping(address => GameModels.PlayerBalance) public balances;\r\n  mapping(address => uint8[PLANETS_NUMBER]) planets;\r\n  mapping(address => uint256) characters;\r\n\r\n  uint8 public TOKENS_BUY_BACK_PERCENT = 10;\r\n\r\n  uint256 public totalUsers;\r\n  uint256 public totalSpent;\r\n  uint256[PLANETS_NUMBER] public unlockedPlanets;\r\n  uint256[PLANETS_NUMBER] public unlockedPlanetLevels;\r\n  uint256 public totalCrystalsWithdrawn;\r\n\r\n  constructor(\r\n    address defaultReferrerAddress,\r\n    address promotionAddress,\r\n    address nftTokenAddress,\r\n    address erc20TokenAddress,\r\n    address lpTokenContractAddress\r\n  ) {\r\n    require(defaultReferrerAddress != address(0x0), \"Invalid default referrer address\");\r\n    require(Address.isContract(lpTokenContractAddress), \"Invalid LP-token contract address\");\r\n\r\n    DEFAULT_REFERRER = defaultReferrerAddress;\r\n    PROMOTION_ADDRESS = promotionAddress;\r\n\r\n    NFT_TOKEN_ADDRESS = nftTokenAddress;\r\n\r\n    ERC20_TOKEN_ADDRESS = erc20TokenAddress;\r\n    LP_TOKEN_ADDRESS = lpTokenContractAddress;\r\n\r\n    QUICKSWAP_ROUTER_ADDRESS = address(0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff);\r\n    WRAPPED_MATIC = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\r\n  }\r\n\r\n  receive() external payable {}\r\n\r\n  function buyEnergy(address referrer) external payable {\r\n    require(msg.value >= Constants.BUY_ENERGY_MIN_VALUE, \"Minimal amount is 1.25 MATIC\");\r\n\r\n    GameModels.Player storage player = players[msg.sender];\r\n    \r\n    if (player.referrer == address(0x0)) {\r\n      if (referrer == address(0x0) || referrer == msg.sender || players[referrer].referrer == address(0x0)) {\r\n        referrer = DEFAULT_REFERRER;\r\n      }\r\n      player.referrer = referrer;\r\n      players[referrer].referrals.push(msg.sender);\r\n\r\n      totalUsers++;\r\n\r\n      emit Events.RatingUpdate(referrer, getRating(referrer), block.timestamp);\r\n\r\n      emit Events.Registration(\r\n        msg.sender, referrer, totalUsers, block.timestamp\r\n      );\r\n    }\r\n\r\n    player.invested+= msg.value;\r\n    balances[msg.sender].energy+= msg.value * Constants.ENERGY_FOR_MATIC;\r\n\r\n    totalSpent+= msg.value;\r\n\r\n    \r\n    uint256 xp = msg.value * Constants.ENERGY_FOR_MATIC * Constants.PERCENT_PRECISION / 1 ether;\r\n    player.xp+= xp * getXPMultiplier(msg.sender);\r\n    emit Events.RatingUpdate(msg.sender, getRating(msg.sender), block.timestamp);\r\n\r\n    \r\n    uint256 tokensAmount = getTokensAmount(msg.value);\r\n    address ref = player.referrer;\r\n    for (uint8 i = 0; i < MAX_REFERRAL_LEVELS_NUMBER; i++) {\r\n      if (i < REFERRAL_LEVELS_NUMBER || getReferralLevelsNumber(ref) > i) {\r\n        uint256 tokensRewardAmount = tokensAmount * REFERRAL_PERCENTS[i] / Constants.PERCENT_PRECISION;\r\n        uint256 bnbRewardAmount = msg.value * REFERRAL_PERCENTS[i] / Constants.PERCENT_PRECISION;\r\n\r\n        ICommonInterface(ERC20_TOKEN_ADDRESS).mint(ref, tokensRewardAmount);\r\n        players[ref].referralRewardFromBuyEnergy+= bnbRewardAmount;\r\n        players[ref].referralRewards[i][0]+= bnbRewardAmount;\r\n\r\n        emit Events.ReferralReward(\r\n          ref,\r\n          msg.sender,\r\n          tokensRewardAmount,\r\n          bnbRewardAmount,\r\n          0,\r\n          block.timestamp\r\n        );\r\n      }\r\n\r\n      \r\n      if (i == 0) {\r\n        players[ref].xp+= xp * getXPMultiplier(ref) / 2;\r\n        emit Events.RatingUpdate(ref, getRating(ref), block.timestamp);\r\n      } else if (i == 1) {\r\n        players[ref].xp+= xp * getXPMultiplier(ref) / 4;\r\n        emit Events.RatingUpdate(ref, getRating(ref), block.timestamp);\r\n      }\r\n\r\n      \r\n      players[ref].turnover+= msg.value;\r\n      players[ref].turnoverLines[i]+= msg.value;\r\n\r\n      players[ref].referralsNumber[i]++;\r\n\r\n      ref = players[ref].referrer;\r\n      if (ref == address(0x0)) {\r\n        ref = DEFAULT_REFERRER;\r\n      }\r\n    }\r\n\r\n    payable(owner()).transfer(msg.value * Constants.ADMIN_FEE_PERCENT / Constants.PERCENT_PRECISION);\r\n    \r\n\r\n    \r\n    buyBackTokens(address(this).balance * uint256(TOKENS_BUY_BACK_PERCENT) / 100);\r\n    addLiquidity(address(this).balance);\r\n\r\n    emit Events.BuyEnergy(\r\n      msg.sender, msg.value, block.timestamp\r\n    );\r\n  }\r\n\r\n  function upgradePlanet(uint8 planetIdx, uint8 levelsToBuy) external {\r\n    require(!Address.isContract(msg.sender), \"Buyer shouldn't be a contract\"); \r\n    require(planetIdx >= 0 && planetIdx < PLANETS_NUMBER, \"Invalid planet index\");\r\n    require(planetIdx == 0 || planets[msg.sender][planetIdx - 1] >= Constants.NEXT_PLANET_THRESHOLD, \"This planed is closed. Upgrade previous planet first.\");\r\n    require(levelsToBuy <= Constants.PLANET_LEVELS_NUMBER, \"Invalid levels to buy amount\");\r\n\r\n    if (planets[msg.sender][planetIdx] + levelsToBuy > Constants.PLANET_LEVELS_NUMBER) {\r\n      levelsToBuy = Constants.PLANET_LEVELS_NUMBER - planets[msg.sender][planetIdx];\r\n    }\r\n    require(levelsToBuy > 0, \"Invalid levels to buy amount\");\r\n\r\n    collectCrystalsAndEnergy();\r\n\r\n    uint256 energyAmount = levelsToBuy * PLANET_LEVEL_PRICE[planetIdx];\r\n    require(balances[msg.sender].energy >= energyAmount, \"Not enough energy on the balance\");\r\n\r\n    if (planets[msg.sender][planetIdx] == 0) {\r\n      unlockedPlanets[planetIdx]++;\r\n    }\r\n    unlockedPlanetLevels[planetIdx]+= levelsToBuy;\r\n\r\n    balances[msg.sender].energy-= energyAmount;\r\n    planets[msg.sender][planetIdx]+= levelsToBuy;\r\n\r\n    emit Events.UpgradePlanet(\r\n      msg.sender, planetIdx, levelsToBuy, planets[msg.sender][planetIdx], block.timestamp\r\n    );\r\n  }\r\n\r\n  function mayBeCollected(address playerAddr) public view returns (uint256 energy, uint256 crystals) {\r\n    if (balances[playerAddr].lastCollectionTime == 0 || balances[playerAddr].lastCollectionTime == block.timestamp) {\r\n      return (0 , 0);\r\n    }\r\n\r\n    GameModels.PlayerBalance memory balance = balances[playerAddr];\r\n    uint256 startTime = balance.lastCollectionTime;\r\n    uint256 endTime = block.timestamp;\r\n    if (startTime < balance.lastRocketPushTime) {\r\n      startTime = balance.lastRocketPushTime;\r\n    }\r\n    if (endTime > balance.lastRocketPushTime + getRocketFlightDuration(playerAddr)) {\r\n      endTime = balance.lastRocketPushTime + getRocketFlightDuration(playerAddr);\r\n    }\r\n\r\n    if (startTime >= endTime) {\r\n      return (0 , 0);\r\n    }\r\n    uint256 time = endTime - startTime;\r\n\r\n    uint256 profit = 0;\r\n    for (uint8 planetIdx = 0; planetIdx < PLANETS_NUMBER; planetIdx++) {\r\n      if (planets[playerAddr][planetIdx] > 0) {\r\n        profit+= PLANET_LEVEL_PRICE[planetIdx] * planets[playerAddr][planetIdx];\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (profit == 0) {\r\n      return (0 , 0);\r\n    }\r\n    profit= profit * time / 30 days;\r\n    crystals = profit * getPerformanceRatio(playerAddr) / Constants.PERCENT_PRECISION;\r\n\r\n    return (profit - crystals, crystals);\r\n  }\r\n\r\n  function collectCrystalsAndEnergy() public {\r\n    GameModels.PlayerBalance storage balance = balances[msg.sender];\r\n\r\n    if (balance.lastCollectionTime == 0) {\r\n      balance.lastCollectionTime = block.timestamp;\r\n      balance.lastRocketPushTime = block.timestamp;\r\n\r\n      return;\r\n    }\r\n\r\n    (uint256 energy, uint256 crystals) = mayBeCollected(msg.sender);\r\n    if (energy == 0 || crystals == 0) {\r\n      return;\r\n    }\r\n\r\n    balance.energy+= energy;\r\n    balance.crystals+= crystals;\r\n    balance.lastCollectionTime = block.timestamp;\r\n\r\n    emit Events.CollectResources(\r\n      msg.sender, energy, crystals, block.timestamp\r\n    );\r\n  }\r\n\r\n  function instantBalance(address playerAddr) external view returns (uint256, uint256) {\r\n    GameModels.PlayerBalance memory balance = balances[playerAddr];\r\n\r\n    (uint256 energy, uint256 crystals) = mayBeCollected(playerAddr);\r\n\r\n    return (balance.energy + energy, balance.crystals + crystals);\r\n  }\r\n\r\n  \r\n  function changeCrystalsForEnergy(uint256 crystalsAmount) external {\r\n    require(crystalsAmount > 0, \"Invalid crystals amount\");\r\n\r\n    collectCrystalsAndEnergy();\r\n    require(crystalsAmount <= balances[msg.sender].crystals, \"Not enough crystals on the balance\");\r\n\r\n    balances[msg.sender].crystals-= crystalsAmount;\r\n    balances[msg.sender].energy+= crystalsAmount * Constants.ENERGY_FOR_CRYSTAL / Constants.PERCENT_PRECISION;\r\n\r\n    \r\n    address ref = players[msg.sender].referrer;\r\n    for (uint8 i = 0; i < MAX_REFERRAL_LEVELS_NUMBER; i++) {\r\n      if (i < REFERRAL_LEVELS_NUMBER || getReferralLevelsNumber(ref) > i) {\r\n        uint256 rewardAmount = crystalsAmount * REFERRAL_PERCENTS[i] / Constants.PERCENT_PRECISION;\r\n        uint256 bnbRewardAmount = rewardAmount / Constants.ENERGY_FOR_MATIC;\r\n\r\n        balances[ref].energy+= rewardAmount;\r\n        players[ref].referralRewardFromExchange+= bnbRewardAmount;\r\n        players[ref].referralRewards[i][1]+= bnbRewardAmount;\r\n\r\n        emit Events.ReferralReward(\r\n          ref,\r\n          msg.sender,\r\n          rewardAmount,\r\n          bnbRewardAmount,\r\n          1,\r\n          block.timestamp\r\n        );\r\n      }\r\n\r\n      ref = players[ref].referrer;\r\n      if (ref == address(0x0)) {\r\n        ref = DEFAULT_REFERRER;\r\n      }\r\n    }\r\n\r\n    emit Events.ExchangeCrystals(\r\n      msg.sender, crystalsAmount, block.timestamp\r\n    );\r\n  }\r\n\r\n  \r\n  function withdrawCrystals(uint256 crystalsAmount) external {\r\n    require(crystalsAmount > 0, \"Invalid crystals amount\");\r\n\r\n    collectCrystalsAndEnergy();\r\n    require(crystalsAmount <= balances[msg.sender].crystals, \"Not enough crystals on the balance\");\r\n\r\n    uint256 tokensMayBeWithdrawn = mayBeWithdrawn(msg.sender);\r\n    require(tokensMayBeWithdrawn > 0, \"You have reached withdrawal limit\");\r\n    if (crystalsAmount > tokensMayBeWithdrawn) {\r\n      crystalsAmount = tokensMayBeWithdrawn;\r\n    }\r\n\r\n    GameModels.Player storage player = players[msg.sender];\r\n    uint256 value = getMATICAmount(crystalsAmount);\r\n\r\n    player.withdrawn+= value;\r\n    player.withdrawnCrystals+= crystalsAmount;\r\n    totalCrystalsWithdrawn+= crystalsAmount;\r\n\r\n    balances[msg.sender].crystals-= crystalsAmount;\r\n\r\n    ICommonInterface(ERC20_TOKEN_ADDRESS).mint(msg.sender, crystalsAmount);\r\n\r\n    emit Events.WithdrawCrystals(\r\n      msg.sender, crystalsAmount, value, block.timestamp\r\n    );\r\n  }\r\n\r\n  function mayBeWithdrawn(address playerAddr) public view returns (uint256) {\r\n    GameModels.Player memory player = players[playerAddr];\r\n\r\n    uint256 bnbAmount =\r\n      (player.invested + player.referralRewardFromExchange) * Constants.TOKENS_WITHDRAW_LIMIT / Constants.PERCENT_PRECISION\r\n      - player.withdrawn;\r\n\r\n    return getTokensAmount(bnbAmount);\r\n  }\r\n\r\n  function attachCharacter(uint256 tokenId) external {\r\n    require(characters[msg.sender] == 0, \"You have already attached other character\");\r\n    require(ICommonInterface(NFT_TOKEN_ADDRESS).ownerOf(tokenId) == msg.sender, \"You are not an owner of this NFT\");\r\n\r\n    collectCrystalsAndEnergy();\r\n\r\n    ICommonInterface(NFT_TOKEN_ADDRESS).safeTransferFrom(msg.sender, address(this), tokenId);\r\n    characters[msg.sender] = tokenId;\r\n\r\n    ICommonInterface(NFT_TOKEN_ADDRESS).markAsUsed(msg.sender, tokenId);\r\n\r\n    emit Events.AttachCharacter(\r\n      msg.sender, tokenId, block.timestamp\r\n    );\r\n\r\n    \r\n    balances[msg.sender].lastRocketPushTime = block.timestamp;\r\n  }\r\n\r\n  function detachCharacter() external {\r\n    require(characters[msg.sender] > 0, \"You have no attached character\");\r\n    require(\r\n      ICommonInterface(NFT_TOKEN_ADDRESS).ownerOf(characters[msg.sender]) == address(this),\r\n      \"We have no this NFT on the contract\"\r\n    );\r\n\r\n    collectCrystalsAndEnergy();\r\n\r\n    ICommonInterface(NFT_TOKEN_ADDRESS).safeTransferFrom(address(this), msg.sender, characters[msg.sender]);\r\n    emit Events.DetachCharacter(\r\n      msg.sender, characters[msg.sender], block.timestamp\r\n    );\r\n    characters[msg.sender] = 0;\r\n\r\n    \r\n    balances[msg.sender].lastRocketPushTime = block.timestamp;\r\n  }\r\n\r\n  function upgradeCharacter(uint8 toLevel) external payable {\r\n    require(toLevel <= 20, \"Invalid level value\");\r\n    require(characters[msg.sender] > 0, \"You have no attached character\");\r\n    require(\r\n      ICommonInterface(NFT_TOKEN_ADDRESS).ownerOf(characters[msg.sender]) == address(this),\r\n      \"Character NFT isn't attached to the game\"\r\n    );\r\n\r\n    uint8 characterLvl = ICommonInterface(NFT_TOKEN_ADDRESS).level(characters[msg.sender]);\r\n    require(characterLvl < 20, \"You have reached the maximum level\");\r\n    require(toLevel > characterLvl, \"You can't downgrade character\");\r\n\r\n    collectCrystalsAndEnergy();\r\n\r\n    uint256 upgradePriceMATIC = 0;\r\n    uint256 upgradePriceCrystals = 0;\r\n    for (uint8 lvl = characterLvl; lvl < toLevel; lvl++) {\r\n      upgradePriceMATIC+= CHARACTER_LEVEL_UPGARE_PRICE_MATIC[lvl];\r\n      upgradePriceCrystals+= CHARACTER_LEVEL_UPGARE_PRICE_CRYSTALS[lvl];\r\n    }\r\n\r\n    if (upgradePriceMATIC > 0) {\r\n      require(msg.value == upgradePriceMATIC, \"Invalid upgrade MATIC amount\");\r\n\r\n      payable(ICommonInterface(NFT_TOKEN_ADDRESS).MATIC_RECEIVER_ADDRESS()).transfer(msg.value);\r\n    }\r\n\r\n    if (upgradePriceCrystals > 0) {\r\n      require(\r\n        balances[msg.sender].crystals >= upgradePriceCrystals,\r\n        \"Insufficient crystals balance\"\r\n      );\r\n\r\n      balances[msg.sender].crystals-= upgradePriceCrystals;\r\n    }\r\n    ICommonInterface(NFT_TOKEN_ADDRESS).upgrade(msg.sender, characters[msg.sender], toLevel);\r\n\r\n    emit Events.RatingUpdate(msg.sender, getRating(msg.sender), block.timestamp);\r\n\r\n    emit Events.UpgradeCharacter(msg.sender, characters[msg.sender], toLevel);\r\n\r\n    \r\n    balances[msg.sender].lastRocketPushTime = block.timestamp;\r\n  }\r\n\r\n  function pushRocket() external {\r\n    collectCrystalsAndEnergy();\r\n\r\n    balances[msg.sender].lastRocketPushTime = block.timestamp;\r\n\r\n    emit Events.PushRocket(msg.sender, block.timestamp);\r\n  }\r\n\r\n  \r\n  function getRocketState(address playerAddr) external view returns (uint256 lastRocketPushTime, uint256 duration) {\r\n    return (balances[playerAddr].lastRocketPushTime, getRocketFlightDuration(playerAddr));\r\n  }\r\n\r\n  function getMATICAmount(uint256 tokensAmount) public view returns(uint256) {\r\n    (uint256 reserve0, uint256 reserve1, ) = IPancakePair(LP_TOKEN_ADDRESS).getReserves();\r\n\r\n    return tokensAmount * reserve1 / reserve0;\r\n  }\r\n\r\n  function getTokensAmount(uint256 amount) public view returns(uint256) {\r\n    (uint256 reserve0, uint256 reserve1, ) = IPancakePair(LP_TOKEN_ADDRESS).getReserves();\r\n\r\n    return amount * reserve0 / reserve1;\r\n  }\r\n\r\n  function getTokenLiquidity() external view returns (\r\n    uint256 liquidityMATIC,\r\n    uint256 liquiditySTM\r\n  ) {\r\n    (liquiditySTM, liquidityMATIC, ) = IPancakePair(LP_TOKEN_ADDRESS).getReserves();\r\n  }\r\n\r\n  function buyBackTokens(uint256 bnbAmount) private {\r\n    address[] memory path = new address[](2);\r\n    path[0] = WRAPPED_MATIC; \r\n    path[1] = ERC20_TOKEN_ADDRESS;\r\n\r\n    IPancakeRouter(QUICKSWAP_ROUTER_ADDRESS).swapExactETHForTokens {value: bnbAmount} (\r\n      0,\r\n      path,\r\n      PROMOTION_ADDRESS,\r\n      block.timestamp + 5 minutes\r\n    );\r\n\r\n    \r\n  }\r\n\r\n  function addLiquidity(uint256 bnbAmount) private {\r\n    uint256 amount = getTokensAmount(bnbAmount);\r\n\r\n    ICommonInterface(ERC20_TOKEN_ADDRESS).mint(address(this), amount);\r\n    ICommonInterface(ERC20_TOKEN_ADDRESS).increaseAllowance(QUICKSWAP_ROUTER_ADDRESS, amount);\r\n\r\n    \r\n\r\n    (uint256 amountToken, uint256 amountMATIC, uint256 liquidity) = IPancakeRouter(QUICKSWAP_ROUTER_ADDRESS).addLiquidityETH {value: bnbAmount} (\r\n      ERC20_TOKEN_ADDRESS,\r\n      amount,\r\n      0,\r\n      0,\r\n      address(this),\r\n      block.timestamp + 5 minutes\r\n    );\r\n\r\n    \r\n\r\n    \r\n  }\r\n\r\n  function addLiquidityManually(uint256 bnbAmount) external onlyOwner {\r\n    addLiquidity(bnbAmount);\r\n  }\r\n\r\n  function normalizePrice(uint256 tokensAmount) external onlyOwner {\r\n    address[] memory path = new address[](2);\r\n    path[0] = ERC20_TOKEN_ADDRESS;\r\n    path[1] = WRAPPED_MATIC; \r\n\r\n    ICommonInterface(ERC20_TOKEN_ADDRESS).mint(address(this), tokensAmount);\r\n    ICommonInterface(ERC20_TOKEN_ADDRESS).increaseAllowance(QUICKSWAP_ROUTER_ADDRESS, tokensAmount);\r\n\r\n    IPancakeRouter(QUICKSWAP_ROUTER_ADDRESS).swapExactTokensForETH(\r\n      tokensAmount,\r\n      0,\r\n      path,\r\n      address(this),\r\n      block.timestamp + 5 minutes\r\n    );\r\n\r\n    addLiquidity(address(this).balance);\r\n  }\r\n\r\n  function changePancakeRouterAddress(address newAddr) external onlyOwner {\r\n    require(newAddr != address(0x0) && Address.isContract(newAddr), \"Invalid PancakeRouter address\");\r\n    require(newAddr != QUICKSWAP_ROUTER_ADDRESS, \"Address is already setted\");\r\n\r\n    QUICKSWAP_ROUTER_ADDRESS = newAddr;\r\n  }\r\n\r\n  function changeTokensBuyBackPercent(uint8 percent) external onlyOwner {\r\n    require(percent > 0 && percent <= 100, \"Invalid percent value\");\r\n\r\n    TOKENS_BUY_BACK_PERCENT = percent;\r\n  }\r\n\r\n  function getReferralLevelsNumber(address playerAddr) public view returns (uint8 refLevelsNumber) {\r\n    if (characters[playerAddr] == 0) {\r\n      return REFERRAL_LEVELS_NUMBER;\r\n    }\r\n\r\n    uint8 characterLvl = ICommonInterface(NFT_TOKEN_ADDRESS).level(characters[playerAddr]);\r\n    if (characterLvl >= 15) {\r\n      return (REFERRAL_LEVELS_NUMBER + 2);\r\n    } else if (characterLvl >= 11) {\r\n      return (REFERRAL_LEVELS_NUMBER + 1);\r\n    }\r\n\r\n    return REFERRAL_LEVELS_NUMBER;\r\n  }\r\n\r\n  \r\n  function getPerformanceRatio(address playerAddr) public view returns (uint256 performanceRatio) {\r\n    if (characters[playerAddr] == 0) {\r\n      return 40_00;\r\n    }\r\n\r\n    uint8 characterLvl = ICommonInterface(NFT_TOKEN_ADDRESS).level(characters[playerAddr]);\r\n\r\n    return (40_00 + 1_00 * uint256(characterLvl));\r\n  }\r\n\r\n  function getRocketFlightDuration(address playerAddr) public view returns (uint256 rocketFlyDuration) {\r\n    if (characters[playerAddr] == 0) {\r\n      return (24 hours);\r\n    }\r\n\r\n    uint8 characterLvl = ICommonInterface(NFT_TOKEN_ADDRESS).level(characters[playerAddr]);\r\n    if (characterLvl >= 19) {\r\n      return (24 hours + 240 hours);\r\n    } else if (characterLvl >= 16) {\r\n      return (24 hours + 144 hours);\r\n    } else if (characterLvl >= 14) {\r\n      return (24 hours + 120 hours);\r\n    } else if (characterLvl >= 10) {\r\n      return (24 hours + 96 hours);\r\n    } else if (characterLvl >= 8) {\r\n      return (24 hours + 72 hours);\r\n    } else if (characterLvl >= 5) {\r\n      return (24 hours + 48 hours);\r\n    } else if (characterLvl >= 2) {\r\n      return (24 hours + 24 hours);\r\n    } else if (characterLvl == 1) {\r\n      return (24 hours + 12 hours);\r\n    }\r\n\r\n    return (24 hours);\r\n  }\r\n\r\n  function getXPMultiplier(address playerAddr) public view returns (uint256 xpMultiplier) {\r\n    if (characters[playerAddr] == 0) {\r\n      return Constants.PERCENT_PRECISION;\r\n    }\r\n\r\n    uint8 characterLvl = ICommonInterface(NFT_TOKEN_ADDRESS).level(characters[playerAddr]);\r\n    if (characterLvl >= 13) {\r\n      return Constants.PERCENT_PRECISION + 30_00;\r\n    } else if (characterLvl >= 11) {\r\n      return Constants.PERCENT_PRECISION + 25_00;\r\n    } else if (characterLvl >= 9) {\r\n      return Constants.PERCENT_PRECISION + 20_00;\r\n    } else if (characterLvl >= 7) {\r\n      return Constants.PERCENT_PRECISION + 15_00;\r\n    } else if (characterLvl >= 5) {\r\n      return Constants.PERCENT_PRECISION + 10_00;\r\n    } else if (characterLvl >= 3) {\r\n      return Constants.PERCENT_PRECISION + 5_00;\r\n    }\r\n\r\n    return Constants.PERCENT_PRECISION;\r\n  }\r\n\r\n  function getRatingMultiplier(address playerAddr) public view returns (uint256 ratingMultiplier) {\r\n    if (characters[playerAddr] == 0) {\r\n      return Constants.PERCENT_PRECISION;\r\n    }\r\n\r\n    uint8 characterLvl = ICommonInterface(NFT_TOKEN_ADDRESS).level(characters[playerAddr]);\r\n\r\n    return Constants.PERCENT_PRECISION + uint256(characterLvl) * 10_00;\r\n  }\r\n\r\n  function getRating(address playerAddr) public view returns (uint256 rating) {\r\n    return (players[playerAddr].xp + players[playerAddr].referrals.length * 50_000 * Constants.PERCENT_PRECISION * Constants.PERCENT_PRECISION)\r\n      * getRatingMultiplier(playerAddr) / Constants.PERCENT_PRECISION\r\n      / Constants.PERCENT_PRECISION\r\n      / Constants.PERCENT_PRECISION;\r\n  }\r\n\r\n  function collectAchievementReward() external {\r\n    GameModels.Player storage player = players[msg.sender];\r\n\r\n    uint8 lvl = player.level + 1;\r\n    while (lvl < ACHIEVEMENTS_NUMBER) {\r\n      if (player.xp >= ACHIEVEMENTS_XP[lvl] * Constants.PERCENT_PRECISION * Constants.PERCENT_PRECISION) {\r\n        balances[msg.sender].energy+= ACHIEVEMENTS_REWARDS[lvl];\r\n        lvl++;\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    player.level = lvl - 1;\r\n\r\n    emit Events.CollectAchievementReward(msg.sender, player.level, block.timestamp);\r\n  }\r\n\r\n  function onERC721Received(\r\n    address operator,\r\n    address from,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external pure returns (bytes4) {\r\n    return this.onERC721Received.selector; \r\n  }\r\n\r\n  function referrals(address playerAddr) external view returns (address[] memory) {\r\n    return players[playerAddr].referrals;\r\n  }\r\n\r\n  function commonReferralStats(address playerAddr) external view returns (\r\n    address referrer,\r\n    uint256 referralsCount,\r\n    uint256 structureVolume,\r\n    uint256 turnover,\r\n    address[] memory referralsList,\r\n    uint256[MAX_REFERRAL_LEVELS_NUMBER] memory referralsNumber,\r\n    uint256[MAX_REFERRAL_LEVELS_NUMBER] memory turnoverLines\r\n  ) {\r\n    GameModels.Player memory player = players[playerAddr];\r\n\r\n    for (uint8 i = 0; i < MAX_REFERRAL_LEVELS_NUMBER; i++) {\r\n      structureVolume+= player.referralsNumber[i];\r\n    }\r\n\r\n    return (\r\n      player.referrer,\r\n      player.referrals.length,\r\n      structureVolume,\r\n      player.turnover,\r\n      player.referrals,\r\n      player.referralsNumber,\r\n      player.turnoverLines\r\n    );\r\n  }\r\n\r\n  function getReferralRewards(address playerAddr) external view returns (\r\n    uint256[] memory referralRewardsFromBuyEnergy, uint256[] memory referralRewardsFromExchange\r\n  ) {\r\n    GameModels.Player memory player = players[playerAddr];\r\n\r\n    referralRewardsFromBuyEnergy = new uint256[](MAX_REFERRAL_LEVELS_NUMBER);\r\n    referralRewardsFromExchange = new uint256[](MAX_REFERRAL_LEVELS_NUMBER);\r\n\r\n    for (uint8 i = 0; i < MAX_REFERRAL_LEVELS_NUMBER; i++) {\r\n      referralRewardsFromBuyEnergy[i] = player.referralRewards[i][0];\r\n      referralRewardsFromExchange[i] = player.referralRewards[i][1];\r\n    }\r\n  }\r\n\r\n  function getPlanetsStats() external view returns (\r\n    uint256[] memory unlockedPlanetsStats,\r\n    uint256[] memory unlockedPlanetLevelsStats\r\n  ) {\r\n    unlockedPlanetsStats = new uint256[](PLANETS_NUMBER);\r\n    unlockedPlanetLevelsStats = new uint256[](PLANETS_NUMBER);\r\n\r\n    for (uint8 i = 0; i < PLANETS_NUMBER; i++) {\r\n      unlockedPlanetsStats[i] = unlockedPlanets[i];\r\n      unlockedPlanetLevelsStats[i] = unlockedPlanetLevels[i];\r\n    }\r\n  }\r\n\r\n  function getPlayerPlanets(address playerAddr) external view returns (uint8[PLANETS_NUMBER] memory) {\r\n    return planets[playerAddr];\r\n  }\r\n\r\n  function buyEnergy() external payable {\r\n    payable(msg.sender).transfer(msg.value);\r\n\r\n    \r\n  }\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"defaultReferrerAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"promotionAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"nftTokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"erc20TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lpTokenContractAddress\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ACHIEVEMENTS_NUMBER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ACHIEVEMENTS_REWARDS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ACHIEVEMENTS_XP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CHARACTER_LEVELS\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CHARACTER_LEVEL_UPGARE_PRICE_CRYSTALS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"CHARACTER_LEVEL_UPGARE_PRICE_MATIC\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DEFAULT_REFERRER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ERC20_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"LP_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_REFERRAL_LEVELS_NUMBER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NFT_TOKEN_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLANETS_NUMBER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"PLANET_LEVEL_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROMOTION_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"QUICKSWAP_ROUTER_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REFERRAL_LEVELS_NUMBER\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOKENS_BUY_BACK_PERCENT\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WRAPPED_MATIC\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bnbAmount\",\"type\":\"uint256\"}],\"name\":\"addLiquidityManually\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"attachCharacter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"energy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crystals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastCollectionTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRocketPushTime\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buyEnergy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buyEnergy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"crystalsAmount\",\"type\":\"uint256\"}],\"name\":\"changeCrystalsForEnergy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"changePancakeRouterAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"percent\",\"type\":\"uint8\"}],\"name\":\"changeTokensBuyBackPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectAchievementReward\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"collectCrystalsAndEnergy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"commonReferralStats\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"referralsCount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"structureVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"turnover\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"referralsList\",\"type\":\"address[]\"},{\"internalType\":\"uint256[7]\",\"name\":\"referralsNumber\",\"type\":\"uint256[7]\"},{\"internalType\":\"uint256[7]\",\"name\":\"turnoverLines\",\"type\":\"uint256[7]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"detachCharacter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"getMATICAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getPerformanceRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"performanceRatio\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPlanetsStats\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"unlockedPlanetsStats\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"unlockedPlanetLevelsStats\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getPlayerPlanets\",\"outputs\":[{\"internalType\":\"uint8[8]\",\"name\":\"\",\"type\":\"uint8[8]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getRating\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rating\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getRatingMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"ratingMultiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getReferralLevelsNumber\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"refLevelsNumber\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getReferralRewards\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"referralRewardsFromBuyEnergy\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"referralRewardsFromExchange\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getRocketFlightDuration\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"rocketFlyDuration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getRocketState\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"lastRocketPushTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"duration\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTokenLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidityMATIC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquiditySTM\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getTokensAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"getXPMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"xpMultiplier\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"instantBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"mayBeCollected\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"energy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"crystals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"mayBeWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"normalizePrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"turnover\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"invested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralRewardFromBuyEnergy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"referralRewardFromExchange\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"withdrawnCrystals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"xp\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"level\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pushRocket\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"playerAddr\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalCrystalsWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSpent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unlockedPlanetLevels\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unlockedPlanets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"toLevel\",\"type\":\"uint8\"}],\"name\":\"upgradeCharacter\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"planetIdx\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"levelsToBuy\",\"type\":\"uint8\"}],\"name\":\"upgradePlanet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"crystalsAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawCrystals\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Stellum", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000c07e5f85c9647a90bbc8ebbd6f1f1756bb3b225a0000000000000000000000000f2e395e26296d0ec3769f829186a05c621fe1440000000000000000000000004c8bc94e2bcf4b1df48ae3cc901dbe4f8610112d0000000000000000000000000d1e5baeb64d1a56c1bedbd6fe7cc8ea0af674630000000000000000000000001da0aed52fd91cb167ed52c3a74913a5baae9cf6", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fd6baf6940a52f40333c9a629a87d89a1487163520e63834030b716acf0c1f27"}