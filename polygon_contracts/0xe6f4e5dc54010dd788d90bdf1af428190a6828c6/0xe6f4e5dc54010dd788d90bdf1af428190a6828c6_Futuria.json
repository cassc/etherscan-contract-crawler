{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./extensions/IERC20Metadata.sol\\\";\\nimport \\\"../../utils/Context.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\\n * instead returning `false` on failure. This behavior is nonetheless\\n * conventional and does not conflict with the expectations of ERC20\\n * applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20, IERC20Metadata {\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}.\\n     *\\n     * The default value of {decimals} is 18. To select a different value for\\n     * {decimals} you should overload it.\\n     *\\n     * All two of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name_, string memory symbol_) {\\n        _name = name_;\\n        _symbol = symbol_;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual override returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual override returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\\n     * overridden;\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual override returns (uint8) {\\n        return 18;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _transfer(owner, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * NOTE: Does not update the allowance if the current allowance\\n     * is the maximum `uint256`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` and `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``from``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual override returns (bool) {\\n        address spender = _msgSender();\\n        _spendAllowance(from, spender, amount);\\n        _transfer(from, to, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        address owner = _msgSender();\\n        uint256 currentAllowance = allowance(owner, spender);\\n        require(currentAllowance >= subtractedValue, \\\"ERC20: decreased allowance below zero\\\");\\n        unchecked {\\n            _approve(owner, spender, currentAllowance - subtractedValue);\\n        }\\n\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves `amount` of tokens from `from` to `to`.\\n     *\\n     * This internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `from` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {\\n        require(from != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(to != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(from, to, amount);\\n\\n        uint256 fromBalance = _balances[from];\\n        require(fromBalance >= amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        unchecked {\\n            _balances[from] = fromBalance - amount;\\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\\n            // decrementing then incrementing.\\n            _balances[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        _afterTokenTransfer(from, to, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply += amount;\\n        unchecked {\\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\\n            _balances[account] += amount;\\n        }\\n        emit Transfer(address(0), account, amount);\\n\\n        _afterTokenTransfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        uint256 accountBalance = _balances[account];\\n        require(accountBalance >= amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        unchecked {\\n            _balances[account] = accountBalance - amount;\\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\\n            _totalSupply -= amount;\\n        }\\n\\n        emit Transfer(account, address(0), amount);\\n\\n        _afterTokenTransfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\\n     *\\n     * Does not update the allowance amount in case of infinite allowance.\\n     * Revert if not enough allowance is available.\\n     *\\n     * Might emit an {Approval} event.\\n     */\\n    function _spendAllowance(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal virtual {\\n        uint256 currentAllowance = allowance(owner, spender);\\n        if (currentAllowance != type(uint256).max) {\\n            require(currentAllowance >= amount, \\\"ERC20: insufficient allowance\\\");\\n            unchecked {\\n                _approve(owner, spender, currentAllowance - amount);\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n\\n    /**\\n     * @dev Hook that is called after any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * has been transferred to `to`.\\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _afterTokenTransfer(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal virtual {}\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Counters.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary Counters {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/Futuria.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.17;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Counters.sol\\\";\\n\\n// import \\\"hardhat/console.sol\\\";\\n\\ncontract Futuria is Ownable {\\n    using Counters for Counters.Counter;\\n    Counters.Counter _tokenIdCounter;\\n\\n    bool isTestnet = block.chainid == 80001;\\n\\n    struct EarningsItem {\\n        address addr;\\n        uint256 earningsWithoutIndirectCommissions;\\n        uint256 indirectCommissions;\\n    }\\n\\n    struct User {\\n        address addr;\\n        uint256 directCustomersVolume;\\n        uint256 weeklyDirectCustomersVolume;\\n        uint256 purchases;\\n        uint256 weeklyPurchases;\\n        uint256 earnings;\\n        uint256 minRank;\\n        address sponsor;\\n        address leg1Address;\\n        address leg2Address;\\n        bool isRightLegSelected;\\n        uint256 leftTurnover;\\n        uint256 rightTurnover;\\n        uint256 legPosition;\\n        uint256 subscriberTimestamp;\\n        uint256 penalty;\\n        bool isFounder;\\n    }\\n\\n    struct Subscription {\\n        uint256 price;\\n        uint256 subsLength;\\n        uint256 tokenId;\\n    }\\n\\n    address public tokenAddress =\\n        isTestnet\\n            ? 0xA02f6adc7926efeBBd59Fd43A84f4E0c0c91e832\\n            : 0xc2132D05D31c914a87C6611C10748AEb04B58e8F; // USDT\\n    address admin = 0x0D0095Ac3d4E5F01c6B625A971bA893b42E5AEf6;\\n    address defaultReferralAccount = 0x2198354afa0bCb24ddd0344d69D89a88B8876674;\\n\\n    uint256 public subscriptionPercentage = 97;\\n    uint256 public matchingBonus = 10;\\n    uint256 public championBonus = 3;\\n    uint256 public minWeeklyTurnoverPerLeg = isTestnet ? 1 ether : 200 ether;\\n    uint256 public weekTurnover = 0;\\n    uint256 public globalCap = 65;\\n    uint256 public championBonusMinAmount = 2000 ether;\\n\\n    uint256[] public directSalesPercentage = [20, 25, 27, 30, 35];\\n    uint256[] public binaryPercentage = [10, 12, 15, 17, 20];\\n\\n    // User addresses\\n    address[] public addresses;\\n    mapping(address => bool) public hasAddress;\\n\\n    // Volume\\n    mapping(address => uint256) public addressToDirectCustomersVolume;\\n    mapping(address => uint256) public addressToWeeklyDirectCustomersVolume;\\n    mapping(address => uint256) public addressToPurchases;\\n    mapping(address => uint256) public addressToWeeklyPurchases;\\n    mapping(address => uint256) public addressToEarnings;\\n    mapping(address => uint256) public addressToMinRank;\\n    uint256[] public minParity = [\\n        1500 ether,\\n        5000 ether,\\n        25000 ether,\\n        100000 ether\\n    ];\\n    uint256[] public salesToAchieveRank = [\\n        1500 ether,\\n        5000 ether,\\n        25000 ether,\\n        50000 ether\\n    ];\\n\\n    // Extra bonus\\n    uint256[] public extraBonusMinAmount = [150 ether, 300 ether, 1500 ether];\\n    uint256[] public extraBonusPerc = [3, 5, 10];\\n\\n    // Legs\\n    mapping(address => address) public addressToSponsor;\\n    mapping(address => address) public addressToLeg1Address;\\n    mapping(address => address) public addressToLeg2Address;\\n    mapping(address => bool) public addressToIsRightLegSelected;\\n    mapping(address => uint256) public addressToLeftTurnover;\\n    mapping(address => uint256) public addressToRightTurnover;\\n    mapping(address => uint256) public addressToLegPosition; // 1 for left, 2 for right\\n\\n    // Price\\n    mapping(uint256 => uint256) public tokenIdToPrice;\\n\\n    // Subscriptions\\n    mapping(address => uint256) public subscriberToTimestamp;\\n    mapping(address => uint256) public addressToPenalty;\\n    mapping(uint256 => uint256) public tokenIdToSubsLength;\\n\\n    mapping(address => bool) public isFounder;\\n    uint256 public remainingFounders = 250;\\n    uint256 public founderBonusPercentage = 1;\\n\\n    constructor() {\\n        saveAddressIfNeeded(defaultReferralAccount);\\n        saveAddressIfNeeded(admin);\\n\\n        subscriberToTimestamp[defaultReferralAccount] = 1687450370000000;\\n        addFounderIfPossible(defaultReferralAccount);\\n    }\\n\\n    modifier onlyAdmin() {\\n        require(isAdmin());\\n        _;\\n    }\\n\\n    // View functions\\n    function checkIfActiveSubscription(\\n        address addr\\n    ) public view returns (bool) {\\n        return subscriberToTimestamp[addr] >= block.timestamp;\\n    }\\n\\n    function totalSupply() public view virtual returns (uint256) {\\n        return _tokenIdCounter.current();\\n    }\\n\\n    function allowanceToken(\\n        address owner,\\n        address spender\\n    ) public view returns (uint256) {\\n        return ERC20(tokenAddress).allowance(owner, spender);\\n    }\\n\\n    function getTreeSum(\\n        address rootAddress,\\n        uint256 count\\n    ) public view virtual returns (uint256) {\\n        address leg1Address = addressToLeg1Address[rootAddress];\\n        address leg2Address = addressToLeg2Address[rootAddress];\\n        uint256 sum = addressToWeeklyPurchases[rootAddress];\\n\\n        if (count > 800) {\\n            return sum;\\n        }\\n\\n        if (leg1Address != address(0)) {\\n            sum += getTreeSum(leg1Address, count + 1);\\n        }\\n\\n        if (leg2Address != address(0)) {\\n            sum += getTreeSum(leg2Address, count + 1);\\n        }\\n\\n        return sum;\\n    }\\n\\n    function hasMatchingBonus(address addr) public view returns (bool) {\\n        bool hasActiveSubs = checkIfActiveSubscription(addr);\\n\\n        if (!hasActiveSubs || rankOf(addr) < 2) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function hasChampionBonus(address addr) public view returns (bool) {\\n        bool hasActiveSubs = checkIfActiveSubscription(addr);\\n        uint256 sales = addressToDirectCustomersVolume[addr];\\n        uint256 rank = rankOf(addr);\\n\\n        if (!hasActiveSubs || sales < championBonusMinAmount || rank < 3) {\\n            return false;\\n        }\\n\\n        return true;\\n    }\\n\\n    function getChampionBonusAmount() public view returns (uint256) {\\n        return (weekTurnover * championBonus) / 100;\\n    }\\n\\n    function getFoundersBonusAmount() public view returns (uint256) {\\n        return (weekTurnover * founderBonusPercentage) / 100;\\n    }\\n\\n    function getDirectSalesPercentage(\\n        address addr\\n    ) public view returns (uint256) {\\n        return directSalesPercentage[rankOf(addr) - 1];\\n    }\\n\\n    function getDirectCommissions(address addr) public view returns (uint256) {\\n        uint256 weeklyDirectCustomersVolume = addressToWeeklyDirectCustomersVolume[\\n                addr\\n            ];\\n        return\\n            (weeklyDirectCustomersVolume * getDirectSalesPercentage(addr)) /\\n            100;\\n    }\\n\\n    function getIndirectCommissions(\\n        address addr\\n    ) public view returns (uint256) {\\n        bool hasActiveSubs = checkIfActiveSubscription(addr);\\n        uint256 parity = getParity(addr);\\n\\n        if (!hasActiveSubs || parity < minWeeklyTurnoverPerLeg) {\\n            return 0;\\n        }\\n\\n        uint256 rank = rankOf(addr);\\n        uint256 binaryPerc = binaryPercentage[rank - 1];\\n        uint256 binaryExtraBonus = getBinaryExtraBonus(addr);\\n        uint256 percentage = binaryExtraBonus + binaryPerc;\\n\\n        return (parity * percentage) / 100;\\n    }\\n\\n    function getWeeklyLegsTurnover(\\n        address rootAddress\\n    ) public view returns (uint256[] memory) {\\n        address leg1Address = addressToLeg1Address[rootAddress];\\n        address leg2Address = addressToLeg2Address[rootAddress];\\n        uint256[] memory weeklyLegsTurnover = new uint256[](2);\\n\\n        weeklyLegsTurnover[0] =\\n            getTreeSum(leg1Address, 0) +\\n            addressToLeftTurnover[rootAddress];\\n        weeklyLegsTurnover[1] =\\n            getTreeSum(leg2Address, 0) +\\n            addressToRightTurnover[rootAddress];\\n\\n        return weeklyLegsTurnover;\\n    }\\n\\n    function getBinaryExtraBonus(address addr) public view returns (uint256) {\\n        uint256 weeklyVolume = addressToWeeklyDirectCustomersVolume[addr];\\n\\n        if (weeklyVolume >= extraBonusMinAmount[2]) {\\n            return extraBonusPerc[2];\\n        } else if (weeklyVolume >= extraBonusMinAmount[1]) {\\n            return extraBonusPerc[1];\\n        } else if (weeklyVolume >= extraBonusMinAmount[0]) {\\n            return extraBonusPerc[0];\\n        }\\n\\n        return 0;\\n    }\\n\\n    function getParity(address addr) public view returns (uint256) {\\n        uint256[] memory weeklyLegsTurnover = getWeeklyLegsTurnover(addr);\\n        uint256 leftTurnover = weeklyLegsTurnover[0];\\n        uint256 rightTurnover = weeklyLegsTurnover[1];\\n\\n        return leftTurnover >= rightTurnover ? rightTurnover : leftTurnover;\\n    }\\n\\n    function rankOf(address addr) public view returns (uint256) {\\n        uint256 sales = addressToDirectCustomersVolume[addr];\\n        uint256 salesToAchieveRank2 = salesToAchieveRank[0];\\n        uint256 salesToAchieveRank3 = salesToAchieveRank[1];\\n        uint256 salesToAchieveRank4 = salesToAchieveRank[2];\\n        uint256 salesToAchieveRank5 = salesToAchieveRank[3];\\n        uint256 rankPenalty = addressToPenalty[addr];\\n        uint256 rank = 1;\\n        uint256 minRank = addressToMinRank[addr];\\n        uint256 parity = getParity(addr);\\n\\n        if (sales >= salesToAchieveRank5 || parity >= minParity[3]) {\\n            rank = 5;\\n        } else if (sales >= salesToAchieveRank4 || parity >= minParity[2]) {\\n            rank = 4;\\n        } else if (sales >= salesToAchieveRank3 || parity >= minParity[1]) {\\n            rank = 3;\\n        } else if (\\n            sales >= salesToAchieveRank2 ||\\n            isFounder[addr] ||\\n            parity >= minParity[0]\\n        ) {\\n            rank = 2;\\n        }\\n\\n        if (minRank > rank) {\\n            rank = minRank;\\n        }\\n\\n        rank = rank - rankPenalty;\\n\\n        if (rank < 1) {\\n            return 1;\\n        }\\n\\n        return rank;\\n    }\\n\\n    function claim() public payable {\\n        uint256 tokenAmountInWei = addressToEarnings[msg.sender];\\n        uint256 tokenBalance = ERC20(tokenAddress).balanceOf(address(this));\\n\\n        require(tokenAmountInWei > 0, \\\"0 amount\\\");\\n        require(tokenBalance > 0, \\\"No tokens\\\");\\n\\n        addressToEarnings[msg.sender] = 0;\\n        saveAddressIfNeeded(msg.sender);\\n        transferToken(tokenAmountInWei);\\n    }\\n\\n    function setContractState(\\n        User[] memory users,\\n        Subscription[] memory subscription,\\n        uint256 _weekTurnover\\n    ) external onlyOwner {\\n        for (uint256 i = 0; i < users.length; i++) {\\n            User memory user = users[i];\\n\\n            saveAddressIfNeeded(user.addr);\\n\\n            if (user.isFounder) {\\n                addFounderIfPossible(user.addr);\\n            }\\n\\n            // Set other state variables\\n            addressToDirectCustomersVolume[user.addr] = user\\n                .directCustomersVolume;\\n            addressToWeeklyDirectCustomersVolume[user.addr] = user\\n                .weeklyDirectCustomersVolume;\\n            addressToPurchases[user.addr] = user.purchases;\\n            addressToWeeklyPurchases[user.addr] = user.weeklyPurchases;\\n            addressToEarnings[user.addr] = user.earnings;\\n            addressToMinRank[user.addr] = user.minRank;\\n            addressToSponsor[user.addr] = user.sponsor;\\n            addressToLeg1Address[user.addr] = user.leg1Address;\\n            addressToLeg2Address[user.addr] = user.leg2Address;\\n            addressToIsRightLegSelected[user.addr] = user.isRightLegSelected;\\n            addressToLeftTurnover[user.addr] = user.leftTurnover;\\n            addressToRightTurnover[user.addr] = user.rightTurnover;\\n            addressToLegPosition[user.addr] = user.legPosition;\\n            subscriberToTimestamp[user.addr] = user.subscriberTimestamp;\\n            addressToPenalty[user.addr] = user.penalty;\\n        }\\n\\n        for (uint256 i = 0; i < subscription.length; i++) {\\n            Subscription memory data = subscription[i];\\n            safeMint(1, msg.sender, data.price, data.subsLength);\\n        }\\n\\n        weekTurnover = _weekTurnover;\\n    }\\n\\n    function updateSubscription(\\n        uint256 tokenId,\\n        uint256 price,\\n        uint256 subsLength\\n    ) external onlyAdmin {\\n        tokenIdToSubsLength[tokenId] = subsLength;\\n        tokenIdToPrice[tokenId] = price;\\n    }\\n\\n    function deposit() external payable {\\n        require(msg.value > 0, \\\"Amount should be greater than 0\\\");\\n    }\\n\\n    function depositTokens(uint256 amount) external {\\n        require(amount > 0, \\\"Amount should be greater than 0\\\");\\n\\n        ERC20 token = ERC20(tokenAddress);\\n\\n        // transferFrom will throw if there's insufficient allowance or insufficient balance\\n        require(\\n            token.transferFrom(msg.sender, address(this), amount),\\n            \\\"Token transfer failed\\\"\\n        );\\n    }\\n\\n    function subscribe(\\n        uint256 tokenId,\\n        address referralAddress\\n    ) external payable {\\n        uint256 subsPrice = tokenIdToPrice[tokenId];\\n        uint256 volume = (subsPrice * subscriptionPercentage) / 100;\\n        address sponsor = addToTreeIfNeeded(referralAddress);\\n\\n        if (sponsor != address(0)) {\\n            updateDirectCustomersVolume(sponsor, volume);\\n        }\\n\\n        subscriberToTimestamp[msg.sender] =\\n            block.timestamp +\\n            tokenIdToSubsLength[tokenId];\\n        updatePurchases(msg.sender, volume);\\n        addFounderIfPossible(msg.sender);\\n        transferFromToken(msg.sender, address(this), subsPrice);\\n    }\\n\\n    function subscribeOnlyAdmin(\\n        uint256 tokenId,\\n        address subscriber\\n    ) external onlyAdmin {\\n        uint256 subsPrice = tokenIdToPrice[tokenId];\\n        uint256 volume = (subsPrice * subscriptionPercentage) / 100;\\n        address sponsor = addressToSponsor[subscriber];\\n\\n        if (sponsor != address(0)) {\\n            updateDirectCustomersVolume(sponsor, volume);\\n        }\\n\\n        subscriberToTimestamp[subscriber] =\\n            block.timestamp +\\n            tokenIdToSubsLength[tokenId];\\n        updatePurchases(subscriber, volume);\\n        addFounderIfPossible(subscriber);\\n    }\\n\\n    // Fallback function to accept Main Currency\\n    receive() external payable {}\\n\\n    function setSelectedLeg(\\n        bool isRightLegSelected,\\n        address referralAddress\\n    ) external payable {\\n        addressToIsRightLegSelected[msg.sender] = isRightLegSelected;\\n        saveAddressIfNeeded(msg.sender);\\n        addToTreeIfNeeded(referralAddress);\\n    }\\n\\n    // Admin functions\\n    function setPercentages(\\n        uint256[] calldata _directSalesPercentage,\\n        uint256[] calldata _binaryPercentage,\\n        uint256[] calldata _salesToAchieveRank,\\n        uint256 _minWeeklyTurnoverPerLeg,\\n        uint256 _globalCap,\\n        uint256 _subscriptionPercentage,\\n        uint256 _matchingBonus,\\n        uint256 _championBonus\\n    ) external onlyAdmin {\\n        directSalesPercentage = _directSalesPercentage;\\n        binaryPercentage = _binaryPercentage;\\n        salesToAchieveRank = _salesToAchieveRank;\\n        championBonus = _championBonus;\\n        minWeeklyTurnoverPerLeg = _minWeeklyTurnoverPerLeg;\\n        globalCap = _globalCap;\\n        subscriptionPercentage = _subscriptionPercentage;\\n        matchingBonus = _matchingBonus;\\n    }\\n\\n    function addFounderIfPossibleOnlyAdmin(address addr) external onlyAdmin {\\n        addFounderIfPossible(addr);\\n    }\\n\\n    function addToTreeOnlyAdmin(\\n        address rootAddress,\\n        address newUser\\n    ) public onlyAdmin {\\n        bool isRightLegSelected = addressToIsRightLegSelected[rootAddress];\\n        addressToSponsor[newUser] = rootAddress;\\n        addToTree(rootAddress, newUser, isRightLegSelected, 0);\\n    }\\n\\n    function safeMint(\\n        uint256 quantity,\\n        address to,\\n        uint256 price,\\n        uint256 subsLength\\n    ) public payable onlyAdmin {\\n        for (uint256 i; i < quantity; i++) {\\n            uint256 tokenId = _tokenIdCounter.current();\\n            _tokenIdCounter.increment();\\n            tokenIdToPrice[tokenId] = price;\\n            tokenIdToSubsLength[tokenId] = subsLength;\\n        }\\n\\n        saveAddressIfNeeded(to);\\n    }\\n\\n    function setWeeklyEarnings(EarningsItem[] memory items) external onlyAdmin {\\n        for (uint i = 0; i < items.length; i++) {\\n            addressToEarnings[items[i].addr] += items[i]\\n                .earningsWithoutIndirectCommissions;\\n            setIndirectCommissions(items[i].addr, items[i].indirectCommissions);\\n        }\\n\\n        resetWeek();\\n    }\\n\\n    function setAddressToEarnings(\\n        address addr,\\n        uint256 earnings\\n    ) external onlyAdmin {\\n        addressToEarnings[addr] = earnings;\\n    }\\n\\n    function setIndirectCommissionsOnlyAdmin(\\n        address addr,\\n        uint256 earnings\\n    ) external onlyAdmin {\\n        setIndirectCommissions(addr, earnings);\\n    }\\n\\n    function stopSubscription(\\n        address addr,\\n        uint256 rankPenalty\\n    ) external onlyAdmin {\\n        subscriberToTimestamp[addr] = 0;\\n        setPenalty(addr, rankPenalty);\\n    }\\n\\n    function setSubscriberToTimestamp(\\n        address addr,\\n        uint256 timestamp\\n    ) external onlyAdmin {\\n        subscriberToTimestamp[addr] = timestamp;\\n    }\\n\\n    function setMinParity(uint256[] calldata _minParity) external onlyAdmin {\\n        minParity = _minParity;\\n    }\\n\\n    function setChampionBonusMinAmount(\\n        uint256 _championBonusMinAmount\\n    ) external onlyAdmin {\\n        championBonusMinAmount = _championBonusMinAmount;\\n    }\\n\\n    function setWeekTurnover(uint256 _weekTurnover) external onlyAdmin {\\n        weekTurnover = _weekTurnover;\\n    }\\n\\n    function resetWeekOnlyAdmin() external onlyAdmin {\\n        resetWeek();\\n    }\\n\\n    function renewSubscription(\\n        address addr,\\n        uint256 tokenId\\n    ) external onlyAdmin {\\n        uint256 subsPrice = tokenIdToPrice[tokenId];\\n        uint256 volume = (subsPrice * subscriptionPercentage) / 100;\\n        address sponsor = addressToSponsor[addr];\\n\\n        weekTurnover += volume;\\n        subscriberToTimestamp[addr] =\\n            block.timestamp +\\n            tokenIdToSubsLength[tokenId];\\n        saveAddressIfNeeded(addr);\\n        updateDirectCustomersVolume(sponsor, volume);\\n        updatePurchases(addr, volume);\\n        transferFromToken(addr, address(this), subsPrice);\\n    }\\n\\n    function setPenalty(address addr, uint256 rankPenalty) public onlyAdmin {\\n        addressToPenalty[addr] = rankPenalty;\\n        saveAddressIfNeeded(addr);\\n    }\\n\\n    function updateDirectCustomersVolumeOnlyAdmin(\\n        address sponsor,\\n        uint256 amount\\n    ) external onlyAdmin {\\n        updateDirectCustomersVolume(sponsor, amount);\\n    }\\n\\n    function setAddressToWeeklyPurchases(\\n        address addr,\\n        uint256 amountInWei\\n    ) external onlyAdmin {\\n        saveAddressIfNeeded(addr);\\n        addressToWeeklyPurchases[addr] = amountInWei;\\n    }\\n\\n    function setLegs(\\n        address rootAddress,\\n        address leg1Address,\\n        address leg2Address\\n    ) external onlyAdmin {\\n        require(\\n            rootAddress != leg1Address && leg1Address != leg2Address,\\n            \\\"invalid addr\\\"\\n        );\\n\\n        if (leg1Address != address(0)) {\\n            addressToLeg1Address[rootAddress] = leg1Address;\\n        }\\n\\n        if (leg2Address != address(0)) {\\n            addressToLeg2Address[rootAddress] = leg2Address;\\n        }\\n\\n        saveAddressIfNeeded(rootAddress);\\n        saveAddressIfNeeded(leg1Address);\\n        saveAddressIfNeeded(leg2Address);\\n    }\\n\\n    function setWeeklyDirectCustomersVolume(\\n        address addr,\\n        uint256 amountInWei\\n    ) external onlyAdmin {\\n        saveAddressIfNeeded(addr);\\n        addressToWeeklyDirectCustomersVolume[addr] = amountInWei;\\n    }\\n\\n    function setAddressToMinRank(\\n        address addr,\\n        uint256 rank\\n    ) external onlyAdmin {\\n        addressToMinRank[addr] = rank;\\n    }\\n\\n    function setAddressToLeftTurnover(\\n        address addr,\\n        uint256 turnover\\n    ) external onlyAdmin {\\n        addressToLeftTurnover[addr] = turnover;\\n    }\\n\\n    function setAddressToRightTurnover(\\n        address addr,\\n        uint256 turnover\\n    ) external onlyAdmin {\\n        addressToRightTurnover[addr] = turnover;\\n    }\\n\\n    function setAddressToSponsor(\\n        address addr,\\n        address sponsor\\n    ) external onlyAdmin {\\n        addressToSponsor[addr] = sponsor;\\n    }\\n\\n    function setAddressToLeg1Address(\\n        address addr1,\\n        address addr2\\n    ) external onlyAdmin {\\n        addressToLeg1Address[addr1] = addr2;\\n    }\\n\\n    function setAddressToLeg2Address(\\n        address addr1,\\n        address addr2\\n    ) external onlyAdmin {\\n        addressToLeg2Address[addr1] = addr2;\\n    }\\n\\n    function setExtraBonus(\\n        uint256[] calldata _extraBonusMinAmount,\\n        uint256[] calldata _extraBonusPerc\\n    ) external virtual onlyAdmin {\\n        extraBonusMinAmount = _extraBonusMinAmount;\\n        extraBonusPerc = _extraBonusPerc;\\n    }\\n\\n    function setAdmin(address _admin) external virtual onlyAdmin {\\n        if (admin != _admin) {\\n            admin = _admin;\\n        }\\n    }\\n\\n    function setDefaultReferralAccount(\\n        address _defaultReferralAccount\\n    ) external virtual onlyAdmin {\\n        defaultReferralAccount = _defaultReferralAccount;\\n    }\\n\\n    function setFounderBonusPercentage(\\n        uint256 _founderBonusPercentage\\n    ) external virtual onlyAdmin {\\n        founderBonusPercentage = _founderBonusPercentage;\\n    }\\n\\n    function updateTokenAddress(\\n        address _tokenAddress\\n    ) external virtual onlyAdmin {\\n        tokenAddress = _tokenAddress;\\n    }\\n\\n    function withdrawMatic() external payable onlyAdmin {\\n        (bool success, ) = payable(msg.sender).call{\\n            value: address(this).balance\\n        }(\\\"\\\");\\n        require(success);\\n    }\\n\\n    function withdrawToken(\\n        uint256 tokenAmountInWei\\n    ) external payable onlyAdmin {\\n        if (tokenAmountInWei > 0) {\\n            transferToken(tokenAmountInWei);\\n        }\\n    }\\n\\n    function saveLegPositionOnlyAdmin(\\n        address newUser,\\n        uint256 leg\\n    ) external onlyAdmin {\\n        saveLegPosition(newUser, leg);\\n    }\\n\\n    // Internal\\n    function transferToken(uint256 amount) internal {\\n        ERC20(tokenAddress).transfer(msg.sender, amount);\\n    }\\n\\n    function isAdmin() internal view returns (bool) {\\n        return\\n            msg.sender == owner() ||\\n            msg.sender == admin ||\\n            msg.sender == defaultReferralAccount;\\n    }\\n\\n    function addToTreeIfNeeded(\\n        address referralAddress\\n    ) internal returns (address) {\\n        bool isDefaultReferralAccount = msg.sender == defaultReferralAccount;\\n        address sponsor = addressToSponsor[msg.sender];\\n\\n        if (!isDefaultReferralAccount) {\\n            if (referralAddress == address(0)) {\\n                referralAddress = defaultReferralAccount;\\n            }\\n\\n            require(referralAddress != msg.sender, \\\"invalid addr\\\");\\n\\n            if (sponsor == address(0)) {\\n                addressToSponsor[msg.sender] = referralAddress;\\n                addToTree(\\n                    referralAddress,\\n                    msg.sender,\\n                    addressToIsRightLegSelected[referralAddress],\\n                    0\\n                );\\n\\n                return referralAddress;\\n            }\\n        }\\n\\n        return sponsor;\\n    }\\n\\n    function updatePurchases(address addr, uint256 volume) internal {\\n        saveAddressIfNeeded(addr);\\n\\n        addressToPurchases[addr] += volume;\\n        addressToWeeklyPurchases[addr] += volume;\\n        weekTurnover += volume;\\n    }\\n\\n    function resetWeek() internal {\\n        for (uint256 i; i < addresses.length; i++) {\\n            address addr = addresses[i];\\n\\n            if (rankOf(addr) > addressToMinRank[addr]) {\\n                addressToMinRank[addr] = rankOf(addr);\\n            }\\n        }\\n\\n        weekTurnover = 0;\\n\\n        for (uint256 i; i < addresses.length; i++) {\\n            address addr = addresses[i];\\n\\n            addressToWeeklyDirectCustomersVolume[addr] = 0;\\n            addressToWeeklyPurchases[addr] = 0;\\n        }\\n    }\\n\\n    function setIndirectCommissions(address addr, uint256 earnings) internal {\\n        uint256[] memory weeklyLegsTurnover = getWeeklyLegsTurnover(addr);\\n        uint256 leftTurnover = weeklyLegsTurnover[0];\\n        uint256 rightTurnover = weeklyLegsTurnover[1];\\n\\n        if (earnings == 0) {\\n            addressToLeftTurnover[addr] = leftTurnover;\\n            addressToRightTurnover[addr] = rightTurnover;\\n        } else if (leftTurnover >= rightTurnover) {\\n            addressToLeftTurnover[addr] = leftTurnover - rightTurnover;\\n            addressToRightTurnover[addr] = 0;\\n        } else {\\n            addressToLeftTurnover[addr] = 0;\\n            addressToRightTurnover[addr] = rightTurnover - leftTurnover;\\n        }\\n\\n        addressToEarnings[addr] += earnings;\\n    }\\n\\n    function saveLegPosition(address newUser, uint256 leg) internal {\\n        require(leg == 1 || leg == 2);\\n        addressToLegPosition[newUser] = leg;\\n    }\\n\\n    function saveLegPositionIfNeeded(address newUser, uint256 leg) internal {\\n        if (addressToLegPosition[newUser] == 0) {\\n            saveLegPosition(newUser, leg);\\n        }\\n    }\\n\\n    function saveLegData(\\n        address rootAddress,\\n        address newUser,\\n        uint256 leg\\n    ) internal {\\n        saveAddressIfNeeded(rootAddress);\\n        saveAddressIfNeeded(newUser);\\n        saveLegPositionIfNeeded(newUser, leg);\\n    }\\n\\n    function addToTree(\\n        address rootAddress,\\n        address newUser,\\n        bool isRightLegSelected,\\n        uint256 count\\n    ) internal {\\n        address leftLegAddr = addressToLeg1Address[rootAddress];\\n        address rightLegAddr = addressToLeg2Address[rootAddress];\\n        uint256 leftLeg = 1;\\n        uint256 rightLeg = 2;\\n\\n        if (count > 800) {\\n            return;\\n        }\\n\\n        if (!isRightLegSelected) {\\n            if (leftLegAddr == address(0)) {\\n                saveLegData(rootAddress, newUser, leftLeg);\\n                addressToLeg1Address[rootAddress] = newUser;\\n            } else {\\n                // 2 legs occupied\\n                saveLegPositionIfNeeded(newUser, leftLeg);\\n                addToTree(leftLegAddr, newUser, isRightLegSelected, count + 1);\\n            }\\n        } else {\\n            if (rightLegAddr == address(0)) {\\n                saveLegData(rootAddress, newUser, rightLeg);\\n                addressToLeg2Address[rootAddress] = newUser;\\n            } else {\\n                // 2 legs occupied\\n                saveLegPositionIfNeeded(newUser, rightLeg);\\n                addToTree(rightLegAddr, newUser, isRightLegSelected, count + 1);\\n            }\\n        }\\n    }\\n\\n    function addFounderIfPossible(address addr) internal {\\n        if (remainingFounders > 0) {\\n            isFounder[addr] = true;\\n            remainingFounders--;\\n        }\\n    }\\n\\n    function transferFromToken(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal {\\n        require(allowanceToken(sender, recipient) >= amount, \\\"allowance\\\");\\n\\n        ERC20(tokenAddress).transferFrom(sender, recipient, amount);\\n    }\\n\\n    function saveAddressIfNeeded(address addr) internal {\\n        if (!hasAddress[addr] && addr != address(0)) {\\n            hasAddress[addr] = true;\\n            addresses.push(addr);\\n        }\\n    }\\n\\n    function updateDirectCustomersVolume(\\n        address sponsor,\\n        uint256 amount\\n    ) internal {\\n        saveAddressIfNeeded(sponsor);\\n        addressToDirectCustomersVolume[sponsor] += amount;\\n        addressToWeeklyDirectCustomersVolume[sponsor] += amount;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addFounderIfPossibleOnlyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rootAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"newUser\",\"type\":\"address\"}],\"name\":\"addToTreeOnlyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToDirectCustomersVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToEarnings\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToIsRightLegSelected\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToLeftTurnover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToLeg1Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToLeg2Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToLegPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToMinRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToPenalty\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToPurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToRightTurnover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToSponsor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToWeeklyDirectCustomersVolume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToWeeklyPurchases\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowanceToken\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"binaryPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"championBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"championBonusMinAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"checkIfActiveSubscription\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"directSalesPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extraBonusMinAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"extraBonusPerc\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"founderBonusPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getBinaryExtraBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChampionBonusAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getDirectCommissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getDirectSalesPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFoundersBonusAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getIndirectCommissions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getParity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rootAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"getTreeSum\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rootAddress\",\"type\":\"address\"}],\"name\":\"getWeeklyLegsTurnover\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"globalCap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"hasAddress\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasChampionBonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasMatchingBonus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFounder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"matchingBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"minParity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minWeeklyTurnoverPerLeg\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"rankOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"remainingFounders\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"renewSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetWeekOnlyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"quantity\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subsLength\",\"type\":\"uint256\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"salesToAchieveRank\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leg\",\"type\":\"uint256\"}],\"name\":\"saveLegPositionOnlyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"}],\"name\":\"setAddressToEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"turnover\",\"type\":\"uint256\"}],\"name\":\"setAddressToLeftTurnover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"}],\"name\":\"setAddressToLeg1Address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"addr2\",\"type\":\"address\"}],\"name\":\"setAddressToLeg2Address\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rank\",\"type\":\"uint256\"}],\"name\":\"setAddressToMinRank\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"turnover\",\"type\":\"uint256\"}],\"name\":\"setAddressToRightTurnover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"}],\"name\":\"setAddressToSponsor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"setAddressToWeeklyPurchases\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_championBonusMinAmount\",\"type\":\"uint256\"}],\"name\":\"setChampionBonusMinAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"directCustomersVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weeklyDirectCustomersVolume\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"purchases\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"weeklyPurchases\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minRank\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leg1Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leg2Address\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"isRightLegSelected\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"leftTurnover\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rightTurnover\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"legPosition\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subscriberTimestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"penalty\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isFounder\",\"type\":\"bool\"}],\"internalType\":\"struct Futuria.User[]\",\"name\":\"users\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subsLength\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct Futuria.Subscription[]\",\"name\":\"subscription\",\"type\":\"tuple[]\"},{\"internalType\":\"uint256\",\"name\":\"_weekTurnover\",\"type\":\"uint256\"}],\"name\":\"setContractState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_defaultReferralAccount\",\"type\":\"address\"}],\"name\":\"setDefaultReferralAccount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_extraBonusMinAmount\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_extraBonusPerc\",\"type\":\"uint256[]\"}],\"name\":\"setExtraBonus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_founderBonusPercentage\",\"type\":\"uint256\"}],\"name\":\"setFounderBonusPercentage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earnings\",\"type\":\"uint256\"}],\"name\":\"setIndirectCommissionsOnlyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"rootAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leg1Address\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"leg2Address\",\"type\":\"address\"}],\"name\":\"setLegs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_minParity\",\"type\":\"uint256[]\"}],\"name\":\"setMinParity\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rankPenalty\",\"type\":\"uint256\"}],\"name\":\"setPenalty\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_directSalesPercentage\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_binaryPercentage\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_salesToAchieveRank\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"_minWeeklyTurnoverPerLeg\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_globalCap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_subscriptionPercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_matchingBonus\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_championBonus\",\"type\":\"uint256\"}],\"name\":\"setPercentages\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isRightLegSelected\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"setSelectedLeg\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"setSubscriberToTimestamp\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_weekTurnover\",\"type\":\"uint256\"}],\"name\":\"setWeekTurnover\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"setWeeklyDirectCustomersVolume\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"earningsWithoutIndirectCommissions\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"indirectCommissions\",\"type\":\"uint256\"}],\"internalType\":\"struct Futuria.EarningsItem[]\",\"name\":\"items\",\"type\":\"tuple[]\"}],\"name\":\"setWeeklyEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"rankPenalty\",\"type\":\"uint256\"}],\"name\":\"stopSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"referralAddress\",\"type\":\"address\"}],\"name\":\"subscribe\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"subscriber\",\"type\":\"address\"}],\"name\":\"subscribeOnlyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"subscriberToTimestamp\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"subscriptionPercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToSubsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sponsor\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"updateDirectCustomersVolumeOnlyAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"subsLength\",\"type\":\"uint256\"}],\"name\":\"updateSubscription\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"updateTokenAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"weekTurnover\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawMatic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenAmountInWei\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "Futuria", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "1000", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}