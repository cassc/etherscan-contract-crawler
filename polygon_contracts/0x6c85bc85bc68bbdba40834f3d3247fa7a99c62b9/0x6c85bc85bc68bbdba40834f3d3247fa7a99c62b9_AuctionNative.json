{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/auction/AuctionNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./IAuctionNative.sol\\\";\\nimport \\\"./base/AuctionBase.sol\\\";\\nimport \\\"../buyNow/BuyNowNative.sol\\\";\\n\\n/**\\n * @title Escrow Contract for Payments in Auction & BuyNow modes, in Native Cryptocurrencies.\\n * @author Freeverse.io, www.freeverse.io\\n * @notice Full contract documentation in IAuctionNative\\n */\\n\\ncontract AuctionNative is IAuctionNative, AuctionBase, BuyNowNative {\\n    constructor(\\n        string memory currencyDescriptor,\\n        address eip712,\\n        uint256 minIncreasePercentage,\\n        uint256 time2Extend,\\n        uint256 extendableBy\\n    )\\n        BuyNowNative(currencyDescriptor, eip712)\\n        AuctionBase(minIncreasePercentage, time2Extend, extendableBy)\\n    {}\\n\\n    /// @inheritdoc IAuctionNative\\n    function bid(\\n        BidInput calldata bidInput,\\n        bytes calldata operatorSignature,\\n        bytes calldata sellerSignature\\n    ) external payable {\\n        require(\\n            msg.sender == bidInput.bidder,\\n            \\\"AuctionNative::bid: only bidder can execute this function\\\"\\n        );\\n        address operator = universeOperator(bidInput.universeId);\\n        require(\\n            IEIP712VerifierAuction(_eip712).verifyBid(\\n                bidInput,\\n                operatorSignature,\\n                operator\\n            ),\\n            \\\"AuctionNative::bid: incorrect operator signature\\\"\\n        );\\n        // The following requirement avoids possible mistakes in building the TX's msg.value by a user.\\n        // While the funds provided can be less than the bid amount (in case of buyer having local balance),\\n        // there is no reason for providing more funds than the bid amount.\\n        require(\\n            (msg.value <= bidInput.bidAmount),\\n            \\\"AuctionNative::bid: new funds provided must be less than bid amount\\\"\\n        );\\n        _processBid(operator, bidInput, sellerSignature);\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function paymentState(bytes32 paymentId) public view override(AuctionBase, IBuyNowBase, BuyNowBase) returns (State) {\\n        return AuctionBase.paymentState(paymentId);\\n    }\\n\\n    /**\\n     * @dev On arrival of a bid that outbids a previous one,\\n     *  refunds previous bidder by increasing local balance.\\n     * @param bidInput The struct containing all bid data\\n     */\\n    function _refundPreviousBidder(BidInput memory bidInput) internal override {\\n        uint256 prevHighestBid = _payments[bidInput.paymentId].amount;\\n        if (prevHighestBid > 0) {\\n            address prevHighestBidder = _payments[bidInput.paymentId].buyer;\\n            _balanceOf[prevHighestBidder] += prevHighestBid;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/roles/Operators.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Management of Operators.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev The Operator role is to execute the actions required when\\n * payments arrive to this contract, and then either\\n * confirm the success of those actions, or confirm the failure.\\n * All parties agree explicitly on a specific address to \\n * act as an Operator for each individual payment process. \\n *\\n * The constructor sets a defaultOperator = deployer.\\n * The owner of the contract can change the defaultOperator.\\n *\\n * The owner of the contract can assign explicit operators to each universe.\\n * If a universe does not have an explicitly assigned operator,\\n * the default operator is used.\\n */\\n\\ncontract Operators is Ownable {\\n    /**\\n     * @dev Event emitted on change of default operator\\n     * @param operator The address of the new default operator\\n     * @param prevOperator The previous value of operator\\n     */\\n    event DefaultOperator(address indexed operator, address indexed prevOperator);\\n\\n    /**\\n     * @dev Event emitted on change of a specific universe operator\\n     * @param universeId The id of the universe\\n     * @param operator The address of the new universe operator\\n     * @param prevOperator The previous value of operator\\n     */\\n    event UniverseOperator(\\n        uint256 indexed universeId,\\n        address indexed operator,\\n        address indexed prevOperator\\n    );\\n\\n    /// @dev The address of the default operator:\\n    address private _defaultOperator;\\n\\n    /// @dev The mapping from universeId to specific universe operator:\\n    mapping(uint256 => address) private _universeOperators;\\n\\n    constructor() {\\n        setDefaultOperator(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Sets a new default operator\\n     * @param operator The address of the new default operator\\n     */\\n    function setDefaultOperator(address operator) public onlyOwner {\\n        emit DefaultOperator(operator, _defaultOperator);\\n        _defaultOperator = operator;\\n    }\\n\\n    /**\\n     * @dev Sets a new specific universe operator\\n     * @param universeId The id of the universe\\n     * @param operator The address of the new universe operator\\n     */\\n    function setUniverseOperator(uint256 universeId, address operator)\\n        external\\n        onlyOwner\\n    {\\n        emit UniverseOperator(universeId, operator, universeOperator(universeId));\\n        _universeOperators[universeId] = operator;\\n    }\\n\\n    /**\\n     * @dev Removes a specific universe operator\\n     * @notice The universe will then be operated by _defaultOperator\\n     * @param universeId The id of the universe\\n     */\\n    function removeUniverseOperator(uint256 universeId) external onlyOwner {\\n        emit UniverseOperator(universeId, _defaultOperator, _universeOperators[universeId]);\\n        delete _universeOperators[universeId];\\n    }\\n\\n    /**\\n     * @dev Returns the default operator\\n     */\\n    function defaultOperator() external view returns (address) {\\n        return _defaultOperator;\\n    }\\n\\n    /**\\n     * @dev Returns the operator of a specific universe\\n     * @param universeId The id of the universe\\n     */\\n    function universeOperator(uint256 universeId)\\n        public\\n        view\\n        returns (address)\\n    {\\n        address storedOperator = _universeOperators[universeId];\\n        return storedOperator == address(0) ? _defaultOperator : storedOperator;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/roles/FeesCollectors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\n\\n/**\\n * @title Management of Fees Collectors.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev FeesCollectors are just the addresses to which fees\\n * are paid when payments are successfully completed.\\n *\\n * The constructor sets a defaultFeesCollector = deployer.\\n * The owner of the contract can change the defaultFeesCollector.\\n *\\n * The owner of the contract can assign explicit feesCollectors to each universe.\\n * If a universe does not have an explicitly assigned feesCollector,\\n * the default feesCollector is used.\\n */\\n\\ncontract FeesCollectors is Ownable {\\n    /**\\n     * @dev Event emitted on change of default feesCollector\\n     * @param feesCollector The address of the new default feesCollector\\n     * @param prevFeesCollector The previous value of feesCollector\\n     */\\n    event DefaultFeesCollector(address indexed feesCollector, address indexed prevFeesCollector);\\n\\n    /**\\n     * @dev Event emitted on change of a specific universe feesCollector\\n     * @param universeId The id of the universe\\n     * @param feesCollector The address of the new universe feesCollector\\n     * @param prevFeesCollector The previous value of feesCollector\\n     */\\n    event UniverseFeesCollector(\\n        uint256 indexed universeId,\\n        address indexed feesCollector,\\n        address indexed prevFeesCollector\\n    );\\n\\n    /// @dev The address of the default feesCollector:\\n    address private _defaultFeesCollector;\\n\\n    /// @dev The mapping from universeId to specific universe feesCollector:\\n    mapping(uint256 => address) private _universeFeesCollectors;\\n\\n    constructor() {\\n        setDefaultFeesCollector(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Sets a new default feesCollector\\n     * @param feesCollector The address of the new default feesCollector\\n     */\\n    function setDefaultFeesCollector(address feesCollector) public onlyOwner {\\n        emit DefaultFeesCollector(feesCollector, _defaultFeesCollector);\\n        _defaultFeesCollector = feesCollector;\\n    }\\n\\n    /**\\n     * @dev Sets a new specific universe feesCollector\\n     * @param universeId The id of the universe\\n     * @param feesCollector The address of the new universe feesCollector\\n     */\\n    function setUniverseFeesCollector(uint256 universeId, address feesCollector)\\n        external\\n        onlyOwner\\n    {\\n        emit UniverseFeesCollector(universeId, feesCollector, universeFeesCollector(universeId));\\n        _universeFeesCollectors[universeId] = feesCollector;\\n    }\\n\\n    /**\\n     * @dev Removes a specific universe feesCollector\\n     * @notice The universe will then have fees collected by _defaultFeesCollector\\n     * @param universeId The id of the universe\\n     */\\n    function removeUniverseFeesCollector(uint256 universeId)\\n        external\\n        onlyOwner\\n    {\\n        emit UniverseFeesCollector(universeId, _defaultFeesCollector, _universeFeesCollectors[universeId]);\\n        delete _universeFeesCollectors[universeId];\\n    }\\n\\n    /**\\n     * @dev Returns the default feesCollector\\n     */\\n    function defaultFeesCollector() external view returns (address) {\\n        return _defaultFeesCollector;\\n    }\\n\\n    /**\\n     * @dev Returns the feesCollector of a specific universe\\n     * @param universeId The id of the universe\\n     */\\n    function universeFeesCollector(uint256 universeId)\\n        public\\n        view\\n        returns (address)\\n    {\\n        address storedFeesCollector = _universeFeesCollectors[universeId];\\n        return\\n            storedFeesCollector == address(0)\\n                ? _defaultFeesCollector\\n                : storedFeesCollector;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/buyNow/base/ISignableStructsBuyNow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\n/**\\n * @title Interface for structs required in MetaTXs using EIP712.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev This contract defines 2 structures (BuyNowInput, AssetTransferResult),\\n *  required for the BuyNow processes. These structures require a separate implementation\\n *  of their corresponding EIP712-verifying functions.\\n */\\n\\ninterface ISignableStructsBuyNow {\\n    /**\\n     * @notice The main struct that characterizes a buyNow\\n     * @dev Used as input to the buyNow method\\n     * @dev it needs to be signed following EIP712\\n     */\\n    struct BuyNowInput {\\n        // the unique Id that identifies a payment,\\n        // common to both Auctions and BuyNows,\\n        // obtained from hashing params related to the listing, \\n        // including a sufficiently large source of entropy.\\n        bytes32 paymentId;\\n\\n        // the price of the asset, an integer expressed in the\\n        // lowest unit of the currency.\\n        uint256 amount;\\n\\n        // the fee that will be charged by the feeOperator,\\n        // expressed as percentage Basis Points (bps), applied to amount.\\n        // e.g. feeBPS = 500 applies a 5% fee.\\n        uint256 feeBPS;\\n\\n        // the id of the universe that the asset belongs to.\\n        uint256 universeId;\\n\\n        // the deadline for the payment to arrive to this\\n        // contract, otherwise it will be rejected.\\n        uint256 deadline;\\n\\n        // the buyer, providing the required funds, who shall receive\\n        // the asset on a successful payment.\\n        address buyer;\\n\\n        // the seller of the asset, who shall receive the funds\\n        // (subtracting fees) on a successful payment.\\n        address seller;\\n    }\\n\\n    /**\\n     * @notice The struct that specifies the success or failure of an asset transfer\\n     * @dev It needs to be signed by the operator following EIP712\\n     * @dev Must arrive when the asset is in ASSET_TRANSFERING state, to then move to PAID or REFUNDED\\n     */\\n    struct AssetTransferResult {\\n        // the unique Id that identifies a payment previously initiated in this contract.\\n        bytes32 paymentId;\\n\\n        // a bool set to true if the asset was successfully transferred, false otherwise\\n        bool wasSuccessful;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/buyNow/base/IEIP712VerifierBuyNow.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./ISignableStructsBuyNow.sol\\\";\\n\\n/**\\n * @title Interface to Verification of MetaTXs for BuyNows.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev This contract defines the interface to the two verifying functions\\n *  for the structs defined in ISignableStructsBuyNow (BuyNowInput, AssetTransferResult),\\n *  used within the BuyNow process, as well as to the function that verifies\\n *  the seller signature agreeing to list the asset.\\n *  Potential future changes in any of these signing methods can be handled by having\\n *  the main contract redirect to a different verifier contract.\\n */\\n\\ninterface IEIP712VerifierBuyNow is ISignableStructsBuyNow {\\n    /**\\n     * @notice Verifies that the provided BuyNowInput struct has been signed\\n     *  by the provided signer.\\n     * @param buyNowInp The provided BuyNowInput struct\\n     * @param signature The provided signature of the input struct\\n     * @param signer The signer's address that we want to verify\\n     * @return Returns true if the signature corresponds to the\\n     *  provided signer having signed the input struct\\n     */\\n    function verifyBuyNow(\\n        BuyNowInput calldata buyNowInp,\\n        bytes calldata signature,\\n        address signer\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Verifies that the provided AssetTransferResult struct\\n     *  has been signed by the provided signer.\\n     * @param transferResult The provided AssetTransferResult struct\\n     * @param signature The provided signature of the input struct\\n     * @param signer The signer's address that we want to verify\\n     * @return Returns true if the signature corresponds to the signer\\n     *  having signed the input struct\\n     */\\n    function verifyAssetTransferResult(\\n        AssetTransferResult calldata transferResult,\\n        bytes calldata signature,\\n        address signer\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Verifies the seller signature showing agreement \\n     *  to list the asset as ruled by this explicit paymentId.\\n     * @dev To anticipate for future potential differences in verifiers for\\n     *  BuyNow/Auction listings, the interfaces to verifiers for both flows are \\n     *  kept separate, accepting the entire respective structs as input.\\n     *  For the same reason, the interface declares the method as 'view', prepared\\n     *  to use EIP712 flows, even if the initial implementation can be 'pure'.\\n     * @param sellerSignature the signature of the seller agreeing to list the asset as ruled by\\n     *  this explicit paymentId\\n     * @param buyNowInp The provided BuyNowInput struct\\n     * @return Returns true if the seller signature is correct\\n     */\\n    function verifySellerSignature(\\n        bytes calldata sellerSignature,\\n        BuyNowInput calldata buyNowInp\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/buyNow/base/IBuyNowBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./ISignableStructsBuyNow.sol\\\";\\n\\n/**\\n * @title Interface to base Escrow Contract for Payments in BuyNow mode.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev The contract that implements this interface only operates the BuyNow path of a payment;\\n * it derives from previously audited code, except for minimal method name changes and\\n * several methods changed from 'private' to 'internal'\\n * The contract that implements this interface can be inherited to:\\n * - conduct buyNows in either native crypto or ERC20 tokens\\n * - add more elaborated payment processes (such as Auctions)\\n *\\n * The contract that implements this interface operates as an escrow\\n * for paying for assets in BuyNow mode: the first buyer that\\n * executes the buyNow method gets the asset.\\n *\\n * ROLES: Buyers/bidders explicitly sign the agreement to let the specified Operator address\\n * act as an Oracle, responsible for signing the success or failure of the asset transfer,\\n * which is conducted outside this contract upon reception of funds.\\n *\\n * If no confirmation is received from the Operator during the PaymentWindow,\\n * all funds received from the buyer are made available to him/her for refund.\\n * Throughout the contract, this moment is labeled as 'expirationTime'.\\n *\\n * To start a payment, signatures of both the buyer and the Operator are required, and they\\n * are checked in the contracts that inherit from this one.\\n *\\n * The contract that implements this interface maintains the balances of all users,\\n * which can be withdrawn via explicit calls to the various 'withdraw' methods.\\n * If a buyer has a non-zero local balance at the moment of starting a new payment,\\n * the contract reuses it, and only requires the provision of the remainder funds required (if any).\\n *\\n * Each BuyNow has the following State Machine:\\n * - NOT_STARTED -> ASSET_TRANSFERRING, triggered by buyNow\\n * - ASSET_TRANSFERRING -> PAID, triggered by relaying assetTransferSuccess signed by Operator\\n * - ASSET_TRANSFERRING -> REFUNDED, triggered by relaying assetTransferFailed signed by Operator\\n * - ASSET_TRANSFERRING -> REFUNDED, triggered by a refund request after expirationTime\\n *\\n * NOTE: To ensure that the payment process proceeds as expected when the payment starts,\\n * upon acceptance of a payment, the following data: {operator, feesCollector, expirationTime}\\n * is stored in the payment struct, and used throughout the payment, regardless of\\n * any possible modifications to the contract's storage.\\n *\\n * NOTE: The contract allows a feature, 'Seller Registration', that can be used in the scenario that\\n * applications want users to prove that they have enough crypto know-how (obtain native crypto,\\n * pay for gas using a web3 wallet, etc.) to interact by themselves with this smart contract before selling,\\n * so that they are less likely to require technical help in case they need to withdraw funds.\\n * - If _isSellerRegistrationRequired = true, this feature is enabled, and payments can only be initiated\\n *    if the payment seller has previously executed the registerAsSeller method.\\n * - If _isSellerRegistrationRequired = false, this feature is disabled, and payments can be initiated\\n *    regardless of any previous call to the registerAsSeller method.\\n *\\n * NOTE: Following audits suggestions, the EIP712 contract, which uses OpenZeppelin's implementation,\\n * is not inherited; it is separately deployed, so that it can be upgraded should the standard evolve in the future.\\n *\\n */\\n\\ninterface IBuyNowBase is ISignableStructsBuyNow {\\n    /**\\n     * @dev Event emitted on change of EIP712 verifier contract address\\n     * @param eip712address The address of the new EIP712 verifier contract\\n     * @param prevEip712address The previous value of eip712address\\n     */\\n\\n    event EIP712(address eip712address, address prevEip712address);\\n\\n    /**\\n     * @dev Event emitted on change of payment window\\n     * @param window The new amount of time after the arrival of a payment for which,\\n     *  in absence of confirmation of asset transfer success, a buyer is allowed to refund\\n     * @param prevWindow The previous value of window\\n     */\\n    event PaymentWindow(uint256 window, uint256 prevWindow);\\n\\n    /**\\n     * @dev Event emitted on change of maximum fee BPS that can be accepted in any payment\\n     * @param maxFeeBPS the max fee (in BPS units) that can be accepted in any payment\\n     *  despite operator and buyer having signed a larger amount;\\n     *  a value of 10000 BPS would correspond to 100% (no limit at all)\\n     * @param prevMaxFeeBPS The previous value of maxFeeBPS\\n     */\\n    event MaxFeeBPS(uint256 maxFeeBPS, uint256 prevMaxFeeBPS);\\n\\n    /**\\n     * @dev Event emitted when a user executes the registerAsSeller method\\n     * @param seller The address of the newly registeredAsSeller user.\\n     */\\n    event NewSeller(address indexed seller);\\n\\n    /**\\n     * @dev Event emitted when a user sets a value of onlyUserCanWithdraw\\n     *  - if true: only the user can execute withdrawals of his/her local balance\\n     *  - if false: any address can help and execute the withdrawals on behalf of the user\\n     *   (the funds still go straight to the user, but the helper address covers gas costs\\n     *    and the hassle of executing the transaction)\\n     * @param user The address of the user.\\n     * @param onlyUserCanWithdraw true if only the user can execute withdrawals of his/her local balance\\n     * @param prevOnlyUserCanWithdraw the previous value, overwritten by 'onlyUserCanWithdraw'\\n     */\\n    event OnlyUserCanWithdraw(address indexed user, bool onlyUserCanWithdraw, bool prevOnlyUserCanWithdraw);\\n\\n    /**\\n     * @dev Event emitted when a buyer is refunded for a given payment process\\n     * @param paymentId The id of the already initiated payment\\n     * @param buyer The address of the refunded buyer\\n     */\\n    event BuyerRefunded(bytes32 indexed paymentId, address indexed buyer);\\n\\n    /**\\n     * @dev Event emitted when funds for a given payment arrive to this contract\\n     * @param paymentId The unique id identifying the payment\\n     * @param buyer The address of the buyer providing the funds\\n     * @param seller The address of the seller of the asset\\n     */\\n    event BuyNow(\\n        bytes32 indexed paymentId,\\n        address indexed buyer,\\n        address indexed seller\\n    );\\n\\n    /**\\n     * @dev Event emitted when a payment process arrives at the PAID\\n     *  final state, where the seller receives the funds.\\n     * @param paymentId The id of the already initiated payment\\n     */\\n    event Paid(bytes32 indexed paymentId);\\n\\n    /**\\n     * @dev Event emitted when user withdraws funds from this contract\\n     * @param user The address of the user that withdraws\\n     * @param amount The amount withdrawn, in lowest units of the currency\\n     */\\n    event Withdraw(address indexed user, uint256 amount);\\n\\n    /**\\n     * @dev The enum characterizing the possible states of an payment process\\n     */\\n    enum State {\\n        NotStarted,\\n        AssetTransferring,\\n        Refunded,\\n        Paid,\\n        Auctioning\\n    }\\n\\n    /**\\n     * @notice Main struct stored with every payment.\\n     *  All variables of the struct remain immutable throughout a payment process\\n     *  except for `state`.\\n     */\\n    struct Payment {\\n        // the current state of the payment process\\n        State state;\\n\\n        // the buyer, providing the required funds, who shall receive\\n        // the asset on a successful payment.\\n        address buyer;\\n\\n        // the seller of the asset, who shall receive the funds\\n        // (subtracting fees) on a successful payment.        \\n        address seller;\\n\\n        // the id of the universe that the asset belongs to.\\n        uint256 universeId;\\n\\n        // The address of the feesCollector of this payment\\n        address feesCollector;\\n\\n        // The timestamp after which, in absence of confirmation of \\n        // asset transfer success, a buyer is allowed to refund\\n        uint256 expirationTime;\\n\\n        // the percentage fee expressed in Basis Points (bps), typical in finance\\n        // Examples:  2.5% = 250 bps, 10% = 1000 bps, 100% = 10000 bps\\n        uint256 feeBPS;\\n\\n        // the price of the asset, an integer expressed in the\\n        // lowest unit of the currency.\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @notice Registers msg.sender as seller so that, if the contract has set\\n     *  _isSellerRegistrationRequired = true, then payments will be accepted with\\n     *  msg.sender as seller.\\n    */\\n    function registerAsSeller() external;\\n\\n    /**\\n     * @notice Sets the value of onlyUserCanWithdraw for the user with msg.sender address:\\n     *  - if true: only the user can execute withdrawals of his/her local balance\\n     *  - if false: any address can help and execute the withdrawals on behalf of the user\\n     *   (the funds still go straight to the user, but the helper address covers gas costs\\n     *    and the hassle of executing the transaction)\\n     * @param onlyUserCan true if only the user can execute withdrawals of his/her local balance\\n     */\\n    function setOnlyUserCanWithdraw(bool onlyUserCan) external;\\n\\n    /**\\n     * @notice Relays the operator signature declaring that the asset transfer was successful or failed,\\n     *  and updates local balances of seller or buyer, respectively.\\n     * @dev Can be executed by anyone, but the operator signature must be included as input param.\\n     *  Seller or Buyer's local balances are updated, allowing explicit withdrawal.\\n     *  Moves payment to PAID or REFUNDED state on transfer success/failure, respectively.\\n     * @param transferResult The asset transfer result struct signed by the operator.\\n     * @param operatorSignature The operator signature of transferResult\\n     */\\n    function finalize(\\n        AssetTransferResult calldata transferResult,\\n        bytes calldata operatorSignature\\n    ) external;\\n\\n    /**\\n     * @notice Relays the operator signature declaring that the asset transfer was successful or failed,\\n     *  updates balances of seller or buyer, respectively, and proceeds to withdraw all funds \\n     *  in this contract available to the rightful recipient of the paymentId: \\n     *  the seller if transferResult.wasSuccessful == true, the buyer otherwise.\\n     * @dev If recipient has set onlyUserCanWithdraw == true, then msg.sender must be the recipient;\\n     *  otherwise, anyone can execute this method, with funds arriving to the recipient too, but with a\\n     *  helping 3rd party covering gas costs and TX sending hassle.\\n     *  The operator signature must be included as input param.\\n     *  Moves payment to PAID or REFUNDED state on transfer success/failure, respectively.\\n     * @param transferResult The asset transfer result struct signed by the operator.\\n     * @param operatorSignature The operator signature of transferResult\\n     */\\n    function finalizeAndWithdraw(\\n        AssetTransferResult calldata transferResult,\\n        bytes calldata operatorSignature\\n    ) external;\\n\\n    /**\\n     * @notice Moves buyer's provided funds to buyer's balance.\\n     * @dev Anybody can call this function.\\n     *  Requires acceptsRefunds == true to proceed.\\n     *  After updating buyer's balance, he/she can later withdraw.\\n     *  Moves payment to REFUNDED state.\\n     * @param paymentId The unique ID that identifies the payment.\\n     */\\n    function refund(bytes32 paymentId) external;\\n\\n    /**\\n     * @notice Executes refund and withdraw to the buyer in one transaction.\\n     * @dev If the buyer has set onlyUserCanWithdraw == true, then msg.sender must be the recipient;\\n     *  otherwise, anyone can execute this method, with funds arriving to the buyer too, but with a\\n     *  helping 3rd party covering gas costs and TX sending hassle.\\n     *  Requires acceptsRefunds == true to proceed.\\n     *  All of msg.sender's balance in the contract is withdrawn,\\n     *  not only the part that was locked in this particular paymentId\\n     *  Moves payment to REFUNDED state.\\n     * @param paymentId The unique ID that identifies the payment.\\n     */\\n    function refundAndWithdraw(bytes32 paymentId) external;\\n\\n    /**\\n     * @notice Transfers funds avaliable in this\\n     *  contract's balanceOf[msg.sender] to msg.sender\\n     */\\n    function withdraw() external;\\n\\n    /**\\n     * @notice Transfers funds avaliable in this\\n     *  contract's balanceOf[recipient] to recipient.\\n     *  The funds still go to straight the recipient, as if he/she\\n     *  has executed the withdrawal() method, but the msg.sender\\n     *  covers gas costs and the hassle of executing the transaction.\\n     *  Users can always opt out from this feature, using the setOnlyUserCanWithdraw method.\\n     */\\n    function relayedWithdraw(address recipient) external;\\n\\n    /**\\n     * @notice Transfers only the specified amount\\n     *  from this contract's balanceOf[msg.sender] to msg.sender.\\n     *  Reverts if balanceOf[msg.sender] < amount.\\n     * @param amount The required amount to withdraw\\n     */\\n    function withdrawAmount(uint256 amount) external;\\n\\n    // VIEW FUNCTIONS\\n\\n    /**\\n     * @notice Returns whether sellers need to be registered to be able to accept payments\\n     * @return Returns true if sellers need to be registered to be able to accept payments\\n     */\\n    function isSellerRegistrationRequired() external view returns (bool);\\n\\n    /**\\n     * @notice Returns true if the address provided is a registered seller\\n     * @param addr the address that is queried\\n     * @return Returns whether the address is registered as seller\\n     */\\n    function isRegisteredSeller(address addr) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the local balance of the provided address that is stored in this\\n     *  contract, and hence, available for withdrawal.\\n     * @param addr the address that is queried\\n     * @return the local balance\\n     */\\n    function balanceOf(address addr) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns all data stored in a payment\\n     * @param paymentId The unique ID that identifies the payment.\\n     * @return the struct stored for the payment\\n     */\\n    function paymentInfo(bytes32 paymentId)\\n        external\\n        view\\n        returns (Payment memory);\\n\\n    /**\\n     * @notice Returns the state of a payment.\\n     * @dev If payment is in ASSET_TRANSFERRING, it may be worth\\n     *  checking acceptsRefunds to check if it has gone beyond expirationTime.\\n     * @param paymentId The unique ID that identifies the payment.\\n     * @return the state of the payment.\\n     */\\n    function paymentState(bytes32 paymentId) external view returns (State);\\n\\n    /**\\n     * @notice Returns true if the payment accepts a refund to the buyer\\n     * @dev The payment must be in ASSET_TRANSFERRING and beyond expirationTime.\\n     * @param paymentId The unique ID that identifies the payment.\\n     * @return true if the payment accepts a refund to the buyer.\\n     */\\n    function acceptsRefunds(bytes32 paymentId) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the address of the of the contract containing\\n     *  the implementation of the EIP712 verifying functions\\n     * @return the address of the EIP712 verifier contract\\n     */\\n    function EIP712Address() external view returns (address);\\n\\n    /**\\n     * @notice Returns the amount of seconds that a payment\\n     *  can remain in ASSET_TRANSFERRING state without positive\\n     *  or negative confirmation by the operator\\n     * @return the payment window in secs\\n     */\\n    function paymentWindow() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the max fee (in BPS units) that can be accepted in any payment\\n     *  despite operator and buyer having signed a larger amount;\\n     *  a value of 10000 BPS would correspond to 100% (no limit at all)\\n     * @return the max fee (in BPS units)\\n     */\\n    function maxFeeBPS() external view returns (uint256);\\n\\n    /**\\n     * @notice Returns a descriptor about the currency that this contract accepts\\n     * @return the string describing the currency\\n     */\\n    function currencyLongDescriptor() external view returns (string memory);\\n\\n    /**\\n     * @notice Splits the funds required to provide 'amount' into two sources:\\n     *  - externalFunds: the funds required to be transferred from the external buyer balance\\n     *  - localFunds: the funds required from the buyer's already available balance in this contract.\\n     * @param buyer The address for which the amount is to be split\\n     * @param amount The amount to be split\\n     * @return externalFunds The funds required to be transferred from the external buyer balance\\n     * @return localFunds The amount of local funds that will be used.\\n     */\\n    function splitFundingSources(address buyer, uint256 amount)\\n        external\\n        view\\n        returns (uint256 externalFunds, uint256 localFunds);\\n\\n    /**\\n     * @notice Returns true if the 'amount' required for a payment is available to this contract.\\n     * @dev In more detail: returns true if the sum of the buyer's local balance in this contract,\\n     *  plus the external available balance, is larger or equal than 'amount'\\n     * @param buyer The address for which funds are queried\\n     * @param amount The amount that is queried\\n     * @return Returns true if enough funds are available\\n     */\\n    function enoughFundsAvailable(address buyer, uint256 amount)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @notice Returns the maximum amount of funds available to a buyer\\n     * @dev In more detail: returns the sum of the buyer's local balance in this contract,\\n     *  plus the available external balance.\\n     * @param buyer The address for which funds are queried\\n     * @return the max funds available\\n     */\\n    function maxFundsAvailable(address buyer) external view returns (uint256);\\n\\n    /**\\n     * @notice Reverts unless the requirements for a BuyNowInput are fulfilled.\\n     * @param buyNowInp The BuyNowInput struct\\n     */\\n    function assertBuyNowInputsOK(BuyNowInput calldata buyNowInp) external view;\\n\\n    /**\\n     * @notice Returns the value of onlyUserCanWithdraw for a given user\\n     * @param user The address of the user\\n     */\\n    function onlyUserCanWithdraw(address user) external view returns (bool);\\n\\n    // PURE FUNCTIONS\\n\\n    /**\\n     * @notice Safe computation of fee amount for a provided amount, feeBPS pair\\n     * @dev Must return a value that is guaranteed to be less or equal to the provided amount\\n     * @param amount The amount\\n     * @param feeBPS The percentage fee expressed in Basis Points (bps).\\n     *  feeBPS examples:  2.5% = 250 bps, 10% = 1000 bps, 100% = 10000 bps\\n     * @return The fee amount\\n     */\\n    function computeFeeAmount(uint256 amount, uint256 feeBPS)\\n        external\\n        pure\\n        returns (uint256);\\n}\\n\"\r\n    },\r\n    \"/contracts/buyNow/base/BuyNowBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./IBuyNowBase.sol\\\";\\nimport \\\"../../roles/Operators.sol\\\";\\nimport \\\"../../roles/FeesCollectors.sol\\\";\\nimport \\\"./IEIP712VerifierBuyNow.sol\\\";\\n\\n/**\\n * @title Base Escrow Contract for Payments in BuyNow mode.\\n * @author Freeverse.io, www.freeverse.io\\n * @notice Full contract documentation in IBuyNowBase\\n */\\n\\nabstract contract BuyNowBase is IBuyNowBase, FeesCollectors, Operators {\\n    // the address of the deployed EIP712 verifier contract\\n    address internal _eip712;\\n\\n    // a human readable long descripton of the accepted currency \\n    // (be it native or ERC20), e.g. \\\"USDC on Polygon PoS\\\"\\n    string private _currencyLongDescriptor;\\n\\n    //  the amount of seconds that a payment can remain\\n    //  in ASSET_TRANSFERRING state without positive\\n    //  or negative confirmation by the operator\\n    uint256 internal _paymentWindow;\\n\\n    //  the max fee (in BPS units) that can be accepted in any payment\\n    //  despite operator and buyer having signed a larger amount;\\n    //  a value of 10000 BPS would correspond to 100% (no limit at all)\\n    uint256 internal _maxFeeBPS;\\n\\n    // whether sellers need to be registered to be able to accept payments\\n    bool internal _isSellerRegistrationRequired;\\n\\n    // mapping from seller address to whether seller is registered\\n    mapping(address => bool) internal _isRegisteredSeller;\\n\\n    // mapping from user address to a bool:\\n    // - if true: only the user can execute withdrawals of his/her local balance\\n    // - if false: any address can help and execute the withdrawals on behalf of the user\\n    //   (the funds still go straight to the user, but the helper address covers gas costs\\n    //    and the hassle of executing the transaction)\\n    mapping(address => bool) internal _onlyUserCanWithdraw;\\n\\n    // mapping from paymentId to payment struct describing the entire payment process\\n    mapping(bytes32 => Payment) internal _payments;\\n\\n    // mapping from user address to local balance in this contract\\n    mapping(address => uint256) internal _balanceOf;\\n\\n    constructor(string memory currencyDescriptor, address eip712) {\\n        setEIP712(eip712);\\n        _currencyLongDescriptor = currencyDescriptor;\\n        setPaymentWindow(30 days);\\n        _isSellerRegistrationRequired = false;\\n        setMaxFeeBPS(3000); // 30%\\n    }\\n\\n    /**\\n     * @notice Sets the address of the EIP712 verifier contract.\\n     * @dev This upgradable pattern is required in case that the\\n     *  EIP712 spec/code changes in the future\\n     * @param eip712address The address of the new EIP712 contract.\\n     */\\n    function setEIP712(address eip712address) public onlyOwner {\\n        emit EIP712(eip712address, _eip712);\\n        _eip712 = eip712address;\\n    }\\n\\n    /**\\n     * @notice Sets the amount of time available to the operator, after the payment starts,\\n     *  to confirm either the success or the failure of the asset transfer.\\n     *  After this time, the payment moves to FAILED, allowing buyer to withdraw.\\n     * @param window The amount of time available, in seconds.\\n     */\\n    function setPaymentWindow(uint256 window) public onlyOwner {\\n        require(\\n            (window < 60 days) && (window > 3 hours),\\n            \\\"BuyNowBase::setPaymentWindow: payment window outside limits\\\"\\n        );\\n        emit PaymentWindow(window, _paymentWindow);\\n        _paymentWindow = window;\\n    }\\n\\n    /**\\n     * @notice Sets the max fee (in BPS units) that can be accepted in any payment\\n     *  despite operator and buyer having signed a larger amount;\\n     *  a value of 10000 BPS would correspond to 100% (no limit at all)\\n     * @param feeBPS The new max fee (in BPS units)\\n     */\\n    function setMaxFeeBPS(uint256 feeBPS) public onlyOwner {\\n        require(\\n            (feeBPS <= 10000) && (feeBPS >= 0),\\n            \\\"BuyNowBase::setMaxFeeBPS: maxFeeBPS outside limits\\\"\\n        );\\n        emit MaxFeeBPS(feeBPS, _maxFeeBPS);\\n        _maxFeeBPS = feeBPS;\\n    }\\n\\n    /**\\n     * @notice Sets whether sellers are required to register in this contract before being\\n     *  able to accept payments.\\n     * @param isRequired (bool) if true, registration is required.\\n     */\\n    function setIsSellerRegistrationRequired(bool isRequired)\\n        external\\n        onlyOwner\\n    {\\n        _isSellerRegistrationRequired = isRequired;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function registerAsSeller() external {\\n        require(\\n            !_isRegisteredSeller[msg.sender],\\n            \\\"BuyNowBase::registerAsSeller: seller already registered\\\"\\n        );\\n        _isRegisteredSeller[msg.sender] = true;\\n        emit NewSeller(msg.sender);\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function setOnlyUserCanWithdraw(bool onlyUserCan) external {\\n        emit OnlyUserCanWithdraw(msg.sender, onlyUserCan, _onlyUserCanWithdraw[msg.sender]);\\n        _onlyUserCanWithdraw[msg.sender] = onlyUserCan;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function finalize(\\n        AssetTransferResult calldata transferResult,\\n        bytes calldata operatorSignature\\n    ) external {\\n        _finalize(transferResult, operatorSignature);\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function finalizeAndWithdraw(\\n        AssetTransferResult calldata transferResult,\\n        bytes calldata operatorSignature\\n    ) external {\\n        address recipient = transferResult.wasSuccessful\\n            ? _payments[transferResult.paymentId].seller\\n            : _payments[transferResult.paymentId].buyer;\\n        if (_onlyUserCanWithdraw[recipient]) require(\\n            msg.sender == recipient,\\n            \\\"BuyNowBase::finalizeAndWithdraw: tx sender not authorized to withdraw on recipients behalf\\\"\\n        );\\n        _finalize(transferResult, operatorSignature);\\n        // withdrawal cannot fail due to zero balance, since\\n        // balance has just been increased when finalizing the payment:\\n        _withdrawAmount(recipient, _balanceOf[recipient]);\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function refund(bytes32 paymentId) public {\\n        _refund(paymentId);\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function refundAndWithdraw(bytes32 paymentId) external {\\n        address recipient = _payments[paymentId].buyer;\\n        if (_onlyUserCanWithdraw[recipient]) require(\\n            msg.sender == recipient,\\n            \\\"BuyNowBase::refundAndWithdraw: tx sender not authorized to withdraw on recipients behalf\\\"\\n        );\\n        _refund(paymentId);\\n        // withdrawal cannot fail due to zero balance, since\\n        // balance has just been increased when refunding:\\n        _withdrawAmount(recipient, _balanceOf[recipient]);\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function withdraw() external {\\n        _withdraw();\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function relayedWithdraw(address recipient) external {\\n        require(\\n            !_onlyUserCanWithdraw[recipient] || (msg.sender == recipient),\\n            \\\"BuyNowBase::relayedWithdraw: tx sender not authorized to withdraw on recipients behalf\\\"\\n        );\\n        _withdrawAmount(recipient, _balanceOf[recipient]);\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function withdrawAmount(uint256 amount) external {\\n        _withdrawAmount(msg.sender, amount);\\n    }\\n\\n    // PRIVATE & INTERNAL FUNCTIONS\\n\\n    /**\\n     * @dev Interface to method that must update buyer's local balance on arrival of a payment,\\n     *  re-using local balance if available. In ERC20 payments, it transfers to this contract\\n     *  the required amount; in case of native crypto, it must add excess of provided funds, if any, to local balance.\\n     * @param buyer The address of the buyer\\n     * @param newFundsNeeded The elsewhere computed minimum amount of funds required to be provided by the buyer,\\n     *  having possible re-use of local funds into account\\n     * @param localFunds The elsewhere computed amount of funds available to the buyer in this contract, that will be\\n     *  re-used in the payment\\n     */\\n    function _updateBuyerBalanceOnPaymentReceived(\\n        address buyer,\\n        uint256 newFundsNeeded,\\n        uint256 localFunds\\n    ) internal virtual;\\n\\n    /**\\n     * @dev Asserts correcteness of buyNow input parameters,\\n     *  transfers required funds from external contract (in case of ERC20 Payments),\\n     *  reuses buyer's local balance (if any),\\n     *  and stores the payment data in contract's storage.\\n     *  Moves the payment to AssetTransferring state\\n     * @param buyNowInp The BuyNowInput struct\\n     * @param operator The address of the operator of this payment.\\n     */\\n    function _processBuyNow(\\n        BuyNowInput calldata buyNowInp,\\n        address operator,\\n        bytes calldata sellerSignature\\n    ) internal {\\n        require(\\n            IEIP712VerifierBuyNow(_eip712).verifySellerSignature(\\n                sellerSignature,\\n                buyNowInp\\n            ),\\n            \\\"BuyNowBase::_processBuyNow: incorrect seller signature\\\"\\n        );\\n        assertBuyNowInputsOK(buyNowInp);\\n        assertSeparateRoles(operator, buyNowInp.buyer, buyNowInp.seller);\\n        (uint256 newFundsNeeded, uint256 localFunds) = splitFundingSources(\\n            buyNowInp.buyer,\\n            buyNowInp.amount\\n        );\\n        _updateBuyerBalanceOnPaymentReceived(buyNowInp.buyer, newFundsNeeded, localFunds);\\n        _payments[buyNowInp.paymentId] = Payment(\\n            State.AssetTransferring,\\n            buyNowInp.buyer,\\n            buyNowInp.seller,\\n            buyNowInp.universeId,\\n            universeFeesCollector(buyNowInp.universeId),\\n            block.timestamp + _paymentWindow,\\n            buyNowInp.feeBPS,\\n            buyNowInp.amount\\n        );\\n        emit BuyNow(buyNowInp.paymentId, buyNowInp.buyer, buyNowInp.seller);\\n    }\\n\\n    /**\\n     * @dev (private) Moves the payment funds to the buyer's local balance\\n     *  The buyer still needs to withdraw afterwards.\\n     *  Moves the payment to REFUNDED state\\n     * @param paymentId The unique ID that identifies the payment.\\n     */\\n    function _refund(bytes32 paymentId) private {\\n        require(\\n            acceptsRefunds(paymentId),\\n            \\\"BuyNowBase::_refund: payment does not accept refunds at this stage\\\"\\n        );\\n        _refundToLocalBalance(paymentId);\\n    }\\n\\n    /**\\n     * @dev (private) Uses the operator signed msg regarding asset transfer success to update\\n     *  the balances of seller (on success) or buyer (on failure).\\n     *  They still need to withdraw afterwards.\\n     *  Moves the payment to either PAID (on success) or REFUNDED (on failure) state\\n     * @param transferResult The asset transferResult struct signed by the operator.\\n     * @param operatorSignature The operator signature of transferResult\\n     */\\n    function _finalize(\\n        AssetTransferResult calldata transferResult,\\n        bytes calldata operatorSignature\\n    ) private {\\n        Payment memory payment = _payments[transferResult.paymentId];\\n        require(\\n            paymentState(transferResult.paymentId) == State.AssetTransferring,\\n            \\\"BuyNowBase::_finalize: payment not initially in asset transferring state\\\"\\n        );\\n        require(\\n            IEIP712VerifierBuyNow(_eip712).verifyAssetTransferResult(\\n                transferResult,\\n                operatorSignature,\\n                universeOperator(payment.universeId)\\n            ),\\n            \\\"BuyNowBase::_finalize: only the operator can sign an assetTransferResult\\\"\\n        );\\n        if (transferResult.wasSuccessful) {\\n            _finalizeSuccess(transferResult.paymentId, payment);\\n        } else {\\n            _finalizeFailed(transferResult.paymentId);\\n        }\\n    }\\n\\n    /**\\n     * @dev (private) Updates the balance of the seller on successful asset transfer\\n     *  Moves the payment to PAID\\n     * @param paymentId The unique ID that identifies the payment.\\n     * @param payment The payment struct corresponding to paymentId\\n     */\\n    function _finalizeSuccess(bytes32 paymentId, Payment memory payment) private {\\n        _payments[paymentId].state = State.Paid;\\n        uint256 feeAmount = computeFeeAmount(payment.amount, payment.feeBPS);\\n        _balanceOf[payment.seller] += (payment.amount - feeAmount);\\n        _balanceOf[payment.feesCollector] += feeAmount;\\n        emit Paid(paymentId);\\n    }\\n\\n    /**\\n     * @dev (private) Updates the balance of the buyer on failed asset transfer\\n     *  Moves the payment to REFUNDED\\n     * @param paymentId The unique ID that identifies the payment.\\n     */\\n    function _finalizeFailed(bytes32 paymentId) private {\\n        _refundToLocalBalance(paymentId);\\n    }\\n\\n    /**\\n     * @dev (private) Executes refund, moves to REFUNDED state\\n     * @param paymentId The unique ID that identifies the payment.\\n     */\\n    function _refundToLocalBalance(bytes32 paymentId) private {\\n        _payments[paymentId].state = State.Refunded;\\n        Payment memory payment = _payments[paymentId];\\n        _balanceOf[payment.buyer] += payment.amount;\\n        emit BuyerRefunded(paymentId, payment.buyer);\\n    }\\n\\n    /**\\n     * @dev (private) Transfers funds available in this\\n     *  contract's balanceOf[msg.sender] to msg.sender\\n     *  Follows standard Checks-Effects-Interactions pattern\\n     *  to protect against re-entrancy attacks.\\n     */\\n    function _withdraw() private {\\n        _withdrawAmount(msg.sender, _balanceOf[msg.sender]);\\n    }\\n\\n    /**\\n     * @dev (private) Transfers the specified amount of \\n     *  funds in this contract's balanceOf[recipient] to the recipient address.\\n     *  Follows standard Checks-Effects-Interactions pattern\\n     *  to protect against re-entrancy attacks.\\n     * @param recipient The address of to transfer funds from the local contract\\n     * @param amount The amount to withdraw.\\n    */\\n    function _withdrawAmount(address recipient, uint256 amount) private {\\n        // requirements: \\n        //  1. check that there is enough balance\\n        uint256 currentBalance = _balanceOf[recipient];\\n        require(\\n            currentBalance >= amount,\\n            \\\"BuyNowBase::_withdrawAmount: not enough balance to withdraw specified amount\\\"\\n        );\\n        //  2. prevent dummy withdrawals with 0 amount to avoid useless events \\n        require(\\n            amount > 0,\\n            \\\"BuyNowBase::_withdrawAmount: cannot withdraw zero amount\\\"\\n        );\\n        // effect:\\n        _balanceOf[recipient] = currentBalance - amount;\\n        // interaction:\\n        _transfer(recipient, amount);\\n        emit Withdraw(recipient, amount);\\n    }\\n\\n    /**\\n     * @dev Interface to method that transfers the specified amount to the specified address.\\n     *  Requirements and effects are checked before calling this function.\\n     *  Implementations can deal with native crypto transfers, with ERC20 token transfers, etc.\\n     * @param to The address that must receive the funds.\\n     * @param amount The amount to transfer.\\n    */\\n    function _transfer(address to, uint256 amount) internal virtual;\\n\\n    // VIEW FUNCTIONS\\n\\n    /// @inheritdoc IBuyNowBase\\n    function isSellerRegistrationRequired() external view returns (bool) {\\n        return _isSellerRegistrationRequired;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function isRegisteredSeller(address addr) external view returns (bool) {\\n        return _isRegisteredSeller[addr];\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function balanceOf(address addr) external view returns (uint256) {\\n        return _balanceOf[addr];\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function paymentInfo(bytes32 paymentId)\\n        external\\n        view\\n        returns (Payment memory)\\n    {\\n        return _payments[paymentId];\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function paymentState(bytes32 paymentId) public view virtual returns (State) {\\n        return _payments[paymentId].state;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function acceptsRefunds(bytes32 paymentId) public view returns (bool) {\\n        return\\n            (paymentState(paymentId) == State.AssetTransferring) &&\\n            (block.timestamp > _payments[paymentId].expirationTime);\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function EIP712Address() external view returns (address) {\\n        return _eip712;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function paymentWindow() external view returns (uint256) {\\n        return _paymentWindow;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function maxFeeBPS() external view returns (uint256) {\\n        return _maxFeeBPS;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function currencyLongDescriptor() external view returns (string memory) {\\n        return _currencyLongDescriptor;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function assertBuyNowInputsOK(BuyNowInput calldata buyNowInp) public view {\\n        require(\\n            buyNowInp.amount > 0,\\n            \\\"BuyNowBase::assertBuyNowInputsOK: payment amount cannot be zero\\\"\\n        );\\n        require(\\n            buyNowInp.feeBPS <= _maxFeeBPS,\\n            \\\"BuyNowBase::assertBuyNowInputsOK: fee cannot be larger than maxFeeBPS\\\"\\n        );\\n        require(\\n            paymentState(buyNowInp.paymentId) == State.NotStarted,\\n            \\\"BuyNowBase::assertBuyNowInputsOK: payment in incorrect current state\\\"\\n        );\\n        require(\\n            block.timestamp <= buyNowInp.deadline,\\n            \\\"BuyNowBase::assertBuyNowInputsOK: payment deadline expired\\\"\\n        );\\n        if (_isSellerRegistrationRequired)\\n            require(\\n                _isRegisteredSeller[buyNowInp.seller],\\n                \\\"BuyNowBase::assertBuyNowInputsOK: seller not registered\\\"\\n            );\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function enoughFundsAvailable(address buyer, uint256 amount)\\n        public\\n        view\\n        returns (bool)\\n    {\\n        return maxFundsAvailable(buyer) >= amount;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function maxFundsAvailable(address buyer) public view returns (uint256) {\\n        return _balanceOf[buyer] + externalBalance(buyer);\\n    }\\n\\n    /**\\n     * @notice Interface to method that must return the amount available to a buyer outside this contract\\n     * @dev If the contract that implements this interface deals with native crypto, then it must return buyer.balance;\\n     *  if dealing with ERC20, it must return the available balance in the external ERC20 contract.\\n     * @param buyer The address for which funds are queried\\n     * @return the external funds available\\n     */\\n    function externalBalance(address buyer) public view virtual returns (uint256);\\n\\n    /// @inheritdoc IBuyNowBase\\n    function splitFundingSources(address buyer, uint256 amount)\\n        public\\n        view\\n        returns (uint256 externalFunds, uint256 localFunds)\\n    {\\n        uint256 localBalance = _balanceOf[buyer];\\n        localFunds = (amount > localBalance) ? localBalance : amount;\\n        externalFunds = (amount > localBalance) ? amount - localBalance : 0;\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function onlyUserCanWithdraw(address user) public view returns (bool) {\\n        return _onlyUserCanWithdraw[user];\\n    }\\n\\n    // PURE FUNCTIONS\\n\\n    /**\\n     * @dev Reverts if either of the following addresses coincide: operator, buyer, seller\\n     *  On the one hand, the operator must be an observer.\\n     *  On the other hand, the seller cannot act on his/her already owned assets.\\n     * @param operator The address of the operator\\n     * @param buyer The address of the buyer\\n     * @param seller The address of the seller\\n    */\\n    function assertSeparateRoles(address operator, address buyer, address seller)\\n        internal pure {\\n        require(\\n            (operator != buyer) && (operator != seller),\\n            \\\"BuyNowBase::assertSeparateRoles: operator must be an observer\\\"\\n        );\\n        require(\\n            (buyer != seller),\\n            \\\"BuyNowBase::assertSeparateRoles: buyer and seller cannot coincide\\\"\\n        );\\n    }\\n\\n    /// @inheritdoc IBuyNowBase\\n    function computeFeeAmount(uint256 amount, uint256 feeBPS)\\n        public\\n        pure\\n        returns (uint256)\\n    {\\n        uint256 feeAmount = (amount * feeBPS) / 10000;\\n        return (feeAmount <= amount) ? feeAmount : amount;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/buyNow/IBuyNowNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./base/IBuyNowBase.sol\\\";\\n\\n/**\\n * @title Interface to Escrow Contract for Payments in BuyNow mode, in native cryptocurrency.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev The contract that implements this interface adds an entry point for BuyNow payments,\\n * which are defined and documented in the inherited IBuyNowBase.\\n * - in the 'buyNow' method, the buyer is the msg.sender (the buyer therefore signs the TX),\\n *   and the operator's EIP712-signature of the BuyNowInput struct is provided as input to the call.\\n */\\n\\ninterface IBuyNowNative is IBuyNowBase {\\n    /**\\n     * @notice Starts Payment process by the buyer.\\n     * @dev Executed by the buyer, who relays the MetaTX with the operator's signature.\\n     *  The buyer must provide the correct amount via msg.value.\\n     *  If all requirements are fulfilled, it stores the data relevant\\n     *  for the next steps of the payment, and it locks the funds\\n     *  in this contract.\\n     *  Follows standard Checks-Effects-Interactions pattern\\n     *  to protect against re-entrancy attacks.\\n     *  Moves payment to ASSET_TRANSFERRING state.\\n     * @param buyNowInp The struct containing all required payment data\\n     * @param operatorSignature The signature of 'buyNowInp' by the operator\\n     * @param sellerSignature the signature of the seller agreeing to list the asset\\n     */\\n    function buyNow(\\n        BuyNowInput calldata buyNowInp,\\n        bytes calldata operatorSignature,\\n        bytes calldata sellerSignature\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"/contracts/buyNow/BuyNowNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./IBuyNowNative.sol\\\";\\nimport \\\"./base/BuyNowBase.sol\\\";\\n\\n/**\\n * @title Escrow Contract for Payments in BuyNow mode, in Native Cryptocurrency.\\n * @author Freeverse.io, www.freeverse.io\\n * @notice Full contract documentation in IBuyNowNative\\n */\\n\\ncontract BuyNowNative is IBuyNowNative, BuyNowBase {\\n\\n    constructor(string memory currencyDescriptor, address eip712) BuyNowBase(currencyDescriptor, eip712) {}\\n\\n    /// @inheritdoc IBuyNowNative\\n    function buyNow(\\n        BuyNowInput calldata buyNowInp,\\n        bytes calldata operatorSignature,\\n        bytes calldata sellerSignature\\n    ) external payable {\\n        require(\\n            msg.sender == buyNowInp.buyer,\\n            \\\"BuyNowNative::buyNow: only buyer can execute this function\\\"\\n        );\\n        address operator = universeOperator(buyNowInp.universeId);\\n        require(\\n            IEIP712VerifierBuyNow(_eip712).verifyBuyNow(buyNowInp, operatorSignature, operator),\\n            \\\"BuyNowNative::buyNow: incorrect operator signature\\\"\\n        );\\n        // The following requirement avoids possible mistakes in building the TX's msg.value.\\n        // While the funds provided can be less than the asset price (in case of buyer having local balance),\\n        // there is no reason for providing more funds than the asset price.\\n        require(\\n            (msg.value <= buyNowInp.amount),\\n            \\\"BuyNowNative::buyNow: new funds provided must be less than bid amount\\\"\\n        );\\n        _processBuyNow(buyNowInp, operator, sellerSignature);\\n    }\\n\\n    // PRIVATE & INTERNAL FUNCTIONS\\n\\n    /**\\n     * @dev Updates buyer's local balance, re-using it if possible, and adding excess of provided funds, if any.\\n     *  It is difficult to predict the exact msg.value required at the moment of submitting a payment,\\n     *  because localFunds may have just increased due to an asynchronously finished sale by the buyer.\\n     *  Any possible excess of provided funds is moved to buyer's local balance.\\n     * @param buyer The address executing the payment\\n     * @param newFundsNeeded The elsewhere computed minimum amount of funds required to be provided by the buyer,\\n     *  having possible re-use of local funds into account\\n     * @param localFunds The elsewhere computed amount of funds available to the buyer in this contract that will be\\n     *  re-used in the payment\\n     */\\n    function _updateBuyerBalanceOnPaymentReceived(\\n        address buyer,\\n        uint256 newFundsNeeded,\\n        uint256 localFunds\\n    ) internal override {\\n        require(\\n            (msg.value >= newFundsNeeded),\\n            \\\"BuyNowNative::_updateBuyerBalanceOnPaymentReceived: new funds provided are not within required range\\\"\\n        );\\n        // The next operation can never underflow due to the previous constraint,\\n        // and to the fact that splitFundingSources guarantees that _balanceOf[buyer] >= localFunds\\n        _balanceOf[buyer] = (_balanceOf[buyer] + msg.value) - newFundsNeeded - localFunds;\\n    }\\n\\n    /**\\n     * @dev Transfers the specified amount to the specified address.\\n     *  Requirements and effects (e.g. balance updates) are performed\\n     *  before calling this function.\\n     * @param to The address that must receive the funds.\\n     * @param amount The amount to transfer.\\n    */\\n    function _transfer(address to, uint256 amount) internal override {\\n        (bool success, ) = to.call{value: amount}(\\\"\\\");\\n        require(success, \\\"BuyNowNative::_transfer: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    // VIEW FUNCTIONS\\n\\n    /**\\n     * @notice Returns the amount available to a buyer outside this contract\\n     * @param buyer The address for which funds are queried\\n     * @return the external funds available\\n     */\\n    function externalBalance(address buyer) public view override returns (uint256) {\\n        return buyer.balance;\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/auction/base/ISignableStructsAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\n/**\\n * @title Interface for Structs required in MetaTXs using EIP712.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev This contract defines the structure BidInput, required for auction processes.\\n *  This structure requires a separate implementation of its EIP712-verifying function.\\n */\\n\\ninterface ISignableStructsAuction {\\n\\n    /**\\n    * @notice The main struct that characterizes a bid\\n    * @dev Used as input to the bid/relayedBid methods to either start\\n    * @dev an auction or increment a previous existing bid;\\n    * @dev it needs to be signed following EIP712\\n    */\\n    struct BidInput {\\n        // the unique Id that identifies a payment process,\\n        // common to both Auctions and BuyNows,\\n        // obtained from hashing params related to the listing, \\n        // including a sufficiently large source of entropy.\\n        bytes32 paymentId;\\n\\n        // the time at which the auction ends if\\n        // no bids arrive during the final minutes;\\n        // this value is stored on arrival of the first bid,\\n        // and possibly incremented on arrival of late bids\\n        uint256 endsAt;\\n\\n        // the bid amount, an integer expressed in the\\n        // lowest unit of the currency.\\n        uint256 bidAmount;\\n\\n        // the fee that will be charged by the feeOperator,\\n        // expressed as percentage Basis Points (bps), applied to amount.\\n        // e.g. feeBPS = 500 implements a 5% fee.\\n        uint256 feeBPS;\\n\\n        // the id of the universe that the asset belongs to.\\n        uint256 universeId;\\n\\n        // the deadline for the payment to arrive to this\\n        // contract, otherwise it will be rejected.\\n        uint256 deadline;\\n\\n        // the bidder, providing the required funds, who shall receive\\n        // the asset in case of winning the auction.       \\n        address bidder;\\n\\n        // the seller of the asset, who shall receive the funds\\n        // (subtracting fees) on successful completion of the auction.\\n        address seller;\\n    }\\n}\"\r\n    },\r\n    \"/contracts/auction/base/IEIP712VerifierAuction.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./ISignableStructsAuction.sol\\\";\\n\\n/**\\n * @title Interface to Verification of MetaTXs for Auctions.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev This contract defines the interface to the verifying function\\n *  for the struct defined in ISignableStructsAuction (BidInput),\\n *  used in auction processes, as well as to the function that verifies\\n *  the seller signature agreeing to list the asset.\\n *  Potential future changes in any of these signing methods can be handled by having\\n *  the main contract redirect to a different verifier contract.\\n */\\n\\ninterface IEIP712VerifierAuction is ISignableStructsAuction {\\n    /**\\n     * @notice Verifies that the provided BidInput struct has been signed\\n     *  by the provided signer.\\n     * @param bidInput The provided BidInput struct\\n     * @param signature The provided signature of the input struct\\n     * @param signer The signer's address that we want to verify\\n     * @return Returns true if the signature corresponds to the\\n     *  provided signer having signed the input struct\\n     */\\n    function verifyBid(\\n        BidInput calldata bidInput,\\n        bytes calldata signature,\\n        address signer\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice Verifies the seller signature showing agreement\\n     *  to list the asset as ruled by this explicit paymentId.\\n     * @dev To anticipate for future potential differences in verifiers for\\n     *  BuyNow/Auction listings, the interfaces to verifiers for both flows are\\n     *  kept separate, accepting the entire respective structs as input.\\n     *  For the same reason, the interface declares the method as 'view', prepared\\n     *  to use EIP712 flows, even if the initial implementation can be 'pure'.\\n     * @param sellerSignature the signature of the seller agreeing to list the asset as ruled by\\n     *  this explicit paymentId\\n     * @param bidInput The provided BuyNowInput struct\\n     * @return Returns true if the seller signature is correct\\n     */\\n    function verifySellerSignature(\\n        bytes calldata sellerSignature,\\n        BidInput calldata bidInput\\n    ) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"/contracts/auction/base/IAuctionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"../../buyNow/base/IBuyNowBase.sol\\\";\\nimport \\\"./ISignableStructsAuction.sol\\\";\\n\\n/**\\n * @title Interface for a base Escrow Contract for Payments, that adds\\n * an Auction mode to an inherited contract that implements the BuyNow mode.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev The contract that implements this interface inherits the payment process \\n * required to conduct BuyNows, and extends it with Auctioning capabilities,\\n * adding new entry points to start Auctions via bid methods, and reusing all the\\n * State Machine, refund and withdraw methods of BuyNows after an auction finishes. \\n *\\n * The contract that implements this interface can be inherited to conduct\\n * auctions/buyNows in either native crypto or ERC20 tokens.\\n\\n * Buyers/bidders explicitly sign the agreement to let the specified Operator address\\n * act as an Oracle, responsible for signing the success or failure of the asset transfer,\\n * which is conducted outside this contract upon reception of funds in a Buynow, or\\n * completion of an Auction.\\n *\\n * If no confirmation is received from the Operator during the PaymentWindow,\\n * all funds received from the buyer/bidder are made available to him/her for refund.\\n * Throughout the contract, this moment is labeled as 'expirationTime'.\\n *\\n * To start an auction, signatures of both the buyer and the Operator are required, and they\\n * are checked in the contracts that inherit from this one. \\n *\\n * The variable 'uint256 paymentId' is used to uniquely identify the started process, regardless\\n * of whether it is a BuyNow or an Auction.\\n *\\n * The contract that implements this interface maintains the balances of all users,\\n * which can be withdrawn via explicit calls to the various 'withdraw' methods.\\n * If a buyer/bidder has a non-zero local balance at the moment of executing buyNow/bid,\\n * the contract reuses it, and only requires the provision of the\\n * remainder funds required (if any).\\n *\\n * Auctions start with an initial bid, and an initial 'endsAt' time,\\n * and are characterized by: {minIncreasePercentage, timeToExtend, extendableUntil}.\\n * - New bids need to provide and increase of at least minIncreasePercentage;\\n * - 'Late bids', defined as those that arrive during the time window [endsAt - timeToExtend, endsAt],\\n *   increment endsAt by an amount equal to timeToExtend, with max accumulated extension capped by extendableUntil.\\n *\\n * Each payment has the following State Machine:\\n * - NOT_STARTED -> ASSET_TRANSFERRING, triggered by buyNow\\n * - NOT_STARTED -> AUCTIONING, triggered by bid\\n * - AUCTIONING -> AUCTIONING, triggered by successive bids\\n * - AUCTIONING -> ASSET_TRANSFERRING, triggered when block.timestamp > endsAt;\\n *   in this case, this transition is an implicit one, reflected by the change in the return\\n *   state of the paymentState method.\\n * - ASSET_TRANSFERRING -> PAID, triggered by relaying assetTransferSuccess signed by Operator\\n * - ASSET_TRANSFERRING -> REFUNDED, triggered by relaying assetTransferFailed signed by Operator\\n * - ASSET_TRANSFERRING -> REFUNDED, triggered by a refund request after expirationTime\\n *\\n * NOTE: To ensure that the every process proceeds as expected when the payment starts,\\n * the following configuration data is stored uniquely for every payment when it is created,\\n * remaining unmodified regardless of any possible changes to the contract's storage defaults:\\n * - In BuyNow payments: {operator, feesCollector, expirationTime}\\n * - In Auctions: {operator, feesCollector, expirationTime, minIncreasePercentage, timeToExtend, extendableUntil}\\n *\\n * NOTE: The contract allows a feature, 'Seller Registration', that can be used in the scenario that\\n * applications want users to prove that they have enough crypto know-how (obtain native crypto,\\n * pay for gas using a web3 wallet, etc.) to interact by themselves with this smart contract before selling,\\n * so that they are less likely to require technical help in case they need to withdraw funds.\\n * - If _isSellerRegistrationRequired = true, this feature is enabled, and payments can only be initiated\\n *    if the payment seller has previously executed the registerAsSeller method.\\n * - If _isSellerRegistrationRequired = false, this feature is disabled, and payments can be initiated\\n *    regardless of any previous call to the registerAsSeller method.\\n *\\n * NOTE: Following previous audits suggestions, the EIP712 contract, which uses OpenZeppelin's implementation,\\n * is not inherited; it is separately deployed, so that it can be upgraded should the standard evolve in the future.\\n *\\n */\\n\\ninterface IAuctionBase is IBuyNowBase, ISignableStructsAuction {\\n    /**\\n     * @dev Event emitted on change of the default auction configuration settings.\\n     * @param minIncreasePercentage The minimum % amount that a new bid needs to increase\\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\\n     * @param timeToExtend If a bid arrives during the time window [endsAt - timeToExtend, endsAt],\\n     *  then endsAt is increased by timeToExtend.\\n     * @param extendableBy The maximum value that endsAt can be increased in an auction\\n     *  as a result of accumulated late-arriving bids.\\n     * @param prevMinIncreasePercentage The previous value of minIncreasePercentage\\n     * @param prevTimeToExtend The previous value of timeToExtend\\n     * @param prevExtendableBy The previous value of extendableBy\\n     */\\n    event DefaultAuctionConfig(\\n        uint256 minIncreasePercentage,\\n        uint256 timeToExtend,\\n        uint256 extendableBy,\\n        uint256 prevMinIncreasePercentage,\\n        uint256 prevTimeToExtend,\\n        uint256 prevExtendableBy\\n    );\\n\\n    /**\\n     * @dev Event emitted on change of the auction configuration settings of a specific universe.\\n     *  Note that the previous values emitted correspond to the previous values of the struct\\n     *  storing the universe config params; not the params queried by the method universeAuctionConfig,\\n     *  which resorts to the default config if the specific universe config is not set. \\n     *  This is to avoid events depending on internal logic, and just keeping track of stored state changes.  \\n     * @param universeId The id of the universe\\n     * @param minIncreasePercentage The minimum amount that a new bid needs to increase\\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\\n     * @param timeToExtend If a bid arrives during the time window [endsAt - timeToExtend, endsAt],\\n     *  then endsAt is increased by timeToExtend.\\n     * @param extendableBy The maximum value that endsAt can be increased in an auction\\n     *  as a result of accumulated late-arriving bids.\\n     * @param prevMinIncreasePercentage The previous value of minIncreasePercentage\\n     * @param prevTimeToExtend The previous value of timeToExtend\\n     * @param prevExtendableBy The previous value of extendableBy\\n    */\\n    event UniverseAuctionConfig(\\n        uint256 indexed universeId,\\n        uint256 minIncreasePercentage,\\n        uint256 timeToExtend,\\n        uint256 extendableBy,\\n        uint256 prevMinIncreasePercentage,\\n        uint256 prevTimeToExtend,\\n        uint256 prevExtendableBy\\n    );\\n\\n    /**\\n     * @dev Event emitted on removal of a specific universe Auction Config,\\n     *  so that the default Auction Config is used from now on.\\n     * @param universeId The id of the universe\\n     */\\n    event RemovedUniverseAuctionConfig(uint256 indexed universeId);\\n\\n    /**\\n     * @dev Event emitted when a Bid arrives and is correctly validated\\n     * @param paymentId The unique id identifying the payment\\n     * @param bidder The address of the bidder providing the funds\\n     * @param seller The address of the seller of the asset\\n     * @param bidAmount The funds provided with the bid\\n     * @param endsAt The time at which the auction ends if no late bids arrive\\n     */\\n    event Bid(\\n        bytes32 indexed paymentId,\\n        address indexed bidder,\\n        address indexed seller,\\n        uint256 bidAmount,\\n        uint256 endsAt\\n    );\\n\\n    /**\\n     * @notice Struct containing auction parameters that will be used by new incoming bids.\\n     * @param minIncreasePercentage The minimum amount that a new bid needs to increase\\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\\n     * @param timeToExtend If a bid arrives during the time window [endsAt - timeToExtend, endsAt],\\n     *  then endsAt is increased by timeToExtend.\\n     * @param extendableBy The maximum value that endsAt can be increased in an auction\\n     *  as a result of accumulated late-arriving bids.\\n     */\\n    struct AuctionConfig {\\n        uint256 minIncreasePercentage;\\n        uint256 timeToExtend;\\n        uint256 extendableBy;\\n    }\\n\\n    /**\\n     * @notice Struct containing config parameters describing already existing Auctions\\n     * @dev When an auction is created, and an instance of this struct is stored,\\n     *  all fields of the struct remain non-modifiable except for 'endsAt'.\\n     * @param endsAt The time at which the auction ends if no late bids arrive\\n     * @param minIncreasePercentage The minimum amount that a new bid needs to increase\\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\\n     * @param timeToExtend If a bid arrives during the time window [endsAt - timeToExtend, endsAt],\\n     *  then endsAt is increased by timeToExtend.\\n     * @param extendableUntil The maximum value that endsAt can achieve in an auction\\n     *  as a result of accumulated late-arriving bids.\\n     */\\n    struct ExistingAuction {\\n        uint256 endsAt;\\n        uint256 minIncreasePercentage;\\n        uint256 timeToExtend;\\n        uint256 extendableUntil;\\n    }\\n\\n    /**\\n     * @notice Sets the default auction configuration settings\\n     * @param minIncreasePercentage The minimum amount that a new bid needs to increase\\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\\n     * @param timeToExtend If a bid arrives during the time window [endsAt - timeToExtend, endsAt],\\n     *  then endsAt is increased by timeToExtend.\\n     * @param extendableBy The maximum value that endsAt can be increased in an auction\\n     *  as a result of accumulated late-arriving bids.\\n     */\\n    function setDefaultAuctionConfig(\\n        uint256 minIncreasePercentage,\\n        uint256 timeToExtend,\\n        uint256 extendableBy\\n    ) external;\\n\\n    /**\\n     * @notice Sets the auction configuration settings specific to one universe\\n     * @param universeId The id of the universe\\n     * @param minIncreasePercentage The minimum amount that a new bid needs to increase\\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\\n     * @param timeToExtend the value such that, if a bid arrives during the\\n     *  time window [endsAt - timeToExtend, endsAt], then endsAt is increased by timeToExtend.\\n     * @param extendableBy The maximum value that endsAt can be increased in an auction\\n     *  as a result of accumulated late-arriving bids.\\n     */\\n    function setUniverseAuctionConfig(\\n        uint256 universeId,\\n        uint256 minIncreasePercentage,\\n        uint256 timeToExtend,\\n        uint256 extendableBy\\n    ) external;\\n\\n    /**\\n     * @notice Removes the auction configuration settings specific to one universe,\\n     *  so that, from now on, this universe uses the default configuration.\\n     * @param universeId The id of the universe\\n     */\\n    function removeUniverseAuctionConfig(uint256 universeId) external;\\n\\n    /**\\n     * @notice Splits the funds required to provide the bidAmount specified in a bid into two sources:\\n     *  - externalFunds: the funds required to be transferred from the external bidder balance\\n     *  - localFunds: the funds required from the bidder's already available balance in this contract.\\n     *  If new bidder coincides with previous max bidder, only the difference between\\n     *  the two bidAmounts is required.\\n     * @param bidInput The struct containing all required bid data\\n     * @return externalFunds The funds required to be transferred from the external bidder balance\\n     * @return localFunds The amount of local funds that will be used.\\n     * @return isSameBidder A bool which is true if the bidder coincides with the previous max bidder of the auction.\\n     */\\n    function splitAuctionFundingSources(BidInput memory bidInput)\\n        external\\n        view\\n        returns (\\n            uint256 externalFunds,\\n            uint256 localFunds,\\n            bool isSameBidder\\n        );\\n\\n    /**\\n     * @notice Reverts unless the requirements for a BidInput are fulfilled.\\n     * @param bidInput The struct containing all required bid data\\n     * @return state The current state of the auction\\n     */\\n    function assertBidInputsOK(BidInput calldata bidInput)\\n        external\\n        view\\n        returns (State state);\\n\\n    /**\\n     * @notice Returns the minimum bidAmount required for a new arriving bid,\\n     *  having minIncreasePercentage into account.\\n     * @param paymentId The unique ID that identifies the payment.\\n     * @return the minimum bidAmount of a new arriving bid\\n     */\\n    function minNewBidAmount(bytes32 paymentId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the state of a payment.\\n     * @dev Overrides the method in the BuyNow contract to account for\\n     *  possibly on-going Auctions.\\n     *  It returns the explicit state stored unless:\\n     *  - it is in AUCTIONING state &&\\n     *  - the current time is beyond the auction ending time,\\n     *  in wich case the auction is finished, and it returns ASSET_TRANSFERING.\\n     *  If payment is in ASSET_TRANSFERRING, it may be worth\\n     *  checking acceptsRefunds to check to it has gone beyond expirationTime.\\n     * @param paymentId The unique ID that identifies the payment.\\n     * @return the state of the payment.\\n     */\\n    function paymentState(bytes32 paymentId)\\n        external\\n        view\\n        override\\n        returns (State);\\n\\n    /**\\n     * @notice The minimum percentage that a new bid needs to increase\\n     *  above the previous highest bid, for the specified universe\\n     * @dev It returns the default value unless the universe has a specific auction config\\n     * @param universeId The id of the universe\\n     * @return minIncreasePercentage The minimum percentage that a new bid needs to increase\\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\\n     */\\n    function universeMinIncreasePercentage(uint256 universeId)\\n        external\\n        view\\n        returns (uint256);\\n\\n    /**\\n     * @notice Returns the value such that, if a bid arrives during the\\n     *  time window [endsAt - timeToExtend, endsAt], then endsAt is increased by timeToExtend,\\n     *  for the specified universe.\\n     * @dev It returns the default value unless the universe has a specific auction config\\n     * @param universeId The id of the universe\\n     * @return the value such that, if a bid arrives during the\\n     *  time window [endsAt - timeToExtend, endsAt], then endsAt is increased by timeToExtend.\\n     */\\n    function universeTimeToExtend(uint256 universeId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the maximum value that endsAt can be increased in an auction\\n     *  as a result of accumulated late-arriving bids, for the specified universe.\\n     * @dev It returns the default value unless the universe has a specific auction config\\n     * @param universeId The id of the universe\\n     * @return The maximum value that endsAt can be increased in an auction\\n     *  as a result of accumulated late-arriving bids for the specified universe\\n     */\\n    function universeExtendableBy(uint256 universeId) external view returns (uint256);\\n\\n    /**\\n     * @notice Returns the default auction configuration settings struct\\n     * @return the default auction configuration settings struct.\\n     */\\n    function defaultAuctionConfig()\\n        external\\n        view\\n        returns (AuctionConfig memory);\\n\\n    /**\\n     * @notice Returns the auction configuration settings of a specific universe.\\n     * @param universeId The id of the universe\\n     * @return the struct containing the auction configuration settings of the specified universe.\\n     */\\n    function universeAuctionConfig(uint256 universeId)\\n        external\\n        view\\n        returns (AuctionConfig memory);\\n\\n    /**\\n     * @notice Returns the stored auction data of an existing auction\\n     * @param paymentId The unique id identifying the payment\\n     * @return the struct containing the auction configuration settings of the specified paymentId.\\n     */\\n    function existingAuction(bytes32 paymentId)\\n        external\\n        view\\n        returns (ExistingAuction memory);\\n}\\n\"\r\n    },\r\n    \"/contracts/auction/base/AuctionBase.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./IAuctionBase.sol\\\";\\nimport \\\"../../buyNow/base/BuyNowBase.sol\\\";\\nimport \\\"./IEIP712VerifierAuction.sol\\\";\\n\\n/**\\n * @title Base Escrow Contract for Payments, that adds an Auction mode\\n *  to the inherited BuyNowBase, which implements the BuyNow mode.\\n * @author Freeverse.io, www.freeverse.io\\n * @notice Full contract documentation in IAuctionBase\\n */\\n\\nabstract contract AuctionBase is IAuctionBase, BuyNowBase {\\n    // max amount of time allowed between the arrival of the first bid\\n    // of an auction, and the planned auction endsAt, in absence of late bids.\\n    uint256 public constant _MAX_AUCTION_DURATION = 15 days;\\n\\n    // max total amount of time that an auction's endsAt can be\\n    // increased as a result of accumulated late-arriving bids.\\n    uint256 public constant _MAX_EXTENDABLE_BY = 2 days;\\n\\n    // the default config parameters used by Auctions\\n    AuctionConfig internal _defaultAuctionConfig;\\n\\n    // mapping between universeId and their specific auction config parameters\\n    mapping(uint256 => AuctionConfig) private _universeAuctionConfig;\\n\\n    // mapping between universeId and whether a specific auction config exists\\n    // for that universe\\n    mapping(uint256 => bool) public _universeAuctionConfigExists;\\n\\n    // mapping between existing paymentsIds for auctions,\\n    // and the stored data about these Auctions\\n    mapping(bytes32 => ExistingAuction) private _auctions;\\n\\n    constructor(\\n        uint256 minIncreasePercentage,\\n        uint256 time2Extend,\\n        uint256 extendableBy\\n    ) {\\n       setDefaultAuctionConfig(\\n            minIncreasePercentage,\\n            time2Extend,\\n            extendableBy\\n        );\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function setDefaultAuctionConfig(\\n        uint256 minIncreasePercentage,\\n        uint256 time2Extend,\\n        uint256 extendableBy\\n    ) public onlyOwner {\\n        AuctionConfig memory oldConfig = _defaultAuctionConfig;\\n        _defaultAuctionConfig = _createAuctionConfig(\\n            minIncreasePercentage,\\n            time2Extend,\\n            extendableBy\\n        );\\n        emit DefaultAuctionConfig(\\n            minIncreasePercentage, time2Extend, extendableBy,\\n            oldConfig.minIncreasePercentage, oldConfig.timeToExtend, oldConfig.extendableBy\\n        );\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function setUniverseAuctionConfig(\\n        uint256 universeId,\\n        uint256 minIncreasePercentage,\\n        uint256 time2Extend,\\n        uint256 extendableBy\\n    ) external onlyOwner {\\n        AuctionConfig memory oldConfig =  _universeAuctionConfig[universeId];\\n        _universeAuctionConfig[universeId] = _createAuctionConfig(\\n            minIncreasePercentage,\\n            time2Extend,\\n            extendableBy\\n        );\\n        _universeAuctionConfigExists[universeId] = true;\\n        emit UniverseAuctionConfig(\\n            universeId,\\n            minIncreasePercentage, time2Extend, extendableBy,\\n            oldConfig.minIncreasePercentage, oldConfig.timeToExtend, oldConfig.extendableBy\\n        );\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function removeUniverseAuctionConfig(uint256 universeId)\\n        external\\n        onlyOwner\\n    {\\n        delete _universeAuctionConfig[universeId];\\n        _universeAuctionConfigExists[universeId] = false;\\n        emit RemovedUniverseAuctionConfig(universeId);\\n    }\\n\\n    // PRIVATE & INTERNAL FUNCTIONS\\n\\n    /**\\n     * @dev Checks bid input parameters,\\n     *  transfers required funds from external contract (in case of ERC20 Payments),\\n     *  reuses buyer's local balance (if any),\\n     *  stores the payment and auction data in contract's storage,\\n     *  and refunds previous highest bidder (if any).\\n     *  - If payment is in NOT_STARTED => it moves to AUCTIONING\\n     *  - If payment is in AUCTIONING => it remains in AUCTIONING\\n     * @param operator The address of the operator of this payment.\\n     * @param bidInput The BidInput struct\\n     */\\n    function _processBid(\\n        address operator,\\n        BidInput calldata bidInput,\\n        bytes calldata sellerSignature\\n    ) internal {\\n        State state = assertBidInputsOK(bidInput);\\n        assertSeparateRoles(operator, bidInput.bidder, bidInput.seller);\\n        (uint256 newFundsNeeded, uint256 localFunds, bool isSameBidder) = splitAuctionFundingSources(bidInput);\\n        _updateBuyerBalanceOnPaymentReceived(bidInput.bidder, newFundsNeeded, localFunds);\\n\\n        if (state == State.NotStarted) {\\n            // If 1st bid for auction => new auction is to be created:\\n            // 1. Only verify the permission to list the asset on the first bid to arrive\\n            require(\\n                IEIP712VerifierAuction(_eip712).verifySellerSignature(\\n                    sellerSignature,\\n                    bidInput\\n                ),\\n                \\\"AuctionBase::_processBid: incorrect seller signature\\\"\\n            );\\n            // 2.- store the part of the data common to Auctions and BuyNows;\\n            //     maxBidder and maxBid are stored in this struct, and updated on successive bids\\n            uint256 extendableUntil = bidInput.endsAt + universeExtendableBy(bidInput.universeId);\\n            uint256 expirationTime = extendableUntil + _paymentWindow;\\n            _payments[bidInput.paymentId] = Payment(\\n                State.Auctioning,\\n                bidInput.bidder,\\n                bidInput.seller,\\n                bidInput.universeId,\\n                universeFeesCollector(bidInput.universeId),\\n                expirationTime,\\n                bidInput.feeBPS,\\n                bidInput.bidAmount\\n            );\\n            // 2.- store the part of the data only relevant to Auctions;\\n            //     only 'endsAt' may change in this struct (and only on arrival of late bids)\\n            _auctions[bidInput.paymentId] = ExistingAuction(\\n                bidInput.endsAt,\\n                universeMinIncreasePercentage(bidInput.universeId),\\n                universeTimeToExtend(bidInput.universeId),\\n                extendableUntil\\n            );\\n        } else {\\n            // If an auction already existed:\\n            if (!isSameBidder) {\\n                // if new bidder is different from previous max bidder:\\n                // - and refund previous max bidder\\n                _refundPreviousBidder(bidInput);\\n\\n                // - update max bidder\\n                _payments[bidInput.paymentId].buyer = bidInput.bidder;\\n\\n            }\\n\\n            // 2.- update the previous highest bid\\n            _payments[bidInput.paymentId].amount = bidInput.bidAmount;\\n        }\\n\\n        // extend auction ending time if classified as late bid:\\n        uint256 endsAt = _extendAuctionOnLateBid(bidInput);\\n\\n        emit Bid(bidInput.paymentId, bidInput.bidder, bidInput.seller, bidInput.bidAmount, endsAt);\\n    }\\n\\n    /**\\n     * @dev Interface to a method that, on arrival of a bid that outbids a previous one,\\n     *  refunds previous bidder, with refund options depedending on implementation\\n     *  (refund to local balance, transfer to external contract, etc.)\\n     * @param bidInput The struct containing all bid data\\n     */\\n    function _refundPreviousBidder(BidInput memory bidInput) internal virtual;\\n\\n    /**\\n     * @notice Increments the ending time of an auction on arrival of a 'late bid' during the\\n     *  time window [currentEndsAt - timeToExtend, currentEndsAt], by an amount equal to timeToExtend,\\n     *  never exceeding the extendableUntil value stored during the creation of that auction.\\n     * @param bidInput The struct containing all bid data\\n     * @return endsAt On late bid: the incremented ending time of the auction;\\n     *  on non-late bid: the previous unmodified ending time.\\n     */\\n    function _extendAuctionOnLateBid(BidInput memory bidInput)\\n        private\\n        returns (uint256 endsAt)\\n    {\\n        endsAt = _auctions[bidInput.paymentId].endsAt;\\n\\n        // return current endsAt if not within the last minutes:\\n        uint256 time2Extend = _auctions[bidInput.paymentId].timeToExtend;\\n        if ((block.timestamp + time2Extend) <= endsAt) return endsAt;\\n\\n        // increment endsAt, but never beyond extension limit\\n        endsAt += time2Extend;\\n        uint256 extendableUntil = _auctions[bidInput.paymentId].extendableUntil;\\n        if (endsAt > extendableUntil) endsAt = extendableUntil;\\n\\n        // store incremented value:\\n        _auctions[bidInput.paymentId].endsAt = endsAt;\\n    }\\n\\n    /**\\n     * @notice Checks that minIncreasePercentage is non-zero, and returns an AuctionConfig struct\\n     * @param minIncreasePercentage The minimum amount that a new bid needs to increase\\n     *  above the previous highest bid, expressed as a percentage in Basis Points (BPS).\\n     *  e.g.: minIncreasePercentage = 500 requires new bids to be 5% larger.\\n     * @param time2Extend If a bid arrives during the time window [endsAt - timeToExtend, endsAt],\\n     *  then endsAt is increased by timeToExtend.\\n     * @param extendableBy The maximum value that endsAt can be increased in an auction\\n     *  as a result of accumulated late-arriving bids.\\n     * @return the AuctionConfig struct\\n     */\\n    function _createAuctionConfig(\\n        uint256 minIncreasePercentage,\\n        uint256 time2Extend,\\n        uint256 extendableBy\\n    ) private pure returns (AuctionConfig memory) {\\n        require(\\n            minIncreasePercentage > 0,\\n            \\\"AuctionBase::_createAuctionConfig: minIncreasePercentage must be non-zero\\\"\\n        );\\n        require(\\n            extendableBy <= _MAX_EXTENDABLE_BY,\\n            \\\"AuctionBase::_createAuctionConfig: extendableBy exceeds maximum allowed\\\"\\n        );\\n        return AuctionConfig(minIncreasePercentage, time2Extend, extendableBy);\\n    }\\n\\n    // VIEW FUNCTIONS\\n\\n    /// @inheritdoc IAuctionBase\\n    function assertBidInputsOK(BidInput calldata bidInput)\\n        public\\n        view\\n        returns (State state)\\n    {\\n        uint256 currentTime = block.timestamp;\\n\\n        // requirements independent of current auction state:\\n        require(\\n            currentTime <= bidInput.deadline,\\n            \\\"AuctionBase::assertBidInputsOK: payment deadline expired\\\"\\n        );\\n        if (_isSellerRegistrationRequired) {\\n            require(\\n                _isRegisteredSeller[bidInput.seller],\\n                \\\"AuctionBase::assertBidInputsOK: seller not registered\\\"\\n            );\\n        }\\n\\n        // requirements that depend on current auction state:\\n        state = paymentState(bidInput.paymentId);\\n        if (state == State.NotStarted) {\\n            // if auction does not exist yet, assert values are within obvious limits \\n            require(\\n                bidInput.endsAt >= currentTime,\\n                \\\"AuctionBase::assertBidInputsOK: endsAt cannot be in the past\\\"\\n            );\\n            require(\\n                bidInput.endsAt < currentTime + _MAX_AUCTION_DURATION,\\n                \\\"AuctionBase::assertBidInputsOK: endsAt exceeds maximum allowed\\\"\\n            );\\n            require(\\n                bidInput.feeBPS <= _maxFeeBPS,\\n                \\\"AuctionBase::assertBidInputsOK: fee cannot be larger than maxFeeBPS\\\"\\n            );\\n            require(\\n                bidInput.bidAmount > 0,\\n                \\\"AuctionBase::assertBidInputsOK: bid amount cannot be 0\\\"\\n            );\\n        } else if (state == State.Auctioning) {\\n            // if auction exists already:\\n            require(\\n                bidInput.bidAmount >= minNewBidAmount(bidInput.paymentId),\\n                \\\"AuctionBase::assertBidInputsOK: bid needs to be larger than previous bid by a certain percentage\\\"\\n            );\\n        } else {\\n            revert(\\\"AuctionBase::assertBidInputsOK: bids are only accepted if state is either NOT_STARTED or AUCTIONING\\\");\\n        }\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function splitAuctionFundingSources(BidInput calldata bidInput)\\n        public\\n        view\\n        returns (\\n            uint256 externalFunds,\\n            uint256 localFunds,\\n            bool isSameBidder\\n        )\\n    {\\n        isSameBidder = (bidInput.bidder == _payments[bidInput.paymentId].buyer);\\n\\n        // If new bidder coincides with previous max bidder, only the provision of funds\\n        // corresponding to the difference between the two bidAmounts is required\\n        uint256 amount = isSameBidder\\n            ? bidInput.bidAmount - _payments[bidInput.paymentId].amount\\n            : bidInput.bidAmount;\\n        (externalFunds, localFunds) = splitFundingSources(\\n            bidInput.bidder,\\n            amount\\n        );\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function minNewBidAmount(bytes32 paymentId) public view returns (uint256) {\\n        uint256 previousBidAmount = _payments[paymentId].amount;\\n        uint256 minNewAmount = (previousBidAmount *\\n            (10000 + _auctions[paymentId].minIncreasePercentage)) / 10000;\\n        // If previousBidAmount and minIncreasePercentage are small,\\n        // it is possible to the int division results in minNewAmount = previousBidAmount.\\n        // In that case, return + 1 to avoid accepting bids that do not increment previous amount.\\n        return minNewAmount > previousBidAmount ? minNewAmount : previousBidAmount + 1;\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function paymentState(bytes32 paymentId)\\n        public\\n        view\\n        virtual\\n        override(IAuctionBase, BuyNowBase)\\n        returns (State)\\n    {\\n        State state = _payments[paymentId].state;\\n        if (state != State.Auctioning) return state;\\n        return\\n            (block.timestamp > _auctions[paymentId].endsAt)\\n                ? State.AssetTransferring\\n                : State.Auctioning;\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function universeMinIncreasePercentage(uint256 universeId)\\n        public\\n        view\\n        returns (uint256)\\n    {\\n        return\\n            _universeAuctionConfigExists[universeId]\\n                ? _universeAuctionConfig[universeId].minIncreasePercentage\\n                : _defaultAuctionConfig.minIncreasePercentage;\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function universeTimeToExtend(uint256 universeId) public view returns (uint256) {\\n        return\\n            _universeAuctionConfigExists[universeId]\\n                ? _universeAuctionConfig[universeId].timeToExtend\\n                : _defaultAuctionConfig.timeToExtend;\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function universeExtendableBy(uint256 universeId) public view returns (uint256) {\\n        return\\n            _universeAuctionConfigExists[universeId]\\n                ? _universeAuctionConfig[universeId].extendableBy\\n                : _defaultAuctionConfig.extendableBy;\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function defaultAuctionConfig() public view returns (AuctionConfig memory) {\\n        return _defaultAuctionConfig;\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function universeAuctionConfig(uint256 universeId)\\n        public\\n        view\\n        returns (AuctionConfig memory)\\n    {\\n        return _universeAuctionConfig[universeId];\\n    }\\n\\n    /// @inheritdoc IAuctionBase\\n    function existingAuction(bytes32 paymentId)\\n        public\\n        view\\n        returns (ExistingAuction memory)\\n    {\\n        return _auctions[paymentId];\\n    }\\n}\\n\"\r\n    },\r\n    \"/contracts/auction/IAuctionNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity =0.8.14;\\n\\nimport \\\"./base/ISignableStructsAuction.sol\\\";\\n\\n/**\\n * @title Interface to Escrow Contract for Payments in Auction & BuyNow modes, in Native Cryptocurrencies.\\n * @author Freeverse.io, www.freeverse.io\\n * @dev The contract that implements this interface adds an entry point for Bid processes in Auctions,\\n * which are defined and documented in the AuctionBase contract.\\n * - in the 'bid' method, the buyer is the msg.sender (the buyer therefore signs the TX),\\n *   and the Operator's EIP712-signature of the BidInput struct is provided as input to the call.\\n *\\n *  When a bidder is outbid by a different user, he/she is automatically refunded to this contract's\\n *  local balance. Accepting a new bid and transferring funds to the previous bidder in the same TX would\\n *  not be a safe operation, since the external address could contain malicious implementations\\n *  on arrival of new funds.\\n*/\\n\\ninterface IAuctionNative is ISignableStructsAuction {\\n    /**\\n     * @notice Processes an arriving bid, and either starts a new Auction process,\\n     *   or updates an existing one.\\n     * @dev Executed by the bidder, who relays the operator's signature.\\n     *  The bidder must provide, at least, the minimal required funds via msg.value,\\n     *  where the minimal amount takes into account any possibly available local funds,\\n     *  and the case where the same bidder raises his/her previous max bid,\\n     *  in which case only the difference between bids is required.\\n     *  If all requirements are fulfilled, it stores the data relevant for the next steps\\n     *  of the auction, and it locks the funds in this contract.\\n     *  If this is the first bid of an auction, it moves its state to AUCTIONING,\\n     *  whereas if it arrives on an on-going auction, it remains in AUCTIONING.\\n     * @param bidInput The struct containing all required bid data\\n     * @param operatorSignature The signature of 'bidInput' by the operator\\n     * @param sellerSignature the signature of the seller agreeing to list the asset\\n     */\\n    function bid(\\n        BidInput calldata bidInput,\\n        bytes calldata operatorSignature,\\n        bytes calldata sellerSignature\\n    ) external payable;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"currencyDescriptor\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"eip712\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"minIncreasePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time2Extend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extendableBy\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"endsAt\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"BuyNow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BuyerRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minIncreasePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeToExtend\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extendableBy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevMinIncreasePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevTimeToExtend\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevExtendableBy\",\"type\":\"uint256\"}],\"name\":\"DefaultAuctionConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feesCollector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevFeesCollector\",\"type\":\"address\"}],\"name\":\"DefaultFeesCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOperator\",\"type\":\"address\"}],\"name\":\"DefaultOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"eip712address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"prevEip712address\",\"type\":\"address\"}],\"name\":\"EIP712\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"maxFeeBPS\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevMaxFeeBPS\",\"type\":\"uint256\"}],\"name\":\"MaxFeeBPS\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"NewSeller\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"onlyUserCanWithdraw\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"prevOnlyUserCanWithdraw\",\"type\":\"bool\"}],\"name\":\"OnlyUserCanWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"Paid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevWindow\",\"type\":\"uint256\"}],\"name\":\"PaymentWindow\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"RemovedUniverseAuctionConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minIncreasePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"timeToExtend\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"extendableBy\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevMinIncreasePercentage\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevTimeToExtend\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevExtendableBy\",\"type\":\"uint256\"}],\"name\":\"UniverseAuctionConfig\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"feesCollector\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevFeesCollector\",\"type\":\"address\"}],\"name\":\"UniverseFeesCollector\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"prevOperator\",\"type\":\"address\"}],\"name\":\"UniverseOperator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"EIP712Address\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_AUCTION_DURATION\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_MAX_EXTENDABLE_BY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_universeAuctionConfigExists\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"acceptsRefunds\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"endsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"internalType\":\"struct ISignableStructsAuction.BidInput\",\"name\":\"bidInput\",\"type\":\"tuple\"}],\"name\":\"assertBidInputsOK\",\"outputs\":[{\"internalType\":\"enum IBuyNowBase.State\",\"name\":\"state\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"internalType\":\"struct ISignableStructsBuyNow.BuyNowInput\",\"name\":\"buyNowInp\",\"type\":\"tuple\"}],\"name\":\"assertBuyNowInputsOK\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"endsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"internalType\":\"struct ISignableStructsAuction.BidInput\",\"name\":\"bidInput\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"operatorSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sellerSignature\",\"type\":\"bytes\"}],\"name\":\"bid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"internalType\":\"struct ISignableStructsBuyNow.BuyNowInput\",\"name\":\"buyNowInp\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"operatorSignature\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"sellerSignature\",\"type\":\"bytes\"}],\"name\":\"buyNow\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBPS\",\"type\":\"uint256\"}],\"name\":\"computeFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"currencyLongDescriptor\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultAuctionConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minIncreasePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeToExtend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extendableBy\",\"type\":\"uint256\"}],\"internalType\":\"struct IAuctionBase.AuctionConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultFeesCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"defaultOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"enoughFundsAvailable\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"existingAuction\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"endsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minIncreasePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeToExtend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extendableUntil\",\"type\":\"uint256\"}],\"internalType\":\"struct IAuctionBase.ExistingAuction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"externalBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"wasSuccessful\",\"type\":\"bool\"}],\"internalType\":\"struct ISignableStructsBuyNow.AssetTransferResult\",\"name\":\"transferResult\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"operatorSignature\",\"type\":\"bytes\"}],\"name\":\"finalize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"internalType\":\"bool\",\"name\":\"wasSuccessful\",\"type\":\"bool\"}],\"internalType\":\"struct ISignableStructsBuyNow.AssetTransferResult\",\"name\":\"transferResult\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"operatorSignature\",\"type\":\"bytes\"}],\"name\":\"finalizeAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isRegisteredSeller\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSellerRegistrationRequired\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxFeeBPS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"maxFundsAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"minNewBidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"onlyUserCanWithdraw\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"paymentInfo\",\"outputs\":[{\"components\":[{\"internalType\":\"enum IBuyNowBase.State\",\"name\":\"state\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feesCollector\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"expirationTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct IBuyNowBase.Payment\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"paymentState\",\"outputs\":[{\"internalType\":\"enum IBuyNowBase.State\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paymentWindow\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"refundAndWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"registerAsSeller\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"relayedWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"removeUniverseAuctionConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"removeUniverseFeesCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"removeUniverseOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"minIncreasePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time2Extend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extendableBy\",\"type\":\"uint256\"}],\"name\":\"setDefaultAuctionConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feesCollector\",\"type\":\"address\"}],\"name\":\"setDefaultFeesCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"setDefaultOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"eip712address\",\"type\":\"address\"}],\"name\":\"setEIP712\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"isRequired\",\"type\":\"bool\"}],\"name\":\"setIsSellerRegistrationRequired\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"feeBPS\",\"type\":\"uint256\"}],\"name\":\"setMaxFeeBPS\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"onlyUserCan\",\"type\":\"bool\"}],\"name\":\"setOnlyUserCanWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"window\",\"type\":\"uint256\"}],\"name\":\"setPaymentWindow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minIncreasePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"time2Extend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extendableBy\",\"type\":\"uint256\"}],\"name\":\"setUniverseAuctionConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feesCollector\",\"type\":\"address\"}],\"name\":\"setUniverseFeesCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"setUniverseOperator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bytes32\",\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"endsAt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"feeBPS\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"bidder\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"seller\",\"type\":\"address\"}],\"internalType\":\"struct ISignableStructsAuction.BidInput\",\"name\":\"bidInput\",\"type\":\"tuple\"}],\"name\":\"splitAuctionFundingSources\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"externalFunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"localFunds\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSameBidder\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"buyer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"splitFundingSources\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"externalFunds\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"localFunds\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"universeAuctionConfig\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"minIncreasePercentage\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timeToExtend\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"extendableBy\",\"type\":\"uint256\"}],\"internalType\":\"struct IAuctionBase.AuctionConfig\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"universeExtendableBy\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"universeFeesCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"universeMinIncreasePercentage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"universeOperator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"universeTimeToExtend\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AuctionNative", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000eb33d526e3fd28768b67f50cbe31dcefe6e08c2300000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000258000000000000000000000000000000000000000000000000000000000002a30000000000000000000000000000000000000000000000000000000000000000054d41544943000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}