{"SourceCode": "# @version 0.3.7\r\n\r\n\"\"\"\r\n@title Yearn V3 Vault\r\n@license GNU AGPLv3\r\n@author yearn.finance\r\n@notice\r\n    The Yearn VaultV3 is designed as an non-opinionated system to distribute funds of \r\n    depositors for a specific `asset` into different opportunities (aka Strategies)\r\n    and manage accounting in a robust way.\r\n\r\n    Depositors receive shares (aka vaults tokens) proportional to their deposit amount. \r\n    Vault tokens are yield-bearing and can be redeemed at any time to get back deposit \r\n    plus any yield generated.\r\n\r\n    Addresses that are given different permissioned roles by the `role_manager` \r\n    are then able to allocate funds as they best see fit to different strategies \r\n    and adjust the strategies and allocations as needed, as well as reporting realized\r\n    profits or losses.\r\n\r\n    Strategies are any ERC-4626 compliant contracts that use the same underlying `asset` \r\n    as the vault. The vault provides no assurances as to the safety of any strategy\r\n    and it is the responsibility of those that hold the corresponding roles to choose\r\n    and fund strategies that best fit their desired specifications.\r\n\r\n    Those holding vault tokens are able to redeem the tokens for the corresponding\r\n    amount of underlying asset based on any reported profits or losses since their\r\n    initial deposit.\r\n\r\n    The vault is built to be customized by the management to be able to fit their\r\n    specific desired needs Including the customization of strategies, accountants, \r\n    ownership etc.\r\n\"\"\"\r\n\r\nfrom vyper.interfaces import ERC20\r\nfrom vyper.interfaces import ERC20Detailed\r\n\r\n# INTERFACES #\r\ninterface IStrategy:\r\n    def asset() -> address: view\r\n    def balanceOf(owner: address) -> uint256: view\r\n    def maxDeposit(receiver: address) -> uint256: view\r\n    def maxWithdraw(owner: address) -> uint256: view\r\n    def withdraw(amount: uint256, receiver: address, owner: address) -> uint256: nonpayable\r\n    def redeem(shares: uint256, receiver: address, owner: address) -> uint256: nonpayable\r\n    def deposit(assets: uint256, receiver: address) -> uint256: nonpayable\r\n    def totalAssets() -> (uint256): view\r\n    def convertToAssets(shares: uint256) -> uint256: view\r\n    def convertToShares(assets: uint256) -> uint256: view\r\n    def previewWithdraw(assets: uint256) -> uint256: view\r\n\r\ninterface IAccountant:\r\n    def report(strategy: address, gain: uint256, loss: uint256) -> (uint256, uint256): nonpayable\r\n\r\ninterface IFactory:\r\n    def protocol_fee_config() -> (uint16, address): view\r\n\r\n# EVENTS #\r\n# ERC4626 EVENTS\r\nevent Deposit:\r\n    sender: indexed(address)\r\n    owner: indexed(address)\r\n    assets: uint256\r\n    shares: uint256\r\n\r\nevent Withdraw:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    owner: indexed(address)\r\n    assets: uint256\r\n    shares: uint256\r\n\r\n# ERC20 EVENTS\r\nevent Transfer:\r\n    sender: indexed(address)\r\n    receiver: indexed(address)\r\n    value: uint256\r\n\r\nevent Approval:\r\n    owner: indexed(address)\r\n    spender: indexed(address)\r\n    value: uint256\r\n\r\n# STRATEGY EVENTS\r\nevent StrategyChanged:\r\n    strategy: indexed(address)\r\n    change_type: indexed(StrategyChangeType)\r\n    \r\nevent StrategyReported:\r\n    strategy: indexed(address)\r\n    gain: uint256\r\n    loss: uint256\r\n    current_debt: uint256\r\n    protocol_fees: uint256\r\n    total_fees: uint256\r\n    total_refunds: uint256\r\n\r\n# DEBT MANAGEMENT EVENTS\r\nevent DebtUpdated:\r\n    strategy: indexed(address)\r\n    current_debt: uint256\r\n    new_debt: uint256\r\n\r\n# ROLE UPDATES\r\nevent RoleSet:\r\n    account: indexed(address)\r\n    role: indexed(Roles)\r\n\r\nevent RoleStatusChanged:\r\n    role: indexed(Roles)\r\n    status: indexed(RoleStatusChange)\r\n\r\n# STORAGE MANAGEMENT EVENTS\r\nevent UpdateRoleManager:\r\n    role_manager: indexed(address)\r\n\r\nevent UpdateAccountant:\r\n    accountant: indexed(address)\r\n\r\nevent UpdateDefaultQueue:\r\n    new_default_queue: DynArray[address, MAX_QUEUE]\r\n\r\nevent UpdatedMaxDebtForStrategy:\r\n    sender: indexed(address)\r\n    strategy: indexed(address)\r\n    new_debt: uint256\r\n\r\nevent UpdateDepositLimit:\r\n    deposit_limit: uint256\r\n\r\nevent UpdateMinimumTotalIdle:\r\n    minimum_total_idle: uint256\r\n\r\nevent UpdateProfitMaxUnlockTime:\r\n    profit_max_unlock_time: uint256\r\n\r\nevent DebtPurchased:\r\n    strategy: indexed(address)\r\n    amount: uint256\r\n\r\nevent Shutdown:\r\n    pass\r\n\r\n# STRUCTS #\r\nstruct StrategyParams:\r\n    # Timestamp when the strategy was added.\r\n    activation: uint256 \r\n    # Timestamp of the strategies last report.\r\n    last_report: uint256\r\n    # The current assets the strategy holds.\r\n    current_debt: uint256\r\n    # The max assets the strategy can hold. \r\n    max_debt: uint256\r\n\r\n# CONSTANTS #\r\n# The max length the withdrawal queue can be.\r\nMAX_QUEUE: constant(uint256) = 10\r\n# 100% in Basis Points.\r\nMAX_BPS: constant(uint256) = 10_000\r\n# Extended for profit locking calculations.\r\nMAX_BPS_EXTENDED: constant(uint256) = 1_000_000_000_000\r\n# The version of this vault.\r\nAPI_VERSION: constant(String[28]) = \"3.0.0\"\r\n\r\n# ENUMS #\r\n# Each permissioned function has its own Role.\r\n# Roles can be combined in any combination or all kept separate.\r\n# Follows python Enum patterns so the first Enum == 1 and doubles each time.\r\nenum Roles:\r\n    ADD_STRATEGY_MANAGER # Can add strategies to the vault.\r\n    REVOKE_STRATEGY_MANAGER # Can remove strategies from the vault.\r\n    FORCE_REVOKE_MANAGER # Can force remove a strategy causing a loss.\r\n    ACCOUNTANT_MANAGER # Can set the accountant that assess fees.\r\n    QUEUE_MANAGER # Can set the default withdrawal queue.\r\n    REPORTING_MANAGER # Calls report for strategies.\r\n    DEBT_MANAGER # Adds and removes debt from strategies.\r\n    MAX_DEBT_MANAGER # Can set the max debt for a strategy.\r\n    DEPOSIT_LIMIT_MANAGER # Sets deposit limit for the vault.\r\n    MINIMUM_IDLE_MANAGER # Sets the minimum total idle the vault should keep.\r\n    PROFIT_UNLOCK_MANAGER # Sets the profit_max_unlock_time.\r\n    DEBT_PURCHASER # Can purchase bad debt from the vault.\r\n    EMERGENCY_MANAGER # Can shutdown vault in an emergency.\r\n\r\nenum StrategyChangeType:\r\n    ADDED\r\n    REVOKED\r\n\r\nenum Rounding:\r\n    ROUND_DOWN\r\n    ROUND_UP\r\n\r\nenum RoleStatusChange:\r\n    OPENED\r\n    CLOSED\r\n\r\n# IMMUTABLE #\r\n# Underlying token used by the vault.\r\nASSET: immutable(ERC20)\r\n# Based off the `asset` decimals.\r\nDECIMALS: immutable(uint256)\r\n# Deployer contract used to retrieve the protocol fee config.\r\nFACTORY: public(immutable(address))\r\n\r\n# STORAGE\u00a0#\r\n# HashMap that records all the strategies that are allowed to receive assets from the vault.\r\nstrategies: public(HashMap[address, StrategyParams])\r\n# The current default withdrawal queue.\r\ndefault_queue: public(DynArray[address, MAX_QUEUE])\r\n\r\n# ERC20 - amount of shares per account\r\nbalance_of: HashMap[address, uint256]\r\n# ERC20 - owner -> (spender -> amount)\r\nallowance: public(HashMap[address, HashMap[address, uint256]])\r\n# Total amount of shares that are currently minted including those locked.\r\n# NOTE: To get the ERC20 compliant version user totalSupply().\r\ntotal_supply: public(uint256)\r\n\r\n# Total amount of assets that has been deposited in strategies.\r\ntotal_debt: uint256\r\n# Current assets held in the vault contract. Replacing balanceOf(this) to avoid price_per_share manipulation.\r\ntotal_idle: uint256\r\n# Minimum amount of assets that should be kept in the vault contract to allow for fast, cheap redeems.\r\nminimum_total_idle: public(uint256)\r\n# Maximum amount of tokens that the vault can accept. If totalAssets > deposit_limit, deposits will revert.\r\ndeposit_limit: public(uint256)\r\n# Contract that charges fees and can give refunds.\r\naccountant: public(address)\r\n# HashMap mapping addresses to their roles\r\nroles: public(HashMap[address, Roles])\r\n# HashMap mapping roles to their permissioned state. If false, the role is not open to the public.\r\nopen_roles: public(HashMap[Roles, bool])\r\n# Address that can add and remove roles to addresses.\r\nrole_manager: public(address)\r\n# Temporary variable to store the address of the next role_manager until the role is accepted.\r\nfuture_role_manager: public(address)\r\n# State of the vault - if set to true, only withdrawals will be available. It can't be reverted.\r\nshutdown: public(bool)\r\n\r\n# ERC20 - name of the vaults token.\r\nname: public(String[64])\r\n# ERC20 - symbol of the vaults token.\r\nsymbol: public(String[32])\r\n\r\n# The amount of time profits will unlock over.\r\nprofit_max_unlock_time: uint256\r\n# The timestamp of when the current unlocking period ends.\r\nfull_profit_unlock_date: uint256\r\n# The per second rate at which profit will unlock.\r\nprofit_unlocking_rate: uint256\r\n# Last timestamp of the most recent profitable report.\r\nlast_profit_update: uint256\r\n\r\n# `nonces` track `permit` approvals with signature.\r\nnonces: public(HashMap[address, uint256])\r\nDOMAIN_TYPE_HASH: constant(bytes32) = keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\r\nPERMIT_TYPE_HASH: constant(bytes32) = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\")\r\n\r\n# Constructor\r\n@external\r\ndef __init__(\r\n    asset: ERC20, \r\n    name: String[64], \r\n    symbol: String[32], \r\n    role_manager: address, \r\n    profit_max_unlock_time: uint256\r\n):\r\n    \"\"\"\r\n    @notice\r\n        The constructor for the vault. Sets the asset, name, symbol, and role manager.\r\n    @param asset\r\n        The address of the asset that the vault will accept.\r\n    @param name\r\n        The name of the vault token.\r\n    @param symbol\r\n        The symbol of the vault token.\r\n    @param role_manager \r\n        The address that can add and remove roles to addresses\r\n    @param profit_max_unlock_time\r\n        The amount of time that the profit will be locked for\r\n    \"\"\"\r\n    ASSET = asset\r\n    DECIMALS = convert(ERC20Detailed(asset.address).decimals(), uint256)\r\n    assert DECIMALS < 256 # dev: see VVE-2020-0001\r\n    \r\n    FACTORY = msg.sender\r\n\r\n    # Must be > 0 so we can unlock shares\r\n    assert profit_max_unlock_time > 0 # dev: profit unlock time too low\r\n    # Must be less than one year for report cycles\r\n    assert profit_max_unlock_time <= 31_556_952 # dev: profit unlock time too long\r\n    self.profit_max_unlock_time = profit_max_unlock_time\r\n\r\n    self.name = name\r\n    self.symbol = symbol\r\n    self.role_manager = role_manager\r\n\r\n## SHARE MANAGEMENT ##\r\n## ERC20 ##\r\n@internal\r\ndef _spend_allowance(owner: address, spender: address, amount: uint256):\r\n    # Unlimited approval does nothing (saves an SSTORE)\r\n    current_allowance: uint256 = self.allowance[owner][spender]\r\n    if (current_allowance < max_value(uint256)):\r\n        assert current_allowance >= amount, \"insufficient allowance\"\r\n        self._approve(owner, spender, unsafe_sub(current_allowance, amount))\r\n\r\n@internal\r\ndef _transfer(sender: address, receiver: address, amount: uint256):\r\n    sender_balance: uint256 = self.balance_of[sender]\r\n    assert sender_balance >= amount, \"insufficient funds\"\r\n    self.balance_of[sender] = unsafe_sub(sender_balance, amount)\r\n    self.balance_of[receiver] = unsafe_add(self.balance_of[receiver], amount)\r\n    log Transfer(sender, receiver, amount)\r\n\r\n@internal\r\ndef _transfer_from(sender: address, receiver: address, amount: uint256) -> bool:\r\n    self._spend_allowance(sender, msg.sender, amount)\r\n    self._transfer(sender, receiver, amount)\r\n    return True\r\n\r\n@internal\r\ndef _approve(owner: address, spender: address, amount: uint256) -> bool:\r\n    self.allowance[owner][spender] = amount\r\n    log Approval(owner, spender, amount)\r\n    return True\r\n\r\n@internal\r\ndef _increase_allowance(owner: address, spender: address, amount: uint256) -> bool:\r\n    new_allowance: uint256 = self.allowance[owner][spender] + amount\r\n    self.allowance[owner][spender] = new_allowance\r\n    log Approval(owner, spender, new_allowance)\r\n    return True\r\n\r\n@internal\r\ndef _decrease_allowance(owner: address, spender: address, amount: uint256) -> bool:\r\n    new_allowance: uint256 = self.allowance[owner][spender] - amount\r\n    self.allowance[owner][spender] = new_allowance\r\n    log Approval(owner, spender, new_allowance)\r\n    return True\r\n\r\n@internal\r\ndef _permit(\r\n    owner: address, \r\n    spender: address, \r\n    amount: uint256, \r\n    deadline: uint256, \r\n    v: uint8, \r\n    r: bytes32, \r\n    s: bytes32\r\n) -> bool:\r\n    assert owner != empty(address), \"invalid owner\"\r\n    assert deadline >= block.timestamp, \"permit expired\"\r\n    nonce: uint256 = self.nonces[owner]\r\n    digest: bytes32 = keccak256(\r\n        concat(\r\n            b'\\x19\\x01',\r\n            self.domain_separator(),\r\n            keccak256(\r\n                concat(\r\n                    PERMIT_TYPE_HASH,\r\n                    convert(owner, bytes32),\r\n                    convert(spender, bytes32),\r\n                    convert(amount, bytes32),\r\n                    convert(nonce, bytes32),\r\n                    convert(deadline, bytes32),\r\n                )\r\n            )\r\n        )\r\n    )\r\n    assert ecrecover(\r\n        digest, convert(v, uint256), convert(r, uint256), convert(s, uint256)\r\n    ) == owner, \"invalid signature\"\r\n\r\n    self.allowance[owner][spender] = amount\r\n    self.nonces[owner] = nonce + 1\r\n    log Approval(owner, spender, amount)\r\n    return True\r\n\r\n@internal\r\ndef _burn_shares(shares: uint256, owner: address):\r\n    self.balance_of[owner] -= shares\r\n    self.total_supply = unsafe_sub(self.total_supply, shares)\r\n    log Transfer(owner, empty(address), shares)\r\n\r\n@view\r\n@internal\r\ndef _unlocked_shares() -> uint256:\r\n    \"\"\"\r\n    Returns the amount of shares that have been unlocked.\r\n    To avoid sudden price_per_share spikes, profits must be processed \r\n    through an unlocking period. The mechanism involves shares to be \r\n    minted to the vault which are unlocked gradually over time. Shares \r\n    that have been locked are gradually unlocked over profit_max_unlock_time.\r\n    \"\"\"\r\n    _full_profit_unlock_date: uint256 = self.full_profit_unlock_date\r\n    unlocked_shares: uint256 = 0\r\n    if _full_profit_unlock_date > block.timestamp:\r\n        # If we have not fully unlocked, we need to calculate how much has been.\r\n        unlocked_shares = self.profit_unlocking_rate * (block.timestamp - self.last_profit_update) / MAX_BPS_EXTENDED\r\n\r\n    elif _full_profit_unlock_date != 0:\r\n        # All shares have been unlocked\r\n        unlocked_shares = self.balance_of[self]\r\n\r\n    return unlocked_shares\r\n\r\n\r\n@view\r\n@internal\r\ndef _total_supply() -> uint256:\r\n    # Need to account for the shares issued to the vault that have unlockded.\r\n    return self.total_supply - self._unlocked_shares()\r\n\r\n@internal\r\ndef _burn_unlocked_shares():\r\n    \"\"\"\r\n    Burns shares that have been unlocked since last update. \r\n    In case the full unlocking period has passed, it stops the unlocking.\r\n    \"\"\"\r\n    # Get the amount of shares that have unlocked\r\n    unlocked_shares: uint256 = self._unlocked_shares()\r\n\r\n    # IF 0 there's nothing to do.\r\n    if unlocked_shares == 0:\r\n        return\r\n\r\n    # Only do an SSTORE if necessary\r\n    if self.full_profit_unlock_date > block.timestamp:\r\n        self.last_profit_update = block.timestamp\r\n\r\n    # Burn the shares unlocked.\r\n    self._burn_shares(unlocked_shares, self)\r\n\r\n@view\r\n@internal\r\ndef _total_assets() -> uint256:\r\n    \"\"\"\r\n    Total amount of assets that are in the vault and in the strategies. \r\n    \"\"\"\r\n    return self.total_idle + self.total_debt\r\n\r\n@view\r\n@internal\r\ndef _convert_to_assets(shares: uint256, rounding: Rounding) -> uint256:\r\n    \"\"\" \r\n    assets = shares * (total_assets / total_supply) --- (== price_per_share * shares)\r\n    \"\"\"\r\n    total_supply: uint256 = self._total_supply()\r\n    # if total_supply is 0, price_per_share is 1\r\n    if total_supply == 0: \r\n        return shares\r\n\r\n    numerator: uint256 = shares * self._total_assets()\r\n    amount: uint256 = numerator / total_supply\r\n    if rounding == Rounding.ROUND_UP and numerator % total_supply != 0:\r\n        amount += 1\r\n\r\n    return amount\r\n\r\n@view\r\n@internal\r\ndef _convert_to_shares(assets: uint256, rounding: Rounding) -> uint256:\r\n    \"\"\"\r\n    shares = amount * (total_supply / total_assets) --- (== amount / price_per_share)\r\n    \"\"\"\r\n    total_supply: uint256 = self._total_supply()\r\n    total_assets: uint256 = self._total_assets()\r\n\r\n    if total_assets == 0:\r\n        # if total_assets and total_supply is 0, price_per_share is 1\r\n        if total_supply == 0:\r\n            return assets\r\n        else:\r\n            # Else if total_supply > 0 price_per_share is 0\r\n            return 0\r\n\r\n    numerator: uint256 = assets * total_supply\r\n    shares: uint256 = numerator / total_assets\r\n    if rounding == Rounding.ROUND_UP and numerator % total_assets != 0:\r\n        shares += 1\r\n\r\n    return shares\r\n\r\n@internal\r\ndef _erc20_safe_approve(token: address, spender: address, amount: uint256):\r\n    # Used only to approve tokens that are not the type managed by this Vault.\r\n    # Used to handle non-compliant tokens like USDT\r\n    assert ERC20(token).approve(spender, amount, default_return_value=True), \"approval failed\"\r\n\r\n@internal\r\ndef _erc20_safe_transfer_from(token: address, sender: address, receiver: address, amount: uint256):\r\n    # Used only to transfer tokens that are not the type managed by this Vault.\r\n    # Used to handle non-compliant tokens like USDT\r\n    assert ERC20(token).transferFrom(sender, receiver, amount, default_return_value=True), \"transfer failed\"\r\n\r\n@internal\r\ndef _erc20_safe_transfer(token: address, receiver: address, amount: uint256):\r\n    # Used only to send tokens that are not the type managed by this Vault.\r\n    # Used to handle non-compliant tokens like USDT\r\n    assert ERC20(token).transfer(receiver, amount, default_return_value=True), \"transfer failed\"\r\n\r\n@internal\r\ndef _issue_shares(shares: uint256, recipient: address):\r\n    self.balance_of[recipient] = unsafe_add(self.balance_of[recipient], shares)\r\n    self.total_supply += shares\r\n\r\n    log Transfer(empty(address), recipient, shares)\r\n\r\n@internal\r\ndef _issue_shares_for_amount(amount: uint256, recipient: address) -> uint256:\r\n    \"\"\"\r\n    Issues shares that are worth 'amount' in the underlying token (asset).\r\n    WARNING: this takes into account that any new assets have been summed \r\n    to total_assets (otherwise pps will go down).\r\n    \"\"\"\r\n    total_supply: uint256 = self._total_supply()\r\n    total_assets: uint256 = self._total_assets()\r\n    new_shares: uint256 = 0\r\n    \r\n    # If no supply PPS = 1.\r\n    if total_supply == 0:\r\n        new_shares = amount\r\n    elif total_assets > amount:\r\n        new_shares = amount * total_supply / (total_assets - amount)\r\n    else:\r\n        # If total_supply > 0 but amount = totalAssets we want to revert because\r\n        # after first deposit, getting here would mean that the rest of the shares\r\n        # would be diluted to a price_per_share of 0. Issuing shares would then mean\r\n        # either the new depositer or the previous depositers will loose money.\r\n        assert total_assets > amount, \"amount too high\"\r\n  \r\n    # We don't make the function revert\r\n    if new_shares == 0:\r\n       return 0\r\n\r\n    self._issue_shares(new_shares, recipient)\r\n\r\n    return new_shares\r\n\r\n## ERC4626 ##\r\n@view\r\n@internal\r\ndef _max_deposit(receiver: address) -> uint256: \r\n    if receiver in [empty(address), self]:\r\n        return 0\r\n\r\n    _total_assets: uint256 = self._total_assets()\r\n    _deposit_limit: uint256 = self.deposit_limit\r\n    if (_total_assets >= _deposit_limit):\r\n        return 0\r\n\r\n    return unsafe_sub(_deposit_limit, _total_assets)\r\n\r\n@view\r\n@internal\r\ndef _max_redeem(owner: address) -> uint256:\r\n    return self.balance_of[owner]\r\n\r\n@view\r\n@internal\r\ndef _max_withdraw(owner: address) -> uint256:\r\n    return self._convert_to_assets(self.balance_of[owner], Rounding.ROUND_DOWN)\r\n\r\n@internal\r\ndef _deposit(sender: address, recipient: address, assets: uint256) -> uint256:\r\n    \"\"\"\r\n    Used for `deposit` calls to transfer the amount of `asset` to the vault, \r\n    issue the corresponding shares to the `recipient` and update all needed \r\n    vault accounting.\r\n    \"\"\"\r\n    assert self.shutdown == False # dev: shutdown\r\n    assert recipient not in [self, empty(address)], \"invalid recipient\"\r\n    assert self._total_assets() + assets <= self.deposit_limit, \"exceed deposit limit\"\r\n \r\n    # Transfer the tokens to the vault first.\r\n    self._erc20_safe_transfer_from(ASSET.address, msg.sender, self, assets)\r\n    # Record the change in total assets.\r\n    self.total_idle += assets\r\n    \r\n    # Issue the corresponding shares for assets.\r\n    shares: uint256 = self._issue_shares_for_amount(assets, recipient)\r\n\r\n    assert shares > 0, \"cannot mint zero\"\r\n\r\n    log Deposit(sender, recipient, assets, shares)\r\n    return shares\r\n\r\n@internal\r\ndef _mint(sender: address, recipient: address, shares: uint256) -> uint256:\r\n    \"\"\"\r\n    Used for `mint` calls to issue the corresponding shares to the `recipient`,\r\n    transfer the amount of `asset` to the vault, and update all needed vault \r\n    accounting.\r\n    \"\"\"\r\n    assert self.shutdown == False # dev: shutdown\r\n    assert recipient not in [self, empty(address)], \"invalid recipient\"\r\n\r\n    assets: uint256 = self._convert_to_assets(shares, Rounding.ROUND_UP)\r\n\r\n    assert assets > 0, \"cannot mint zero\"\r\n    assert self._total_assets() + assets <= self.deposit_limit, \"exceed deposit limit\"\r\n\r\n    # Transfer the tokens to the vault first.\r\n    self._erc20_safe_transfer_from(ASSET.address, msg.sender, self, assets)\r\n    # Record the change in total assets.\r\n    self.total_idle += assets\r\n    \r\n    # Issue the corresponding shares for assets.\r\n    self._issue_shares(shares, recipient)\r\n\r\n    log Deposit(sender, recipient, assets, shares)\r\n    return assets\r\n\r\n@view\r\n@internal\r\ndef _assess_share_of_unrealised_losses(strategy: address, assets_needed: uint256) -> uint256:\r\n    \"\"\"\r\n    Returns the share of losses that a user would take if withdrawing from this strategy\r\n    e.g. if the strategy has unrealised losses for 10% of its current debt and the user \r\n    wants to withdraw 1000 tokens, the losses that he will take are 100 token\r\n    \"\"\"\r\n    # Minimum of how much debt the debt should be worth.\r\n    strategy_current_debt: uint256 = self.strategies[strategy].current_debt\r\n    # The actual amount that the debt is currently worth.\r\n    vault_shares: uint256 = IStrategy(strategy).balanceOf(self)\r\n    strategy_assets: uint256 = IStrategy(strategy).convertToAssets(vault_shares)\r\n    \r\n    # If no losses, return 0\r\n    if strategy_assets >= strategy_current_debt or strategy_current_debt == 0:\r\n        return 0\r\n\r\n    # Users will withdraw assets_to_withdraw divided by loss ratio (strategy_assets / strategy_current_debt - 1),\r\n    # but will only receive assets_to_withdraw.\r\n    # NOTE: If there are unrealised losses, the user will take his share.\r\n    numerator: uint256 = assets_needed * strategy_assets\r\n    losses_user_share: uint256 = assets_needed - numerator / strategy_current_debt\r\n    # Always round up.\r\n    if numerator % strategy_current_debt != 0:\r\n        losses_user_share += 1\r\n\r\n    return losses_user_share\r\n\r\n@internal\r\ndef _redeem(\r\n    sender: address, \r\n    receiver: address, \r\n    owner: address,\r\n    assets: uint256,\r\n    shares_to_burn: uint256, \r\n    max_loss: uint256,\r\n    strategies: DynArray[address, MAX_QUEUE]\r\n) -> uint256:\r\n    \"\"\"\r\n    This will attempt to free up the full amount of assets equivalent to\r\n    `shares_to_burn` and transfer them to the `receiver`. If the vault does\r\n    not have enough idle funds it will go through any strategies provided by\r\n    either the withdrawer or the queue_manaager to free up enough funds to \r\n    service the request.\r\n\r\n    The vault will attempt to account for any unrealized losses taken on from\r\n    strategies since their respective last reports.\r\n\r\n    Any losses realized during the withdraw from a strategy will be passed on\r\n    to the user that is redeeming their vault shares.\r\n    \"\"\"\r\n    assert receiver != empty(address), \"ZERO ADDRESS\"\r\n\r\n    shares: uint256 = shares_to_burn\r\n    shares_balance: uint256 = self.balance_of[owner]\r\n\r\n    assert shares > 0, \"no shares to redeem\"\r\n    assert shares_balance >= shares, \"insufficient shares to redeem\"\r\n    \r\n    if sender != owner:\r\n        self._spend_allowance(owner, sender, shares_to_burn)\r\n\r\n    # The amount of the underlying token to withdraw.\r\n    requested_assets: uint256 = assets\r\n\r\n    # load to memory to save gas\r\n    curr_total_idle: uint256 = self.total_idle\r\n    \r\n    # If there are not enough assets in the Vault contract, we try to free \r\n    # funds from strategies.\r\n    if requested_assets > curr_total_idle:\r\n\r\n        # Cache the input withdrawal queue.\r\n        _strategies: DynArray[address, MAX_QUEUE] = strategies\r\n\r\n        # If no queue was passed.\r\n        if len(_strategies) == 0:\r\n                # Use the default queue.\r\n                _strategies = self.default_queue\r\n\r\n        # load to memory to save gas\r\n        curr_total_debt: uint256 = self.total_debt\r\n\r\n        # Withdraw from strategies only what idle doesn't cover.\r\n        # `assets_needed` is the total amount we need to fill the request.\r\n        assets_needed: uint256 = unsafe_sub(requested_assets, curr_total_idle)\r\n        # `assets_to_withdraw` is the amount to request from the current strategy.\r\n        assets_to_withdraw: uint256 = 0\r\n\r\n        # To compare against real withdrawals from strategies\r\n        previous_balance: uint256 = ASSET.balanceOf(self)\r\n\r\n        for strategy in _strategies:\r\n            # Make sure we have a valid strategy.\r\n            assert self.strategies[strategy].activation != 0, \"inactive strategy\"\r\n\r\n            # How much should the strategy have.\r\n            current_debt: uint256 = self.strategies[strategy].current_debt\r\n\r\n            # What is the max amount to withdraw from this strategy.\r\n            assets_to_withdraw = min(assets_needed, current_debt)\r\n\r\n            # Cache max_withdraw now for use if unrealized loss > 0\r\n            max_withdraw: uint256 = IStrategy(strategy).maxWithdraw(self)\r\n\r\n            # CHECK FOR UNREALISED LOSSES\r\n            # If unrealised losses > 0, then the user will take the proportional share \r\n            # and realize it (required to avoid users withdrawing from lossy strategies).\r\n            # NOTE: strategies need to manage the fact that realising part of the loss can \r\n            # mean the realisation of 100% of the loss!! (i.e. if for withdrawing 10% of the\r\n            # strategy it needs to unwind the whole position, generated losses might be bigger)\r\n            unrealised_losses_share: uint256 = self._assess_share_of_unrealised_losses(strategy, assets_to_withdraw)\r\n            if unrealised_losses_share > 0:\r\n                # If max withdraw is limiting the amount to pull, we need to adjust the portion of \r\n                # the unrealized loss the user should take.\r\n                if max_withdraw < assets_to_withdraw - unrealised_losses_share:\r\n                    # How much would we want to withdraw\r\n                    wanted: uint256 = assets_to_withdraw - unrealised_losses_share\r\n                    # Get the proportion of unrealised comparing what we want vs. what we can get\r\n                    unrealised_losses_share = unrealised_losses_share * max_withdraw / wanted\r\n                    # Adjust assets_to_withdraw so all future calcultations work correctly\r\n                    assets_to_withdraw = max_withdraw + unrealised_losses_share\r\n                \r\n                # User now \"needs\" less assets to be unlocked (as he took some as losses)\r\n                assets_to_withdraw -= unrealised_losses_share\r\n                requested_assets -= unrealised_losses_share\r\n                # NOTE: done here instead of waiting for regular update of these values \r\n                # because it's a rare case (so we can save minor amounts of gas)\r\n                assets_needed -= unrealised_losses_share\r\n                curr_total_debt -= unrealised_losses_share\r\n\r\n                # If max withdraw is 0 and unrealised loss is still > 0 then the strategy likely\r\n                # realized a 100% loss and we will need to realize that loss before moving on.\r\n                if max_withdraw == 0 and unrealised_losses_share > 0:\r\n                    # Adjust the strategy debt accordingly.\r\n                    new_debt: uint256 = current_debt - unrealised_losses_share\r\n        \r\n                    # Update strategies storage\r\n                    self.strategies[strategy].current_debt = new_debt\r\n                    # Log the debt update\r\n                    log DebtUpdated(strategy, current_debt, new_debt)\r\n\r\n            # Adjust based on the max withdraw of the strategy.\r\n            assets_to_withdraw = min(assets_to_withdraw, max_withdraw)\r\n\r\n            # Can't withdraw 0.\r\n            if assets_to_withdraw == 0:\r\n                continue\r\n            \r\n            # WITHDRAW FROM STRATEGY\r\n            # Need to get shares since we use redeem to be able to take on losses.\r\n            shares_to_withdraw: uint256 = min(\r\n                # Use previewWithdraw since it should round up.\r\n                IStrategy(strategy).previewWithdraw(assets_to_withdraw), \r\n                # And check against our actual balance.\r\n                IStrategy(strategy).balanceOf(self)\r\n            )\r\n            IStrategy(strategy).redeem(shares_to_withdraw, self, self)\r\n            post_balance: uint256 = ASSET.balanceOf(self)\r\n            \r\n            # Always check withdrawn against the real amounts.\r\n            withdrawn: uint256 = post_balance - previous_balance\r\n            loss: uint256 = 0\r\n            # Check if we redeemed to much.\r\n            if withdrawn > assets_to_withdraw:\r\n                # Make sure we don't underlfow in debt updates.\r\n                if withdrawn > current_debt:\r\n                    # Can't withdraw more than our debt.\r\n                    assets_to_withdraw = current_debt\r\n                else:\r\n                    # Add the extra to how much we withdrew.\r\n                    assets_to_withdraw += (unsafe_sub(withdrawn, assets_to_withdraw))\r\n\r\n            # If we have not received what we expected, we consider the difference a loss.\r\n            elif withdrawn < assets_to_withdraw:\r\n                loss = unsafe_sub(assets_to_withdraw, withdrawn)\r\n\r\n            # NOTE: strategy's debt decreases by the full amount but the total idle increases \r\n            # by the actual amount only (as the difference is considered lost).\r\n            curr_total_idle += (assets_to_withdraw - loss)\r\n            requested_assets -= loss\r\n            curr_total_debt -= assets_to_withdraw\r\n\r\n            # Vault will reduce debt because the unrealised loss has been taken by user\r\n            new_debt: uint256 = current_debt - (assets_to_withdraw + unrealised_losses_share)\r\n        \r\n            # Update strategies storage\r\n            self.strategies[strategy].current_debt = new_debt\r\n            # Log the debt update\r\n            log DebtUpdated(strategy, current_debt, new_debt)\r\n\r\n            # Break if we have enough total idle to serve initial request.\r\n            if requested_assets <= curr_total_idle:\r\n                break\r\n\r\n            # We update the previous_balance variable here to save gas in next iteration.\r\n            previous_balance = post_balance\r\n\r\n            # Reduce what we still need. Safe to use assets_to_withdraw \r\n            # here since it has been checked against requested_assets\r\n            assets_needed -= assets_to_withdraw\r\n\r\n        # If we exhaust the queue and still have insufficient total idle, revert.\r\n        assert curr_total_idle >= requested_assets, \"insufficient assets in vault\"\r\n        # Commit memory to storage.\r\n        self.total_debt = curr_total_debt\r\n\r\n    # Check if there is a loss and a non-default value was set.\r\n    if assets > requested_assets and max_loss < MAX_BPS:\r\n        # The loss is within the allowed range.\r\n        assert assets - requested_assets <= assets * max_loss / MAX_BPS, \"to much loss\"\r\n\r\n    # First burn the corresponding shares from the redeemer.\r\n    self._burn_shares(shares, owner)\r\n    # Commit memory to storage.\r\n    self.total_idle = curr_total_idle - requested_assets\r\n    # Transfer the requested amount to the receiver.\r\n    self._erc20_safe_transfer(ASSET.address, receiver, requested_assets)\r\n\r\n    log Withdraw(sender, receiver, owner, requested_assets, shares)\r\n    return requested_assets\r\n\r\n## STRATEGY MANAGEMENT ##\r\n@internal\r\ndef _add_strategy(new_strategy: address):\r\n    assert new_strategy not in [self, empty(address)], \"strategy cannot be zero address\"\r\n    assert IStrategy(new_strategy).asset() == ASSET.address, \"invalid asset\"\r\n    assert self.strategies[new_strategy].activation == 0, \"strategy already active\"\r\n\r\n    # Add the new strategy to the mapping.\r\n    self.strategies[new_strategy] = StrategyParams({\r\n        activation: block.timestamp,\r\n        last_report: block.timestamp,\r\n        current_debt: 0,\r\n        max_debt: 0\r\n    })\r\n\r\n    # If the default queue has space, add the strategy.\r\n    if len(self.default_queue) < MAX_QUEUE:\r\n        self.default_queue.append(new_strategy)        \r\n        \r\n    log StrategyChanged(new_strategy, StrategyChangeType.ADDED)\r\n\r\n@internal\r\ndef _revoke_strategy(strategy: address, force: bool=False):\r\n    assert self.strategies[strategy].activation != 0, \"strategy not active\"\r\n\r\n    # If force revoking a strategy, it will cause a loss.\r\n    loss: uint256 = 0\r\n    \r\n    if self.strategies[strategy].current_debt != 0:\r\n        assert force, \"strategy has debt\"\r\n        # Vault realizes the full loss of outstanding debt.\r\n        loss = self.strategies[strategy].current_debt\r\n        # Adjust total vault debt.\r\n        self.total_debt -= loss\r\n\r\n        log StrategyReported(strategy, 0, loss, 0, 0, 0, 0)\r\n\r\n    # Set strategy params all back to 0 (WARNING: it can be readded).\r\n    self.strategies[strategy] = StrategyParams({\r\n      activation: 0,\r\n      last_report: 0,\r\n      current_debt: 0,\r\n      max_debt: 0\r\n    })\r\n\r\n    # Remove strategy if it is in the default queue.\r\n    new_queue: DynArray[address, MAX_QUEUE] = []\r\n    for _strategy in self.default_queue:\r\n        # Add all strategies to the new queue besides the one revoked.\r\n        if _strategy != strategy:\r\n            new_queue.append(_strategy)\r\n        \r\n    # Set the default queue to our updated queue.\r\n    self.default_queue = new_queue\r\n\r\n    log StrategyChanged(strategy, StrategyChangeType.REVOKED)\r\n\r\n# DEBT MANAGEMENT #\r\n@internal\r\ndef _update_debt(strategy: address, target_debt: uint256) -> uint256:\r\n    \"\"\"\r\n    The vault will re-balance the debt vs target debt. Target debt must be\r\n    smaller or equal to strategy's max_debt. This function will compare the \r\n    current debt with the target debt and will take funds or deposit new \r\n    funds to the strategy. \r\n\r\n    The strategy can require a maximum amount of funds that it wants to receive\r\n    to invest. The strategy can also reject freeing funds if they are locked.\r\n    \"\"\"\r\n    # How much we want the strategy to have.\r\n    new_debt: uint256 = target_debt\r\n    # How much the strategy currently has.\r\n    current_debt: uint256 = self.strategies[strategy].current_debt\r\n\r\n    # If the vault is shutdown we can only pull funds.\r\n    if self.shutdown:\r\n        new_debt = 0\r\n\r\n    assert new_debt != current_debt, \"new debt equals current debt\"\r\n\r\n    if current_debt > new_debt:\r\n        # Reduce debt.\r\n        assets_to_withdraw: uint256 = unsafe_sub(current_debt, new_debt)\r\n\r\n        # Ensure we always have minimum_total_idle when updating debt.\r\n        minimum_total_idle: uint256 = self.minimum_total_idle\r\n        total_idle: uint256 = self.total_idle\r\n        \r\n        # Respect minimum total idle in vault\r\n        if total_idle + assets_to_withdraw < minimum_total_idle:\r\n            assets_to_withdraw = unsafe_sub(minimum_total_idle, total_idle)\r\n            # Cant withdraw more than the strategy has.\r\n            if assets_to_withdraw > current_debt:\r\n                assets_to_withdraw = current_debt\r\n\r\n        # Check how much we are able to withdraw.\r\n        withdrawable: uint256 = IStrategy(strategy).maxWithdraw(self)\r\n        assert withdrawable != 0, \"nothing to withdraw\"\r\n\r\n        # If insufficient withdrawable, withdraw what we can.\r\n        if withdrawable < assets_to_withdraw:\r\n            assets_to_withdraw = withdrawable\r\n\r\n        # If there are unrealised losses we don't let the vault reduce its debt until there is a new report\r\n        unrealised_losses_share: uint256 = self._assess_share_of_unrealised_losses(strategy, assets_to_withdraw)\r\n        assert unrealised_losses_share == 0, \"strategy has unrealised losses\"\r\n        \r\n        # Always check the actual amount withdrawn.\r\n        pre_balance: uint256 = ASSET.balanceOf(self)\r\n        IStrategy(strategy).withdraw(assets_to_withdraw, self, self)\r\n        post_balance: uint256 = ASSET.balanceOf(self)\r\n        \r\n        # making sure we are changing according to the real result no matter what. \r\n        # This will spend more gas but makes it more robust. Also prevents issues\r\n        # from a faulty strategy that either under or over delievers 'assets_to_withdraw'\r\n        assets_to_withdraw = min(post_balance - pre_balance, current_debt)\r\n\r\n        # Update storage.\r\n        self.total_idle += assets_to_withdraw\r\n        self.total_debt -= assets_to_withdraw\r\n  \r\n        new_debt = current_debt - assets_to_withdraw\r\n    else: \r\n        # We are increasing the strategies debt\r\n\r\n        # Revert if target_debt cannot be achieved due to configured max_debt for given strategy\r\n        assert new_debt <= self.strategies[strategy].max_debt, \"target debt higher than max debt\"\r\n\r\n        # Vault is increasing debt with the strategy by sending more funds.\r\n        max_deposit: uint256 = IStrategy(strategy).maxDeposit(self)\r\n        assert max_deposit != 0, \"nothing to deposit\"\r\n\r\n        # Deposit the difference between desired and current.\r\n        assets_to_deposit: uint256 = new_debt - current_debt\r\n        if assets_to_deposit > max_deposit:\r\n            # Deposit as much as possible.\r\n            assets_to_deposit = max_deposit\r\n        \r\n        # Ensure we always have minimum_total_idle when updating debt.\r\n        minimum_total_idle: uint256 = self.minimum_total_idle\r\n        total_idle: uint256 = self.total_idle\r\n\r\n        assert total_idle > minimum_total_idle, \"no funds to deposit\"\r\n        available_idle: uint256 = unsafe_sub(total_idle, minimum_total_idle)\r\n\r\n        # If insufficient funds to deposit, transfer only what is free.\r\n        if assets_to_deposit > available_idle:\r\n            assets_to_deposit = available_idle\r\n\r\n        # Can't Deposit 0.\r\n        if assets_to_deposit > 0:\r\n            # Approve the strategy to pull only what we are giving it.\r\n            self._erc20_safe_approve(ASSET.address, strategy, assets_to_deposit)\r\n\r\n            # Always update based on actual amounts deposited.\r\n            pre_balance: uint256 = ASSET.balanceOf(self)\r\n            IStrategy(strategy).deposit(assets_to_deposit, self)\r\n            post_balance: uint256 = ASSET.balanceOf(self)\r\n\r\n            # Make sure our approval is always back to 0.\r\n            self._erc20_safe_approve(ASSET.address, strategy, 0)\r\n\r\n            # Making sure we are changing according to the real result no \r\n            # matter what. This will spend more gas but makes it more robust.\r\n            assets_to_deposit = pre_balance - post_balance\r\n\r\n            # Update storage.\r\n            self.total_idle -= assets_to_deposit\r\n            self.total_debt += assets_to_deposit\r\n\r\n        new_debt = current_debt + assets_to_deposit\r\n\r\n    # Commit memory to storage.\r\n    self.strategies[strategy].current_debt = new_debt\r\n\r\n    log DebtUpdated(strategy, current_debt, new_debt)\r\n    return new_debt\r\n\r\n## ACCOUNTING MANAGEMENT ##\r\n@internal\r\ndef _process_report(strategy: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    Processing a report means comparing the debt that the strategy has taken \r\n    with the current amount of funds it is reporting. If the strategy owes \r\n    less than it currently has, it means it has had a profit, else (assets < debt) \r\n    it has had a loss.\r\n\r\n    Different strategies might choose different reporting strategies: pessimistic, \r\n    only realised P&L, ... The best way to report depends on the strategy.\r\n\r\n    The profit will be distributed following a smooth curve over the vaults \r\n    profit_max_unlock_time seconds. Losses will be taken immediately, first from the \r\n    profit buffer (avoiding an impact in pps), then will reduce pps.\r\n\r\n    Any applicable fees are charged and distributed during the report as well\r\n    to the specified recipients.\r\n    \"\"\"\r\n    # Make sure we have a valid strategy.\r\n    assert self.strategies[strategy].activation != 0, \"inactive strategy\"\r\n\r\n    # Burn shares that have been unlocked since the last update\r\n    self._burn_unlocked_shares()\r\n\r\n    # Vault asseses profits using 4626 compliant interface. \r\n    # NOTE: It is important that a strategies `convertToAssets` implementation\r\n    # cannot be manipulated or else the vault could report incorrect gains/losses.\r\n    strategy_shares: uint256 = IStrategy(strategy).balanceOf(self)\r\n    # How much the vaults position is worth.\r\n    total_assets: uint256 = IStrategy(strategy).convertToAssets(strategy_shares)\r\n    # How much the vault had deposited to the strategy.\r\n    current_debt: uint256 = self.strategies[strategy].current_debt\r\n\r\n    gain: uint256 = 0\r\n    loss: uint256 = 0\r\n\r\n    # Compare reported assets vs. the current debt.\r\n    if total_assets > current_debt:\r\n        # We have a gain.\r\n        gain = unsafe_sub(total_assets, current_debt)\r\n    else:\r\n        # We have a loss.\r\n        loss = unsafe_sub(current_debt, total_assets)\r\n\r\n    # For Accountant fee assessment.\r\n    total_fees: uint256 = 0\r\n    total_refunds: uint256 = 0\r\n    # For Protocol fee assessment.\r\n    protocol_fees: uint256 = 0\r\n    protocol_fee_recipient: address = empty(address)\r\n\r\n    accountant: address = self.accountant\r\n    # If accountant is not set, fees and refunds remain unchanged.\r\n    if accountant != empty(address):\r\n        total_fees, total_refunds = IAccountant(accountant).report(strategy, gain, loss)\r\n\r\n        # Protocol fees will be 0 if accountant fees are 0.\r\n        if total_fees > 0:\r\n            protocol_fee_bps: uint16 = 0\r\n            # Get the config for this vault.\r\n            protocol_fee_bps, protocol_fee_recipient = IFactory(FACTORY).protocol_fee_config()\r\n\r\n            if(protocol_fee_bps > 0):\r\n                # Protocol fees are a percent of the fees the accountant is charging.\r\n                protocol_fees = total_fees * convert(protocol_fee_bps, uint256) / MAX_BPS\r\n\r\n    # `shares_to_burn` is derived from amounts that would reduce the vaullts PPS.\r\n    # NOTE: this needs to be done before any pps changes\r\n    shares_to_burn: uint256 = 0\r\n    accountant_fees_shares: uint256 = 0\r\n    protocol_fees_shares: uint256 = 0\r\n    # Only need to burn shares if there is a loss or fees.\r\n    if loss + total_fees > 0:\r\n        # The amount of shares we will want to burn to offset losses and fees.\r\n        shares_to_burn += self._convert_to_shares(loss + total_fees, Rounding.ROUND_UP)\r\n\r\n        # Vault calculates the amount of shares to mint as fees before changing totalAssets / totalSupply.\r\n        if total_fees > 0:\r\n            # Accountant fees are total fees - protocol fees.\r\n            accountant_fees_shares = self._convert_to_shares(total_fees - protocol_fees, Rounding.ROUND_DOWN)\r\n            if protocol_fees > 0:\r\n              protocol_fees_shares = self._convert_to_shares(protocol_fees, Rounding.ROUND_DOWN)\r\n\r\n    # Shares to lock is any amounts that would otherwise increase the vaults PPS.\r\n    newly_locked_shares: uint256 = 0\r\n    if total_refunds > 0:\r\n        # Make sure we have enough approval and enough asset to pull.\r\n        total_refunds = min(total_refunds, min(ASSET.balanceOf(accountant), ASSET.allowance(accountant, self)))\r\n        # Transfer the refunded amount of asset to the vault.\r\n        self._erc20_safe_transfer_from(ASSET.address, accountant, self, total_refunds)\r\n        # Update storage to increase total assets.\r\n        self.total_idle += total_refunds\r\n        # Mint new shares corresponding to the refunded assets to self.\r\n        newly_locked_shares += self._issue_shares_for_amount(total_refunds, self)\r\n\r\n    # Record any reported gains.\r\n    if gain > 0:\r\n        # NOTE: this will increase total_assets\r\n        self.strategies[strategy].current_debt += gain\r\n        self.total_debt += gain\r\n\r\n        # Vault will issue shares worth the profit to itself to lock avoid instant pps change.\r\n        newly_locked_shares += self._issue_shares_for_amount(gain, self)\r\n\r\n    # Strategy is reporting a loss\r\n    if loss > 0:\r\n        self.strategies[strategy].current_debt -= loss\r\n        self.total_debt -= loss\r\n\r\n    # NOTE: should be precise (no new unlocked shares due to above's burn of shares)\r\n    # newly_locked_shares have already been minted / transfered to the vault, so they need to be substracted\r\n    # no risk of underflow because they have just been minted.\r\n    previously_locked_shares: uint256 = self.balance_of[self] - newly_locked_shares\r\n\r\n    # Now that pps has updated, we can burn the shares we intended to burn as a result of losses/fees.\r\n    # NOTE: If a value reduction (losses / fees) has occured, prioritize burning locked profit to avoid\r\n    # negative impact on price per share. Price per share is reduced only if losses exceed locked value.\r\n    if shares_to_burn > 0:\r\n        # Cant burn more than the vault owns.\r\n        shares_to_burn = min(shares_to_burn, previously_locked_shares + newly_locked_shares)\r\n        self._burn_shares(shares_to_burn, self)\r\n\r\n        # We burn first the newly locked shares, then the previously locked shares.\r\n        shares_not_to_lock: uint256 = min(shares_to_burn, newly_locked_shares)\r\n        # Reduce the amounts to lock by how much we burned\r\n        newly_locked_shares -= shares_not_to_lock\r\n        previously_locked_shares -= (shares_to_burn - shares_not_to_lock)\r\n\r\n    # Issue shares for fees that were calculated above if applicable.\r\n    if accountant_fees_shares > 0:\r\n        self._issue_shares(accountant_fees_shares, accountant)\r\n\r\n    if protocol_fees_shares > 0:\r\n        self._issue_shares(protocol_fees_shares, protocol_fee_recipient)\r\n\r\n    # Update unlocking rate and time to fully unlocked.\r\n    total_locked_shares: uint256 = previously_locked_shares + newly_locked_shares\r\n    if total_locked_shares > 0:\r\n        previously_locked_time: uint256 = 0\r\n        _full_profit_unlock_date: uint256 = self.full_profit_unlock_date\r\n        # Check if we need to account for shares still unlocking.\r\n        if _full_profit_unlock_date > block.timestamp: \r\n            # There will only be previously locked shares if time remains.\r\n            # We calculate this here since it will not occur every time we lock shares.\r\n            previously_locked_time = previously_locked_shares * (_full_profit_unlock_date - block.timestamp)\r\n\r\n        # new_profit_locking_period is a weighted average between the remaining time of the previously locked shares and the profit_max_unlock_time\r\n        new_profit_locking_period: uint256 = (previously_locked_time + newly_locked_shares * self.profit_max_unlock_time) / total_locked_shares\r\n        # Calculate how many shares unlock per second.\r\n        self.profit_unlocking_rate = total_locked_shares * MAX_BPS_EXTENDED / new_profit_locking_period\r\n        # Calculate how long until the full amount of shares is unlocked.\r\n        self.full_profit_unlock_date = block.timestamp + new_profit_locking_period\r\n        # Update the last profitable report timestamp.\r\n        self.last_profit_update = block.timestamp\r\n\r\n    else:\r\n        # NOTE: only setting this to 0 will turn in the desired effect, no need \r\n        # to update last_profit_update or full_profit_unlock_date\r\n        self.profit_unlocking_rate = 0\r\n\r\n    # Record the report of profit timestamp.\r\n    self.strategies[strategy].last_report = block.timestamp\r\n\r\n    # We have to recalculate the fees paid for cases with an overall loss.\r\n    log StrategyReported(\r\n        strategy,\r\n        gain,\r\n        loss,\r\n        self.strategies[strategy].current_debt,\r\n        self._convert_to_assets(protocol_fees_shares, Rounding.ROUND_DOWN),\r\n        self._convert_to_assets(protocol_fees_shares + accountant_fees_shares, Rounding.ROUND_DOWN),\r\n        total_refunds\r\n    )\r\n\r\n    return (gain, loss)\r\n\r\n# SETTERS #\r\n@external\r\ndef set_accountant(new_accountant: address):\r\n    \"\"\"\r\n    @notice Set the new accountant address.\r\n    @param new_accountant The new accountant address.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.ACCOUNTANT_MANAGER)\r\n    self.accountant = new_accountant\r\n\r\n    log UpdateAccountant(new_accountant)\r\n\r\n@external\r\ndef set_default_queue(new_default_queue: DynArray[address, MAX_QUEUE]):\r\n    \"\"\"\r\n    @notice Set the new default queue array.\r\n    @dev Will check each strategy to make sure it is active.\r\n    @param new_default_queue The new default queue array.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.QUEUE_MANAGER)\r\n\r\n    # Make sure every strategy in the new queue is active.\r\n    for strategy in new_default_queue:\r\n        assert self.strategies[strategy].activation != 0, \"!inactive\"\r\n\r\n    # Save the new queue.\r\n    self.default_queue = new_default_queue\r\n\r\n    log UpdateDefaultQueue(new_default_queue)\r\n\r\n@external\r\ndef set_deposit_limit(deposit_limit: uint256):\r\n    \"\"\"\r\n    @notice Set the new deposit limit.\r\n    @dev Can not be changed if shutdown.\r\n    @param deposit_limit The new deposit limit.\r\n    \"\"\"\r\n    assert self.shutdown == False # Dev: shutdown\r\n    self._enforce_role(msg.sender, Roles.DEPOSIT_LIMIT_MANAGER)\r\n    self.deposit_limit = deposit_limit\r\n\r\n    log UpdateDepositLimit(deposit_limit)\r\n\r\n@external\r\ndef set_minimum_total_idle(minimum_total_idle: uint256):\r\n    \"\"\"\r\n    @notice Set the new minimum total idle.\r\n    @param minimum_total_idle The new minimum total idle.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.MINIMUM_IDLE_MANAGER)\r\n    self.minimum_total_idle = minimum_total_idle\r\n\r\n    log UpdateMinimumTotalIdle(minimum_total_idle)\r\n\r\n@external\r\ndef set_profit_max_unlock_time(new_profit_max_unlock_time: uint256):\r\n    \"\"\"\r\n    @notice Set the new profit max unlock time.\r\n    @dev The time is denominated in seconds and must be more than 0\r\n        and less than 1 year. We don't need to update locking period\r\n        since the current period will use the old rate and on the next\r\n        report it will be reset with the new unlocking time.\r\n    @param new_profit_max_unlock_time The new profit max unlock time.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.PROFIT_UNLOCK_MANAGER)\r\n    \r\n    # Must be > 0 so we can unlock shares\r\n    assert new_profit_max_unlock_time > 0, \"profit unlock time too low\"\r\n    # Must be less than one year for report cycles\r\n    assert new_profit_max_unlock_time <= 31_556_952, \"profit unlock time too long\"\r\n\r\n    self.profit_max_unlock_time = new_profit_max_unlock_time\r\n\r\n    log UpdateProfitMaxUnlockTime(new_profit_max_unlock_time)\r\n\r\n# ROLE MANAGEMENT #\r\n@internal\r\ndef _enforce_role(account: address, role: Roles):\r\n    # Make sure the sender either holds the role or it has been opened.\r\n    assert role in self.roles[account] or self.open_roles[role], \"not allowed\"\r\n\r\n@external\r\ndef set_role(account: address, role: Roles):\r\n    \"\"\"\r\n    @notice Set the role of an account.\r\n    @param account The account to set the role for.\r\n    @param role The role to set.\r\n    \"\"\"\r\n    assert msg.sender == self.role_manager\r\n    self.roles[account] = role\r\n\r\n    log RoleSet(account, role)\r\n\r\n@external\r\ndef set_open_role(role: Roles):\r\n    \"\"\"\r\n    @notice Set a role to be open.\r\n    @param role The role to set.\r\n    \"\"\"\r\n    assert msg.sender == self.role_manager\r\n    self.open_roles[role] = True\r\n\r\n    log RoleStatusChanged(role, RoleStatusChange.OPENED)\r\n\r\n@external\r\ndef close_open_role(role: Roles):\r\n    \"\"\"\r\n    @notice Close a opened role.\r\n    @param role The role to close.\r\n    \"\"\"\r\n    assert msg.sender == self.role_manager\r\n    self.open_roles[role] = False\r\n\r\n    log RoleStatusChanged(role, RoleStatusChange.CLOSED)\r\n    \r\n@external\r\ndef transfer_role_manager(role_manager: address):\r\n    \"\"\"\r\n    @notice Step 1 of 2 in order to transfer the \r\n        role manager to a new address. This will set\r\n        the future_role_manager. Which will then need\r\n        to be accepted by the new manager.\r\n    @param role_manager The new role manager address.\r\n    \"\"\"\r\n    assert msg.sender == self.role_manager\r\n    self.future_role_manager = role_manager\r\n\r\n@external\r\ndef accept_role_manager():\r\n    \"\"\"\r\n    @notice Accept the role manager transfer.\r\n    \"\"\"\r\n    assert msg.sender == self.future_role_manager\r\n    self.role_manager = msg.sender\r\n    self.future_role_manager = empty(address)\r\n\r\n    log UpdateRoleManager(msg.sender)\r\n\r\n# VAULT STATUS VIEWS\r\n@view\r\n@external\r\ndef unlocked_shares() -> uint256:\r\n    \"\"\"\r\n    @notice Get the amount of shares that have been unlocked.\r\n    @return The amount of shares that are have been unlocked.\r\n    \"\"\"\r\n    return self._unlocked_shares()\r\n\r\n@view\r\n@external\r\ndef pricePerShare() -> uint256:\r\n    \"\"\"\r\n    @notice Get the price per share (pps) of the vault.\r\n    @dev This value offers limited precision. Integrations that require \r\n        exact precision should use convertToAssets or convertToShares instead.\r\n    @return The price per share.\r\n    \"\"\"\r\n    return self._convert_to_assets(10 ** DECIMALS, Rounding.ROUND_DOWN)\r\n\r\n@view\r\n@external\r\ndef availableDepositLimit() -> uint256:\r\n    \"\"\"\r\n    @notice Get the available deposit limit.\r\n    @return The available deposit limit.\r\n    \"\"\"\r\n    limit: uint256 = self.deposit_limit\r\n    assets: uint256 = self._total_assets()\r\n    if limit > assets:\r\n        return unsafe_sub(limit, assets)\r\n    return 0\r\n\r\n@view\r\n@external\r\ndef get_default_queue() -> DynArray[address, 10]:\r\n    \"\"\"\r\n    @notice Get the full default queue currently set.\r\n    @return The current default withdrawal queue.\r\n    \"\"\"\r\n    return self.default_queue\r\n\r\n## REPORTING MANAGEMENT ##\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef process_report(strategy: address) -> (uint256, uint256):\r\n    \"\"\"\r\n    @notice Process the report of a strategy.\r\n    @param strategy The strategy to process the report for.\r\n    @return The gain and loss of the strategy.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.REPORTING_MANAGER)\r\n    return self._process_report(strategy)\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef buy_debt(strategy: address, amount: uint256):\r\n    \"\"\"\r\n    @notice Used for governance to buy bad debt from the vault.\r\n    @dev This should only ever be used in an emergency in place\r\n    of force revoking a strategy in order to not report a loss.\r\n    It allows the DEBT_PURCHASER role to buy the strategies debt\r\n    for an equal amount of `asset`. It's important to note that \r\n    this does rely on the strategies `convertToShares` function to\r\n    determine the amount of shares to buy.\r\n    @param strategy The strategy to buy the debt for\r\n    @param amount The amount of debt to buy from the vault.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.DEBT_PURCHASER)\r\n    assert self.strategies[strategy].activation != 0, \"not active\"\r\n    \r\n    # Cache the current debt.\r\n    current_debt: uint256 = self.strategies[strategy].current_debt\r\n    \r\n    assert current_debt > 0, \"nothing to buy\"\r\n    assert amount > 0, \"nothing to buy with\"\r\n\r\n    # Get the current shares value for the amount.\r\n    shares: uint256 = IStrategy(strategy).convertToShares(amount)\r\n\r\n    assert shares > 0, \"can't buy 0\"\r\n    assert shares <= IStrategy(strategy).balanceOf(self), \"not enough shares\"\r\n\r\n    self._erc20_safe_transfer_from(ASSET.address, msg.sender, self, amount)\r\n\r\n    # Adjust if needed to not underflow on math\r\n    bought: uint256 = min(current_debt, amount)\r\n\r\n    # Lower strategy debt\r\n    self.strategies[strategy].current_debt -= bought\r\n    # lower total debt\r\n    self.total_debt -= bought\r\n    # Increase total idle\r\n    self.total_idle += bought\r\n\r\n    # log debt change\r\n    log DebtUpdated(strategy, current_debt, current_debt - bought)\r\n\r\n    # Transfer the strategies shares out.\r\n    self._erc20_safe_transfer(strategy, msg.sender, shares)\r\n\r\n    log DebtPurchased(strategy, bought)\r\n\r\n## STRATEGY MANAGEMENT ##\r\n@external\r\ndef add_strategy(new_strategy: address):\r\n    \"\"\"\r\n    @notice Add a new strategy.\r\n    @param new_strategy The new strategy to add.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.ADD_STRATEGY_MANAGER)\r\n    self._add_strategy(new_strategy)\r\n\r\n@external\r\ndef revoke_strategy(strategy: address):\r\n    \"\"\"\r\n    @notice Revoke a strategy.\r\n    @param strategy The strategy to revoke.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.REVOKE_STRATEGY_MANAGER)\r\n    self._revoke_strategy(strategy)\r\n\r\n@external\r\ndef force_revoke_strategy(strategy: address):\r\n    \"\"\"\r\n    @notice Force revoke a strategy.\r\n    @dev The vault will remove the strategy and write off any debt left \r\n        in it as a loss. This function is a dangerous function as it can force a \r\n        strategy to take a loss. All possible assets should be removed from the \r\n        strategy first via update_debt. If a strategy is removed erroneously it \r\n        can be re-added and the loss will be credited as profit. Fees will apply.\r\n    @param strategy The strategy to force revoke.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.FORCE_REVOKE_MANAGER)\r\n    self._revoke_strategy(strategy, True)\r\n\r\n## DEBT MANAGEMENT ##\r\n@external\r\ndef update_max_debt_for_strategy(strategy: address, new_max_debt: uint256):\r\n    \"\"\"\r\n    @notice Update the max debt for a strategy.\r\n    @param strategy The strategy to update the max debt for.\r\n    @param new_max_debt The new max debt for the strategy.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.MAX_DEBT_MANAGER)\r\n    assert self.strategies[strategy].activation != 0, \"inactive strategy\"\r\n    self.strategies[strategy].max_debt = new_max_debt\r\n\r\n    log UpdatedMaxDebtForStrategy(msg.sender, strategy, new_max_debt)\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef update_debt(strategy: address, target_debt: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Update the debt for a strategy.\r\n    @param strategy The strategy to update the debt for.\r\n    @param target_debt The target debt for the strategy.\r\n    @return The amount of debt added or removed.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.DEBT_MANAGER)\r\n    return self._update_debt(strategy, target_debt)\r\n\r\n## EMERGENCY MANAGEMENT ##\r\n@external\r\ndef shutdown_vault():\r\n    \"\"\"\r\n    @notice Shutdown the vault.\r\n    \"\"\"\r\n    self._enforce_role(msg.sender, Roles.EMERGENCY_MANAGER)\r\n    assert self.shutdown == False\r\n    \r\n    # Shutdown the vault.\r\n    self.shutdown = True\r\n\r\n    # Set deposit limit to 0.\r\n    self.deposit_limit = 0\r\n    log UpdateDepositLimit(0)\r\n\r\n    self.roles[msg.sender] = self.roles[msg.sender] | Roles.DEBT_MANAGER\r\n    log Shutdown()\r\n\r\n\r\n## SHARE MANAGEMENT ##\r\n## ERC20 + ERC4626 ##\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef deposit(assets: uint256, receiver: address) -> uint256:\r\n    \"\"\"\r\n    @notice Deposit assets into the vault.\r\n    @param assets The amount of assets to deposit.\r\n    @param receiver The address to receive the shares.\r\n    @return The amount of shares minted.\r\n    \"\"\"\r\n    return self._deposit(msg.sender, receiver, assets)\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef mint(shares: uint256, receiver: address) -> uint256:\r\n    \"\"\"\r\n    @notice Mint shares for the receiver.\r\n    @param shares The amount of shares to mint.\r\n    @param receiver The address to receive the shares.\r\n    @return The amount of assets deposited.\r\n    \"\"\"\r\n    return self._mint(msg.sender, receiver, shares)\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef withdraw(\r\n    assets: uint256, \r\n    receiver: address, \r\n    owner: address, \r\n    max_loss: uint256 = 0,\r\n    strategies: DynArray[address, MAX_QUEUE] = []\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Withdraw an amount of asset to `receiver` burning `owner`s shares.\r\n    @dev The default behavior is to not allow any loss.\r\n    @param assets The amount of asset to withdraw.\r\n    @param receiver The address to receive the assets.\r\n    @param owner The address who's shares are being burnt.\r\n    @param max_loss Optional amount of acceptable loss in Basis Points.\r\n    @param strategies Optional array of strategies to withdraw from.\r\n    @return The amount of shares actually burnt.\r\n    \"\"\"\r\n    shares: uint256 = self._convert_to_shares(assets, Rounding.ROUND_UP)\r\n    self._redeem(msg.sender, receiver, owner, assets, shares, max_loss, strategies)\r\n    return shares\r\n\r\n@external\r\n@nonreentrant(\"lock\")\r\ndef redeem(\r\n    shares: uint256, \r\n    receiver: address, \r\n    owner: address, \r\n    max_loss: uint256 = MAX_BPS,\r\n    strategies: DynArray[address, MAX_QUEUE] = []\r\n) -> uint256:\r\n    \"\"\"\r\n    @notice Redeems an amount of shares of `owners` shares sending funds to `receiver`.\r\n    @dev The default behavior is to allow losses to be realized.\r\n    @param shares The amount of shares to burn.\r\n    @param receiver The address to receive the assets.\r\n    @param owner The address who's shares are being burnt.\r\n    @param max_loss Optional amount of acceptable loss in Basis Points.\r\n    @param strategies Optional array of strategies to withdraw from.\r\n    @return The amount of assets actually withdrawn.\r\n    \"\"\"\r\n    assets: uint256 = self._convert_to_assets(shares, Rounding.ROUND_DOWN)\r\n    # Always return the actual amount of assets withdrawn.\r\n    return self._redeem(msg.sender, receiver, owner, assets, shares, max_loss, strategies)\r\n\r\n\r\n@external\r\ndef approve(spender: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Approve an address to spend the vault's shares.\r\n    @param spender The address to approve.\r\n    @param amount The amount of shares to approve.\r\n    @return True if the approval was successful.\r\n    \"\"\"\r\n    return self._approve(msg.sender, spender, amount)\r\n\r\n@external\r\ndef transfer(receiver: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer shares to a receiver.\r\n    @param receiver The address to transfer shares to.\r\n    @param amount The amount of shares to transfer.\r\n    @return True if the transfer was successful.\r\n    \"\"\"\r\n    assert receiver not in [self, empty(address)]\r\n    self._transfer(msg.sender, receiver, amount)\r\n    return True\r\n\r\n@external\r\ndef transferFrom(sender: address, receiver: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Transfer shares from a sender to a receiver.\r\n    @param sender The address to transfer shares from.\r\n    @param receiver The address to transfer shares to.\r\n    @param amount The amount of shares to transfer.\r\n    @return True if the transfer was successful.\r\n    \"\"\"\r\n    assert receiver not in [self, empty(address)]\r\n    return self._transfer_from(sender, receiver, amount)\r\n\r\n## ERC20+4626 compatibility\r\n@external\r\ndef increaseAllowance(spender: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Increase the allowance for a spender.\r\n    @param spender The address to increase the allowance for.\r\n    @param amount The amount to increase the allowance by.\r\n    @return True if the increase was successful.\r\n    \"\"\"\r\n    return self._increase_allowance(msg.sender, spender, amount)\r\n\r\n@external\r\ndef decreaseAllowance(spender: address, amount: uint256) -> bool:\r\n    \"\"\"\r\n    @notice Decrease the allowance for a spender.\r\n    @param spender The address to decrease the allowance for.\r\n    @param amount The amount to decrease the allowance by.\r\n    @return True if the decrease was successful.\r\n    \"\"\"\r\n    return self._decrease_allowance(msg.sender, spender, amount)\r\n\r\n@external\r\ndef permit(\r\n    owner: address, \r\n    spender: address, \r\n    amount: uint256, \r\n    deadline: uint256, \r\n    v: uint8, \r\n    r: bytes32, \r\n    s: bytes32\r\n) -> bool:\r\n    \"\"\"\r\n    @notice Approve an address to spend the vault's shares.\r\n    @param owner The address to approve.\r\n    @param spender The address to approve.\r\n    @param amount The amount of shares to approve.\r\n    @param deadline The deadline for the permit.\r\n    @param v The v component of the signature.\r\n    @param r The r component of the signature.\r\n    @param s The s component of the signature.\r\n    @return True if the approval was successful.\r\n    \"\"\"\r\n    return self._permit(owner, spender, amount, deadline, v, r, s)\r\n\r\n@view\r\n@external\r\ndef balanceOf(addr: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the balance of a user.\r\n    @param addr The address to get the balance of.\r\n    @return The balance of the user.\r\n    \"\"\"\r\n    if(addr == self):\r\n        # If the address is the vault, account for locked shares.\r\n        return self.balance_of[addr] - self._unlocked_shares()\r\n\r\n    return self.balance_of[addr]\r\n\r\n@view\r\n@external\r\ndef totalSupply() -> uint256:\r\n    \"\"\"\r\n    @notice Get the total supply of shares.\r\n    @return The total supply of shares.\r\n    \"\"\"\r\n    return self._total_supply()\r\n\r\n@view\r\n@external\r\ndef asset() -> address:\r\n    \"\"\"\r\n    @notice Get the address of the asset.\r\n    @return The address of the asset.\r\n    \"\"\"\r\n    return ASSET.address\r\n\r\n@view\r\n@external\r\ndef decimals() -> uint8:\r\n    \"\"\"\r\n    @notice Get the number of decimals of the asset/share.\r\n    @return The number of decimals of the asset/share.\r\n    \"\"\"\r\n    return convert(DECIMALS, uint8)\r\n\r\n@view\r\n@external\r\ndef totalAssets() -> uint256:\r\n    \"\"\"\r\n    @notice Get the total assets held by the vault.\r\n    @return The total assets held by the vault.\r\n    \"\"\"\r\n    return self._total_assets()\r\n\r\n@view\r\n@external\r\ndef totalIdle() -> uint256:\r\n    \"\"\"\r\n    @notice Get the amount of loose `asset` the vault holds.\r\n    @return The current total idle.\r\n    \"\"\"\r\n    return self.total_idle\r\n\r\n@view\r\n@external\r\ndef totalDebt() -> uint256:\r\n    \"\"\"\r\n    @notice Get the the total amount of funds invested\r\n    across all strategies.\r\n    @return The current total debt.\r\n    \"\"\"\r\n    return self.total_debt\r\n\r\n@view\r\n@external\r\ndef convertToShares(assets: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Convert an amount of assets to shares.\r\n    @param assets The amount of assets to convert.\r\n    @return The amount of shares.\r\n    \"\"\"\r\n    return self._convert_to_shares(assets, Rounding.ROUND_DOWN)\r\n\r\n@view\r\n@external\r\ndef previewDeposit(assets: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Preview the amount of shares that would be minted for a deposit.\r\n    @param assets The amount of assets to deposit.\r\n    @return The amount of shares that would be minted.\r\n    \"\"\"\r\n    return self._convert_to_shares(assets, Rounding.ROUND_DOWN)\r\n\r\n@view\r\n@external\r\ndef previewMint(shares: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Preview the amount of assets that would be deposited for a mint.\r\n    @param shares The amount of shares to mint.\r\n    @return The amount of assets that would be deposited.\r\n    \"\"\"\r\n    return self._convert_to_assets(shares, Rounding.ROUND_UP)\r\n\r\n@view\r\n@external\r\ndef convertToAssets(shares: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Convert an amount of shares to assets.\r\n    @param shares The amount of shares to convert.\r\n    @return The amount of assets.\r\n    \"\"\"\r\n    return self._convert_to_assets(shares, Rounding.ROUND_DOWN)\r\n\r\n@view\r\n@external\r\ndef maxDeposit(receiver: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the maximum amount of assets that can be deposited.\r\n    @param receiver The address that will receive the shares.\r\n    @return The maximum amount of assets that can be deposited.\r\n    \"\"\"\r\n    return self._max_deposit(receiver)\r\n\r\n@view\r\n@external\r\ndef maxMint(receiver: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the maximum amount of shares that can be minted.\r\n    @param receiver The address that will receive the shares.\r\n    @return The maximum amount of shares that can be minted.\r\n    \"\"\"\r\n    max_deposit: uint256 = self._max_deposit(receiver)\r\n    return self._convert_to_shares(max_deposit, Rounding.ROUND_DOWN)\r\n\r\n@view\r\n@external\r\ndef maxWithdraw(owner: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the maximum amount of assets that can be withdrawn.\r\n    @param owner The address that owns the shares.\r\n    @return The maximum amount of assets that can be withdrawn.\r\n    \"\"\"\r\n    return self._max_withdraw(owner)\r\n\r\n@view\r\n@external\r\ndef maxRedeem(owner: address) -> uint256:\r\n    \"\"\"\r\n    @notice Get the maximum amount of shares that can be redeemed.\r\n    @param owner The address that owns the shares.\r\n    @return The maximum amount of shares that can be redeemed.\r\n    \"\"\"\r\n    return self._max_redeem(owner)\r\n\r\n@view\r\n@external\r\ndef previewWithdraw(assets: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Preview the amount of shares that would be redeemed for a withdraw.\r\n    @param assets The amount of assets to withdraw.\r\n    @return The amount of shares that would be redeemed.\r\n    \"\"\"\r\n    return self._convert_to_shares(assets, Rounding.ROUND_UP)\r\n\r\n@view\r\n@external\r\ndef previewRedeem(shares: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Preview the amount of assets that would be withdrawn for a redeem.\r\n    @param shares The amount of shares to redeem.\r\n    @return The amount of assets that would be withdrawn.\r\n    \"\"\"\r\n    return self._convert_to_assets(shares, Rounding.ROUND_DOWN)\r\n\r\n@view\r\n@external\r\ndef api_version() -> String[28]:\r\n    \"\"\"\r\n    @notice Get the API version of the vault.\r\n    @return The API version of the vault.\r\n    \"\"\"\r\n    return API_VERSION\r\n\r\n@view\r\n@external\r\ndef assess_share_of_unrealised_losses(strategy: address, assets_needed: uint256) -> uint256:\r\n    \"\"\"\r\n    @notice Assess the share of unrealised losses that a strategy has.\r\n    @param strategy The address of the strategy.\r\n    @param assets_needed The amount of assets needed to be withdrawn.\r\n    @return The share of unrealised losses that the strategy has.\r\n    \"\"\"\r\n    assert self.strategies[strategy].current_debt >= assets_needed\r\n\r\n    return self._assess_share_of_unrealised_losses(strategy, assets_needed)\r\n\r\n## Profit locking getter functions ##\r\n\r\n@view\r\n@external\r\ndef profitMaxUnlockTime() -> uint256:\r\n    \"\"\"\r\n    @notice Gets the current time profits are set to unlock over.\r\n    @return The current profit max unlock time.\r\n    \"\"\"\r\n    return self.profit_max_unlock_time\r\n\r\n@view\r\n@external\r\ndef fullProfitUnlockDate() -> uint256:\r\n    \"\"\"\r\n    @notice Gets the timestamp at which all profits will be unlocked.\r\n    @return The full profit unlocking timestamp\r\n    \"\"\"\r\n    return self.full_profit_unlock_date\r\n\r\n@view\r\n@external\r\ndef profitUnlockingRate() -> uint256:\r\n    \"\"\"\r\n    @notice The per second rate at which profits are unlocking.\r\n    @dev This is denominated in EXTENDED_BPS decimals.\r\n    @return The current profit unlocking rate.\r\n    \"\"\"\r\n    return self.profit_unlocking_rate\r\n\r\n\r\n@view\r\n@external\r\ndef lastProfitUpdate() -> uint256:\r\n    \"\"\"\r\n    @notice The timestamp of the last time shares were locked.\r\n    @return The last profit update.\r\n    \"\"\"\r\n    return self.last_profit_update\r\n\r\n# eip-1344\r\n@view\r\n@internal\r\ndef domain_separator() -> bytes32:\r\n    return keccak256(\r\n        concat(\r\n            DOMAIN_TYPE_HASH,\r\n            keccak256(convert(\"Yearn Vault\", Bytes[11])),\r\n            keccak256(convert(API_VERSION, Bytes[28])),\r\n            convert(chain.id, bytes32),\r\n            convert(self, bytes32)\r\n        )\r\n    )\r\n\r\n@view\r\n@external\r\ndef DOMAIN_SEPARATOR() -> bytes32:\r\n    \"\"\"\r\n    @notice Get the domain separator.\r\n    @return The domain separator.\r\n    \"\"\"\r\n    return self.domain_separator()", "ABI": "[{\"name\":\"Deposit\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"assets\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"shares\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Withdraw\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"assets\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"shares\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Transfer\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"receiver\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Approval\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\",\"indexed\":true},{\"name\":\"spender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"value\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StrategyChanged\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"change_type\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"StrategyReported\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"gain\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"loss\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"current_debt\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"protocol_fees\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"total_fees\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"total_refunds\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DebtUpdated\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"current_debt\",\"type\":\"uint256\",\"indexed\":false},{\"name\":\"new_debt\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RoleSet\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\",\"indexed\":true},{\"name\":\"role\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"RoleStatusChanged\",\"inputs\":[{\"name\":\"role\",\"type\":\"uint256\",\"indexed\":true},{\"name\":\"status\",\"type\":\"uint256\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateRoleManager\",\"inputs\":[{\"name\":\"role_manager\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateAccountant\",\"inputs\":[{\"name\":\"accountant\",\"type\":\"address\",\"indexed\":true}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateDefaultQueue\",\"inputs\":[{\"name\":\"new_default_queue\",\"type\":\"address[]\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdatedMaxDebtForStrategy\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\",\"indexed\":true},{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"new_debt\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateDepositLimit\",\"inputs\":[{\"name\":\"deposit_limit\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateMinimumTotalIdle\",\"inputs\":[{\"name\":\"minimum_total_idle\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"UpdateProfitMaxUnlockTime\",\"inputs\":[{\"name\":\"profit_max_unlock_time\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"DebtPurchased\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\",\"indexed\":true},{\"name\":\"amount\",\"type\":\"uint256\",\"indexed\":false}],\"anonymous\":false,\"type\":\"event\"},{\"name\":\"Shutdown\",\"inputs\":[],\"anonymous\":false,\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"constructor\",\"inputs\":[{\"name\":\"asset\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"role_manager\",\"type\":\"address\"},{\"name\":\"profit_max_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_accountant\",\"inputs\":[{\"name\":\"new_accountant\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_default_queue\",\"inputs\":[{\"name\":\"new_default_queue\",\"type\":\"address[]\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_deposit_limit\",\"inputs\":[{\"name\":\"deposit_limit\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_minimum_total_idle\",\"inputs\":[{\"name\":\"minimum_total_idle\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_profit_max_unlock_time\",\"inputs\":[{\"name\":\"new_profit_max_unlock_time\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_role\",\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"role\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"set_open_role\",\"inputs\":[{\"name\":\"role\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"close_open_role\",\"inputs\":[{\"name\":\"role\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer_role_manager\",\"inputs\":[{\"name\":\"role_manager\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"accept_role_manager\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"unlocked_shares\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"pricePerShare\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"availableDepositLimit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"get_default_queue\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"process_report\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"buy_debt\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"add_strategy\",\"inputs\":[{\"name\":\"new_strategy\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"revoke_strategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"force_revoke_strategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_max_debt_for_strategy\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"},{\"name\":\"new_max_debt\",\"type\":\"uint256\"}],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"update_debt\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"},{\"name\":\"target_debt\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"shutdown_vault\",\"inputs\":[],\"outputs\":[]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"deposit\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"mint\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"max_loss\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"withdraw\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"max_loss\",\"type\":\"uint256\"},{\"name\":\"strategies\",\"type\":\"address[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"max_loss\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"redeem\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"max_loss\",\"type\":\"uint256\"},{\"name\":\"strategies\",\"type\":\"address[]\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"approve\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transfer\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"transferFrom\",\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"increaseAllowance\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"decreaseAllowance\",\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"nonpayable\",\"type\":\"function\",\"name\":\"permit\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"deadline\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"balanceOf\",\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalSupply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"asset\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"decimals\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalAssets\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalIdle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"totalDebt\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"convertToShares\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previewDeposit\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previewMint\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"convertToAssets\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxDeposit\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxMint\",\"inputs\":[{\"name\":\"receiver\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxWithdraw\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"maxRedeem\",\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previewWithdraw\",\"inputs\":[{\"name\":\"assets\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"previewRedeem\",\"inputs\":[{\"name\":\"shares\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"api_version\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"assess_share_of_unrealised_losses\",\"inputs\":[{\"name\":\"strategy\",\"type\":\"address\"},{\"name\":\"assets_needed\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"profitMaxUnlockTime\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"fullProfitUnlockDate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"profitUnlockingRate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"lastProfitUpdate\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"DOMAIN_SEPARATOR\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"FACTORY\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"strategies\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"tuple\",\"components\":[{\"name\":\"activation\",\"type\":\"uint256\"},{\"name\":\"last_report\",\"type\":\"uint256\"},{\"name\":\"current_debt\",\"type\":\"uint256\"},{\"name\":\"max_debt\",\"type\":\"uint256\"}]}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"default_queue\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"allowance\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"},{\"name\":\"arg1\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"total_supply\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"minimum_total_idle\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"deposit_limit\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"accountant\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"roles\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"open_roles\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"uint256\"}],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"role_manager\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"future_role_manager\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"address\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"shutdown\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"name\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"symbol\",\"inputs\":[],\"outputs\":[{\"name\":\"\",\"type\":\"string\"}]},{\"stateMutability\":\"view\",\"type\":\"function\",\"name\":\"nonces\",\"inputs\":[{\"name\":\"arg0\",\"type\":\"address\"}],\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}]}]", "ContractName": "Yearn V3 Vault", "CompilerVersion": "vyper:0.3.7", "OptimizationUsed": "0", "Runs": "0", "ConstructorArguments": "0000000000000000000000002791bca1f2de4661ed88a30c99a7a9449aa8417400000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000b865aaf1f9f60630934739595f183c4900f65ed9000000000000000000000000000000000000000000000000000000000003f480000000000000000000000000000000000000000000000000000000000000000b5553444320795661756c7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000067976555344430000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU AGPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": ""}