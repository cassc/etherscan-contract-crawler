{"SourceCode": "pragma solidity ^0.8.0;\r\n\r\n\r\ninterface IReceiver {\r\n    function onERC721Received(address, address, uint, bytes calldata) external returns (bytes4);\r\n}\r\n\r\nlibrary Utils {\r\n    function toString(uint256 value) internal pure returns (string memory str) {\r\n        assembly {\r\n            str := add(mload(0x40), 0x80)\r\n            mstore(0x40, add(str, 0x20))\r\n            mstore(str, 0)\r\n            let end := str\r\n            let w := not(0)\r\n            for {\r\n                let temp := value\r\n            } 1 {\r\n\r\n            } {\r\n                str := add(str, w)\r\n                mstore8(str, add(48, mod(temp, 10)))\r\n                temp := div(temp, 10)\r\n                if iszero(temp) {\r\n                    break\r\n                }\r\n            }\r\n\r\n            let length := sub(end, str)\r\n            str := sub(str, 0x20)\r\n            mstore(str, length)\r\n        }\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\ncontract ERC721 {\r\n    event Transfer(address indexed, address indexed, uint256 indexed);\r\n    event Approval(address indexed, address indexed, uint256 indexed);\r\n\r\n    mapping(uint256 => address) internal _ownerOf;\r\n    mapping(address => uint256) internal _balanceOf;\r\n    mapping(uint256 => address) internal _approvals;\r\n    mapping(address => mapping(address => bool)) internal _isApprovedForAll;\r\n    mapping(address => uint256[]) internal _history;\r\n\r\n    function ownerOf(uint256 id) public view returns (address) {\r\n        return _ownerOf[id];\r\n    }\r\n\r\n    function balanceOf(address owner) public view returns (uint256) {\r\n        require(owner != address(0), \"ERC721: owner = zero address\");\r\n        return _balanceOf[owner];\r\n    }\r\n\r\n    function getApproved(uint256 id) public view returns (address) {\r\n        require(_ownerOf[id] != address(0), \"ERC721: token doesn't exist\");\r\n        return _approvals[id];\r\n    }\r\n\r\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\r\n        return _isApprovedForAll[owner][operator];\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool result) {\r\n        return interfaceId == 0x01ffc9a7 || interfaceId == 0x80ac58cd || interfaceId == 0x5b5e139f;\r\n    }\r\n\r\n    function historyCount(address owner) public view returns (uint256) {\r\n        return _history[owner].length;\r\n    }\r\n\r\n    function historyAt(address owner, uint256 index) public view returns (uint256) {\r\n        return _history[owner][index];\r\n    }\r\n\r\n    function approve(address spender, uint256 id) public {\r\n        address owner = _ownerOf[id];\r\n        require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], \"ERC721: not authorized\");\r\n        _approvals[id] = spender;\r\n        emit Approval(owner, spender, id);\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public {\r\n        _isApprovedForAll[msg.sender][operator] = approved;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 id) public {\r\n        require(from == _ownerOf[id], \"ERC721: from != owner\");\r\n        require(to != address(0), \"ERC721: transfer to zero address\");\r\n\r\n        require(_isApprovedOrOwner(from, msg.sender, id), \"ERC721: not authorized\");\r\n\r\n        _balanceOf[from]--;\r\n        _balanceOf[to]++;\r\n        _ownerOf[id] = to;\r\n        _history[to].push(id);\r\n\r\n        delete _approvals[id];\r\n\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id) public {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 || IReceiver(to).onERC721Received(msg.sender, from, id, \"\") == 0x150b7a02,\r\n            \"ERC721: unsafe recipient\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(address from, address to, uint256 id, bytes calldata data) public {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 || IReceiver(to).onERC721Received(msg.sender, from, id, data) == 0x150b7a02,\r\n            \"ERC721: unsafe recipient\"\r\n        );\r\n    }\r\n\r\n    function _isApprovedOrOwner(address owner, address spender, uint256 id) internal view returns (bool) {\r\n        return (spender == owner || _isApprovedForAll[owner][spender] || spender == _approvals[id]);\r\n    }\r\n\r\n    function _mint(address to, uint256 id) internal {\r\n        require(to != address(0), \"ERC721: mint to zero address\");\r\n        require(_ownerOf[id] == address(0), \"ERC721: already minted\");\r\n\r\n        _balanceOf[to]++;\r\n        _ownerOf[id] = to;\r\n        _history[to].push(id);\r\n\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    function _burn(uint256 id) internal {\r\n        address owner = _ownerOf[id];\r\n        require(owner != address(0), \"ERC721: not minted\");\r\n\r\n        _balanceOf[owner]--;\r\n         \r\n        delete _ownerOf[id];\r\n        delete _approvals[id];\r\n\r\n        emit Transfer(owner, address(0), id);\r\n    }\r\n}\r\n\r\ninterface IERC20 {\r\n    function transfer(address, uint256) external returns (bool);\r\n}\r\n\r\ncontract CryptoRobots is ERC721 {\r\n    struct Token {\r\n        uint80 cost;\r\n        uint32 claimTimestamp;\r\n        uint32 chargeTimestamp;\r\n        uint32 createTimestamp;\r\n        uint8 numberOfCharges;\r\n        uint8 numberOfDays;\r\n        bool boosted;\r\n    }\r\n\r\n    struct User {\r\n        address partner;\r\n        uint16 partners;\r\n        uint80 earnings;\r\n    }\r\n\r\n    mapping(uint256 => Token) public tokens;\r\n    mapping(address => User) public users;\r\n\r\n    string public name = \"CryptoRobots\";\r\n    string public symbol = \"ROBOT\";\r\n    address public constant manager = 0x92f95285d7F3f373a695Afa86337EA639e4EF920;\r\n    uint256 public tokenIdTracker;\r\n    uint256 public tokensBurned;\r\n    uint256 public volume;\r\n\r\n    modifier checkToken(uint256 tokenId) {\r\n        require(msg.sender == ownerOf(tokenId), \"CryptoRobots: access denied\");\r\n        _;\r\n    }\r\n\r\n    function safeMint(uint8 numberOfDays, bool boosted, address partner) public payable {\r\n        require(\r\n            numberOfDays >= 60 && numberOfDays <= 120 && numberOfDays % 10 == 0,\r\n            \"CryptoRobots: days should be 60 to 120\"\r\n        );\r\n        require(msg.value >= 1 ether, \"CryptoRobots: minimum deposit 1 MATIC\");\r\n        require(msg.value <= 1e6 ether, \"CryptoRobots: maximum deposit 1,000,000 MATIC\");\r\n\r\n        volume += msg.value;\r\n        uint256 tokenId = tokenIdTracker + 1;\r\n        tokenIdTracker = tokenId;\r\n\r\n        tokens[tokenId] = Token(\r\n            uint80(msg.value),\r\n            uint32(block.timestamp),\r\n            uint32(block.timestamp),\r\n            uint32(block.timestamp),\r\n            0,\r\n            numberOfDays,\r\n            boosted\r\n        );\r\n\r\n        _mint(msg.sender, tokenId);\r\n\r\n        uint256 share = (msg.value * 5) / 100;\r\n\r\n        if (users[msg.sender].partner == address(0)) {\r\n            partner = partner == address(0) || partner == msg.sender ? manager : partner;\r\n            users[msg.sender].partner = partner;\r\n            users[partner].partners += 1;\r\n        } else {\r\n            partner = users[msg.sender].partner;\r\n        }\r\n        users[partner].earnings += uint80(share);\r\n\r\n        payable(partner).transfer(share);\r\n        payable(manager).transfer(share);\r\n    }\r\n\r\n    function charge(uint256 tokenId) public checkToken(tokenId) {\r\n        uint256 lastChargeDay = _chargeTimestampOf(tokenId) / 86400;\r\n        uint256 expirationTimestamp = _expirationTimestampOf(tokenId);\r\n\r\n        require(block.timestamp / 86400 > lastChargeDay, \"CryptoRobots: the robot was charging today\");\r\n        require(block.timestamp < expirationTimestamp, \"CryptoRobots: expired\");\r\n\r\n        tokens[tokenId].chargeTimestamp = uint32(block.timestamp);\r\n        tokens[tokenId].numberOfCharges += 1;\r\n    }\r\n\r\n    function claim(uint256 tokenId) public checkToken(tokenId) {\r\n        uint256 expirationTimestamp = _expirationTimestampOf(tokenId);\r\n        uint256 claimTimestamp = _claimTimestampOf(tokenId);\r\n\r\n        require(claimTimestamp / 3600 < expirationTimestamp / 3600, \"CryptoRobots: expired\");\r\n\r\n        uint256 profitPerHour = _profitPerHourOf(tokenId);\r\n        uint256 hoursPassed = Utils.min(block.timestamp, expirationTimestamp) / 3600 - claimTimestamp / 3600;\r\n\r\n        if (hoursPassed > 0) {\r\n            uint256 yield = Utils.min(profitPerHour * hoursPassed, address(this).balance);\r\n            tokens[tokenId].claimTimestamp = uint32(block.timestamp);\r\n            volume += yield;\r\n            payable(msg.sender).transfer(yield);\r\n        }\r\n    }\r\n\r\n    function refund(uint256 tokenId) public checkToken(tokenId) {\r\n        require(tokens[tokenId].boosted == false, \"CryptoRobots: boost mode enabled\");\r\n\r\n        claim(tokenId);\r\n\r\n        uint256 profitPerHour = _profitPerHourOf(tokenId);\r\n        uint256 hoursPassed = _claimTimestampOf(tokenId) / 3600 - _createTimestampOf(tokenId) / 3600;\r\n        uint256 earned = hoursPassed * profitPerHour;\r\n        uint256 maxRefund = (_costOf(tokenId) * 9) / 10;\r\n\r\n        require(earned < maxRefund, \"CryptoRobots: no amount to refund\");\r\n\r\n        _burn(tokenId);\r\n        tokensBurned += 1;\r\n\r\n        volume += maxRefund - earned;\r\n        payable(msg.sender).transfer(maxRefund - earned);\r\n    }\r\n\r\n    function multicall(bytes[] calldata data) public {\r\n        for (uint256 i = 0; i < data.length; i++) {\r\n            (bool success, ) = address(this).delegatecall(data[i]);\r\n            require(success, \"CryptoRobots: multicall failed\");\r\n        }\r\n    }\r\n\r\n    function transferERC20(address token, address recipient, uint256 amount) public {\r\n        require(msg.sender == manager, \"CryptoRobots: access denied\");\r\n        IERC20(token).transfer(recipient, amount);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return tokenIdTracker - tokensBurned;\r\n    }\r\n\r\n    function tokenURI(uint256 id) public pure returns (string memory) {\r\n        return string(abi.encodePacked(\"https://nft.cryptorobots.cc/\", Utils.toString(id)));\r\n    }\r\n\r\n    function _profitPerHourOf(uint256 tokenId) internal view returns (uint256) {\r\n        uint256 numberOfDays = _numberOfDaysOf(tokenId);\r\n        uint256 dailyROI;\r\n\r\n        if (numberOfDays == 60) dailyROI = 200;\r\n        if (numberOfDays == 70) dailyROI = 194;\r\n        if (numberOfDays == 80) dailyROI = 188;\r\n        if (numberOfDays == 90) dailyROI = 182;\r\n        if (numberOfDays == 100) dailyROI = 176;\r\n        if (numberOfDays == 110) dailyROI = 170;\r\n        if (numberOfDays == 120) dailyROI = 164;\r\n\r\n        uint256 perHour = (_costOf(tokenId) * dailyROI) / 100 / 100 / 24;\r\n        if (tokens[tokenId].boosted) {\r\n            perHour = (perHour * 110) / 100;\r\n        }\r\n\r\n        return perHour;\r\n    }\r\n\r\n    function _expirationTimestampOf(uint256 tokenId) internal view returns (uint256) {\r\n        return _createTimestampOf(tokenId) + _numberOfDaysOf(tokenId) * 86400 + _numberOfChargesOf(tokenId) * 3600 * 4;\r\n    }\r\n\r\n    function _costOf(uint256 tokenId) internal view returns (uint256) {\r\n        return tokens[tokenId].cost;\r\n    }\r\n\r\n    function _claimTimestampOf(uint256 tokenId) internal view returns (uint256) {\r\n        return tokens[tokenId].claimTimestamp;\r\n    }\r\n\r\n    function _chargeTimestampOf(uint256 tokenId) internal view returns (uint256) {\r\n        return tokens[tokenId].chargeTimestamp;\r\n    }\r\n\r\n    function _createTimestampOf(uint256 tokenId) internal view returns (uint256) {\r\n        return tokens[tokenId].createTimestamp;\r\n    }\r\n\r\n    function _numberOfChargesOf(uint256 tokenId) internal view returns (uint256) {\r\n        return tokens[tokenId].numberOfCharges;\r\n    }\r\n\r\n    function _numberOfDaysOf(uint256 tokenId) internal view returns (uint256) {\r\n        return tokens[tokenId].numberOfDays;\r\n    }\r\n}\r\n\r\ncontract CryptoRobotsAPI {\r\n    struct Token {\r\n        uint32 tokenId;\r\n        uint80 cost;\r\n        uint32 timeLeft;\r\n        uint8 numberOfCharges;\r\n        uint8 numberOfDays;\r\n        bool boosted;\r\n        bool canBeCharged;\r\n        uint16 hoursPassed;\r\n        uint16 lifeHoursPassed;\r\n    }\r\n\r\n    struct User {\r\n        uint16 partners;\r\n        uint80 earnings;\r\n    }\r\n\r\n    CryptoRobots provider;\r\n\r\n    address deployer = msg.sender;\r\n\r\n    constructor(address api) {\r\n        setProvider(api);\r\n    }\r\n\r\n    function setProvider(address api) public {\r\n        require(msg.sender == deployer);\r\n        provider = CryptoRobots(api);\r\n    }\r\n\r\n    function refundOf(uint256 tokenId) external view returns (uint256) {\r\n        (uint80 cost, uint32 claimTimestamp, , uint32 createTimestamp, , uint8 numberOfDays, bool boosted) = provider\r\n            .tokens(tokenId);\r\n\r\n        if (boosted) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 dailyROI;\r\n\r\n        if (numberOfDays == 60) dailyROI = 200;\r\n        if (numberOfDays == 70) dailyROI = 194;\r\n        if (numberOfDays == 80) dailyROI = 188;\r\n        if (numberOfDays == 90) dailyROI = 182;\r\n        if (numberOfDays == 100) dailyROI = 176;\r\n        if (numberOfDays == 110) dailyROI = 170;\r\n        if (numberOfDays == 120) dailyROI = 164;\r\n\r\n        uint256 profitPerHour = (uint256(cost) * dailyROI) / 100 / 100 / 24;\r\n        \r\n        uint256 earned = (uint256(claimTimestamp) / 3600 - uint256(createTimestamp) / 3600) * profitPerHour;\r\n        uint256 earnedWithClaim = (block.timestamp / 3600 - uint256(createTimestamp) / 3600) * profitPerHour;\r\n\r\n        uint256 maxRefund = (uint256(cost) * 9) / 10;\r\n\r\n        if (earnedWithClaim < maxRefund) {\r\n            return maxRefund - earned;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    function idsOf(address owner) external view returns (uint256[] memory) {\r\n        uint256 historyCount = provider.historyCount(owner);\r\n        uint256[] memory ids = new uint256[](historyCount);\r\n        for (uint256 i = 0; i < historyCount; i++) {\r\n            ids[i] = provider.historyAt(owner, i);\r\n        }\r\n        return ids;\r\n    }\r\n\r\n    function dataOf(address owner) external view returns (uint256, User memory, Token[] memory, uint256) {\r\n        uint256 historyCount = provider.historyCount(owner);\r\n        Token[] memory tokens = new Token[](historyCount);\r\n\r\n        for (uint256 i = 0; i < historyCount; i++) {\r\n            uint32 tokenId = uint32(provider.historyAt(owner, i));\r\n\r\n            if (provider.ownerOf(tokenId) == owner) {\r\n                (\r\n                    uint80 cost,\r\n                    uint32 claimTimestamp,\r\n                    uint32 chargeTimestamp,\r\n                    uint32 createTimestamp,\r\n                    uint8 numberOfCharges,\r\n                    uint8 numberOfDays,\r\n                    bool boosted\r\n                ) = provider.tokens(tokenId);\r\n\r\n                uint16 hoursPassed;\r\n                uint32 expirationTimestamp = createTimestamp +\r\n                    uint32(numberOfDays) *\r\n                    86400 +\r\n                    uint32(numberOfCharges) *\r\n                    3600 *\r\n                    4;\r\n\r\n                if (expirationTimestamp > claimTimestamp) {\r\n                    hoursPassed = uint16(_min(block.timestamp, expirationTimestamp) / 3600 - claimTimestamp / 3600);\r\n                }\r\n\r\n                uint32 timeLeft = expirationTimestamp < block.timestamp\r\n                    ? 0\r\n                    : expirationTimestamp - uint32(block.timestamp);\r\n                bool canBeCharged = chargeTimestamp / 86400 < block.timestamp / 86400;\r\n                if (block.timestamp >= expirationTimestamp) {\r\n                    canBeCharged = false;\r\n                }\r\n\r\n                uint16 lifeHoursPassed = uint16(\r\n                    _min(block.timestamp, expirationTimestamp) / 3600 - createTimestamp / 3600\r\n                );\r\n\r\n                tokens[i] = Token(\r\n                    tokenId,\r\n                    cost,\r\n                    timeLeft,\r\n                    numberOfCharges,\r\n                    numberOfDays,\r\n                    boosted,\r\n                    canBeCharged,\r\n                    hoursPassed,\r\n                    lifeHoursPassed\r\n                );\r\n            }\r\n        }\r\n\r\n        (, uint16 partners, uint80 earnings) = provider.users(owner);\r\n\r\n        User memory user = User(partners, earnings);\r\n\r\n        return (owner.balance, user, tokens, 86400 - (block.timestamp % 86400));\r\n    }\r\n\r\n    function _dataOf(\r\n        address owner,\r\n        uint32[] memory tokenIds\r\n    ) external view returns (uint256, User memory, Token[] memory, uint256) {\r\n        uint256 tokenCount = tokenIds.length;\r\n\r\n        Token[] memory tokens = new Token[](tokenCount);\r\n        for (uint256 i = 0; i < tokenCount; i++) {\r\n            uint32 tokenId = tokenIds[i];\r\n\r\n            (\r\n                uint80 cost,\r\n                uint32 claimTimestamp,\r\n                uint32 chargeTimestamp,\r\n                uint32 createTimestamp,\r\n                uint8 numberOfCharges,\r\n                uint8 numberOfDays,\r\n                bool boosted\r\n            ) = provider.tokens(tokenId);\r\n\r\n            uint16 hoursPassed;\r\n            uint32 expirationTimestamp = createTimestamp +\r\n                uint32(numberOfDays) *\r\n                86400 +\r\n                uint32(numberOfCharges) *\r\n                3600 *\r\n                4;\r\n\r\n            if (expirationTimestamp > claimTimestamp) {\r\n                hoursPassed = uint16(_min(block.timestamp, expirationTimestamp) / 3600 - claimTimestamp / 3600);\r\n            }\r\n\r\n            uint32 timeLeft = expirationTimestamp < block.timestamp ? 0 : expirationTimestamp - uint32(block.timestamp);\r\n            bool canBeCharged = chargeTimestamp / 86400 < block.timestamp / 86400;\r\n            if (block.timestamp >= expirationTimestamp) {\r\n                canBeCharged = false;\r\n            }\r\n\r\n            uint16 lifeHoursPassed = uint16(_min(block.timestamp, expirationTimestamp) / 3600 - createTimestamp / 3600);\r\n\r\n            tokens[i] = Token(\r\n                tokenId,\r\n                cost,\r\n                timeLeft,\r\n                numberOfCharges,\r\n                numberOfDays,\r\n                boosted,\r\n                canBeCharged,\r\n                hoursPassed,\r\n                lifeHoursPassed\r\n            );\r\n        }\r\n\r\n        (, uint16 partners, uint80 earnings) = provider.users(owner);\r\n\r\n        User memory user = User(partners, earnings);\r\n\r\n        return (owner.balance, user, tokens, 86400 - (block.timestamp % 86400));\r\n    }\r\n\r\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"charge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"historyAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"historyCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"numberOfDays\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"boosted\",\"type\":\"bool\"},{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"}],\"name\":\"safeMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"result\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenIdTracker\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokens\",\"outputs\":[{\"internalType\":\"uint80\",\"name\":\"cost\",\"type\":\"uint80\"},{\"internalType\":\"uint32\",\"name\":\"claimTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"chargeTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"createTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint8\",\"name\":\"numberOfCharges\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"numberOfDays\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"boosted\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokensBurned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"users\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"partner\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"partners\",\"type\":\"uint16\"},{\"internalType\":\"uint80\",\"name\":\"earnings\",\"type\":\"uint80\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"volume\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "CryptoRobots", "CompilerVersion": "v0.8.0+commit.c7dfd78e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "1", "Implementation": "0x1d21867b6c43c79af26843a447fd82eaa11ff12a", "SwarmSource": "ipfs://32d8fff881017995e4d81560d54362993f4dbc2e9da45dfc6782c44856a525af"}