{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.3;\r\n\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n    function clone(address implementation) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create(0, ptr, 0x37)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            instance := create2(0, ptr, 0x37, salt)\r\n        }\r\n        require(instance != address(0), \"ERC1167: create2 failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal pure returns (address predicted) {\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(ptr, 0x14), shl(0x60, implementation))\r\n            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)\r\n            mstore(add(ptr, 0x38), shl(0x60, deployer))\r\n            mstore(add(ptr, 0x4c), salt)\r\n            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))\r\n            predicted := keccak256(add(ptr, 0x37), 0x55)\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n    function predictDeterministicAddress(address implementation, bytes32 salt) internal view returns (address predicted) {\r\n        return predictDeterministicAddress(implementation, salt, address(this));\r\n    }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor () {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and make it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        // On the first call to nonReentrant, _notEntered will be true\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n\r\n        _;\r\n\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n}\r\n\r\n\r\ncontract Governance is ReentrancyGuard {\r\n\r\n\tuint constant public governance_challenging_period = 10 days;\r\n\tuint constant public governance_freeze_period = 30 days;\r\n\r\n\taddress public votingTokenAddress;\r\n\taddress public governedContractAddress;\r\n\r\n\tmapping(address => uint) public balances;\r\n\r\n\tVotedValue[] public votedValues;\r\n\tmapping(string => VotedValue) public votedValuesMap;\r\n\r\n\r\n\tconstructor(address _governedContractAddress, address _votingTokenAddress){\r\n\t\tinit(_governedContractAddress, _votingTokenAddress);\r\n\t}\r\n\r\n\tfunction init(address _governedContractAddress, address _votingTokenAddress) public {\r\n\t\trequire(governedContractAddress == address(0), \"governance already initialized\");\r\n\t\tgovernedContractAddress = _governedContractAddress;\r\n\t\tvotingTokenAddress = _votingTokenAddress;\r\n\t}\r\n\r\n\tfunction addressBelongsToGovernance(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (address(votedValues[i]) == addr)\r\n\t\t\t\treturn true;\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction isUntiedFromAllVotes(address addr) public view returns (bool) {\r\n\t\tfor (uint i = 0; i < votedValues.length; i++)\r\n\t\t\tif (votedValues[i].hasVote(addr))\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction addVotedValue(string memory name, VotedValue votedValue) external {\r\n\t\trequire(msg.sender == governedContractAddress, \"not authorized\");\r\n\t\tvotedValues.push(votedValue);\r\n\t\tvotedValuesMap[name] = votedValue;\r\n\t}\r\n\r\n\r\n\t// deposit\r\n\r\n\tfunction deposit(uint amount) payable external {\r\n\t\tdeposit(msg.sender, amount);\r\n\t}\r\n\r\n\tfunction deposit(address from, uint amount) nonReentrant payable public {\r\n\t\trequire(from == msg.sender || addressBelongsToGovernance(msg.sender), \"not allowed\");\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\trequire(msg.value == amount, \"wrong amount received\");\r\n\t\telse {\r\n\t\t\trequire(msg.value == 0, \"don't send ETH\");\r\n\t\t\trequire(IERC20(votingTokenAddress).transferFrom(from, address(this), amount), \"failed to pull gov deposit\");\r\n\t\t}\r\n\t\tbalances[from] += amount;\r\n\t}\r\n\r\n\r\n\t// withdrawal functions\r\n\r\n\tfunction withdraw() external {\r\n\t\twithdraw(balances[msg.sender]);\r\n\t}\r\n\r\n\tfunction withdraw(uint amount) nonReentrant public {\r\n\t\trequire(amount > 0, \"zero withdrawal requested\");\r\n\t\trequire(amount <= balances[msg.sender], \"not enough balance\");\r\n\t\trequire(isUntiedFromAllVotes(msg.sender), \"some votes not removed yet\");\r\n\t\tbalances[msg.sender] -= amount;\r\n\t\tif (votingTokenAddress == address(0))\r\n\t\t\tpayable(msg.sender).transfer(amount);\r\n\t\telse\r\n\t\t\trequire(IERC20(votingTokenAddress).transfer(msg.sender, amount), \"failed to withdraw gov deposit\");\r\n\t}\r\n}\r\n\r\n\r\nabstract contract VotedValue is ReentrancyGuard {\r\n\tGovernance public governance;\r\n\tuint public challenging_period_start_ts;\r\n\tmapping(address => bool) public hasVote;\r\n\r\n\tconstructor(Governance _governance){\r\n\t\tgovernance = _governance;\r\n\t}\r\n\r\n\tfunction checkVoteChangeLock() view public {\r\n\t\trequire(challenging_period_start_ts + governance.governance_challenging_period() + governance.governance_freeze_period() < block.timestamp, \"you cannot change your vote yet\");\r\n\t}\r\n\r\n\tfunction checkChallengingPeriodExpiry() view public {\r\n\t\trequire(block.timestamp > challenging_period_start_ts + governance.governance_challenging_period(), \"challenging period not expired yet\");\r\n\t}\r\n}\r\n\r\n\r\ncontract VotedValueUint is VotedValue {\r\n\r\n\tfunction(uint) external validationCallback;\r\n\tfunction(uint) external commitCallback;\r\n\r\n\tuint public leader;\r\n\tuint public current_value;\r\n\r\n\tmapping(address => uint) public choices;\r\n\tmapping(uint => uint) public votesByValue;\r\n\tmapping(uint => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, uint initial_value, function(uint) external _validationCallback, function(uint) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction vote(uint value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(uint value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(uint value) private {\r\n\t\tvalidationCallback(value);\r\n\t\tuint prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// first, remove votes from the previous choice\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add them to the new choice\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[value] += balance;\r\n\t\tvotesByValueAddress[value][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[value] > votesByValue[leader]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\tuint prev_choice = choices[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(uint value) internal {\r\n\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\r\n\t\tvotesByValueAddress[value][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(leader != current_value, \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract VotedValueUintArray is VotedValue {\r\n\r\n\tfunction(uint[] memory) external validationCallback;\r\n\tfunction(uint[] memory) external commitCallback;\r\n\r\n\tuint[] public leader;\r\n\tuint[] public current_value;\r\n\r\n\tmapping(address => uint[]) public choices;\r\n\tmapping(bytes32 => uint) public votesByValue;\r\n\tmapping(bytes32 => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, uint[] memory initial_value, function(uint[] memory) external _validationCallback, function(uint[] memory) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction equal(uint[] memory a1, uint[] memory a2) public pure returns (bool) {\r\n\t\tif (a1.length != a2.length)\r\n\t\t\treturn false;\r\n\t\tfor (uint i = 0; i < a1.length; i++)\r\n\t\t\tif (a1[i] != a2[i])\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction getKey(uint[] memory a) public pure returns (bytes32){\r\n\t\treturn keccak256(abi.encodePacked(a));\r\n\t}\r\n\r\n\tfunction vote(uint[] memory value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(uint[] memory value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(uint[] memory value) private {\r\n\t\tvalidationCallback(value);\r\n\t\tuint[] storage prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (equal(prev_choice, leader))\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// remove one's vote from the previous choice first\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add it to the new choice, if any\r\n\t\tbytes32 key = getKey(value);\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[key] += balance;\r\n\t\tvotesByValueAddress[key][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[key] > votesByValue[getKey(leader)]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\tuint[] storage prev_choice = choices[msg.sender];\r\n\t\tif (equal(prev_choice, leader))\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(uint[] memory value) internal {\r\n\t\tbytes32 key = getKey(value);\r\n\t\tvotesByValue[key] -= votesByValueAddress[key][msg.sender];\r\n\t\tvotesByValueAddress[key][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(!equal(leader, current_value), \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\n\r\ncontract VotedValueAddress is VotedValue {\r\n\r\n\tfunction(address) external validationCallback;\r\n\tfunction(address) external commitCallback;\r\n\r\n\taddress public leader;\r\n\taddress public current_value;\r\n\r\n\t// mapping(who => value)\r\n\tmapping(address => address) public choices;\r\n\r\n\t// mapping(value => votes)\r\n\tmapping(address => uint) public votesByValue;\r\n\r\n\t// mapping(value => mapping(who => votes))\r\n\tmapping(address => mapping(address => uint)) public votesByValueAddress;\r\n\r\n\tconstructor() VotedValue(Governance(address(0))) {}\r\n\r\n\t// constructor(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) VotedValue(_governance) {\r\n\t// \tleader = initial_value;\r\n\t// \tcurrent_value = initial_value;\r\n\t// \tvalidationCallback = _validationCallback;\r\n\t// \tcommitCallback = _commitCallback;\r\n\t// }\r\n\r\n\tfunction init(Governance _governance, address initial_value, function(address) external _validationCallback, function(address) external _commitCallback) external {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = _governance;\r\n\t\tleader = initial_value;\r\n\t\tcurrent_value = initial_value;\r\n\t\tvalidationCallback = _validationCallback;\r\n\t\tcommitCallback = _commitCallback;\r\n\t}\r\n\r\n\tfunction vote(address value) nonReentrant external {\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction voteAndDeposit(address value, uint amount) nonReentrant payable external {\r\n\t\tgovernance.deposit{value: msg.value}(msg.sender, amount);\r\n\t\t_vote(value);\r\n\t}\r\n\r\n\tfunction _vote(address value) private {\r\n\t\tvalidationCallback(value);\r\n\t\taddress prev_choice = choices[msg.sender];\r\n\t\tbool hadVote = hasVote[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\r\n\t\t// first, remove votes from the previous choice\r\n\t\tif (hadVote)\r\n\t\t\tremoveVote(prev_choice);\r\n\r\n\t\t// then, add them to the new choice\r\n\t\tuint balance = governance.balances(msg.sender);\r\n\t\trequire(balance > 0, \"no balance\");\r\n\t\tvotesByValue[value] += balance;\r\n\t\tvotesByValueAddress[value][msg.sender] = balance;\r\n\t\tchoices[msg.sender] = value;\r\n\t\thasVote[msg.sender] = true;\r\n\r\n\t\t// check if the leader has just changed\r\n\t\tif (votesByValue[value] > votesByValue[leader]){\r\n\t\t\tleader = value;\r\n\t\t\tchallenging_period_start_ts = block.timestamp;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction unvote() external {\r\n\t\tif (!hasVote[msg.sender])\r\n\t\t\treturn;\r\n\t\taddress prev_choice = choices[msg.sender];\r\n\t\tif (prev_choice == leader)\r\n\t\t\tcheckVoteChangeLock();\r\n\t\t\r\n\t\tremoveVote(prev_choice);\r\n\t\tdelete choices[msg.sender];\r\n\t\tdelete hasVote[msg.sender];\r\n\t}\r\n\r\n\tfunction removeVote(address value) internal {\r\n\t\tvotesByValue[value] -= votesByValueAddress[value][msg.sender];\r\n\t\tvotesByValueAddress[value][msg.sender] = 0;\r\n\t}\r\n\r\n\tfunction commit() nonReentrant external {\r\n\t\trequire(leader != current_value, \"already equal to leader\");\r\n\t\tcheckChallengingPeriodExpiry();\r\n\t\tcurrent_value = leader;\r\n\t\tcommitCallback(leader);\r\n\t}\r\n}\r\n\r\n\r\ncontract VotedValueFactory {\r\n\r\n\taddress public votedValueUintMaster;\r\n\taddress public votedValueUintArrayMaster;\r\n\taddress public votedValueAddressMaster;\r\n\r\n\tconstructor(address _votedValueUintMaster, address _votedValueUintArrayMaster, address _votedValueAddressMaster) {\r\n\t\tvotedValueUintMaster = _votedValueUintMaster;\r\n\t\tvotedValueUintArrayMaster = _votedValueUintArrayMaster;\r\n\t\tvotedValueAddressMaster = _votedValueAddressMaster;\r\n\t}\r\n\r\n\r\n\tfunction createVotedValueUint(Governance governance, uint initial_value, function(uint) external validationCallback, function(uint) external commitCallback) external returns (VotedValueUint) {\r\n\t\tVotedValueUint vv = VotedValueUint(Clones.clone(votedValueUintMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n\tfunction createVotedValueUintArray(Governance governance, uint[] memory initial_value, function(uint[] memory) external validationCallback, function(uint[] memory) external commitCallback) external returns (VotedValueUintArray) {\r\n\t\tVotedValueUintArray vv = VotedValueUintArray(Clones.clone(votedValueUintArrayMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n\tfunction createVotedValueAddress(Governance governance, address initial_value, function(address) external validationCallback, function(address) external commitCallback) external returns (VotedValueAddress) {\r\n\t\tVotedValueAddress vv = VotedValueAddress(Clones.clone(votedValueAddressMaster));\r\n\t\tvv.init(governance, initial_value, validationCallback, commitCallback);\r\n\t\treturn vv;\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract GovernanceFactory {\r\n\r\n\taddress public governanceMaster;\r\n\r\n\tconstructor(address _governanceMaster) {\r\n\t\tgovernanceMaster = _governanceMaster;\r\n\t}\r\n\r\n\tfunction createGovernance(address governedContractAddress, address votingTokenAddress) external returns (Governance) {\r\n\t\tGovernance governance = Governance(Clones.clone(governanceMaster));\r\n\t\tgovernance.init(governedContractAddress, votingTokenAddress);\r\n\t\treturn governance;\r\n\t}\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n// The purpose of the library is to separate some of the code out of the Export/Import contracts and keep their sizes under the 24KiB limit\r\n\r\n\r\nlibrary CounterstakeLibrary {\r\n\r\n\tenum Side {no, yes}\r\n\r\n\t// small values (bool, uint32, ...) are grouped together in order to be packed efficiently\r\n\tstruct Claim {\r\n\t\tuint amount;\r\n\t//\tint reward;\r\n\r\n\t\taddress payable recipient_address; // 20 bytes, 12 bytes left\r\n\t\tuint32 txts;\r\n\t\tuint32 ts;\r\n\t\t\r\n\t\taddress payable claimant_address;\r\n\t\tuint32 expiry_ts;\r\n\t\tuint16 period_number;\r\n\t\tSide current_outcome;\r\n\t\tbool is_large;\r\n\t\tbool withdrawn;\r\n\t\tbool finished;\r\n\t\t\r\n\t\tstring sender_address;\r\n\t//\tstring txid;\r\n\t\tstring data;\r\n\t\tuint yes_stake;\r\n\t\tuint no_stake;\r\n\t//\tuint challenging_target;\r\n\t}\r\n\r\n\tstruct Settings {\r\n\t\taddress tokenAddress;\r\n\t\tuint16 ratio100;// = 100;\r\n\t\tuint16 counterstake_coef100;// = 150;\r\n\t\tuint32 min_tx_age;\r\n\t\tuint min_stake;\r\n\t\tuint[] challenging_periods;// = [12 hours, 3 days, 1 weeks, 30 days];\r\n\t\tuint[] large_challenging_periods;// = [3 days, 1 weeks, 30 days];\r\n\t\tuint large_threshold;\r\n\t}\r\n\r\n\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\r\n\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, Side outcome, Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\r\n\tevent FinishedClaim(uint indexed claim_num, Side outcome);\r\n\r\n\r\n\tstruct ClaimRequest {\r\n\t\tstring txid;\r\n\t\tuint32 txts;\r\n\t\tuint amount;\r\n\t\tint reward;\r\n\t\tuint stake;\r\n\t\tuint required_stake;\r\n\t\taddress payable recipient_address;\r\n\t\tstring sender_address;\r\n\t\tstring data;\r\n\t}\r\n\r\n\tfunction claim(\r\n\t\tSettings storage settings,\r\n\t\tmapping(string => uint) storage claim_nums,\r\n\t\tmapping(uint => Claim) storage claims,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes,\r\n\t\tuint claim_num,\r\n\t\tClaimRequest memory req\r\n\t) external {\r\n\t\trequire(req.amount > 0, \"0 claim\");\r\n\t\trequire(req.stake >= req.required_stake, \"the stake is too small\");\r\n\t\trequire(block.timestamp >= req.txts + settings.min_tx_age, \"too early\");\r\n\t\tif (req.recipient_address == address(0))\r\n\t\t\treq.recipient_address = payable(msg.sender);\r\n\t\tif (req.reward < 0)\r\n\t\t\trequire(req.recipient_address == payable(msg.sender), \"the sender disallowed third-party claiming by setting a negative reward\");\r\n\t\tstring memory claim_id = getClaimId(req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.data);\r\n\t\trequire(claim_nums[claim_id] == 0, \"this transfer has already been claimed\");\r\n\t\tbool is_large = (settings.large_threshold > 0 && req.stake >= settings.large_threshold);\r\n\t\tuint32 expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, 0, is_large)); // might wrap\r\n\t\tclaim_nums[claim_id] = claim_num;\r\n\t//\tuint challenging_target = req.stake * settings.counterstake_coef100/100;\r\n\t\tclaims[claim_num] = Claim({\r\n\t\t\tamount: req.amount,\r\n\t\t//\treward: req.reward,\r\n\t\t\trecipient_address: req.recipient_address,\r\n\t\t\tclaimant_address: payable(msg.sender),\r\n\t\t\tsender_address: req.sender_address,\r\n\t\t//\ttxid: req.txid,\r\n\t\t\tdata: req.data,\r\n\t\t\tyes_stake: req.stake,\r\n\t\t\tno_stake: 0,\r\n\t\t\tcurrent_outcome: Side.yes,\r\n\t\t\tis_large: is_large,\r\n\t\t\tperiod_number: 0,\r\n\t\t\ttxts: req.txts,\r\n\t\t\tts: uint32(block.timestamp),\r\n\t\t\texpiry_ts: expiry_ts,\r\n\t\t//\tchallenging_target: req.stake * settings.counterstake_coef100/100,\r\n\t\t\twithdrawn: false,\r\n\t\t\tfinished: false\r\n\t\t});\r\n\t\tstakes[claim_num][Side.yes][msg.sender] = req.stake;\r\n\t\temit NewClaim(claim_num, msg.sender, req.sender_address, req.recipient_address, req.txid, req.txts, req.amount, req.reward, req.stake, req.data, expiry_ts);\r\n\t//\treturn claim_id;\r\n\t}\r\n\r\n\r\n\tfunction challenge(\r\n\t\tSettings storage settings, \r\n\t\tClaim storage c,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \r\n\t\tuint claim_num, \r\n\t\tSide stake_on, \r\n\t\tuint stake\r\n\t) external {\r\n\t\trequire(block.timestamp < c.expiry_ts, \"the challenging period has expired\");\r\n\t\trequire(stake_on != c.current_outcome, \"this outcome is already current\");\r\n\t\tuint excess;\r\n\t\tuint challenging_target = (c.current_outcome == Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100;\r\n\t\t{ // circumvent stack too deep\r\n\t\t\tuint stake_on_proposed_outcome = (stake_on == Side.yes ? c.yes_stake : c.no_stake) + stake;\r\n\t\t\tbool would_override_current_outcome = stake_on_proposed_outcome >= challenging_target;\r\n\t\t\texcess = would_override_current_outcome ? stake_on_proposed_outcome - challenging_target : 0;\r\n\t\t\tuint accepted_stake = stake - excess;\r\n\t\t\tif (stake_on == Side.yes)\r\n\t\t\t\tc.yes_stake += accepted_stake;\r\n\t\t\telse\r\n\t\t\t\tc.no_stake += accepted_stake;\r\n\t\t\tif (would_override_current_outcome){\r\n\t\t\t\tc.period_number++;\r\n\t\t\t\tc.current_outcome = stake_on;\r\n\t\t\t\tc.expiry_ts = uint32(block.timestamp + getChallengingPeriod(settings, c.period_number, c.is_large));\r\n\t\t\t\tchallenging_target = challenging_target * settings.counterstake_coef100/100;\r\n\t\t\t}\r\n\t\t\tstakes[claim_num][stake_on][msg.sender] += accepted_stake;\r\n\t\t}\r\n\t\temit NewChallenge(claim_num, msg.sender, stake, stake_on, c.current_outcome, c.yes_stake, c.no_stake, c.expiry_ts, challenging_target);\r\n\t\tif (excess > 0){\r\n\t\t\tif (settings.tokenAddress == address(0))\r\n\t\t\t\tpayable(msg.sender).transfer(excess);\r\n\t\t\telse\r\n\t\t\t\trequire(IERC20(settings.tokenAddress).transfer(msg.sender, excess), \"failed to transfer the token\");\r\n\t\t}\r\n\t}\r\n\r\n\r\n\r\n\tfunction finish(\r\n\t\tClaim storage c,\r\n\t\tmapping(uint => mapping(Side => mapping(address => uint))) storage stakes, \r\n\t\tuint claim_num, \r\n\t\taddress payable to_address\r\n\t) external \r\n\treturns (bool, bool, uint)\r\n\t{\r\n\t\trequire(block.timestamp > c.expiry_ts, \"challenging period is still ongoing\");\r\n\t\tif (to_address == address(0))\r\n\t\t\tto_address = payable(msg.sender);\r\n\t\t\r\n\t\tbool is_winning_claimant = (to_address == c.claimant_address && c.current_outcome == Side.yes);\r\n\t\trequire(!(is_winning_claimant && c.withdrawn), \"already withdrawn\");\r\n\t\tuint won_stake;\r\n\t\t{ // circumvent stack too deep\r\n\t\t\tuint my_stake = stakes[claim_num][c.current_outcome][to_address];\r\n\t\t\trequire(my_stake > 0 || is_winning_claimant, \"you are not the recipient and you didn't stake on the winning outcome or you have already withdrawn\");\r\n\t\t\tuint winning_stake = c.current_outcome == Side.yes ? c.yes_stake : c.no_stake;\r\n\t\t\tif (my_stake > 0)\r\n\t\t\t\twon_stake = (c.yes_stake + c.no_stake) * my_stake / winning_stake;\r\n\t\t}\r\n\t\tif (is_winning_claimant)\r\n\t\t\tc.withdrawn = true;\r\n\t\tbool finished;\r\n\t\tif (!c.finished){\r\n\t\t\tfinished = true;\r\n\t\t\tc.finished = true;\r\n\t\t//\tSide losing_outcome = outcome == Side.yes ? Side.no : Side.yes;\r\n\t\t//\tdelete stakes[claim_id][losing_outcome]; // can't purge the stakes that will never be claimed\r\n\t\t\temit FinishedClaim(claim_num, c.current_outcome);\r\n\t\t}\r\n\t\tdelete stakes[claim_num][c.current_outcome][to_address];\r\n\t\treturn (finished, is_winning_claimant, won_stake);\r\n\t}\r\n\r\n\r\n\r\n\tfunction getChallengingPeriod(Settings storage settings, uint16 period_number, bool bLarge) public view returns (uint) {\r\n\t\tuint[] storage periods = bLarge ? settings.large_challenging_periods : settings.challenging_periods;\r\n\t\tif (period_number > periods.length - 1)\r\n\t\t\tperiod_number = uint16(periods.length - 1);\r\n\t\treturn periods[period_number];\r\n\t}\r\n\r\n\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\r\n\t\trequire(periods.length > 0, \"empty periods\");\r\n\t\tuint prev_period = 0;\r\n\t\tfor (uint i = 0; i < periods.length; i++) {\r\n\t\t\trequire(periods[i] < 3 * 365 days, \"some periods are longer than 3 years\");\r\n\t\t\trequire(periods[i] >= prev_period, \"subsequent periods cannot get shorter\");\r\n\t\t\tprev_period = periods[i];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getClaimId(string memory sender_address, address recipient_address, string memory txid, uint32 txts, uint amount, int reward, string memory data) public pure returns (string memory){\r\n\t\treturn string(abi.encodePacked(sender_address, '_', toAsciiString(recipient_address), '_', txid, '_', uint2str(txts), '_', uint2str(amount), '_', int2str(reward), '_', data));\r\n\t}\r\n\r\n\r\n\tfunction uint2str(uint256 _i) private pure returns (string memory) {\r\n\t\tif (_i == 0)\r\n\t\t\treturn \"0\";\r\n\t\tuint256 j = _i;\r\n\t\tuint256 length;\r\n\t\twhile (j != 0) {\r\n\t\t\tlength++;\r\n\t\t\tj /= 10;\r\n\t\t}\r\n\t\tbytes memory bstr = new bytes(length);\r\n\t\tuint256 k = length;\r\n\t\tj = _i;\r\n\t\twhile (j != 0) {\r\n\t\t\tbstr[--k] = bytes1(uint8(48 + j % 10));\r\n\t\t\tj /= 10;\r\n\t\t}\r\n\t\treturn string(bstr);\r\n\t}\r\n\r\n\tfunction int2str(int256 _i) private pure returns (string memory) {\r\n\t\trequire(_i < type(int).max, \"int too large\");\r\n\t\treturn _i >= 0 ? uint2str(uint(_i)) : string(abi.encodePacked('-', uint2str(uint(-_i))));\r\n\t}\r\n\r\n\tfunction toAsciiString(address x) private pure returns (string memory) {\r\n\t\tbytes memory s = new bytes(40);\r\n\t\tfor (uint i = 0; i < 20; i++) {\r\n\t\t\tbytes1 b = bytes1(uint8(uint(uint160(x)) / (2**(8*(19 - i)))));\r\n\t\t\tbytes1 hi = bytes1(uint8(b) / 16);\r\n\t\t\tbytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\r\n\t\t\ts[2*i] = char(hi);\r\n\t\t\ts[2*i+1] = char(lo);            \r\n\t\t}\r\n\t\treturn string(s);\r\n\t}\r\n\r\n\tfunction char(bytes1 b) private pure returns (bytes1 c) {\r\n\t\tif (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\r\n\t\telse return bytes1(uint8(b) + 0x57);\r\n\t}\r\n\r\n\tfunction isContract(address _addr) public view returns (bool){\r\n\t\tuint32 size;\r\n\t\tassembly {\r\n\t\t\tsize := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (size > 0);\r\n\t}\r\n}\r\n\r\n\r\n\r\n\r\ninterface CounterstakeReceiver {\r\n\tfunction onReceivedFromClaim(uint claim_num, uint net_claimed_amount, uint won_stake, string memory sender_address, address claim_recipient_address, string memory data) external;\r\n}\r\n\r\nabstract contract Counterstake is ReentrancyGuard {\r\n\r\n\tevent NewClaim(uint indexed claim_num, address author_address, string sender_address, address recipient_address, string txid, uint32 txts, uint amount, int reward, uint stake, string data, uint32 expiry_ts);\r\n\tevent NewChallenge(uint indexed claim_num, address author_address, uint stake, CounterstakeLibrary.Side outcome, CounterstakeLibrary.Side current_outcome, uint yes_stake, uint no_stake, uint32 expiry_ts, uint challenging_target);\r\n\tevent FinishedClaim(uint indexed claim_num, CounterstakeLibrary.Side outcome);\r\n\r\n\tGovernance public governance;\r\n\tCounterstakeLibrary.Settings public settings;\r\n\r\n\r\n\tuint64 public last_claim_num;\r\n\tuint64[] public ongoing_claim_nums;\r\n\tmapping(uint => uint) public num2index;\r\n\r\n\tmapping(string => uint) public claim_nums;\r\n\tmapping(uint => CounterstakeLibrary.Claim) private claims;\r\n\tmapping(uint => mapping(CounterstakeLibrary.Side => mapping(address => uint))) public stakes;\r\n\r\n\tfunction getClaim(uint claim_num) external view returns (CounterstakeLibrary.Claim memory) {\r\n\t\treturn claims[claim_num];\r\n\t}\r\n\r\n\tfunction getClaim(string memory claim_id) external view returns (CounterstakeLibrary.Claim memory) {\r\n\t\treturn claims[claim_nums[claim_id]];\r\n\t}\r\n\r\n\tfunction getOngoingClaimNums() external view returns (uint64[] memory) {\r\n\t\treturn ongoing_claim_nums;\r\n\t}\r\n\r\n\r\n\tconstructor (address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) {\r\n\t\tinitCounterstake(_tokenAddr, _counterstake_coef100, _ratio100, _large_threshold, _challenging_periods, _large_challenging_periods);\r\n\t}\r\n\r\n\tfunction initCounterstake(address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods) public {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tsettings = CounterstakeLibrary.Settings({\r\n\t\t\ttokenAddress: _tokenAddr,\r\n\t\t\tcounterstake_coef100: _counterstake_coef100 > 100 ? _counterstake_coef100 : 150,\r\n\t\t\tratio100: _ratio100 > 0 ? _ratio100 : 100,\r\n\t\t\tmin_stake: 0,\r\n\t\t\tmin_tx_age: 0,\r\n\t\t\tchallenging_periods: _challenging_periods,\r\n\t\t\tlarge_challenging_periods: _large_challenging_periods,\r\n\t\t\tlarge_threshold: _large_threshold\r\n\t\t});\r\n\t}\r\n\r\n\t/*\r\n\tmodifier onlyETH(){\r\n\t\trequire(settings.tokenAddress == address(0), \"ETH only\");\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyERC20(){\r\n\t\trequire(settings.tokenAddress != address(0), \"ERC20 only\");\r\n\t\t_;\r\n\t}*/\r\n\r\n\tmodifier onlyVotedValueContract(){\r\n\t\trequire(governance.addressBelongsToGovernance(msg.sender), \"not from voted value contract\");\r\n\t\t_;\r\n\t}\r\n\r\n\t// would be happy to call this from the constructor but unfortunately `this` is not set at that time yet\r\n\tfunction setupGovernance(GovernanceFactory governanceFactory, VotedValueFactory votedValueFactory) virtual public {\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tgovernance = governanceFactory.createGovernance(address(this), settings.tokenAddress);\r\n\r\n\t\tgovernance.addVotedValue(\"ratio100\", votedValueFactory.createVotedValueUint(governance, settings.ratio100, this.validateRatio, this.setRatio));\r\n\t\tgovernance.addVotedValue(\"counterstake_coef100\", votedValueFactory.createVotedValueUint(governance, settings.counterstake_coef100, this.validateCounterstakeCoef, this.setCounterstakeCoef));\r\n\t\tgovernance.addVotedValue(\"min_stake\", votedValueFactory.createVotedValueUint(governance, settings.min_stake, this.validateMinStake, this.setMinStake));\r\n\t\tgovernance.addVotedValue(\"min_tx_age\", votedValueFactory.createVotedValueUint(governance, settings.min_tx_age, this.validateMinTxAge, this.setMinTxAge));\r\n\t\tgovernance.addVotedValue(\"large_threshold\", votedValueFactory.createVotedValueUint(governance, settings.large_threshold, this.validateLargeThreshold, this.setLargeThreshold));\r\n\t\tgovernance.addVotedValue(\"challenging_periods\", votedValueFactory.createVotedValueUintArray(governance, settings.challenging_periods, this.validateChallengingPeriods, this.setChallengingPeriods));\r\n\t\tgovernance.addVotedValue(\"large_challenging_periods\", votedValueFactory.createVotedValueUintArray(governance, settings.large_challenging_periods, this.validateChallengingPeriods, this.setLargeChallengingPeriods));\r\n\t}\r\n\r\n\tfunction validateRatio(uint _ratio100) pure external {\r\n\t\trequire(_ratio100 > 0 && _ratio100 < 64000, \"bad ratio\");\r\n\t}\r\n\r\n\tfunction setRatio(uint _ratio100) onlyVotedValueContract external {\r\n\t\tsettings.ratio100 = uint16(_ratio100);\r\n\t}\r\n\r\n\t\r\n\tfunction validateCounterstakeCoef(uint _counterstake_coef100) pure external {\r\n\t\trequire(_counterstake_coef100 > 100 && _counterstake_coef100 < 64000, \"bad counterstake coef\");\r\n\t}\r\n\r\n\tfunction setCounterstakeCoef(uint _counterstake_coef100) onlyVotedValueContract external {\r\n\t\tsettings.counterstake_coef100 = uint16(_counterstake_coef100);\r\n\t}\r\n\r\n\t\r\n\tfunction validateMinStake(uint _min_stake) pure external {\r\n\t\t// anything goes\r\n\t}\r\n\r\n\tfunction setMinStake(uint _min_stake) onlyVotedValueContract external {\r\n\t\tsettings.min_stake = _min_stake;\r\n\t}\r\n\r\n\r\n\tfunction validateMinTxAge(uint _min_tx_age) pure external {\r\n\t\trequire(_min_tx_age < 4 weeks, \"min tx age too large\");\r\n\t}\r\n\r\n\tfunction setMinTxAge(uint _min_tx_age) onlyVotedValueContract external {\r\n\t\tsettings.min_tx_age = uint32(_min_tx_age);\r\n\t}\r\n\r\n\r\n\tfunction validateLargeThreshold(uint _large_threshold) pure external {\r\n\t\t// anything goes\r\n\t}\r\n\r\n\tfunction setLargeThreshold(uint _large_threshold) onlyVotedValueContract external {\r\n\t\tsettings.large_threshold = _large_threshold;\r\n\t}\r\n\r\n\r\n\tfunction validateChallengingPeriods(uint[] memory periods) pure external {\r\n\t\tCounterstakeLibrary.validateChallengingPeriods(periods);\r\n\t}\r\n\r\n\tfunction setChallengingPeriods(uint[] memory _challenging_periods) onlyVotedValueContract external {\r\n\t\tsettings.challenging_periods = _challenging_periods;\r\n\t}\r\n\r\n\tfunction setLargeChallengingPeriods(uint[] memory _large_challenging_periods) onlyVotedValueContract external {\r\n\t\tsettings.large_challenging_periods = _large_challenging_periods;\r\n\t}\r\n\r\n\r\n\tfunction getChallengingPeriod(uint16 period_number, bool bLarge) external view returns (uint) {\r\n\t\treturn CounterstakeLibrary.getChallengingPeriod(settings, period_number, bLarge);\r\n\t}\r\n\r\n\tfunction getRequiredStake(uint amount) public view virtual returns (uint);\r\n\r\n\tfunction getMissingStake(uint claim_num, CounterstakeLibrary.Side stake_on) external view returns (uint) {\r\n\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\r\n\t\trequire(c.yes_stake > 0, \"no such claim\");\r\n\t\tuint current_stake = (stake_on == CounterstakeLibrary.Side.yes) ? c.yes_stake : c.no_stake;\r\n\t\treturn (c.current_outcome == CounterstakeLibrary.Side.yes ? c.yes_stake : c.no_stake) * settings.counterstake_coef100/100 - current_stake;\r\n\t}\r\n\r\n\r\n\r\n\tfunction claim(string memory txid, uint32 txts, uint amount, int reward, uint stake, string memory sender_address, address payable recipient_address, string memory data) nonReentrant payable external {\r\n\t\tif (recipient_address == address(0))\r\n\t\t\trecipient_address = payable(msg.sender);\r\n\t\tbool bThirdPartyClaiming = (recipient_address != payable(msg.sender) && reward >= 0);\r\n\t\tuint paid_amount;\r\n\t\tif (bThirdPartyClaiming) {\r\n\t\t\trequire(amount > uint(reward), \"reward too large\");\r\n\t\t\tpaid_amount = amount - uint(reward);\r\n\t\t}\r\n\t\treceiveMoneyInClaim(stake, paid_amount);\r\n\t\tuint required_stake = getRequiredStake(amount);\r\n\t\tCounterstakeLibrary.ClaimRequest memory req = CounterstakeLibrary.ClaimRequest({\r\n\t\t\ttxid: txid,\r\n\t\t\ttxts: txts,\r\n\t\t\tamount: amount,\r\n\t\t\treward: reward,\r\n\t\t\tstake: stake,\r\n\t\t\trequired_stake: required_stake,\r\n\t\t\trecipient_address: recipient_address,\r\n\t\t\tsender_address: sender_address,\r\n\t\t\tdata: data\r\n\t\t});\r\n\t\tlast_claim_num++;\r\n\t\tongoing_claim_nums.push(last_claim_num);\r\n\t\tnum2index[last_claim_num] = ongoing_claim_nums.length - 1;\r\n\r\n\t\tCounterstakeLibrary.claim(settings, claim_nums, claims, stakes, last_claim_num, req);\r\n\t\t\r\n\t\tif (bThirdPartyClaiming){\r\n\t\t\tsendToClaimRecipient(recipient_address, paid_amount);\r\n\t\t\tnotifyPaymentRecipient(recipient_address, paid_amount, 0, last_claim_num);\r\n\t\t}\r\n\t}\r\n\t\r\n\r\n\tfunction challenge(string calldata claim_id, CounterstakeLibrary.Side stake_on, uint stake) payable external {\r\n\t\tchallenge(claim_nums[claim_id], stake_on, stake);\r\n\t}\r\n\r\n\tfunction challenge(uint claim_num, CounterstakeLibrary.Side stake_on, uint stake) nonReentrant payable public {\r\n\t\treceiveStakeAsset(stake);\r\n\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\r\n\t\trequire(c.amount > 0, \"no such claim\");\r\n\t\tCounterstakeLibrary.challenge(settings, c, stakes, claim_num, stake_on, stake);\r\n\t}\r\n\r\n\tfunction withdraw(string memory claim_id) external {\r\n\t\twithdraw(claim_nums[claim_id], payable(0));\r\n\t}\r\n\r\n\tfunction withdraw(uint claim_num) external {\r\n\t\twithdraw(claim_num, payable(0));\r\n\t}\r\n\r\n\tfunction withdraw(string memory claim_id, address payable to_address) external {\r\n\t\twithdraw(claim_nums[claim_id], to_address);\r\n\t}\r\n\r\n\tfunction withdraw(uint claim_num, address payable to_address) nonReentrant public {\r\n\t\tif (to_address == address(0))\r\n\t\t\tto_address = payable(msg.sender);\r\n\t\trequire(claim_num > 0, \"no such claim num\");\r\n\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\r\n\t\trequire(c.amount > 0, \"no such claim\");\r\n\r\n\t\t(bool finished, bool is_winning_claimant, uint won_stake) = CounterstakeLibrary.finish(c, stakes, claim_num, to_address);\r\n\t\t\r\n\t\tif (finished){\r\n\t\t\tuint index = num2index[claim_num];\r\n\t\t\tuint last_index = ongoing_claim_nums.length - 1;\r\n\t\t\tif (index != last_index){ // move the last element in place of our removed element\r\n\t\t\t\trequire(index < last_index, \"BUG index after last\");\r\n\t\t\t\tuint64 claim_num_of_last_element = ongoing_claim_nums[last_index];\r\n\t\t\t\tnum2index[claim_num_of_last_element] = index;\r\n\t\t\t\tongoing_claim_nums[index] = claim_num_of_last_element;\r\n\t\t\t}\r\n\t\t\tongoing_claim_nums.pop();\r\n\t\t\tdelete num2index[claim_num];\r\n\t\t}\r\n\r\n\t\tuint claimed_amount_to_be_paid = is_winning_claimant ? c.amount : 0;\r\n\t\tsendWithdrawals(to_address, claimed_amount_to_be_paid, won_stake);\r\n\t\tnotifyPaymentRecipient(to_address, claimed_amount_to_be_paid, won_stake, claim_num);\r\n\t}\r\n\r\n\tfunction notifyPaymentRecipient(address payable payment_recipient_address, uint net_claimed_amount, uint won_stake, uint claim_num) private {\r\n\t\tif (CounterstakeLibrary.isContract(payment_recipient_address)){\r\n\t\t\tCounterstakeLibrary.Claim storage c = claims[claim_num];\r\n\t\t//\tCounterstakeReceiver(payment_recipient_address).onReceivedFromClaim(claim_num, is_winning_claimant ? claimed_amount : 0, won_stake);\r\n\t\t\t(bool res, ) = payment_recipient_address.call(abi.encodeWithSignature(\"onReceivedFromClaim(uint256,uint256,uint256,string,address,string)\", claim_num, net_claimed_amount, won_stake, c.sender_address, c.recipient_address, c.data));\r\n\t\t\tif (!res){\r\n\t\t\t\t// ignore\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction receiveStakeAsset(uint stake_asset_amount) internal {\r\n\t\tif (settings.tokenAddress == address(0))\r\n\t\t\trequire(msg.value == stake_asset_amount, \"wrong amount received\");\r\n\t\telse {\r\n\t\t\trequire(msg.value == 0, \"don't send ETH\");\r\n\t\t\trequire(IERC20(settings.tokenAddress).transferFrom(msg.sender, address(this), stake_asset_amount), \"failed to pull the token\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sendWithdrawals(address payable to_address, uint claimed_amount_to_be_paid, uint won_stake) internal virtual;\r\n\t\r\n\tfunction sendToClaimRecipient(address payable to_address, uint paid_amount) internal virtual;\r\n\r\n\tfunction receiveMoneyInClaim(uint stake, uint paid_amount) internal virtual;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\ncontract Export is Counterstake {\r\n\r\n\r\n\tevent NewExpatriation(address sender_address, uint amount, int reward, string foreign_address, string data);\r\n\r\n\tstring public foreign_network;\r\n\tstring public foreign_asset;\r\n\r\n\tconstructor (string memory _foreign_network, string memory _foreign_asset, address _tokenAddr, uint16 _counterstake_coef100, uint16 _ratio100, uint _large_threshold, uint[] memory _challenging_periods, uint[] memory _large_challenging_periods)\r\n\tCounterstake(_tokenAddr, _counterstake_coef100, _ratio100, _large_threshold, _challenging_periods, _large_challenging_periods)\r\n\t{\r\n\t\tforeign_network = _foreign_network;\r\n\t\tforeign_asset = _foreign_asset;\r\n\t}\r\n\r\n\tfunction initExport(string memory _foreign_network, string memory _foreign_asset) public\r\n\t{\r\n\t\trequire(address(governance) == address(0), \"already initialized\");\r\n\t\tforeign_network = _foreign_network;\r\n\t\tforeign_asset = _foreign_asset;\r\n\t}\r\n\r\n\r\n\tfunction transferToForeignChain(string memory foreign_address, string memory data, uint amount, int reward) payable nonReentrant external {\r\n\t\treceiveStakeAsset(amount);\r\n\t\tif (reward >= 0)\r\n\t\t\trequire(uint(reward) < amount, \"reward too big\");\r\n\t\temit NewExpatriation(msg.sender, amount, reward, foreign_address, data);\r\n\t}\r\n\r\n\r\n\tfunction getRequiredStake(uint amount) public view override returns (uint) {\r\n\t\treturn Math.max(amount * settings.ratio100 / 100, settings.min_stake);\r\n\t}\r\n\r\n\r\n\tfunction sendWithdrawals(address payable to_address, uint paid_claimed_amount, uint won_stake) internal override {\r\n\t\tuint total = won_stake + paid_claimed_amount;\r\n\t\tif (settings.tokenAddress == address(0)) {\r\n\t\t\tto_address.transfer(total);\r\n\t\t}\r\n\t\telse {\r\n\t\t\trequire(IERC20(settings.tokenAddress).transfer(to_address, total), \"failed to send tokens\");\r\n\t\t}\r\n\t}\r\n\r\n\tfunction receiveMoneyInClaim(uint stake, uint paid_amount) internal override {\r\n\t\treceiveStakeAsset(stake + paid_amount);\r\n\t}\r\n\r\n\tfunction sendToClaimRecipient(address payable to_address, uint paid_amount) internal override {\r\n\t\tif (settings.tokenAddress == address(0)) {\r\n\t\t\tto_address.transfer(paid_amount);\r\n\t\t}\r\n\t\telse {\r\n\t\t\trequire(IERC20(settings.tokenAddress).transfer(to_address, paid_amount), \"failed to send tokens\");\r\n\t\t}\r\n\t}\r\n\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_foreign_network\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_foreign_asset\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_counterstake_coef100\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_ratio100\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_large_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_challenging_periods\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_large_challenging_periods\",\"type\":\"uint256[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"outcome\",\"type\":\"uint8\"}],\"name\":\"FinishedClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"outcome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"current_outcome\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"yes_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"no_stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"expiry_ts\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"challenging_target\",\"type\":\"uint256\"}],\"name\":\"NewChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"author_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"sender_address\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recipient_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"txid\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"txts\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"reward\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"expiry_ts\",\"type\":\"uint32\"}],\"name\":\"NewClaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender_address\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"reward\",\"type\":\"int256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"foreign_address\",\"type\":\"string\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"NewExpatriation\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"stake_on\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"challenge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"claim_id\",\"type\":\"string\"},{\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"stake_on\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"challenge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"txid\",\"type\":\"string\"},{\"internalType\":\"uint32\",\"name\":\"txts\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"reward\",\"type\":\"int256\"},{\"internalType\":\"uint256\",\"name\":\"stake\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"sender_address\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"recipient_address\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"claim_nums\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreign_asset\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"foreign_network\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"period_number\",\"type\":\"uint16\"},{\"internalType\":\"bool\",\"name\":\"bLarge\",\"type\":\"bool\"}],\"name\":\"getChallengingPeriod\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"claim_id\",\"type\":\"string\"}],\"name\":\"getClaim\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient_address\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"txts\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ts\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"claimant_address\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"expiry_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"period_number\",\"type\":\"uint16\"},{\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"current_outcome\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"is_large\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"sender_address\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"yes_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"no_stake\",\"type\":\"uint256\"}],\"internalType\":\"struct CounterstakeLibrary.Claim\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"}],\"name\":\"getClaim\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"recipient_address\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"txts\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"ts\",\"type\":\"uint32\"},{\"internalType\":\"address payable\",\"name\":\"claimant_address\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"expiry_ts\",\"type\":\"uint32\"},{\"internalType\":\"uint16\",\"name\":\"period_number\",\"type\":\"uint16\"},{\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"current_outcome\",\"type\":\"uint8\"},{\"internalType\":\"bool\",\"name\":\"is_large\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"withdrawn\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"finished\",\"type\":\"bool\"},{\"internalType\":\"string\",\"name\":\"sender_address\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"yes_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"no_stake\",\"type\":\"uint256\"}],\"internalType\":\"struct CounterstakeLibrary.Claim\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"stake_on\",\"type\":\"uint8\"}],\"name\":\"getMissingStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOngoingClaimNums\",\"outputs\":[{\"internalType\":\"uint64[]\",\"name\":\"\",\"type\":\"uint64[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getRequiredStake\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"contract Governance\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"_counterstake_coef100\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_ratio100\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_large_threshold\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"_challenging_periods\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_large_challenging_periods\",\"type\":\"uint256[]\"}],\"name\":\"initCounterstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_foreign_network\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_foreign_asset\",\"type\":\"string\"}],\"name\":\"initExport\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"last_claim_num\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"num2index\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ongoing_claim_nums\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_challenging_periods\",\"type\":\"uint256[]\"}],\"name\":\"setChallengingPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_counterstake_coef100\",\"type\":\"uint256\"}],\"name\":\"setCounterstakeCoef\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"_large_challenging_periods\",\"type\":\"uint256[]\"}],\"name\":\"setLargeChallengingPeriods\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_large_threshold\",\"type\":\"uint256\"}],\"name\":\"setLargeThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min_stake\",\"type\":\"uint256\"}],\"name\":\"setMinStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min_tx_age\",\"type\":\"uint256\"}],\"name\":\"setMinTxAge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ratio100\",\"type\":\"uint256\"}],\"name\":\"setRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"settings\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint16\",\"name\":\"ratio100\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"counterstake_coef100\",\"type\":\"uint16\"},{\"internalType\":\"uint32\",\"name\":\"min_tx_age\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"min_stake\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"large_threshold\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract GovernanceFactory\",\"name\":\"governanceFactory\",\"type\":\"address\"},{\"internalType\":\"contract VotedValueFactory\",\"name\":\"votedValueFactory\",\"type\":\"address\"}],\"name\":\"setupGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"enum CounterstakeLibrary.Side\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"stakes\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"foreign_address\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"data\",\"type\":\"string\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"int256\",\"name\":\"reward\",\"type\":\"int256\"}],\"name\":\"transferToForeignChain\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"periods\",\"type\":\"uint256[]\"}],\"name\":\"validateChallengingPeriods\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_counterstake_coef100\",\"type\":\"uint256\"}],\"name\":\"validateCounterstakeCoef\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_large_threshold\",\"type\":\"uint256\"}],\"name\":\"validateLargeThreshold\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min_stake\",\"type\":\"uint256\"}],\"name\":\"validateMinStake\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_min_tx_age\",\"type\":\"uint256\"}],\"name\":\"validateMinTxAge\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_ratio100\",\"type\":\"uint256\"}],\"name\":\"validateRatio\",\"outputs\":[],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"},{\"internalType\":\"address payable\",\"name\":\"to_address\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claim_num\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"claim_id\",\"type\":\"string\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"claim_id\",\"type\":\"string\"},{\"internalType\":\"address payable\",\"name\":\"to_address\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "Export", "CompilerVersion": "v0.8.6+commit.11564f7e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000006e0000000000000000000000000000000000000000000000056bc75e2d631000000000000000000000000000000000000000000000000000000000000000000180000000000000000000000000000000000000000000000000000000000000022000000000000000000000000000000000000000000000000000000000000000054f6279746500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000094f455448617373657400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000c4e0000000000000000000000000000000000000000000000000000000000003f4800000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000000278d00000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000546000000000000000000000000000000000000000000000000000000000000093a800000000000000000000000000000000000000000000000000000000000278d00", "EVMVersion": "Default", "Library": "CounterstakeLibrary:ac6f466dfc250f612aa35e942dcf4a42e2156ce2", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://fa6cd8eab129f4cb661b25af6b263c7ee8324287c0722af6d6e205e965375d65"}