{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/BalancerFlashloan.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.17;\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\nimport \\\"./IBalancerVault.sol\\\";\\n\\ninterface IOrbsStaking{\\n    function stake(uint256 _amount) external;\\n   function  unstake(uint256 _amount) external;\\n   function  withdraw() external; // all orbs token withdraw\\n   function distributeRewards(uint256 _totalAmount, address[] calldata _stakeOwners, uint256[] calldata _amounts)  external;\\n   function claimStakingRewards(address addr) external;\\n}\\n\\n\\n\\n// Interface for QuickSwap Router\\ninterface IUniswapV2Router {\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n     function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\\n\\n\\ncontract BalancerFlashloan is IFlashLoanRecipient{\\n\\n    address public immutable vault = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\\n    address public immutable usdc = 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174;\\n    address public immutable usdt = 0xc2132D05D31c914a87C6611C10748AEb04B58e8F;\\n    address public immutable pool = 0xB2b6D423e535b57aaD06E9866803B95fB66152EA; // ORBS/USDT\\n    address private constant quickSwapRouter = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff; // QuickSwap Router address\\n    address private constant uniSwapRouter = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;\\n    address public immutable orbsStaking = 0xEeAE6791F684117B7028b48Cb5dD21186dF80B9c;\\n    address public immutable orbs = 0x614389EaAE0A6821DC49062D56BDA3d9d45Fa2ff;\\n    address private owner;\\n\\n     IUniswapV2Router private router;\\n     IOrbsStaking private stakeContract;\\n    constructor(address _owner) {\\n        owner = _owner;\\n        router = IUniswapV2Router(uniSwapRouter);\\n        stakeContract = IOrbsStaking(orbsStaking);\\n\\n    }\\n\\n    modifier onlyOwner {\\n        require(msg.sender == owner,\\\"Only owner\\\");\\n        _;        \\n    }\\n\\n     function receiveFlashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory\\n    ) external override {\\n         // do something\\n         for(uint256 i=0;i<tokens.length;++i){\\n            IERC20 token = tokens[i];\\n            // borrow amount\\n             uint256 amount = amounts[i];\\n             \\n             // ----swap USDT to USDC --- //\\n    //     IERC20(token).approve(uniSwapRouter, amount);\\n\\n    //     address[] memory path = new address[](2);\\n    //     path[0] = address(token);\\n    //     path[1]= usdc;\\n    //     swapTokens(amount,path);\\n\\n    //     uint256 usdcAmount = IERC20(usdc).balanceOf(address(this));\\n    //     //--------start swap USDC to ORBS-----//\\n\\n    //     IERC20(usdc).approve(uniSwapRouter, usdcAmount);\\n\\n    //     address[] memory path1 = new address[](2);\\n    //     path1[0] = usdc;\\n    //     path1[1]= orbs;\\n            \\n    //         swapTokens(usdcAmount,path1);\\n\\n    //         uint256 orbsAmountbeforeStake = IERC20(orbs).balanceOf(address(this));\\n\\n    //          //---- stake orbs token---//\\n    //          IERC20(orbs).approve(orbsStaking,orbsAmountbeforeStake);\\n    //          stakeContract.stake(10000);\\n            \\n    //          // --- unstake orbs token--//\\n    //          stakeContract.unstake(100);\\n\\n    //         //  stakeContract.withdraw();\\n    //         uint256 orbsAmountafterWithdraw = IERC20(orbs).balanceOf(address(this));\\n          \\n    //       IERC20(orbs).approve(uniSwapRouter,orbsAmountafterWithdraw);\\n    //       //---- swap ORBS to USDC -- //   \\n    //     address[] memory path2 = new address[](2);\\n    //     path2[0] = orbs;\\n    //     path2[1]=usdc;\\n      \\n    //         swapTokens(amount,path2);\\n    //    uint256 usdcAmoutAfterSwap = IERC20(usdc).balanceOf(address(this));\\n          \\n    //     // ----swap USDC to USDT --- //\\n    //     IERC20(usdc).approve(uniSwapRouter, usdcAmoutAfterSwap);\\n\\n    //     address[] memory path3 = new address[](2);\\n    //     path3[0] = usdc;\\n    //     path3[1]= usdt;\\n    //     swapTokens(usdcAmoutAfterSwap,path3);\\n\\n    //     uint256 usdtAmount = IERC20(usdt).balanceOf(address(this));\\n    //     uint256 profit = usdtAmount - amount;\\n    //          //------ end ------//\\n            // fee amount\\n             uint256 feeAmount = feeAmounts[i];\\n             feeAmount = 0;\\n            // return loan\\n            token.transfer(vault,amount);\\n         }\\n    }\\n  \\n    \\n     function swapTokens(uint256 amount, address[] memory path) internal{\\n     uint deadline = block.timestamp + 1;\\n     router.swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n            amount,\\n            0, // amountOutMin - you should calculate the minimum amount using an oracle or estimation\\n            path,\\n            address(this),\\n            deadline\\n        );\\n     }\\n     \\n    \\n    function flashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external {\\n        IBalancerVault(vault).flashLoan(\\n            IFlashLoanRecipient(address(this)),\\n            tokens,\\n            amounts,\\n            userData\\n        );\\n    }\\n\\n\\n    function withDraw(address token,uint256 amount) public onlyOwner {\\n        \\n       IERC20(token).transfer(owner,amount);\\n    }\\n\\n    function getTokenAmount(address token) public view returns(uint256){\\n        return IERC20(token).balanceOf(address(this));\\n    }\\n}\"\r\n    },\r\n    \"contracts/IBalancerVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./IFlashLoanRecipient.sol\\\";\\n\\ninterface IBalancerVault {\\n    function flashLoan(\\n        IFlashLoanRecipient recipient,\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\"\r\n    },\r\n    \"contracts/IFlashLoanRecipient.sol\": {\r\n      \"content\": \"// This is a file copied from https://github.com/balancer-labs/balancer-v2-monorepo/blob/master/pkg/interfaces/contracts/vault/IFlashLoanRecipient.sol\\n// SPDX-License-Identifier: GPL-3.0-or-later\\n// This program is free software: you can redistribute it and/or modify\\n// it under the terms of the GNU General Public License as published by\\n// the Free Software Foundation, either version 3 of the License, or\\n// (at your option) any later version.\\n\\n// This program is distributed in the hope that it will be useful,\\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n// GNU General Public License for more details.\\n\\n// You should have received a copy of the GNU General Public License\\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\\n\\npragma solidity ^0.8.0;\\n\\n// Inspired by Aave Protocol's IFlashLoanReceiver.\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IFlashLoanRecipient {\\n    /**\\n     * @dev When `flashLoan` is called on the Vault, it invokes the `receiveFlashLoan` hook on the recipient.\\n     *\\n     * At the time of the call, the Vault will have transferred `amounts` for `tokens` to the recipient. Before this\\n     * call returns, the recipient must have transferred `amounts` plus `feeAmounts` for each token back to the\\n     * Vault, or else the entire flash loan will revert.\\n     *\\n     * `userData` is the same value passed in the `IVault.flashLoan` call.\\n     */\\n    function receiveFlashLoan(\\n        IERC20[] memory tokens,\\n        uint256[] memory amounts,\\n        uint256[] memory feeAmounts,\\n        bytes memory userData\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200,\r\n      \"details\": {\r\n        \"yul\": false\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"userData\",\"type\":\"bytes\"}],\"name\":\"flashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orbs\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"orbsStaking\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"feeAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"receiveFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdc\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usdt\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"vault\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withDraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BalancerFlashloan", "CompilerVersion": "v0.8.20+commit.a1b79de6", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000efa06561aa306a8b24d78e6e34b96cbb6d90a3c6", "EVMVersion": "paris", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}