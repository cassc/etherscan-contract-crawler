{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/home/ablts/work/tenguswap/farms/contracts/MasterChef.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"./libs/IBEP20.sol\\\";\\nimport \\\"./libs/SafeBEP20.sol\\\";\\nimport \\\"./libs/ITenguReferral.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/ReentrancyGuard.sol\\\";\\n\\nimport \\\"./TenguToken.sol\\\";\\n\\n// MasterChef is the master of Tengu. He can make Tengu and he is a fair guy.\\n//\\n// Note that it's ownable and the owner wields tremendous power. The ownership\\n// will be transferred to a governance smart contract once TENGU is sufficiently\\n// distributed and the community can show to govern itself.\\n//\\n// Have fun reading it. Hopefully it's bug-free. God bless.\\ncontract MasterChef is Ownable, ReentrancyGuard {\\n    using SafeMath for uint256;\\n    using SafeBEP20 for IBEP20;\\n    using SafeBEP20 for TenguToken;\\n\\n    // Info of each user.\\n    struct UserInfo {\\n        uint256 amount;         // How many LP tokens the user has provided.\\n        uint256 rewardDebt;     // Reward debt. See explanation below.\\n        uint256 rewardLockedUp;  // Reward locked up.\\n        uint256 nextHarvestUntil; // When can the user harvest again.\\n        //\\n        // We do some fancy math here. Basically, any point in time, the amount of TENGUs\\n        // entitled to a user but is pending to be distributed is:\\n        //\\n        //   pending reward = (user.amount * pool.accTenguPerShare) - user.rewardDebt\\n        //\\n        // Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\\n        //   1. The pool's `accTenguPerShare` (and `lastRewardBlock`) gets updated.\\n        //   2. User receives the pending reward sent to his/her address.\\n        //   3. User's `amount` gets updated.\\n        //   4. User's `rewardDebt` gets updated.\\n    }\\n\\n    // Info of each pool.\\n    struct PoolInfo {\\n        IBEP20 lpToken;           // Address of LP token contract.\\n        uint256 allocPoint;       // How many allocation points assigned to this pool. TENGUs to distribute per block.\\n        uint256 lastRewardBlock;  // Last block number that TENGUs distribution occurs.\\n        uint256 accTenguPerShare;   // Accumulated TENGUs per share, times 1e12. See below.\\n        uint256 depositFeeBP;      // Deposit fee in basis points\\n        uint256 harvestInterval;  // Harvest interval in seconds\\n        uint256 lpSupply;        // To determine more precisely the deposits and avoid the dilution of rewards\\n    }\\n\\n    // The TENGU TOKEN!\\n    TenguToken public tengu;\\n    // Dev address.\\n    address public devAddress;\\n    // Deposit Fee address\\n    address public feeAddress;\\n    // TENGU tokens created per block.\\n    uint256 public tenguPerBlock;\\n    // Max tokens / block\\n    uint256 public constant MAX_EMISSION_RATE = 10 ether;\\n    // Bonus muliplier for early tengu makers.\\n    uint256 public constant BONUS_MULTIPLIER = 1;\\n    // Max harvest interval: 14 days.\\n    uint256 public constant MAXIMUM_HARVEST_INTERVAL = 14 days;\\n\\n\\n    // Info of each pool.\\n    PoolInfo[] public poolInfo;\\n    // Info of each user that stakes LP tokens.\\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\\n    // Total allocation points. Must be the sum of all allocation points in all pools.\\n    uint256 public totalAllocPoint = 0;\\n    // The block number when TENGU mining starts.\\n    uint256 public startBlock;\\n    // Total locked up rewards\\n    uint256 public totalLockedUpRewards;\\n\\n    // Tengu referral contract address.\\n    ITenguReferral public tenguReferral;\\n    // Referral commission rate in basis points.\\n    uint256 public referralCommissionRate = 100;\\n    // Max referral commission rate: 10%.\\n    uint256 public constant MAXIMUM_REFERRAL_COMMISSION_RATE = 1000;\\n    // Max deposit fee: 4%\\n    uint256 public constant MAXIMUM_DEPOSIT_FEE = 400;\\n\\n    event Deposit(address indexed user, uint256 indexed pid, uint256 amount);\\n    event Withdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmergencyWithdraw(address indexed user, uint256 indexed pid, uint256 amount);\\n    event EmissionRateUpdated(uint256 previousAmount, uint256 newAmount);\\n    event ReferralCommissionPaid(address indexed user, address indexed referrer, uint256 commissionAmount);\\n    event RewardLockedUp(address indexed user, uint256 indexed pid, uint256 amountLockedUp);\\n    event AddPool(uint256 indexed pid, uint256 allocPoint, address lpTokenAddress, uint256 depositFeeBP, uint256 harvestInterval, uint256 lastRewardBlock);\\n    event SetPool(uint256 indexed pid, uint256 allocPoint, uint256 depositFeeBP, uint256 harvestInterval);\\n    event SetDevAddress(address previousDevAddress, address newDevAddress);\\n    event SetFeeAddress(address previousFeeAddress, address newFeeAddress);\\n    event SetReferralCommissionRate(uint256 previousReferralCommissionRate, uint256 newReferralCommissionRate);\\n    event SetTenguReferral(address previousTenguReferral, address newTenguReferral);\\n\\n    constructor(\\n        TenguToken _tengu,\\n        uint256 _startBlock,\\n        uint256 _tenguPerBlock\\n    ) public {\\n        tengu = _tengu;\\n        startBlock = _startBlock;\\n        tenguPerBlock = _tenguPerBlock;\\n\\n        devAddress = msg.sender;\\n        feeAddress = msg.sender;\\n    }\\n\\n    function poolLength() external view returns (uint256) {\\n        return poolInfo.length;\\n    }\\n\\n    // Add a new lp to the pool. Can only be called by the owner.\\n    // XXX DO NOT add the same LP token more than once. Rewards will be messed up if you do.\\n    function add(uint256 _allocPoint, IBEP20 _lpToken, uint256 _depositFeeBP, uint256 _harvestInterval, bool _withUpdate) public onlyOwner {\\n        require(_depositFeeBP <= MAXIMUM_DEPOSIT_FEE, \\\"add: invalid deposit fee basis points\\\");\\n        require(_harvestInterval <= MAXIMUM_HARVEST_INTERVAL, \\\"add: invalid harvest interval\\\");\\n\\n        // Test line to ensure the function will fail if the token doesn't exist\\n        _lpToken.balanceOf(address(this));\\n\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        uint256 lastRewardBlock = block.number > startBlock ? block.number : startBlock;\\n        totalAllocPoint = totalAllocPoint.add(_allocPoint);\\n        poolInfo.push(PoolInfo({\\n            lpToken: _lpToken,\\n            allocPoint: _allocPoint,\\n            lastRewardBlock: lastRewardBlock,\\n            accTenguPerShare: 0,\\n            depositFeeBP: _depositFeeBP,\\n            harvestInterval: _harvestInterval,\\n            lpSupply: 0\\n        }));\\n        uint256 pid = poolInfo.length.sub(1);\\n        emit AddPool(pid, _allocPoint, address(_lpToken), _depositFeeBP, _harvestInterval, lastRewardBlock);\\n    }\\n\\n    // Update the given pool's TENGU allocation point and deposit fee. Can only be called by the owner.\\n    function set(uint256 _pid, uint256 _allocPoint, uint256 _depositFeeBP, uint256 _harvestInterval, bool _withUpdate) public onlyOwner {\\n        require(_depositFeeBP <= MAXIMUM_DEPOSIT_FEE, \\\"set: invalid deposit fee basis points\\\");\\n        require(_harvestInterval <= MAXIMUM_HARVEST_INTERVAL, \\\"set: invalid harvest interval\\\");\\n\\n        if (_withUpdate) {\\n            massUpdatePools();\\n        }\\n        totalAllocPoint = totalAllocPoint.sub(poolInfo[_pid].allocPoint).add(_allocPoint);\\n        poolInfo[_pid].allocPoint = _allocPoint;\\n        poolInfo[_pid].depositFeeBP = _depositFeeBP;\\n        poolInfo[_pid].harvestInterval = _harvestInterval;\\n        emit SetPool(_pid, _allocPoint, _depositFeeBP, _harvestInterval);\\n    }\\n\\n    // Return reward multiplier over the given _from to _to block.\\n    function getMultiplier(uint256 _from, uint256 _to) public pure returns (uint256) {\\n        return _to.sub(_from).mul(BONUS_MULTIPLIER);\\n    }\\n\\n    // View function to see pending TENGUs on frontend.\\n    function pendingTengu(uint256 _pid, address _user) external view returns (uint256) {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][_user];\\n        uint256 accTenguPerShare = pool.accTenguPerShare;\\n        if (block.number > pool.lastRewardBlock && pool.lpSupply != 0) {\\n            uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n            uint256 tenguReward = multiplier.mul(tenguPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\n            accTenguPerShare = accTenguPerShare.add(tenguReward.mul(1e12).div(pool.lpSupply));\\n        }\\n        uint256 pending = user.amount.mul(accTenguPerShare).div(1e12).sub(user.rewardDebt);\\n        return pending.add(user.rewardLockedUp);\\n    }\\n\\n    // View function to see if user can harvest TENGUs.\\n    function canHarvest(uint256 _pid, address _user) public view returns (bool) {\\n        UserInfo storage user = userInfo[_pid][_user];\\n        return block.timestamp >= user.nextHarvestUntil;\\n    }\\n\\n    // Update reward variables for all pools. Be careful of gas spending!\\n    function massUpdatePools() public {\\n        uint256 length = poolInfo.length;\\n        for (uint256 pid = 0; pid < length; ++pid) {\\n            _updatePool(pid);\\n        }\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date.\\n    function _updatePool(uint256 _pid) internal {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        if (block.number <= pool.lastRewardBlock) {\\n            return;\\n        }\\n        if (pool.lpSupply == 0 || pool.allocPoint == 0) {\\n            pool.lastRewardBlock = block.number;\\n            return;\\n        }\\n        uint256 multiplier = getMultiplier(pool.lastRewardBlock, block.number);\\n        uint256 tenguReward = multiplier.mul(tenguPerBlock).mul(pool.allocPoint).div(totalAllocPoint);\\n        tengu.mint(devAddress, tenguReward.div(10));\\n        tengu.mint(address(this), tenguReward);\\n        pool.accTenguPerShare = pool.accTenguPerShare.add(tenguReward.mul(1e12).div(pool.lpSupply));\\n        pool.lastRewardBlock = block.number;\\n    }\\n\\n    // Update reward variables of the given pool to be up-to-date (external version w/ non-reentrancy)\\n    function updatePool(uint256 _pid) external nonReentrant {\\n        _updatePool(_pid);\\n    }\\n\\n    // Deposit LP tokens to MasterChef for TENGU allocation.\\n    function deposit(uint256 _pid, uint256 _amount, address _referrer) public nonReentrant {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        _updatePool(_pid);\\n        if (_amount > 0 && address(tenguReferral) != address(0) && _referrer != address(0) && _referrer != msg.sender) {\\n            tenguReferral.recordReferral(msg.sender, _referrer);\\n        }\\n        _payOrLockupPendingTengu(_pid);\\n        if (_amount > 0) {\\n            // To handle correctly the transfer tax tokens w/ the pools\\n            uint256 balanceBefore = pool.lpToken.balanceOf(address(this));\\n            pool.lpToken.safeTransferFrom(address(msg.sender), address(this), _amount);\\n            _amount = pool.lpToken.balanceOf(address(this)).sub(balanceBefore);\\n\\n            if (pool.depositFeeBP > 0) {\\n                uint256 depositFee = _amount.mul(pool.depositFeeBP).div(10000);\\n                pool.lpToken.safeTransfer(feeAddress, depositFee);\\n                user.amount = user.amount.add(_amount).sub(depositFee);\\n                pool.lpSupply = pool.lpSupply.add(_amount).sub(depositFee);\\n            } else {\\n                user.amount = user.amount.add(_amount);\\n                pool.lpSupply = pool.lpSupply.add(_amount);\\n            }\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accTenguPerShare).div(1e12);\\n        emit Deposit(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw LP tokens from MasterChef.\\n    function withdraw(uint256 _pid, uint256 _amount) public nonReentrant {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        require(user.amount >= _amount, \\\"withdraw: not good\\\");\\n\\n        _updatePool(_pid);\\n        _payOrLockupPendingTengu(_pid);\\n        if (_amount > 0) {\\n            user.amount = user.amount.sub(_amount);\\n            pool.lpToken.safeTransfer(address(msg.sender), _amount);\\n            pool.lpSupply = pool.lpSupply.sub(_amount);\\n        }\\n        user.rewardDebt = user.amount.mul(pool.accTenguPerShare).div(1e12);\\n        emit Withdraw(msg.sender, _pid, _amount);\\n    }\\n\\n    // Withdraw without caring about rewards. EMERGENCY ONLY.\\n    function emergencyWithdraw(uint256 _pid) public nonReentrant {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n        uint256 amount = user.amount;\\n        pool.lpSupply = pool.lpSupply.sub(user.amount);\\n        user.amount = 0;\\n        user.rewardDebt = 0;\\n        user.rewardLockedUp = 0;\\n        user.nextHarvestUntil = 0;\\n        pool.lpToken.safeTransfer(address(msg.sender), amount);\\n        emit EmergencyWithdraw(msg.sender, _pid, amount);\\n    }\\n\\n    // Pay or lockup pending TENGUs.\\n    function _payOrLockupPendingTengu(uint256 _pid) internal {\\n        PoolInfo storage pool = poolInfo[_pid];\\n        UserInfo storage user = userInfo[_pid][msg.sender];\\n\\n        if (user.nextHarvestUntil == 0) {\\n            user.nextHarvestUntil = block.timestamp.add(pool.harvestInterval);\\n        }\\n\\n        uint256 pending = user.amount.mul(pool.accTenguPerShare).div(1e12).sub(user.rewardDebt);\\n        if (canHarvest(_pid, msg.sender)) {\\n            if (pending > 0 || user.rewardLockedUp > 0) {\\n                uint256 totalRewards = pending.add(user.rewardLockedUp);\\n\\n                // reset lockup\\n                totalLockedUpRewards = totalLockedUpRewards.sub(user.rewardLockedUp);\\n                user.rewardLockedUp = 0;\\n                user.nextHarvestUntil = block.timestamp.add(pool.harvestInterval);\\n\\n                // send rewards\\n                _safeTenguTransfer(msg.sender, totalRewards);\\n                _payReferralCommission(msg.sender, totalRewards);\\n            }\\n        } else if (pending > 0) {\\n            user.rewardLockedUp = user.rewardLockedUp.add(pending);\\n            totalLockedUpRewards = totalLockedUpRewards.add(pending);\\n            emit RewardLockedUp(msg.sender, _pid, pending);\\n        }\\n    }\\n\\n    // Safe tengu transfer function, just in case if rounding error causes pool to not have enough TENGUs.\\n    function _safeTenguTransfer(address _to, uint256 _amount) internal {\\n        uint256 tenguBal = tengu.balanceOf(address(this));\\n        if (_amount > tenguBal) {\\n            tengu.safeTransfer(_to, tenguBal);\\n        } else {\\n            tengu.safeTransfer(_to, _amount);\\n        }\\n    }\\n\\n    // Update dev address by the previous dev.\\n    function setDevAddress(address _devAddress) public {\\n        require(msg.sender == devAddress, \\\"setDevAddress: FORBIDDEN\\\");\\n        require(_devAddress != address(0), \\\"setDevAddress: ZERO\\\");\\n\\n        address previousDevAddress = devAddress;\\n        devAddress = _devAddress;\\n        emit SetDevAddress(previousDevAddress, devAddress);\\n    }\\n\\n    function setFeeAddress(address _feeAddress) public {\\n        require(msg.sender == feeAddress, \\\"setFeeAddress: FORBIDDEN\\\");\\n        require(_feeAddress != address(0), \\\"setFeeAddress: ZERO\\\");\\n\\n        address previousFeeAddress = feeAddress;\\n        feeAddress = _feeAddress;\\n        emit SetFeeAddress(previousFeeAddress, feeAddress);\\n    }\\n\\n    // Pancake has to add hidden dummy pools in order to alter the emission, here we make it simple and transparent to all.\\n    function updateEmissionRate(uint256 _tenguPerBlock) public onlyOwner {\\n        require(_tenguPerBlock <= MAX_EMISSION_RATE, \\\"TENGU::updateEmissionRate: emission rate must not exceed the the maximum rate\\\");\\n\\n        massUpdatePools();\\n        uint256 previousTenguPerBlock = tenguPerBlock;\\n        tenguPerBlock = _tenguPerBlock;\\n        emit EmissionRateUpdated(previousTenguPerBlock, tenguPerBlock);\\n    }\\n\\n    // Update the tengu referral contract address by the owner\\n    function setTenguReferral(ITenguReferral _tenguReferral) public onlyOwner {\\n        address previousTenguReferral = address(tenguReferral);\\n        tenguReferral = _tenguReferral;\\n        emit SetTenguReferral(previousTenguReferral, address(tenguReferral));\\n    }\\n\\n    // Update referral commission rate by the owner\\n    function setReferralCommissionRate(uint256 _referralCommissionRate) public onlyOwner {\\n        require(_referralCommissionRate <= MAXIMUM_REFERRAL_COMMISSION_RATE, \\\"setReferralCommissionRate: invalid referral commission rate basis points\\\");\\n\\n        uint256 previousReferralCommissionRate = referralCommissionRate;\\n        referralCommissionRate = _referralCommissionRate;\\n        emit SetReferralCommissionRate(previousReferralCommissionRate, referralCommissionRate);\\n    }\\n\\n    // Pay referral commission to the referrer who referred this user.\\n    function _payReferralCommission(address _user, uint256 _pending) internal {\\n        if (address(tenguReferral) != address(0) && referralCommissionRate > 0) {\\n            address referrer = tenguReferral.getReferrer(_user);\\n            uint256 commissionAmount = _pending.mul(referralCommissionRate).div(10000);\\n\\n            if (referrer != address(0) && commissionAmount > 0) {\\n                tengu.mint(referrer, commissionAmount);\\n                tenguReferral.recordReferralCommission(referrer, commissionAmount);\\n                emit ReferralCommissionPaid(_user, referrer, commissionAmount);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ablts/work/tenguswap/farms/contracts/TenguToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./libs/BEP20.sol\\\";\\nimport \\\"./libs/IGreatTengu.sol\\\";\\nimport \\\"./libs/SafeBEP20.sol\\\";\\n\\nimport \\\"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\\\";\\nimport \\\"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\\\";\\n\\n// TenguToken with Governance.\\ncontract TenguToken is BEP20 {\\n    using SafeBEP20 for IGreatTengu;\\n\\n    IGreatTengu public gTengu;\\n    // Transfer tax rate in basis points. (default 8%)\\n    uint256 public transferTaxRate = 800;\\n    // Burn rate % of transfer tax. (default 25% x 8% = 2% of total amount).\\n    uint256 public burnRate = 25;\\n    // Rate % of the gTengu obtained from the transfer tax. (default 50% x 8% = 4% of total amount)\\n    uint256 public gTenguRate = 50;\\n    // Max transfer tax rate: 10%.\\n    uint256 public constant MAXIMUM_TRANSFER_TAX_RATE = 1000;\\n    // Burn address\\n    address public constant BURN_ADDRESS = 0x000000000000000000000000000000000000dEaD;\\n    // Active fee to swap GTENGU to TENGU (default is 20%)\\n    uint256 public swapGTenguToTenguFee = 2000;\\n    // Max fee to swap GTENGU to TENGU (30%)\\n    uint256 public constant SWAP_GTENGU_TO_TENGU_MAX_FEE = 3000;\\n    // List to cancel GTENGU tax to master & pools contracts\\n    mapping(address => bool) public excludedFromGTenguTax;\\n    // Addresses excluded from whole transfer tax\\n    mapping(address => bool) public excludedFromTransferTax;\\n\\n    // Max transfer amount rate in basis points. (default is 0.5% of total supply)\\n    uint256 public maxTransferAmountRate = 50;\\n    // Min. transfer amount rate : 0.3% of total supply\\n    uint256 public constant MIN_TRANSFER_AMOUNT_RATE = 30;\\n    // Addresses that excluded from antiWhale\\n    mapping(address => bool) private _excludedFromAntiWhale;\\n    // Min amount to liquify. (default 50 TENGUs)\\n    uint256 public minAmountToLiquify = 50 ether;\\n    // The swap router, modifiable. Will be changed to TenguSwap's router when our own AMM release\\n    IUniswapV2Router02 public tenguSwapRouter;\\n    // The trading pair\\n    address public tenguSwapPair;\\n    // Not in swap and liquify\\n    bool private _notInSwapAndLiquify = true;\\n    // Set locker contract address\\n    address public locker;\\n\\n    /**\\n    * @notice The operator can update the transfer tax rate and its repartition\\n    * It will be transferred to the timelock contract\\n    */\\n    address private _operator;\\n\\n    /**\\n    * @notice The sensitive operator can update the tenguSwapRouter and the locker address\\n    * It will be transferred to a second timelock contract w/ a much longer duration\\n    */\\n    address private _sensitiveOperator;\\n\\n    // Events\\n    event OperatorTransferred(address indexed previousOperator, address indexed newOperator);\\n    event SensitiveOperatorTransferred(address indexed previousOperator, address indexed newOperator);\\n    event TransferTaxRateUpdated(address indexed operator, uint256 previousRate, uint256 newRate);\\n    event BurnRateUpdated(address indexed operator, uint256 previousRate, uint256 newRate);\\n    event GTenguRateUpdated(address indexed operator, uint256 previousRate, uint256 newRate);\\n    event MaxTransferAmountRateUpdated(address indexed operator, uint256 previousRate, uint256 newRate);\\n    event MinAmountToLiquifyUpdated(address indexed operator, uint256 previousAmount, uint256 newAmount);\\n    event TenguSwapRouterUpdated(address indexed operator, address indexed router, address indexed pair);\\n    event SwapAndLiquify(uint256 tokensSwapped, uint256 ethReceived, uint256 tokensIntoLiqudity);\\n    event SetSwapGTenguToTenguFee(uint256 previousFee, uint256 newFee);\\n    event SwapGTenguToTengu(address indexed sender, address indexed recipient, uint256 gTenguAmount, uint256 tenguAmount);\\n    event LockerUpdated(address previousLocker, address newLocker);\\n    event SetGTenguContractAddress(address gTengu);\\n    event SetExcludedFromAntiWhale(address accountAddress, bool excluded);\\n    event SetExcludedFromGTenguTax(address accountAddress, bool excluded);\\n    event SetExcludedFromTransferTax(address accountAddress, bool excluded);\\n    event BuyBackAndBurn(uint256 ethAmount);\\n\\n    modifier onlyOperator() {\\n        require(_operator == msg.sender, \\\"operator: caller is not the operator\\\");\\n        _;\\n    }\\n\\n    modifier onlySensitiveOperator() {\\n        require(_sensitiveOperator == msg.sender, \\\"operator: caller is not the sensitive operator\\\");\\n        _;\\n    }\\n\\n    modifier antiWhale(address sender, address recipient, uint256 amount) {\\n        if (maxTransferAmount() > 0) {\\n            if (\\n                _excludedFromAntiWhale[sender] == false\\n                && _excludedFromAntiWhale[recipient] == false\\n            ) {\\n                require(amount <= maxTransferAmount(), \\\"TENGU::antiWhale: Transfer amount exceeds the maxTransferAmount\\\");\\n            }\\n        }\\n        _;\\n    }\\n\\n    modifier lockTheSwap {\\n        require(_notInSwapAndLiquify, \\\"TENGU::lockTheSwap: already in\\\");\\n        _notInSwapAndLiquify = false;\\n        _;\\n        _notInSwapAndLiquify = true;\\n    }\\n\\n    modifier transferTaxFree {\\n        uint256 _transferTaxRate = transferTaxRate;\\n        transferTaxRate = 0;\\n        _;\\n        transferTaxRate = _transferTaxRate;\\n    }\\n\\n    /**\\n     * @notice Constructs the TenguToken contract.\\n     */\\n    constructor() public BEP20(\\\"TENGU Token\\\", \\\"TENGU\\\") {\\n        _operator = _msgSender();\\n        emit OperatorTransferred(address(0), _operator);\\n        _sensitiveOperator = _msgSender();\\n        emit SensitiveOperatorTransferred(address(0), _sensitiveOperator);\\n\\n        setExcludedFromAntiWhale(msg.sender,  true);\\n        setExcludedFromAntiWhale(address(0), true);\\n        setExcludedFromAntiWhale(address(this), true);\\n        setExcludedFromAntiWhale(BURN_ADDRESS, true);\\n    }\\n\\n    /// @notice Creates `_amount` token to `_to`. Must only be called by the owner (MasterChef).\\n    function mint(address _to, uint256 _amount) public onlyOwner {\\n        _mint(_to, _amount);\\n    }\\n\\n    /// @dev overrides transfer function to meet tokenomics of TENGU\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual override antiWhale(sender, recipient, amount) {\\n        if (recipient == BURN_ADDRESS || transferTaxRate == 0 || excludedFromTransferTax[sender] || excludedFromTransferTax[recipient]) {\\n            super._transfer(sender, recipient, amount);\\n        } else {\\n            // default tax is 8% of every transfer\\n            uint256 taxAmount = amount.mul(transferTaxRate).div(10000);\\n\\n            // default 92% of transfer sent to recipient\\n            uint256 sendAmount = amount.sub(taxAmount);\\n            require(amount == sendAmount + taxAmount, \\\"TENGU::transfer: Tax value invalid\\\");\\n\\n            uint256 burnAmount = taxAmount.mul(burnRate).div(100);\\n\\n            uint256 toGTenguAmount = taxAmount.mul(gTenguRate).div(100);\\n            // Exclude master and pools from GTengu swap (burn instead)\\n            if (excludedFromGTenguTax[sender]) {\\n                burnAmount = burnAmount.add(toGTenguAmount);\\n                toGTenguAmount = 0;\\n            }\\n\\n            uint256 liquidityAmount = taxAmount.sub(burnAmount).sub(toGTenguAmount);\\n            require(taxAmount == burnAmount + toGTenguAmount + liquidityAmount, \\\"TENGU::transfer: Burn value invalid\\\");\\n\\n            super._transfer(sender, BURN_ADDRESS, burnAmount);\\n            // transfer on this contract the amounts to liquify and to swap to GTengu\\n            super._transfer(sender, address(this), liquidityAmount.add(toGTenguAmount));\\n            super._transfer(sender, recipient, sendAmount);\\n            if (toGTenguAmount > 0) {\\n                gTengu.swapTenguToGTengu(toGTenguAmount, sender);\\n            }\\n        }\\n    }\\n\\n    /// @dev Swap and liquify\\n    function swapAndLiquify() external lockTheSwap transferTaxFree {\\n        require(address(tenguSwapRouter) != address(0), \\\"TENGU::swapAndLiquify: Router not defined\\\");\\n\\n        uint256 contractTokenBalance = balanceOf(address(this));\\n        uint256 maxTransferAmount = maxTransferAmount();\\n        contractTokenBalance = contractTokenBalance > maxTransferAmount ? maxTransferAmount : contractTokenBalance;\\n\\n        if (contractTokenBalance >= minAmountToLiquify) {\\n            // only min amount to liquify\\n            uint256 liquifyAmount = minAmountToLiquify;\\n\\n            // split the liquify amount into halves\\n            uint256 half = liquifyAmount.div(2);\\n            uint256 otherHalf = liquifyAmount.sub(half);\\n\\n            // capture the contract's current ETH balance.\\n            // this is so that we can capture exactly the amount of ETH that the\\n            // swap creates, and not make the liquidity event include any ETH that\\n            // has been manually sent to the contract\\n            uint256 initialBalance = address(this).balance;\\n\\n            // swap tokens for ETH\\n            swapTokensForEth(half);\\n\\n            // how much ETH did we just swap into?\\n            uint256 newBalance = address(this).balance.sub(initialBalance);\\n\\n            // add liquidity\\n            addLiquidity(otherHalf, newBalance);\\n\\n            emit SwapAndLiquify(half, newBalance, otherHalf);\\n        }\\n    }\\n\\n    /// @dev Swap tokens for eth\\n    function swapTokensForEth(uint256 tokenAmount) private {\\n        // generate the tenguSwap pair path of token -> weth\\n        address[] memory path = new address[](2);\\n        path[0] = address(this);\\n        path[1] = tenguSwapRouter.WETH();\\n\\n        _approve(address(this), address(tenguSwapRouter), tokenAmount);\\n\\n        // make the swap\\n        tenguSwapRouter.swapExactTokensForETHSupportingFeeOnTransferTokens(\\n            tokenAmount,\\n            0, // accept any amount of ETH\\n            path,\\n            address(this),\\n            block.timestamp\\n        );\\n    }\\n\\n    /// @dev Add liquidity\\n    function addLiquidity(uint256 tokenAmount, uint256 ethAmount) private {\\n        require(locker != address(0), \\\"TENGU::addLiquidity: locker address must be set\\\");\\n\\n        // approve token transfer to cover all possible scenarios\\n        _approve(address(this), address(tenguSwapRouter), tokenAmount);\\n\\n        // add the liquidity\\n        tenguSwapRouter.addLiquidityETH{value: ethAmount}(\\n            address(this),\\n            tokenAmount,\\n            0, // slippage is unavoidable\\n            0, // slippage is unavoidable\\n            locker,\\n            block.timestamp\\n        );\\n    }\\n\\n    /**\\n     * @dev Returns the max transfer amount.\\n     */\\n    function maxTransferAmount() public view returns (uint256) {\\n        return totalSupply().mul(maxTransferAmountRate).div(10000);\\n    }\\n\\n    /**\\n     * @dev Returns the address is excluded from antiWhale or not.\\n     */\\n    function isExcludedFromAntiWhale(address _account) public view returns (bool) {\\n        return _excludedFromAntiWhale[_account];\\n    }\\n\\n    // To receive BNB from tenguSwapRouter when swapping\\n    receive() external payable {}\\n\\n    /**\\n     * @dev Update the transfer tax rate.\\n     * Can only be called by the current operator.\\n     */\\n    function updateTransferTaxRate(uint256 _transferTaxRate) public onlyOperator {\\n        require(_transferTaxRate <= MAXIMUM_TRANSFER_TAX_RATE, \\\"TENGU::updateTransferTaxRate: Transfer tax rate must not exceed the maximum rate.\\\");\\n\\n        uint256 previousTransferTaxRate = transferTaxRate;\\n        transferTaxRate = _transferTaxRate;\\n        emit TransferTaxRateUpdated(msg.sender, previousTransferTaxRate, transferTaxRate);\\n    }\\n\\n    /**\\n     * @dev Update the burn rate.\\n     * Can only be called by the current operator.\\n     */\\n    function updateBurnRate(uint256 _burnRate) public onlyOperator {\\n        require(_burnRate.add(gTenguRate) <= 100, \\\"TENGU::updateBurnRate: GTengu + burn rates must not exceed the maximum rate.\\\");\\n\\n        uint256 previousBurnRate = burnRate;\\n        burnRate = _burnRate;\\n        emit BurnRateUpdated(msg.sender, previousBurnRate, burnRate);\\n    }\\n\\n    /**\\n     * @dev Update the burn rate.\\n     * Can only be called by the current operator.\\n     */\\n    function updateGTenguRate(uint256 _gTenguRate) public onlyOperator {\\n        require(burnRate.add(_gTenguRate) <= 100, \\\"TENGU::updateGTenguRate: GTengu + burn rates must not exceed the maximum rate.\\\");\\n\\n        uint256 previousGTenguRate = gTenguRate;\\n        gTenguRate = _gTenguRate;\\n        emit GTenguRateUpdated(msg.sender, previousGTenguRate, gTenguRate);\\n    }\\n\\n    /**\\n     * @dev Update the max transfer amount rate.\\n     * Can only be called by the current operator.\\n     */\\n    function updateMaxTransferAmountRate(uint256 _maxTransferAmountRate) public onlyOperator {\\n        require(_maxTransferAmountRate <= 50, \\\"TENGU::updateMaxTransferAmountRate: Max transfer amount rate must not exceed the maximum rate.\\\");\\n        require(_maxTransferAmountRate >= MIN_TRANSFER_AMOUNT_RATE, \\\"TENGU::updateMaxTransferAmountRate: Min transfer amount rate must be above the minimum rate.\\\");\\n\\n        uint256 previousMaxTransferAmountRate = maxTransferAmountRate;\\n        maxTransferAmountRate = _maxTransferAmountRate;\\n        emit MaxTransferAmountRateUpdated(msg.sender, previousMaxTransferAmountRate, maxTransferAmountRate);\\n    }\\n\\n    /**\\n     * @dev Update the min amount to liquify.\\n     * Can only be called by the current operator.\\n     */\\n    function updateMinAmountToLiquify(uint256 _minAmount) public onlyOperator {\\n        uint256 previousMinAmountToLiquify = minAmountToLiquify;\\n        minAmountToLiquify = _minAmount;\\n        emit MinAmountToLiquifyUpdated(msg.sender, previousMinAmountToLiquify, minAmountToLiquify);\\n    }\\n\\n    /**\\n     * @dev Exclude or include an address from antiWhale.\\n     * Can only be called by the current operator.\\n     */\\n    function setExcludedFromAntiWhale(address _account, bool _excluded) public onlyOperator {\\n        _excludedFromAntiWhale[_account] = _excluded;\\n        emit SetExcludedFromAntiWhale(_account, _excluded);\\n    }\\n\\n    /**\\n     * @dev Update the swap router.\\n     * Can only be called by the current sensitiveOperator.\\n     */\\n    function updateTenguSwapRouter(address _router) public onlySensitiveOperator {\\n        tenguSwapRouter = IUniswapV2Router02(_router);\\n        tenguSwapPair = IUniswapV2Factory(tenguSwapRouter.factory()).getPair(address(this), tenguSwapRouter.WETH());\\n        require(tenguSwapPair != address(0), \\\"TENGU::updateTenguSwapRouter: Invalid pair address.\\\");\\n        emit TenguSwapRouterUpdated(msg.sender, address(tenguSwapRouter), tenguSwapPair);\\n    }\\n\\n    /**\\n     * @dev Update the tengu locker contract.\\n     * Can only be called by the current sensitiveOperator.\\n     */\\n    function updateLocker(address _locker) public onlySensitiveOperator {\\n        require(_locker != address(0), \\\"TENGU::updateTenguLocker: new operator is the zero address\\\");\\n\\n        address previousLocker = locker;\\n        locker = _locker;\\n        // Remove previous locker from anti-whale\\n        if (address(previousLocker) != address(0)) {\\n            setExcludedFromAntiWhale(address(previousLocker), false);\\n        }\\n        // Exclude new locker from anti-whale\\n        setExcludedFromAntiWhale(address(locker), true);\\n        emit LockerUpdated(previousLocker, locker);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current operator.\\n     */\\n    function operator() public view returns (address) {\\n        return _operator;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current sensitive operator.\\n     */\\n    function sensitiveOperator() public view returns (address) {\\n        return _sensitiveOperator;\\n    }\\n\\n    /**\\n     * @dev Transfers operator of the contract to a new account (`newOperator`).\\n     * Can only be called by the current operator.\\n     */\\n    function transferOperator(address newOperator) public onlyOperator {\\n        require(newOperator != address(0), \\\"TENGU::transferOperator: new operator is the zero address\\\");\\n\\n        address previousOperator = _operator;\\n        _operator = newOperator;\\n        emit OperatorTransferred(previousOperator, _operator);\\n    }\\n\\n    /**\\n     * @dev Transfers sensitiveOperator of the contract to a new account (`newOperator`).\\n     * Can only be called by the current sensitiveOperator.\\n     */\\n    function transferSensitiveOperator(address newOperator) public onlySensitiveOperator {\\n        require(newOperator != address(0), \\\"TENGU::transferSensitiveOperator: new operator is the zero address\\\");\\n\\n        address previousOperator = _operator;\\n        _sensitiveOperator = newOperator;\\n        emit SensitiveOperatorTransferred(previousOperator, _sensitiveOperator);\\n    }\\n\\n    /**\\n     * @dev Swap an amount of GTengu for the corresponding amount of newly minted Tengu. Burn the swapped GTengu.\\n     */\\n    function _swapGTenguToTengu(address sender, address recipient, uint256 amount) internal {\\n        require(amount > 0, \\\"TENGU::swapGTenguToTengu: amount 0\\\");\\n        require(gTengu.balanceOf(sender) >= amount, \\\"TENGU::swapGTenguToTengu: not enough GTENGU\\\");\\n\\n        uint256 tenguAmount = getSwapGTenguToTenguAmount(amount);\\n        _mint(recipient, tenguAmount);\\n        gTengu.safeTransferFrom(sender, BURN_ADDRESS, amount);\\n        emit SwapGTenguToTengu(sender, recipient, amount, tenguAmount);\\n    }\\n\\n    function swapGTenguToTengu(uint256 amount) external {\\n        _swapGTenguToTengu(msg.sender, msg.sender, amount);\\n    }\\n\\n    function swapGTenguToTengu(uint256 amount, address recipient) external {\\n        _swapGTenguToTengu(msg.sender, recipient, amount);\\n    }\\n\\n    /**\\n     * @dev Set the fee when swapping GTengu for Tengu.\\n     * Can only be called by the current operator.\\n     */\\n    function setSwapGTenguToTenguFee(uint256 fee) external onlyOperator {\\n        require(fee <= SWAP_GTENGU_TO_TENGU_MAX_FEE, \\\"TENGU::setSwapGTenguToTenguFee: fee too high\\\");\\n\\n        uint256 previousFee = swapGTenguToTenguFee;\\n        swapGTenguToTenguFee = fee;\\n        emit SetSwapGTenguToTenguFee(previousFee, swapGTenguToTenguFee);\\n    }\\n\\n    /**\\n     * @dev Returns the amount of Tengu obtainable for swapping 'amount' of GTengu.\\n     */\\n    function getSwapGTenguToTenguAmount(uint256 amount) public view returns (uint256 tenguAmount) {\\n        uint256 fee = amount.mul(swapGTenguToTenguFee).div(10000);\\n        return amount.sub(fee);\\n    }\\n\\n    /**\\n     * @dev Set the GTengu contract address.\\n     * Can only be called by the current operator.\\n     * Can only be called once.\\n     */\\n    function setGTenguContractAddress(IGreatTengu gTengu_) external onlyOperator {\\n        require(address(gTengu) == address(0), \\\"TENGU::setGTenguContractAddress: already initialized\\\");\\n\\n        gTengu = gTengu_;\\n        // Exclude GTengu contract from anti-whale\\n        setExcludedFromAntiWhale(address(gTengu), true);\\n        // Authorize GTengu contract to transfer (to the burn address) the Tengu we want to swap to GTengu\\n        // cf GreatTenguToken._swapToGTengu()\\n        _approve(address(this), address(gTengu), uint256(-1));\\n        emit SetGTenguContractAddress(address(gTengu));\\n    }\\n\\n    /**\\n     * @dev Exclude or include an address from transfer tax.\\n     * Used for the Master and some internal project addresses\\n     * Can only be called by the current operator.\\n     */\\n    function setExcludedFromTransferTax(address _account, bool _excluded) public onlyOperator {\\n        excludedFromTransferTax[_account] = _excluded;\\n        emit SetExcludedFromTransferTax(_account, _excluded);\\n    }\\n\\n    /**\\n     * @dev Exclude or include an address from GTengu tax.\\n     * Used for the Master and the Tengu pools.\\n     * Can only be called by the current operator.\\n     */\\n    function setExcludedFromGTenguTax(address _account, bool _excluded) public onlyOperator {\\n        excludedFromGTenguTax[_account] = _excluded;\\n        emit SetExcludedFromGTenguTax(_account, _excluded);\\n    }\\n\\n    /**\\n     * @dev To handle the BNB dust that may build up on the contract\\n     * Use the BNB to buy back and burn TENGU\\n     */\\n    function buyBackAndBurn() external onlyOperator {\\n        // generate the tenguSwap pair path of weth -> token\\n        address[] memory path = new address[](2);\\n        path[0] = tenguSwapRouter.WETH();\\n        path[1] = address(this);\\n\\n        uint256 ethAmount = address(this).balance;\\n        // make the swap\\n        tenguSwapRouter.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount}(\\n            0, // accept any amount of TENGU\\n            path,\\n            BURN_ADDRESS,\\n            block.timestamp\\n        );\\n        emit BuyBackAndBurn(ethAmount);\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"/home/ablts/work/tenguswap/farms/contracts/libs/BEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.4.0;\\n\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Context.sol\\\";\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IBEP20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {BEP20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-BEP20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of BEP20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IBEP20-approve}.\\n */\\ncontract BEP20 is Context, IBEP20, Ownable {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    mapping(address => uint256) private _balances;\\n\\n    mapping(address => mapping(address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor(string memory name, string memory symbol) public {\\n        _name = name;\\n        _symbol = symbol;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external override view returns (address) {\\n        return owner();\\n    }\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() public override view returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() public override view returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() public override view returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-totalSupply}.\\n     */\\n    function totalSupply() public override view returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-balanceOf}.\\n     */\\n    function balanceOf(address account) public override view returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {BEP20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public override view returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {BEP20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {BEP20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {BEP20};\\n     *\\n     * Requirements:\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for `sender`'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) public override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(\\n            sender,\\n            _msgSender(),\\n            _allowances[sender][_msgSender()].sub(amount, \\\"BEP20: transfer amount exceeds allowance\\\")\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {BEP20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {BEP20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\\n        _approve(\\n            _msgSender(),\\n            spender,\\n            _allowances[_msgSender()][spender].sub(subtractedValue, \\\"BEP20: decreased allowance below zero\\\")\\n        );\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) internal virtual {\\n        require(sender != address(0), \\\"BEP20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"BEP20: transfer to the zero address\\\");\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"BEP20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"BEP20: mint to the zero address\\\");\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal {\\n        require(account != address(0), \\\"BEP20: burn from the zero address\\\");\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"BEP20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\\n     *\\n     * This is internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(\\n        address owner,\\n        address spender,\\n        uint256 amount\\n    ) internal {\\n        require(owner != address(0), \\\"BEP20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"BEP20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`.`amount` is then deducted\\n     * from the caller's allowance.\\n     *\\n     * See {_burn} and {_approve}.\\n     */\\n    function _burnFrom(address account, uint256 amount) internal {\\n        _burn(account, amount);\\n        _approve(\\n            account,\\n            _msgSender(),\\n            _allowances[account][_msgSender()].sub(amount, \\\"BEP20: burn amount exceeds allowance\\\")\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"/home/ablts/work/tenguswap/farms/contracts/libs/IBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: GPL-3.0-or-later\\n\\npragma solidity >=0.4.0;\\n\\ninterface IBEP20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the token decimals.\\n     */\\n    function decimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns the token symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the bep token owner.\\n     */\\n    function getOwner() external view returns (address);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address _owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\"\r\n    },\r\n    \"/home/ablts/work/tenguswap/farms/contracts/libs/IGreatTengu.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IBEP20.sol\\\";\\n\\n\\ninterface IGreatTengu is IBEP20 {\\n    function swapTenguToGTengu(uint256 amount) external;\\n    function swapTenguToGTengu(uint256 amount, address recipient) external;\\n}\\n\"\r\n    },\r\n    \"/home/ablts/work/tenguswap/farms/contracts/libs/ITenguReferral.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\ninterface ITenguReferral {\\n    /**\\n     * @dev Record referral.\\n     */\\n    function recordReferral(address user, address referrer) external;\\n\\n    /**\\n     * @dev Record referral commission.\\n     */\\n    function recordReferralCommission(address referrer, uint256 commission) external;\\n\\n    /**\\n     * @dev Get the referrer address that referred the user.\\n     */\\n    function getReferrer(address user) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"/home/ablts/work/tenguswap/farms/contracts/libs/SafeBEP20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.6.0;\\n\\nimport \\\"./IBEP20.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\n\\n/**\\n * @title SafeBEP20\\n * @dev Wrappers around BEP20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeBEP20 for IBEP20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeBEP20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IBEP20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IBEP20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IBEP20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IBEP20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeBEP20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IBEP20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IBEP20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(\\n            value,\\n            \\\"SafeBEP20: decreased allowance below zero\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IBEP20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeBEP20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeBEP20: BEP20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor () internal {\\n        address msgSender = _msgSender();\\n        _owner = msgSender;\\n        emit OwnershipTransferred(address(0), msgSender);\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        emit OwnershipTransferred(_owner, address(0));\\n        _owner = address(0);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        emit OwnershipTransferred(_owner, newOwner);\\n        _owner = newOwner;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/math/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor () internal {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and make it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n\\n        _;\\n\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Factory {\\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\\n\\n    function feeTo() external view returns (address);\\n    function feeToSetter() external view returns (address);\\n\\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\\n    function allPairs(uint) external view returns (address pair);\\n    function allPairsLength() external view returns (uint);\\n\\n    function createPair(address tokenA, address tokenB) external returns (address pair);\\n\\n    function setFeeTo(address) external;\\n    function setFeeToSetter(address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\": {\r\n      \"content\": \"pragma solidity >=0.5.0;\\n\\ninterface IUniswapV2Pair {\\n    event Approval(address indexed owner, address indexed spender, uint value);\\n    event Transfer(address indexed from, address indexed to, uint value);\\n\\n    function name() external pure returns (string memory);\\n    function symbol() external pure returns (string memory);\\n    function decimals() external pure returns (uint8);\\n    function totalSupply() external view returns (uint);\\n    function balanceOf(address owner) external view returns (uint);\\n    function allowance(address owner, address spender) external view returns (uint);\\n\\n    function approve(address spender, uint value) external returns (bool);\\n    function transfer(address to, uint value) external returns (bool);\\n    function transferFrom(address from, address to, uint value) external returns (bool);\\n\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\\n    function nonces(address owner) external view returns (uint);\\n\\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    event Mint(address indexed sender, uint amount0, uint amount1);\\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\\n    event Swap(\\n        address indexed sender,\\n        uint amount0In,\\n        uint amount1In,\\n        uint amount0Out,\\n        uint amount1Out,\\n        address indexed to\\n    );\\n    event Sync(uint112 reserve0, uint112 reserve1);\\n\\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\\n    function factory() external view returns (address);\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function price0CumulativeLast() external view returns (uint);\\n    function price1CumulativeLast() external view returns (uint);\\n    function kLast() external view returns (uint);\\n\\n    function mint(address to) external returns (uint liquidity);\\n    function burn(address to) external returns (uint amount0, uint amount1);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n    function skim(address to) external;\\n    function sync() external;\\n\\n    function initialize(address, address) external;\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\ninterface IUniswapV2Router01 {\\n    function factory() external pure returns (address);\\n    function WETH() external pure returns (address);\\n\\n    function addLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint amountADesired,\\n        uint amountBDesired,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB, uint liquidity);\\n    function addLiquidityETH(\\n        address token,\\n        uint amountTokenDesired,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\\n    function removeLiquidity(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETH(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountToken, uint amountETH);\\n    function removeLiquidityWithPermit(\\n        address tokenA,\\n        address tokenB,\\n        uint liquidity,\\n        uint amountAMin,\\n        uint amountBMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountA, uint amountB);\\n    function removeLiquidityETHWithPermit(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountToken, uint amountETH);\\n    function swapExactTokensForTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapTokensForExactTokens(\\n        uint amountOut,\\n        uint amountInMax,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external returns (uint[] memory amounts);\\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\\n        external\\n        returns (uint[] memory amounts);\\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\\n        external\\n        payable\\n        returns (uint[] memory amounts);\\n\\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\\n}\\n\"\r\n    },\r\n    \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\": {\r\n      \"content\": \"pragma solidity >=0.6.2;\\n\\nimport './IUniswapV2Router01.sol';\\n\\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline\\n    ) external returns (uint amountETH);\\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\\n        address token,\\n        uint liquidity,\\n        uint amountTokenMin,\\n        uint amountETHMin,\\n        address to,\\n        uint deadline,\\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\\n    ) external returns (uint amountETH);\\n\\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external payable;\\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\\n        uint amountIn,\\n        uint amountOutMin,\\n        address[] calldata path,\\n        address to,\\n        uint deadline\\n    ) external;\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": false,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"istanbul\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract TenguToken\",\"name\":\"_tengu\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_tenguPerBlock\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositFeeBP\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"harvestInterval\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"}],\"name\":\"AddPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EmergencyWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"EmissionRateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"commissionAmount\",\"type\":\"uint256\"}],\"name\":\"ReferralCommissionPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountLockedUp\",\"type\":\"uint256\"}],\"name\":\"RewardLockedUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousDevAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newDevAddress\",\"type\":\"address\"}],\"name\":\"SetDevAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousFeeAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeAddress\",\"type\":\"address\"}],\"name\":\"SetFeeAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"depositFeeBP\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"harvestInterval\",\"type\":\"uint256\"}],\"name\":\"SetPool\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"previousReferralCommissionRate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newReferralCommissionRate\",\"type\":\"uint256\"}],\"name\":\"SetReferralCommissionRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"previousTenguReferral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newTenguReferral\",\"type\":\"address\"}],\"name\":\"SetTenguReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BONUS_MULTIPLIER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_DEPOSIT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_HARVEST_INTERVAL\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAXIMUM_REFERRAL_COMMISSION_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MAX_EMISSION_RATE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"contract IBEP20\",\"name\":\"_lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_depositFeeBP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_harvestInterval\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"add\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"canHarvest\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"devAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"emergencyWithdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_from\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"getMultiplier\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"massUpdatePools\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"pendingTengu\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolInfo\",\"outputs\":[{\"internalType\":\"contract IBEP20\",\"name\":\"lpToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastRewardBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"accTenguPerShare\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"depositFeeBP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"harvestInterval\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpSupply\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"referralCommissionRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_allocPoint\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_depositFeeBP\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_harvestInterval\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_withUpdate\",\"type\":\"bool\"}],\"name\":\"set\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_devAddress\",\"type\":\"address\"}],\"name\":\"setDevAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeAddress\",\"type\":\"address\"}],\"name\":\"setFeeAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_referralCommissionRate\",\"type\":\"uint256\"}],\"name\":\"setReferralCommissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITenguReferral\",\"name\":\"_tenguReferral\",\"type\":\"address\"}],\"name\":\"setTenguReferral\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tengu\",\"outputs\":[{\"internalType\":\"contract TenguToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tenguPerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tenguReferral\",\"outputs\":[{\"internalType\":\"contract ITenguReferral\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAllocPoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalLockedUpRewards\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tenguPerBlock\",\"type\":\"uint256\"}],\"name\":\"updateEmissionRate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"updatePool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardDebt\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rewardLockedUp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nextHarvestUntil\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MasterChef", "CompilerVersion": "v0.6.12+commit.27d51765", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "0000000000000000000000006f6350d5d347aa8f7e9731756b60b774a7acf95b00000000000000000000000000000000000000000000000000000000011b6b7f0000000000000000000000000000000000000000000000005c9099a92bdb0000", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}