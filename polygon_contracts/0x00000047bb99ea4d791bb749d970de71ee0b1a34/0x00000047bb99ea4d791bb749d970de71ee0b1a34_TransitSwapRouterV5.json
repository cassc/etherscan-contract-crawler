{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"TransitSwapRouterV5.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./UniswapV2Router.sol\\\";\\nimport \\\"./UniswapV3Router.sol\\\";\\nimport \\\"./AggregateRouter.sol\\\";\\nimport \\\"./CrossRouter.sol\\\";\\n\\ncontract TransitSwapRouterV5 is UniswapV2Router, UniswapV3Router, AggregateRouter, CrossRouter  {\\n\\n    function withdrawTokens(address[] memory tokens, address recipient) external onlyExecutor {\\n        for (uint index; index < tokens.length; index++) {\\n            uint amount;\\n            if (TransferHelper.isETH(tokens[index])) {\\n                amount = address(this).balance;\\n                TransferHelper.safeTransferETH(recipient, amount);\\n            } else {\\n                amount = IERC20(tokens[index]).balanceOf(address(this));\\n                TransferHelper.safeTransferWithoutRequire(tokens[index], recipient, amount);\\n            }\\n            emit Withdraw(tokens[index], msg.sender, recipient, amount);\\n        }\\n    }\\n}\"\r\n    },\r\n    \"CrossRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseCore.sol\\\";\\n\\ncontract CrossRouter is BaseCore {\\n\\n    using SafeMath for uint256;\\n\\n    constructor() {}\\n\\n    function cross(CrossDescription calldata desc) external payable nonReentrant whenNotPaused {\\n        require(desc.calls.length > 0, \\\"data should be not zero\\\");\\n        require(desc.amount > 0, \\\"amount should be greater than 0\\\");\\n        require(_cross_caller_allowed[desc.caller], \\\"invalid caller\\\");\\n        uint256 swapAmount;\\n        uint256 actualAmountIn = calculateTradeFee(false, desc.amount, desc.fee, desc.signature);\\n        if (TransferHelper.isETH(desc.srcToken)) {\\n            require(msg.value == desc.amount, \\\"invalid msg.value\\\");\\n            swapAmount = actualAmountIn;\\n            if (desc.wrappedToken != address(0)) {\\n                require(_wrapped_allowed[desc.wrappedToken], \\\"Invalid wrapped address\\\");\\n                TransferHelper.safeDeposit(desc.wrappedToken, swapAmount);\\n                TransferHelper.safeApprove(desc.wrappedToken, desc.caller, swapAmount);\\n                swapAmount = 0;\\n            }\\n        } else {\\n            TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\\n            TransferHelper.safeApprove(desc.srcToken, desc.caller, actualAmountIn);\\n        }\\n\\n        {\\n            (bool success, bytes memory result) = desc.caller.call{value:swapAmount}(desc.calls);\\n            if (!success) {\\n                revert(RevertReasonParser.parse(result, \\\"TransitCrossV5:\\\"));\\n            }\\n        }\\n\\n        _emitTransit(desc.srcToken, desc.dstToken, desc.dstReceiver, desc.amount, 0, desc.toChain, desc.channel);\\n    } \\n}\"\r\n    },\r\n    \"AggregateRouter.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseCore.sol\\\";\\n\\ncontract AggregateRouter is BaseCore {\\n\\n    using SafeMath for uint256;\\n\\n    constructor() {\\n\\n    }\\n\\n    function aggregateAndGasUsed(TransitSwapDescription calldata desc, CallbytesDescription calldata callbytesDesc) external payable returns (uint256 returnAmount, uint256 gasUsed) {\\n        uint256 gasLeftBefore = gasleft();\\n        returnAmount = _executeAggregate(desc, callbytesDesc);\\n        gasUsed = gasLeftBefore - gasleft();\\n    }\\n\\n    function aggregate(TransitSwapDescription calldata desc, CallbytesDescription calldata callbytesDesc) external payable returns (uint256 returnAmount) {\\n        returnAmount = _executeAggregate(desc, callbytesDesc);\\n    }\\n\\n    function _executeAggregate(TransitSwapDescription calldata desc, CallbytesDescription calldata callbytesDesc) internal nonReentrant whenNotPaused returns (uint256 returnAmount) {\\n        require(callbytesDesc.calldatas.length > 0, \\\"data should be not zero\\\");\\n        require(desc.amount > 0, \\\"amount should be greater than 0\\\");\\n        require(desc.dstReceiver != address(0), \\\"receiver should be not address(0)\\\");\\n        require(desc.minReturnAmount > 0, \\\"minReturnAmount should be greater than 0\\\");\\n        require(_wrapped_allowed[desc.wrappedToken], \\\"invalid wrapped address\\\");\\n\\n        uint256 actualAmountIn = calculateTradeFee(true, desc.amount, desc.fee, desc.signature);\\n        uint256 swapAmount;\\n        uint256 toBeforeBalance;\\n        address bridgeAddress = _aggregate_bridge;\\n        if (TransferHelper.isETH(desc.srcToken)) {\\n            require(msg.value == desc.amount, \\\"invalid msg.value\\\");\\n            swapAmount = actualAmountIn;\\n        } else {\\n            TransferHelper.safeTransferFrom(desc.srcToken, msg.sender, address(this), desc.amount);\\n            TransferHelper.safeTransfer(desc.srcToken, bridgeAddress, actualAmountIn);\\n        }\\n\\n        if (TransferHelper.isETH(desc.dstToken)) {\\n            toBeforeBalance = desc.dstReceiver.balance;\\n        } else {\\n            toBeforeBalance = IERC20(desc.dstToken).balanceOf(desc.dstReceiver);\\n        }\\n\\n        {\\n            //bytes4(keccak256(bytes('callbytes(CallbytesDescription)')));\\n            (bool success, bytes memory result) = bridgeAddress.call{value : swapAmount}(abi.encodeWithSelector(0x3f3204d2, callbytesDesc));\\n            if (!success) {\\n                revert(RevertReasonParser.parse(result, \\\"TransitSwap:\\\"));\\n            }\\n        }\\n\\n        if (TransferHelper.isETH(desc.dstToken)) {\\n            returnAmount = desc.dstReceiver.balance.sub(toBeforeBalance);\\n        } else {\\n            returnAmount = IERC20(desc.dstToken).balanceOf(desc.dstReceiver).sub(toBeforeBalance);\\n        }\\n        require(returnAmount >= desc.minReturnAmount, \\\"Too little received\\\");\\n\\n        _emitTransit(desc.srcToken, desc.dstToken, desc.dstReceiver, desc.amount, returnAmount, 0, desc.channel);\\n\\n    }\\n}\"\r\n    },\r\n    \"UniswapV3Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseCore.sol\\\";\\n\\ncontract UniswapV3Router is BaseCore {\\n\\n    using SafeMath for uint256;\\n\\n    uint256 private constant _ZERO_FOR_ONE_MASK = 1 << 255;\\n    uint160 private constant MIN_SQRT_RATIO = 4295128739;\\n    uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    constructor() {}\\n\\n    fallback() external {\\n        (int256 amount0Delta, int256 amount1Delta, bytes memory _data) = abi.decode(msg.data[4:], (int256,int256,bytes));\\n        _executeCallback(amount0Delta, amount1Delta, _data);\\n    }\\n\\n    function pancakeV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata _data\\n    ) external {\\n        _executeCallback(amount0Delta, amount1Delta, _data);\\n    }\\n\\n    function uniswapV3SwapCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes calldata _data\\n    ) external {\\n        _executeCallback(amount0Delta, amount1Delta, _data);\\n    }\\n\\n    function _executeCallback(\\n        int256 amount0Delta,\\n        int256 amount1Delta,\\n        bytes memory _data\\n    ) internal {\\n        require(amount0Delta > 0 || amount1Delta > 0, \\\"M0 or M1\\\"); // swaps entirely within 0-liquidity regions are not supported\\n        (uint256 pool, bytes memory tokenInAndPoolSalt) = abi.decode(_data, (uint256, bytes));\\n        (address tokenIn, bytes32 poolSalt) = abi.decode(tokenInAndPoolSalt, (address, bytes32));\\n        _verifyCallback(pool, poolSalt, msg.sender);\\n\\n        uint256 amountToPay = uint256(amount1Delta);\\n        if (amount0Delta > 0) {\\n            amountToPay = uint256(amount0Delta);\\n        }\\n\\n        TransferHelper.safeTransfer(tokenIn, msg.sender, amountToPay);\\n    }\\n\\n    function exactInputV3SwapAndGasUsed(ExactInputV3SwapParams calldata params) external payable returns (uint256 returnAmount, uint256 gasUsed) {\\n        uint256 gasLeftBefore = gasleft();\\n        returnAmount = _executeV3Swap(params);\\n        gasUsed = gasLeftBefore - gasleft();\\n\\n    }\\n\\n    function exactInputV3Swap(ExactInputV3SwapParams calldata params) external payable returns (uint256 returnAmount) {\\n        returnAmount = _executeV3Swap(params);\\n    }\\n\\n    function _executeV3Swap(ExactInputV3SwapParams calldata params) internal nonReentrant whenNotPaused returns (uint256 returnAmount) {\\n        require(params.pools.length > 0, \\\"Empty pools\\\");\\n        require(params.deadline >= block.timestamp, \\\"Expired\\\");\\n        require(_wrapped_allowed[params.wrappedToken], \\\"Invalid wrapped address\\\");\\n        address tokenIn = params.srcToken;\\n        address tokenOut = params.dstToken;\\n        uint256 actualAmountIn = calculateTradeFee(true, params.amount, params.fee, params.signature);\\n        uint256 toBeforeBalance;\\n        bool isToETH;\\n        if (TransferHelper.isETH(params.srcToken)) {\\n            tokenIn = params.wrappedToken;\\n            require(msg.value == params.amount, \\\"Invalid msg.value\\\");\\n            TransferHelper.safeDeposit(params.wrappedToken, actualAmountIn);\\n        } else {\\n            TransferHelper.safeTransferFrom(params.srcToken, msg.sender, address(this), params.amount);\\n        }\\n\\n        if (TransferHelper.isETH(params.dstToken)) {\\n            tokenOut = params.wrappedToken;\\n            toBeforeBalance = IERC20(params.wrappedToken).balanceOf(address(this));\\n            isToETH = true;\\n        } else {\\n            toBeforeBalance = IERC20(params.dstToken).balanceOf(params.dstReceiver);\\n        }\\n\\n        {\\n            uint256 len = params.pools.length;\\n            address recipient = address(this);\\n            bytes memory tokenInAndPoolSalt;\\n            if (len > 1) {\\n                address thisTokenIn = tokenIn;\\n                address thisTokenOut = address(0);\\n                for (uint256 i; i < len; i++) {\\n                    uint256 thisPool = params.pools[i];\\n                    (thisTokenIn, tokenInAndPoolSalt) = _verifyPool(thisTokenIn, thisTokenOut, thisPool);\\n                    if (i == len - 1 && !isToETH) {\\n                        recipient = params.dstReceiver;\\n                        thisTokenOut = tokenOut;\\n                    } \\n                    actualAmountIn = _swap(recipient, thisPool, tokenInAndPoolSalt, actualAmountIn);\\n                }\\n                returnAmount = actualAmountIn;\\n            } else {\\n                (, tokenInAndPoolSalt) = _verifyPool(tokenIn, tokenOut, params.pools[0]);\\n                if (!isToETH) {\\n                    recipient = params.dstReceiver;\\n                }\\n                returnAmount = _swap(recipient, params.pools[0], tokenInAndPoolSalt, actualAmountIn);\\n            }\\n        }\\n\\n        if (isToETH) {\\n            returnAmount = IERC20(params.wrappedToken).balanceOf(address(this)).sub(toBeforeBalance);\\n            require(returnAmount >= params.minReturnAmount, \\\"Too little received\\\");\\n            TransferHelper.safeWithdraw(params.wrappedToken, returnAmount);\\n            TransferHelper.safeTransferETH(params.dstReceiver, returnAmount);\\n        } else {\\n            returnAmount = IERC20(params.dstToken).balanceOf(params.dstReceiver).sub(toBeforeBalance);\\n            require(returnAmount >= params.minReturnAmount, \\\"Too little received\\\");\\n        }\\n        \\n        _emitTransit(params.srcToken, params.dstToken, params.dstReceiver, params.amount, returnAmount, 0, params.channel);\\n\\n    }\\n\\n    function _swap(address recipient, uint256 pool, bytes memory tokenInAndPoolSalt, uint256 amount) internal returns (uint256 amountOut) {\\n        bool zeroForOne = pool & _ZERO_FOR_ONE_MASK == 0;\\n        if (zeroForOne) {\\n            (, int256 amount1) =\\n                IUniswapV3Pool(address(uint160(pool))).swap(\\n                    recipient,\\n                    zeroForOne,\\n                    amount.toInt256(),\\n                    MIN_SQRT_RATIO + 1,\\n                    abi.encode(pool, tokenInAndPoolSalt)\\n                );\\n            amountOut = SafeMath.toUint256(-amount1);\\n        } else {\\n            (int256 amount0,) =\\n                IUniswapV3Pool(address(uint160(pool))).swap(\\n                    recipient,\\n                    zeroForOne,\\n                    amount.toInt256(),\\n                    MAX_SQRT_RATIO - 1,\\n                    abi.encode(pool, tokenInAndPoolSalt)\\n                );\\n            amountOut = SafeMath.toUint256(-amount0);\\n        }\\n    }\\n\\n    function _verifyPool(address tokenIn, address tokenOut, uint256 pool) internal view returns (address nextTokenIn, bytes memory tokenInAndPoolSalt) {\\n        IUniswapV3Pool iPool = IUniswapV3Pool(address(uint160(pool)));\\n        address token0 = iPool.token0();\\n        address token1 = iPool.token1();\\n        uint24 fee = iPool.fee();\\n        bytes32 poolSalt = keccak256(abi.encode(token0, token1, fee));\\n\\n        bool zeroForOne = pool & _ZERO_FOR_ONE_MASK == 0;\\n        if (zeroForOne) {\\n            require(tokenIn == token0, \\\"Bad pool\\\");\\n            if (tokenOut != address(0)) {\\n                require(tokenOut == token1, \\\"Bad pool\\\");\\n            }\\n            nextTokenIn = token1;\\n            tokenInAndPoolSalt = abi.encode(token0, poolSalt);\\n        } else {\\n            require(tokenIn == token1, \\\"Bad pool\\\");\\n            if (tokenOut != address(0)) {\\n                require(tokenOut == token0, \\\"Bad pool\\\");\\n            }\\n            nextTokenIn = token0;\\n            tokenInAndPoolSalt = abi.encode(token1, poolSalt);\\n        }\\n    }\\n\\n    function _verifyCallback(uint256 pool, bytes32 poolSalt, address caller) internal view {\\n        uint poolDigit = pool >> 248 & 0xf;\\n        UniswapV3Pool memory v3Pool = _uniswapV3_factory_allowed[poolDigit];\\n        require(v3Pool.factory != address(0), \\\"Callback bad pool indexed\\\");\\n        address calcPool = address(\\n            uint160(\\n                uint256(\\n                    keccak256(\\n                        abi.encodePacked(\\n                            hex'ff',\\n                            v3Pool.factory,\\n                            poolSalt,\\n                            v3Pool.initCodeHash\\n                        )\\n                    )\\n                )\\n            )\\n        );\\n        require(calcPool == caller, \\\"Callback bad pool\\\");\\n    }\\n\\n}\"\r\n    },\r\n    \"UniswapV2Router.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./BaseCore.sol\\\";\\n\\ncontract UniswapV2Router is BaseCore {\\n\\n    using SafeMath for uint256;\\n\\n    constructor() {\\n\\n    }\\n\\n    function _beforeSwap(ExactInputV2SwapParams calldata exactInput, bool supportingFeeOn) internal returns (bool isToETH, uint256 actualAmountIn, address[] memory paths, uint256 thisAddressBeforeBalance, uint256 toBeforeBalance) {\\n        require(exactInput.path.length == exactInput.pool.length + 1, \\\"Invalid path\\\");\\n        require(_wrapped_allowed[exactInput.wrappedToken], \\\"Invalid wrapped address\\\");\\n        actualAmountIn = calculateTradeFee(true, exactInput.amount, exactInput.fee, exactInput.signature);\\n        //\u68c0\u67e5\u7b2c\u4e00\u4e2a\u6216\u6700\u540e\u4e00\u4e2a\u662f\u5426\u4e3aETH\\n        address[] memory path = exactInput.path;\\n        address dstToken = path[exactInput.path.length - 1];\\n        if (TransferHelper.isETH(exactInput.path[0])) {\\n            require(msg.value == exactInput.amount, \\\"Invalid msg.value\\\");\\n            path[0] = exactInput.wrappedToken;\\n            TransferHelper.safeDeposit(exactInput.wrappedToken, actualAmountIn);\\n        } else {\\n            if (supportingFeeOn) {\\n                actualAmountIn = IERC20(path[0]).balanceOf(address(this));\\n                TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), exactInput.amount);\\n                actualAmountIn = IERC20(path[0]).balanceOf(address(this)).sub(actualAmountIn).sub(exactInput.fee);\\n            } else {\\n                TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), exactInput.amount);\\n            }\\n        }\\n        if (TransferHelper.isETH(dstToken)) {\\n            path[path.length - 1] = exactInput.wrappedToken;\\n            isToETH = true;\\n            thisAddressBeforeBalance = IERC20(exactInput.wrappedToken).balanceOf(address(this));\\n        } else {\\n            if (supportingFeeOn) {\\n                toBeforeBalance = IERC20(dstToken).balanceOf(exactInput.dstReceiver);\\n            }\\n        }\\n        paths = path;\\n    }\\n\\n    function exactInputV2SwapAndGasUsed(ExactInputV2SwapParams calldata exactInput, uint256 deadline) external payable returns (uint256 returnAmount, uint256 gasUsed) {\\n        uint256 gasLeftBefore = gasleft();\\n        returnAmount = _executeV2Swap(exactInput, deadline);\\n        gasUsed = gasLeftBefore - gasleft();\\n    }\\n\\n    function exactInputV2Swap(ExactInputV2SwapParams calldata exactInput, uint256 deadline) external payable returns (uint256 returnAmount) {\\n        returnAmount = _executeV2Swap(exactInput, deadline);\\n    }\\n\\n    function _executeV2Swap(ExactInputV2SwapParams calldata exactInput, uint256 deadline) internal nonReentrant whenNotPaused returns (uint256 returnAmount) {\\n        require(deadline >= block.timestamp, \\\"Expired\\\");\\n        \\n        bool supportingFeeOn = exactInput.router >> 248 & 0xf == 1;\\n        {\\n            (bool isToETH, uint256 actualAmountIn, address[] memory paths, uint256 thisAddressBeforeBalance, uint256 toBeforeBalance) = _beforeSwap(exactInput, supportingFeeOn);\\n            \\n            TransferHelper.safeTransfer(paths[0], exactInput.pool[0], actualAmountIn);\\n\\n            if (supportingFeeOn) {\\n                if(isToETH) {\\n                    _swapSupportingFeeOnTransferTokens(address(uint160(exactInput.router)), paths, exactInput.pool, address(this));\\n                    returnAmount = IERC20(exactInput.wrappedToken).balanceOf(address(this)).sub(thisAddressBeforeBalance);\\n                } else {\\n                    _swapSupportingFeeOnTransferTokens(address(uint160(exactInput.router)), paths, exactInput.pool, exactInput.dstReceiver);\\n                    returnAmount = IERC20(paths[paths.length - 1]).balanceOf(exactInput.dstReceiver).sub(toBeforeBalance);\\n                }\\n            } else {\\n                uint[] memory amounts = IUniswapV2(address(uint160(exactInput.router))).getAmountsOut(actualAmountIn, paths);\\n                if(isToETH) {\\n                    _swap(amounts, paths, exactInput.pool, address(this));\\n                    returnAmount = IERC20(exactInput.wrappedToken).balanceOf(address(this)).sub(thisAddressBeforeBalance);\\n                } else {\\n                    _swap(amounts, paths, exactInput.pool, exactInput.dstReceiver);\\n                    returnAmount = amounts[amounts.length - 1];\\n                }\\n            }\\n\\n            require(returnAmount >= exactInput.minReturnAmount, \\\"Too little received\\\");\\n            if (isToETH) {\\n                TransferHelper.safeWithdraw(exactInput.wrappedToken, returnAmount);\\n                TransferHelper.safeTransferETH(exactInput.dstReceiver, returnAmount);\\n            }\\n        }\\n        string memory channel = exactInput.channel;\\n\\n        _emitTransit(exactInput.path[0], exactInput.path[exactInput.path.length - 1], exactInput.dstReceiver, exactInput.amount, returnAmount, 0, channel);\\n        \\n    }\\n\\n    function _swap(uint[] memory amounts, address[] memory path, address[] memory pool, address _to) internal {\\n        for (uint i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0,) = input < output ? (input, output) : (output, input);\\n            uint amountOut = amounts[i + 1];\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOut) : (amountOut, uint(0));\\n            address to = i < path.length - 2 ? pool[i + 1] : _to;\\n            IUniswapV2(pool[i]).swap(\\n                amount0Out, amount1Out, to, new bytes(0)\\n            );\\n        }\\n    }\\n\\n    function _swapSupportingFeeOnTransferTokens(address router, address[] memory path, address[] memory pool, address _to) internal virtual {\\n        for (uint i; i < path.length - 1; i++) {\\n            (address input, address output) = (path[i], path[i + 1]);\\n            (address token0,) = input < output ? (input, output) : (output, input);\\n            IUniswapV2 pair = IUniswapV2(pool[i]);\\n            uint amountInput;\\n            uint amountOutput;\\n            { // scope to avoid stack too deep errors\\n                (uint reserve0, uint reserve1,) = pair.getReserves();\\n                (uint reserveInput, uint reserveOutput) = input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);\\n                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);\\n                amountOutput = IUniswapV2(router).getAmountOut(amountInput, reserveInput, reserveOutput);\\n            }\\n            (uint amount0Out, uint amount1Out) = input == token0 ? (uint(0), amountOutput) : (amountOutput, uint(0));\\n            address to = i < path.length - 2 ? pool[i + 1] : _to;\\n            pair.swap(amount0Out, amount1Out, to, new bytes(0));\\n        }\\n    }\\n\\n}\"\r\n    },\r\n    \"BaseCore.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./libs/Pausable.sol\\\";\\nimport \\\"./libs/ReentrancyGuard.sol\\\";\\nimport \\\"./libs/TransferHelper.sol\\\";\\nimport \\\"./libs/RevertReasonParser.sol\\\";\\nimport \\\"./libs/SafeMath.sol\\\";\\nimport \\\"./libs/Ownable.sol\\\";\\nimport \\\"./interfaces/IERC20.sol\\\";\\nimport \\\"./interfaces/IUniswapV2.sol\\\";\\nimport \\\"./interfaces/IUniswapV3Pool.sol\\\";\\n\\n\\ncontract BaseCore is Ownable, Pausable, ReentrancyGuard {\\n\\n    using SafeMath for uint256;\\n\\n    struct ExactInputV2SwapParams {\\n        address dstReceiver;\\n        address wrappedToken;\\n        uint256 router;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 fee;\\n        address[] path;\\n        address[] pool;\\n        bytes signature;\\n        string channel;\\n    }\\n\\n    struct ExactInputV3SwapParams {\\n        address srcToken;\\n        address dstToken;\\n        address dstReceiver;\\n        address wrappedToken;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 fee;\\n        uint256 deadline;\\n        uint256[] pools;\\n        bytes signature;\\n        string channel;\\n    }\\n\\n    struct TransitSwapDescription {\\n        address srcToken;\\n        address dstToken;\\n        address dstReceiver;\\n        address wrappedToken;\\n        uint256 amount;\\n        uint256 minReturnAmount;\\n        uint256 fee;\\n        string channel;\\n        bytes signature;\\n    }\\n\\n    struct CrossDescription {\\n        address srcToken;\\n        address dstToken;\\n        address caller;\\n        address dstReceiver;\\n        address wrappedToken;\\n        uint256 amount;\\n        uint256 fee;\\n        uint256 toChain;\\n        string channel;\\n        bytes calls;\\n        bytes signature;\\n    }\\n\\n    struct CallbytesDescription {\\n        address srcToken;\\n        bytes calldatas;\\n    }\\n\\n    struct UniswapV3Pool {\\n        address factory;\\n        bytes initCodeHash;\\n    }\\n\\n    uint256 internal _aggregate_fee;\\n    uint256 internal _cross_fee;\\n    address internal _aggregate_bridge;\\n    address internal _fee_signer;\\n    bytes32 public DOMAIN_SEPARATOR;\\n    //whitelist cross's caller\\n    mapping(address => bool) internal _cross_caller_allowed;\\n    //whitelist wrapped\\n    mapping(address => bool) internal _wrapped_allowed;\\n    //whitelist uniswap v3 factory\\n    mapping(uint => UniswapV3Pool) internal _uniswapV3_factory_allowed;\\n    bytes32 public constant CHECKFEE_TYPEHASH = keccak256(\\\"CheckFee(address payer,uint256 amount,uint256 fee)\\\");\\n\\n    event Receipt(address from, uint256 amount);\\n    event Withdraw(address indexed token, address indexed executor, address indexed recipient, uint amount);\\n    event ChangeWrappedAllowed(address[] wrappedTokens, bool[] newAllowed);\\n    event ChangeV3FactoryAllowed(uint256[] poolIndex, address[] factories, bytes[] initCodeHash);\\n    event ChangeCrossCallerAllowed(address[] callers);\\n    event ChangeFeeRate(bool isAggregate, uint256 newRate);\\n    event ChangeSigner(address preSigner, address newSigner);\\n    event ChangeAggregateBridge(address newBridge);\\n    event TransitSwapped(address indexed srcToken, address indexed dstToken, address indexed dstReceiver, uint256 amount, uint256 returnAmount, uint256 toChainID, string channel);\\n    \\n    constructor() Ownable(msg.sender) {\\n        DOMAIN_SEPARATOR = keccak256(\\n            abi.encode(\\n                keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                keccak256(bytes(\\\"TransitSwapV5\\\")),\\n                keccak256(bytes(\\\"5\\\")),\\n                block.chainid,\\n                address(this)\\n            )\\n        );\\n    }\\n\\n    receive() external payable {\\n        emit Receipt(msg.sender, msg.value);\\n    }\\n\\n    function calculateTradeFee(bool isAggregate, uint256 tradeAmount, uint256 fee, bytes calldata signature) internal view returns (uint256) {\\n        uint256 thisFee;\\n        if (isAggregate) {\\n            thisFee = tradeAmount.mul(_aggregate_fee).div(10000);\\n        } else {\\n            thisFee = tradeAmount.mul(_cross_fee).div(10000);\\n        }\\n        if (fee < thisFee) {\\n            require(verifySignature(tradeAmount, fee, signature), \\\"Invalid signature fee\\\");\\n        }\\n        return tradeAmount.sub(fee);\\n    }\\n\\n    function _emitTransit(address srcToken, address dstToken, address dstReceiver, uint256 amount, uint256 returnAmount, uint256 toChainID, string memory channel) internal {\\n        emit TransitSwapped (\\n            srcToken, \\n            dstToken, \\n            dstReceiver,\\n            amount,\\n            returnAmount,\\n            toChainID,\\n            channel\\n        );\\n    }\\n\\n    function changeFee(bool[] memory isAggregate, uint256[] memory newRate) external onlyExecutor {\\n        for (uint i; i < isAggregate.length; i++) {\\n            require(newRate[i] >= 0 && newRate[i] <= 1000, \\\"fee rate is:0-1000\\\");\\n            if (isAggregate[i]) {\\n                _aggregate_fee = newRate[i];\\n            } else {\\n                _cross_fee = newRate[i];\\n            }\\n            emit ChangeFeeRate(isAggregate[i], newRate[i]);\\n        }\\n    }\\n\\n    function changeTransitProxy(address aggregator, address signer) external onlyExecutor {\\n        if (aggregator != address(0)) {\\n            _aggregate_bridge = aggregator;\\n            emit ChangeAggregateBridge(aggregator);\\n        }\\n        if (signer != address(0)) {\\n            address preSigner = _fee_signer;\\n            _fee_signer = signer;\\n            emit ChangeSigner(preSigner, signer);\\n        }\\n    }\\n\\n    function changeAllowed(address[] calldata crossCallers, address[] calldata wrappedTokens) public onlyExecutor {\\n        if(crossCallers.length != 0){\\n            for (uint i; i < crossCallers.length; i++) {\\n                _cross_caller_allowed[crossCallers[i]] = !_cross_caller_allowed[crossCallers[i]];\\n            }\\n            emit ChangeCrossCallerAllowed(crossCallers);\\n        }\\n        if(wrappedTokens.length != 0) {\\n            bool[] memory newAllowed = new bool[](wrappedTokens.length);\\n            for (uint index; index < wrappedTokens.length; index++) {\\n                _wrapped_allowed[wrappedTokens[index]] = !_wrapped_allowed[wrappedTokens[index]];\\n                newAllowed[index] = _wrapped_allowed[wrappedTokens[index]];\\n            }\\n            emit ChangeWrappedAllowed(wrappedTokens, newAllowed);\\n        }\\n    }\\n\\n    function changeUniswapV3FactoryAllowed(uint[] calldata poolIndex, address[] calldata factories, bytes[] calldata initCodeHash) public onlyExecutor {\\n        require(poolIndex.length == initCodeHash.length, \\\"invalid data\\\");\\n        require(factories.length == initCodeHash.length, \\\"invalid data\\\");\\n        uint len = factories.length;\\n        for (uint i; i < len; i++) {\\n            _uniswapV3_factory_allowed[poolIndex[i]] = UniswapV3Pool(factories[i],initCodeHash[i]);\\n        }\\n        emit ChangeV3FactoryAllowed(poolIndex, factories, initCodeHash);\\n    }\\n\\n    function changePause(bool paused) external onlyExecutor {\\n        if (paused) {\\n            _pause();\\n        } else {\\n            _unpause();\\n        }\\n    }\\n\\n    function transitProxyAddress() external view returns (address bridgeProxy, address feeSigner) {\\n        bridgeProxy = _aggregate_bridge;\\n        feeSigner = _fee_signer;\\n    }\\n\\n    function transitFee() external view returns (uint256, uint256) {\\n        return (_aggregate_fee, _cross_fee);\\n    }\\n\\n    function transitAllowedQuery(address crossCaller, address wrappedToken, uint256 poolIndex) external view returns (bool isCrossCallerAllowed, bool isWrappedAllowed, UniswapV3Pool memory pool) {\\n        isCrossCallerAllowed = _cross_caller_allowed[crossCaller];\\n        isWrappedAllowed = _wrapped_allowed[wrappedToken];\\n        pool = _uniswapV3_factory_allowed[poolIndex];\\n    }\\n\\n    function verifySignature(uint256 amount, uint256 fee, bytes calldata signature) internal view returns (bool) {\\n        bytes32 digest = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19\\\\x01\\\",\\n                DOMAIN_SEPARATOR,\\n                keccak256(abi.encode(CHECKFEE_TYPEHASH, msg.sender, amount, fee))\\n            )\\n        );\\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(signature);\\n        address recovered = ecrecover(digest, v, r, s);\\n        return recovered == _fee_signer;\\n    }\\n\\n    function splitSignature(bytes memory _signature) internal pure returns (uint8 v, bytes32 r, bytes32 s) {\\n        require(bytes(_signature).length == 65, \\\"Invalid signature length\\\");\\n\\n        assembly {\\n            r := mload(add(_signature, 0x20))\\n            s := mload(add(_signature, 0x40))\\n            v := byte(0, mload(add(_signature, 0x60)))\\n        }\\n\\n        return (v, r, s);\\n    }\\n\\n}\"\r\n    },\r\n    \"interfaces/IUniswapV3Pool.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.5.0;\\n\\ninterface IUniswapV3Pool {\\n    function token0() external view returns (address);\\n    function token1() external view returns (address);\\n    function fee() external view returns (uint24);\\n    function swap(\\n        address recipient,\\n        bool zeroForOne,\\n        int256 amountSpecified,\\n        uint160 sqrtPriceLimitX96,\\n        bytes calldata data\\n    ) external returns (int256 amount0, int256 amount1);\\n}\"\r\n    },\r\n    \"interfaces/IUniswapV2.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.9;\\n\\ninterface IUniswapV2 {\\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\\n    function getAmountsOut(uint amountIn, address[] memory path) external view returns (uint[] memory amounts);\\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\\n}\"\r\n    },\r\n    \"interfaces/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.9;\\n\\ninterface IERC20 {\\n    \\n    function totalSupply() external view returns (uint256);\\n    function decimals() external view returns (uint8);\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function balanceOf(address account) external view returns (uint256);\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n    function allowance(address owner, address spender) external view returns (uint256);\\n    function approve(address spender, uint256 amount) external returns (bool);\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n \\n}\"\r\n    },\r\n    \"libs/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n// Add executor extension\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable {\\n\\n    address private _executor;\\n    address private _pendingExecutor;\\n    bool internal _initialized;\\n\\n    event ExecutorshipTransferStarted(address indexed previousExecutor, address indexed newExecutor);\\n    event ExecutorshipTransferred(address indexed previousExecutor, address indexed newExecutor);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor(address newExecutor) {\\n        require(!_initialized, \\\"Ownable: initialized\\\");\\n        _transferExecutorship(newExecutor);\\n        _initialized = true;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the executor.\\n     */\\n    modifier onlyExecutor() {\\n        _checkExecutor();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current executor.\\n     */\\n    function executor() public view virtual returns (address) {\\n        return _executor;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the pending executor.\\n     */\\n    function pendingExecutor() public view virtual returns (address) {\\n        return _pendingExecutor;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the executor.\\n     */\\n    function _checkExecutor() internal view virtual {\\n        require(executor() == msg.sender, \\\"Ownable: caller is not the executor\\\");\\n    }\\n\\n    /**\\n     * @dev Transfers executorship of the contract to a new account (`newExecutor`).\\n     * Can only be called by the current executor.\\n     */\\n    function transferExecutorship(address newExecutor) public virtual onlyExecutor {\\n        _pendingExecutor = newExecutor;\\n        emit ExecutorshipTransferStarted(executor(), newExecutor);\\n    }\\n\\n    function _transferExecutorship(address newExecutor) internal virtual {\\n        delete _pendingExecutor;\\n        address oldExecutor = _executor;\\n        _executor = newExecutor;\\n        emit ExecutorshipTransferred(oldExecutor, newExecutor);\\n    }\\n\\n    function acceptExecutorship() external {\\n        address sender = msg.sender;\\n        require(pendingExecutor() == sender, \\\"Ownable: caller is not the new executor\\\");\\n        _transferExecutorship(sender);\\n    }\\n}\"\r\n    },\r\n    \"libs/SafeMath.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nlibrary SafeMath {\\n    function add(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x + y) >= x, 'ds-math-add-overflow');\\n    }\\n\\n    function sub(uint x, uint y) internal pure returns (uint z) {\\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\\n    }\\n\\n    function mul(uint x, uint y) internal pure returns (uint z) {\\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\\n    }\\n    \\n    function div(uint x, uint y) internal pure returns (uint z) {\\n        require(y != 0 , 'ds-math-div-zero');\\n        z = x / y;\\n    }\\n\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n}\"\r\n    },\r\n    \"libs/RevertReasonParser.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nlibrary RevertReasonParser {\\n        function parse(bytes memory data, string memory prefix) internal pure returns (string memory) {\\n        // https://solidity.readthedocs.io/en/latest/control-structures.html#revert\\n        // We assume that revert reason is abi-encoded as Error(string)\\n\\n        // 68 = 4-byte selector 0x08c379a0 + 32 bytes offset + 32 bytes length\\n        if (data.length >= 68 && data[0] == \\\"\\\\x08\\\" && data[1] == \\\"\\\\xc3\\\" && data[2] == \\\"\\\\x79\\\" && data[3] == \\\"\\\\xa0\\\") {\\n            string memory reason;\\n            // solhint-disable no-inline-assembly\\n            assembly {\\n                // 68 = 32 bytes data length + 4-byte selector + 32 bytes offset\\n                reason := add(data, 68)\\n            }\\n            /*\\n                revert reason is padded up to 32 bytes with ABI encoder: Error(string)\\n                also sometimes there is extra 32 bytes of zeros padded in the end:\\n                https://github.com/ethereum/solidity/issues/10170\\n                because of that we can't check for equality and instead check\\n                that string length + extra 68 bytes is less than overall data length\\n            */\\n            require(data.length >= 68 + bytes(reason).length, \\\"Invalid revert reason\\\");\\n            return string(abi.encodePacked(prefix, \\\"Error(\\\", reason, \\\")\\\"));\\n        }\\n        // 36 = 4-byte selector 0x4e487b71 + 32 bytes integer\\n        else if (data.length == 36 && data[0] == \\\"\\\\x4e\\\" && data[1] == \\\"\\\\x48\\\" && data[2] == \\\"\\\\x7b\\\" && data[3] == \\\"\\\\x71\\\") {\\n            uint256 code;\\n            // solhint-disable no-inline-assembly\\n            assembly {\\n                // 36 = 32 bytes data length + 4-byte selector\\n                code := mload(add(data, 36))\\n            }\\n            return string(abi.encodePacked(prefix, \\\"Panic(\\\", _toHex(code), \\\")\\\"));\\n        }\\n\\n        return string(abi.encodePacked(prefix, \\\"Unknown(\\\", _toHex(data), \\\")\\\"));\\n    }\\n    \\n    function _toHex(uint256 value) private pure returns(string memory) {\\n        return _toHex(abi.encodePacked(value));\\n    }\\n\\n    function _toHex(bytes memory data) private pure returns(string memory) {\\n        bytes16 alphabet = 0x30313233343536373839616263646566;\\n        bytes memory str = new bytes(2 + data.length * 2);\\n        str[0] = \\\"0\\\";\\n        str[1] = \\\"x\\\";\\n        for (uint256 i = 0; i < data.length; i++) {\\n            str[2 * i + 2] = alphabet[uint8(data[i] >> 4)];\\n            str[2 * i + 3] = alphabet[uint8(data[i] & 0x0f)];\\n        }\\n        return string(str);\\n    }\\n}\"\r\n    },\r\n    \"libs/TransferHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.6.0;\\n\\nlibrary TransferHelper {\\n    \\n    address private constant _ETH_ADDRESS = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\\n    address private constant _ZERO_ADDRESS = address(0);\\n    \\n    function isETH(address token) internal pure returns (bool) {\\n        return (token == _ZERO_ADDRESS || token == _ETH_ADDRESS);\\n    }\\n    \\n    function safeApprove(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\\n    }\\n\\n    function safeTransfer(address token, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_TOKEN_FAILED');\\n    }\\n\\n    function safeTransferWithoutRequire(address token, address to, uint256 value) internal returns (bool) {\\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\\n        return (success && (data.length == 0 || abi.decode(data, (bool))));\\n    }\\n\\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\\n    }\\n\\n    function safeTransferETH(address to, uint value) internal {\\n        // solium-disable-next-line\\n        (bool success,) = to.call{value:value}(new bytes(0));\\n        require(success, 'TransferHelper: TRANSFER_FAILED');\\n    }\\n\\n    function safeDeposit(address wrapped, uint value) internal {\\n        // bytes4(keccak256(bytes('deposit()')));\\n        (bool success, bytes memory data) = wrapped.call{value:value}(abi.encodeWithSelector(0xd0e30db0));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: DEPOSIT_FAILED');\\n    }\\n\\n    function safeWithdraw(address wrapped, uint value) internal {\\n        // bytes4(keccak256(bytes('withdraw(uint256 wad)')));\\n        (bool success, bytes memory data) = wrapped.call{value:0}(abi.encodeWithSelector(0x2e1a7d4d, value));\\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: WITHDRAW_FAILED');\\n    }\\n}\"\r\n    },\r\n    \"libs/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module that helps prevent reentrant calls to a function.\\n *\\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\\n * available, which can be applied to functions to make sure there are no nested\\n * (reentrant) calls to them.\\n *\\n * Note that because there is a single `nonReentrant` guard, functions marked as\\n * `nonReentrant` may not call one another. This can be worked around by making\\n * those functions `private`, and then adding `external` `nonReentrant` entry\\n * points to them.\\n *\\n * TIP: If you would like to learn more about reentrancy and alternative ways\\n * to protect against it, check out our blog post\\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\\n */\\nabstract contract ReentrancyGuard {\\n    // Booleans are more expensive than uint256 or any type that takes up a full\\n    // word because each write operation emits an extra SLOAD to first read the\\n    // slot's contents, replace the bits taken up by the boolean, and then write\\n    // back. This is the compiler's defense against contract upgrades and\\n    // pointer aliasing, and it cannot be disabled.\\n\\n    // The values being non-zero value makes deployment a bit more expensive,\\n    // but in exchange the refund on every call to nonReentrant will be lower in\\n    // amount. Since refunds are capped to a percentage of the total\\n    // transaction's gas, it is best to keep them low in cases like this one, to\\n    // increase the likelihood of the full refund coming into effect.\\n    uint256 private constant _NOT_ENTERED = 1;\\n    uint256 private constant _ENTERED = 2;\\n\\n    uint256 private _status;\\n\\n    constructor() {\\n        _status = _NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n        assembly {\\n            sstore(_status.slot, _ENTERED)\\n        }\\n        _;\\n        assembly {\\n            sstore(_status.slot, _NOT_ENTERED)\\n        }\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\\n        require(_status != _ENTERED, \\\"ReentrancyGuard: reentrant call\\\");\\n\\n        // Any calls to nonReentrant after this point will fail\\n        _status = _ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _status = _NOT_ENTERED;\\n    }\\n}\"\r\n    },\r\n    \"libs/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        _requireNotPaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        _requirePaused();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is paused.\\n     */\\n    function _requireNotPaused() internal view virtual {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n    }\\n\\n    /**\\n     * @dev Throws if the contract is not paused.\\n     */\\n    function _requirePaused() internal view virtual {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(msg.sender);\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(msg.sender);\\n    }\\n}\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newBridge\",\"type\":\"address\"}],\"name\":\"ChangeAggregateBridge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"callers\",\"type\":\"address[]\"}],\"name\":\"ChangeCrossCallerAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"isAggregate\",\"type\":\"bool\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"ChangeFeeRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"preSigner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newSigner\",\"type\":\"address\"}],\"name\":\"ChangeSigner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"poolIndex\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"factories\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bytes[]\",\"name\":\"initCodeHash\",\"type\":\"bytes[]\"}],\"name\":\"ChangeV3FactoryAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"wrappedTokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"bool[]\",\"name\":\"newAllowed\",\"type\":\"bool[]\"}],\"name\":\"ChangeWrappedAllowed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"ExecutorshipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousExecutor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"ExecutorshipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Receipt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toChainID\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"}],\"name\":\"TransitSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"executor\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"CHECKFEE_TYPEHASH\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptExecutorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BaseCore.TransitSwapDescription\",\"name\":\"desc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldatas\",\"type\":\"bytes\"}],\"internalType\":\"struct BaseCore.CallbytesDescription\",\"name\":\"callbytesDesc\",\"type\":\"tuple\"}],\"name\":\"aggregate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BaseCore.TransitSwapDescription\",\"name\":\"desc\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"calldatas\",\"type\":\"bytes\"}],\"internalType\":\"struct BaseCore.CallbytesDescription\",\"name\":\"callbytesDesc\",\"type\":\"tuple\"}],\"name\":\"aggregateAndGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"crossCallers\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"wrappedTokens\",\"type\":\"address[]\"}],\"name\":\"changeAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool[]\",\"name\":\"isAggregate\",\"type\":\"bool[]\"},{\"internalType\":\"uint256[]\",\"name\":\"newRate\",\"type\":\"uint256[]\"}],\"name\":\"changeFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"changePause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"aggregator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"changeTransitProxy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"poolIndex\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"factories\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"initCodeHash\",\"type\":\"bytes[]\"}],\"name\":\"changeUniswapV3FactoryAllowed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"toChain\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"},{\"internalType\":\"bytes\",\"name\":\"calls\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"internalType\":\"struct BaseCore.CrossDescription\",\"name\":\"desc\",\"type\":\"tuple\"}],\"name\":\"cross\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"router\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"pool\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"}],\"internalType\":\"struct BaseCore.ExactInputV2SwapParams\",\"name\":\"exactInput\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"exactInputV2Swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"router\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"path\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"pool\",\"type\":\"address[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"}],\"internalType\":\"struct BaseCore.ExactInputV2SwapParams\",\"name\":\"exactInput\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"exactInputV2SwapAndGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"pools\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"}],\"internalType\":\"struct BaseCore.ExactInputV3SwapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInputV3Swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"srcToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"dstReceiver\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minReturnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"pools\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"string\",\"name\":\"channel\",\"type\":\"string\"}],\"internalType\":\"struct BaseCore.ExactInputV3SwapParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"exactInputV3SwapAndGasUsed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"returnAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasUsed\",\"type\":\"uint256\"}],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"executor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"pancakeV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingExecutor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newExecutor\",\"type\":\"address\"}],\"name\":\"transferExecutorship\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"crossCaller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"wrappedToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"poolIndex\",\"type\":\"uint256\"}],\"name\":\"transitAllowedQuery\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isCrossCallerAllowed\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"isWrappedAllowed\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"factory\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"initCodeHash\",\"type\":\"bytes\"}],\"internalType\":\"struct BaseCore.UniswapV3Pool\",\"name\":\"pool\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transitFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transitProxyAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"bridgeProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"feeSigner\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"amount0Delta\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1Delta\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"uniswapV3SwapCallback\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "TransitSwapRouterV5", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}