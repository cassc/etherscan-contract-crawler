{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/wizards/v1/listing/ListingWizardV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/Multicall.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\\\";\\nimport \\\"./IListingWizardV1.sol\\\";\\nimport \\\"./../utils/ListingWizardsHelperV1.sol\\\";\\nimport \\\"./../utils/GeneralWizardsHelperV1.sol\\\";\\nimport \\\"../../../contract-registry/ContractEntity.sol\\\";\\nimport \\\"../../../listing/listing-manager/IListingManager.sol\\\";\\n\\ncontract ListingWizardV1 is IListingWizardV1, ContractEntity, EIP712, Multicall {\\n    using Assets for Assets.Asset;\\n    using Address for address;\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n\\n    /**\\n     * @dev Delegate listing hashed data signature.\\n     */\\n    bytes32 private constant _DELEGATED_LISTING_TYPEHASH = keccak256(\\\"DelegatedListing(uint256 nonce)\\\");\\n\\n    // @dev Mapping from lister's address to nonces counter.\\n    mapping(address => CountersUpgradeable.Counter) internal _listerDelegatedListingNonces;\\n\\n    modifier onlyCallerIsLister(Listings.Params calldata params) {\\n        if (msg.sender != params.lister) revert CallerIsNotLister();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Listing Wizard constructor\\n     */\\n    constructor(address metahub) EIP712(\\\"IQProtocol\\\", \\\"1\\\") {\\n        _metahub = IMetahub(metahub);\\n    }\\n\\n    /**\\n     * @inheritdoc IListingWizardV1\\n     */\\n    function createListingWithTerms(\\n        Assets.Asset[] calldata assets,\\n        Listings.Params calldata params,\\n        IListingTermsRegistry.ListingTerms calldata terms,\\n        uint32 maxLockPeriod,\\n        bool immediatePayout,\\n        uint256 universeId\\n    ) external onlyCallerIsLister(params) returns (uint256 listingId, uint256 listingTermsId) {\\n        (listingId, listingTermsId) = _createListingWithTerms(\\n            assets,\\n            params,\\n            terms,\\n            maxLockPeriod,\\n            immediatePayout,\\n            universeId\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc IListingWizardV1\\n     */\\n    function delegatedCreateListingWithTerms(\\n        Assets.Asset[] calldata assets,\\n        Listings.Params calldata params,\\n        IListingTermsRegistry.ListingTerms calldata terms,\\n        uint32 maxLockPeriod,\\n        bool immediatePayout,\\n        uint256 universeId,\\n        bytes calldata delegatedListingSignature\\n    ) external returns (uint256 listingId, uint256 listingTermsId) {\\n        bytes32 delegatedListingHash = keccak256(\\n            abi.encode(\\n                _DELEGATED_LISTING_TYPEHASH,\\n                // is sufficient to call _useNonce() to prevent multiple usage\\n                _useNonce(params.lister)\\n            )\\n        );\\n\\n        _validateSigner(params.lister, delegatedListingHash, delegatedListingSignature);\\n\\n        (listingId, listingTermsId) = _createListingWithTerms(\\n            assets,\\n            params,\\n            terms,\\n            maxLockPeriod,\\n            immediatePayout,\\n            universeId\\n        );\\n    }\\n\\n    /**\\n     * @inheritdoc IListingWizardV1\\n     */\\n    function getDelegatedListingCurrentNonce(address lister) external view returns (uint256) {\\n        return _listerDelegatedListingNonces[lister].current();\\n    }\\n\\n    /**\\n     * @inheritdoc IListingWizardV1\\n     */\\n    // solhint-disable func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\\n        // solhint-disable-line\\n        return _domainSeparatorV4(); // solhint-disable-line\\n    }\\n\\n    /**\\n     * @inheritdoc IListingWizardV1\\n     */\\n    function getChainId() external view returns (uint256) {\\n        return block.chainid;\\n    }\\n\\n    /**\\n     * @inheritdoc IContractEntity\\n     */\\n    function contractKey() external pure override returns (bytes4) {\\n        return Contracts.LISTING_WIZARD_V1;\\n    }\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view override(ContractEntity, IERC165) returns (bool) {\\n        return interfaceId == type(IListingWizardV1).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n\\n    /**\\n     * @dev \\\"Consume a nonce\\\": return the current value and increment.\\n     *\\n     * _Available since v4.1._\\n     */\\n    function _useNonce(address lister) internal returns (uint256 current) {\\n        CountersUpgradeable.Counter storage delegatedListingNonces = _listerDelegatedListingNonces[lister];\\n        current = delegatedListingNonces.current();\\n        delegatedListingNonces.increment();\\n    }\\n\\n    function _createListingWithTerms(\\n        Assets.Asset[] calldata assets,\\n        Listings.Params calldata params,\\n        IListingTermsRegistry.ListingTerms calldata terms,\\n        uint32 maxLockPeriod,\\n        bool immediatePayout,\\n        uint256 universeId\\n    ) internal returns (uint256 listingId, uint256 listingTermsId) {\\n        listingId = IListingManager(_metahub.getContract(Contracts.LISTING_MANAGER)).createListing(\\n            assets,\\n            params,\\n            maxLockPeriod,\\n            immediatePayout\\n        );\\n\\n        GeneralWizardsHelperV1.checkListingTermsAreValid(terms);\\n        listingTermsId = IListingTermsRegistry(_metahub.getContract(Contracts.LISTING_TERMS_REGISTRY))\\n            .registerUniverseListingTerms(listingId, universeId, terms);\\n\\n        // Detecting address of Original Assets Collection (all Assets are from the same Collection)\\n        address originalCollection = assets[0].token();\\n\\n        ListingWizardsHelperV1.validateMatchWithUniverse(universeId, originalCollection, terms, _metahub);\\n    }\\n\\n    function _validateSigner(\\n        address declaredLister,\\n        bytes32 delegatedListingHash,\\n        bytes calldata delegatedListingSignature\\n    ) internal view {\\n        // getting fully encoded EIP712 message\\n        bytes32 hash = _hashTypedDataV4(delegatedListingHash);\\n        // decoding ECDSA signature\\n        (uint8 v, bytes32 r, bytes32 s) = abi.decode(delegatedListingSignature, (uint8, bytes32, bytes32));\\n        // recovering ECDSA signature and getting message signer\\n        address delegatedListingSigner = ECDSAUpgradeable.recover(hash, v, r, s);\\n        // validating that declared lister is matching the Delegated Listing signer\\n        if (declaredLister != delegatedListingSigner) {\\n            revert DeclaredListerIsDifferentFromDelegatedListingSigner(declaredLister, delegatedListingSigner);\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Multicall.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Multicall.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev Provides a function to batch together multiple calls in a single external call.\\n *\\n * _Available since v4.1._\\n */\\nabstract contract Multicall {\\n    /**\\n     * @dev Receives and executes a batch of function calls on this contract.\\n     */\\n    function multicall(bytes[] calldata data) external virtual returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\\n        }\\n        return results;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/draft-EIP712.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\n\\n/**\\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\\n *\\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\\n *\\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\\n * ({_hashTypedDataV4}).\\n *\\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\\n * the chain id to protect against replay attacks on an eventual fork of the chain.\\n *\\n * NOTE: This contract implements the version of the encoding known as \\\"v4\\\", as implemented by the JSON RPC method\\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\\n *\\n * _Available since v3.4._\\n */\\nabstract contract EIP712 {\\n    /* solhint-disable var-name-mixedcase */\\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\\n    // invalidate the cached domain separator if the chain id changes.\\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\\n    uint256 private immutable _CACHED_CHAIN_ID;\\n    address private immutable _CACHED_THIS;\\n\\n    bytes32 private immutable _HASHED_NAME;\\n    bytes32 private immutable _HASHED_VERSION;\\n    bytes32 private immutable _TYPE_HASH;\\n\\n    /* solhint-enable var-name-mixedcase */\\n\\n    /**\\n     * @dev Initializes the domain separator and parameter caches.\\n     *\\n     * The meaning of `name` and `version` is specified in\\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\\n     *\\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\\n     * - `version`: the current major version of the signing domain.\\n     *\\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\\n     * contract upgrade].\\n     */\\n    constructor(string memory name, string memory version) {\\n        bytes32 hashedName = keccak256(bytes(name));\\n        bytes32 hashedVersion = keccak256(bytes(version));\\n        bytes32 typeHash = keccak256(\\n            \\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"\\n        );\\n        _HASHED_NAME = hashedName;\\n        _HASHED_VERSION = hashedVersion;\\n        _CACHED_CHAIN_ID = block.chainid;\\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\\n        _CACHED_THIS = address(this);\\n        _TYPE_HASH = typeHash;\\n    }\\n\\n    /**\\n     * @dev Returns the domain separator for the current chain.\\n     */\\n    function _domainSeparatorV4() internal view returns (bytes32) {\\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\\n            return _CACHED_DOMAIN_SEPARATOR;\\n        } else {\\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\\n        }\\n    }\\n\\n    function _buildDomainSeparator(\\n        bytes32 typeHash,\\n        bytes32 nameHash,\\n        bytes32 versionHash\\n    ) private view returns (bytes32) {\\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\\n    }\\n\\n    /**\\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\\n     * function returns the hash of the fully encoded EIP712 message for this domain.\\n     *\\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\\n     *\\n     * ```solidity\\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\\n     *     keccak256(\\\"Mail(address to,string contents)\\\"),\\n     *     mailTo,\\n     *     keccak256(bytes(mailContents))\\n     * )));\\n     * address signer = ECDSA.recover(digest, signature);\\n     * ```\\n     */\\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../StringsUpgradeable.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSAUpgradeable {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", StringsUpgradeable.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wizards/v1/listing/IListingWizardV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC721.sol\\\";\\nimport \\\"../../../contract-registry/IContractEntity.sol\\\";\\nimport \\\"../../../listing/Listings.sol\\\";\\n\\ninterface IListingWizardV1 is IContractEntity {\\n    /**\\n     * @dev Thrown when the provided `account` doesn't match the Listing params' lister address.\\n     */\\n    error CallerIsNotLister();\\n\\n    // @dev Thrown, when the declared lister is different from the Delegated Listing signer.\\n    error DeclaredListerIsDifferentFromDelegatedListingSigner(address declaredLister, address delegatedLitingSigner);\\n\\n    /**\\n     * @dev Creates new listing and fill in listing terms on universe level.\\n     * Emits an {ListingCreated, UniverseListingTermsRegistered} events.\\n     * @param assets Assets to be listed.\\n     * @param params Listing params.\\n     * @param terms Listing terms on universe level.\\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\\n     * * If FALSE, the rental fees get accumulated until withdrawn manually.\\n     * @param universeId Universe ID.\\n     * * Makes possible to run this {assets} only within this universe.\\n     * @return listingId New listing ID.\\n     * @return listingTermsId New listing terms ID.\\n     */\\n    function createListingWithTerms(\\n        Assets.Asset[] calldata assets,\\n        Listings.Params calldata params,\\n        IListingTermsRegistry.ListingTerms calldata terms,\\n        uint32 maxLockPeriod,\\n        bool immediatePayout,\\n        uint256 universeId\\n    ) external returns (uint256 listingId, uint256 listingTermsId);\\n\\n    /**\\n     * @dev Does the same as `createListingWithTerms`, with only difference to allow\\n     * delegated listing for the purpose of gas-less TXs.\\n     * @param delegatedListingSignature Delegated Listing ECDSA signature ABI encoded (v,r,s)(uint8, bytes32, bytes32).\\n     */\\n    function delegatedCreateListingWithTerms(\\n        Assets.Asset[] calldata assets,\\n        Listings.Params calldata params,\\n        IListingTermsRegistry.ListingTerms calldata terms,\\n        uint32 maxLockPeriod,\\n        bool immediatePayout,\\n        uint256 universeId,\\n        bytes calldata delegatedListingSignature\\n    ) external returns (uint256 listingId, uint256 listingTermsId);\\n\\n    /**\\n     * @dev Get the current nonce of lister for delegated listing.\\n     * This 'nonce' should be included in the signature of DelegatedListing.\\n     * @param lister Address of the actual lister.\\n     */\\n    function getDelegatedListingCurrentNonce(address lister) external view returns (uint256);\\n\\n    // @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n    // @dev Getting the Chain ID\\n    function getChainId() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/wizards/v1/utils/ListingWizardsHelperV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../../../metahub/core/IMetahub.sol\\\";\\nimport \\\"../../../contract-registry/Contracts.sol\\\";\\nimport \\\"../../../warper/warper-manager/IWarperManager.sol\\\";\\nimport \\\"../../../listing/listing-strategy-registry/IListingStrategyRegistry.sol\\\";\\nimport \\\"../../../tax/tax-terms-registry/ITaxTermsRegistry.sol\\\";\\n\\nlibrary ListingWizardsHelperV1 {\\n    /**\\n     * @dev Thrown when the Universe does not support the Original Asset Collection.\\n     * @param universeId The Universe.\\n     * @param collection The address of unsupported by the `universeId` Original Asset Collection.\\n     */\\n    error UniverseDoesNotSupportAsset(uint256 universeId, address collection);\\n\\n    function validateMatchWithUniverse(\\n        uint256 universeId,\\n        address originalCollection,\\n        IListingTermsRegistry.ListingTerms calldata terms,\\n        IMetahub metahub\\n    ) internal view {\\n        // get [0] element from Universe Asset Warpers\\n        // cause right now there is a limit that Universe can have only 1 Warper for unique asset.\\n        (address[] memory warperAddresses, ) = IWarperManager(metahub.getContract(Contracts.WARPER_MANAGER))\\n            .universeAssetWarpers(universeId, originalCollection, 0, 1);\\n\\n        if (warperAddresses.length == 0) {\\n            revert UniverseDoesNotSupportAsset(universeId, originalCollection);\\n        }\\n\\n        bytes4 taxStrategyId = IListingStrategyRegistry(metahub.getContract(Contracts.LISTING_STRATEGY_REGISTRY))\\n            .listingTaxId(terms.strategyId);\\n        ITaxTermsRegistry.Params memory taxTermsParams = ITaxTermsRegistry.Params({\\n            taxStrategyId: taxStrategyId,\\n            universeId: universeId,\\n            warperAddress: warperAddresses[0]\\n        });\\n        ITaxTermsRegistry(metahub.getContract(Contracts.TAX_TERMS_REGISTRY)).checkRegisteredUniverseTaxTermsWithParams(\\n            taxTermsParams\\n        );\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/wizards/v1/utils/GeneralWizardsHelperV1.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.13;\\n\\nimport \\\"../../../listing/listing-strategies/ListingStrategies.sol\\\";\\nimport \\\"../../../listing/listing-terms-registry/IListingTermsRegistry.sol\\\";\\nimport \\\"../../../tax/tax-strategies/TaxStrategies.sol\\\";\\nimport \\\"../../../tax/tax-terms-registry/ITaxTermsRegistry.sol\\\";\\n\\nlibrary GeneralWizardsHelperV1 {\\n    /**\\n     * @dev Thrown when provided Tax Terms are invalid.\\n     */\\n    error TaxTermsAreInvalid();\\n\\n    /**\\n     * @dev Thrown when provided Listing Terms are invalid.\\n     */\\n    error ListingTermsAreInvalid();\\n\\n    function areEmptyTaxTerms(ITaxTermsRegistry.TaxTerms calldata taxTerms) internal pure returns (bool) {\\n        return taxTerms.strategyId.length == 0 || taxTerms.strategyData.length == 0;\\n    }\\n\\n    function areEmptyListingTerms(IListingTermsRegistry.ListingTerms calldata listingTerms)\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return listingTerms.strategyId.length == 0 || listingTerms.strategyData.length == 0;\\n    }\\n\\n    function checkTaxTermsAreValid(ITaxTermsRegistry.TaxTerms calldata taxTerms) internal pure {\\n        if (areEmptyTaxTerms(taxTerms) || !TaxStrategies.isValidTaxStrategy(taxTerms.strategyId))\\n            revert TaxTermsAreInvalid();\\n    }\\n\\n    function checkListingTermsAreValid(IListingTermsRegistry.ListingTerms calldata listingTerms) internal pure {\\n        if (areEmptyListingTerms(listingTerms) || !ListingStrategies.isValidListingStrategy(listingTerms.strategyId))\\n            revert ListingTermsAreInvalid();\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/contract-registry/ContractEntity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/introspection/ERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./IContractEntity.sol\\\";\\nimport \\\"../metahub/core/IMetahub.sol\\\";\\n\\nabstract contract ContractEntity is IContractEntity, ERC165 {\\n    /**\\n     * @dev Metahub contract.\\n     * Contract (e.g. ACL, AssetClassRegistry etc), the Metahub depends on\\n     * still can be Contract Entities (with key), but\\n     * do not have the `_metahub` reference set.\\n     */\\n    IMetahub internal _metahub;\\n\\n    /**\\n     * @inheritdoc IERC165\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC165) returns (bool) {\\n        return interfaceId == type(IContractEntity).interfaceId || super.supportsInterface(interfaceId);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/listing/listing-manager/IListingManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\nimport \\\"../Listings.sol\\\";\\n\\ninterface IListingManager is IContractEntity {\\n    /**\\n     * @dev Thrown when the message sender is not renting manager.\\n     */\\n    error CallerIsNotRentingManager();\\n\\n    /**\\n     * @dev Thrown when the message sender does not own LISTING_WIZARD role and is not lister.\\n     * @param listingId The Listing ID.\\n     * @param account The account that was checked.\\n     */\\n    error AccountIsNotAuthorizedOperatorForListingManagement(uint256 listingId, address account);\\n\\n    /**\\n     * @dev Thrown when the message sender does not own LISTING_WIZARD role\\n     */\\n    error AccountIsNotListingWizard(address account);\\n\\n    /**\\n     * @dev Thrown when assets array is empty.\\n     */\\n    error EmptyAssetsArray();\\n\\n    /**\\n     * @dev Thrown when asset collection is mismatched in one of the assets from assets array.\\n     */\\n    error AssetCollectionMismatch();\\n\\n    /**\\n     * @dev Thrown when the original asset cannot be withdrawn because of active rentals\\n     * or other activity that requires asset to stay in the vault.\\n     */\\n    error AssetIsLocked();\\n\\n    /**\\n     * @dev Thrown when the configurator returns a payment beneficiary different from lister.\\n     */\\n    error OnlyImmediatePayoutSupported();\\n\\n    /**\\n     * @dev Thrown when the Listing with `listingId`\\n     * is not registered among present or historical Listings,\\n     * meaning it has never existed.\\n     * @param listingId The ID of Listing that never existed.\\n     */\\n    error ListingNeverExisted(uint256 listingId);\\n\\n    /**\\n     * @dev Emitted when a new listing is created.\\n     * @param listingId Listing ID.\\n     * @param lister Lister account address.\\n     * @param assets Listing asset.\\n     * @param params Listing params.\\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\\n     */\\n    event ListingCreated(\\n        uint256 indexed listingId,\\n        address indexed lister,\\n        Assets.Asset[] assets,\\n        Listings.Params params,\\n        uint32 maxLockPeriod\\n    );\\n\\n    /**\\n     * @dev Emitted when the listing is no longer available for renting.\\n     * @param listingId Listing ID.\\n     * @param lister Lister account address.\\n     * @param unlocksAt The earliest possible time when the asset can be returned to the owner.\\n     */\\n    event ListingDisabled(uint256 indexed listingId, address indexed lister, uint32 unlocksAt);\\n\\n    /**\\n     * @dev Emitted when the asset is returned to the `lister`.\\n     * @param listingId Listing ID.\\n     * @param lister Lister account address.\\n     * @param assets Returned assets.\\n     */\\n    event ListingWithdrawal(uint256 indexed listingId, address indexed lister, Assets.Asset[] assets);\\n\\n    /**\\n     * @dev Emitted when the listing is paused.\\n     * @param listingId Listing ID.\\n     */\\n    event ListingPaused(uint256 indexed listingId);\\n\\n    /**\\n     * @dev Emitted when the listing pause is lifted.\\n     * @param listingId Listing ID.\\n     */\\n    event ListingUnpaused(uint256 indexed listingId);\\n\\n    /**\\n     * @dev Creates new listing.\\n     * Emits an {ListingCreated} event.\\n     * @param assets Assets to be listed.\\n     * @param params Listing params.\\n     * @param maxLockPeriod The maximum amount of time the original asset owner can wait before getting the asset back.\\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\\n     * @return listingId New listing ID.\\n     */\\n    function createListing(\\n        Assets.Asset[] calldata assets,\\n        Listings.Params calldata params,\\n        uint32 maxLockPeriod,\\n        bool immediatePayout\\n    ) external returns (uint256 listingId);\\n\\n    /**\\n     * @dev Updates listing lock time for Listing.\\n     * @param listingId Listing ID.\\n     * @param unlockTimestamp Timestamp when asset would be unlocked.\\n     */\\n    function addLock(uint256 listingId, uint32 unlockTimestamp) external;\\n\\n    /**\\n     * @dev Marks the assets as being delisted. This operation in irreversible.\\n     * After delisting, the asset can only be withdrawn when it has no active rentals.\\n     * Emits an {AssetDelisted} event.\\n     * @param listingId Listing ID.\\n     */\\n    function disableListing(uint256 listingId) external;\\n\\n    /**\\n     * @dev Returns the asset back to the lister.\\n     * Emits an {AssetWithdrawn} event.\\n     * @param listingId Listing ID.\\n     */\\n    function withdrawListingAssets(uint256 listingId) external;\\n\\n    /**\\n     * @dev Puts the listing on pause.\\n     * Emits a {ListingPaused} event.\\n     * @param listingId Listing ID.\\n     */\\n    function pauseListing(uint256 listingId) external;\\n\\n    /**\\n     * @dev Lifts the listing pause.\\n     * Emits a {ListingUnpaused} event.\\n     * @param listingId Listing ID.\\n     */\\n    function unpauseListing(uint256 listingId) external;\\n\\n    /**\\n     * @dev Returns the Listing details by the `listingId`.\\n     * Performs a look up among both\\n     * present (contains listed and delisted, but not yet withdrawn Listings)\\n     * and historical ones (withdrawn Listings only).\\n     * @param listingId Listing ID.\\n     * @return Listing details.\\n     */\\n    function listingInfo(uint256 listingId) external view returns (Listings.Listing memory);\\n\\n    /**\\n     * @dev Reverts if Listing is\\n     * neither registered among present ones nor listed.\\n     * @param listingId Listing ID.\\n     */\\n    function checkRegisteredAndListed(uint256 listingId) external view;\\n\\n    /**\\n     * @dev Reverts if the provided `account` does not own LISTING_WIZARD role.\\n     * @param account The account to check ownership for.\\n     */\\n    function checkIsListingWizard(address account) external view;\\n\\n    /**\\n     * @dev Returns the number of currently registered listings.\\n     * @return Listing count.\\n     */\\n    function listingCount() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return Listing IDs.\\n     * @return Listings.\\n     */\\n    function listings(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (uint256[] memory, Listings.Listing[] memory);\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for the particular lister account.\\n     * @param lister Lister address.\\n     * @return Listing count.\\n     */\\n    function userListingCount(address lister) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\\n     * @param lister Lister address.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return Listing IDs.\\n     * @return Listings.\\n     */\\n    function userListings(\\n        address lister,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listings.Listing[] memory);\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for the particular original asset address.\\n     * @param original Original asset address.\\n     * @return Listing count.\\n     */\\n    function assetListingCount(address original) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the particular original asset address.\\n     * @param original Original asset address.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return Listing IDs.\\n     * @return Listings.\\n     */\\n    function assetListings(\\n        address original,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listings.Listing[] memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Address.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary StringsUpgradeable {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../token/ERC721/IERC721.sol\\\";\\n\"\r\n    },\r\n    \"contracts/contract-registry/IContractEntity.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\ninterface IContractEntity is IERC165 {\\n    /**\\n     * @dev Thrown when contract entity does not implement the required interface.\\n     */\\n    error InvalidContractEntityInterface();\\n\\n    /**\\n     * @dev Returns implemented contract key.\\n     * @return Contract key;\\n     */\\n    function contractKey() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"contracts/listing/Listings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"./listing-terms-registry/IListingTermsRegistry.sol\\\";\\n\\nlibrary Listings {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n    using Listings for Registry;\\n    using Listings for Listing;\\n    using Assets for Assets.Asset;\\n\\n    /**\\n     * @dev Thrown when the Listing with `listingId`\\n     * is neither registered among present ones nor listed (disabled).\\n     */\\n    error ListingIsNeitherRegisteredNorListed(uint256 listingId);\\n\\n    /**\\n     * @dev Thrown when the Listing with `listingId` is not registered among present ones.\\n     */\\n    error ListingIsNotRegistered(uint256 listingId);\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the listing being paused.\\n     */\\n    error ListingIsPaused();\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the listing not being paused.\\n     */\\n    error ListingIsNotPaused();\\n\\n    /**\\n     * @dev Thrown when attempting to lock listed assets for the period longer than the lister allowed.\\n     */\\n    error InvalidLockPeriod(uint32 period);\\n\\n    /**\\n     * @dev Listing params.\\n     * The layout of `config.data` might vary for different listing strategies.\\n     * For example, in case of FIXED_RATE strategy, the `config.data` might contain only base rate,\\n     * and for more advanced auction strategies it might include period, min bid step etc.\\n     * @param lister Listing creator.\\n     * @param configurator Optional listing configurator address which may customize renting conditions.\\n     */\\n    struct Params {\\n        address lister;\\n        address configurator;\\n    }\\n\\n    /**\\n     * @dev Listing structure.\\n     * @param assets Listed assets structure.\\n     * @param lister Lister account address.\\n     * @param beneficiary The target to receive payments or other various rewards from rentals.\\n     * @param maxLockPeriod The maximum amount of time the assets owner can wait before getting the assets back.\\n     * @param lockedTill The earliest possible time when the assets can be returned to the owner.\\n     * @param configurator Optional listing configurator address which may customize renting conditions\\n     * @param immediatePayout Indicates whether the rental fee must be transferred to the lister on every renting.\\n     * If FALSE, the rental fees get accumulated until withdrawn manually.\\n     * @param enabled Indicates whether listing is enabled.\\n     * @param paused Indicates whether the listing is paused.\\n     */\\n    struct Listing {\\n        Assets.Asset[] assets;\\n        address lister;\\n        address beneficiary;\\n        uint32 maxLockPeriod;\\n        uint32 lockedTill;\\n        address configurator;\\n        bool immediatePayout;\\n        bool enabled;\\n        bool paused;\\n    }\\n\\n    /**\\n     * @dev Listing related data associated with the specific account.\\n     * @param listingIndex The set of listing IDs.\\n     */\\n    struct ListerInfo {\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n    }\\n\\n    /**\\n     * @dev Listing related data associated with the specific account.\\n     * @param listingIndex The set of listing IDs.\\n     */\\n    struct AssetInfo {\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n    }\\n\\n    /**\\n     * @dev Listing registry.\\n     * @param idTracker Listing ID tracker (incremental counter).\\n     * @param listingIndex The global set of registered listing IDs.\\n     * @param listings Mapping from listing ID to the listing info.\\n     * @param listers Mapping from lister address to the lister info.\\n     * @param assetCollections Mapping from an Asset Collection's address to the asset info.\\n     */\\n    struct Registry {\\n        CountersUpgradeable.Counter listingIdTracker;\\n        EnumerableSetUpgradeable.UintSet listingIndex;\\n        mapping(uint256 => Listing) listings;\\n        mapping(uint256 => Listing) listingsHistory;\\n        mapping(address => ListerInfo) listers;\\n        mapping(address => AssetInfo) assetCollections;\\n    }\\n\\n    /**\\n     * @dev Puts the listing on pause.\\n     */\\n    function pause(Listing storage self) internal {\\n        if (self.paused) revert ListingIsPaused();\\n\\n        self.paused = true;\\n    }\\n\\n    /**\\n     * @dev Lifts the listing pause.\\n     */\\n    function unpause(Listing storage self) internal {\\n        if (!self.paused) revert ListingIsNotPaused();\\n\\n        self.paused = false;\\n    }\\n\\n    /**\\n     * Determines whether the listing is registered and active.\\n     */\\n    function isRegisteredAndListed(Listing storage self) internal view returns (bool) {\\n        return self.isRegistered() && self.enabled;\\n    }\\n\\n    function isRegistered(Listing storage self) internal view returns (bool) {\\n        return self.lister != address(0);\\n    }\\n\\n    /**\\n     * @dev Reverts if the listing is paused.\\n     */\\n    function checkNotPaused(Listing memory self) internal pure {\\n        if (self.paused) revert ListingIsPaused();\\n    }\\n\\n    /*\\n     * @dev Validates lock period.\\n     */\\n    function isValidLockPeriod(Listing memory self, uint32 lockPeriod) internal pure returns (bool) {\\n        return (lockPeriod > 0 && lockPeriod <= self.maxLockPeriod);\\n    }\\n\\n    /**\\n     * Determines whether the caller address is assets lister.\\n     */\\n    function isAssetLister(\\n        Registry storage self,\\n        uint256 listingId,\\n        address caller\\n    ) internal view returns (bool) {\\n        return self.listings[listingId].lister == caller;\\n    }\\n\\n    /**\\n     * @dev Reverts if the lock period is not valid.\\n     */\\n    function checkValidLockPeriod(Listing memory self, uint32 lockPeriod) internal pure {\\n        if (!self.isValidLockPeriod(lockPeriod)) revert InvalidLockPeriod(lockPeriod);\\n    }\\n\\n    /**\\n     * @dev Extends listing lock time.\\n     * Does not modify the state if current lock time is larger.\\n     */\\n    function addLock(Listing storage self, uint32 unlockTimestamp) internal {\\n        // Listing is already locked till later time, no need to extend locking period.\\n        if (self.lockedTill >= unlockTimestamp) return;\\n        // Extend listing lock.\\n        self.lockedTill = unlockTimestamp;\\n    }\\n\\n    /**\\n     * @dev Registers new listing.\\n     * @return listingId New listing ID.\\n     */\\n    function register(Registry storage self, Listing memory listing) external returns (uint256 listingId) {\\n        // Generate new listing ID.\\n        self.listingIdTracker.increment();\\n        listingId = self.listingIdTracker.current();\\n\\n        // Add new listing ID to the global index.\\n        self.listingIndex.add(listingId);\\n        // Add user listing data.\\n        self.listers[listing.lister].listingIndex.add(listingId);\\n\\n        // Creating an instance of listing record\\n        Listing storage listingRecord = self.listings[listingId];\\n\\n        // Store new listing record.\\n        listingRecord.lister = listing.lister;\\n        listingRecord.beneficiary = listing.beneficiary;\\n        listingRecord.maxLockPeriod = listing.maxLockPeriod;\\n        listingRecord.lockedTill = listing.lockedTill;\\n        listingRecord.immediatePayout = listing.immediatePayout;\\n        listingRecord.enabled = listing.enabled;\\n        listingRecord.paused = listing.paused;\\n        listingRecord.configurator = listing.configurator;\\n\\n        // Extract collection address. All Original Assets are from the same Original Asset Collection.\\n        address originalCollectionAddress = listing.assets[0].token();\\n        self.assetCollections[originalCollectionAddress].listingIndex.add(listingId);\\n\\n        // Add assets to listing record and listing data.\\n        for (uint256 i = 0; i < listing.assets.length; i++) {\\n            listingRecord.assets.push(listing.assets[i]);\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes listing data.\\n     * @param listingId The ID of the listing to be deleted.\\n     */\\n    function remove(Registry storage self, uint256 listingId) external {\\n        // Creating an instance of listing record\\n        Listing storage listingRecord = self.listings[listingId];\\n\\n        // Remove the listing ID from the global index.\\n        self.listingIndex.remove(listingId);\\n        // Remove user listing data.\\n        self.listers[listingRecord.lister].listingIndex.remove(listingId);\\n\\n        // All Original Assets are from the same Original Assets Collection.\\n        address originalCollectionAddress = listingRecord.assets[0].token();\\n        self.assetCollections[originalCollectionAddress].listingIndex.remove(listingId);\\n\\n        listingRecord.enabled = false;\\n        self.listingsHistory[listingId] = listingRecord;\\n\\n        // Delete Listing.\\n        delete self.listings[listingId];\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings.\\n     */\\n    function allListings(\\n        Registry storage self,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the particular lister account.\\n     */\\n    function userListings(\\n        Registry storage self,\\n        address lister,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.listers[lister].listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listings for the original asset.\\n     */\\n    function assetListings(\\n        Registry storage self,\\n        address original,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Listing[] memory) {\\n        return self.paginateIndexedListings(self.assetCollections[original].listingIndex, offset, limit);\\n    }\\n\\n    /**\\n     * @dev Reverts if Listing is\\n     * neither registered among present Listings nor enabled.\\n     * @param listingId Listing ID.\\n     */\\n    function checkRegisteredAndListed(Registry storage self, uint256 listingId) internal view {\\n        if (!self.listings[listingId].isRegisteredAndListed()) revert ListingIsNeitherRegisteredNorListed(listingId);\\n    }\\n\\n    function checkRegistered(Registry storage self, uint256 listingId) internal view {\\n        if (!self.listings[listingId].isRegistered()) revert ListingIsNotRegistered(listingId);\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings.\\n     */\\n    function listingCount(Registry storage self) internal view returns (uint256) {\\n        return self.listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for a particular lister account.\\n     */\\n    function userListingCount(Registry storage self, address lister) internal view returns (uint256) {\\n        return self.listers[lister].listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered listings for a particular original asset.\\n     */\\n    function assetListingCount(Registry storage self, address original) internal view returns (uint256) {\\n        return self.assetCollections[original].listingIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered listing using provided index reference.\\n     */\\n    function paginateIndexedListings(\\n        Registry storage self,\\n        EnumerableSetUpgradeable.UintSet storage listingIndex,\\n        uint256 offset,\\n        uint256 limit\\n    ) internal view returns (uint256[] memory, Listing[] memory) {\\n        uint256 indexSize = listingIndex.length();\\n        if (offset >= indexSize) return (new uint256[](0), new Listing[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Listing[] memory listings = new Listing[](limit);\\n        uint256[] memory listingIds = new uint256[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            listingIds[i] = listingIndex.at(offset + i);\\n            listings[i] = self.listings[listingIds[i]];\\n        }\\n\\n        return (listingIds, listings);\\n    }\\n\\n    /**\\n     * @dev Returns the hash of listing terms strategy ID and data.\\n     * @param listingTerms Listing Terms.\\n     */\\n    function hash(IListingTermsRegistry.ListingTerms memory listingTerms) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(listingTerms.strategyId, listingTerms.strategyData));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC721/IERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/interfaces/IERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/introspection/IERC165.sol\\\";\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Counters\\n * @author Matt Condon (@shrugs)\\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\\n *\\n * Include with `using Counters for Counters.Counter;`\\n */\\nlibrary CountersUpgradeable {\\n    struct Counter {\\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\\n        uint256 _value; // default: 0\\n    }\\n\\n    function current(Counter storage counter) internal view returns (uint256) {\\n        return counter._value;\\n    }\\n\\n    function increment(Counter storage counter) internal {\\n        unchecked {\\n            counter._value += 1;\\n        }\\n    }\\n\\n    function decrement(Counter storage counter) internal {\\n        uint256 value = counter._value;\\n        require(value > 0, \\\"Counter: decrement overflow\\\");\\n        unchecked {\\n            counter._value = value - 1;\\n        }\\n    }\\n\\n    function reset(Counter storage counter) internal {\\n        counter._value = 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableSet.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSetUpgradeable {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        return _values(set._inner);\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/asset/Assets.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./IAssetController.sol\\\";\\nimport \\\"./IAssetVault.sol\\\";\\nimport \\\"./asset-class-registry/IAssetClassRegistry.sol\\\";\\n\\nlibrary Assets {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using Address for address;\\n    using Assets for Registry;\\n    using Assets for Asset;\\n    using Assets for AssetId;\\n\\n    /*\\n     * @dev This is the list of asset class identifiers to be used across the system.\\n     */\\n    bytes4 public constant ERC721 = bytes4(keccak256(\\\"ERC721\\\"));\\n    bytes4 public constant ERC1155 = bytes4(keccak256(\\\"ERC1155\\\"));\\n\\n    bytes32 public constant ASSET_ID_TYPEHASH = keccak256(\\\"AssetId(bytes4 class,bytes data)\\\");\\n\\n    bytes32 public constant ASSET_TYPEHASH =\\n        keccak256(\\\"Asset(AssetId id,uint256 value)AssetId(bytes4 class,bytes data)\\\");\\n\\n    /**\\n     * @dev Thrown upon attempting to register an asset twice.\\n     * @param asset Duplicate asset address.\\n     */\\n    error AssetIsAlreadyRegistered(address asset);\\n\\n    /**\\n     * @dev Thrown when target for operation asset is not registered\\n     * @param asset Asset address, which is not registered.\\n     */\\n    error AssetIsNotRegistered(address asset);\\n\\n    /**\\n     * @dev Communicates asset identification information.\\n     * The structure designed to be token-standard agnostic,\\n     * so the layout of `data` might vary for different token standards.\\n     * For example, in case of ERC721 token, the `data` will contain contract address and tokenId.\\n     * @param class Asset class ID\\n     * @param data Asset identification data.\\n     */\\n    struct AssetId {\\n        bytes4 class;\\n        bytes data;\\n    }\\n\\n    /**\\n     * @dev Calculates Asset ID hash\\n     */\\n    function hash(AssetId memory assetId) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ASSET_ID_TYPEHASH, assetId.class, keccak256(assetId.data)));\\n    }\\n\\n    /**\\n     * @dev Extracts token contract address from the Asset ID structure.\\n     * The address is the common attribute for all assets regardless of their asset class.\\n     */\\n    function token(AssetId memory self) internal pure returns (address) {\\n        return abi.decode(self.data, (address));\\n    }\\n\\n    function hash(Assets.AssetId[] memory assetIds) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(assetIds));\\n    }\\n\\n    /**\\n     * @dev Uniformed structure to describe arbitrary asset (token) and its value.\\n     * @param id Asset ID structure.\\n     * @param value Asset value (amount).\\n     */\\n    struct Asset {\\n        AssetId id;\\n        uint256 value;\\n    }\\n\\n    /**\\n     * @dev Calculates Asset hash\\n     */\\n    function hash(Asset memory asset) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(ASSET_TYPEHASH, hash(asset.id), asset.value));\\n    }\\n\\n    /**\\n     * @dev Extracts token contract address from the Asset structure.\\n     * The address is the common attribute for all assets regardless of their asset class.\\n     */\\n    function token(Asset memory self) internal pure returns (address) {\\n        return abi.decode(self.id.data, (address));\\n    }\\n\\n    function toIds(Assets.Asset[] memory assets) internal pure returns (Assets.AssetId[] memory result) {\\n        result = new Assets.AssetId[](assets.length);\\n        for (uint256 i = 0; i < assets.length; i++) {\\n            result[i] = assets[i].id;\\n        }\\n    }\\n\\n    function hashIds(Assets.Asset[] memory assets) internal pure returns (bytes32) {\\n        return hash(toIds(assets));\\n    }\\n\\n    /**\\n     * @dev Original asset data.\\n     * @param controller Asset controller.\\n     * @param assetClass The asset class identifier.\\n     * @param vault Asset vault.\\n     */\\n    struct AssetConfig {\\n        IAssetController controller;\\n        bytes4 assetClass;\\n        IAssetVault vault;\\n    }\\n\\n    /**\\n     * @dev Asset registry.\\n     * @param classRegistry Asset class registry contract.\\n     * @param assetIndex Set of registered asset addresses.\\n     * @param assets Mapping from asset address to the asset configuration.\\n     */\\n    struct Registry {\\n        IAssetClassRegistry classRegistry;\\n        EnumerableSetUpgradeable.AddressSet assetIndex;\\n        mapping(address => AssetConfig) assets;\\n    }\\n\\n    /**\\n     * @dev Registers new asset.\\n     */\\n    function registerAsset(\\n        Registry storage self,\\n        bytes4 assetClass,\\n        address asset\\n    ) external {\\n        if (self.assetIndex.add(asset)) {\\n            IAssetClassRegistry.ClassConfig memory assetClassConfig = self.classRegistry.assetClassConfig(assetClass);\\n            self.assets[asset] = AssetConfig({\\n                controller: IAssetController(assetClassConfig.controller),\\n                assetClass: assetClass,\\n                vault: IAssetVault(assetClassConfig.vault)\\n            });\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered asset configs.\\n     */\\n    function supportedAssets(\\n        Registry storage self,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, AssetConfig[] memory) {\\n        uint256 indexSize = self.assetIndex.length();\\n        if (offset >= indexSize) return (new address[](0), new AssetConfig[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        AssetConfig[] memory assetConfigs = new AssetConfig[](limit);\\n        address[] memory assetAddresses = new address[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            assetAddresses[i] = self.assetIndex.at(offset + i);\\n            assetConfigs[i] = self.assets[assetAddresses[i]];\\n        }\\n        return (assetAddresses, assetConfigs);\\n    }\\n\\n    /**\\n     * @dev Transfers an asset to the vault using associated controller.\\n     */\\n    function transferAssetToVault(\\n        Registry storage self,\\n        Assets.Asset memory asset,\\n        address from\\n    ) external {\\n        // Extract token address from asset struct and check whether the asset is supported.\\n        address assetToken = asset.token();\\n\\n        if (!isRegisteredAsset(self, assetToken)) revert AssetIsNotRegistered(assetToken);\\n\\n        // Transfer asset to the class asset specific vault.\\n        AssetConfig memory assetConfig = self.assets[assetToken];\\n        address assetController = address(assetConfig.controller);\\n        address assetVault = address(assetConfig.vault);\\n\\n        assetController.functionDelegateCall(\\n            abi.encodeWithSelector(IAssetController.transferAssetToVault.selector, asset, from, assetVault)\\n        );\\n    }\\n\\n    /**\\n     * @dev Transfers an asset from the vault using associated controller.\\n     */\\n    function returnAssetFromVault(Registry storage self, Assets.Asset calldata asset) external {\\n        address assetToken = asset.token();\\n\\n        AssetConfig memory assetConfig = self.assets[assetToken];\\n        address assetController = address(assetConfig.controller);\\n        address assetVault = address(assetConfig.vault);\\n\\n        assetController.functionDelegateCall(\\n            abi.encodeWithSelector(IAssetController.returnAssetFromVault.selector, asset, assetVault)\\n        );\\n    }\\n\\n    function assetCount(Registry storage self) internal view returns (uint256) {\\n        return self.assetIndex.length();\\n    }\\n\\n    /**\\n     * @dev Checks asset registration by address.\\n     */\\n    function isRegisteredAsset(Registry storage self, address asset) internal view returns (bool) {\\n        return self.assetIndex.contains(asset);\\n    }\\n\\n    /**\\n     * @dev Returns controller for asset class.\\n     * @param assetClass Asset class ID.\\n     */\\n    function assetClassController(Registry storage self, bytes4 assetClass) internal view returns (address) {\\n        return self.classRegistry.assetClassConfig(assetClass).controller;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/listing/listing-terms-registry/IListingTermsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\n\\ninterface IListingTermsRegistry is IContractEntity {\\n    /**\\n     * @dev Thrown upon attempting to work with unregistered listing terms.\\n     */\\n    error UnregisteredListingTerms(uint256 listingTermsId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with listing terms with params that have more specific terms on warper level.\\n     */\\n    error MoreSpecificListingTermsExistForWarper(uint256 listingTermsId, uint256 listingId, address warperAddress);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with listing terms with\\n     * params that have more specific terms on universe level.\\n     */\\n    error MoreSpecificListingTermsExistForUniverse(uint256 listingTermsId, uint256 listingId, uint256 universeId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with listing without listing terms.\\n     */\\n    error WrongListingTermsIdForParams(\\n        uint256 listingTermsId,\\n        uint256 listingId,\\n        uint256 universeId,\\n        address warperAddress\\n    );\\n\\n    /**\\n     * @dev Thrown upon attempting to work with listing without listing terms on global level.\\n     */\\n    error GlobalListingTermsMismatch(uint256 listingId, uint256 listingTermsId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with listing without listing terms on universe level.\\n     */\\n    error UniverseListingTermsMismatch(uint256 listingId, uint256 universeId, uint256 listingTermsId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with listing without listing terms on warper level.\\n     */\\n    error WarperListingTermsMismatch(uint256 listingId, address warperAddress, uint256 listingTermsId);\\n\\n    /**\\n     * @dev Emitted when the new listing terms are registered.\\n     * @param listingTermsId Listing terms ID.\\n     * @param strategyId Listing strategy ID.\\n     * @param strategyData Listing strategy data.\\n     */\\n    event ListingTermsRegistered(uint256 indexed listingTermsId, bytes4 indexed strategyId, bytes strategyData);\\n\\n    /**\\n     * @dev Emitted when existing global listing terms are registered.\\n     * @param listingId Listing group ID.\\n     * @param listingTermsId Listing terms ID.\\n     */\\n    event GlobalListingTermsRegistered(uint256 indexed listingId, uint256 indexed listingTermsId);\\n\\n    /**\\n     * @dev Emitted when the global listing terms are removed.\\n     * @param listingId Listing group ID.\\n     * @param listingTermsId Listing terms ID.\\n     */\\n    event GlobalListingTermsRemoved(uint256 indexed listingId, uint256 indexed listingTermsId);\\n\\n    /**\\n     * @dev Emitted when universe listing terms are registered.\\n     * @param listingId Listing group ID.\\n     * @param universeId Universe ID.\\n     * @param listingTermsId Listing terms ID.\\n     */\\n    event UniverseListingTermsRegistered(\\n        uint256 indexed listingId,\\n        uint256 indexed universeId,\\n        uint256 indexed listingTermsId\\n    );\\n\\n    /**\\n     * @dev Emitted when universe listing terms are removed.\\n     * @param listingId Listing group ID.\\n     * @param universeId Universe ID.\\n     * @param listingTermsId Listing terms ID.\\n     */\\n    event UniverseListingTermsRemoved(\\n        uint256 indexed listingId,\\n        uint256 indexed universeId,\\n        uint256 indexed listingTermsId\\n    );\\n\\n    /**\\n     * @dev Emitted when the warper listing terms are registered.\\n     * @param listingId Listing group ID.\\n     * @param warperAddress Address of the warper.\\n     * @param listingTermsId Listing terms ID.\\n     */\\n    event WarperListingTermsRegistered(\\n        uint256 indexed listingId,\\n        address indexed warperAddress,\\n        uint256 indexed listingTermsId\\n    );\\n\\n    /**\\n     * @dev Emitted when warper level lister's listing terms are removed.\\n     * @param listingId Listing group ID.\\n     * @param warperAddress Address of the warper.\\n     * @param listingTermsId Listing terms ID.\\n     */\\n    event WarperListingTermsRemoved(\\n        uint256 indexed listingId,\\n        address indexed warperAddress,\\n        uint256 indexed listingTermsId\\n    );\\n\\n    /**\\n     * @dev Listing terms information.\\n     * @param strategyId Listing strategy ID.\\n     * @param strategyData Listing strategy data.\\n     */\\n    struct ListingTerms {\\n        bytes4 strategyId;\\n        bytes strategyData;\\n    }\\n\\n    /**\\n     * @dev Listing Terms parameters.\\n     * @param listingId Listing ID.\\n     * @param universeId Universe ID.\\n     * @param warperAddress Address of the warper.\\n     */\\n    struct Params {\\n        uint256 listingId;\\n        uint256 universeId;\\n        address warperAddress;\\n    }\\n\\n    /**\\n     * @dev Registers global listing terms.\\n     * @param listingId Listing ID.\\n     * @param terms Listing terms data.\\n     * @return listingTermsId Listing terms ID.\\n     */\\n    function registerGlobalListingTerms(uint256 listingId, ListingTerms calldata terms)\\n        external\\n        returns (uint256 listingTermsId);\\n\\n    /**\\n     * @dev Removes global listing terms.\\n     * @param listingId Listing ID.\\n     * @param listingTermsId Listing Terms ID.\\n     */\\n    function removeGlobalListingTerms(uint256 listingId, uint256 listingTermsId) external;\\n\\n    /**\\n     * @dev Registers universe listing terms.\\n     * @param listingId Listing ID.\\n     * @param universeId Universe ID.\\n     * @param terms Listing terms data.\\n     * @return listingTermsId Listing terms ID.\\n     */\\n    function registerUniverseListingTerms(\\n        uint256 listingId,\\n        uint256 universeId,\\n        ListingTerms calldata terms\\n    ) external returns (uint256 listingTermsId);\\n\\n    /**\\n     * @dev Removes universe listing terms.\\n     * @param listingId Listing ID.\\n     * @param universeId Universe ID.\\n     * @param listingTermsId Listing terms ID.\\n     */\\n    function removeUniverseListingTerms(\\n        uint256 listingId,\\n        uint256 universeId,\\n        uint256 listingTermsId\\n    ) external;\\n\\n    /**\\n     * @dev Registers warper listing terms.\\n     * @param listingId Listing ID.\\n     * @param warperAddress The address of the warper.\\n     * @param terms Listing terms.\\n     * @return listingTermsId Listing terms ID.\\n     */\\n    function registerWarperListingTerms(\\n        uint256 listingId,\\n        address warperAddress,\\n        ListingTerms calldata terms\\n    ) external returns (uint256 listingTermsId);\\n\\n    /**\\n     * @dev Removes warper listing terms.\\n     * @param listingId Listing ID.\\n     * @param warperAddress The address of the warper.\\n     * @param listingTermsId Listing terms ID\\n     */\\n    function removeWarperListingTerms(\\n        uint256 listingId,\\n        address warperAddress,\\n        uint256 listingTermsId\\n    ) external;\\n\\n    /**\\n     * @dev Returns listing terms by ID.\\n     * @param listingTermsId Listing terms ID.\\n     * @return Listing Terms.\\n     */\\n    function listingTerms(uint256 listingTermsId) external view returns (ListingTerms memory);\\n\\n    /**\\n     * @dev Returns listing terms by ID.\\n     * @param listingTermsId Listing terms ID.\\n     * @return Listing Terms.\\n     * @return Listing Terms Params.\\n     */\\n    function listingTermsWithParams(uint256 listingTermsId) external view returns (ListingTerms memory, Params memory);\\n\\n    /**\\n     * @dev Returns all listing terms for params.\\n     * @param params Listing terms specific params.\\n     * @param offset List offset value.\\n     * @param limit List limit value.\\n     * @return List of Listing Terms IDs.\\n     * @return List of Listing Terms.\\n     */\\n    function allListingTerms(\\n        Params calldata params,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, ListingTerms[] memory);\\n\\n    /**\\n     * @dev Checks registration of listing terms.\\n     * @param listingTermsId Listing Terms ID.\\n     * @return Boolean that is positive in case of existance\\n     */\\n    function areRegisteredListingTerms(uint256 listingTermsId) external view returns (bool);\\n\\n    /**\\n     * @dev Checks registration of listing terms.\\n     * @param listingTermsId Listing Terms ID.\\n     * @param params Listing terms specific params.\\n     * @return Boolean that is positive in case of existance\\n     */\\n    function areRegisteredListingTermsWithParams(uint256 listingTermsId, Params memory params)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Checks registration of listing terms.\\n     *      Reverts with UnregisteredListingTerms() in case listing terms were not registered.\\n     * @param listingTermsId Listing Terms ID.\\n     */\\n    function checkRegisteredListingTerms(uint256 listingTermsId) external view;\\n\\n    /**\\n     * @dev Checks registration of listing terms for lister on global, universe and warper levels.\\n     *      Reverts in case of absence of listing terms on all levels.\\n     * @param listingTermsId Listing Terms ID.\\n     * @param params Listing terms specific params.\\n     */\\n    function checkRegisteredListingTermsWithParams(uint256 listingTermsId, Params memory params) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/asset/IAssetController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"./Assets.sol\\\";\\n\\ninterface IAssetController is IERC165 {\\n    /**\\n     * @dev Thrown when the asset has invalid class for specific operation.\\n     * @param provided Provided class ID.\\n     * @param required Required class ID.\\n     */\\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\\n\\n    // @dev Thrown when asset token address order is violated\\n    error AssetCollectionMismatch(address expected, address actual);\\n\\n    // @dev Thrown when asset token id order is violated\\n    error AssetOrderMismatch(address token, uint256 left, uint256 right);\\n\\n    /**\\n     * @dev Emitted when asset is transferred.\\n     * @param asset Asset being transferred.\\n     * @param from Asset sender.\\n     * @param to Asset recipient.\\n     * @param data Auxiliary data.\\n     */\\n    event AssetTransfer(Assets.Asset asset, address indexed from, address indexed to, bytes data);\\n\\n    /**\\n     * @dev Returns controller asset class.\\n     * @return Asset class ID.\\n     */\\n    function assetClass() external pure returns (bytes4);\\n\\n    /**\\n     * @dev Transfers asset.\\n     * Emits a {AssetTransfer} event.\\n     * @param asset Asset being transferred.\\n     * @param from Asset sender.\\n     * @param to Asset recipient.\\n     * @param data Auxiliary data.\\n     */\\n    function transfer(\\n        Assets.Asset memory asset,\\n        address from,\\n        address to,\\n        bytes memory data\\n    ) external;\\n\\n    /**\\n     * @dev Transfers asset from owner to the vault contract.\\n     * @param asset Asset being transferred.\\n     * @param assetOwner Original asset owner address.\\n     * @param vault Asset vault contract address.\\n     */\\n    function transferAssetToVault(\\n        Assets.Asset memory asset,\\n        address assetOwner,\\n        address vault\\n    ) external;\\n\\n    /**\\n     * @dev Transfers asset from the vault contract to the original owner.\\n     * @param asset Asset being transferred.\\n     * @param vault Asset vault contract address.\\n     */\\n    function returnAssetFromVault(Assets.Asset calldata asset, address vault) external;\\n\\n    /**\\n     * @dev Decodes asset ID structure and returns collection identifier.\\n     * The collection ID is bytes32 value which is calculated based on the asset class.\\n     * For example, ERC721 collection can be identified by address only,\\n     * but for ERC1155 it should be calculated based on address and token ID.\\n     * @return Collection ID.\\n     */\\n    function collectionId(Assets.AssetId memory assetId) external pure returns (bytes32);\\n\\n    /**\\n     * @dev Ensures asset array is sorted in incremental order.\\n     *      This is required for batched listings to guarantee\\n     *      stable hashing\\n     */\\n    function ensureSorted(Assets.AssetId[] calldata assets) external pure;\\n}\\n\"\r\n    },\r\n    \"contracts/asset/IAssetVault.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IAssetVault is IERC165 {\\n    /**\\n     * @dev Thrown when the asset is not is found among vault inventory.\\n     */\\n    error AssetNotFound();\\n\\n    /**\\n     * @dev Thrown when the function is called on the vault in recovery mode.\\n     */\\n    error VaultIsInRecoveryMode();\\n\\n    /**\\n     * @dev Thrown when the asset return is not allowed, due to the vault state or the caller permissions.\\n     */\\n    error AssetReturnIsNotAllowed();\\n\\n    /**\\n     * @dev Thrown when the asset deposit is not allowed, due to the vault state or the caller permissions.\\n     */\\n    error AssetDepositIsNotAllowed();\\n\\n    /**\\n     * @dev Emitted when the vault is switched to recovery mode by `account`.\\n     */\\n    event RecoveryModeActivated(address account);\\n\\n    /**\\n     * @dev Activates asset recovery mode.\\n     * Emits a {RecoveryModeActivated} event.\\n     */\\n    function switchToRecoveryMode() external;\\n\\n    /**\\n     * @notice Send ERC20 tokens to an address.\\n     */\\n    function withdrawERC20Tokens(\\n        IERC20 token,\\n        address to,\\n        uint256 amount\\n    ) external;\\n\\n    /**\\n     * @dev Pauses the vault.\\n     */\\n    function pause() external;\\n\\n    /**\\n     * @dev Unpauses the vault.\\n     */\\n    function unpause() external;\\n\\n    /**\\n     * @dev Returns vault asset class.\\n     * @return Asset class ID.\\n     */\\n    function assetClass() external pure returns (bytes4);\\n\\n    /**\\n     * @dev Returns the Metahub address.\\n     */\\n    function metahub() external view returns (address);\\n\\n    /**\\n     * @dev Returns vault recovery mode flag state.\\n     * @return True when the vault is in recovery mode.\\n     */\\n    function isRecovery() external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/asset/asset-class-registry/IAssetClassRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\n\\ninterface IAssetClassRegistry is IContractEntity {\\n    /**\\n     * @dev Thrown when the asset class supported by contract does not match the required one.\\n     * @param provided Provided class ID.\\n     * @param required Required class ID.\\n     */\\n    error AssetClassMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Thrown upon attempting to register an asset class twice.\\n     * @param assetClass Duplicate asset class ID.\\n     */\\n    error AssetClassIsAlreadyRegistered(bytes4 assetClass);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with unregistered asset class.\\n     * @param assetClass Asset class ID.\\n     */\\n    error UnregisteredAssetClass(bytes4 assetClass);\\n\\n    /**\\n     * @dev Thrown when the asset controller contract does not implement the required interface.\\n     */\\n    error InvalidAssetControllerInterface();\\n\\n    /**\\n     * @dev Thrown when the vault contract does not implement the required interface.\\n     */\\n    error InvalidAssetVaultInterface();\\n\\n    /**\\n     * @dev Emitted when the new asset class is registered.\\n     * @param assetClass Asset class ID.\\n     * @param controller Controller address.\\n     * @param vault Vault address.\\n     */\\n    event AssetClassRegistered(bytes4 indexed assetClass, address indexed controller, address indexed vault);\\n\\n    /**\\n     * @dev Emitted when the asset class controller is changed.\\n     * @param assetClass Asset class ID.\\n     * @param newController New controller address.\\n     */\\n    event AssetClassControllerChanged(bytes4 indexed assetClass, address indexed newController);\\n\\n    /**\\n     * @dev Emitted when the asset class vault is changed.\\n     * @param assetClass Asset class ID.\\n     * @param newVault New vault address.\\n     */\\n    event AssetClassVaultChanged(bytes4 indexed assetClass, address indexed newVault);\\n\\n    /**\\n     * @dev Asset class configuration.\\n     * @param vault Asset class vault.\\n     * @param controller Asset class controller.\\n     */\\n    struct ClassConfig {\\n        address vault;\\n        address controller;\\n    }\\n\\n    /**\\n     * @dev Registers new asset class.\\n     * @param assetClass Asset class ID.\\n     * @param config Asset class initial configuration.\\n     */\\n    function registerAssetClass(bytes4 assetClass, ClassConfig calldata config) external;\\n\\n    /**\\n     * @dev Sets asset class vault.\\n     * @param assetClass Asset class ID.\\n     * @param vault Asset class vault address.\\n     */\\n    function setAssetClassVault(bytes4 assetClass, address vault) external;\\n\\n    /**\\n     * @dev Sets asset class controller.\\n     * @param assetClass Asset class ID.\\n     * @param controller Asset class controller address.\\n     */\\n    function setAssetClassController(bytes4 assetClass, address controller) external;\\n\\n    /**\\n     * @dev Returns asset class configuration.\\n     * @param assetClass Asset class ID.\\n     * @return Asset class configuration.\\n     */\\n    function assetClassConfig(bytes4 assetClass) external view returns (ClassConfig memory);\\n\\n    /**\\n     * @dev Checks asset class registration.\\n     * @param assetClass Asset class ID.\\n     */\\n    function isRegisteredAssetClass(bytes4 assetClass) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if asset class is not registered.\\n     * @param assetClass Asset class ID.\\n     */\\n    function checkRegisteredAssetClass(bytes4 assetClass) external view;\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/metahub/core/IMetahub.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable no-empty-blocks\\npragma solidity ^0.8.13;\\n\\nimport \\\"../IProtocolConfigManager.sol\\\";\\nimport \\\"../../accounting/IPaymentManager.sol\\\";\\nimport \\\"../../asset/IAssetManager.sol\\\";\\nimport \\\"../../contract-registry/IContractRegistry.sol\\\";\\n\\ninterface IMetahub is IProtocolConfigManager, IPaymentManager, IAssetManager, IContractRegistry {\\n    /**\\n     * @dev Raised when the caller is not the WarperManager contract.\\n     */\\n    error CallerIsNotWarperManager();\\n\\n    /**\\n     * @dev Raised when the caller is not the ListingManager contract.\\n     */\\n    error CallerIsNotListingManager();\\n\\n    /**\\n     * @dev Raised when the caller is not the RentingManager contract.\\n     */\\n    error CallerIsNotRentingManager();\\n\\n    /**\\n     * @dev Raised when the caller is not the ERC20RewardDistributor contract.\\n     */\\n    error CallerIsNotERC20RewardDistributor();\\n}\\n\"\r\n    },\r\n    \"contracts/contract-registry/Contracts.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\n/**\\n * @title IQ Protocol Contracts and their keys.\\n */\\nlibrary Contracts {\\n    /**** Accounting ****/\\n    bytes4 public constant ERC20_REWARD_DISTRIBUTOR = bytes4(keccak256(\\\"ERC20RewardDistributor\\\"));\\n    bytes4 public constant TOKEN_QUOTE = bytes4(keccak256(\\\"TokenQuote\\\"));\\n    /**** ACL ****/\\n    bytes4 public constant ACL = bytes4(keccak256(\\\"ACL\\\"));\\n    /**** Asset ****/\\n    bytes4 public constant ASSET_CLASS_REGISTRY = bytes4(keccak256(\\\"AssetClassRegistry\\\"));\\n    /**** Listing & Listing Configurator ****/\\n    bytes4 public constant LISTING_MANAGER = bytes4(keccak256(\\\"ListingManager\\\"));\\n    bytes4 public constant LISTING_CONFIGURATOR_REGISTRY = bytes4(keccak256(\\\"ListingConfiguratorRegistry\\\"));\\n    bytes4 public constant LISTING_CONFIGURATOR_PRESET_FACTORY = bytes4(keccak256(\\\"ListingConfiguratorPresetFactory\\\"));\\n    bytes4 public constant LISTING_STRATEGY_REGISTRY = bytes4(keccak256(\\\"ListingStrategyRegistry\\\"));\\n    bytes4 public constant LISTING_TERMS_REGISTRY = bytes4(keccak256(\\\"ListingTermsRegistry\\\"));\\n    bytes4 public constant FIXED_RATE_LISTING_CONTROLLER = bytes4(keccak256(\\\"FixedRateListingController\\\"));\\n    bytes4 public constant FIXED_RATE_WITH_REWARD_LISTING_CONTROLLER =\\n        bytes4(keccak256(\\\"FixedRateWithRewardListingController\\\"));\\n    /**** Renting ****/\\n    bytes4 public constant RENTING_MANAGER = bytes4(keccak256(\\\"RentingManager\\\"));\\n    /**** Universe & Tax ****/\\n    bytes4 public constant UNIVERSE_REGISTRY = bytes4(keccak256(\\\"UniverseRegistry\\\"));\\n    bytes4 public constant TAX_STRATEGY_REGISTRY = bytes4(keccak256(\\\"TaxStrategyRegistry\\\"));\\n    bytes4 public constant TAX_TERMS_REGISTRY = bytes4(keccak256(\\\"TaxTermsRegistry\\\"));\\n    bytes4 public constant FIXED_RATE_TAX_CONTROLLER = bytes4(keccak256(\\\"FixedRateTaxController\\\"));\\n    bytes4 public constant FIXED_RATE_WITH_REWARD_TAX_CONTROLLER =\\n        bytes4(keccak256(\\\"FixedRateWithRewardTaxController\\\"));\\n    /**** Warper ****/\\n    bytes4 public constant WARPER_MANAGER = bytes4(keccak256(\\\"WarperManager\\\"));\\n    bytes4 public constant WARPER_PRESET_FACTORY = bytes4(keccak256(\\\"WarperPresetFactory\\\"));\\n    /**** Wizards v1 ****/\\n    bytes4 public constant LISTING_WIZARD_V1 = bytes4(keccak256(\\\"ListingWizardV1\\\"));\\n    bytes4 public constant RENTING_WIZARD_V1 = bytes4(keccak256(\\\"RentingWizardV1\\\"));\\n    bytes4 public constant GENERAL_GUILD_WIZARD_V1 = bytes4(keccak256(\\\"GeneralGuildWizardV1\\\"));\\n    bytes4 public constant UNIVERSE_WIZARD_V1 = bytes4(keccak256(\\\"UniverseWizardV1\\\"));\\n    bytes4 public constant WARPER_WIZARD_V1 = bytes4(keccak256(\\\"WarperWizardV1\\\"));\\n}\\n\"\r\n    },\r\n    \"contracts/warper/warper-manager/IWarperManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\nimport \\\"./Warpers.sol\\\";\\n\\ninterface IWarperManager is IContractEntity {\\n    /**\\n     * @dev Thrown when the `account` is not a Wizard authorized for Warper Management.\\n     * @param account The account that was checked.\\n     */\\n    error AccountIsNotAuthorizedWizardForWarperManagement(address account);\\n\\n    /**\\n     * @dev Thrown when the `account` is not an Operator authorized for Warper Management.\\n     * @param warper The Warper's address.\\n     * @param account The account that was checked.\\n     */\\n    error AccountIsNotAuthorizedOperatorForWarperManagement(address warper, address account);\\n\\n    /**\\n     * @dev Thrown when the `account` is not a Warper admin for `warper`.\\n     * @param warper The Warper.\\n     * @param account The account that was checked.\\n     */\\n    error AccountIsNotWarperAdmin(address warper, address account);\\n\\n    /**\\n     * @dev Warper registration params.\\n     * @param name The warper name.\\n     * @param universeId The universe ID.\\n     * @param paused Indicates whether the warper should stay paused after registration.\\n     */\\n    struct WarperRegistrationParams {\\n        string name;\\n        uint256 universeId;\\n        bool paused;\\n    }\\n\\n    /**\\n     * @dev Emitted when a new warper is registered.\\n     * @param universeId Universe ID.\\n     * @param warper Warper address.\\n     * @param original Original asset address.\\n     * @param assetClass Asset class ID (identical for the `original` and `warper`).\\n     */\\n    event WarperRegistered(\\n        uint256 indexed universeId,\\n        address indexed warper,\\n        address indexed original,\\n        bytes4 assetClass\\n    );\\n\\n    /**\\n     * @dev Emitted when the warper is no longer registered.\\n     * @param warper Warper address.\\n     */\\n    event WarperDeregistered(address indexed warper);\\n\\n    /**\\n     * @dev Emitted when the warper is paused.\\n     * @param warper Address.\\n     */\\n    event WarperPaused(address indexed warper);\\n\\n    /**\\n     * @dev Emitted when the warper pause is lifted.\\n     * @param warper Address.\\n     */\\n    event WarperUnpaused(address indexed warper);\\n\\n    /**\\n     * @dev Registers a new warper.\\n     * The warper must be deployed and configured prior to registration,\\n     * since it becomes available for renting immediately.\\n     * @param warper Warper address.\\n     * @param params Warper registration params.\\n     */\\n    function registerWarper(address warper, WarperRegistrationParams memory params) external;\\n\\n    /**\\n     * @dev Deletes warper registration information.\\n     * All current rental agreements with the warper will stay intact, but the new rentals won't be possible.\\n     * @param warper Warper address.\\n     */\\n    function deregisterWarper(address warper) external;\\n\\n    /**\\n     * @dev Puts the warper on pause.\\n     * Emits a {WarperPaused} event.\\n     * @param warper Address.\\n     */\\n    function pauseWarper(address warper) external;\\n\\n    /**\\n     * @dev Lifts the warper pause.\\n     * Emits a {WarperUnpaused} event.\\n     * @param warper Address.\\n     */\\n    function unpauseWarper(address warper) external;\\n\\n    /**\\n     * @dev Sets the new controller address for one or multiple registered warpers.\\n     * @param warpers A list of registered warper addresses which controller will be changed.\\n     * @param controller Warper controller address.\\n     */\\n    function setWarperController(address[] calldata warpers, address controller) external;\\n\\n    /**\\n     * @dev Reverts if the warpers universe owner is not the provided account address.\\n     * @param warper Warpers address.\\n     * @param account The address that's expected to be the warpers universe owner.\\n     */\\n    function checkWarperAdmin(address warper, address account) external view;\\n\\n    /**\\n     * @dev Reverts if warper is not registered.\\n     */\\n    function checkRegisteredWarper(address warper) external view;\\n\\n    /**\\n     * @dev Reverts if no warpers are registered for the universe.\\n     */\\n    function checkUniverseHasWarper(uint256 universeId) external view;\\n\\n    /**\\n     * @dev Reverts if no warpers are registered for asset in the certain universe.\\n     */\\n    function checkUniverseHasWarperForAsset(uint256 universeId, address asset) external view;\\n\\n    /**\\n     * @dev Reverts if the provided `account` is not a Wizard authorized for Warper Management.\\n     * @param account The account to check for.\\n     */\\n    function checkIsAuthorizedWizardForWarperManagement(address account) external view;\\n\\n    /**\\n     * @dev Returns the number of warpers belonging to the particular universe.\\n     * @param universeId The universe ID.\\n     * @return Warper count.\\n     */\\n    function universeWarperCount(uint256 universeId) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of warpers belonging to the particular universe.\\n     * @param universeId The universe ID.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return List of warper addresses.\\n     * @return List of warpers.\\n     */\\n    function universeWarpers(\\n        uint256 universeId,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, Warpers.Warper[] memory);\\n\\n    /**\\n     * @dev Returns the list of warpers belonging to the particular asset in universe.\\n     * @param universeId The universe ID.\\n     * @param asset Original asset.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return List of warper addresses.\\n     * @return List of warpers.\\n     */\\n    function universeAssetWarpers(\\n        uint256 universeId,\\n        address asset,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory, Warpers.Warper[] memory);\\n\\n    /**\\n     * @dev Returns the number of warpers registered for certain asset in universe.\\n     * @param universeId Universe ID.\\n     * @param asset Original asset address.\\n     * @return Warper count.\\n     */\\n    function universeAssetWarperCount(uint256 universeId, address asset) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the Metahub address.\\n     */\\n    function metahub() external view returns (address);\\n\\n    /**\\n     * @dev Checks whether `account` is the `warper` admin.\\n     * @param warper Warper address.\\n     * @param account Account address.\\n     * @return True if the `account` is the admin of the `warper` and false otherwise.\\n     */\\n    function isWarperAdmin(address warper, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns registered warper details.\\n     * @param warper Warper address.\\n     * @return Warper details.\\n     */\\n    function warperInfo(address warper) external view returns (Warpers.Warper memory);\\n\\n    /**\\n     * @dev Returns warper controller address.\\n     * @param warper Warper address.\\n     * @return Current controller.\\n     */\\n    function warperController(address warper) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/listing/listing-strategy-registry/IListingStrategyRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\n\\ninterface IListingStrategyRegistry is IContractEntity {\\n    /**\\n     * @dev Thrown when the listing strategy is not registered or deprecated.\\n     * @param listingStrategyId Unsupported listing strategy ID.\\n     */\\n    error UnsupportedListingStrategy(bytes4 listingStrategyId);\\n\\n    /**\\n     * @dev Thrown when listing controller does not implement the required interface.\\n     */\\n    error InvalidListingControllerInterface();\\n\\n    /**\\n     * @dev Thrown when the listing cannot be processed by the specific controller due to the listing strategy ID\\n     * mismatch.\\n     * @param provided Provided listing strategy ID.\\n     * @param required Required listing strategy ID.\\n     */\\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Thrown upon attempting to register a listing strategy twice.\\n     * @param listingStrategyId Duplicate listing strategy ID.\\n     */\\n    error ListingStrategyIsAlreadyRegistered(bytes4 listingStrategyId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with unregistered listing strategy.\\n     * @param listingStrategyId Listing strategy ID.\\n     */\\n    error UnregisteredListingStrategy(bytes4 listingStrategyId);\\n\\n    /**\\n     * @dev Emitted when the new listing strategy is registered.\\n     * @param listingStrategyId Listing strategy ID.\\n     * @param listingTaxStrategyId Taxation strategy ID.\\n     * @param controller Controller address.\\n     */\\n    event ListingStrategyRegistered(\\n        bytes4 indexed listingStrategyId,\\n        bytes4 indexed listingTaxStrategyId,\\n        address indexed controller\\n    );\\n\\n    /**\\n     * @dev Emitted when the listing strategy controller is changed.\\n     * @param listingStrategyId Listing strategy ID.\\n     * @param newController Controller address.\\n     */\\n    event ListingStrategyControllerChanged(bytes4 indexed listingStrategyId, address indexed newController);\\n\\n    /**\\n     * @dev Listing strategy information.\\n     * @param controller Listing controller address.\\n     */\\n    struct ListingStrategyConfig {\\n        address controller;\\n        bytes4 taxStrategyId;\\n    }\\n\\n    /**\\n     * @dev Registers new listing strategy.\\n     * @param listingStrategyId Listing strategy ID.\\n     * @param config Listing strategy configuration.\\n     */\\n    function registerListingStrategy(bytes4 listingStrategyId, ListingStrategyConfig calldata config) external;\\n\\n    /**\\n     * @dev Sets listing strategy controller.\\n     * @param listingStrategyId Listing strategy ID.\\n     * @param controller Listing controller address.\\n     */\\n    function setListingController(bytes4 listingStrategyId, address controller) external;\\n\\n    /**\\n     * @dev Returns listing strategy controller.\\n     * @param listingStrategyId Listing strategy ID.\\n     * @return Listing controller address.\\n     */\\n    function listingController(bytes4 listingStrategyId) external view returns (address);\\n\\n    /**\\n     * @dev Returns tax strategy ID for listing strategy.\\n     * @param listingStrategyId Listing strategy ID.\\n     * @return Tax strategy ID.\\n     */\\n    function listingTaxId(bytes4 listingStrategyId) external view returns (bytes4);\\n\\n    /**\\n     * @dev Returns listing strategy configuration.\\n     * @param listingStrategyId Listing strategy ID.\\n     * @return Listing strategy information.\\n     */\\n    function listingStrategy(bytes4 listingStrategyId) external view returns (ListingStrategyConfig memory);\\n\\n    /**\\n     * @dev Returns tax strategy controller for listing strategy.\\n     * @param listingStrategyId Listing strategy ID.\\n     * @return Tax strategy controller address.\\n     */\\n    function listingTaxController(bytes4 listingStrategyId) external view returns (address);\\n\\n    /**\\n     * @dev Checks listing strategy registration.\\n     * @param listingStrategyId Listing strategy ID.\\n     */\\n    function isRegisteredListingStrategy(bytes4 listingStrategyId) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if listing strategy is not registered.\\n     * @param listingStrategyId Listing strategy ID.\\n     */\\n    function checkRegisteredListingStrategy(bytes4 listingStrategyId) external view;\\n}\\n\"\r\n    },\r\n    \"contracts/tax/tax-terms-registry/ITaxTermsRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\n\\ninterface ITaxTermsRegistry is IContractEntity {\\n    /**\\n     * @dev Thrown upon attempting to work with universe without tax terms.\\n     */\\n    error MissingUniverseTaxTerms(bytes4 taxStrategyId, uint256 universeId, address warperAddress);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with protocol without tax terms.\\n     */\\n    error MissingProtocolTaxTerms(bytes4 taxStrategyId, uint256 universeId, address warperAddress);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with universe without tax terms on local level.\\n     */\\n    error UniverseLocalTaxTermsMismatch(uint256 universeId, bytes4 taxStrategyId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with universe without tax terms on warper level.\\n     */\\n    error UniverseWarperTaxTermsMismatch(uint256 universeId, address warperAddress, bytes4 taxStrategyId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with protocol without tax terms on global level.\\n     */\\n    error ProtocolGlobalTaxTermsMismatch(bytes4 taxStrategyId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with protocol without tax terms on universe level.\\n     */\\n    error ProtocolUniverseTaxTermsMismatch(uint256 universeId, bytes4 taxStrategyId);\\n\\n    /**\\n     * @dev Thrown upon attempting to work with protocol without tax terms on warper level.\\n     */\\n    error ProtocolWarperTaxTermsMismatch(address warperAddress, bytes4 taxStrategyId);\\n\\n    /**\\n     * @dev Emitted when universe local tax terms are registered.\\n     * @param universeId Universe ID.\\n     * @param strategyId Tax strategy ID.\\n     * @param strategyData Tax strategy data.\\n     */\\n    event UniverseLocalTaxTermsRegistered(uint256 indexed universeId, bytes4 indexed strategyId, bytes strategyData);\\n\\n    /**\\n     * @dev Emitted when universe local tax terms are removed.\\n     * @param universeId Universe ID.\\n     * @param strategyId Tax strategy ID.\\n     */\\n    event UniverseLocalTaxTermsRemoved(uint256 indexed universeId, bytes4 indexed strategyId);\\n\\n    /**\\n     * @dev Emitted when universe warper tax terms are registered.\\n     * @param universeId Universe ID.\\n     * @param warperAddress Warper address.\\n     * @param strategyId Tax strategy ID.\\n     * @param strategyData Tax strategy data.\\n     */\\n    event UniverseWarperTaxTermsRegistered(\\n        uint256 indexed universeId,\\n        address indexed warperAddress,\\n        bytes4 indexed strategyId,\\n        bytes strategyData\\n    );\\n\\n    /**\\n     * @dev Emitted when universe warper tax terms are removed.\\n     * @param universeId Universe ID.\\n     * @param warperAddress Warper address.\\n     * @param strategyId Tax strategy ID.\\n     */\\n    event UniverseWarperTaxTermsRemoved(\\n        uint256 indexed universeId,\\n        address indexed warperAddress,\\n        bytes4 indexed strategyId\\n    );\\n\\n    /**\\n     * @dev Emitted when protocol global tax terms are registered.\\n     * @param strategyId Tax strategy ID.\\n     * @param strategyData Tax strategy data.\\n     */\\n    event ProtocolGlobalTaxTermsRegistered(bytes4 indexed strategyId, bytes strategyData);\\n\\n    /**\\n     * @dev Emitted when protocol global tax terms are removed.\\n     * @param strategyId Tax strategy ID.\\n     */\\n    event ProtocolGlobalTaxTermsRemoved(bytes4 indexed strategyId);\\n\\n    /**\\n     * @dev Emitted when protocol global tax terms are registered.\\n     * @param universeId Universe ID.\\n     * @param strategyId Tax strategy ID.\\n     * @param strategyData Tax strategy data.\\n     */\\n    event ProtocolUniverseTaxTermsRegistered(uint256 indexed universeId, bytes4 indexed strategyId, bytes strategyData);\\n\\n    /**\\n     * @dev Emitted when protocol global tax terms are removed.\\n     * @param universeId Universe ID.\\n     * @param strategyId Tax strategy ID.\\n     */\\n    event ProtocolUniverseTaxTermsRemoved(uint256 indexed universeId, bytes4 indexed strategyId);\\n\\n    /**\\n     * @dev Emitted when protocol warper tax terms are registered.\\n     * @param warperAddress Warper address.\\n     * @param strategyId Tax strategy ID.\\n     * @param strategyData Tax strategy data.\\n     */\\n    event ProtocolWarperTaxTermsRegistered(\\n        address indexed warperAddress,\\n        bytes4 indexed strategyId,\\n        bytes strategyData\\n    );\\n\\n    /**\\n     * @dev Emitted when protocol warper tax terms are removed.\\n     * @param warperAddress Warper address.\\n     * @param strategyId Tax strategy ID.\\n     */\\n    event ProtocolWarperTaxTermsRemoved(address indexed warperAddress, bytes4 indexed strategyId);\\n\\n    /**\\n     * @dev Tax terms information.\\n     * @param strategyId Tax strategy ID.\\n     * @param strategyData Tax strategy data.\\n     */\\n    struct TaxTerms {\\n        bytes4 strategyId;\\n        bytes strategyData;\\n    }\\n\\n    /**\\n     * @dev Tax Terms parameters.\\n     * @param taxStrategyId Tax strategy ID.\\n     * @param universeId Universe ID.\\n     * @param warperAddress Address of the warper.\\n     */\\n    struct Params {\\n        bytes4 taxStrategyId;\\n        uint256 universeId;\\n        address warperAddress;\\n    }\\n\\n    /**\\n     * @dev Registers universe local tax terms.\\n     * @param universeId Universe ID.\\n     * @param terms Tax terms data.\\n     */\\n    function registerUniverseLocalTaxTerms(uint256 universeId, TaxTerms calldata terms) external;\\n\\n    /**\\n     * @dev Removes universe local tax terms.\\n     * @param universeId Universe ID.\\n     * @param taxStrategyId Tax strategy ID.\\n     */\\n    function removeUniverseLocalTaxTerms(uint256 universeId, bytes4 taxStrategyId) external;\\n\\n    /**\\n     * @dev Registers universe warper tax terms.\\n     * @param universeId Universe ID.\\n     * @param warperAddress Warper address.\\n     * @param terms Tax terms data.\\n     */\\n    function registerUniverseWarperTaxTerms(\\n        uint256 universeId,\\n        address warperAddress,\\n        TaxTerms calldata terms\\n    ) external;\\n\\n    /**\\n     * @dev Removes universe warper tax terms.\\n     * @param universeId Universe ID.\\n     * @param warperAddress Warper address.\\n     * @param taxStrategyId Tax strategy ID.\\n     */\\n    function removeUniverseWarperTaxTerms(\\n        uint256 universeId,\\n        address warperAddress,\\n        bytes4 taxStrategyId\\n    ) external;\\n\\n    /**\\n     * @dev Registers protocol global tax terms.\\n     * @param terms Tax terms.\\n     */\\n    function registerProtocolGlobalTaxTerms(TaxTerms calldata terms) external;\\n\\n    /**\\n     * @dev Removes protocol global tax terms.\\n     * @param taxStrategyId Tax strategy ID.\\n     */\\n    function removeProtocolGlobalTaxTerms(bytes4 taxStrategyId) external;\\n\\n    /**\\n     * @dev Registers protocol universe tax terms.\\n     * @param universeId Universe ID.\\n     * @param terms Tax terms.\\n     */\\n    function registerProtocolUniverseTaxTerms(uint256 universeId, TaxTerms calldata terms) external;\\n\\n    /**\\n     * @dev Removes protocol universe tax terms.\\n     * @param universeId Universe ID\\n     * @param taxStrategyId Tax strategy ID.\\n     */\\n    function removeProtocolUniverseTaxTerms(uint256 universeId, bytes4 taxStrategyId) external;\\n\\n    /**\\n     * @dev Registers protocol warper tax terms.\\n     * @param warperAddress Warper address.\\n     * @param terms Tax terms.\\n     */\\n    function registerProtocolWarperTaxTerms(address warperAddress, TaxTerms calldata terms) external;\\n\\n    /**\\n     * @dev Removes protocol warper tax terms.\\n     * @param warperAddress Warper address.\\n     * @param taxStrategyId Tax strategy ID.\\n     */\\n    function removeProtocolWarperTaxTerms(address warperAddress, bytes4 taxStrategyId) external;\\n\\n    /**\\n     * @dev Returns universe's tax terms.\\n     * @param params The tax terms params.\\n     * @return Tax terms.\\n     */\\n    function universeTaxTerms(Params memory params) external view returns (TaxTerms memory);\\n\\n    /**\\n     * @dev Returns protocol's tax terms.\\n     * @param params The tax terms params.\\n     * @return Tax terms.\\n     */\\n    function protocolTaxTerms(Params memory params) external view returns (TaxTerms memory);\\n\\n    /**\\n     * @dev Checks registration of universe tax terms on either local or Warper levels.\\n     *      Reverts in case of absence of listing terms on all levels.\\n     * @param params ListingTermsParams specific params.\\n     */\\n    function checkRegisteredUniverseTaxTermsWithParams(Params memory params) external view;\\n\\n    /**\\n     * @dev Checks registration of universe tax terms on either global, universe or Warper levels.\\n     *      Reverts in case of absence of listing terms on all levels.\\n     * @param params ListingTermsParams specific params.\\n     */\\n    function checkRegisteredProtocolTaxTermsWithParams(Params memory params) external view;\\n\\n    /**\\n     * @dev Checks registration of universe local tax terms.\\n     * @param universeId Universe ID.\\n     * @param taxStrategyId Tax Strategy ID.\\n     * @return Boolean that is positive in case of existance\\n     */\\n    function areRegisteredUniverseLocalTaxTerms(uint256 universeId, bytes4 taxStrategyId) external view returns (bool);\\n\\n    /**\\n     * @dev Checks registration of universe warper tax terms.\\n     * @param universeId Universe ID.\\n     * @param warperAddress Warper address.\\n     * @param taxStrategyId Tax Strategy ID.\\n     * @return Boolean that is positive in case of existance\\n     */\\n    function areRegisteredUniverseWarperTaxTerms(\\n        uint256 universeId,\\n        address warperAddress,\\n        bytes4 taxStrategyId\\n    ) external view returns (bool);\\n\\n    /**\\n     * @dev Checks registration of protocol global tax terms.\\n     * @param taxStrategyId Tax Strategy ID.\\n     * @return Boolean that is positive in case of existance\\n     */\\n    function areRegisteredProtocolGlobalTaxTerms(bytes4 taxStrategyId) external view returns (bool);\\n\\n    /**\\n     * @dev Checks registration of protocol universe tax terms.\\n     * @param universeId Universe ID.\\n     * @param taxStrategyId Tax Strategy ID.\\n     * @return Boolean that is positive in case of existance\\n     */\\n    function areRegisteredProtocolUniverseTaxTerms(uint256 universeId, bytes4 taxStrategyId)\\n        external\\n        view\\n        returns (bool);\\n\\n    /**\\n     * @dev Checks registration of global protocol warper tax terms.\\n     * @param warperAddress Warper address.\\n     * @param taxStrategyId Tax Strategy ID.\\n     * @return Boolean that is positive in case of existance\\n     */\\n    function areRegisteredProtocolWarperTaxTerms(address warperAddress, bytes4 taxStrategyId)\\n        external\\n        view\\n        returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/metahub/IProtocolConfigManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IProtocolConfigManager {\\n    /**\\n     * @dev Emitted when address of collector for Protocol's external fees is changed.\\n     * @param oldCollector Address of old collector.\\n     * @param newCollector Address of new collector.\\n     */\\n    event ProtocolExternalFeesCollectorChanged(address oldCollector, address newCollector);\\n\\n    /**\\n     * @dev Changes the address of collector for Protocol's external fees.\\n     * Also emits `ProtocolExternalFeesCollectorChanged`.\\n     * @param newProtocolExternalFeesCollector The new collector's address.\\n     */\\n    function changeProtocolExternalFeesCollector(address newProtocolExternalFeesCollector) external;\\n\\n    /**\\n     * @dev Returns the base token that's used for stable price denomination.\\n     * @return The base token address.\\n     */\\n    function baseToken() external view returns (address);\\n\\n    /**\\n     * @dev Returns the base token decimals.\\n     * @return The base token decimals.\\n     */\\n    function baseTokenDecimals() external view returns (uint8);\\n\\n    /**\\n     * @dev Returns address of Protocol's external fees collector.\\n     * @return The address of Protocol's external fees collector.\\n     */\\n    function protocolExternalFeesCollector() external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/accounting/IPaymentManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Accounts.sol\\\";\\nimport \\\"./token-quote/ITokenQuote.sol\\\";\\nimport \\\"./distributors/ERC20RewardDistributionHelper.sol\\\";\\nimport \\\"../listing/Listings.sol\\\";\\n\\ninterface IPaymentManager {\\n    /**\\n     * @notice Describes the earning type.\\n     */\\n    enum EarningType {\\n        LISTER_FIXED_FEE,\\n        LISTER_EXTERNAL_ERC20_REWARD,\\n        RENTER_EXTERNAL_ERC20_REWARD,\\n        UNIVERSE_FIXED_FEE,\\n        UNIVERSE_EXTERNAL_ERC20_REWARD,\\n        PROTOCOL_FIXED_FEE,\\n        PROTOCOL_EXTERNAL_ERC20_REWARD\\n    }\\n\\n    /**\\n     * @dev Emitted when a user has earned some amount tokens.\\n     * @param user Address of the user that earned some amount.\\n     * @param earningType Describes the type of the user.\\n     * @param paymentToken The currency that the user has earned.\\n     * @param amount The amount of tokens that the user has earned.\\n     */\\n    event UserEarned(\\n        address indexed user,\\n        EarningType indexed earningType,\\n        address indexed paymentToken,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted when the universe has earned some amount of tokens.\\n     * @param universeId ID of the universe that earned the tokens.\\n     * @param earningType Describes the type of the user.\\n     * @param paymentToken The currency that the user has earned.\\n     * @param amount The amount of tokens that the user has earned.\\n     */\\n    event UniverseEarned(\\n        uint256 indexed universeId,\\n        EarningType indexed earningType,\\n        address indexed paymentToken,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @dev Emitted when the protocol has earned some amount of tokens.\\n     * @param earningType Describes the type of the user.\\n     * @param paymentToken The currency that the user has earned.\\n     * @param amount The amount of tokens that the user has earned.\\n     */\\n    event ProtocolEarned(EarningType indexed earningType, address indexed paymentToken, uint256 amount);\\n\\n    /**\\n     * @dev Redirects handle rental payment from RentingManager to Accounts.Registry\\n     * @param rentingParams Renting params.\\n     * @param fees Rental fees.\\n     * @param payer Address of the rent payer.\\n     * @param maxPaymentAmount Maximum payment amount.\\n     * @param tokenQuote Encoded token quote data.\\n     * @param tokenQuoteSignature Encoded ECDSA signature for checking token quote data for validity.\\n     * @return rentalEarnings Payment token earnings.\\n     * @return paymentTokenData Payment token data.\\n     */\\n    function handleRentalPayment(\\n        Rentings.Params calldata rentingParams,\\n        Rentings.RentalFees calldata fees,\\n        address payer,\\n        uint256 maxPaymentAmount,\\n        bytes calldata tokenQuote,\\n        bytes calldata tokenQuoteSignature\\n    )\\n        external\\n        returns (Accounts.RentalEarnings memory rentalEarnings, ITokenQuote.PaymentTokenData memory paymentTokenData);\\n\\n    /**\\n     * @dev Redirects handle external ERC20 reward payment from ERC20RewardDistributor to Accounts.Registry.\\n     * Metahub must have enough funds to cover the distribution.\\n     * ERC20RewardDistributor makes sure of that.\\n     * @param listing Represents, related to the distribution, listing.\\n     * @param agreement Represents, related to the distribution, agreement.\\n     * @param rentalExternalERC20RewardFees Represents calculated fees based on all terms applied to external reward.\\n     */\\n    function handleExternalERC20Reward(\\n        Listings.Listing memory listing,\\n        Rentings.Agreement memory agreement,\\n        ERC20RewardDistributionHelper.RentalExternalERC20RewardFees memory rentalExternalERC20RewardFees\\n    ) external returns (Accounts.RentalEarnings memory rentalExternalRewardEarnings);\\n\\n    /**\\n     * @dev Transfers the specific `amount` of `token` from a protocol balance to an arbitrary address.\\n     * @param token The token address.\\n     * @param amount The amount to be withdrawn.\\n     * @param to The payee address.\\n     */\\n    function withdrawProtocolFunds(\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @dev Transfers the specific `amount` of `token` from a universe balance to an arbitrary address.\\n     * @param universeId The universe ID.\\n     * @param token The token address.\\n     * @param amount The amount to be withdrawn.\\n     * @param to The payee address.\\n     */\\n    function withdrawUniverseFunds(\\n        uint256 universeId,\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @dev Transfers the specific `amount` of `token` from a user balance to an arbitrary address.\\n     * @param token The token address.\\n     * @param amount The amount to be withdrawn.\\n     * @param to The payee address.\\n     */\\n    function withdrawFunds(\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external;\\n\\n    /**\\n     * @dev Returns the amount of `token`, currently accumulated by the protocol.\\n     * @param token The token address.\\n     * @return Balance of `token`.\\n     */\\n    function protocolBalance(address token) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of protocol balances in various tokens.\\n     * @return List of balances.\\n     */\\n    function protocolBalances() external view returns (Accounts.Balance[] memory);\\n\\n    /**\\n     * @dev Returns the amount of `token`, currently accumulated by the universe.\\n     * @param universeId The universe ID.\\n     * @param token The token address.\\n     * @return Balance of `token`.\\n     */\\n    function universeBalance(uint256 universeId, address token) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of universe balances in various tokens.\\n     * @param universeId The universe ID.\\n     * @return List of balances.\\n     */\\n    function universeBalances(uint256 universeId) external view returns (Accounts.Balance[] memory);\\n\\n    /**\\n     * @dev Returns the amount of `token`, currently accumulated by the user.\\n     * @param account The account to query the balance for.\\n     * @param token The token address.\\n     * @return Balance of `token`.\\n     */\\n    function balance(address account, address token) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of user balances in various tokens.\\n     * @param account The account to query the balance for.\\n     * @return List of balances.\\n     */\\n    function balances(address account) external view returns (Accounts.Balance[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/asset/IAssetManager.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./Assets.sol\\\";\\n\\ninterface IAssetManager {\\n    /**\\n     * @dev Register a new asset.\\n     * @param assetClass Asset class identifier.\\n     * @param original The original assets address.\\n     */\\n    function registerAsset(bytes4 assetClass, address original) external;\\n\\n    /**\\n     * @dev Transfers an asset to the vault using associated controller.\\n     * @param asset Asset and its value.\\n     * @param from The owner of the asset.\\n     */\\n    function depositAsset(Assets.Asset memory asset, address from) external;\\n\\n    /**\\n     * @dev Withdraw asset from the vault using associated controller to owner.\\n     * @param asset Asset and its value.\\n     */\\n    function withdrawAsset(Assets.Asset calldata asset) external;\\n\\n    /**\\n     * @dev Retrieve the asset class controller for a given assetClass.\\n     * @param assetClass Asset class identifier.\\n     * @return The asset class controller.\\n     */\\n    function assetClassController(bytes4 assetClass) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of currently supported assets.\\n     * @return Asset count.\\n     */\\n    function supportedAssetCount() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the list of all supported asset addresses.\\n     * @param offset Starting index.\\n     * @param limit Max number of items.\\n     * @return List of original asset addresses.\\n     * @return List of asset config structures.\\n     */\\n    function supportedAssets(uint256 offset, uint256 limit)\\n        external\\n        view\\n        returns (address[] memory, Assets.AssetConfig[] memory);\\n}\\n\"\r\n    },\r\n    \"contracts/contract-registry/IContractRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IContractRegistry {\\n    /**\\n     * @dev Thrown when the contract with a provided key does not exist.\\n     */\\n    error InvalidContractEntityInterface();\\n\\n    /**\\n     * @dev Thrown when the contract with a provided key does not exist.\\n     */\\n    error ContractKeyMismatch(bytes4 keyProvided, bytes4 keyRequired);\\n\\n    /**\\n     * @dev Thrown when the contract with a provided key does not exist.\\n     */\\n    error ContractNotAuthorized(bytes4 keyProvided, address addressProvided);\\n\\n    /**\\n     * @dev Thrown when the contract with a provided key does not exist.\\n     */\\n    error ContractDoesNotExist(bytes4 keyProvided);\\n\\n    /**\\n     * @dev Emitted when the new contract is registered.\\n     * @param contractKey Key of the contract.\\n     * @param contractAddress Address of the contract.\\n     */\\n    event ContractRegistered(bytes4 contractKey, address contractAddress);\\n\\n    /**\\n     * @dev Register new contract with a key.\\n     * @param contractKey Key of the contract.\\n     * @param contractAddress Address of the contract.\\n     */\\n    function registerContract(bytes4 contractKey, address contractAddress) external;\\n\\n    /**\\n     * @dev Get contract address with a key.\\n     * @param contractKey Key of the contract.\\n     * @return Contract address.\\n     */\\n    function getContract(bytes4 contractKey) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/accounting/Accounts.sol\": {\r\n      \"content\": \"// solhint-disable private-vars-leading-underscore\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\\\";\\nimport \\\"../renting/Rentings.sol\\\";\\nimport \\\"../universe/universe-registry/IUniverseRegistry.sol\\\";\\nimport \\\"../listing/Listings.sol\\\";\\nimport \\\"../contract-registry/Contracts.sol\\\";\\nimport \\\"./IPaymentManager.sol\\\";\\nimport \\\"../listing/listing-strategies/ListingStrategies.sol\\\";\\nimport \\\"../listing/listing-strategies/fixed-rate-with-reward/IFixedRateWithRewardListingController.sol\\\";\\nimport \\\"../tax/tax-strategies/fixed-rate-with-reward/IFixedRateWithRewardTaxController.sol\\\";\\n\\nlibrary Accounts {\\n    using Accounts for Account;\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\n    using EnumerableMapUpgradeable for EnumerableMapUpgradeable.AddressToUintMap;\\n\\n    /**\\n     * @dev Thrown when the estimated rental fee calculated upon renting\\n     * is higher than maximal payment amount the renter is willing to pay.\\n     */\\n    error RentalFeeSlippage();\\n\\n    /**\\n     * @dev Thrown when the amount requested to be paid out is not valid.\\n     */\\n    error InvalidWithdrawalAmount(uint256 amount);\\n\\n    /**\\n     * @dev Thrown when the amount requested to be paid out is larger than available balance.\\n     */\\n    error InsufficientBalance(uint256 balance);\\n\\n    /**\\n     * @dev A structure that describes account balance in ERC20 tokens.\\n     */\\n    struct Balance {\\n        address token;\\n        uint256 amount;\\n    }\\n\\n    /**\\n     * @dev Describes an account state.\\n     * @param tokenBalances Mapping from an ERC20 token address to the amount.\\n     */\\n    struct Account {\\n        EnumerableMapUpgradeable.AddressToUintMap tokenBalances;\\n    }\\n\\n    /**\\n     * @dev Transfers funds from the account balance to the specific address after validating balance sufficiency.\\n     */\\n    function withdraw(\\n        Account storage self,\\n        address token,\\n        uint256 amount,\\n        address to\\n    ) external {\\n        if (amount == 0) revert InvalidWithdrawalAmount(amount);\\n        uint256 currentBalance = self.balance(token);\\n        if (amount > currentBalance) revert InsufficientBalance(currentBalance);\\n        unchecked {\\n            self.tokenBalances.set(token, currentBalance - amount);\\n        }\\n        IERC20Upgradeable(token).safeTransfer(to, amount);\\n    }\\n\\n    struct UserEarning {\\n        IPaymentManager.EarningType earningType;\\n        bool isLister;\\n        address account;\\n        uint256 value;\\n        address token;\\n    }\\n\\n    struct UniverseEarning {\\n        IPaymentManager.EarningType earningType;\\n        uint256 universeId;\\n        uint256 value;\\n        address token;\\n    }\\n\\n    struct ProtocolEarning {\\n        IPaymentManager.EarningType earningType;\\n        uint256 value;\\n        address token;\\n    }\\n\\n    struct RentalEarnings {\\n        UserEarning[] userEarnings;\\n        UniverseEarning universeEarning;\\n        ProtocolEarning protocolEarning;\\n    }\\n\\n    /**\\n     * @dev Redirects handle rental payment from RentingManager to Accounts.Registry\\n     * @param self Instance of Accounts.Registry.\\n     * @param rentingParams Renting params.\\n     * @param fees Rental fees.\\n     * @param payer Address of the rent payer.\\n     * @param maxPaymentAmount Maximum payment amount.\\n     * @return earnings Payment token earnings.\\n     */\\n    function handleRentalPayment(\\n        Accounts.Registry storage self,\\n        Rentings.Params calldata rentingParams,\\n        Rentings.RentalFees calldata fees,\\n        address payer,\\n        uint256 maxPaymentAmount\\n    ) external returns (RentalEarnings memory earnings) {\\n        IMetahub metahub = IMetahub(address(this));\\n        // Ensure no rental fee payment slippage.\\n        if (fees.total > maxPaymentAmount) revert RentalFeeSlippage();\\n\\n        // Handle lister fee component.\\n        Listings.Listing memory listing = IListingManager(metahub.getContract(Contracts.LISTING_MANAGER)).listingInfo(\\n            rentingParams.listingId\\n        );\\n\\n        // Initialize user earnings array. Here we have only one user, who is lister.\\n        earnings.userEarnings = new UserEarning[](1);\\n\\n        earnings.userEarnings[0] = _createListerEarning(\\n            listing,\\n            IPaymentManager.EarningType.LISTER_FIXED_FEE,\\n            fees.listerBaseFee + fees.listerPremium,\\n            rentingParams.paymentToken\\n        );\\n\\n        earnings.universeEarning = _createUniverseEarning(\\n            IPaymentManager.EarningType.UNIVERSE_FIXED_FEE,\\n            IWarperManager(metahub.getContract(Contracts.WARPER_MANAGER)).warperInfo(rentingParams.warper).universeId,\\n            fees.universeBaseFee + fees.universePremium,\\n            rentingParams.paymentToken\\n        );\\n\\n        earnings.protocolEarning = _createProtocolEarning(\\n            IPaymentManager.EarningType.PROTOCOL_FIXED_FEE,\\n            fees.protocolFee,\\n            rentingParams.paymentToken\\n        );\\n\\n        performPayouts(self, listing, earnings, payer, rentingParams.paymentToken);\\n    }\\n\\n    function handleExternalERC20Reward(\\n        Accounts.Registry storage self,\\n        Listings.Listing memory listing,\\n        Rentings.Agreement memory agreement,\\n        ERC20RewardDistributionHelper.RentalExternalERC20RewardFees memory rentalExternalERC20RewardFees,\\n        address rewardSource\\n    ) external returns (RentalEarnings memory earnings) {\\n        // Initialize user earnings array. Here we have 2 users: lister and renter.\\n        earnings.userEarnings = new UserEarning[](2);\\n\\n        earnings.userEarnings[0] = _createListerEarning(\\n            listing,\\n            IPaymentManager.EarningType.LISTER_EXTERNAL_ERC20_REWARD,\\n            rentalExternalERC20RewardFees.listerRewardFee,\\n            rentalExternalERC20RewardFees.token\\n        );\\n\\n        earnings.userEarnings[1] = _createNonListerEarning(\\n            agreement.renter,\\n            IPaymentManager.EarningType.RENTER_EXTERNAL_ERC20_REWARD,\\n            rentalExternalERC20RewardFees.renterRewardFee,\\n            rentalExternalERC20RewardFees.token\\n        );\\n\\n        earnings.universeEarning = _createUniverseEarning(\\n            IPaymentManager.EarningType.UNIVERSE_EXTERNAL_ERC20_REWARD,\\n            agreement.universeId,\\n            rentalExternalERC20RewardFees.universeRewardFee,\\n            rentalExternalERC20RewardFees.token\\n        );\\n\\n        earnings.protocolEarning = _createProtocolEarning(\\n            IPaymentManager.EarningType.PROTOCOL_EXTERNAL_ERC20_REWARD,\\n            rentalExternalERC20RewardFees.protocolRewardFee,\\n            rentalExternalERC20RewardFees.token\\n        );\\n\\n        performPayouts(self, listing, earnings, rewardSource, rentalExternalERC20RewardFees.token);\\n    }\\n\\n    function performPayouts(\\n        Accounts.Registry storage self,\\n        Listings.Listing memory listing,\\n        RentalEarnings memory rentalEarnings,\\n        address payer,\\n        address payoutToken\\n    ) internal {\\n        // The amount of payment tokens to be accumulated on the Metahub for future payouts.\\n        // This will include all fees which are not being paid out immediately.\\n        uint256 accumulatedTokens = 0;\\n\\n        // Increase universe balance.\\n        self.universes[rentalEarnings.universeEarning.universeId].increaseBalance(\\n            rentalEarnings.universeEarning.token,\\n            rentalEarnings.universeEarning.value\\n        );\\n        accumulatedTokens += rentalEarnings.universeEarning.value;\\n\\n        // Increase protocol balance.\\n        self.protocol.increaseBalance(rentalEarnings.protocolEarning.token, rentalEarnings.protocolEarning.value);\\n        accumulatedTokens += rentalEarnings.protocolEarning.value;\\n\\n        UserEarning[] memory userEarnings = rentalEarnings.userEarnings;\\n\\n        for (uint256 i = 0; i < userEarnings.length; i++) {\\n            UserEarning memory userEarning = userEarnings[i];\\n\\n            if (userEarning.value == 0) continue;\\n\\n            if (userEarning.isLister && !listing.immediatePayout) {\\n                // If the lister has not requested immediate payout, the earned amount is added to the lister balance.\\n                // The direct payout case is handled along with other transfers later.\\n                self.users[userEarning.account].increaseBalance(userEarning.token, userEarning.value);\\n                accumulatedTokens += userEarning.value;\\n            } else {\\n                // Proceed with transfers.\\n                // If immediate payout requested, transfer the lister earnings directly to the user account.\\n                IERC20Upgradeable(userEarning.token).safeTransferFrom(payer, userEarning.account, userEarning.value);\\n            }\\n        }\\n\\n        // Transfer the accumulated token amount from payer to the metahub.\\n        if (accumulatedTokens > 0) {\\n            IERC20Upgradeable(payoutToken).safeTransferFrom(payer, address(this), accumulatedTokens);\\n        }\\n    }\\n\\n    function _createListerEarning(\\n        Listings.Listing memory listing,\\n        IPaymentManager.EarningType earningType,\\n        uint256 value,\\n        address token\\n    ) internal pure returns (UserEarning memory listerEarning) {\\n        listerEarning = UserEarning({\\n            earningType: earningType,\\n            isLister: true,\\n            account: listing.beneficiary,\\n            value: value,\\n            token: token\\n        });\\n    }\\n\\n    function _createNonListerEarning(\\n        address user,\\n        IPaymentManager.EarningType earningType,\\n        uint256 value,\\n        address token\\n    ) internal pure returns (UserEarning memory nonListerEarning) {\\n        nonListerEarning = UserEarning({\\n            earningType: earningType,\\n            isLister: false,\\n            account: user,\\n            value: value,\\n            token: token\\n        });\\n    }\\n\\n    function _createUniverseEarning(\\n        IPaymentManager.EarningType earningType,\\n        uint256 universeId,\\n        uint256 value,\\n        address token\\n    ) internal pure returns (UniverseEarning memory universeEarning) {\\n        universeEarning = UniverseEarning({\\n            earningType: earningType,\\n            universeId: universeId,\\n            value: value,\\n            token: token\\n        });\\n    }\\n\\n    function _createProtocolEarning(\\n        IPaymentManager.EarningType earningType,\\n        uint256 value,\\n        address token\\n    ) internal pure returns (ProtocolEarning memory protocolEarning) {\\n        protocolEarning = ProtocolEarning({earningType: earningType, value: value, token: token});\\n    }\\n\\n    /**\\n     * @dev Increments value of the particular account balance.\\n     */\\n    function increaseBalance(\\n        Account storage self,\\n        address token,\\n        uint256 amount\\n    ) internal {\\n        uint256 currentBalance = self.balance(token);\\n        self.tokenBalances.set(token, currentBalance + amount);\\n    }\\n\\n    /**\\n     * @dev Returns account current balance.\\n     * Does not revert if `token` is not in the map.\\n     */\\n    function balance(Account storage self, address token) internal view returns (uint256) {\\n        (, uint256 value) = self.tokenBalances.tryGet(token);\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Returns the list of account balances in various tokens.\\n     */\\n    function balances(Account storage self) internal view returns (Balance[] memory) {\\n        uint256 length = self.tokenBalances.length();\\n        Balance[] memory allBalances = new Balance[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            (address token, uint256 amount) = self.tokenBalances.at(i);\\n            allBalances[i] = Balance({token: token, amount: amount});\\n        }\\n        return allBalances;\\n    }\\n\\n    /**\\n     * @dev Account registry.\\n     * @param protocol The protocol account state.\\n     * @param universes Mapping from a universe ID to the universe account state.\\n     * @param users Mapping from a user address to the account state.\\n     */\\n    struct Registry {\\n        Account protocol;\\n        mapping(uint256 => Account) universes;\\n        mapping(address => Account) users;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/accounting/token-quote/ITokenQuote.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\nimport \\\"../../renting/Rentings.sol\\\";\\n\\ninterface ITokenQuote is IContractEntity {\\n    /**\\n     * @dev Thrown when the message sender is not Metahub.\\n     */\\n    error CallerIsNotMetahub();\\n\\n    /**\\n     * @dev Thrown when trying to work with expired token quote.\\n     */\\n    error TokenQuoteExpired();\\n\\n    /**\\n     * @dev Thrown when trying to work with token quote signed by entity missing quote signing role.\\n     */\\n    error InvalidTokenQuoteSigner();\\n\\n    /**\\n     * @dev Thrown when token quote listing id does not equal one provided from renting params.\\n     */\\n    error TokenQuoteListingIdMismatch();\\n\\n    /**\\n     * @dev Thrown when token quote renter address does not equal one provided from renting params.\\n     */\\n    error TokenQuoteRenterMismatch();\\n\\n    /**\\n     * @dev Thrown when token quote warper address does not equal one provided from renting params.\\n     */\\n    error TokenQuoteWarperMismatch();\\n\\n    /**\\n     * @dev Describes the universe-specific token quote data.\\n     * @param paymentToken Address of payment token.\\n     * @param paymentTokenQuote Quote of payment token in accordance to base token\\n     */\\n    struct PaymentTokenData {\\n        address paymentToken;\\n        uint256 paymentTokenQuote;\\n    }\\n\\n    /**\\n     * @dev Describes the universe-specific-to-base token quote.\\n     * @param listingId Listing ID.\\n     * @param renter Address of renter.\\n     * @param warperAddress Address of warper.\\n     * @param paymentToken Address of payment token.\\n     * @param paymentTokenQuote Quote of payment token in accordance to base token\\n     * @param nonce Anti-replication mechanism value.\\n     * @param deadline The maximum possible time when token quote can be used.\\n     */\\n    struct TokenQuote {\\n        uint256 listingId;\\n        address renter;\\n        address warperAddress;\\n        address paymentToken;\\n        uint256 paymentTokenQuote;\\n        uint256 nonce;\\n        uint32 deadline;\\n    }\\n\\n    /**\\n     * @dev Using and verification of the price quote for universe-specific token in relation to base token.\\n     * @param rentingParams Renting params.\\n     * @param baseTokenFees Base fees in equivalent of base token.\\n     * @param tokenQuote Encoded token quote.\\n     * @param tokenQuoteSignature Token Quote ECDSA signature ABI encoded (v,r,s)(uint8, bytes32, bytes32).\\n     * @return paymentTokenFees Payment token fees calculated in accordance with payment token quote.\\n     * @return paymentTokenData Payment token data.\\n     */\\n    function useTokenQuote(\\n        Rentings.Params calldata rentingParams,\\n        Rentings.RentalFees memory baseTokenFees,\\n        bytes calldata tokenQuote,\\n        bytes calldata tokenQuoteSignature\\n    ) external returns (Rentings.RentalFees memory paymentTokenFees, PaymentTokenData memory paymentTokenData);\\n\\n    /**\\n     * @dev Getting the nonce for token quote.\\n     *      This 'nonce' should be included in the signature of TokenQuote\\n     * @param renter Address of the renter.\\n     */\\n    function getTokenQuoteNonces(address renter) external view returns (uint256);\\n\\n    /**\\n     * @dev Getting the Chain ID\\n     */\\n    function getChainId() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/accounting/distributors/ERC20RewardDistributionHelper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../listing/listing-strategies/ListingStrategies.sol\\\";\\nimport \\\"../../tax/tax-strategies/TaxStrategies.sol\\\";\\nimport \\\"../../renting/Rentings.sol\\\";\\n\\nlibrary ERC20RewardDistributionHelper {\\n    struct RentalExternalERC20RewardFees {\\n        address token;\\n        uint256 totalReward;\\n        uint256 listerRewardFee;\\n        uint256 renterRewardFee;\\n        uint256 universeRewardFee;\\n        uint256 protocolRewardFee;\\n    }\\n\\n    /**\\n     * A constant that represents one hundred percent for calculation.\\n     * This defines a calculation precision for percentage values as two decimals.\\n     * For example: 1 is 0.01%, 100 is 1%, 10_000 is 100%.\\n     */\\n    uint16 private constant _HUNDRED_PERCENT = 10_000;\\n\\n    function getRentalExternalERC20RewardFees(\\n        Rentings.Agreement memory agreement,\\n        address token,\\n        uint256 rewardAmount\\n    ) internal view returns (RentalExternalERC20RewardFees memory rentalExternalERC20RewardFees) {\\n        // Listing Terms will have equivalent (in terms of strategy type) Tax Terms.\\n        IListingTermsRegistry.ListingTerms memory listingTerms = agreement.agreementTerms.listingTerms;\\n\\n        if (listingTerms.strategyId == ListingStrategies.FIXED_RATE_WITH_REWARD) {\\n            (\\n                uint16 listerRewardPercentage,\\n                uint16 universeRewardTaxPercentage,\\n                uint16 protocolRewardTaxPercentage\\n            ) = retrieveRewardPercentages(agreement);\\n\\n            rentalExternalERC20RewardFees = calculateExternalRewardBasedFees(\\n                token,\\n                rewardAmount,\\n                listerRewardPercentage,\\n                universeRewardTaxPercentage,\\n                protocolRewardTaxPercentage\\n            );\\n        } else if (listingTerms.strategyId == ListingStrategies.FIXED_RATE) {\\n            rentalExternalERC20RewardFees = calculateExternalRewardForFixedRate(token, rewardAmount);\\n        }\\n    }\\n\\n    function retrieveRewardPercentages(Rentings.Agreement memory agreement)\\n        internal\\n        view\\n        returns (\\n            uint16 listerRewardPercentage,\\n            uint16 universeRewardTaxPercentage,\\n            uint16 protocolRewardTaxPercentage\\n        )\\n    {\\n        IListingTermsRegistry.ListingTerms memory listingTerms = agreement.agreementTerms.listingTerms;\\n        ITaxTermsRegistry.TaxTerms memory universeTaxTerms = agreement.agreementTerms.universeTaxTerms;\\n        ITaxTermsRegistry.TaxTerms memory protocolTaxTerms = agreement.agreementTerms.protocolTaxTerms;\\n\\n        (, listerRewardPercentage) = ListingStrategies.decodeFixedRateWithRewardListingStrategyParams(listingTerms);\\n        (, universeRewardTaxPercentage) = TaxStrategies.decodeFixedRateWithRewardTaxStrategyParams(universeTaxTerms);\\n        (, protocolRewardTaxPercentage) = TaxStrategies.decodeFixedRateWithRewardTaxStrategyParams(protocolTaxTerms);\\n    }\\n\\n    function calculateExternalRewardBasedFees(\\n        address token,\\n        uint256 rewardAmount,\\n        uint16 listerRewardPercentage,\\n        uint16 universeRewardTaxPercentage,\\n        uint16 protocolRewardTaxPercentage\\n    ) internal pure returns (RentalExternalERC20RewardFees memory externalRewardFees) {\\n        externalRewardFees.token = token;\\n        externalRewardFees.totalReward = rewardAmount;\\n        uint256 leftoverRewardAmount = rewardAmount;\\n\\n        externalRewardFees.universeRewardFee = (leftoverRewardAmount * universeRewardTaxPercentage) / _HUNDRED_PERCENT;\\n        if (leftoverRewardAmount <= externalRewardFees.universeRewardFee) {\\n            externalRewardFees.universeRewardFee = leftoverRewardAmount;\\n            return externalRewardFees;\\n        }\\n        leftoverRewardAmount -= externalRewardFees.universeRewardFee;\\n\\n        externalRewardFees.protocolRewardFee = (leftoverRewardAmount * protocolRewardTaxPercentage) / _HUNDRED_PERCENT;\\n        if (leftoverRewardAmount <= externalRewardFees.protocolRewardFee) {\\n            externalRewardFees.protocolRewardFee = leftoverRewardAmount;\\n            return externalRewardFees;\\n        }\\n        leftoverRewardAmount -= externalRewardFees.protocolRewardFee;\\n\\n        externalRewardFees.listerRewardFee = (leftoverRewardAmount * listerRewardPercentage) / _HUNDRED_PERCENT;\\n        if (leftoverRewardAmount <= externalRewardFees.listerRewardFee) {\\n            externalRewardFees.listerRewardFee = leftoverRewardAmount;\\n            return externalRewardFees;\\n        }\\n        externalRewardFees.renterRewardFee = leftoverRewardAmount - externalRewardFees.listerRewardFee;\\n    }\\n\\n    function calculateExternalRewardForFixedRate(address token, uint256 rewardAmount)\\n        internal\\n        pure\\n        returns (RentalExternalERC20RewardFees memory externalRewardFees)\\n    {\\n        externalRewardFees.token = token;\\n        externalRewardFees.totalReward = rewardAmount;\\n\\n        externalRewardFees.renterRewardFee = rewardAmount;\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/draft-IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    function safeTransfer(\\n        IERC20Upgradeable token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20Upgradeable token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20Upgradeable token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableMapUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/structs/EnumerableMap.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./EnumerableSetUpgradeable.sol\\\";\\n\\n/**\\n * @dev Library for managing an enumerable variant of Solidity's\\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\\n * type.\\n *\\n * Maps have the following properties:\\n *\\n * - Entries are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\\n *\\n *     // Declare a set state variable\\n *     EnumerableMap.UintToAddressMap private myMap;\\n * }\\n * ```\\n *\\n * The following map types are supported:\\n *\\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32`) since v4.6.0\\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\\n *\\n * [WARNING]\\n * ====\\n *  Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable.\\n *  See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n *  In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an array of EnumerableMap.\\n * ====\\n */\\nlibrary EnumerableMapUpgradeable {\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\\n\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Map type with\\n    // bytes32 keys and values.\\n    // The Map implementation uses private functions, and user-facing\\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\\n    // the underlying Map.\\n    // This means that we can only create new EnumerableMaps for types that fit\\n    // in bytes32.\\n\\n    struct Bytes32ToBytes32Map {\\n        // Storage of keys\\n        EnumerableSetUpgradeable.Bytes32Set _keys;\\n        mapping(bytes32 => bytes32) _values;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        bytes32 value\\n    ) internal returns (bool) {\\n        map._values[key] = value;\\n        return map._keys.add(key);\\n    }\\n\\n    /**\\n     * @dev Removes a key-value pair from a map. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\\n        delete map._values[key];\\n        return map._keys.remove(key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\\n        return map._keys.contains(key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of key-value pairs in the map. O(1).\\n     */\\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\\n        return map._keys.length();\\n    }\\n\\n    /**\\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of entries inside the\\n     * array, and it may change when more entries are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\\n        bytes32 key = map._keys.at(index);\\n        return (key, map._values[key]);\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\\n        bytes32 value = map._values[key];\\n        if (value == bytes32(0)) {\\n            return (contains(map, key), bytes32(0));\\n        } else {\\n            return (true, value);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), \\\"EnumerableMap: nonexistent key\\\");\\n        return value;\\n    }\\n\\n    /**\\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\\n     */\\n    function get(\\n        Bytes32ToBytes32Map storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (bytes32) {\\n        bytes32 value = map._values[key];\\n        require(value != 0 || contains(map, key), errorMessage);\\n        return value;\\n    }\\n\\n    // UintToUintMap\\n\\n    struct UintToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key)));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToUintMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(key), errorMessage));\\n    }\\n\\n    // UintToAddressMap\\n\\n    struct UintToAddressMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        address value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\\n        return remove(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(key));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (uint256(key), address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\\n        return (success, address(uint160(uint256(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        UintToAddressMap storage map,\\n        uint256 key,\\n        string memory errorMessage\\n    ) internal view returns (address) {\\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\\n    }\\n\\n    // AddressToUintMap\\n\\n    struct AddressToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        AddressToUintMap storage map,\\n        address key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\\n        return remove(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\\n        return contains(map._inner, bytes32(uint256(uint160(key))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (address(uint160(uint256(key))), uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        AddressToUintMap storage map,\\n        address key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\\n    }\\n\\n    // Bytes32ToUintMap\\n\\n    struct Bytes32ToUintMap {\\n        Bytes32ToBytes32Map _inner;\\n    }\\n\\n    /**\\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\\n     * key. O(1).\\n     *\\n     * Returns true if the key was added to the map, that is if it was not\\n     * already present.\\n     */\\n    function set(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        uint256 value\\n    ) internal returns (bool) {\\n        return set(map._inner, key, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the key was removed from the map, that is if it was present.\\n     */\\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\\n        return remove(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns true if the key is in the map. O(1).\\n     */\\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\\n        return contains(map._inner, key);\\n    }\\n\\n    /**\\n     * @dev Returns the number of elements in the map. O(1).\\n     */\\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\\n        return length(map._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the element stored at position `index` in the set. O(1).\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\\n        (bytes32 key, bytes32 value) = at(map._inner, index);\\n        return (key, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Tries to returns the value associated with `key`.  O(1).\\n     * Does not revert if `key` is not in the map.\\n     */\\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\\n        (bool success, bytes32 value) = tryGet(map._inner, key);\\n        return (success, uint256(value));\\n    }\\n\\n    /**\\n     * @dev Returns the value associated with `key`.  O(1).\\n     *\\n     * Requirements:\\n     *\\n     * - `key` must be in the map.\\n     */\\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\\n        return uint256(get(map._inner, key));\\n    }\\n\\n    /**\\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryGet}.\\n     */\\n    function get(\\n        Bytes32ToUintMap storage map,\\n        bytes32 key,\\n        string memory errorMessage\\n    ) internal view returns (uint256) {\\n        return uint256(get(map._inner, key, errorMessage));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/renting/Rentings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"../asset/Assets.sol\\\";\\nimport \\\"../metahub/Protocol.sol\\\";\\nimport \\\"../listing/Listings.sol\\\";\\nimport \\\"../warper/warper-manager/Warpers.sol\\\";\\nimport \\\"../tax/tax-terms-registry/ITaxTermsRegistry.sol\\\";\\nimport \\\"../accounting/token-quote/ITokenQuote.sol\\\";\\nimport \\\"../listing/listing-manager/IListingManager.sol\\\";\\nimport \\\"../metahub/core/IMetahub.sol\\\";\\nimport \\\"../universe/universe-registry/IUniverseRegistry.sol\\\";\\nimport \\\"../listing/listing-configurator/registry/IListingConfiguratorRegistry.sol\\\";\\nimport \\\"../listing/listing-strategy-registry/IListingStrategyRegistry.sol\\\";\\nimport \\\"../listing/listing-strategies/IListingController.sol\\\";\\n\\nlibrary Rentings {\\n    using CountersUpgradeable for CountersUpgradeable.Counter;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.UintSet;\\n    using Rentings for RenterInfo;\\n    using Rentings for Agreement;\\n    using Rentings for Registry;\\n    using Assets for Assets.AssetId;\\n    using Protocol for Protocol.Config;\\n    using Listings for Listings.Registry;\\n    using Listings for Listings.Listing;\\n    using Warpers for Warpers.Registry;\\n    using Warpers for Warpers.Warper;\\n\\n    /**\\n     * @dev Thrown when a rental agreement is being registered for a specific warper ID,\\n     * while the previous rental agreement for this warper is still effective.\\n     */\\n    error RentalAgreementConflict(uint256 conflictingRentalId);\\n\\n    /**\\n     * @dev Thrown when attempting to delete effective rental agreement data (before expiration).\\n     */\\n    error CannotDeleteEffectiveRentalAgreement(uint256 rentalId);\\n\\n    /**\\n     * @dev Thrown when attempting to rent for Zero address.\\n     */\\n    error RenterCannotBeZeroAddress();\\n\\n    /**\\n     * @dev Warper rental status.\\n     * NONE - means the warper had never been minted.\\n     * AVAILABLE - can be rented.\\n     * RENTED - currently rented.\\n     */\\n    enum RentalStatus {\\n        NONE,\\n        AVAILABLE,\\n        RENTED\\n    }\\n\\n    /**\\n     * @dev Defines the maximal allowed number of cycles when looking for expired rental agreements.\\n     */\\n    uint256 private constant _GC_CYCLES = 20;\\n\\n    /**\\n     * @dev Rental fee breakdown.\\n     */\\n    struct RentalFees {\\n        uint256 total;\\n        uint256 protocolFee;\\n        uint256 listerBaseFee;\\n        uint256 listerPremium;\\n        uint256 universeBaseFee;\\n        uint256 universePremium;\\n        IListingTermsRegistry.ListingTerms listingTerms;\\n        ITaxTermsRegistry.TaxTerms universeTaxTerms;\\n        ITaxTermsRegistry.TaxTerms protocolTaxTerms;\\n    }\\n\\n    /**\\n     * @dev Renting parameters structure.\\n     * It is used to encode all the necessary information to estimate and/or fulfill a particular renting request.\\n     * @param listingId Listing ID. Also allows to identify the asset(s) being rented.\\n     * @param warper Warper address.\\n     * @param renter Renter address.\\n     * @param rentalPeriod Desired period of asset(s) renting.\\n     * @param paymentToken The token address which renter offers as a mean of payment.\\n     * @param listingTermsId Listing terms ID.\\n     * @param selectedConfiguratorListingTerms\\n     */\\n    struct Params {\\n        uint256 listingId;\\n        address warper;\\n        address renter;\\n        uint32 rentalPeriod;\\n        address paymentToken;\\n        uint256 listingTermsId;\\n        IListingTermsRegistry.ListingTerms selectedConfiguratorListingTerms;\\n    }\\n\\n    /**\\n     * @dev Rental agreement information.\\n     * @param warpedAssets Rented asset(s).\\n     * @param universeId The Universe ID.\\n     * @param collectionId Warped collection ID.\\n     * @param listingId The corresponding ID of the original asset(s) listing.\\n     * @param renter The renter account address.\\n     * @param startTime The rental agreement staring time. This is the timestamp after which the `renter`\\n     * considered to be an warped asset(s) owner.\\n     * @param endTime The rental agreement ending time. After this timestamp, the rental agreement is terminated\\n     * and the `renter` is no longer the owner of the warped asset(s).\\n     * @param listingTerms Listing terms\\n     */\\n    struct Agreement {\\n        Assets.Asset[] warpedAssets;\\n        uint256 universeId;\\n        bytes32 collectionId;\\n        uint256 listingId;\\n        address renter;\\n        uint32 startTime;\\n        uint32 endTime;\\n        AgreementTerms agreementTerms;\\n    }\\n\\n    struct AgreementTerms {\\n        IListingTermsRegistry.ListingTerms listingTerms;\\n        ITaxTermsRegistry.TaxTerms universeTaxTerms;\\n        ITaxTermsRegistry.TaxTerms protocolTaxTerms;\\n        ITokenQuote.PaymentTokenData paymentTokenData;\\n    }\\n\\n    function isEffective(Agreement storage self) internal view returns (bool) {\\n        return self.endTime > uint32(block.timestamp);\\n    }\\n\\n    function isRegistered(Agreement memory self) internal pure returns (bool) {\\n        return self.renter != address(0);\\n    }\\n\\n    /**\\n     * @dev Describes user specific renting information.\\n     * @param rentalIndex Renter's set of rental agreement IDs.\\n     * @param collectionRentalIndex Mapping from collection ID to the set of rental IDs.\\n     */\\n    struct RenterInfo {\\n        EnumerableSetUpgradeable.UintSet rentalIndex;\\n        mapping(bytes32 => EnumerableSetUpgradeable.UintSet) collectionRentalIndex;\\n    }\\n\\n    /**\\n     * @dev Describes asset(s) specific renting information.\\n     * @param latestRentalId Holds the most recent rental agreement ID.\\n     */\\n    struct AssetInfo {\\n        uint256 latestRentalId; // NOTE: This must never be deleted during cleanup.\\n    }\\n\\n    /**\\n     * @dev Renting registry.\\n     * @param idTracker Rental agreement ID tracker (incremental counter).\\n     * @param agreements Mapping from rental ID to the rental agreement details.\\n     * @param renters Mapping from renter address to the user specific renting info.\\n     * @param assets Mapping from asset ID (byte32) to the asset specific renting info.\\n     */\\n    struct Registry {\\n        CountersUpgradeable.Counter idTracker;\\n        mapping(uint256 => Agreement) agreements;\\n        mapping(uint256 => Agreement) agreementsHistory;\\n        mapping(address => RenterInfo) renters;\\n        mapping(bytes32 => AssetInfo) assets;\\n    }\\n\\n    /**\\n     * @dev Returns the number of currently registered rental agreements for particular renter account.\\n     */\\n    function userRentalCount(Registry storage self, address renter) internal view returns (uint256) {\\n        return self.renters[renter].rentalIndex.length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of currently registered rental agreements for particular renter account.\\n     */\\n    function userRentalAgreements(\\n        Registry storage self,\\n        address renter,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (uint256[] memory, Rentings.Agreement[] memory) {\\n        EnumerableSetUpgradeable.UintSet storage userRentalIndex = self.renters[renter].rentalIndex;\\n        uint256 indexSize = userRentalIndex.length();\\n        if (offset >= indexSize) return (new uint256[](0), new Rentings.Agreement[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Rentings.Agreement[] memory agreements = new Rentings.Agreement[](limit);\\n        uint256[] memory rentalIds = new uint256[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            rentalIds[i] = userRentalIndex.at(offset + i);\\n            agreements[i] = self.agreements[rentalIds[i]];\\n        }\\n\\n        return (rentalIds, agreements);\\n    }\\n\\n    /**\\n     * @dev Finds expired user rental agreements associated with `collectionId` and deletes them.\\n     * Deletes only first N entries defined by `toBeRemoved` param.\\n     * The total number of cycles is capped by GC_CYCLES constant.\\n     */\\n    function deleteExpiredUserRentalAgreements(\\n        Registry storage self,\\n        address renter,\\n        bytes32 collectionId,\\n        uint256 toBeRemoved\\n    ) external {\\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\\n\\n        uint256 rentalCount = rentalIndex.length();\\n        if (rentalCount == 0 || toBeRemoved == 0) return;\\n\\n        uint256 maxCycles = rentalCount < _GC_CYCLES ? rentalCount : _GC_CYCLES;\\n        uint256 removed = 0;\\n\\n        for (uint256 i = 0; i < maxCycles; i++) {\\n            uint256 rentalId = rentalIndex.at(i);\\n\\n            if (!self.agreements[rentalId].isEffective()) {\\n                // Warning: we are iterating an array that we are also modifying!\\n                _removeRentalAgreement(self, rentalId);\\n                removed += 1;\\n                maxCycles -= 1; // This is so we account for reduced `rentalCount`.\\n\\n                // Stop iterating if we have cleaned up enough desired items.\\n                if (removed == toBeRemoved) break;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Performs new rental agreement registration.\\n     */\\n    function register(Registry storage self, Agreement memory agreement) external returns (uint256 rentalId) {\\n        // Generate new rental ID.\\n        self.idTracker.increment();\\n        rentalId = self.idTracker.current();\\n\\n        // Save new rental agreement.\\n        Agreement storage agreementRecord = self.agreements[rentalId];\\n        agreementRecord.listingId = agreement.listingId;\\n        agreementRecord.renter = agreement.renter;\\n        agreementRecord.startTime = agreement.startTime;\\n        agreementRecord.endTime = agreement.endTime;\\n        agreementRecord.collectionId = agreement.collectionId;\\n        agreementRecord.agreementTerms.listingTerms = agreement.agreementTerms.listingTerms;\\n        agreementRecord.agreementTerms.universeTaxTerms = agreement.agreementTerms.universeTaxTerms;\\n        agreementRecord.agreementTerms.protocolTaxTerms = agreement.agreementTerms.protocolTaxTerms;\\n\\n        for (uint256 i = 0; i < agreement.warpedAssets.length; i++) {\\n            bytes32 assetId = agreement.warpedAssets[i].id.hash();\\n            uint256 latestRentalId = self.assets[assetId].latestRentalId;\\n\\n            if (latestRentalId != 0 && self.agreements[latestRentalId].isEffective()) {\\n                revert RentalAgreementConflict(latestRentalId);\\n            } else {\\n                // Add warped assets and their collection ids to rental agreement.\\n                agreementRecord.warpedAssets.push(agreement.warpedAssets[i]);\\n\\n                // Update warper latest rental ID.\\n                self.assets[assetId].latestRentalId = rentalId;\\n            }\\n        }\\n\\n        RenterInfo storage renterInfo = self.renters[agreement.renter];\\n        // Update user rental index.\\n        renterInfo.rentalIndex.add(rentalId);\\n        // Update user collection rental index.\\n        renterInfo.collectionRentalIndex[agreement.collectionId].add(rentalId);\\n    }\\n\\n    /**\\n     * @dev Updates Agreement Record structure in storage and in memory.\\n     */\\n    function updateAgreementConfig(\\n        Registry storage self,\\n        Rentings.Agreement memory inMemoryRentalAgreement,\\n        uint256 rentalId,\\n        Rentings.RentalFees memory rentalFees,\\n        Warpers.Warper memory warper,\\n        ITokenQuote.PaymentTokenData memory paymentTokenData\\n    ) external returns (Rentings.Agreement memory) {\\n        inMemoryRentalAgreement.universeId = warper.universeId;\\n        inMemoryRentalAgreement.agreementTerms.listingTerms = rentalFees.listingTerms;\\n        inMemoryRentalAgreement.agreementTerms.universeTaxTerms = rentalFees.universeTaxTerms;\\n        inMemoryRentalAgreement.agreementTerms.protocolTaxTerms = rentalFees.protocolTaxTerms;\\n        inMemoryRentalAgreement.agreementTerms.paymentTokenData = paymentTokenData;\\n\\n        Agreement storage agreementRecord = self.agreements[rentalId];\\n        agreementRecord.universeId = inMemoryRentalAgreement.universeId;\\n        agreementRecord.agreementTerms.listingTerms = inMemoryRentalAgreement.agreementTerms.listingTerms;\\n        agreementRecord.agreementTerms.universeTaxTerms = inMemoryRentalAgreement.agreementTerms.universeTaxTerms;\\n        agreementRecord.agreementTerms.protocolTaxTerms = inMemoryRentalAgreement.agreementTerms.protocolTaxTerms;\\n        agreementRecord.agreementTerms.paymentTokenData = inMemoryRentalAgreement.agreementTerms.paymentTokenData;\\n\\n        return inMemoryRentalAgreement;\\n    }\\n\\n    /**\\n     * @dev Safely removes expired rental data from the registry.\\n     */\\n    function removeExpiredRentalAgreement(Registry storage self, uint256 rentalId) external {\\n        if (self.agreements[rentalId].isEffective()) revert CannotDeleteEffectiveRentalAgreement(rentalId);\\n        _removeRentalAgreement(self, rentalId);\\n    }\\n\\n    /**\\n     * @dev Removes rental data from the registry.\\n     */\\n    function _removeRentalAgreement(Registry storage self, uint256 rentalId) private {\\n        Agreement storage rentalAgreement = self.agreements[rentalId];\\n        address renter = rentalAgreement.renter;\\n\\n        bytes32 collectionId = self.agreements[rentalId].collectionId;\\n        self.renters[renter].rentalIndex.remove(rentalId);\\n        self.renters[renter].collectionRentalIndex[collectionId].remove(rentalId);\\n\\n        self.agreementsHistory[rentalId] = rentalAgreement;\\n        // Delete rental agreement.\\n        delete self.agreements[rentalId];\\n    }\\n\\n    /**\\n     * @dev Finds all effective rental agreements from specific collection.\\n     * Returns the total value rented by `renter`.\\n     */\\n    function collectionRentedValue(\\n        Registry storage self,\\n        address renter,\\n        bytes32 collectionId\\n    ) external view returns (uint256 value) {\\n        EnumerableSetUpgradeable.UintSet storage rentalIndex = self.renters[renter].collectionRentalIndex[collectionId];\\n        uint256 length = rentalIndex.length();\\n        for (uint256 i = 0; i < length; i++) {\\n            Agreement storage agreement = self.agreements[rentalIndex.at(i)];\\n\\n            if (agreement.isEffective()) {\\n                for (uint256 j = 0; j < agreement.warpedAssets.length; j++) {\\n                    value += agreement.warpedAssets[j].value;\\n                }\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns asset(s) rental status based on latest rental agreement.\\n     */\\n    function assetRentalStatus(Registry storage self, Assets.AssetId memory assetId)\\n        external\\n        view\\n        returns (RentalStatus)\\n    {\\n        uint256 latestRentalId = self.assets[assetId.hash()].latestRentalId;\\n        if (latestRentalId == 0) return RentalStatus.NONE;\\n\\n        return self.agreements[latestRentalId].isEffective() ? RentalStatus.RENTED : RentalStatus.AVAILABLE;\\n    }\\n\\n    /**\\n     * @dev Main renting request validation function.\\n     */\\n    function validateRentingParams(Params calldata params, IMetahub metahub) external view {\\n        // Validate from the renter's perspective.\\n        if (params.renter == address(0)) {\\n            revert RenterCannotBeZeroAddress();\\n        }\\n        // Validate from the listing perspective.\\n        IListingManager listingManager = IListingManager(metahub.getContract(Contracts.LISTING_MANAGER));\\n        listingManager.checkRegisteredAndListed(params.listingId);\\n        Listings.Listing memory listing = listingManager.listingInfo(params.listingId);\\n        listing.checkNotPaused();\\n        listing.checkValidLockPeriod(params.rentalPeriod);\\n        // Validate from the warper and strategy override config registry perspective.\\n        IWarperManager warperManager = IWarperManager(metahub.getContract(Contracts.WARPER_MANAGER));\\n        warperManager.checkRegisteredWarper(params.warper);\\n        Warpers.Warper memory warper = warperManager.warperInfo(params.warper);\\n        warper.checkNotPaused();\\n        warper.controller.validateRentingParams(warper, listing.assets, params);\\n\\n        // Validate from the universe perspective\\n        IUniverseRegistry(metahub.getContract(Contracts.UNIVERSE_REGISTRY)).checkUniversePaymentToken(\\n            warper.universeId,\\n            params.paymentToken\\n        );\\n\\n        IListingTermsRegistry.ListingTerms memory listingTerms;\\n\\n        if (listing.configurator != address(0)) {\\n            IListingConfiguratorRegistry(metahub.getContract(Contracts.LISTING_CONFIGURATOR_REGISTRY))\\n                .getController(listing.configurator)\\n                .validateRenting(params, listing, warper.universeId);\\n            listingTerms = params.selectedConfiguratorListingTerms;\\n        } else {\\n            // Validate from the listing terms perspective\\n            IListingTermsRegistry.Params memory listingTermsParams = IListingTermsRegistry.Params({\\n                listingId: params.listingId,\\n                universeId: warper.universeId,\\n                warperAddress: params.warper\\n            });\\n            IListingTermsRegistry listingTermsRegistry = IListingTermsRegistry(\\n                metahub.getContract(Contracts.LISTING_TERMS_REGISTRY)\\n            );\\n            listingTermsRegistry.checkRegisteredListingTermsWithParams(params.listingTermsId, listingTermsParams);\\n            listingTerms = listingTermsRegistry.listingTerms(params.listingTermsId);\\n        }\\n\\n        bytes4 taxStrategyId = IListingStrategyRegistry(metahub.getContract(Contracts.LISTING_STRATEGY_REGISTRY))\\n            .listingTaxId(listingTerms.strategyId);\\n        // Validate from the tax terms perspective\\n        ITaxTermsRegistry.Params memory taxTermsParams = ITaxTermsRegistry.Params({\\n            taxStrategyId: taxStrategyId,\\n            universeId: warper.universeId,\\n            warperAddress: params.warper\\n        });\\n        ITaxTermsRegistry taxTermsRegistry = ITaxTermsRegistry(metahub.getContract(Contracts.TAX_TERMS_REGISTRY));\\n        taxTermsRegistry.checkRegisteredUniverseTaxTermsWithParams(taxTermsParams);\\n        taxTermsRegistry.checkRegisteredProtocolTaxTermsWithParams(taxTermsParams);\\n    }\\n\\n    /**\\n     * @dev Performs rental fee calculation and returns the fee breakdown.\\n     */\\n    function calculateRentalFees(\\n        Params calldata rentingParams,\\n        Warpers.Warper memory warper,\\n        IMetahub metahub\\n    ) external view returns (RentalFees memory fees) {\\n        // Resolve listing info\\n        Listings.Listing memory listing = IListingManager(metahub.getContract(Contracts.LISTING_MANAGER)).listingInfo(\\n            rentingParams.listingId\\n        );\\n\\n        // Listing terms\\n        IListingTermsRegistry.Params memory listingTermsParams;\\n\\n        if (listing.configurator != address(0)) {\\n            fees.listingTerms = rentingParams.selectedConfiguratorListingTerms;\\n        } else {\\n            // Compose ListingTerms Params for getting listing terms\\n            listingTermsParams = IListingTermsRegistry.Params({\\n                listingId: rentingParams.listingId,\\n                universeId: warper.universeId,\\n                warperAddress: rentingParams.warper\\n            });\\n\\n            // Reading Listing Terms from Listing Terms Registry\\n            fees.listingTerms = IListingTermsRegistry(metahub.getContract(Contracts.LISTING_TERMS_REGISTRY))\\n                .listingTerms(rentingParams.listingTermsId);\\n        }\\n        // Resolve listing controller to calculate lister fee based on selected listing strategy.\\n        address listingControllerAddress = IListingStrategyRegistry(\\n            metahub.getContract(Contracts.LISTING_STRATEGY_REGISTRY)\\n        ).listingController(fees.listingTerms.strategyId);\\n\\n        // Resolving all fees using single call to ListingController.calculateRentalFee(...)\\n        (\\n            fees.total,\\n            fees.listerBaseFee,\\n            fees.universeBaseFee,\\n            fees.protocolFee,\\n            fees.universeTaxTerms,\\n            fees.protocolTaxTerms\\n        ) = IListingController(listingControllerAddress).calculateRentalFee(\\n            listingTermsParams,\\n            fees.listingTerms,\\n            rentingParams\\n        );\\n        // Calculate warper premiums.\\n        (uint256 universePremium, uint256 listerPremium) = warper.controller.calculatePremiums(\\n            listing.assets,\\n            rentingParams,\\n            fees.universeBaseFee,\\n            fees.listerBaseFee\\n        );\\n        // Setting premiums.\\n        fees.listerPremium = listerPremium;\\n        fees.universePremium = universePremium;\\n        // Adding premiums to fees.total.\\n        fees.total += fees.listerPremium;\\n        fees.total += fees.universePremium;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/universe/universe-registry/IUniverseRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\n\\ninterface IUniverseRegistry is IContractEntity {\\n    /**\\n     * @dev Thrown when the message sender does not own UNIVERSE_WIZARD role and is not Universe owner.\\n     * @param universeId The Universe ID.\\n     * @param account The account that was checked.\\n     */\\n    error AccountIsNotAuthorizedOperatorForUniverseManagement(uint256 universeId, address account);\\n\\n    /**\\n     * @dev Thrown when the message sender does not own UNIVERSE_WIZARD role.\\n     */\\n    error AccountIsNotUniverseWizard(address account);\\n\\n    /**\\n     * @dev Thrown when a check is made where the given account must also be the Universe owner.\\n     */\\n    error AccountIsNotUniverseOwner(address account);\\n\\n    /**\\n     * @dev Thrown when a check is made when given token is not registered for the universe.\\n     */\\n    error PaymentTokenIsNotRegistered(address paymentToken);\\n\\n    /**\\n     * @dev Thrown when trying to add payment token that is already register for the universe.\\n     */\\n    error PaymentTokenAlreadyRegistered(address paymentToken);\\n\\n    /**\\n     * @dev Thrown when a the supplied universe name is empty.\\n     */\\n    error EmptyUniverseName();\\n\\n    /**\\n     * @dev Thrown when trying to register a universe with empty list of payment tokens.\\n     */\\n    error EmptyListOfUniversePaymentTokens();\\n\\n    /**\\n     * @dev Thrown when trying to read universe data for a universe is not registered.\\n     */\\n    error QueryForNonExistentUniverse(uint256 universeId);\\n\\n    /**\\n     * @dev Emitted when a universe is created.\\n     * @param universeId Universe ID.\\n     * @param name Universe name.\\n     * @param paymentTokens Universe token.\\n     */\\n    event UniverseCreated(uint256 indexed universeId, string name, address[] paymentTokens);\\n\\n    /**\\n     * @dev Emitted when a universe name is changed.\\n     * @param universeId Universe ID.\\n     * @param name The newly set name.\\n     */\\n    event UniverseNameChanged(uint256 indexed universeId, string name);\\n\\n    /**\\n     * @dev Emitted when a universe payment token is registered.\\n     * @param universeId Universe ID.\\n     * @param paymentToken Universe payment token.\\n     */\\n    event PaymentTokenRegistered(uint256 indexed universeId, address paymentToken);\\n\\n    /**\\n     * @dev Emitted when a universe payment token is disabled.\\n     * @param universeId Universe ID.\\n     * @param paymentToken Universe payment token.\\n     */\\n    event PaymentTokenRemoved(uint256 indexed universeId, address paymentToken);\\n\\n    /**\\n     * @dev Updates the universe token base URI.\\n     * @param baseURI New base URI. Must include a trailing slash (\\\"/\\\").\\n     */\\n    function setUniverseTokenBaseURI(string calldata baseURI) external;\\n\\n    /**\\n     * @dev The universe properties & initial configuration params.\\n     * @param name The universe name.\\n     * @param token The universe name.\\n     */\\n    struct UniverseParams {\\n        string name;\\n        address[] paymentTokens;\\n    }\\n\\n    /**\\n     * @dev Creates new Universe. This includes minting new universe NFT,\\n     * where the caller of this method becomes the universe owner.\\n     * @param params The universe properties & initial configuration params.\\n     * @return Universe ID (universe token ID).\\n     */\\n    function createUniverse(UniverseParams calldata params) external returns (uint256);\\n\\n    /**\\n     * @dev Update the universe name.\\n     * @param universeId The unique identifier for the universe.\\n     * @param universeName The universe name to set.\\n     */\\n    function setUniverseName(uint256 universeId, string memory universeName) external;\\n\\n    /**\\n     * @dev Registers certain payment token for universe.\\n     * @param universeId The unique identifier for the universe.\\n     * @param paymentToken The universe payment token.\\n     */\\n    function registerUniversePaymentToken(uint256 universeId, address paymentToken) external;\\n\\n    /**\\n     * @dev Removes certain payment token for universe.\\n     * @param universeId The unique identifier for the universe.\\n     * @param paymentToken The universe payment token.\\n     */\\n    function removeUniversePaymentToken(uint256 universeId, address paymentToken) external;\\n\\n    /**\\n     * @dev Returns name.\\n     * @param universeId Universe ID.\\n     * @return universe name.\\n     */\\n    function universeName(uint256 universeId) external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Universe payment token address.\\n     */\\n    function universePaymentTokens(uint256 universeId) external view returns (address[] memory paymentTokens);\\n\\n    /**\\n     * @dev Returns the Universe token address.\\n     */\\n    function universeToken() external view returns (address);\\n\\n    /**\\n     * @dev Returns the Universe token base URI.\\n     */\\n    function universeTokenBaseURI() external view returns (string memory);\\n\\n    /**\\n     * @dev Aggregate and return Universe data.\\n     * @param universeId Universe-specific ID.\\n     * @return name The name of the universe.\\n     */\\n    function universe(uint256 universeId) external view returns (string memory name, address[] memory paymentTokens);\\n\\n    /**\\n     * @dev Reverts if the universe owner is not the provided account address.\\n     * @param universeId Universe ID.\\n     * @param account The address of the expected owner.\\n     */\\n    function checkUniverseOwner(uint256 universeId, address account) external view;\\n\\n    /**\\n     * @dev Reverts if the universe owner is not the provided account address.\\n     * @param universeId Universe ID.\\n     * @param paymentToken The address of the payment token.\\n     */\\n    function checkUniversePaymentToken(uint256 universeId, address paymentToken) external view;\\n\\n    /**\\n     * @dev Returns `true` if the universe owner is the supplied account address.\\n     * @param universeId Universe ID.\\n     * @param account The address of the expected owner.\\n     */\\n    function isUniverseOwner(uint256 universeId, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns `true` if the account is UNIVERSE_WIZARD.\\n     * @param account The account to check for.\\n     */\\n    function isUniverseWizard(address account) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/listing/listing-strategies/ListingStrategies.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../listing-terms-registry/IListingTermsRegistry.sol\\\";\\n\\nlibrary ListingStrategies {\\n    bytes4 public constant FIXED_RATE = bytes4(keccak256(\\\"FIXED_RATE\\\"));\\n    bytes4 public constant FIXED_RATE_WITH_REWARD = bytes4(keccak256(\\\"FIXED_RATE_WITH_REWARD\\\"));\\n\\n    /**\\n     * @dev Thrown when the listing strategy ID does not match the required one.\\n     * @param provided Provided listing strategy ID.\\n     * @param required Required listing strategy ID.\\n     */\\n    error ListingStrategyMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Modifier to check strategy compatibility.\\n     */\\n    modifier compatibleStrategy(bytes4 checkedStrategyId, bytes4 expectedStrategyId) {\\n        if (checkedStrategyId != expectedStrategyId)\\n            revert ListingStrategyMismatch(checkedStrategyId, expectedStrategyId);\\n        _;\\n    }\\n\\n    function getSupportedListingStrategyIDs() internal pure returns (bytes4[] memory supportedListingStrategyIDs) {\\n        bytes4[] memory supportedListingStrategies = new bytes4[](2);\\n        supportedListingStrategies[0] = FIXED_RATE;\\n        supportedListingStrategies[1] = FIXED_RATE_WITH_REWARD;\\n        return supportedListingStrategies;\\n    }\\n\\n    function isValidListingStrategy(bytes4 listingStrategyId) internal pure returns (bool) {\\n        return listingStrategyId == FIXED_RATE || listingStrategyId == FIXED_RATE_WITH_REWARD;\\n    }\\n\\n    function decodeFixedRateListingStrategyParams(IListingTermsRegistry.ListingTerms memory terms)\\n        internal\\n        pure\\n        compatibleStrategy(terms.strategyId, FIXED_RATE)\\n        returns (uint256 baseRate)\\n    {\\n        return abi.decode(terms.strategyData, (uint256));\\n    }\\n\\n    function decodeFixedRateWithRewardListingStrategyParams(IListingTermsRegistry.ListingTerms memory terms)\\n        internal\\n        pure\\n        compatibleStrategy(terms.strategyId, FIXED_RATE_WITH_REWARD)\\n        returns (uint256 baseRate, uint16 rewardPercentage)\\n    {\\n        return abi.decode(terms.strategyData, (uint256, uint16));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/listing/listing-strategies/fixed-rate-with-reward/IFixedRateWithRewardListingController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../IListingController.sol\\\";\\n\\ninterface IFixedRateWithRewardListingController is IListingController {\\n    /**\\n     * @dev Decodes listing terms data.\\n     * @param terms Encoded listing terms.\\n     * @return baseRate Asset renting base rate (base tokens per second).\\n     * @return rewardPercentage Asset renting base reward percentage rate.\\n     */\\n    function decodeStrategyParams(IListingTermsRegistry.ListingTerms memory terms)\\n        external\\n        pure\\n        returns (uint256 baseRate, uint16 rewardPercentage);\\n}\\n\"\r\n    },\r\n    \"contracts/tax/tax-strategies/fixed-rate-with-reward/IFixedRateWithRewardTaxController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../ITaxController.sol\\\";\\n\\ninterface IFixedRateWithRewardTaxController is ITaxController {\\n    /**\\n     * @dev Decodes tax terms data.\\n     * @param terms Encoded tax terms.\\n     * @return baseTaxRate Asset renting base tax (base rate per rental).\\n     * @return rewardTaxRate Asset renting reward base tax (base rate per reward).\\n     */\\n    function decodeStrategyParams(ITaxTermsRegistry.TaxTerms memory terms)\\n        external\\n        pure\\n        returns (uint16 baseTaxRate, uint16 rewardTaxRate);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/metahub/Protocol.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\n\\nlibrary Protocol {\\n    /**\\n     * @dev Thrown when the provided token does not match with the configured base token.\\n     */\\n    error BaseTokenMismatch();\\n\\n    /**\\n     * @dev Protocol configuration.\\n     * @param baseToken ERC20 contract. Used as the price denominator.\\n     * @param protocolExternalFeesCollector Address that will accumulate fees\\n     * received from external source directly (e.g. Warper performing manual rewards distribution).\\n     */\\n    struct Config {\\n        IERC20Upgradeable baseToken;\\n        address protocolExternalFeesCollector;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/warper/warper-manager/Warpers.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/structs/EnumerableSetUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\\\";\\nimport \\\"../../asset/Assets.sol\\\";\\nimport \\\"../../contract-registry/Contracts.sol\\\";\\nimport \\\"../../metahub/core/IMetahub.sol\\\";\\nimport \\\"../IWarperController.sol\\\";\\nimport \\\"../preset-factory/IWarperPresetFactory.sol\\\";\\nimport \\\"./IWarperManager.sol\\\";\\nimport \\\"../IWarper.sol\\\";\\n\\nlibrary Warpers {\\n    using AddressUpgradeable for address;\\n    using ERC165CheckerUpgradeable for address;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.AddressSet;\\n    using EnumerableSetUpgradeable for EnumerableSetUpgradeable.Bytes32Set;\\n    using Warpers for Registry;\\n    using Assets for Assets.Asset;\\n    using Assets for Assets.Registry;\\n\\n    /**\\n     * @dev Thrown if creating warper for universe asset in case one already exists.\\n     */\\n    error MultipleWarpersNotSupported();\\n\\n    /**\\n     * @dev Thrown if provided warper address does not implement warper interface.\\n     */\\n    error InvalidWarperInterface();\\n\\n    /**\\n     * @dev Thrown when the warper returned metahub address differs from the one it is being registered in.\\n     * @param provided Metahub address returned by warper.\\n     * @param required Required metahub address.\\n     */\\n    error WarperHasIncorrectMetahubReference(address provided, address required);\\n\\n    /**\\n     * @dev Thrown when performing action or accessing data of an unknown warper.\\n     * @param warper Warper address.\\n     */\\n    error WarperIsNotRegistered(address warper);\\n\\n    /**\\n     * @dev Thrown upon attempting to register a warper twice.\\n     * @param warper Duplicate warper address.\\n     */\\n    error WarperIsAlreadyRegistered(address warper);\\n\\n    /**\\n     * @dev Thrown upon attempting to rent for universe without any warper(s).\\n     */\\n    error MissingWarpersForUniverse(uint256 universeId);\\n\\n    /**\\n     * @dev Thrown upon attempting to rent for asset in the certain universe without any warper(s).\\n     */\\n    error MissingWarpersForAssetInUniverse(uint256 universeId, address asset);\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the warper being paused.\\n     */\\n    error WarperIsPaused();\\n\\n    /**\\n     * @dev Thrown when the operation is not allowed due to the warper not being paused.\\n     */\\n    error WarperIsNotPaused();\\n\\n    /**\\n     * @dev Thrown when there are no registered warpers for a particular asset.\\n     * @param asset Asset address.\\n     */\\n    error UnsupportedAsset(address asset);\\n\\n    /**\\n     * @dev Thrown upon attempting to use the warper which is not registered for the provided asset.\\n     */\\n    error IncompatibleAsset(address asset);\\n\\n    /**\\n     * @dev Registered warper data.\\n     * @param assetClass The identifying asset class.\\n     * @param original Original asset contract address.\\n     * @param paused Indicates whether the warper is paused.\\n     * @param controller Warper controller.\\n     * @param name Warper name.\\n     * @param universeId Warper universe ID.\\n     */\\n    struct Warper {\\n        bytes4 assetClass;\\n        address original;\\n        bool paused;\\n        IWarperController controller;\\n        string name;\\n        uint256 universeId;\\n    }\\n\\n    /**\\n     * @dev Reverts if the warper original does not match the `asset`;\\n     */\\n    function checkCompatibleAsset(Warper memory self, Assets.Asset memory asset) internal pure {\\n        address original = asset.token();\\n        if (self.original != original) revert IncompatibleAsset(original);\\n    }\\n\\n    /**\\n     * @dev Puts the warper on pause.\\n     */\\n    function pause(Warper storage self) internal {\\n        if (self.paused) revert WarperIsPaused();\\n\\n        self.paused = true;\\n    }\\n\\n    /**\\n     * @dev Lifts the warper pause.\\n     */\\n    function unpause(Warper storage self) internal {\\n        if (!self.paused) revert WarperIsNotPaused();\\n\\n        self.paused = false;\\n    }\\n\\n    /**\\n     * @dev Reverts if the warper is paused.\\n     */\\n    function checkNotPaused(Warper memory self) internal pure {\\n        if (self.paused) revert WarperIsPaused();\\n    }\\n\\n    /**\\n     * @dev Warper registry.\\n     * @param presetFactory Warper preset factory contract.\\n     * @param warperIndex Set of registered warper addresses.\\n     * @param universeWarperIndex Mapping from a universe ID to the set of warper addresses registered by the universe.\\n     * @param universeAssetWarperIndex Mapping from a universe ID to the set of warper addresses registered\\n     * by the universe.\\n     * @param assetWarperIndex Mapping from an original asset address to the set of warper addresses,\\n     * registered for the asset.\\n     * @param warpers Mapping from a warper address to the warper details.\\n     */\\n    struct Registry {\\n        IWarperPresetFactory presetFactory;\\n        EnumerableSetUpgradeable.AddressSet warperIndex;\\n        mapping(uint256 => EnumerableSetUpgradeable.AddressSet) universeWarperIndex;\\n        mapping(address => EnumerableSetUpgradeable.AddressSet) assetWarperIndex;\\n        mapping(uint256 => mapping(address => EnumerableSetUpgradeable.AddressSet)) universeAssetWarperIndex;\\n        mapping(address => Warpers.Warper) warpers;\\n    }\\n\\n    /**\\n     * @dev Performs warper registration.\\n     * @param warper Warper address.\\n     * @param params Warper registration params.\\n     */\\n    function registerWarper(\\n        Registry storage self,\\n        address warper,\\n        IWarperManager.WarperRegistrationParams memory params\\n    ) internal returns (bytes4 assetClass, address original) {\\n        // Check that provided warper address is a valid contract.\\n        if (!warper.isContract() || !warper.supportsInterface(type(IWarper).interfaceId)) {\\n            revert InvalidWarperInterface();\\n        }\\n\\n        // Creates allowance for only one warper for universe asset.\\n        // Throws when trying to create warper for universe asset in case one already exists.\\n        // Should be removed while adding multi-warper support for universe asset.\\n        if (self.universeAssetWarperIndex[params.universeId][IWarper(warper).__original()].length() >= 1) {\\n            revert MultipleWarpersNotSupported();\\n        }\\n\\n        // Check that warper has correct metahub reference.\\n        address metahub = IWarper(warper).__metahub();\\n        if (metahub != IWarperManager(address(this)).metahub())\\n            revert WarperHasIncorrectMetahubReference(metahub, IWarperManager(address(this)).metahub());\\n\\n        // Check that warper asset class is supported.\\n        assetClass = IWarper(warper).__assetClass();\\n\\n        address warperController = IAssetClassRegistry(IMetahub(metahub).getContract(Contracts.ASSET_CLASS_REGISTRY))\\n            .assetClassConfig(assetClass)\\n            .controller;\\n\\n        // Retrieve warper controller based on assetClass.\\n        // Controller resolution for unsupported asset class will revert.\\n        IWarperController controller = IWarperController(warperController);\\n\\n        // Ensure warper compatibility with the current generation of asset controller.\\n        controller.checkCompatibleWarper(warper);\\n\\n        // Retrieve original asset address.\\n        original = IWarper(warper).__original();\\n\\n        // Save warper record.\\n        _register(\\n            self,\\n            warper,\\n            Warpers.Warper({\\n                original: original,\\n                controller: controller,\\n                name: params.name,\\n                universeId: params.universeId,\\n                paused: params.paused,\\n                assetClass: assetClass\\n            })\\n        );\\n    }\\n\\n    /**\\n     * @dev Performs warper registration.\\n     */\\n    function _register(\\n        Registry storage self,\\n        address warperAddress,\\n        Warper memory warper\\n    ) private {\\n        if (!self.warperIndex.add(warperAddress)) revert WarperIsAlreadyRegistered(warperAddress);\\n\\n        // Create warper main registration record.\\n        self.warpers[warperAddress] = warper;\\n        // Associate the warper with the universe.\\n        self.universeWarperIndex[warper.universeId].add(warperAddress);\\n        // Associate the warper with the original asset.\\n        self.assetWarperIndex[warper.original].add(warperAddress);\\n        // Associate the warper to the original asset in certain universe\\n        self.universeAssetWarperIndex[warper.universeId][warper.original].add(warperAddress);\\n    }\\n\\n    /**\\n     * @dev Removes warper data from the registry.\\n     */\\n    function remove(Registry storage self, address warperAddress) internal {\\n        Warper storage warper = self.warpers[warperAddress];\\n        // Clean up universe index.\\n        self.universeWarperIndex[warper.universeId].remove(warperAddress);\\n        // Clean up asset index.\\n        self.assetWarperIndex[warper.original].remove(warperAddress);\\n        // Clean up main index.\\n        self.warperIndex.remove(warperAddress);\\n        // Clean up universe asset index\\n        self.universeAssetWarperIndex[warper.universeId][warper.original].remove(warperAddress);\\n        // Delete warper data.\\n        delete self.warpers[warperAddress];\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of warpers belonging to the particular universe.\\n     */\\n    function universeWarpers(\\n        Registry storage self,\\n        uint256 universeId,\\n        uint256 offset,\\n        uint256 limit\\n    ) internal view returns (address[] memory, Warpers.Warper[] memory) {\\n        return self.paginateIndexedWarpers(self.universeWarperIndex[universeId], offset, limit);\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of warpers belonging to the particular universe.\\n     */\\n    function universeAssetWarpers(\\n        Registry storage self,\\n        uint256 universeId,\\n        address asset,\\n        uint256 offset,\\n        uint256 limit\\n    ) internal view returns (address[] memory, Warpers.Warper[] memory) {\\n        return self.paginateIndexedWarpers(self.universeAssetWarperIndex[universeId][asset], offset, limit);\\n    }\\n\\n    /**\\n     * @dev Checks warper registration by address.\\n     */\\n    function isRegisteredWarper(Registry storage self, address warper) internal view returns (bool) {\\n        return self.warperIndex.contains(warper);\\n    }\\n\\n    /**\\n     * @dev Reverts if warper is not registered.\\n     */\\n    function checkRegisteredWarper(Registry storage self, address warper) internal view {\\n        if (!self.isRegisteredWarper(warper)) revert WarperIsNotRegistered(warper);\\n    }\\n\\n    /**\\n     * @dev Reverts if no warpers are registered for the universe.\\n     */\\n    function checkUniverseHasWarper(Registry storage self, uint256 universeId) internal view {\\n        if (self.universeWarperIndex[universeId].length() == 0) revert MissingWarpersForUniverse(universeId);\\n    }\\n\\n    /**\\n     * @dev Reverts if no warpers are registered for the universe.\\n     */\\n    function checkUniverseHasWarperForAsset(\\n        Registry storage self,\\n        uint256 universeId,\\n        address asset\\n    ) internal view {\\n        if (self.universeAssetWarperIndex[universeId][asset].length() == 0)\\n            revert MissingWarpersForAssetInUniverse(universeId, asset);\\n    }\\n\\n    /**\\n     * @dev Checks asset support by address.\\n     * The supported asset should have at least one warper.\\n     * @param asset Asset address.\\n     */\\n    function isSupportedAsset(Registry storage self, address asset) internal view returns (bool) {\\n        return self.assetWarperIndex[asset].length() > 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of warpers belonging to the particular universe.\\n     */\\n    function universeWarperCount(Registry storage self, uint256 universeId) internal view returns (uint256) {\\n        return self.universeWarperIndex[universeId].length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of warpers registered for certain asset in universe.\\n     * @param universeId Universe ID.\\n     * @param asset Asset address.\\n     */\\n    function universeAssetWarperCount(\\n        Registry storage self,\\n        uint256 universeId,\\n        address asset\\n    ) internal view returns (uint256) {\\n        return self.universeAssetWarperIndex[universeId][asset].length();\\n    }\\n\\n    /**\\n     * @dev Returns the number of warpers associated with the particular original asset.\\n     */\\n    function supported(Registry storage self, address original) internal view returns (uint256) {\\n        return self.assetWarperIndex[original].length();\\n    }\\n\\n    /**\\n     * @dev Returns the paginated list of registered warpers using provided index reference.\\n     */\\n    function paginateIndexedWarpers(\\n        Registry storage self,\\n        EnumerableSetUpgradeable.AddressSet storage warperIndex,\\n        uint256 offset,\\n        uint256 limit\\n    ) internal view returns (address[] memory, Warper[] memory) {\\n        uint256 indexSize = warperIndex.length();\\n        if (offset >= indexSize) return (new address[](0), new Warper[](0));\\n\\n        if (limit > indexSize - offset) {\\n            limit = indexSize - offset;\\n        }\\n\\n        Warper[] memory warpers = new Warper[](limit);\\n        address[] memory warperAddresses = new address[](limit);\\n        for (uint256 i = 0; i < limit; i++) {\\n            warperAddresses[i] = warperIndex.at(offset + i);\\n            warpers[i] = self.warpers[warperAddresses[i]];\\n        }\\n\\n        return (warperAddresses, warpers);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/listing/listing-configurator/registry/IListingConfiguratorRegistry.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../../acl/delegated/IDelegatedAccessControlEnumerable.sol\\\";\\nimport \\\"../../../contract-registry/IContractEntity.sol\\\";\\nimport \\\"../IListingConfiguratorController.sol\\\";\\n\\ninterface IListingConfiguratorRegistry is IDelegatedAccessControlEnumerable, IContractEntity {\\n    error InvalidZeroAddress();\\n    error CannotGrantRoleForUnregisteredController(address delegate);\\n    error InvalidListingConfiguratorController(address controller);\\n    /**\\n     * @dev Thrown when lister specifies listing configurator which is not registered in\\n     * {IListingConfiguratorRegistry}\\n     */\\n    error ListingConfiguratorNotRegistered(address listingConfigurator);\\n\\n    event ListingConfiguratorControllerChanged(address indexed previousController, address indexed newController);\\n\\n    /**\\n     * IListingConfiguratorRegistryConfigurator.\\n     * The listing configurator must be deployed and configured prior to registration,\\n     * since it becomes available for renting immediately.\\n     * @param listingConfigurator Listing configurator address.\\n     */\\n    function registerListingConfigurator(address listingConfigurator, address admin) external;\\n\\n    function setController(address controller) external;\\n\\n    function getController(address listingConfigurator) external view returns (IListingConfiguratorController);\\n}\\n\"\r\n    },\r\n    \"contracts/listing/listing-strategies/IListingController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\nimport \\\"../listing-terms-registry/IListingTermsRegistry.sol\\\";\\nimport \\\"../../tax/tax-terms-registry/ITaxTermsRegistry.sol\\\";\\nimport \\\"../../renting/Rentings.sol\\\";\\n\\ninterface IListingController is IERC165, IContractEntity {\\n    /**\\n     * @dev Calculates rental fee based on listing terms, tax terms and renting params.\\n     * @param listingTermsParams Listing terms params.\\n     * @param listingTerms Listing terms.\\n     * @param rentingParams Renting params.\\n     * @return totalFee Rental fee (base tokens per second including taxes).\\n     * @return listerBaseFee Lister fee (base tokens per second without taxes).\\n     * @return universeBaseFee Universe fee.\\n     * @return protocolBaseFee Protocol fee.\\n     * @return universeTaxTerms Universe tax terms.\\n     * @return protocolTaxTerms Protocol tax terms.\\n     */\\n    function calculateRentalFee(\\n        IListingTermsRegistry.Params calldata listingTermsParams,\\n        IListingTermsRegistry.ListingTerms calldata listingTerms,\\n        Rentings.Params calldata rentingParams\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 totalFee,\\n            uint256 listerBaseFee,\\n            uint256 universeBaseFee,\\n            uint256 protocolBaseFee,\\n            ITaxTermsRegistry.TaxTerms memory universeTaxTerms,\\n            ITaxTermsRegistry.TaxTerms memory protocolTaxTerms\\n        );\\n\\n    /**\\n     * @dev Returns implemented strategy ID.\\n     * @return Listing strategy ID.\\n     */\\n    function strategyId() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165CheckerUpgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.2) (utils/introspection/ERC165Checker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Library used to query support of an interface declared via {IERC165}.\\n *\\n * Note that these functions return the actual result of the query: they do not\\n * `revert` if an interface is not supported. It is up to the caller to decide\\n * what to do in these cases.\\n */\\nlibrary ERC165CheckerUpgradeable {\\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\\n\\n    /**\\n     * @dev Returns true if `account` supports the {IERC165} interface,\\n     */\\n    function supportsERC165(address account) internal view returns (bool) {\\n        // Any contract that implements ERC165 must explicitly indicate support of\\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\\n        return\\n            _supportsERC165Interface(account, type(IERC165Upgradeable).interfaceId) &&\\n            !_supportsERC165Interface(account, _INTERFACE_ID_INVALID);\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports the interface defined by\\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\\n        // query support of both ERC165 as per the spec and support of _interfaceId\\n        return supportsERC165(account) && _supportsERC165Interface(account, interfaceId);\\n    }\\n\\n    /**\\n     * @dev Returns a boolean array where each value corresponds to the\\n     * interfaces passed in and whether they're supported or not. This allows\\n     * you to batch check interfaces for a contract where your expectation\\n     * is that some interfaces may not be supported.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\\n        internal\\n        view\\n        returns (bool[] memory)\\n    {\\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\\n\\n        // query support of ERC165 itself\\n        if (supportsERC165(account)) {\\n            // query support of each interface in interfaceIds\\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\\n                interfaceIdsSupported[i] = _supportsERC165Interface(account, interfaceIds[i]);\\n            }\\n        }\\n\\n        return interfaceIdsSupported;\\n    }\\n\\n    /**\\n     * @dev Returns true if `account` supports all the interfaces defined in\\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\\n     *\\n     * Batch-querying can lead to gas savings by skipping repeated checks for\\n     * {IERC165} support.\\n     *\\n     * See {IERC165-supportsInterface}.\\n     */\\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\\n        // query support of ERC165 itself\\n        if (!supportsERC165(account)) {\\n            return false;\\n        }\\n\\n        // query support of each interface in _interfaceIds\\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\\n            if (!_supportsERC165Interface(account, interfaceIds[i])) {\\n                return false;\\n            }\\n        }\\n\\n        // all interfaces supported\\n        return true;\\n    }\\n\\n    /**\\n     * @notice Query if a contract implements an interface, does not check ERC165 support\\n     * @param account The address of the contract to query for support of an interface\\n     * @param interfaceId The interface identifier, as specified in ERC-165\\n     * @return true if the contract at account indicates support of the interface with\\n     * identifier interfaceId, false otherwise\\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\\n     * the behavior of this method is undefined. This precondition can be checked\\n     * with {supportsERC165}.\\n     * Interface identification is specified in ERC-165.\\n     */\\n    function _supportsERC165Interface(address account, bytes4 interfaceId) private view returns (bool) {\\n        // prepare call\\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165Upgradeable.supportsInterface.selector, interfaceId);\\n\\n        // perform static call\\n        bool success;\\n        uint256 returnSize;\\n        uint256 returnValue;\\n        assembly {\\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\\n            returnSize := returndatasize()\\n            returnValue := mload(0x00)\\n        }\\n\\n        return success && returnSize >= 0x20 && returnValue > 0;\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/warper/IWarperController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../asset/IAssetController.sol\\\";\\nimport \\\"../accounting/Accounts.sol\\\";\\nimport \\\"../renting/Rentings.sol\\\";\\nimport \\\"../warper/warper-manager/Warpers.sol\\\";\\n\\ninterface IWarperController is IAssetController {\\n    /**\\n     * @dev Thrown if warper interface is not compatible with the controller.\\n     */\\n    error IncompatibleWarperInterface();\\n\\n    /**\\n     * @dev Thrown upon attempting to use the warper with an asset different from the one expected by the warper.\\n     */\\n    error InvalidAssetForWarper(address warper, address asset);\\n\\n    /**\\n     * @dev Thrown upon attempting to rent a warped asset which is already rented.\\n     */\\n    error AlreadyRented();\\n\\n    /**\\n     * @dev Takes an existing asset and then mints a warper token representing it.\\n     *      Used in Renting Manager->Warper communication.\\n     * @param assets The asset(s) that must be warped.\\n     * @param warper Warper contract to be used for warping.\\n     * @param to The account which will receive the warped asset.\\n     * @return warpedCollectionId The warped collection ID.\\n     * @return warpedAssets The warped Assets.\\n     */\\n    function warp(\\n        Assets.Asset[] memory assets,\\n        address warper,\\n        address to\\n    ) external returns (bytes32 warpedCollectionId, Assets.Asset[] memory warpedAssets);\\n\\n    /**\\n     * @dev Executes warper rental hook.\\n     * @param rentalId Rental agreement ID.\\n     * @param rentalAgreement Newly registered rental agreement details.\\n     * @param rentalEarnings The rental earnings breakdown.\\n     */\\n    function executeRentingHooks(\\n        uint256 rentalId,\\n        Rentings.Agreement memory rentalAgreement,\\n        Accounts.RentalEarnings memory rentalEarnings\\n    ) external;\\n\\n    /**\\n     * @dev Validates that the warper interface is supported by the current WarperController.\\n     * @param warper Warper whose interface we must validate.\\n     * @return bool - `true` if warper is supported.\\n     */\\n    function isCompatibleWarper(address warper) external view returns (bool);\\n\\n    /**\\n     * @dev Reverts if provided warper is not compatible with the controller.\\n     */\\n    function checkCompatibleWarper(address warper) external view;\\n\\n    /**\\n     * @dev Validates renting params taking into account various warper mechanics and warper data.\\n     * Throws an error if the specified asset cannot be rented with particular renting parameters.\\n     * @param warper Registered warper data.\\n     * @param assets The listing asset(s) to validate for.\\n     * @param rentingParams Renting parameters.\\n     */\\n    function validateRentingParams(\\n        Warpers.Warper memory warper,\\n        Assets.Asset[] memory assets,\\n        Rentings.Params calldata rentingParams\\n    ) external view;\\n\\n    /**\\n     * @dev Calculates the universe and/or lister premiums.\\n     * Those are extra amounts that should be added the the resulting rental fee paid by renter.\\n     * @param assets Assets being rented.\\n     * @param rentingParams Renting parameters.\\n     * @param universeFee The current value of the Universe fee component.\\n     * @param listerFee The current value of the lister fee component.\\n     * @return universePremium The universe premium amount.\\n     * @return listerPremium The lister premium amount.\\n     */\\n    function calculatePremiums(\\n        Assets.Asset[] memory assets,\\n        Rentings.Params calldata rentingParams,\\n        uint256 universeFee,\\n        uint256 listerFee\\n    ) external view returns (uint256 universePremium, uint256 listerPremium);\\n}\\n\"\r\n    },\r\n    \"contracts/warper/preset-factory/IWarperPresetFactory.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\n\\ninterface IWarperPresetFactory is IContractEntity {\\n    /**\\n     * @dev Thrown when the implementation does not support the IWarperPreset interface\\n     */\\n    error InvalidWarperPresetInterface();\\n\\n    /**\\n     * @dev Thrown when the warper preset id is already present in the storage.\\n     */\\n    error DuplicateWarperPresetId(bytes32 presetId);\\n\\n    /**\\n     * @dev Thrown when the warper preset has been disabled, when it was expected for it to be enabled.\\n     */\\n    error DisabledWarperPreset(bytes32 presetId);\\n\\n    /**\\n     * @dev Thrown when the warper preset has been enabled, when it was expected for it to be disabled.\\n     */\\n    error EnabledWarperPreset(bytes32 presetId);\\n\\n    /**\\n     * @dev Thrown when it was expected for the warper preset to be registeredr.\\n     */\\n    error WarperPresetNotRegistered(bytes32 presetId);\\n\\n    /**\\n     * @dev Thrown when the provided preset initialization data is empty.\\n     */\\n    error EmptyPresetData();\\n\\n    struct WarperPreset {\\n        bytes32 id;\\n        address implementation;\\n        bool enabled;\\n    }\\n\\n    /**\\n     * @dev Emitted when new warper preset is added.\\n     */\\n    event WarperPresetAdded(bytes32 indexed presetId, address indexed implementation);\\n\\n    /**\\n     * @dev Emitted when a warper preset is disabled.\\n     */\\n    event WarperPresetDisabled(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is enabled.\\n     */\\n    event WarperPresetEnabled(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is enabled.\\n     */\\n    event WarperPresetRemoved(bytes32 indexed presetId);\\n\\n    /**\\n     * @dev Emitted when a warper preset is deployed.\\n     */\\n    event WarperPresetDeployed(bytes32 indexed presetId, address indexed warper);\\n\\n    /**\\n     * @dev Stores the association between `presetId` and `implementation` address.\\n     * NOTE: Warper `implementation` must be deployed beforehand.\\n     * @param presetId Warper preset id.\\n     * @param implementation Warper implementation address.\\n     */\\n    function addPreset(bytes32 presetId, address implementation) external;\\n\\n    /**\\n     * @dev Removes the association between `presetId` and its implementation.\\n     * @param presetId Warper preset id.\\n     */\\n    function removePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Enables warper preset, which makes it deployable.\\n     * @param presetId Warper preset id.\\n     */\\n    function enablePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Disable warper preset, which makes non-deployable.\\n     * @param presetId Warper preset id.\\n     */\\n    function disablePreset(bytes32 presetId) external;\\n\\n    /**\\n     * @dev Deploys a new warper from the preset identified by `presetId`.\\n     * @param presetId Warper preset id.\\n     * @param initData Warper initialization payload.\\n     * @return Deployed warper address.\\n     */\\n    function deployPreset(bytes32 presetId, bytes calldata initData) external returns (address);\\n\\n    /**\\n     * @dev Checks whether warper preset is enabled and available for deployment.\\n     * @param presetId Warper preset id.\\n     */\\n    function presetEnabled(bytes32 presetId) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the list of all registered warper presets.\\n     */\\n    function presets() external view returns (WarperPreset[] memory);\\n\\n    /**\\n     * @dev Returns the warper preset details.\\n     * @param presetId Warper preset id.\\n     */\\n    function preset(bytes32 presetId) external view returns (WarperPreset memory);\\n}\\n\"\r\n    },\r\n    \"contracts/warper/IWarper.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// solhint-disable private-vars-leading-underscore\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\n\\ninterface IWarper is IERC165 {\\n    /**\\n     * @dev Returns the original asset address.\\n     */\\n    function __original() external view returns (address);\\n\\n    /**\\n     * @dev Returns the Metahub address.\\n     */\\n    function __metahub() external view returns (address);\\n\\n    /**\\n     * @dev Returns the warper asset class ID.\\n     */\\n    function __assetClass() external view returns (bytes4);\\n\\n    /**\\n     * @dev Validates if a warper supports multiple interfaces at once.\\n     * @return an array of `bool` flags in order as the `interfaceIds` were passed.\\n     */\\n    function __supportedInterfaces(bytes4[] memory interfaceIds) external view returns (bool[] memory);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/acl/delegated/IDelegatedAccessControlEnumerable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IDelegatedAccessControl.sol\\\";\\n\\n// solhint-disable max-line-length\\ninterface IDelegatedAccessControlEnumerable is IDelegatedAccessControl {\\n    /**\\n     * @dev Returns one of the accounts that have `role`. `index` must be a\\n     * value between 0 and {getRoleMemberCount}, non-inclusive.\\n     *\\n     * Role bearers are not sorted in any particular way, and their ordering may\\n     * change at any point.\\n     *\\n     * WARNING: When using {getRoleMember} and {getRoleMemberCount}, make sure\\n     * you perform all queries on the same block. See the following\\n     * https://forum.openzeppelin.com/t/iterating-over-elements-on-enumerableset-in-openzeppelin-contracts/2296[forum post]\\n     * for more information.\\n     */\\n    function getRoleMember(\\n        address delegate,\\n        string calldata role,\\n        uint256 index\\n    ) external view returns (address);\\n\\n    /**\\n     * @dev Returns the number of accounts that have `role`. Can be used\\n     * together with {getRoleMember} to enumerate all bearers of a role.\\n     */\\n    function getRoleMemberCount(address delegate, string calldata role) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns list of delegates where account has any role\\n     */\\n    function getDelegates(\\n        address account,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (address[] memory delegates, uint256 total);\\n\\n    /**\\n     * @dev Returns list of roles for `account` at `delegate`\\n     */\\n    function getDelegateRoles(\\n        address account,\\n        address delegate,\\n        uint256 offset,\\n        uint256 limit\\n    ) external view returns (string[] memory roles, uint256 total);\\n}\\n\"\r\n    },\r\n    \"contracts/listing/listing-configurator/IListingConfiguratorController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"../listing-terms-registry/IListingTermsRegistry.sol\\\";\\nimport \\\"../../asset/Assets.sol\\\";\\nimport \\\"../Listings.sol\\\";\\nimport \\\"../../renting/Rentings.sol\\\";\\n\\ninterface IListingConfiguratorController is IERC165 {\\n    error ListingTermsNotFound(IListingTermsRegistry.ListingTerms listingTerms);\\n\\n    function validateListing(\\n        Assets.Asset[] calldata assets,\\n        Listings.Params calldata params,\\n        uint32 maxLockPeriod,\\n        bool immediatePayout\\n    ) external view;\\n\\n    function validateRenting(\\n        Rentings.Params calldata params,\\n        Listings.Listing calldata listing,\\n        uint256 universeId\\n    ) external view;\\n\\n    function getERC20RewardTarget(Listings.Listing calldata listing) external view returns (address);\\n}\\n\"\r\n    },\r\n    \"contracts/acl/delegated/IDelegatedAccessControl.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\ninterface IDelegatedAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DELEGATED_ADMIN` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(\\n        address indexed delegate,\\n        string indexed role,\\n        string previousAdminRole,\\n        string indexed newAdminRole\\n    );\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {DelegatedAccessControl-_setupRole}.\\n     */\\n    event RoleGranted(address indexed delegate, string indexed role, address indexed account, address sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(address indexed delegate, string indexed role, address indexed account, address sender);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(\\n        address delegate,\\n        string calldata role,\\n        address account\\n    ) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(\\n        address delegate,\\n        string calldata role,\\n        address account\\n    ) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(\\n        address delegate,\\n        string calldata role,\\n        address account\\n    ) external;\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(\\n        address delegate,\\n        string calldata role,\\n        address account\\n    ) external view returns (bool);\\n\\n    /**\\n     * @notice revert if the `account` does not have the specified role.\\n     * @param delegate delegate to check\\n     * @param role the role specifier.\\n     * @param account the address to check the role for.\\n     */\\n    function checkRole(\\n        address delegate,\\n        string calldata role,\\n        address account\\n    ) external view;\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(address delegate, string calldata role) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"contracts/tax/tax-strategies/TaxStrategies.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"../tax-terms-registry/ITaxTermsRegistry.sol\\\";\\n\\nlibrary TaxStrategies {\\n    bytes4 public constant FIXED_RATE_TAX = bytes4(keccak256(\\\"FIXED_RATE_TAX\\\"));\\n    bytes4 public constant FIXED_RATE_TAX_WITH_REWARD = bytes4(keccak256(\\\"FIXED_RATE_TAX_WITH_REWARD\\\"));\\n\\n    /**\\n     * @dev Thrown when the listing tax strategy ID does not match the required one.\\n     * @param provided Provided taxation strategy ID.\\n     * @param required Required taxation strategy ID.\\n     */\\n    error TaxStrategyMismatch(bytes4 provided, bytes4 required);\\n\\n    /**\\n     * @dev Modifier to check strategy compatibility.\\n     */\\n    modifier compatibleStrategy(bytes4 checkedStrategyId, bytes4 expectedStrategyId) {\\n        if (checkedStrategyId != expectedStrategyId) revert TaxStrategyMismatch(checkedStrategyId, expectedStrategyId);\\n        _;\\n    }\\n\\n    function getSupportedTaxStrategyIDs() internal pure returns (bytes4[] memory supportedTaxStrategyIDs) {\\n        bytes4[] memory supportedTaxStrategies = new bytes4[](2);\\n        supportedTaxStrategies[0] = FIXED_RATE_TAX;\\n        supportedTaxStrategies[1] = FIXED_RATE_TAX_WITH_REWARD;\\n        return supportedTaxStrategies;\\n    }\\n\\n    function isValidTaxStrategy(bytes4 taxStrategyId) internal pure returns (bool) {\\n        return taxStrategyId == FIXED_RATE_TAX || taxStrategyId == FIXED_RATE_TAX_WITH_REWARD;\\n    }\\n\\n    function decodeFixedRateTaxStrategyParams(ITaxTermsRegistry.TaxTerms memory terms)\\n        internal\\n        pure\\n        compatibleStrategy(terms.strategyId, FIXED_RATE_TAX)\\n        returns (uint16 baseTaxRate)\\n    {\\n        return abi.decode(terms.strategyData, (uint16));\\n    }\\n\\n    function decodeFixedRateWithRewardTaxStrategyParams(ITaxTermsRegistry.TaxTerms memory terms)\\n        internal\\n        pure\\n        compatibleStrategy(terms.strategyId, FIXED_RATE_TAX_WITH_REWARD)\\n        returns (uint16 baseTaxRate, uint16 rewardTaxRate)\\n    {\\n        return abi.decode(terms.strategyData, (uint16, uint16));\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/tax/tax-strategies/ITaxController.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/interfaces/IERC165.sol\\\";\\nimport \\\"../../contract-registry/IContractEntity.sol\\\";\\nimport \\\"../tax-terms-registry/ITaxTermsRegistry.sol\\\";\\nimport \\\"../../renting/Rentings.sol\\\";\\n\\ninterface ITaxController is IERC165, IContractEntity {\\n    /**\\n     * @dev Calculates rental tax based on renting params and implemented taxation strategy.\\n     * @param taxTermsParams Listing tax strategy override params.\\n     * @param rentingParams Renting params.\\n     * @param taxableAmount Total taxable amount.\\n     * @return universeBaseTax Universe rental tax (taxableAmount * universeBaseTax / 100%).\\n     * @return protocolBaseTax Protocol rental tax (taxableAmount * protocolBaseTax / 100%).\\n     * @return universeTaxTerms Universe tax terms.\\n     * @return protocolTaxTerms Protocol tax terms.\\n     */\\n    function calculateRentalTax(\\n        ITaxTermsRegistry.Params calldata taxTermsParams,\\n        Rentings.Params calldata rentingParams,\\n        uint256 taxableAmount\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 universeBaseTax,\\n            uint256 protocolBaseTax,\\n            ITaxTermsRegistry.TaxTerms memory universeTaxTerms,\\n            ITaxTermsRegistry.TaxTerms memory protocolTaxTerms\\n        );\\n\\n    /**\\n     * @dev Returns implemented listing tax strategy ID.\\n     * @return Taxation strategy ID.\\n     */\\n    function strategyId() external pure returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/introspection/ERC165.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n    /**\\n     * @dev See {IERC165-supportsInterface}.\\n     */\\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n        return interfaceId == type(IERC165).interfaceId;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": true\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"metahub\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerIsNotLister\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"declaredLister\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"delegatedLitingSigner\",\"type\":\"address\"}],\"name\":\"DeclaredListerIsDifferentFromDelegatedListingSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidContractEntityInterface\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ListingTermsAreInvalid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collection\",\"type\":\"address\"}],\"name\":\"UniverseDoesNotSupportAsset\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DOMAIN_SEPARATOR\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"contractKey\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"class\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Assets.AssetId\",\"name\":\"id\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Assets.Asset[]\",\"name\":\"assets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"configurator\",\"type\":\"address\"}],\"internalType\":\"struct Listings.Params\",\"name\":\"params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"strategyId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"strategyData\",\"type\":\"bytes\"}],\"internalType\":\"struct IListingTermsRegistry.ListingTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"maxLockPeriod\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"immediatePayout\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"}],\"name\":\"createListingWithTerms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTermsId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"class\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"internalType\":\"struct Assets.AssetId\",\"name\":\"id\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"internalType\":\"struct Assets.Asset[]\",\"name\":\"assets\",\"type\":\"tuple[]\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"configurator\",\"type\":\"address\"}],\"internalType\":\"struct Listings.Params\",\"name\":\"params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"bytes4\",\"name\":\"strategyId\",\"type\":\"bytes4\"},{\"internalType\":\"bytes\",\"name\":\"strategyData\",\"type\":\"bytes\"}],\"internalType\":\"struct IListingTermsRegistry.ListingTerms\",\"name\":\"terms\",\"type\":\"tuple\"},{\"internalType\":\"uint32\",\"name\":\"maxLockPeriod\",\"type\":\"uint32\"},{\"internalType\":\"bool\",\"name\":\"immediatePayout\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"universeId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"delegatedListingSignature\",\"type\":\"bytes\"}],\"name\":\"delegatedCreateListingWithTerms\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"listingId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"listingTermsId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getChainId\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lister\",\"type\":\"address\"}],\"name\":\"getDelegatedListingCurrentNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "ListingWizardV1", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000a41b94695379219724bfe4f9a065d4e51650bf57", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}