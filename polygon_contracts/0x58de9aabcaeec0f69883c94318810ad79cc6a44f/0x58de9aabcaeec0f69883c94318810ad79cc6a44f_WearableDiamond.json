{"SourceCode": "/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n/// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.1;\r\n\r\nlibrary LibMeta {\r\n    bytes32 internal constant EIP712_DOMAIN_TYPEHASH =\r\n        keccak256(bytes(\"EIP712Domain(string name,string version,uint256 salt,address verifyingContract)\"));\r\n\r\n    function domainSeparator(string memory name, string memory version) internal view returns (bytes32 domainSeparator_) {\r\n        domainSeparator_ = keccak256(\r\n            abi.encode(EIP712_DOMAIN_TYPEHASH, keccak256(bytes(name)), keccak256(bytes(version)), getChainID(), address(this))\r\n        );\r\n    }\r\n\r\n    function getChainID() internal view returns (uint256 id) {\r\n        assembly {\r\n            id := chainid()\r\n        }\r\n    }\r\n\r\n    function msgSender() internal view returns (address sender_) {\r\n        if (msg.sender == address(this)) {\r\n            bytes memory array = msg.data;\r\n            uint256 index = msg.data.length;\r\n            assembly {\r\n                // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\r\n                sender_ := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\r\n            }\r\n        } else {\r\n            sender_ = msg.sender;\r\n        }\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\ninterface IERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceId The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n/******************************************************************************/\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {Add, Replace, Remove}\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n////import {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\r\n////import {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\r\n////import {IERC165} from \"../interfaces/IERC165.sol\";\r\n////import {IERC173} from \"../interfaces/IERC173.sol\";\r\n////import {LibMeta} from \"./LibMeta.sol\";\r\n\r\nlibrary LibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n\r\n    struct FacetAddressAndPosition {\r\n        address facetAddress;\r\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\r\n    }\r\n\r\n    struct FacetFunctionSelectors {\r\n        bytes4[] functionSelectors;\r\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\r\n    }\r\n\r\n    struct DiamondStorage {\r\n        // maps function selector to the facet address and\r\n        // the position of the selector in the facetFunctionSelectors.selectors array\r\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\r\n        // maps facet addresses to function selectors\r\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\r\n        // facet addresses\r\n        address[] facetAddresses;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(LibMeta.msgSender() == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    function addDiamondFunctions(\r\n        address _diamondCutFacet,\r\n        address _diamondLoupeFacet,\r\n        address _ownershipFacet\r\n    ) internal {\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);\r\n        bytes4[] memory functionSelectors = new bytes4[](1);\r\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\r\n        cut[0] = IDiamondCut.FacetCut({facetAddress: _diamondCutFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors});\r\n        functionSelectors = new bytes4[](5);\r\n        functionSelectors[0] = IDiamondLoupe.facets.selector;\r\n        functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\r\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\r\n        functionSelectors[3] = IDiamondLoupe.facetAddress.selector;\r\n        functionSelectors[4] = IERC165.supportsInterface.selector;\r\n        cut[1] = IDiamondCut.FacetCut({\r\n            facetAddress: _diamondLoupeFacet,\r\n            action: IDiamondCut.FacetCutAction.Add,\r\n            functionSelectors: functionSelectors\r\n        });\r\n        functionSelectors = new bytes4[](2);\r\n        functionSelectors[0] = IERC173.transferOwnership.selector;\r\n        functionSelectors[1] = IERC173.owner.selector;\r\n        cut[2] = IDiamondCut.FacetCut({facetAddress: _ownershipFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors});\r\n        diamondCut(cut, address(0), \"\");\r\n    }\r\n\r\n    // Internal function version of diamondCut\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\r\n            if (action == IDiamondCut.FacetCutAction.Add) {\r\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\r\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\r\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else {\r\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n            }\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        // uint16 selectorCount = uint16(diamondStorage().selectors.length);\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\r\n        uint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\r\n            ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\r\n            ds.facetAddresses.push(_facetAddress);\r\n        }\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\r\n            ds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\r\n            ds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\r\n        uint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\r\n            ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\r\n            ds.facetAddresses.push(_facetAddress);\r\n        }\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n            removeFunction(oldFacetAddress, selector);\r\n            // add function\r\n            ds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\r\n            ds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        // if function does not exist then do nothing and return\r\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            removeFunction(oldFacetAddress, selector);\r\n        }\r\n    }\r\n\r\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n        // an immutable function is a function defined directly in a diamond\r\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n        // replace selector with last selector, then delete last selector\r\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\r\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\r\n        // if not the same then replace _selector with lastSelector\r\n        if (selectorPosition != lastSelectorPosition) {\r\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\r\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\r\n        }\r\n        // delete the last selector\r\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\r\n        delete ds.selectorToFacetAndPosition[_selector];\r\n\r\n        // if no more selectors for facet address then delete the facet address\r\n        if (lastSelectorPosition == 0) {\r\n            // replace facet address with last facet address and delete last facet address\r\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\r\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\r\n            if (facetAddressPosition != lastFacetAddressPosition) {\r\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\r\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\r\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\r\n            }\r\n            ds.facetAddresses.pop();\r\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\r\n        }\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (success == false) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize != 0, _errorMessage);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n////import {LibDiamond} from \"../libraries/LibDiamond.sol\";\r\n////import {IERC173} from \"../interfaces/IERC173.sol\";\r\n\r\ncontract OwnershipFacet is IERC173 {\r\n    function transferOwnership(address _newOwner) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.setContractOwner(_newOwner);\r\n    }\r\n\r\n    function owner() external view override returns (address owner_) {\r\n        owner_ = LibDiamond.contractOwner();\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n////import {LibDiamond} from \"../libraries/LibDiamond.sol\";\r\n////import {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\r\n////import {IERC165} from \"../interfaces/IERC165.sol\";\r\n\r\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n    //\r\n    // struct Facet {\r\n    //     address facetAddress;\r\n    //     bytes4[] functionSelectors;\r\n    // }\r\n\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view override returns (Facet[] memory facets_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        uint256 numFacets = ds.facetAddresses.length;\r\n        facets_ = new Facet[](numFacets);\r\n        for (uint256 i; i < numFacets; i++) {\r\n            address facetAddress_ = ds.facetAddresses[i];\r\n            facets_[i].facetAddress = facetAddress_;\r\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors provided by a facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view override returns (bytes4[] memory facetFunctionSelectors_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddresses_ = ds.facetAddresses;\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\r\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\r\n        return ds.supportedInterfaces[_interfaceId];\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n////import {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\r\n////import {LibDiamond} from \"../libraries/LibDiamond.sol\";\r\n\r\ncontract DiamondCutFacet is IDiamondCut {\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external override {\r\n        LibDiamond.enforceIsContractOwner();\r\n        LibDiamond.diamondCut(_diamondCut, _init, _calldata);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n            \r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n/******************************************************************************\\\r\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\r\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\r\n/******************************************************************************/\r\n\r\n////import {IDiamondCut} from \"../../../shared/interfaces/IDiamondCut.sol\";\r\n////import {IDiamondLoupe} from \"../../../shared/interfaces/IDiamondLoupe.sol\";\r\n////import {IERC165} from \"../../../shared/interfaces/IERC165.sol\";\r\n////import {IERC173} from \"../../../shared/interfaces/IERC173.sol\";\r\n////import {LibMeta} from \"../../../shared/libraries/LibMeta.sol\";\r\n\r\nlibrary WearableLibDiamond {\r\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\r\n    address constant AAVEGOTCHI_DIAMOND = 0x86935F11C86623deC8a25696E1C19a8659CbF95d;\r\n\r\n    struct FacetAddressAndPosition {\r\n        address facetAddress;\r\n        uint16 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\r\n    }\r\n\r\n    struct FacetFunctionSelectors {\r\n        bytes4[] functionSelectors;\r\n        uint16 facetAddressPosition; // position of facetAddress in facetAddresses array\r\n    }\r\n\r\n    struct DiamondStorage {\r\n        // maps function selector to the facet address and\r\n        // the position of the selector in the facetFunctionSelectors.selectors array\r\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\r\n        // maps facet addresses to function selectors\r\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\r\n        // facet addresses\r\n        address[] facetAddresses;\r\n        // Used to query if a contract implements an interface.\r\n        // Used to implement ERC-165.\r\n        mapping(bytes4 => bool) supportedInterfaces;\r\n        // owner of the contract\r\n        address contractOwner;\r\n        //aavegotchi master diamond address\r\n        address aavegotchiDiamond;\r\n    }\r\n\r\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\r\n        bytes32 position = DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        address previousOwner = ds.contractOwner;\r\n        ds.contractOwner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    function contractOwner() internal view returns (address contractOwner_) {\r\n        contractOwner_ = diamondStorage().contractOwner;\r\n    }\r\n\r\n    function enforceIsContractOwner() internal view {\r\n        require(LibMeta.msgSender() == diamondStorage().contractOwner, \"LibDiamond: Must be contract owner\");\r\n    }\r\n\r\n    function enforceIsDiamond() internal view {\r\n        require(msg.sender == AAVEGOTCHI_DIAMOND, \"LibDiamond: Caller must be Aavegotchi Diamond\");\r\n    }\r\n\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n\r\n    function addDiamondFunctions(\r\n        address _diamondCutFacet,\r\n        address _diamondLoupeFacet,\r\n        address _ownershipFacet\r\n    ) internal {\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](3);\r\n        bytes4[] memory functionSelectors = new bytes4[](1);\r\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\r\n        cut[0] = IDiamondCut.FacetCut({facetAddress: _diamondCutFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors});\r\n        functionSelectors = new bytes4[](5);\r\n        functionSelectors[0] = IDiamondLoupe.facets.selector;\r\n        functionSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\r\n        functionSelectors[2] = IDiamondLoupe.facetAddresses.selector;\r\n        functionSelectors[3] = IDiamondLoupe.facetAddress.selector;\r\n        functionSelectors[4] = IERC165.supportsInterface.selector;\r\n        cut[1] = IDiamondCut.FacetCut({\r\n            facetAddress: _diamondLoupeFacet,\r\n            action: IDiamondCut.FacetCutAction.Add,\r\n            functionSelectors: functionSelectors\r\n        });\r\n        functionSelectors = new bytes4[](2);\r\n        functionSelectors[0] = IERC173.transferOwnership.selector;\r\n        functionSelectors[1] = IERC173.owner.selector;\r\n        cut[2] = IDiamondCut.FacetCut({facetAddress: _ownershipFacet, action: IDiamondCut.FacetCutAction.Add, functionSelectors: functionSelectors});\r\n        diamondCut(cut, address(0), \"\");\r\n    }\r\n\r\n    // Internal function version of diamondCut\r\n    function diamondCut(\r\n        IDiamondCut.FacetCut[] memory _diamondCut,\r\n        address _init,\r\n        bytes memory _calldata\r\n    ) internal {\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\r\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\r\n            if (action == IDiamondCut.FacetCutAction.Add) {\r\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\r\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\r\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\r\n            } else {\r\n                revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n            }\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        // uint16 selectorCount = uint16(diamondStorage().selectors.length);\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\r\n        uint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\r\n            ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\r\n            ds.facetAddresses.push(_facetAddress);\r\n        }\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\r\n            ds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\r\n            ds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Add facet can't be address(0)\");\r\n        uint16 selectorPosition = uint16(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\r\n        // add new facet address if it does not exist\r\n        if (selectorPosition == 0) {\r\n            enforceHasContractCode(_facetAddress, \"LibDiamondCut: New facet has no code\");\r\n            ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = uint16(ds.facetAddresses.length);\r\n            ds.facetAddresses.push(_facetAddress);\r\n        }\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            require(oldFacetAddress != _facetAddress, \"LibDiamondCut: Can't replace function with same function\");\r\n            removeFunction(oldFacetAddress, selector);\r\n            // add function\r\n            ds.selectorToFacetAndPosition[selector].functionSelectorPosition = selectorPosition;\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(selector);\r\n            ds.selectorToFacetAndPosition[selector].facetAddress = _facetAddress;\r\n            selectorPosition++;\r\n        }\r\n    }\r\n\r\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\r\n        require(_functionSelectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        DiamondStorage storage ds = diamondStorage();\r\n        // if function does not exist then do nothing and return\r\n        require(_facetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\r\n            bytes4 selector = _functionSelectors[selectorIndex];\r\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\r\n            removeFunction(oldFacetAddress, selector);\r\n        }\r\n    }\r\n\r\n    function removeFunction(address _facetAddress, bytes4 _selector) internal {\r\n        DiamondStorage storage ds = diamondStorage();\r\n        require(_facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\r\n        // an immutable function is a function defined directly in a diamond\r\n        require(_facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function\");\r\n        // replace selector with last selector, then delete last selector\r\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\r\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\r\n        // if not the same then replace _selector with lastSelector\r\n        if (selectorPosition != lastSelectorPosition) {\r\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\r\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\r\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint16(selectorPosition);\r\n        }\r\n        // delete the last selector\r\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\r\n        delete ds.selectorToFacetAndPosition[_selector];\r\n\r\n        // if no more selectors for facet address then delete the facet address\r\n        if (lastSelectorPosition == 0) {\r\n            // replace facet address with last facet address and delete last facet address\r\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\r\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\r\n            if (facetAddressPosition != lastFacetAddressPosition) {\r\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\r\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\r\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = uint16(facetAddressPosition);\r\n            }\r\n            ds.facetAddresses.pop();\r\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\r\n        }\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but_calldata is not empty\");\r\n        } else {\r\n            require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\r\n            if (_init != address(this)) {\r\n                enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n            }\r\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n            if (success == false) {\r\n                if (error.length > 0) {\r\n                    // bubble up the error\r\n                    revert(string(error));\r\n                } else {\r\n                    revert(\"LibDiamondCut: _init function reverted\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize != 0, _errorMessage);\r\n    }\r\n}\r\n\r\n\r\n/** \r\n *  SourceUnit: /home/null/Desktop/aavegotchi-contracts/contracts/Aavegotchi/WearableDiamond/WearableDiamond.sol\r\n*/\r\n\r\n////// SPDX-License-Identifier-FLATTEN-SUPPRESS-WARNING: MIT\r\npragma solidity 0.8.1;\r\n\r\n/******************************************************************************\\\r\n* Authors: Nick Mudge (https://twitter.com/mudgen)\r\n*\r\n* Implementation of a diamond.\r\n/******************************************************************************/\r\n\r\n////import {WearableLibDiamond} from \"./libraries/WearableLibDiamond.sol\";\r\n////import {DiamondCutFacet} from \"../../shared/facets/DiamondCutFacet.sol\";\r\n////import {DiamondLoupeFacet} from \"../../shared/facets/DiamondLoupeFacet.sol\";\r\n////import {OwnershipFacet} from \"../../shared/facets/OwnershipFacet.sol\";\r\n\r\ncontract WearableDiamond {\r\n    constructor(\r\n        address _contractOwner,\r\n        address _diamondCutFacet,\r\n        address _diaomondLoupeFacet,\r\n        address _ownershipFacet\r\n    ) {\r\n        WearableLibDiamond.setContractOwner(_contractOwner);\r\n        WearableLibDiamond.addDiamondFunctions(_diamondCutFacet, _diaomondLoupeFacet, _ownershipFacet);\r\n        WearableLibDiamond.DiamondStorage storage ds = WearableLibDiamond.diamondStorage();\r\n        ds.supportedInterfaces[0xd9b67a26] = true; //erc1155\r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        WearableLibDiamond.DiamondStorage storage ds;\r\n        bytes32 position = WearableLibDiamond.DIAMOND_STORAGE_POSITION;\r\n        assembly {\r\n            ds.slot := position\r\n        }\r\n        address facet = ds.selectorToFacetAndPosition[msg.sig].facetAddress;\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_contractOwner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diaomondLoupeFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_ownershipFacet\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"}]", "ContractName": "WearableDiamond", "CompilerVersion": "v0.8.1+commit.df193b15", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000008d46fd7160940d89da026d59b2e819208e714e820000000000000000000000004f908fa47f10bc2254dae7c74d8b797c1749a8a600000000000000000000000058f64b56b1e15d8c932c51287d814edaa8d6feb9000000000000000000000000ae7df9f59fec446903c64f21a76d039bc81712ef", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "1", "Implementation": "0x4f908fa47f10bc2254dae7c74d8b797c1749a8a6", "SwarmSource": "ipfs://fd8ac4033fb49697dfb475e058cd7d7702ac0a653d6ea63668d75985ee3266ed"}