{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/cygnus-periphery/CygnusAltair.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  CygnusAltair.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\n\\n/*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  \\n    .         \ud83d\udef0\ufe0f    .            .               .      \ud83d\udef0\ufe0f     .           .                .           .\\n           \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588           ---======*.                                                .           \u2800\\n          \u2588\u2588\u2588\u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588                                               \ud83d\udce1                \ud83c\udf14      \ud83d\udef0\ufe0f                   . \\n         \u2588\u2588\u2588     \u2591\u2591\u2591  \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588   \u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588  \u2588\u2588\u2588\u2588\u2588        \u2800\\n        \u2591\u2588\u2588\u2588         \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588\u2591\u2591      .     .\u2800           .          \\n        \u2591\u2588\u2588\u2588          \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588       \u2800\\n        \u2591\u2591\u2588\u2588\u2588     \u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2588\u2588\u2588              .             .\u2800\ud83d\udef0\ufe0f\\n         \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588 \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588     .----===*  \u2800\\n          \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588  \u2591\u2591\u2591\u2591\u2591\u2588\u2588\u2588\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591   \u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 \u2591\u2591\u2591\u2591\u2591\u2591            .                            .\u2800\\n                       \u2588\u2588\u2588 \u2591\u2588\u2588\u2588  \u2588\u2588\u2588 \u2591\u2588\u2588\u2588                .                 .                 .  \u2800\\n     \ud83d\udef0\ufe0f  .             \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588  \u2591\u2591\u2588\u2588\u2588\u2588\u2588\u2588                 \ud83d\udef0\ufe0f                             .                 .           \\n                      \u2591\u2591\u2591\u2591\u2591\u2591    \u2591\u2591\u2591\u2591\u2591\u2591      -------=========*             \ud83d\udef0\ufe0f         .                     \u2800\\n           .                            .\ud83d\udef0\ufe0f       .          .            .                         \ud83d\udef0\ufe0f .             .\u2800\\n    \\n        CYGNUS PERIPHERY ROUTER - `Altair`                                                           \\n    \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\npragma solidity >=0.8.17;\\n\\n// Dependencies\\nimport {ICygnusAltair} from \\\"./interfaces/ICygnusAltair.sol\\\";\\n\\n// Libraries\\nimport {SafeTransferLib} from \\\"./libraries/SafeTransferLib.sol\\\";\\nimport {FixedPointMathLib} from \\\"./libraries/FixedPointMathLib.sol\\\";\\n\\n// Interfaces\\nimport {IWrappedNative} from \\\"./interfaces/IWrappedNative.sol\\\";\\nimport {ICygnusAltairX} from \\\"./interfaces/ICygnusAltairX.sol\\\";\\n\\n// Cygnus Core\\nimport {IERC20} from \\\"./interfaces/core/IERC20.sol\\\";\\nimport {IHangar18} from \\\"./interfaces/core/IHangar18.sol\\\";\\nimport {ICygnusBorrow} from \\\"./interfaces/core/ICygnusBorrow.sol\\\";\\nimport {ICygnusTerminal} from \\\"./interfaces/core/ICygnusTerminal.sol\\\";\\nimport {ICygnusCollateral} from \\\"./interfaces/core/ICygnusCollateral.sol\\\";\\n\\n// Permit2\\nimport {IAllowanceTransfer} from \\\"./interfaces/core/IAllowanceTransfer.sol\\\";\\nimport {ISignatureTransfer} from \\\"./interfaces/core/ISignatureTransfer.sol\\\";\\n\\n/**\\n *  @title  CygnusAltair Periphery contract to interact with Cygnus Core contracts\\n *  @author CygnusDAO\\n *  @notice The base periphery contract that is used to interact with Cygnus Core contracts. Aside from\\n *          depositing and withdrawing from the core contracts, users should always use this router\\n *          (or a similar implementation) to interact wtih the core contracts. It is integrated with Uniswap's\\n *          Permit2 and allows users to interact with Cygnus Core without ever giving any allowance ot this\\n *          router (can borrow, repay, leverage, deleverage and liquidate using the Permit functions).\\n *\\n *          Leverage   = Borrow USDC from the borrowable and use it to mint more collateral (Liquidity Tokens)\\n *          Deleverage = Redeem collateral (Liquidity Tokens) and sell the assets for USDC to repay the loan\\n *                       or just to convert all your liquidity to USDC in 1 step.\\n *\\n *          As such, using a dex aggregator improves capital efficiency during swaps. This router is integrated with\\n *          the following aggregators to make sure that slippage is minimal between the borrowed USDC and the\\n *          minted LP and when converting LP back to USDC. When using the functions you should pass the ID of each.\\n *            - Paraswap                       (0)\\n *            - OneInchV5 Legacy Swap          (1)\\n *            - OneInchV5 Optimized Swap       (2)\\n *            - 0xProject Swap API             (3)\\n *            - OpenOcean Legacy Swap          (4)\\n *            - OpenOcean Optimized Swap       (5)\\n *            - OKX Aggregation Router         (6)\\n *            - UniswapV3 (*)                  (7)\\n *\\n *          (*) In the unlikely case where ALL aggregators start failing at the same time (APIs are down, etc.),\\n *          users can perform EMERGENCY deleverage or liquidations with UniswapV3's router. The end result would\\n *          likely be suffering higher slippage and liquidators receiving less liquidation profit, but this way users\\n *          are always guaranteed to be able to adjust their positions.\\n *\\n *          During the leverage functionality the router borrows USD from the borrowable arm contract, and\\n *          then converts it to LP Tokens. Since each liquidity token requires different logic to \\\"mint\\\".,\\n *          for example, minting an LP from UniswapV2 is different to minting a BPT from Balancer or UniswapV3,\\n *          the router delegates the call to an extension contract to mint the liquidity token.\\n *\\n *          During the deleverage functionality the router receives Liquidity Tokens from the collateral arm\\n *          contract, and then converts it to USDC. Again, since the process of burning or redeeming the liquidity\\n *          token requires different logic across DEXes, this contract delegates the redeem call to the extensions\\n *          in the fallback.\\n *\\n *          The admin is in charge of setting up the extension contracts and these are updatable, however this is\\n *          the only contract that users should interact with.\\n *\\n *          Functions in this contract allow for:\\n *            - Borrowing USD\\n *            - Repaying USD\\n *            - Liquidating user's with USD (pay back USD, receive CygLP + bonus liquidation reward)\\n *            - Flash liquidating a user by selling collateral to the market and receive USD\\n *            - Leveraging USD into Liquidity\\n *            - Deleveraging Liquidity into USD\\n */\\ncontract CygnusAltair is ICygnusAltair {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n          1. LIBRARIES\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @custom:library SafeTransferLib For safe transfers of Erc20 tokens\\n     */\\n    using SafeTransferLib for address;\\n\\n    /**\\n     *  @custom:library FixedPointMathLib Arithmetic library with operations for fixed-point numbers\\n     */\\n    using FixedPointMathLib for uint256;\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n          2. STORAGE\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Internal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Empty bytes to pass to contracts if needed\\n     */\\n    bytes internal constant LOCAL_BYTES = new bytes(0);\\n\\n    /**\\n     *  @notice Internal record of all Altair Extensions - Borrowable/Collateral address to extension contract implementation.\\n     */\\n    mapping(address => address) internal altairExtensions;\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Public \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Internal mapping to check if extension has been added\\n     */\\n    mapping(address => bool) public override isExtension;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address[] public override allExtensions;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    string public constant override name = \\\"Cygnus: Altair Router\\\";\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    string public constant override version = \\\"1.0.0\\\";\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address public constant override PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\\n\\n    // Aggregator addresses are not used in this contract, kept here for consistency with extensions\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address public constant override PARASWAP_AUGUSTUS_SWAPPER_V5 = 0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address public constant override ONE_INCH_ROUTER_V5 = 0x1111111254EEB25477B68fb85Ed929f73A960582;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address public constant override OxPROJECT_EXCHANGE_PROXY = 0xDef1C0ded9bec7F1a1670819833240f027b25EfF;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address public constant override OPEN_OCEAN_EXCHANGE_PROXY = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address public constant override OKX_AGGREGATION_ROUTER = 0xA748D6573acA135aF68F2635BE60CB80278bd855;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address public constant override UNISWAP_V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    IHangar18 public immutable override hangar18;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    address public immutable override usd;\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    IWrappedNative public immutable override nativeToken;\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n          3. CONSTRUCTOR\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @notice Constructs the periphery contract. Factory must be deployed on the chain first to get the addresses\\n     *          of deployers and the wrapped native token (WETH, WFTM, etc.)\\n     *  @param _hangar18 The address of the Cygnus Factory contract on this chain\\n     */\\n    constructor(IHangar18 _hangar18) {\\n        // Factory\\n        hangar18 = _hangar18;\\n\\n        // Assign the native token set at the factory\\n        nativeToken = IWrappedNative(_hangar18.nativeToken());\\n\\n        // Assign the USD address set at the factoryn\\n        usd = _hangar18.usd();\\n    }\\n\\n    /**\\n     *  @dev Fallback function is executed if none of the other functions match the function\\n     *  identifier or no data was provided with the function call.\\n     */\\n    fallback() external payable {\\n        // Get extension for the caller contract (borrowable or collateral)\\n        address altairX = altairExtensions[msg.sender];\\n\\n        /// @custom:error ExtensionDoesntExist Avoid if the extension does not exist\\n        if (altairX == address(0)) revert CygnusAltair__AltairXDoesNotExist();\\n\\n        // Delegate the call to the extension router\\n        (bool success, bytes memory data) = altairX.delegatecall(msg.data);\\n\\n        // Revert with extension reason\\n        if (!success) _extensionRevert(data);\\n\\n        // Return the return value from leverage/deleverage/flash liquidate\\n        _extensionReturn(data);\\n    }\\n\\n    /**\\n     *  @dev This function is called for plain Ether transfers, i.e. for every call with empty calldata.\\n     */\\n    receive() external payable {}\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n          4. MODIFIERS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @custom:modifier checkDeadline Reverts the transaction if the block.timestamp is after deadline\\n     */\\n    modifier checkDeadline(uint256 deadline) {\\n        _checkDeadline(deadline);\\n        _;\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n          5. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Internal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Reverts with reason if the delegate call fails\\n     */\\n    function _extensionRevert(bytes memory data) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            revert(add(data, 32), mload(data))\\n        }\\n    }\\n\\n    /**\\n     *  @notice Returns the returned data from the delegate call\\n     */\\n    function _extensionReturn(bytes memory data) internal pure {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            return(add(data, 32), mload(data))\\n        }\\n    }\\n\\n    /**\\n     *  @notice The current block timestamp\\n     */\\n    function _checkTimestamp() internal view returns (uint256) {\\n        return block.timestamp;\\n    }\\n\\n    /**\\n     *  @notice Reverts the transaction if the block.timestamp is after deadline\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     */\\n    function _checkDeadline(uint256 deadline) internal view {\\n        /// @custom:error TransactionExpired Avoid transacting past deadline\\n        if (_checkTimestamp() > deadline) revert CygnusAltair__TransactionExpired();\\n    }\\n\\n    /**\\n     *  @notice Convert shares to assets\\n     *  @param collateral Address of the CygLP\\n     *  @param shares Amount of CygLP redeemed\\n     */\\n    function _convertToAssets(address collateral, uint256 shares) internal view returns (uint256) {\\n        // CygLP Supply\\n        uint256 _totalSupply = ICygnusCollateral(collateral).totalSupply();\\n\\n        // LP assets in collateral\\n        uint256 _totalAssets = ICygnusCollateral(collateral).totalAssets();\\n\\n        // Return the amount of LPs we get by redeeming shares, rounds down\\n        return shares.fullMulDiv(_totalAssets, _totalSupply);\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function getAltairExtension(address poolToken) external view override returns (address) {\\n        // Return the router extension\\n        return altairExtensions[poolToken];\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function altairExtensionsLength() external view override returns (uint256) {\\n        // How many extensions we have added to the base router\\n        return allExtensions.length;\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function getShuttleExtension(uint256 shuttleId) external view override returns (address) {\\n        // Get the collateral or borrowable (borrowable, collateral and lp share the extension anyways)\\n        (, , , address collateral, ) = hangar18.allShuttles(shuttleId);\\n\\n        // Return extension\\n        return altairExtensions[collateral];\\n    }\\n\\n    /**\\n     *  @dev Same calculation as all vault tokens, asset = shares * balance / supply\\n     *  @dev Relies on the extension to perform the logic\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function getAssetsForShares(\\n        address lpTokenPair,\\n        uint256 shares,\\n        uint256 difference\\n    ) external view returns (address[] memory tokens, uint256[] memory amounts) {\\n        // Get the extension for this lp token pair\\n        address altairX = altairExtensions[lpTokenPair];\\n\\n        /// @custom:error ExtensionDoesntExist Avoid if the extension does not exist\\n        if (altairX == address(0)) revert CygnusAltair__AltairXDoesNotExist();\\n\\n        // The extension should implement the assets for shares function - ie. Which assets and how much we receive\\n        // by redeeming `shares` amount of a liquidity token\\n        return ICygnusAltairX(altairX).getAssetsForShares(lpTokenPair, shares, difference);\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n          6. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Internal \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Calls permit function on pool token\\n     *  @param terminal The address of the collateral or borrowable\\n     *  @param amount The permit amount\\n     *  @param deadline Permit deadline\\n     *  @param permitData Permit data to decode\\n     */\\n    function _checkPermit(address terminal, uint256 amount, uint256 deadline, bytes memory permitData) internal {\\n        // Return if no permit data\\n        if (permitData.length == 0) return;\\n\\n        // Decode permit data\\n        (uint256 _amount, uint8 v, bytes32 r, bytes32 s) = abi.decode(permitData, (uint256, uint8, bytes32, bytes32));\\n\\n        // Shh\\n        amount;\\n\\n        // Call permit on terminal token\\n        ICygnusTerminal(terminal).permit(msg.sender, address(this), _amount, deadline, v, r, s);\\n    }\\n\\n    /**\\n     *  @notice Safe internal function to repay borrowed amount\\n     *  @param borrowable The address of the Cygnus borrow arm where the borrowed amount was taken from\\n     *  @param amountMax The max amount that can be repaid\\n     *  @param borrower The address of the account that is repaying the borrowed amount\\n     */\\n    function _maxRepayAmount(address borrowable, uint256 amountMax, address borrower) internal view returns (uint256 amount) {\\n        // Get latest borrow balance of borrower with borrow indices\\n        (, uint256 borrowedAmount) = ICygnusBorrow(borrowable).getBorrowBalance(borrower);\\n\\n        // Avoid repaying more than borrowedAmount\\n        amount = amountMax < borrowedAmount ? amountMax : borrowedAmount;\\n    }\\n\\n    /**\\n     *  @notice Avoid repeating ourselves to make leverage data and stack-too-deep errors\\n     *  @param lpTokenPair The address of the LP Token\\n     *  @param collateral The address of the collateral of the lending pool\\n     *  @param borrowable The address of the borrowable of the lending pool\\n     *  @param lpAmountMin The minimum amount of LP Tokens to receive\\n     *  @param dexAggregator The dex aggregator to use for the swaps\\n     *  @param swapdata the aggregator swap data to convert USD to liquidity\\n     */\\n    function _createLeverageData(\\n        address lpTokenPair,\\n        address collateral,\\n        address borrowable,\\n        uint256 lpAmountMin,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) internal view returns (bytes memory) {\\n        // Return encoded bytes to pass to borrowbale\\n        return\\n            abi.encode(\\n                AltairLeverageCalldata({\\n                    lpTokenPair: lpTokenPair,\\n                    collateral: collateral,\\n                    borrowable: borrowable,\\n                    recipient: msg.sender,\\n                    lpAmountMin: lpAmountMin,\\n                    dexAggregator: dexAggregator,\\n                    swapdata: swapdata\\n                })\\n            );\\n    }\\n\\n    /**\\n     *  @notice Avoid repeating ourselves to make deleverage data and stack-too-deep errors\\n     *  @param lpTokenPair The address of the LP Token\\n     *  @param collateral The address of the collateral of the lending pool\\n     *  @param borrowable The address of the borrowable of the lending pool\\n     *  @param cygLPAmount The amount of CygLP we are deleveraging\\n     *  @param usdAmountMin The minimum amount of USD to receive from the deleverage\\n     *  @param dexAggregator The dex aggregator to use for the swaps\\n     *  @param swapdata the aggregator swap data to convert USD to liquidity\\n     */\\n    function _createDeleverageData(\\n        address lpTokenPair,\\n        address collateral,\\n        address borrowable,\\n        uint256 cygLPAmount,\\n        uint256 usdAmountMin,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) internal view returns (bytes memory) {\\n        // Encode redeem data\\n        return\\n            abi.encode(\\n                AltairDeleverageCalldata({\\n                    lpTokenPair: lpTokenPair,\\n                    collateral: collateral,\\n                    borrowable: borrowable,\\n                    recipient: msg.sender,\\n                    redeemTokens: cygLPAmount,\\n                    usdAmountMin: usdAmountMin,\\n                    dexAggregator: dexAggregator,\\n                    swapdata: swapdata\\n                })\\n            );\\n    }\\n\\n    /**\\n     *  @notice Flash liquidate data to pass to the borrowable contract\\n     *  @param lpTokenPair The address of the LP Token\\n     *  @param collateral The address of the collateral of the lending pool\\n     *  @param borrowable The address of the borrowable of the lending pool\\n     *  @param borrower The address of the borrower to liquidate\\n     *  @param amount The amount of USDC being repaid\\n     *  @param dexAggregator The dex aggregator to use for the swaps\\n     *  @param swapdata the aggregator swap data to convert USD to liquidity\\n     */\\n    function _createFlashLiquidateData(\\n        address lpTokenPair,\\n        address collateral,\\n        address borrowable,\\n        address borrower,\\n        uint256 amount,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) internal view returns (bytes memory) {\\n        // Encode data to bytes\\n        return\\n            abi.encode(\\n                AltairLiquidateCalldata({\\n                    lpTokenPair: lpTokenPair,\\n                    collateral: collateral,\\n                    borrowable: borrowable,\\n                    borrower: borrower,\\n                    recipient: msg.sender,\\n                    repayAmount: amount,\\n                    dexAggregator: dexAggregator,\\n                    swapdata: swapdata\\n                })\\n            );\\n    }\\n\\n    /**\\n     *  @notice Avoid stack too deep\\n     *  @param collateral The address of the CygLP\\n     *  @param user The address of the borrower\\n     */\\n    function _latestBorrowerInfo(\\n        address collateral,\\n        address user\\n    )\\n        internal\\n        view\\n        returns (\\n            uint256 cygLPBalance,\\n            uint256 principal,\\n            uint256 borrowBalance,\\n            uint256 price,\\n            uint256 rate,\\n            uint256 positionUsd,\\n            uint256 positionLp,\\n            uint256 health\\n        )\\n    {\\n        // Position info\\n        (cygLPBalance, principal, borrowBalance, price, rate, positionUsd, positionLp, health) = ICygnusCollateral(collateral)\\n            .getBorrowerPosition(user);\\n    }\\n\\n    /*  \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 External \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500  */\\n\\n    /**\\n     *  @notice Returns the borrower`s overall positions (borrows, position in usd and balance) across the whole protocol\\n     *  @notice Accrues interest\\n     */\\n    function latestBorrowerAll(address user) external returns (uint256 principal, uint256 borrowBalance, uint256 positionUsd) {\\n        // Total lending pools in Cygnus\\n        uint256 totalShuttles = hangar18.shuttlesDeployed();\\n\\n        // Loop through each pool and update borrower's position\\n        for (uint256 i = 0; i < totalShuttles; i++) {\\n            // Get borrowale and collateral for shuttle `i`\\n            (, , address borrowable, address collateral, ) = hangar18.allShuttles(i);\\n\\n            // Accrue interest in borrowable\\n            ICygnusBorrow(borrowable).sync();\\n\\n            // Get collateral position\\n            (, uint256 _principal, uint256 _borrowBalance, , , uint256 _positionUsd, , ) = ICygnusCollateral(collateral)\\n                .getBorrowerPosition(user);\\n\\n            // Increase total principal\\n            principal += _principal;\\n\\n            // Increase total borrowed balance\\n            borrowBalance += _borrowBalance;\\n\\n            // Increase the borrower`s position in USD\\n            positionUsd += _positionUsd;\\n        }\\n    }\\n\\n    /**\\n     *  @notice Returns the lenders`s overall positions (cygUsd and position in USD) across the whole protocol\\n     *  @notice Accrues interest\\n     */\\n    function latestLenderAll(address user) external returns (uint256 cygUsdBalance, uint256 positionUsd) {\\n        // Total lending pools in Cygnus\\n        uint256 totalShuttles = hangar18.shuttlesDeployed();\\n\\n        // Loop through each pool and update lender's position\\n        for (uint256 i = 0; i < totalShuttles; i++) {\\n            // Get borrowable contract for shuttle `i`\\n            (, , address borrowable, , ) = hangar18.allShuttles(i);\\n\\n            // Accrue interest\\n            ICygnusBorrow(borrowable).sync();\\n\\n            // Get lender position\\n            (uint256 _cygUsdBalance, , uint256 _positionUsd) = ICygnusBorrow(borrowable).getLenderPosition(user);\\n\\n            // Increase shares balance\\n            cygUsdBalance += _cygUsdBalance;\\n\\n            // Increase assets balance\\n            positionUsd += _positionUsd;\\n        }\\n    }\\n\\n    /**\\n     *  @notice Accrues interest\\n     */\\n    function latestLenderPosition(\\n        ICygnusBorrow borrowable,\\n        address lender\\n    ) external returns (uint256 cygUsdBalance, uint256 rate, uint256 positionUsd) {\\n        // Accrue interest and update balance\\n        borrowable.sync();\\n\\n        // Return latest position\\n        return borrowable.getLenderPosition(lender);\\n    }\\n\\n    /**\\n     *  @notice Accrues interest\\n     */\\n    function latestBorrowerPosition(\\n        ICygnusBorrow borrowable,\\n        address borrower\\n    )\\n        external\\n        returns (\\n            uint256 cygLPBalance,\\n            uint256 principal,\\n            uint256 borrowBalance,\\n            uint256 price,\\n            uint256 rate,\\n            uint256 positionUsd,\\n            uint256 positionLp,\\n            uint256 health\\n        )\\n    {\\n        // Accrue interest and update balance\\n        borrowable.sync();\\n\\n        // Get collateral contract\\n        address collateral = borrowable.collateral();\\n\\n        // Return latest info\\n        return _latestBorrowerInfo(collateral, borrower);\\n    }\\n\\n    /**\\n     *  @notice Accrues interest\\n     */\\n    function latestAccountLiquidity(ICygnusBorrow borrowable, address borrower) external returns (uint256 liquidity, uint256 shortfall) {\\n        // Accrue interest and update balance\\n        borrowable.sync();\\n\\n        // Get collateral contract\\n        address collateral = borrowable.collateral();\\n\\n        // Liquidity info\\n        (liquidity, shortfall) = ICygnusCollateral(collateral).getAccountLiquidity(borrower);\\n    }\\n\\n    /**\\n     *  @notice Accrues interest\\n     */\\n    function latestShuttleInfo(\\n        ICygnusBorrow borrowable\\n    )\\n        external\\n        returns (uint256 supplyApr, uint256 borrowApr, uint256 util, uint256 totalBorrows, uint256 totalBalance, uint256 exchangeRate)\\n    {\\n        // Accrue interest and update balance\\n        borrowable.sync();\\n\\n        // For APRs\\n        uint256 secondsPerYear = 24 * 60 * 60 * 365;\\n\\n        // The APR for lenders\\n        supplyApr = borrowable.supplyRate() * secondsPerYear;\\n\\n        // The interest rate for borrowers\\n        borrowApr = borrowable.borrowRate() * secondsPerYear;\\n\\n        // Utilization rate\\n        util = borrowable.utilizationRate();\\n\\n        // Total borrows stored in the contract\\n        totalBorrows = borrowable.totalBorrows();\\n\\n        // Available cash\\n        totalBalance = borrowable.totalBalance();\\n\\n        // The latest exchange rate\\n        exchangeRate = borrowable.exchangeRate();\\n    }\\n\\n    // Start periphery functions:\\n    //   1. Borrow - Users can borrow passing a standard permit to approve borrow allowance + borrow in 1 tx\\n    //   2. Repay - (standard permit + permit2 allowance + permit2 signature)\\n    //   3. Liquidate - (standard permit + permit2 allowance + permit2 signature)\\n    //   4. Flash Liquidate - There's no need to approve anything as we are just selling collateral to the market\\n    //   5. Leverage - Users can leverage passing a standard permit to approve borrow allowance + leverage in 1 tx\\n    //   6. Deleverage - Users can deleverage passing a standard permit to approve CygLP allowance + deleverage in 1 tx\\n\\n    //  1. BORROW \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n    /**\\n     *  @notice Borrows USDC and sends it to `recipient`\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function borrow(\\n        address borrowable,\\n        uint256 amount,\\n        address recipient,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override checkDeadline(deadline) {\\n        // Check permit on borrowable (borrow allowance)\\n        _checkPermit(borrowable, amount, deadline, permitData);\\n\\n        // Borrow amount\\n        ICygnusBorrow(borrowable).borrow(msg.sender, recipient, amount, LOCAL_BYTES);\\n    }\\n\\n    //  2. REPAY \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n    /**\\n     *  @notice Transfers USDC from sender to the borrowable and repays the debt for `borrower`\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function repay(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override checkDeadline(deadline) returns (uint256 amount) {\\n        // Ensure that the amount to repay is never more than currently owed.\\n        // Accrues interest first then gets the borrow balance\\n        amount = _maxRepayAmount(borrowable, amountMax, borrower);\\n\\n        // Check permit on USDC\\n        _checkPermit(usd, amount, deadline, permitData);\\n\\n        // Transfer USD from msg sender to borrow contract\\n        usd.safeTransferFrom(msg.sender, borrowable, amount);\\n\\n        // Call borrow to update borrower's borrow balance\\n        ICygnusBorrow(borrowable).borrow(borrower, address(0), 0, LOCAL_BYTES);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function repayPermit2Allowance(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline,\\n        IAllowanceTransfer.PermitSingle calldata _permit,\\n        bytes calldata signature\\n    ) external virtual override checkDeadline(deadline) returns (uint256 amount) {\\n        // Ensure that the amount to repay is never more than currently owed.\\n        // Accrues interest first then gets the borrow balance\\n        amount = _maxRepayAmount(borrowable, amountMax, borrower);\\n\\n        // Check for permit (else users can just approve permit2 and skip this by passing an empty\\n        // PermitSingle and an empty `_signature`)\\n        if (signature.length > 0) {\\n            // Set allowance using permit\\n            IAllowanceTransfer(PERMIT2).permit(\\n                // The owner of the tokens being approved.\\n                // We only allow the owner of the tokens to be the repayer\\n                msg.sender,\\n                // Data signed over by the owner specifying the terms of approval\\n                _permit,\\n                // The owner's signature over the permit data that was the result\\n                // of signing the EIP712 hash of `_permit`\\n                signature\\n            );\\n        }\\n\\n        // Transfer underlying to vault\\n        IAllowanceTransfer(PERMIT2).transferFrom(msg.sender, borrowable, uint160(amount), usd);\\n\\n        // Call borrow with 0 borrowAmount to update borrower's borrow balance and repay loan\\n        ICygnusBorrow(borrowable).borrow(borrower, address(0), 0, LOCAL_BYTES);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function repayPermit2Signature(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline,\\n        ISignatureTransfer.PermitTransferFrom calldata _permit,\\n        bytes calldata signature\\n    ) external virtual override checkDeadline(deadline) returns (uint256 amount) {\\n        // Ensure that the amount to repay is never more than currently owed.\\n        // Accrues interest first then gets the borrow balance\\n        amount = _maxRepayAmount(borrowable, amountMax, borrower);\\n\\n        // Signture transfer\\n        ISignatureTransfer(PERMIT2).permitTransferFrom(\\n            // The permit message.\\n            _permit,\\n            // The transfer recipient and amount.\\n            ISignatureTransfer.SignatureTransferDetails({to: borrowable, requestedAmount: amount}),\\n            // Owner of the tokens and signer of the message.\\n            msg.sender,\\n            // The packed signature that was the result of signing\\n            // the EIP712 hash of `_permit`.\\n            signature\\n        );\\n\\n        // Call borrow with 0 borrowAmount to update borrower's borrow balance and repay loan\\n        ICygnusBorrow(borrowable).borrow(borrower, address(0), 0, LOCAL_BYTES);\\n    }\\n\\n    //  3. LIQUIDATE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n    /**\\n     *  @notice Transfers USDC from sender to the borrowable, liquidating `borrower` and receiving the equivalent\\n     *          of the repaid amount + the liquidation incentinve in CygLP.\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function liquidate(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address recipient,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external virtual override checkDeadline(deadline) returns (uint256 amount, uint256 seizeTokens) {\\n        // Ensure that the amount to repay is never more than currently owed.\\n        // Accrues interest first then gets the borrow balance\\n        amount = _maxRepayAmount(borrowable, amountMax, borrower);\\n\\n        // Check permit\\n        _checkPermit(usd, amount, deadline, permitData);\\n\\n        // Transfer USD\\n        usd.safeTransferFrom(msg.sender, borrowable, amount);\\n\\n        // Liquidate\\n        seizeTokens = ICygnusBorrow(borrowable).liquidate(borrower, recipient, amount, LOCAL_BYTES);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function liquidatePermit2Allowance(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address recipient,\\n        uint256 deadline,\\n        IAllowanceTransfer.PermitSingle calldata _permit,\\n        bytes calldata signature\\n    ) external virtual override checkDeadline(deadline) returns (uint256 amount, uint256 seizeTokens) {\\n        // Ensure that the amount to repay is never more than currently owed.\\n        // Accrues interest first then gets the borrow balance\\n        amount = _maxRepayAmount(borrowable, amountMax, borrower);\\n\\n        // Check for permit (else users can just approve permit2 and skip this by passing an empty\\n        // PermitSingle and an empty `_signature`)\\n        if (signature.length > 0) {\\n            // Set allowance using permit\\n            IAllowanceTransfer(PERMIT2).permit(\\n                // The owner of the tokens being approved.\\n                // We only allow the owner of the tokens to be the liquidator\\n                msg.sender,\\n                // Data signed over by the owner specifying the terms of approval\\n                _permit,\\n                // The owner's signature over the permit data that was the result\\n                // of signing the EIP712 hash of `_permit`\\n                signature\\n            );\\n        }\\n\\n        // Transfer underlying to vault\\n        IAllowanceTransfer(PERMIT2).transferFrom(msg.sender, borrowable, uint160(amount), usd);\\n\\n        // Liquidate\\n        seizeTokens = ICygnusBorrow(borrowable).liquidate(borrower, recipient, amount, LOCAL_BYTES);\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function liquidatePermit2Signature(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address recipient,\\n        uint256 deadline,\\n        ISignatureTransfer.PermitTransferFrom calldata _permit,\\n        bytes calldata signature\\n    ) external virtual override checkDeadline(deadline) returns (uint256 amount, uint256 seizeTokens) {\\n        // Ensure that the amount to repay is never more than currently owed.\\n        // Accrues interest first then gets the borrow balance\\n        amount = _maxRepayAmount(borrowable, amountMax, borrower);\\n\\n        // Signture transfer\\n        ISignatureTransfer(PERMIT2).permitTransferFrom(\\n            // The permit message.\\n            _permit,\\n            // The transfer recipient and amount.\\n            ISignatureTransfer.SignatureTransferDetails({to: borrowable, requestedAmount: amount}),\\n            // Owner of the tokens and signer of the message.\\n            msg.sender,\\n            // The packed signature that was the result of signing\\n            // the EIP712 hash of `_permit`.\\n            signature\\n        );\\n\\n        // Liquidate\\n        seizeTokens = ICygnusBorrow(borrowable).liquidate(borrower, recipient, amount, LOCAL_BYTES);\\n    }\\n\\n    //  4. FLASH LIQUIDATE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n    /**\\n     *  @notice Sells the LP collateral to the market, repays debt and sends liquidator the liq. incentive in USDC\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function flashLiquidate(\\n        address borrowable,\\n        address collateral,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) external virtual override checkDeadline(deadline) returns (uint256 amount) {\\n        // Ensure that the amount to repay is never more than currently owed.\\n        // Accrues interest first then gets the borrow balance\\n        amount = _maxRepayAmount(borrowable, amountMax, borrower);\\n\\n        // Get LP TokenPair\\n        address lpTokenPair = ICygnusCollateral(collateral).underlying();\\n\\n        // Encode data to bytes\\n        bytes memory liquidateData = _createFlashLiquidateData(\\n            lpTokenPair,\\n            collateral,\\n            borrowable,\\n            borrower,\\n            amount,\\n            dexAggregator,\\n            swapdata\\n        );\\n\\n        // Liquidate\\n        // The liquidated CYGLP is transfered to the collateral to then call `flashRedeem` and receive LP\\n        ICygnusBorrow(borrowable).liquidate(borrower, collateral, amount, liquidateData);\\n    }\\n\\n    //  5. LEVERAGE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n    /**\\n     *  @notice Converts all USDC to LP's assets and mints LP token\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function leverage(\\n        address lpTokenPair,\\n        address collateral,\\n        address borrowable,\\n        uint256 usdAmount,\\n        uint256 lpAmountMin,\\n        uint256 deadline,\\n        bytes calldata permitData,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) external virtual override checkDeadline(deadline) returns (uint256 liquidity) {\\n        // Check permit on borrowable (borrow allowance)\\n        _checkPermit(borrowable, usdAmount, deadline, permitData);\\n\\n        // Encode data to bytes\\n        bytes memory borrowData = _createLeverageData(lpTokenPair, collateral, borrowable, lpAmountMin, dexAggregator, swapdata);\\n\\n        // Call borrow with encoded data\\n        liquidity = ICygnusBorrow(borrowable).borrow(msg.sender, address(this), usdAmount, borrowData);\\n    }\\n\\n    //  6. DELEVERAGE \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\\n\\n    /**\\n     *  @notice Burns the LP token and converts all LP's assets to USDC\\n     *  @inheritdoc ICygnusAltair\\n     */\\n    function deleverage(\\n        address lpTokenPair,\\n        address collateral,\\n        address borrowable,\\n        uint256 cygLPAmount,\\n        uint256 usdAmountMin,\\n        uint256 deadline,\\n        bytes calldata permitData,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) external virtual override checkDeadline(deadline) returns (uint256 usdAmount) {\\n        // Check permit on collateral (transfer allowance)\\n        _checkPermit(collateral, cygLPAmount, deadline, permitData);\\n\\n        // Get redeem amount, rounding down\\n        uint256 redeemAmount = _convertToAssets(collateral, cygLPAmount);\\n\\n        // Encode data to bytes\\n        bytes memory redeemData = _createDeleverageData(\\n            lpTokenPair,\\n            collateral,\\n            borrowable,\\n            cygLPAmount,\\n            usdAmountMin,\\n            dexAggregator,\\n            swapdata\\n        );\\n\\n        // Flash redeem LP Tokens\\n        usdAmount = ICygnusCollateral(collateral).flashRedeemAltair(address(this), redeemAmount, redeemData);\\n    }\\n\\n    // ADMIN\\n\\n    /**\\n     *  @notice Initializes the mapping of borrowable/collateral/lp token => extension\\n     *  @inheritdoc ICygnusAltair\\n     *  @custom:security only-admin\\n     */\\n    function setAltairExtension(uint256[] calldata shuttleIds, address extension) external override {\\n        // Get latest admin\\n        address admin = hangar18.admin();\\n\\n        /// @custom:error MsgSenderNotAdmin\\n        if (msg.sender != admin) revert CygnusAltair__MsgSenderNotAdmin();\\n\\n        // Total lending pools\\n        uint256 length = shuttleIds.length;\\n\\n        // Set extension for shuttleId[i]\\n        for (uint256 i = 0; i < length; i++) {\\n            // Get the shuttle for the shuttle ID\\n            (bool launched, , address borrowable, address collateral, ) = hangar18.allShuttles(shuttleIds[i]);\\n\\n            /// @custom:error ShuttleDoesNotExist\\n            if (!launched) revert CygnusAltair__ShuttleDoesNotExist();\\n\\n            // Add to array - Allow admin to update extension for the lending pool\\n            if (!isExtension[extension]) {\\n                // Add to array\\n                allExtensions.push(extension);\\n\\n                // Mark as true\\n                isExtension[extension] = true;\\n            }\\n\\n            // For leveraging USD\\n            altairExtensions[borrowable] = extension;\\n\\n            // For deleveraging the LP\\n            altairExtensions[collateral] = extension;\\n\\n            // For getting the assets for a a given amount of shares:\\n            //\\n            // asset received = shares_burnt * asset_balance / vault_token_supply\\n            //\\n            // Calling `getAssetsForShares(underlying, amount)` returns two arrays: `tokens` and `amounts`. The\\n            // extensions handle this logic since it differs per underlying Liquidity Token. For example, returning\\n            // assets by burning 1 LP in UniV2, or 1 BPT in a Balancer Weighted Pool, etc. Helpful when deleveraging\\n            // liquidity tokens into USDC.\\n            address lpTokenAddress = ICygnusCollateral(collateral).underlying();\\n\\n            // Store LP => Extension\\n            altairExtensions[lpTokenAddress] = extension;\\n\\n            /// @custom:event NewExtension\\n            emit NewExtension(shuttleIds[i], borrowable, collateral, lpTokenAddress, extension);\\n        }\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     *  @custom:security only-admin\\n     */\\n    function sweepTokens(IERC20[] memory tokens, address to) external override {\\n        // Get latest admin\\n        address admin = hangar18.admin();\\n\\n        /// @custom:error MsgSenderNotAdmin\\n        if (msg.sender != admin) revert CygnusAltair__MsgSenderNotAdmin();\\n\\n        // Transfer each token to admin\\n        for (uint256 i = 0; i < tokens.length; i++) {\\n            // Balance of token\\n            uint256 balance = tokens[i].balanceOf(address(this));\\n\\n            // Send to admin\\n            if (balance > 0) address(tokens[i]).safeTransfer(to, balance);\\n        }\\n    }\\n\\n    /**\\n     *  @inheritdoc ICygnusAltair\\n     *  @custom:security only-admin\\n     */\\n    function sweepNative() external override {\\n        // Get latest admin\\n        address admin = hangar18.admin();\\n\\n        /// @custom:error MsgSenderNotAdmin\\n        if (msg.sender != admin) revert CygnusAltair__MsgSenderNotAdmin();\\n\\n        // Get native balance\\n        uint256 balance = address(this).balance;\\n\\n        // Get ETH out\\n        if (balance > 0) SafeTransferLib.safeTransferETH(admin, balance);\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/IAllowanceTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.17;\\n\\n/// @title AllowanceTransfer\\n/// @notice Handles ERC20 token permissions through signature based allowance setting and ERC20 token transfers by checking allowed amounts\\n/// @dev Requires user's token approval on the Permit2 contract\\ninterface IAllowanceTransfer {\\n    /// @notice Thrown when an allowance on a token has expired.\\n    /// @param deadline The timestamp at which the allowed amount is no longer valid\\n    error AllowanceExpired(uint256 deadline);\\n\\n    /// @notice Thrown when an allowance on a token has been depleted.\\n    /// @param amount The maximum amount allowed\\n    error InsufficientAllowance(uint256 amount);\\n\\n    /// @notice Thrown when too many nonces are invalidated.\\n    error ExcessiveInvalidation();\\n\\n    /// @notice Emits an event when the owner successfully invalidates an ordered nonce.\\n    event NonceInvalidation(address indexed owner, address indexed token, address indexed spender, uint48 newNonce, uint48 oldNonce);\\n\\n    /// @notice Emits an event when the owner successfully sets permissions on a token for the spender.\\n    event Approval(address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration);\\n\\n    /// @notice Emits an event when the owner successfully sets permissions using a permit signature on a token for the spender.\\n    event Permit(address indexed owner, address indexed token, address indexed spender, uint160 amount, uint48 expiration, uint48 nonce);\\n\\n    /// @notice Emits an event when the owner sets the allowance back to 0 with the lockdown function.\\n    event Lockdown(address indexed owner, address token, address spender);\\n\\n    /// @notice The permit data for a token\\n    struct PermitDetails {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount allowed to spend\\n        uint160 amount;\\n        // timestamp at which a spender's token allowances become invalid\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    /// @notice The permit message signed for a single token allownce\\n    struct PermitSingle {\\n        // the permit data for a single token alownce\\n        PermitDetails details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n\\n    /// @notice The permit message signed for multiple token allowances\\n    struct PermitBatch {\\n        // the permit data for multiple token allowances\\n        PermitDetails[] details;\\n        // address permissioned on the allowed tokens\\n        address spender;\\n        // deadline on the permit signature\\n        uint256 sigDeadline;\\n    }\\n\\n    /// @notice The saved permissions\\n    /// @dev This info is saved per owner, per token, per spender and all signed over in the permit message\\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\\n    struct PackedAllowance {\\n        // amount allowed\\n        uint160 amount;\\n        // permission expiry\\n        uint48 expiration;\\n        // an incrementing value indexed per owner,token,and spender for each signature\\n        uint48 nonce;\\n    }\\n\\n    /// @notice A token spender pair.\\n    struct TokenSpenderPair {\\n        // the token the spender is approved\\n        address token;\\n        // the spender address\\n        address spender;\\n    }\\n\\n    /// @notice Details for a token transfer.\\n    struct AllowanceTransferDetails {\\n        // the owner of the token\\n        address from;\\n        // the recipient of the token\\n        address to;\\n        // the amount of the token\\n        uint160 amount;\\n        // the token to be transferred\\n        address token;\\n    }\\n\\n    /// @notice A mapping from owner address to token address to spender address to PackedAllowance struct, which contains details and conditions of the approval.\\n    /// @notice The mapping is indexed in the above order see: allowance[ownerAddress][tokenAddress][spenderAddress]\\n    /// @dev The packed slot holds the allowed amount, expiration at which the allowed amount is no longer valid, and current nonce thats updated on any signature based approvals.\\n    function allowance(address, address, address) external view returns (uint160, uint48, uint48);\\n\\n    /// @notice Approves the spender to use up to amount of the specified token up until the expiration\\n    /// @param token The token to approve\\n    /// @param spender The spender address to approve\\n    /// @param amount The approved amount of the token\\n    /// @param expiration The timestamp at which the approval is no longer valid\\n    /// @dev The packed allowance also holds a nonce, which will stay unchanged in approve\\n    /// @dev Setting amount to type(uint160).max sets an unlimited approval\\n    function approve(address token, address spender, uint160 amount, uint48 expiration) external;\\n\\n    /// @notice Permit a spender to a given amount of the owners token via the owner's EIP-712 signature\\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\\n    /// @param owner The owner of the tokens being approved\\n    /// @param permitSingle Data signed over by the owner specifying the terms of approval\\n    /// @param signature The owner's signature over the permit data\\n    function permit(address owner, PermitSingle memory permitSingle, bytes calldata signature) external;\\n\\n    /// @notice Permit a spender to the signed amounts of the owners tokens via the owner's EIP-712 signature\\n    /// @dev May fail if the owner's nonce was invalidated in-flight by invalidateNonce\\n    /// @param owner The owner of the tokens being approved\\n    /// @param permitBatch Data signed over by the owner specifying the terms of approval\\n    /// @param signature The owner's signature over the permit data\\n    function permit(address owner, PermitBatch memory permitBatch, bytes calldata signature) external;\\n\\n    /// @notice Transfer approved tokens from one address to another\\n    /// @param from The address to transfer from\\n    /// @param to The address of the recipient\\n    /// @param amount The amount of the token to transfer\\n    /// @param token The token address to transfer\\n    /// @dev Requires the from address to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(address from, address to, uint160 amount, address token) external;\\n\\n    /// @notice Transfer approved tokens in a batch\\n    /// @param transferDetails Array of owners, recipients, amounts, and tokens for the transfers\\n    /// @dev Requires the from addresses to have approved at least the desired amount\\n    /// of tokens to msg.sender.\\n    function transferFrom(AllowanceTransferDetails[] calldata transferDetails) external;\\n\\n    /// @notice Enables performing a \\\"lockdown\\\" of the sender's Permit2 identity\\n    /// by batch revoking approvals\\n    /// @param approvals Array of approvals to revoke.\\n    function lockdown(TokenSpenderPair[] calldata approvals) external;\\n\\n    /// @notice Invalidate nonces for a given (token, spender) pair\\n    /// @param token The token to invalidate nonces for\\n    /// @param spender The spender to invalidate nonces for\\n    /// @param newNonce The new nonce to set. Invalidates all nonces less than it.\\n    /// @dev Can't invalidate more than 2**16 nonces per transaction.\\n    function invalidateNonces(address token, address spender, uint48 newNonce) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/ICygnusBorrow.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  ICygnusBorrow.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\n\\ninterface ICygnusBorrow is IERC20Permit {\\n    /**\\n     *  @notice This low level function should only be called from `CygnusAltair` contract only\\n     *\\n     *  @param borrower The address of the Borrow contract.\\n     *  @param receiver The address of the receiver of the borrow amount.\\n     *  @param borrowAmount The amount of the underlying asset to borrow.\\n     *  @param data Calltype data passed to Router contract.\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function borrow(address borrower, address receiver, uint256 borrowAmount, bytes calldata data) external returns (uint256);\\n\\n    /**\\n     *  @notice This low level function should only be called from `CygnusAltair` contract only\\n     *\\n     *  @param borrower The address of the borrower being liquidated\\n     *  @param receiver The address of the receiver of the collateral\\n     *  @param repayAmount USD amount covering the loan\\n     *  @param data Calltype data passed to Router contract.\\n     *  @return usdAmount The amount of USD deposited after taking into account liq. incentive\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function liquidate(address borrower, address receiver, uint256 repayAmount, bytes calldata data) external returns (uint256 usdAmount);\\n\\n    /**\\n     *  @notice Get the lender`s full position\\n     *  @param lender The address of the lender\\n     *  @return cygUsdBalance The `lender's` balance of CygUSD\\n     *  @return rate The currente exchange rate\\n     *  @return positionInUsd The lender's position in USD\\n     */\\n    function getLenderPosition(address lender) external view returns (uint256 cygUsdBalance, uint256 rate, uint256 positionInUsd);\\n\\n    /**\\n     *  @notice This public view function is used to get the borrow balance of users based on stored data\\n     *\\n     *  @param borrower The address whose balance should be calculated\\n     *\\n     *  @return principal The USD amount borrowed without interest accrual\\n     *  @return borrowBalance The USD amount borrowed with interest accrual (ie. USD amount the borrower must repay)\\n     */\\n    function getBorrowBalance(address borrower) external view returns (uint256 principal, uint256 borrowBalance);\\n\\n    /**\\n     *  @notice Applies interest accruals to borrows and reserves\\n     */\\n    function accrueInterest() external;\\n\\n    /**\\n     *  @return underlying The address of the underlying (LP Token for collateral contracts, USDC for borrow contracts)\\n     */\\n    function underlying() external view returns (address);\\n\\n    /**\\n     *  @return collateral The address of this borrowable's collateral\\n     */\\n    function collateral() external view returns (address);\\n\\n    /**\\n     *  @return supplyRate The current APR for lenders\\n     */\\n    function supplyRate() external view returns (uint256);\\n\\n    /**\\n     *  @return borrowRate The current per-second borrow rate stored for this pool.\\n     */\\n    function borrowRate() external view returns (uint48);\\n\\n    /**\\n     *  @return utilizationRate The total amount of borrowed funds divided by the total cash the pool has available\\n     */\\n    function utilizationRate() external view returns (uint256);\\n\\n    /**\\n     *  @return totalBorrows Total borrows stored in the lending pool\\n     */\\n    function totalBorrows() external view returns (uint96);\\n\\n    /**\\n     *  @return totalBalance Total USD balance in the pool\\n     */\\n    function totalBalance() external view returns (uint160);\\n\\n    /**\\n     *  @return exchangeRate The latest exchange rate\\n     */\\n    function exchangeRate() external view returns (uint256);\\n\\n    /**\\n     *  @notice Syncs the total balance to the underlying balance and accrues interest\\n     *  @custom:security non-reentrant\\n     */\\n    function sync() external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/ICygnusCollateral.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  ICygnusCollateral.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\nimport {IAllowanceTransfer} from \\\"./IAllowanceTransfer.sol\\\";\\n\\ninterface ICygnusCollateral is IERC20Permit { \\n    /**\\n     *  @return underlying The address of the underlying (LP Token for collateral contracts, USDC for borrow contracts)\\n     */\\n    function underlying() external view returns (address);\\n\\n    /**\\n     *  @return exchangeRate The ratio which 1 pool token can be redeemed for underlying amount.\\n     */\\n    function exchangeRate() external view returns (uint256);\\n\\n    /**\\n     *  @return borrowable The address of the borrowable contract\\n     */\\n    function borrowable() external view returns (address);\\n\\n    function totalSupply() external view returns (uint256);\\n    function totalAssets() external view returns (uint256);\\n\\n    /**\\n     *  @notice This function must be called with the `approve` method of the underlying asset token contract for\\n     *          the `assets` amount on behalf of the sender before calling this function.\\n     *  @notice Implements the deposit of the underlying asset into the Cygnus Vault pool. This function transfers\\n     *          the underlying assets from the sender to this contract and mints a corresponding amount of Cygnus\\n     *          Vault shares to the recipient. A deposit fee may be charged by the strategy, which is deducted from\\n     *          the deposited assets.\\n     *\\n     *  @dev If the deposit amount is less than or equal to 0, this function will revert.\\n     *\\n     *  @param assets Amount of the underlying asset to deposit.\\n     *  @param recipient Address that will receive the corresponding amount of shares.\\n     *  @param _permit Data signed over by the owner specifying the terms of approval\\n     *  @param _signature The owner's signature over the permit data\\n     *  @return shares Amount of Cygnus Vault shares minted and transferred to the `recipient`.\\n     */\\n    function deposit(\\n        uint256 assets,\\n        address recipient,\\n        IAllowanceTransfer.PermitSingle calldata _permit,\\n        bytes calldata _signature\\n    ) external returns (uint256 shares);\\n\\n    /**\\n     *  @notice Gets the account's total position value in USD (LP Tokens owned multiplied by LP price). It uses the oracle to get the\\n     *          price of the LP Token and uses the current exchange rate.\\n     *\\n     *  @param borrower The address of the borrower\\n     *\\n     *  @return cygLPBalance The user's balance of collateral (CygLP)\\n     *  @return principal The original loaned USDC amount (without interest)\\n     *  @return borrowBalance The original loaned USDC amount plus interest (ie. what the user must pay back)\\n     *  @return price The current liquidity token price\\n     *  @return positionUsd The borrower's position in USD. position = CygLP Balance * Exchange Rate * LP Token Price\\n     *  @return positionLp The borrower`s position in LP Tokens\\n     *  @return rate The current exchange rate between CygLP and LP Token\\n     *  @return health The user's current loan health (once it reaches 100% the user becomes liquidatable)\\n     */\\n    function getBorrowerPosition(\\n        address borrower\\n    )\\n        external\\n        view\\n        returns (\\n            uint256 cygLPBalance,\\n            uint256 principal,\\n            uint256 borrowBalance,\\n            uint256 price,\\n            uint256 positionUsd,\\n            uint256 positionLp,\\n            uint256 rate,\\n            uint256 health\\n        );\\n\\n    /**\\n     *  @notice Gets an account's liquidity or shortfall\\n     *\\n     *  @param borrower The address of the borrower\\n     *  @return liquidity The account's liquidity in USDC\\n     *  @return shortfall If user has no liquidity, return the shortfall in USDC\\n     */\\n    function getAccountLiquidity(address borrower) external view returns (uint256 liquidity, uint256 shortfall);\\n\\n    /**\\n     *  @notice Flash redeems the underlying LP Token\\n     *\\n     *  @dev This should be called from `Altair` contract\\n     *\\n     *  @param redeemer The address redeeming the tokens (Altair contract)\\n     *  @param assets The amount of the underlying assets to redeem\\n     *  @param data Calldata passed from and back to router contract\\n     *\\n     *  @custom:security non-reentrant\\n     */\\n    function flashRedeemAltair(address redeemer, uint256 assets, bytes calldata data) external returns (uint256 usdAmount);\\n\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/ICygnusNebulaRegistry.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  ICygnusNebulaRegistry.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity ^0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/**\\n *  @title ICygnusNebulaRegistry Interface to interact with Cygnus' LP Oracle\\n *  @author CygnusDAO\\n */\\ninterface ICygnusNebulaRegistry {\\n    /**\\n     *  @notice Gets the latest info for an initialized LP Token\\n     *  @param lpTokenPair The address of the LP Token\\n     *  @return tokens Array of addresses of all the LP's assets\\n     *  @return prices Array of prices of each asset (in denom token)\\n     *  @return reserves Array of reserves of each asset in the LP\\n     *  @return tokenDecimals Array of decimals of each token\\n     *  @return reservesUsd Array of reserves of each asset in USD\\n     */\\n    function getLPTokenInfo(\\n        address lpTokenPair\\n    )\\n        external\\n        view\\n        returns (\\n            IERC20[] memory tokens,\\n            uint256[] memory prices,\\n            uint256[] memory reserves,\\n            uint256[] memory tokenDecimals,\\n            uint256[] memory reservesUsd\\n        );\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/ICygnusTerminal.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  ICygnusTerminal.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\n// Dependencies\\nimport {IERC20Permit} from \\\"./IERC20Permit.sol\\\";\\n\\n/**\\n *  @title ICygnusTerminal\\n *  @notice The interface to mint/redeem pool tokens (CygLP and CygUSD)\\n */\\ninterface ICygnusTerminal is IERC20Permit {}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\npragma solidity >=0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/IERC20Permit.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\npragma solidity >=0.8.17;\\n\\nimport {IERC20} from \\\"./IERC20.sol\\\";\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit is IERC20 {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/IHangar18.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  IHangar18.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\nimport {ICygnusNebulaRegistry} from \\\"./ICygnusNebulaRegistry.sol\\\";\\n\\n/**\\n *  @title The interface for the Cygnus Factory\\n *  @notice The Cygnus factory facilitates creation of collateral and borrow pools\\n */\\ninterface IHangar18 {\\n    /**\\n     *  @return usd The address of the borrowable token (stablecoin)\\n     */\\n    function usd() external view returns (address);\\n\\n    /**\\n     *  @return nativeToken The address of the chain's native token\\n     */\\n    function nativeToken() external view returns (address);\\n\\n    /**\\n     *  @return admin The address of the Cygnus Admin which grants special permissions in collateral/borrow contracts\\n     */\\n    function admin() external view returns (address);\\n\\n    /**\\n     *  @notice Array of LP Token pairs deployed\\n     *  @param _shuttleId The ID of the shuttle deployed\\n     *  @return launched Whether this pair exists or not\\n     *  @return shuttleId The ID of this shuttle\\n     *  @return borrowable The address of the borrow contract\\n     *  @return collateral The address of the collateral contract\\n     *  @return orbiterId The ID of the orbiters used to deploy this lending pool\\n     */\\n    function allShuttles(\\n        uint256 _shuttleId\\n    ) external view returns (bool launched, uint88 shuttleId, address borrowable, address collateral, uint96 orbiterId);\\n\\n    function nebulaRegistry() external view returns (ICygnusNebulaRegistry);\\n\\n    function shuttlesDeployed() external view returns (uint256);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/core/ISignatureTransfer.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.17;\\n\\n/// @title SignatureTransfer\\n/// @notice Handles ERC20 token transfers through signature based actions\\n/// @dev Requires user's token approval on the Permit2 contract\\ninterface ISignatureTransfer {\\n    /// @notice Thrown when the requested amount for a transfer is larger than the permissioned amount\\n    /// @param maxAmount The maximum amount a spender can request to transfer\\n    error InvalidAmount(uint256 maxAmount);\\n\\n    /// @notice Thrown when the number of tokens permissioned to a spender does not match the number of tokens being transferred\\n    /// @dev If the spender does not need to transfer the number of tokens permitted, the spender can request amount 0 to be transferred\\n    error LengthMismatch();\\n\\n    /// @notice Emits an event when the owner successfully invalidates an unordered nonce.\\n    event UnorderedNonceInvalidation(address indexed owner, uint256 word, uint256 mask);\\n\\n    /// @notice The token and amount details for a transfer signed in the permit transfer signature\\n    struct TokenPermissions {\\n        // ERC20 token address\\n        address token;\\n        // the maximum amount that can be spent\\n        uint256 amount;\\n    }\\n\\n    /// @notice The signed permit message for a single token transfer\\n    struct PermitTransferFrom {\\n        TokenPermissions permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice Specifies the recipient address and amount for batched transfers.\\n    /// @dev Recipients and amounts correspond to the index of the signed token permissions array.\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount.\\n    struct SignatureTransferDetails {\\n        // recipient address\\n        address to;\\n        // spender requested amount\\n        uint256 requestedAmount;\\n    }\\n\\n    /// @notice Used to reconstruct the signed permit message for multiple token transfers\\n    /// @dev Do not need to pass in spender address as it is required that it is msg.sender\\n    /// @dev Note that a user still signs over a spender address\\n    struct PermitBatchTransferFrom {\\n        // the tokens and corresponding amounts permitted for a transfer\\n        TokenPermissions[] permitted;\\n        // a unique value for every token owner's signature to prevent signature replays\\n        uint256 nonce;\\n        // deadline on the permit signature\\n        uint256 deadline;\\n    }\\n\\n    /// @notice A map from token owner address and a caller specified word index to a bitmap. Used to set bits in the bitmap to prevent against signature replay protection\\n    /// @dev Uses unordered nonces so that permit messages do not need to be spent in a certain order\\n    /// @dev The mapping is indexed first by the token owner, then by an index specified in the nonce\\n    /// @dev It returns a uint256 bitmap\\n    /// @dev The index, or wordPosition is capped at type(uint248).max\\n    function nonceBitmap(address, uint256) external view returns (uint256);\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers a token using a signed permit message\\n    /// @notice Includes extra data provided by the caller to verify signature over\\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\\n    /// @dev Reverts if the requested amount is greater than the permitted signed amount\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails The spender's requested transfer details for the permitted token\\n    /// @param witness Extra data to include when checking the user signature\\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\\n    /// @param signature The signature to verify\\n    function permitWitnessTransferFrom(\\n        PermitTransferFrom memory permit,\\n        SignatureTransferDetails calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers multiple tokens using a signed permit message\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\\n    /// @param signature The signature to verify\\n    function permitTransferFrom(\\n        PermitBatchTransferFrom memory permit,\\n        SignatureTransferDetails[] calldata transferDetails,\\n        address owner,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Transfers multiple tokens using a signed permit message\\n    /// @dev The witness type string must follow EIP712 ordering of nested structs and must include the TokenPermissions type definition\\n    /// @notice Includes extra data provided by the caller to verify signature over\\n    /// @param permit The permit data signed over by the owner\\n    /// @param owner The owner of the tokens to transfer\\n    /// @param transferDetails Specifies the recipient and requested amount for the token transfer\\n    /// @param witness Extra data to include when checking the user signature\\n    /// @param witnessTypeString The EIP-712 type definition for remaining string stub of the typehash\\n    /// @param signature The signature to verify\\n    function permitWitnessTransferFrom(\\n        PermitBatchTransferFrom memory permit,\\n        SignatureTransferDetails[] calldata transferDetails,\\n        address owner,\\n        bytes32 witness,\\n        string calldata witnessTypeString,\\n        bytes calldata signature\\n    ) external;\\n\\n    /// @notice Invalidates the bits specified in mask for the bitmap at the word position\\n    /// @dev The wordPos is maxed at type(uint248).max\\n    /// @param wordPos A number to index the nonceBitmap at\\n    /// @param mask A bitmap masked against msg.sender's current bitmap at the word position\\n    function invalidateUnorderedNonces(uint256 wordPos, uint256 mask) external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/ICygnusAltair.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  CygnusAltair.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"./core/IERC20.sol\\\";\\nimport {IHangar18} from \\\"./core/IHangar18.sol\\\";\\nimport {IWrappedNative} from \\\"./IWrappedNative.sol\\\";\\nimport {ICygnusBorrow} from \\\"./core/ICygnusBorrow.sol\\\";\\n\\n// Permit2\\nimport {IAllowanceTransfer} from \\\"./core/IAllowanceTransfer.sol\\\";\\nimport {ISignatureTransfer} from \\\"./core/ISignatureTransfer.sol\\\";\\n\\n/**\\n *  @notice Interface to interact with Cygnus' router contract\\n */\\ninterface ICygnusAltair {\\n    /**\\n     *  @notice Enum for choosing dex aggregators to perform leverage, deleverage and flash liquidations\\n     *  @custom:member PARASWAP Uses Paraswap\\n     *  @custom:member ONE_INCH Uses 1inch with the legacy `swap` mmethod\\n     *  @custom:member ONE_INCH Uses 1inch with optimized routers\\n     *  @custom:member OxPROJECT Uses 0xProjects swap API\\n     *  @custom:member OPEN_OCEAN_V1 Uses OpenOcean  with the legacy `swap` method\\n     *  @custom:member OPEN_OCEAN_V2 Uses OpenOcean with `uniswapV3SwapTo` method\\n     *  @custom:member OKX Uses OKX aggregation router\\n     *  @custom:member UNISWAP_V3_EMERGENCY Uses Uniswapv3 to perform the swap, should only be used under emergency scenarios\\n     *                 in case that aggregators stop working all of a sudden and users cannot deleverage.\\n     */\\n    enum DexAggregator {\\n        PARASWAP,\\n        ONE_INCH_LEGACY,\\n        ONE_INCH_V2,\\n        OxPROJECT,\\n        OPEN_OCEAN_LEGACY,\\n        OPEN_OCEAN_V2,\\n        OKX,\\n        UNISWAP_V3_EMERGENCY\\n    }\\n\\n    /**\\n     *  @custom:struct AltairLeverageCalldata Encoded bytes passed to Cygnus Borrow contract for leverage\\n     *  @custom:member lpTokenPair The address of the LP Token\\n     *  @custom:member collateral The address of the Cygnus collateral contract\\n     *  @custom:member borrowable The address of the Cygnus borrow contract\\n     *  @custom:member recipient The address of the user receiving the leveraged LP Tokens\\n     *  @custom:member lpAmountMin The minimum amount of LP Tokens to receive\\n     */\\n    struct AltairLeverageCalldata {\\n        address lpTokenPair;\\n        address collateral;\\n        address borrowable;\\n        address recipient;\\n        uint256 lpAmountMin;\\n        DexAggregator dexAggregator;\\n        bytes[] swapdata;\\n    }\\n\\n    /**\\n     *  @custom:struct AltairDeleverageCalldata Encoded bytes passed to Cygnus Collateral contract for de-leverage\\n     *  @custom:member lpTokenPair The address of the LP Token\\n     *  @custom:member collateral The address of the collateral contract\\n     *  @custom:member borrowable The address of the borrow contract\\n     *  @custom:member recipient The address of the user receiving the de-leveraged assets\\n     *  @custom:member redeemTokens The amount of CygLP to redeem\\n     *  @custom:member usdAmountMin The minimum amount of USD to receive by redeeming `redeemTokens`\\n     *  @custom:member swapdata The 1inch swap data byte array to convert Liquidity Tokens to USD\\n     */\\n    struct AltairDeleverageCalldata {\\n        address lpTokenPair;\\n        address collateral;\\n        address borrowable;\\n        address recipient;\\n        uint256 redeemTokens;\\n        uint256 usdAmountMin;\\n        DexAggregator dexAggregator;\\n        bytes[] swapdata;\\n    }\\n\\n    /**\\n     *  @custom:struct AltairLiquidateCalldata Encoded bytes passed to Cygnus Borrow contract for liquidating borrows\\n     *  @custom:member lpTokenPair The address of the LP Token\\n     *  @custom:member collateral The address of the collateral contract\\n     *  @custom:member borrowable The address of the borrow contract\\n     *  @custom:member recipient The address of the liquidator (or this contract if protocol liquidation)\\n     *  @custom:member borrower The address of the borrower being liquidated\\n     *  @custom:member repayAmount The USD amount being repaid by the liquidator\\n     *  @custom:member swapdata The 1inch swap data byte array to convert Liquidity Tokens to USD after burning\\n     */\\n    struct AltairLiquidateCalldata {\\n        address lpTokenPair;\\n        address collateral;\\n        address borrowable;\\n        address recipient;\\n        address borrower;\\n        uint256 repayAmount;\\n        DexAggregator dexAggregator;\\n        bytes[] swapdata;\\n    }\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. CUSTOM ERRORS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @dev Reverts when the current block.timestamp is past deadline\\n     *\\n     *  @custom:error TransactionExpired\\n     */\\n    error CygnusAltair__TransactionExpired();\\n\\n    /**\\n     *  @dev Reverts when the msg sender is not the cygnus factory admin\\n     *\\n     *  @custom:error MsgSenderNotAdmin\\n     */\\n    error CygnusAltair__MsgSenderNotAdmin();\\n\\n    /**\\n     *  @dev Reverts when the paraswap transaction fails\\n     *\\n     *  @custom:error ParaswapTransactionFailed\\n     */\\n    error CygnusAltair__ParaswapTransactionFailed();\\n\\n    /**\\n     *  @dev Reverts when the 1inch transaction fails\\n     *\\n     *  @custom:error OneInchTransactionFailed\\n     */\\n    error CygnusAltair__OneInchTransactionFailed();\\n\\n    /**\\n     *  @dev Reverts when the 0x swap api transaction fails\\n     *\\n     *  @custom:error 0xProjectTransactionFailed\\n     */\\n    error CygnusAltair__0xProjectTransactionFailed();\\n\\n    /**\\n     *  @dev Reverts when the OpenOcean transaction fails\\n     *\\n     *  @custom:error OpenOceanTransactionFailed\\n     */\\n    error CygnusAltair__OpenOceanTransactionFailed();\\n\\n    /**\\n     *  @dev Reverts if an extension has not been set for the borrowable or collateral\\n     *\\n     *  @custom:error AltairXDoesNotExist\\n     */\\n    error CygnusAltair__AltairXDoesNotExist();\\n\\n    /**\\n     *  @dev Reverts if the shuttle does not exist when initializing an extension for it\\n     *\\n     *  @custom:erro ShuttleDoesNotExist\\n     */\\n    error CygnusAltair__ShuttleDoesNotExist();\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            2. CUSTOM EVENTS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @dev Logs when admin sets a new extension\\n     *\\n     *  @param shuttleId Indexed shuttle ID\\n     *  @param borrowable Address of the borrowable\\n     *  @param collateral Address of the collateral\\n     *  @param lpTokenAddres Address of the lp token\\n     *  @param extension Address of the new extension\\n     *\\n     *  @custom:event NewExtension\\n     */\\n    event NewExtension(uint256 indexed shuttleId, address borrowable, address collateral, address lpTokenAddres, address extension);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @return name The human readable name this router is for\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     *  @return version The version of the router\\n     */\\n    function version() external view returns (string memory);\\n\\n    /**\\n     *  @return hangar18 The address of the Cygnus factory contract V1 - Used to get the nativeToken and USD address\\n     */\\n    function hangar18() external view returns (IHangar18);\\n\\n    /**\\n     *  @return PERMIT Uniswap's Permit2 router\\n     */\\n    function PERMIT2() external view returns (address);\\n\\n    /**\\n     *  @return PARASWAP_AUGUSTUS_SWAPPER_V5 The address of the Paraswap router used to perform the swaps\\n     */\\n    function PARASWAP_AUGUSTUS_SWAPPER_V5() external pure returns (address);\\n\\n    /**\\n     *  @return ONE_INCH_ROUTER_V5 The address of the 1Inch router used to perform the swaps\\n     */\\n    function ONE_INCH_ROUTER_V5() external pure returns (address);\\n\\n    /**\\n     *  @return OxPROJECT_EXCHANGE_PROXY The address of 0x's exchange proxy\\n     */\\n    function OxPROJECT_EXCHANGE_PROXY() external pure returns (address);\\n\\n    /**\\n     *  @return OPEN_OCEAN_EXCHANGE_PROXY The address of OpenOcean's exchange router\\n     */\\n    function OPEN_OCEAN_EXCHANGE_PROXY() external pure returns (address);\\n\\n    /**\\n     *  @return OKX_AGGREGATION_ROUTER The address of OKX's Aggregation Router on this chain\\n     */\\n    function OKX_AGGREGATION_ROUTER() external pure returns (address);\\n\\n    /**\\n     *  @return UNISWAP_V3_ROUTER The address of UniswapV3's swap router\\n     */\\n    function UNISWAP_V3_ROUTER() external pure returns (address);\\n\\n    /**\\n     *  @return usd The address of USD on this chain, used for the leverage/deleverage swaps\\n     */\\n    function usd() external view returns (address);\\n\\n    /**\\n     *  @return nativeToken The address of the native token on this chain (ie. WETH)\\n     */\\n    function nativeToken() external view returns (IWrappedNative);\\n\\n    /**\\n     *  @notice Array of all initialized extensions\\n     */\\n    function allExtensions(uint256 index) external view returns (address);\\n\\n    /**\\n     *  @notice Returns the altair extension for a borrowable or collateral contract\\n     *  @param poolToken The address of a Cygnus borrowable or collateral or an lp token pair\\n     *  @return The address of the extension\\n     */\\n    function getAltairExtension(address poolToken) external view returns (address);\\n\\n    /**\\n     *  @notice Returns the altair extension for a shuttle id\\n     *  @param shuttleId The ID of the lending pool\\n     *  @return The address of the extension\\n     */\\n    function getShuttleExtension(uint256 shuttleId) external view returns (address);\\n\\n    /**\\n     *  @return altairExtensionsLength How many extensions we have added to the router so far\\n     */\\n    function altairExtensionsLength() external view returns (uint256);\\n\\n    /**\\n     *  @dev Returns the assets and amounts received by redeeming a given amount of underlying liquidity tokens.\\n     *  @param underlying The address of the underlying liquidity token (e.g., LP token or Balancer BPT).\\n     *  @param shares The amount of underlying liquidity tokens to redeem.\\n     *  @return tokens An array of addresses representing the received tokens.\\n     *  @return amounts An array of corresponding amounts received by redeeming the liquidity tokens.\\n     */\\n    function getAssetsForShares(\\n        address underlying,\\n        uint256 shares,\\n        uint256 slippage\\n    ) external view returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /**\\n     *  @dev Returns whether an extension is set or not\\n     *  @param extension The addres of CygnusAltairX\\n     */\\n    function isExtension(address extension) external returns (bool);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @notice Main function used in Cygnus to liquidate borrows\\n     *  @param borrowable The address of the CygnusBorrow contract\\n     *  @param amountMax The maximum amount to liquidate\\n     *  @param borrower The address of the borrower\\n     *  @param recipient The address of the recipient\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     */\\n    function liquidate(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address recipient,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 amount, uint256 seizeTokens);\\n\\n    /**\\n     *  @notice Main function used in Cygnus to liquidate borrows\\n     *  @param borrowable The address of the CygnusBorrow contract\\n     *  @param amountMax The maximum amount to liquidate\\n     *  @param borrower The address of the borrower\\n     *  @param recipient The address of the recipient\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     *  @param _permit Data signed over by the owner specifying the terms of approval\\n     *  @param signature The owner's signature over the permit data\\n     *  @return amount The amount of stablecoins repaid\\n     *  @return seizeTokens The amount of CygLP seized\\n     */\\n    function liquidatePermit2Allowance(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address recipient,\\n        uint256 deadline,\\n        IAllowanceTransfer.PermitSingle calldata _permit,\\n        bytes calldata signature\\n    ) external returns (uint256 amount, uint256 seizeTokens);\\n\\n    /**\\n     *  @notice Main function used in Cygnus to liquidate borrows\\n     *  @param borrowable The address of the CygnusBorrow contract\\n     *  @param amountMax The maximum amount to liquidate\\n     *  @param borrower The address of the borrower\\n     *  @param recipient The address of the recipient\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     *  @param _permit Data signed over by the owner specifying the terms of approval\\n     *  @param signature The owner's signature over the permit data\\n     *  @return amount The amount of stablecoins repaid\\n     *  @return seizeTokens The amount of CygLP seized\\n     */\\n    function liquidatePermit2Signature(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        address recipient,\\n        uint256 deadline,\\n        ISignatureTransfer.PermitTransferFrom calldata _permit,\\n        bytes calldata signature\\n    ) external returns (uint256 amount, uint256 seizeTokens);\\n\\n    /**\\n     *  @notice Main function used in Cygnus to borrow USD\\n     *  @param borrowable The address of the CygnusBorrow contract\\n     *  @param amount Amount of USD to borrow\\n     *  @param recipient The address of the borrower\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     *  @param permitData Permit data for pool token\\n     */\\n    function borrow(address borrowable, uint256 amount, address recipient, uint256 deadline, bytes calldata permitData) external;\\n\\n    /**\\n     *  @notice Main function used in Cygnus to repay borrows\\n     *  @param borrowable The address of the CygnusBorrow contract\\n     *  @param amountMax The max amount to repay\\n     *  @param borrower Thea ddress of the borrower\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     */\\n    function repay(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline,\\n        bytes calldata permitData\\n    ) external returns (uint256 amount);\\n\\n    /**\\n     *  @notice Main function used in Cygnus to repay borrow using Permit2 Signature Transfer\\n     *  @param borrowable The address of the CygnusBorrow contract\\n     *  @param amountMax The max amount to repay\\n     *  @param borrower Thea ddress of the borrower\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     *  @param _permit Data signed over by the owner specifying the terms of approval\\n     *  @param signature The owner's signature over the permit data\\n     */\\n    function repayPermit2Allowance(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline,\\n        IAllowanceTransfer.PermitSingle calldata _permit,\\n        bytes calldata signature\\n    ) external returns (uint256);\\n\\n    /**\\n     *  @notice Main function used in Cygnus to repay borrow using Permit2 Signature Transfer\\n     *  @param borrowable The address of the CygnusBorrow contract\\n     *  @param amountMax The max amount to repay\\n     *  @param borrower Thea ddress of the borrower\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     *  @param _permit Data signed over by the owner specifying the terms of approval\\n     *  @param signature The owner's signature over the permit data\\n     */\\n    function repayPermit2Signature(\\n        address borrowable,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline,\\n        ISignatureTransfer.PermitTransferFrom calldata _permit,\\n        bytes calldata signature\\n    ) external returns (uint256);\\n\\n    /**\\n     *  @notice Main function to flash liquidate borrows. Ie, liquidating a user without needing to have USD\\n     *  @param borrowable The address of the CygnusBorrow contract\\n     *  @param amountMax The maximum amount to liquidate\\n     *  @param borrower The address of the borrower\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     *  @param dexAggregator The dex used to sell the collateral (0 for Paraswap, 1 for 1inch)\\n     *  @param swapdata Calldata to swap\\n     */\\n    function flashLiquidate(\\n        address borrowable,\\n        address collateral,\\n        uint256 amountMax,\\n        address borrower,\\n        uint256 deadline,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) external returns (uint256 amount);\\n\\n    /**\\n     *  @notice Main leverage function\\n     *  @param lpTokenPair The address of the LP Token\\n     *  @param collateral The address of the collateral of the lending pool\\n     *  @param borrowable The address of the borrowable of the lending pool\\n     *  @param usdAmount The amount to leverage\\n     *  @param lpAmountMin The minimum amount of LP Tokens to receive\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     *  @param permitData Permit data for borrowable leverage\\n     *  @param dexAggregator The dex used to sell the collateral (0 for Paraswap, 1 for 1inch)\\n     *  @param swapdata the 1inch swap data to convert USD to liquidity\\n     */\\n    function leverage(\\n        address lpTokenPair,\\n        address collateral,\\n        address borrowable,\\n        uint256 usdAmount,\\n        uint256 lpAmountMin,\\n        uint256 deadline,\\n        bytes calldata permitData,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) external returns (uint256);\\n\\n    /**\\n     *  @notice Main deleverage function\\n     *  @param lpTokenPair The address of the LP Token\\n     *  @param collateral The address of the collateral of the lending pool\\n     *  @param borrowable The address of the borrowable of the lending pool\\n     *  @param cygLPAmount The amount to CygLP to deleverage\\n     *  @param usdAmountMin The minimum amount of USD to receive\\n     *  @param deadline The time by which the transaction must be included to effect the change\\n     *  @param permitData Permit data for collateral deleverage\\n     *  @param dexAggregator The dex used to sell the collateral (0 for Paraswap, 1 for 1inch)\\n     *  @param swapdata the 1inch swap data to convert liquidity to USD\\n     */\\n    function deleverage(\\n        address lpTokenPair,\\n        address collateral,\\n        address borrowable,\\n        uint256 cygLPAmount,\\n        uint256 usdAmountMin,\\n        uint256 deadline,\\n        bytes calldata permitData,\\n        DexAggregator dexAggregator,\\n        bytes[] calldata swapdata\\n    ) external returns (uint256);\\n\\n    //  Admin only  //\\n\\n    /**\\n     *  @notice Initializes an extnesion of the router and maps it to a borrowable/collateral/lp token\\n     *  @param shuttleIds Array of shuttle IDs for the extension\\n     *  @param extension The address of the extension\\n     *  @custom:security only-admin\\n     */\\n    function setAltairExtension(uint256[] calldata shuttleIds, address extension) external;\\n\\n    /**\\n     *  @notice Sweeps tokens that were sent here by mistake\\n     *  @param tokens Array of tokens to sweep\\n     *  @param to The receiver of the sweep\\n     *  @custom:security only-admin\\n     */\\n    function sweepTokens(IERC20[] memory tokens, address to) external;\\n\\n    /**\\n     *  @notice Sweeps native\\n     *  @custom:security only-admin\\n     */\\n    function sweepNative() external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/ICygnusAltairX.sol\": {\r\n      \"content\": \"//  SPDX-License-Identifier: AGPL-3.0-or-later\\n//\\n//  ICygnusAltairX.sol\\n//\\n//  Copyright (C) 2023 CygnusDAO\\n//\\n//  This program is free software: you can redistribute it and/or modify\\n//  it under the terms of the GNU Affero General Public License as published by\\n//  the Free Software Foundation, either version 3 of the License, or\\n//  (at your option) any later version.\\n//\\n//  This program is distributed in the hope that it will be useful,\\n//  but WITHOUT ANY WARRANTY; without even the implied warranty of\\n//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n//  GNU Affero General Public License for more details.\\n//\\n//  You should have received a copy of the GNU Affero General Public License\\n//  along with this program.  If not, see <https://www.gnu.org/licenses/>.\\npragma solidity >=0.8.17;\\n\\n// Interfaces\\nimport {IERC20} from \\\"./core/IERC20.sol\\\";\\nimport {IHangar18} from \\\"./core/IHangar18.sol\\\";\\nimport {IWrappedNative} from \\\"./IWrappedNative.sol\\\";\\nimport {ICygnusNebulaRegistry} from \\\"./core/ICygnusNebulaRegistry.sol\\\";\\n\\n/**\\n *  @notice Interface to interact with Cygnus' router contract\\n */\\ninterface ICygnusAltairX {\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            1. CUSTOM ERRORS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @dev Reverts when the msg sender is not the collateral contract\\n     *\\n     *  @custom:error MsgSenderNotCollateral\\n     */\\n    error CygnusAltair__MsgSenderNotCollateral();\\n\\n    /**\\n     *  @dev Reverts when the msg sender is not the router in the leverage function\\n     *\\n     *  @custom:error MsgSenderNotRouter\\n     */\\n    error CygnusAltair__MsgSenderNotRouter();\\n\\n    /**\\n     *  @dev Reverts when the msg sender is not the cygnus factory admin\\n     *\\n     *  @custom:error MsgSenderNotAdmin\\n     */\\n    error CygnusAltair__MsgSenderNotAdmin();\\n\\n    /**\\n     *  @dev Reverts when the msg sender is not the borrow contract\\n     *\\n     *  @custom:error MsgSenderNotBorrowable\\n     */\\n    error CygnusAltair__MsgSenderNotBorrowable();\\n\\n    /**\\n     *  @dev Reverts when the paraswap transaction fails\\n     *\\n     *  @custom:error ParaswapTransactionFailed\\n     */\\n    error CygnusAltair__ParaswapTransactionFailed();\\n\\n    /**\\n     *  @dev Reverts when the 1inch transaction fails\\n     *\\n     *  @custom:error OneInchTransactionFailed\\n     */\\n    error CygnusAltair__OneInchTransactionFailed();\\n\\n    /**\\n     *  @dev Reverts when the 0x swap api transaction fails\\n     *\\n     *  @custom:error 0xProjectTransactionFailed\\n     */\\n    error CygnusAltair__0xProjectTransactionFailed();\\n\\n    /**\\n     *  @dev Reverts when the Open Ocean swap transaction fails\\n     *\\n     *  @custom:error OpenOceanTransactionFailed\\n     */\\n    error CygnusAltair__OpenOceanTransactionFailed();\\n\\n    /**\\n     *  @dev Reverts when USD amount received is less than minimum asked while liquidating\\n     *\\n     *  @custom:error InsufficientLiquidateUsd\\n     */\\n    error CygnusAltair__InsufficientLiquidateUsd();\\n\\n    /**\\n     *  @dev Reverts when amount of USD received is less than the minimum asked\\n     *\\n     *  @custom:error InsufficientUSDAmount\\n     */\\n    error CygnusAltair__InsufficientUSDAmount();\\n\\n    /**\\n     *  @dev Reverts when the swapped amount is less than the min requested\\n     *\\n     *  @custom:error InsufficientLPTokenAmount\\n     */\\n    error CygnusAltair__InsufficientLPTokenAmount();\\n\\n    /**\\n     *  @dev Reverts if the call is not a delegate call\\n     *\\n     *  @custom:error OnlyDelegateCall\\n     */\\n    error CygnusAltair__OnlyDelegateCall();\\n\\n    /**\\n     *  @dev Reverts when no pool is found for swapping tokens through the UniswapV3 router\\n     *\\n     *  @custom:error InvalidPoolFee\\n     */\\n    error CygnusAltair__InvalidPool();\\n\\n    /**\\n     *\\n     */\\n    error CygnusAltair__InvalidAggregator();\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            3. CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @return name The human readable name this router is for\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     *  @return version The version of the Extension contract\\n     */\\n    function version() external view returns (string memory);\\n\\n    /**\\n     *  @return PERMIT Uniswap's Permit2 router\\n     */\\n    function PERMIT2() external view returns (address);\\n\\n    /**\\n     *  @return PARASWAP_AUGUSTUS_SWAPPER_V5 The address of the Paraswap router used to perform the swaps\\n     */\\n    function PARASWAP_AUGUSTUS_SWAPPER_V5() external pure returns (address);\\n\\n    /**\\n     *  @return ONE_INCH_ROUTER_V5 The address of the 1Inch router used to perform the swaps\\n     */\\n    function ONE_INCH_ROUTER_V5() external pure returns (address);\\n\\n    /**\\n     *  @return OxPROJECT_EXCHANGE_PROXY The address of 0x's exchange proxy\\n     */\\n    function OxPROJECT_EXCHANGE_PROXY() external pure returns (address);\\n\\n    /**\\n     *  @return OPEN_OCEAN_EXCHANGE_PROXY The address of OpenOcean's exchange router\\n     */\\n    function OPEN_OCEAN_EXCHANGE_PROXY() external pure returns (address);\\n\\n    /**\\n     *  @return OKX_AGGREGATION_ROUTER The address of OKX's Aggregation Router on this chain\\n     */\\n    function OKX_AGGREGATION_ROUTER() external pure returns (address);\\n\\n    /**\\n     *  @return UNISWAP_V3_ROUTER The address of UniswapV3's swap router\\n     */\\n    function UNISWAP_V3_ROUTER() external pure returns (address);\\n\\n    /**\\n     *  @return hangar18 The address of the Cygnus factory contract V1 - Used to get the nativeToken and USD address\\n     */\\n    function hangar18() external view returns (IHangar18);\\n\\n    /**\\n     *  @return usd The address of USD on this chain, used for the leverage/deleverage swaps\\n     */\\n    function usd() external view returns (address);\\n\\n    /**\\n     *  @return nativeToken The address of the native token on this chain (ie. WETH)\\n     */\\n    function nativeToken() external view returns (IWrappedNative);\\n\\n    /**\\n     *  @dev Returns the assets and amounts received by redeeming a given amount of underlying liquidity tokens.\\n     *  @param underlying The address of the underlying liquidity token (e.g., LP token or Balancer BPT).\\n     *  @param shares The amount of underlying liquidity tokens to redeem.\\n     *  @param difference Substract a difference from the estimated amount received to make sure router always has enough\\n     *                    from the actual amount received.\\n     *  @return tokens An array of addresses representing the received tokens.\\n     *  @return amounts An array of corresponding amounts received by redeeming the liquidity tokens.\\n     */\\n    function getAssetsForShares(\\n        address underlying,\\n        uint256 shares,\\n        uint256 difference\\n    ) external view returns (address[] memory tokens, uint256[] memory amounts);\\n\\n    /*  \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 \\n            4. NON-CONSTANT FUNCTIONS\\n        \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550  */\\n\\n    /**\\n     *  @notice Sweeps tokens that were sent here by mistake\\n     *  @param tokens Array of tokens to sweep\\n     *  @param to The receiver of the sweep\\n     *  @custom:security only-admin\\n     */\\n    function sweepTokens(IERC20[] memory tokens, address to) external;\\n\\n    /**\\n     *  @notice Sweeps native\\n     *  @custom:security only-admin\\n     */\\n    function sweepNative() external;\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/interfaces/IWrappedNative.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.17;\\n\\n// Interface for interfacting with Wrapped Eth\\ninterface IWrappedNative {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256 wad) external;\\n\\n    function totalSupply() external view returns (uint256);\\n\\n    function transfer(address dst, uint256 wad) external returns (bool);\\n\\n    function balanceOf(address owner) external view returns (uint256);\\n\\n    function approve(address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/libraries/FixedPointMathLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Arithmetic library with operations for fixed-point numbers.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/FixedPointMathLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/FixedPointMathLib.sol)\\nlibrary FixedPointMathLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error ExpOverflow();\\n\\n    /// @dev The operation failed, as the output exceeds the maximum value of uint256.\\n    error FactorialOverflow();\\n\\n    /// @dev The operation failed, due to an multiplication overflow.\\n    error MulWadFailed();\\n\\n    /// @dev The operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error DivWadFailed();\\n\\n    /// @dev The multiply-divide operation failed, either due to a\\n    /// multiplication overflow, or a division by a zero.\\n    error MulDivFailed();\\n\\n    /// @dev The division failed, as the denominator is zero.\\n    error DivFailed();\\n\\n    /// @dev The full precision multiply-divide operation failed, either due\\n    /// to the result being larger than 256 bits, or a division by a zero.\\n    error FullMulDivFailed();\\n\\n    /// @dev The output is undefined, as the input is less-than-or-equal to zero.\\n    error LnWadUndefined();\\n\\n    /// @dev The output is undefined, as the input is zero.\\n    error Log2Undefined();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The scalar of ETH and most ERC20s.\\n    uint256 internal constant WAD = 1e18;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*              SIMPLIFIED FIXED POINT OPERATIONS             */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded down.\\n    function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), WAD)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * y) / WAD` rounded up.\\n    function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\\n            if mul(y, gt(x, div(not(0), y))) {\\n                // Store the function selector of `MulWadFailed()`.\\n                mstore(0x00, 0xbac65e5b)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded down.\\n    function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, WAD), y)\\n        }\\n    }\\n\\n    /// @dev Equivalent to `(x * WAD) / y` rounded up.\\n    function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to `require(y != 0 && (WAD == 0 || x <= type(uint256).max / WAD))`.\\n            if iszero(mul(y, iszero(mul(WAD, gt(x, div(not(0), WAD)))))) {\\n                // Store the function selector of `DivWadFailed()`.\\n                mstore(0x00, 0x7c5f487d)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\\n        }\\n    }\\n\\n    /// @dev Equivalent to `x` to the power of `y`.\\n    /// because `x ** y = (e ** ln(x)) ** y = e ** (ln(x) * y)`.\\n    function powWad(int256 x, int256 y) internal pure returns (int256) {\\n        // Using `ln(x)` means `x` must be greater than 0.\\n        return expWad((lnWad(x) * y) / int256(WAD));\\n    }\\n\\n    /// @dev Returns `exp(x)`, denominated in `WAD`.\\n    function expWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            // When the result is < 0.5 we return zero. This happens when\\n            // x <= floor(log(0.5e18) * 1e18) ~ -42e18\\n            if (x <= -42139678854452767551) return r;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // When the result is > (2**255 - 1) / 1e18 we can not represent it as an\\n                // int. This happens when x >= floor(log((2**255 - 1) / 1e18) * 1e18) ~ 135.\\n                if iszero(slt(x, 135305999368893231589)) {\\n                    // Store the function selector of `ExpOverflow()`.\\n                    mstore(0x00, 0xa37bfec9)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // x is now in the range (-42, 136) * 1e18. Convert to (-42, 136) * 2**96\\n            // for more intermediate precision and a binary basis. This base conversion\\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\\n            x = (x << 78) / 5 ** 18;\\n\\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\\n            x = x - k * 54916777467707473351141471128;\\n\\n            // k is in the range [-61, 195].\\n\\n            // Evaluate using a (6, 7)-term rational approximation.\\n            // p is made monic, we'll multiply by a scale factor later.\\n            int256 y = x + 1346386616545796478920950773328;\\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\\n            int256 p = y + x - 94201549194550492254356042504812;\\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\\n            p = p * x + (4385272521454847904659076985693276 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            int256 q = x - 2855989394907223263936484059900;\\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\\n\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\\n                // No scaling is necessary because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r should be in the range (0.09, 0.25) * 2**96.\\n\\n            // We now need to multiply r by:\\n            // * the scale factor s = ~6.031367120.\\n            // * the 2**k factor from the range reduction.\\n            // * the 1e18 / 2**96 factor for base conversion.\\n            // We do this all at once, with an intermediate result in 2**213\\n            // basis, so the final right shift is always by a positive amount.\\n            r = int256((uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k));\\n        }\\n    }\\n\\n    /// @dev Returns `ln(x)`, denominated in `WAD`.\\n    function lnWad(int256 x) internal pure returns (int256 r) {\\n        unchecked {\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                if iszero(sgt(x, 0)) {\\n                    // Store the function selector of `LnWadUndefined()`.\\n                    mstore(0x00, 0x1615e638)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n            }\\n\\n            // We want to convert x from 10**18 fixed point to 2**96 fixed point.\\n            // We do this by multiplying by 2**96 / 10**18. But since\\n            // ln(x * C) = ln(x) + ln(C), we can simply do nothing here\\n            // and add ln(2**96 / 10**18) at the end.\\n\\n            // Compute k = log2(x) - 96.\\n            int256 k;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let v := x\\n                k := shl(7, lt(0xffffffffffffffffffffffffffffffff, v))\\n                k := or(k, shl(6, lt(0xffffffffffffffff, shr(k, v))))\\n                k := or(k, shl(5, lt(0xffffffff, shr(k, v))))\\n\\n                // For the remaining 32 bits, use a De Bruijn lookup.\\n                // See: https://graphics.stanford.edu/~seander/bithacks.html\\n                v := shr(k, v)\\n                v := or(v, shr(1, v))\\n                v := or(v, shr(2, v))\\n                v := or(v, shr(4, v))\\n                v := or(v, shr(8, v))\\n                v := or(v, shr(16, v))\\n\\n                // forgefmt: disable-next-item\\n                k := sub(\\n                    or(k, byte(shr(251, mul(v, shl(224, 0x07c4acdd))), 0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f)),\\n                    96\\n                )\\n            }\\n\\n            // Reduce range of x to (1, 2) * 2**96\\n            // ln(2^k * x) = k * ln(2) + ln(x)\\n            x <<= uint256(159 - k);\\n            x = int256(uint256(x) >> 159);\\n\\n            // Evaluate using a (8, 8)-term rational approximation.\\n            // p is made monic, we will multiply by a scale factor later.\\n            int256 p = x + 3273285459638523848632254066296;\\n            p = ((p * x) >> 96) + 24828157081833163892658089445524;\\n            p = ((p * x) >> 96) + 43456485725739037958740375743393;\\n            p = ((p * x) >> 96) - 11111509109440967052023855526967;\\n            p = ((p * x) >> 96) - 45023709667254063763336534515857;\\n            p = ((p * x) >> 96) - 14706773417378608786704636184526;\\n            p = p * x - (795164235651350426258249787498 << 96);\\n\\n            // We leave p in 2**192 basis so we don't need to scale it back up for the division.\\n            // q is monic by convention.\\n            int256 q = x + 5573035233440673466300451813936;\\n            q = ((q * x) >> 96) + 71694874799317883764090561454958;\\n            q = ((q * x) >> 96) + 283447036172924575727196451306956;\\n            q = ((q * x) >> 96) + 401686690394027663651624208769553;\\n            q = ((q * x) >> 96) + 204048457590392012362485061816622;\\n            q = ((q * x) >> 96) + 31853899698501571402653359427138;\\n            q = ((q * x) >> 96) + 909429971244387300277376558375;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                // Div in assembly because solidity adds a zero check despite the unchecked.\\n                // The q polynomial is known not to have zeros in the domain.\\n                // No scaling required because p is already 2**96 too large.\\n                r := sdiv(p, q)\\n            }\\n\\n            // r is in the range (0, 0.125) * 2**96\\n\\n            // Finalization, we need to:\\n            // * multiply by the scale factor s = 5.549\u2026\\n            // * add ln(2**96 / 10**18)\\n            // * add k * ln(2)\\n            // * multiply by 10**18 / 2**96 = 5**18 >> 78\\n\\n            // mul s * 5e18 * 2**96, base is now 5**18 * 2**192\\n            r *= 1677202110996718588342820967067443963516166;\\n            // add ln(2) * k * 5e18 * 2**192\\n            r += 16597577552685614221487285958193947469193820559219878177908093499208371 * k;\\n            // add ln(2**96 / 10**18) * 5e18 * 2**192\\n            r += 600920179829731861736702779321621459595472258049074101567377883020018308;\\n            // base conversion: mul 2**18 / 2**192\\n            r >>= 174;\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                  GENERAL NUMBER UTILITIES                  */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Calculates `floor(a * b / d)` with full precision.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Remco Bloemen under MIT license: https://2\u03c0.com/21/muldiv\\n    function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {\\n\\n            } 1 {\\n\\n            } {\\n                // 512-bit multiply `[prod1 prod0] = x * y`.\\n                // Compute the product mod `2**256` and mod `2**256 - 1`\\n                // then use the Chinese Remainder Theorem to reconstruct\\n                // the 512 bit result. The result is stored in two 256\\n                // variables such that `product = prod1 * 2**256 + prod0`.\\n\\n                // Least significant 256 bits of the product.\\n                let prod0 := mul(x, y)\\n                let mm := mulmod(x, y, not(0))\\n                // Most significant 256 bits of the product.\\n                let prod1 := sub(mm, add(prod0, lt(mm, prod0)))\\n\\n                // Handle non-overflow cases, 256 by 256 division.\\n                if iszero(prod1) {\\n                    if iszero(d) {\\n                        // Store the function selector of `FullMulDivFailed()`.\\n                        mstore(0x00, 0xae47f702)\\n                        // Revert with (offset, size).\\n                        revert(0x1c, 0x04)\\n                    }\\n                    result := div(prod0, d)\\n                    break\\n                }\\n\\n                // Make sure the result is less than `2**256`.\\n                // Also prevents `d == 0`.\\n                if iszero(gt(d, prod1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n\\n                ///////////////////////////////////////////////\\n                // 512 by 256 division.\\n                ///////////////////////////////////////////////\\n\\n                // Make division exact by subtracting the remainder from `[prod1 prod0]`.\\n                // Compute remainder using mulmod.\\n                let remainder := mulmod(x, y, d)\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n                // Factor powers of two out of `d`.\\n                // Compute largest power of two divisor of `d`.\\n                // Always greater or equal to 1.\\n                let twos := and(d, sub(0, d))\\n                // Divide d by power of two.\\n                d := div(d, twos)\\n                // Divide [prod1 prod0] by the factors of two.\\n                prod0 := div(prod0, twos)\\n                // Shift in bits from `prod1` into `prod0`. For this we need\\n                // to flip `twos` such that it is `2**256 / twos`.\\n                // If `twos` is zero, then it becomes one.\\n                prod0 := or(prod0, mul(prod1, add(div(sub(0, twos), twos), 1)))\\n                // Invert `d mod 2**256`\\n                // Now that `d` is an odd number, it has an inverse\\n                // modulo `2**256` such that `d * inv = 1 mod 2**256`.\\n                // Compute the inverse by starting with a seed that is correct\\n                // correct for four bits. That is, `d * inv = 1 mod 2**4`.\\n                let inv := xor(mul(3, d), 2)\\n                // Now use Newton-Raphson iteration to improve the precision.\\n                // Thanks to Hensel's lifting lemma, this also works in modular\\n                // arithmetic, doubling the correct bits in each step.\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\\n                inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\\n                result := mul(prod0, mul(inv, sub(2, mul(d, inv)))) // inverse mod 2**256\\n                break\\n            }\\n        }\\n    }\\n\\n    /// @dev Calculates `floor(x * y / d)` with full precision, rounded up.\\n    /// Throws if result overflows a uint256 or when `d` is zero.\\n    /// Credit to Uniswap-v3-core under MIT license:\\n    /// https://github.com/Uniswap/v3-core/blob/contracts/libraries/FullMath.sol\\n    function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 result) {\\n        result = fullMulDiv(x, y, d);\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if mulmod(x, y, d) {\\n                if iszero(add(result, 1)) {\\n                    // Store the function selector of `FullMulDivFailed()`.\\n                    mstore(0x00, 0xae47f702)\\n                    // Revert with (offset, size).\\n                    revert(0x1c, 0x04)\\n                }\\n                result := add(result, 1)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns `floor(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := div(mul(x, y), d)\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x * y / d)`.\\n    /// Reverts if `x * y` overflows, or `d` is zero.\\n    function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Equivalent to require(d != 0 && (y == 0 || x <= type(uint256).max / y))\\n            if iszero(mul(d, iszero(mul(y, gt(x, div(not(0), y)))))) {\\n                // Store the function selector of `MulDivFailed()`.\\n                mstore(0x00, 0xad251c27)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(mul(x, y), d))), div(mul(x, y), d))\\n        }\\n    }\\n\\n    /// @dev Returns `ceil(x / d)`.\\n    /// Reverts if `d` is zero.\\n    function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(d) {\\n                // Store the function selector of `DivFailed()`.\\n                mstore(0x00, 0x65244e4e)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\\n        }\\n    }\\n\\n    /// @dev Returns `max(0, x - y)`.\\n    function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mul(gt(x, y), sub(x, y))\\n        }\\n    }\\n\\n    /// @dev Returns the square root of `x`.\\n    function sqrt(uint256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\\n            z := 181 // The \\\"correct\\\" value is 1, but this saves a multiplication later.\\n\\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\\n\\n            // Let `y = x / 2**r`.\\n            // We check `y >= 2**(k + 8)` but shift right by `k` bits\\n            // each branch to ensure that if `x >= 256`, then `y >= 256`.\\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\\n            z := shl(shr(1, r), z)\\n\\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\\n\\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\\n\\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\\n\\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\\n            // Then we can estimate `sqrt(y)` using\\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\\n\\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\\n\\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n            z := shr(1, add(z, div(x, z)))\\n\\n            // If `x+1` is a perfect square, the Babylonian method cycles between\\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\\n            // Since the ceil is rare, we save gas on the assignment and repeat division in the rare case.\\n            // If you don't care whether the floor or ceil square root is returned, you can remove this statement.\\n            z := sub(z, lt(div(x, z), z))\\n        }\\n    }\\n\\n    /// @dev Returns the factorial of `x`.\\n    function factorial(uint256 x) internal pure returns (uint256 result) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            for {\\n\\n            } 1 {\\n\\n            } {\\n                if iszero(lt(10, x)) {\\n                    // forgefmt: disable-next-item\\n                    result := and(shr(mul(22, x), 0x375f0016260009d80004ec0002d00001e0000180000180000200000400001), 0x3fffff)\\n                    break\\n                }\\n                if iszero(lt(57, x)) {\\n                    let end := 31\\n                    result := 8222838654177922817725562880000000\\n                    if iszero(lt(end, x)) {\\n                        end := 10\\n                        result := 3628800\\n                    }\\n                    for {\\n                        let w := not(0)\\n                    } 1 {\\n\\n                    } {\\n                        result := mul(result, x)\\n                        x := add(x, w)\\n                        if eq(x, end) {\\n                            break\\n                        }\\n                    }\\n                    break\\n                }\\n                // Store the function selector of `FactorialOverflow()`.\\n                mstore(0x00, 0xaba0f2a2)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`.\\n    /// Equivalent to computing the index of the most significant bit (MSB) of `x`.\\n    function log2(uint256 x) internal pure returns (uint256 r) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            if iszero(x) {\\n                // Store the function selector of `Log2Undefined()`.\\n                mstore(0x00, 0x5be3aa5c)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\\n\\n            // For the remaining 32 bits, use a De Bruijn lookup.\\n            // See: https://graphics.stanford.edu/~seander/bithacks.html\\n            x := shr(r, x)\\n            x := or(x, shr(1, x))\\n            x := or(x, shr(2, x))\\n            x := or(x, shr(4, x))\\n            x := or(x, shr(8, x))\\n            x := or(x, shr(16, x))\\n\\n            // forgefmt: disable-next-item\\n            r := or(r, byte(shr(251, mul(x, shl(224, 0x07c4acdd))), 0x0009010a0d15021d0b0e10121619031e080c141c0f111807131b17061a05041f))\\n        }\\n    }\\n\\n    /// @dev Returns the log2 of `x`, rounded up.\\n    function log2Up(uint256 x) internal pure returns (uint256 r) {\\n        unchecked {\\n            uint256 isNotPo2;\\n            assembly {\\n                isNotPo2 := iszero(iszero(and(x, sub(x, 1))))\\n            }\\n            return log2(x) + isNotPo2;\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = (x & y) + ((x ^ y) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the average of `x` and `y`.\\n    function avg(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = (x >> 1) + (y >> 1) + (((x & 1) + (y & 1)) >> 1);\\n        }\\n    }\\n\\n    /// @dev Returns the absolute value of `x`.\\n    function abs(int256 x) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let mask := sub(0, shr(255, x))\\n            z := xor(mask, add(mask, x))\\n        }\\n    }\\n\\n    /// @dev Returns the absolute distance between `x` and `y`.\\n    function dist(int256 x, int256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let a := sub(y, x)\\n            z := xor(a, mul(xor(a, sub(x, y)), sgt(x, y)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), lt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the minimum of `x` and `y`.\\n    function min(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), slt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), gt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns the maximum of `x` and `y`.\\n    function max(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\\n        }\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(uint256 x, uint256 minValue, uint256 maxValue) internal pure returns (uint256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns `x`, bounded to `minValue` and `maxValue`.\\n    function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\\n        z = min(max(x, minValue), maxValue);\\n    }\\n\\n    /// @dev Returns greatest common divisor of `x` and `y`.\\n    function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // forgefmt: disable-next-item\\n            for {\\n                z := x\\n            } y {\\n\\n            } {\\n                let t := y\\n                y := mod(z, y)\\n                z := t\\n            }\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                   RAW NUMBER OPERATIONS                    */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x + y`, without checking for overflow.\\n    function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x + y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x - y`, without checking for underflow.\\n    function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x - y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x * y`, without checking for overflow.\\n    function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\\n        unchecked {\\n            z = x * y;\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := div(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x / y`, returning 0 if `y` is zero.\\n    function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := sdiv(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `x % y`, returning 0 if `y` is zero.\\n    function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := smod(x, y)\\n        }\\n    }\\n\\n    /// @dev Returns `(x + y) % d`, return 0 if `d` if zero.\\n    function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := addmod(x, y, d)\\n        }\\n    }\\n\\n    /// @dev Returns `(x * y) % d`, return 0 if `d` if zero.\\n    function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            z := mulmod(x, y, d)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"contracts/cygnus-periphery/libraries/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.4;\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solady (https://github.com/vectorized/solady/blob/main/src/utils/SafeTransferLib.sol)\\n/// @author Modified from Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Caution! This library won't check that a token has code, responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       CUSTOM ERRORS                        */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev The ETH transfer has failed.\\n    error ETHTransferFailed();\\n\\n    /// @dev The ERC20 `transferFrom` has failed.\\n    error TransferFromFailed();\\n\\n    /// @dev The ERC20 `transfer` has failed.\\n    error TransferFailed();\\n\\n    /// @dev The ERC20 `approve` has failed.\\n    error ApproveFailed();\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                         CONSTANTS                          */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH\\n    /// that disallows any storage writes.\\n    uint256 internal constant _GAS_STIPEND_NO_STORAGE_WRITES = 2300;\\n\\n    /// @dev Suggested gas stipend for contract receiving ETH to perform a few\\n    /// storage reads and writes, but low enough to prevent griefing.\\n    /// Multiply by a small constant (e.g. 2), if needed.\\n    uint256 internal constant _GAS_STIPEND_NO_GRIEF = 100000;\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                       ETH OPERATIONS                       */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gas(), to, amount, 0, 0, 0, 0)) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(gasStipend, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) {\\n                        revert(0, 0)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend\\n    /// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default\\n    /// for 99% of cases and can be overriden with the three-argument version of this\\n    /// function if necessary.\\n    ///\\n    /// If sending via the normal procedure fails, force sends the ETH by\\n    /// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.\\n    ///\\n    /// Reverts if the current contract has insufficient balance.\\n    function forceSafeTransferETH(address to, uint256 amount) internal {\\n        // Manually inlined because the compiler doesn't inline functions with branches.\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // If insufficient balance, revert.\\n            if lt(selfbalance(), amount) {\\n                // Store the function selector of `ETHTransferFailed()`.\\n                mstore(0x00, 0xb12d13eb)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Transfer the ETH and check if it succeeded or not.\\n            if iszero(call(_GAS_STIPEND_NO_GRIEF, to, amount, 0, 0, 0, 0)) {\\n                mstore(0x00, to) // Store the address in scratch space.\\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\\n                // We can directly use `SELFDESTRUCT` in the contract creation.\\n                // Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758\\n                if iszero(create(amount, 0x0b, 0x16)) {\\n                    // For better gas estimation.\\n                    if iszero(gt(gas(), 1000000)) {\\n                        revert(0, 0)\\n                    }\\n                }\\n            }\\n        }\\n    }\\n\\n    /// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`.\\n    /// The `gasStipend` can be set to a low enough value to prevent\\n    /// storage writes or gas griefing.\\n    ///\\n    /// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.\\n    ///\\n    /// Note: Does NOT revert upon failure.\\n    /// Returns whether the transfer of ETH is successful instead.\\n    function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal returns (bool success) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            // Transfer the ETH and check if it succeeded or not.\\n            success := call(gasStipend, to, amount, 0, 0, 0, 0)\\n        }\\n    }\\n\\n    /*\u00b4:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0\u2022.*\u2022\u00b4.*:\u02da.\u00b0*.\u02da\u2022\u00b4.\u00b0:\u00b0\u2022.\u00b0+.*\u2022\u00b4.*:*/\\n    /*                      ERC20 OPERATIONS                      */\\n    /*.\u2022\u00b0:\u00b0.\u00b4+\u02da.*\u00b0.\u02da:*.\u00b4\u2022*.+\u00b0.\u2022\u00b0:\u00b4*.\u00b4\u2022*.\u2022\u00b0.\u2022\u00b0:\u00b0.\u00b4:\u2022\u02da\u00b0.*\u00b0.\u02da:*.\u00b4+\u00b0.\u2022*/\\n\\n    /// @dev Sends `amount` of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x60, amount) // Store the `amount` argument.\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x0c, 0x23b872dd000000000000000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from `from` to `to`.\\n    /// Reverts upon failure.\\n    ///\\n    /// The `from` account must have at least `amount` approved for\\n    /// the current contract to manage.\\n    function safeTransferAllFrom(address token, address from, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let m := mload(0x40) // Cache the free memory pointer.\\n\\n            mstore(0x40, to) // Store the `to` argument.\\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x0c, 0x70a08231000000000000000000000000)\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            // Store the function selector of `transferFrom(address,address,uint256)`.\\n            mstore(0x00, 0x23b872dd)\\n            // The `amount` argument is already written to the memory word at 0x6c.\\n            amount := mload(0x60)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFromFailed()`.\\n                mstore(0x00, 0x7939f424)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x60, 0) // Restore the zero slot to zero.\\n            mstore(0x40, m) // Restore the free memory pointer.\\n        }\\n    }\\n\\n    /// @dev Sends `amount` of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransfer(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sends all of ERC20 `token` from the current contract to `to`.\\n    /// Reverts upon failure.\\n    function safeTransferAll(address token, address to) internal returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\\n            mstore(0x20, address()) // Store the address of the current contract.\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n\\n            mstore(0x14, to) // Store the `to` argument.\\n            // The `amount` argument is already written to the memory word at 0x34.\\n            amount := mload(0x34)\\n            // Store the function selector of `transfer(address,uint256)`.\\n            mstore(0x00, 0xa9059cbb000000000000000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `TransferFailed()`.\\n                mstore(0x00, 0x90b8ec18)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract.\\n    /// Reverts upon failure.\\n    function safeApprove(address token, address to, uint256 amount) internal {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, to) // Store the `to` argument.\\n            mstore(0x34, amount) // Store the `amount` argument.\\n            // Store the function selector of `approve(address,uint256)`.\\n            mstore(0x00, 0x095ea7b3000000000000000000000000)\\n\\n            if iszero(\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    // Set success to whether the call reverted, if not we check it either\\n                    // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                    or(eq(mload(0x00), 1), iszero(returndatasize())),\\n                    call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\\n                )\\n            ) {\\n                // Store the function selector of `ApproveFailed()`.\\n                mstore(0x00, 0x3e3f8f73)\\n                // Revert with (offset, size).\\n                revert(0x1c, 0x04)\\n            }\\n            // Restore the part of the free memory pointer that was overwritten.\\n            mstore(0x34, 0)\\n        }\\n    }\\n\\n    /// @dev Returns the amount of ERC20 `token` owned by `account`.\\n    /// Returns zero if the `token` does not exist.\\n    function balanceOf(address token, address account) internal view returns (uint256 amount) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x14, account) // Store the `account` argument.\\n            // Store the function selector of `balanceOf(address)`.\\n            mstore(0x00, 0x70a08231000000000000000000000000)\\n            amount := mul(\\n                mload(0x20),\\n                and(\\n                    // The arguments of `and` are evaluated from right to left.\\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\\n                    staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\\n                )\\n            )\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"viaIR\": true,\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 1000000,\r\n      \"details\": {\r\n        \"peephole\": true,\r\n        \"inliner\": true,\r\n        \"jumpdestRemover\": true,\r\n        \"orderLiterals\": true,\r\n        \"deduplicate\": true,\r\n        \"cse\": true,\r\n        \"constantOptimizer\": true,\r\n        \"yulDetails\": {\r\n          \"stackAllocation\": true,\r\n          \"optimizerSteps\": \"dhfoDgvulfnTUtnIf[xa[r]EscLMcCTUtTOntnfDIulLculVcul[j]Tpeulxa[rul]xa[r]cLgvifCTUca[r]LSsTOtfDnca[r]Iulc]jmul[jul]VcTOculjmul\"\r\n        }\r\n      }\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"contract IHangar18\",\"name\":\"_hangar18\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CygnusAltair__0xProjectTransactionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusAltair__AltairXDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusAltair__MsgSenderNotAdmin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusAltair__OneInchTransactionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusAltair__OpenOceanTransactionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusAltair__ParaswapTransactionFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusAltair__ShuttleDoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CygnusAltair__TransactionExpired\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"shuttleId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"lpTokenAddres\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"}],\"name\":\"NewExtension\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"OKX_AGGREGATION_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"ONE_INCH_ROUTER_V5\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OPEN_OCEAN_EXCHANGE_PROXY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"OxPROJECT_EXCHANGE_PROXY\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PARASWAP_AUGUSTUS_SWAPPER_V5\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERMIT2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UNISWAP_V3_ROUTER\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allExtensions\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"altairExtensionsLength\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"borrow\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpTokenPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"cygLPAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"usdAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"},{\"internalType\":\"enum ICygnusAltair.DexAggregator\",\"name\":\"dexAggregator\",\"type\":\"uint8\"},{\"internalType\":\"bytes[]\",\"name\":\"swapdata\",\"type\":\"bytes[]\"}],\"name\":\"deleverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"enum ICygnusAltair.DexAggregator\",\"name\":\"dexAggregator\",\"type\":\"uint8\"},{\"internalType\":\"bytes[]\",\"name\":\"swapdata\",\"type\":\"bytes[]\"}],\"name\":\"flashLiquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolToken\",\"type\":\"address\"}],\"name\":\"getAltairExtension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpTokenPair\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"shares\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"difference\",\"type\":\"uint256\"}],\"name\":\"getAssetsForShares\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"shuttleId\",\"type\":\"uint256\"}],\"name\":\"getShuttleExtension\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"hangar18\",\"outputs\":[{\"internalType\":\"contract IHangar18\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isExtension\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICygnusBorrow\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"latestAccountLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"shortfall\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"latestBorrowerAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionUsd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICygnusBorrow\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"}],\"name\":\"latestBorrowerPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cygLPBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"principal\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionUsd\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionLp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"health\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"latestLenderAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cygUsdBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionUsd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICygnusBorrow\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"lender\",\"type\":\"address\"}],\"name\":\"latestLenderPosition\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"cygUsdBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"positionUsd\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ICygnusBorrow\",\"name\":\"borrowable\",\"type\":\"address\"}],\"name\":\"latestShuttleInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"supplyApr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowApr\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"util\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"lpTokenPair\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collateral\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"usdAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lpAmountMin\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"},{\"internalType\":\"enum ICygnusAltair.DexAggregator\",\"name\":\"dexAggregator\",\"type\":\"uint8\"},{\"internalType\":\"bytes[]\",\"name\":\"swapdata\",\"type\":\"bytes[]\"}],\"name\":\"leverage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"liquidity\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"liquidate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amount\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"}],\"internalType\":\"struct IAllowanceTransfer.PermitDetails\",\"name\":\"details\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sigDeadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAllowanceTransfer.PermitSingle\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"liquidatePermit2Allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.TokenPermissions\",\"name\":\"permitted\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.PermitTransferFrom\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"liquidatePermit2Signature\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"seizeTokens\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nativeToken\",\"outputs\":[{\"internalType\":\"contract IWrappedNative\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"permitData\",\"type\":\"bytes\"}],\"name\":\"repay\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint160\",\"name\":\"amount\",\"type\":\"uint160\"},{\"internalType\":\"uint48\",\"name\":\"expiration\",\"type\":\"uint48\"},{\"internalType\":\"uint48\",\"name\":\"nonce\",\"type\":\"uint48\"}],\"internalType\":\"struct IAllowanceTransfer.PermitDetails\",\"name\":\"details\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sigDeadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IAllowanceTransfer.PermitSingle\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"repayPermit2Allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"borrowable\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountMax\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"borrower\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"components\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.TokenPermissions\",\"name\":\"permitted\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct ISignatureTransfer.PermitTransferFrom\",\"name\":\"_permit\",\"type\":\"tuple\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"repayPermit2Signature\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"shuttleIds\",\"type\":\"uint256[]\"},{\"internalType\":\"address\",\"name\":\"extension\",\"type\":\"address\"}],\"name\":\"setAltairExtension\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sweepNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20[]\",\"name\":\"tokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"sweepTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"usd\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CygnusAltair", "CompilerVersion": "v0.8.17+commit.8df45f5f", "OptimizationUsed": "1", "Runs": "1000000", "ConstructorArguments": "00000000000000000000000094fae55669327e71e9ec579067ad6c3c3b84e574", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}