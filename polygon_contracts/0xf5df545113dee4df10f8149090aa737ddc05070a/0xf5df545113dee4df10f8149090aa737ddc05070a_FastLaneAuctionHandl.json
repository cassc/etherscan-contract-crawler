{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/auction-handler/FastLaneAuctionHandler.sol\": {\r\n      \"content\": \"//SPDX-License-Identifier: Unlicensed\\npragma solidity ^0.8.16;\\n\\nimport \\\"openzeppelin-contracts/contracts/access/Ownable.sol\\\";\\nimport { SafeTransferLib, ERC20 } from \\\"solmate/utils/SafeTransferLib.sol\\\";\\nimport { ReentrancyGuard } from \\\"solmate/utils/ReentrancyGuard.sol\\\";\\n\\n\\nabstract contract FastLaneAuctionHandlerEvents {\\n\\n    event RelayPausedStateSet(bool state);\\n    event RelayValidatorEnabled(address validator, address payee);\\n    event RelayValidatorDisabled(address validator);\\n    event RelayValidatorPayeeUpdated(address validator, address payee, address indexed initiator);\\n    event RelaySimulatorStateSet(bool state);\\n\\n    event RelayInitialized(uint24 initialStakeShare, uint256 minAmount);\\n\\n    event RelayShareSet(uint24 amount);\\n    event RelayShareProposed(uint24 amount, uint256 deadline);\\n    event RelayMinAmountSet(uint256 minAmount);\\n\\n    event RelayFlashBid(address indexed sender, uint256 amount, bytes32 indexed oppTxHash, address indexed validator, address searcherContractAddress);\\n    event RelaySimulatedFlashBid(address indexed sender, uint256 amount, bytes32 indexed oppTxHash, address indexed validator, address searcherContractAddress);\\n\\n    event RelayWithdrawDust(address indexed receiver, uint256 amount);\\n    event RelayWithdrawStuckERC20(\\n        address indexed receiver,\\n        address indexed token,\\n        uint256 amount\\n    );\\n    event RelayWithdrawStuckNativeToken(address indexed receiver, uint256 amount);\\n   \\n\\n    error RelayInequalityTooHigh();\\n\\n    error RelayPermissionPaused();\\n    error RelayPermissionNotFastlaneValidator();\\n    error RelayPermissionSenderNotOrigin();\\n    error RelayPermissionUnauthorized();\\n\\n    error RelayWrongInit();\\n    error RelaySearcherWrongParams();\\n\\n    error RelaySearcherCallFailure(bytes retData);\\n    error RelaySimulatedSearcherCallFailure(bytes retData);\\n    error RelayNotRepaid(uint256 bidAmount, uint256 actualAmount);\\n    error RelaySimulatedNotRepaid(uint256 bidAmount, uint256 actualAmount);\\n\\n    event RelayProcessingPaidValidator(address indexed validator, uint256 validatorPayment, address indexed initiator);\\n    event RelayProcessingWithdrewStakeShare(address indexed recipient, uint256 amountWithdrawn);\\n    error RelayProcessingNoBalancePayable();\\n    error RelayProcessingAmountExceedsBalance(uint256 amountRequested, uint256 balance);\\n    \\n    error RelayAuctionBidReceivedLate();\\n    error RelayAuctionSearcherNotWinner(uint256 current, uint256 existing);\\n\\n    error RelayTimeUnsuitable();\\n    error RelayCannotBeZero();\\n    error RelayCannotBeSelf();\\n}\\n\\n/// @notice Validator Data Struct\\n/// @dev Subject to BLOCK_TIMELOCK for changes\\n/// @param payee Who to pay for this validator\\n/// @param timeUpdated Last time a change was requested for this validator payee\\nstruct ValidatorData {\\n    address payee;\\n    uint256 timeUpdated;\\n}\\n\\ninterface ISearcherContract {\\n    function fastLaneCall(address, uint256, bytes calldata) external payable returns (bool, bytes memory);\\n}\\n\\ncontract FastLaneAuctionHandler is FastLaneAuctionHandlerEvents, Ownable, ReentrancyGuard {\\n\\n    /// @notice Constant delay before the stake share can be changed\\n    uint32 internal constant BLOCK_TIMELOCK = 6 days;\\n\\n    /// @notice Constant base fee\\n    uint24 internal constant FEE_BASE = 1_000_000;\\n\\n\\n\\n\\n    /// @notice If a validator is active or not\\n    mapping(address => bool) public validatorsStatusMap;\\n\\n    /// @notice Mapping to Validator Data Struct\\n    mapping(address => ValidatorData) internal validatorsDataMap;\\n\\n    /// @notice Map[validator] = balance\\n    mapping(address => uint256) public validatorsBalanceMap;\\n\\n    /// @notice Map key is keccak hash of opp tx's gasprice and tx hash\\n    mapping(bytes32 => uint256) public fulfilledAuctionsMap;\\n\\n    uint256 public validatorsTotal;\\n\\n    uint256 public flStakeSharePayable;\\n    uint24 public flStakeShareRatio;\\n\\n    uint24 public proposalStakeShareRatio;\\n    uint256 public proposalDeadline;\\n\\n    uint256 public minRelayBidAmount = 1 ether; // 1 Matic\\n\\n    bool public pendingStakeShareUpdate;\\n    bool public paused;\\n    bool public bid_simulator_enabled = true;\\n\\n    constructor(uint24 _initialStakeShare, uint256 _minRelayBidAmount) {\\n        flStakeShareRatio = _initialStakeShare;\\n        minRelayBidAmount = _minRelayBidAmount;\\n        emit RelayInitialized(_initialStakeShare, _minRelayBidAmount);\\n    }\\n\\n\\n    /// @notice Submits a flash bid\\n    /// @dev Will revert if: already won, minimum bid not respected, not from EOA, or current validator is not participating in PFL.\\n    /// @param _bidAmount Amount committed to be repaid\\n    /// @param _oppTxHash Target Transaction hash\\n    /// @param _searcherToAddress Searcher contract address to be called on its `fastLaneCall` function.\\n    /// @param _searcherCallData callData to be passed to `_searcherToAddress.fastLaneCall(_bidAmount,msg.sender,callData)`\\n    function submitFlashBid(\\n        uint256 _bidAmount, // Value commited to be repaid at the end of execution\\n        bytes32 _oppTxHash, // Target TX\\n        address _searcherToAddress,\\n        bytes calldata _searcherCallData \\n        ) external payable checkBid(_oppTxHash, _bidAmount) onlyParticipatingValidators whenNotPaused onlyEOA nonReentrant {\\n\\n            if (_searcherToAddress == address(0) || _bidAmount < minRelayBidAmount) revert RelaySearcherWrongParams();\\n            \\n            // Store the current balance, excluding msg.value\\n            uint256 balanceBefore = address(this).balance - msg.value;\\n\\n            // Call the searcher's contract (see searcher_contract.sol for example of call receiver)\\n            // And forward msg.value\\n            (bool success, bytes memory retData) = ISearcherContract(_searcherToAddress).fastLaneCall{value: msg.value}(\\n                        msg.sender,\\n                        _bidAmount,\\n                        _searcherCallData\\n            );\\n\\n            if (!success) revert RelaySearcherCallFailure(retData);\\n\\n            // Verify that the searcher paid the amount they bid & emit the event\\n            _handleBalances(_bidAmount, balanceBefore);\\n            emit RelayFlashBid(msg.sender, _bidAmount, _oppTxHash, block.coinbase, _searcherToAddress);\\n    }\\n\\n\\n    /// @notice Submits a SIMULATED flash bid. THE HTTP RELAY won't accept calls for this function.\\n    /// @notice This is just a convenience function for you to test by simulating a call to simulateFlashBid \\n    /// @notice To ensure your calldata correctly works when relayed to `_searcherToAddress`.fastLaneCall(_searcherCallData)\\n    /// @dev This does NOT check that current coinbase is participating in PFL.\\n    /// @dev Only use for testing _searcherCallData\\n    /// @dev You can submit any _bidAmount you like for testing\\n    /// @param _bidAmount Amount committed to be repaid\\n    /// @param _oppTxHash Target Transaction hash\\n    /// @param _searcherToAddress Searcher contract address to be called on its `fastLaneCall` function.\\n    /// @param _searcherCallData callData to be passed to `_searcherToAddress.fastLaneCall(_bidAmount,msg.sender,callData)`\\n    function simulateFlashBid(\\n        uint256 _bidAmount, // Value commited to be repaid at the end of execution, can be set very low in simulated\\n        bytes32 _oppTxHash, // Target TX\\n        address _searcherToAddress,\\n        bytes calldata _searcherCallData \\n        ) external payable nonReentrant whenNotPaused onlyEOA {\\n\\n            // Relax check on min bid amount for simulated\\n            if (_searcherToAddress == address(0) || bid_simulator_enabled == false /* || _bidAmount < minRelayBidAmount */) revert RelaySearcherWrongParams();\\n            \\n            // Store the current balance, excluding msg.value\\n            uint256 balanceBefore = address(this).balance - msg.value;\\n\\n            // Call the searcher's contract (see searcher_contract.sol for example of call receiver)\\n            // And forward msg.value\\n            (bool success, bytes memory retData) = ISearcherContract(_searcherToAddress).fastLaneCall{value: msg.value}(\\n                        msg.sender,\\n                        _bidAmount,\\n                        _searcherCallData\\n            );\\n\\n            if (!success) revert RelaySimulatedSearcherCallFailure(retData);\\n\\n            // Verify that the searcher paid the amount they bid & emit the event\\n            if (address(this).balance < balanceBefore + _bidAmount) {\\n                revert RelaySimulatedNotRepaid(_bidAmount, address(this).balance - balanceBefore);\\n            }\\n            emit RelaySimulatedFlashBid(msg.sender, _bidAmount, _oppTxHash, block.coinbase, _searcherToAddress);\\n    }\\n\\n    /***********************************|\\n    |    Internal Bid Helper Functions  |\\n    |__________________________________*/\\n\\n    function _handleBalances(uint256 _bidAmount, uint256 balanceBefore) internal {\\n        if (address(this).balance < balanceBefore + _bidAmount) {\\n            revert RelayNotRepaid(_bidAmount, address(this).balance - balanceBefore);\\n        }\\n\\n        (uint256 amtPayableToValidator, uint256 amtPayableToStakers) = _calculateStakeShare(_bidAmount, flStakeShareRatio);\\n\\n        validatorsBalanceMap[block.coinbase] += amtPayableToValidator;\\n        validatorsTotal += amtPayableToValidator;\\n        flStakeSharePayable += amtPayableToStakers;\\n    }\\n\\n\\n    /// @notice Internal, calculates shares\\n    /// @param _amount Amount to calculates cuts from\\n    /// @param _share Share bps\\n    /// @return validatorCut Validator cut\\n    /// @return stakeCut Stake cut\\n    function _calculateStakeShare(uint256 _amount, uint24 _share) internal pure returns (uint256 validatorCut, uint256 stakeCut) {\\n        validatorCut = (_amount * (FEE_BASE - _share)) / FEE_BASE;\\n        stakeCut = _amount - validatorCut;\\n    }\\n\\n    receive() external payable {}\\n    fallback() external payable {}\\n\\n\\n    /***********************************|\\n    |             Owner-only            |\\n    |__________________________________*/\\n\\n    /// @notice Defines the paused state of the Auction\\n    /// @dev Only owner\\n    /// @param _state New state\\n    function setPausedState(bool _state) external onlyOwner {\\n        paused = _state;\\n        emit RelayPausedStateSet(_state);\\n    }\\n\\n    /// @notice Defines the paused state of the Simulator\\n    /// @dev Only owner\\n    /// @param _state New state\\n    function setSimulatorState(bool _state) external onlyOwner {\\n        bid_simulator_enabled = _state;\\n        emit RelaySimulatorStateSet(_state);\\n    }\\n\\n    /// @notice Defines the minimum bid\\n    /// @dev Only owner\\n    /// @param _minAmount New minimum amount\\n    function setMininumBidAmount(uint256 _minAmount) external onlyOwner {\\n        minRelayBidAmount = _minAmount;\\n        emit RelayMinAmountSet(_minAmount);\\n    }\\n\\n    /// @notice Sets the stake revenue allocation (out of 1_000_000 (ie v2 fee decimals))\\n    /// @dev Initially set to 50_000 (5%), and pending for 6 days before a change\\n    /// @param _fastLaneStakeShare Protocol stake allocation on bids\\n    function setFastLaneStakeShare(uint24 _fastLaneStakeShare) public onlyOwner {\\n        if (pendingStakeShareUpdate) revert RelayTimeUnsuitable();\\n        if (_fastLaneStakeShare > FEE_BASE) revert RelayInequalityTooHigh();\\n        proposalStakeShareRatio = _fastLaneStakeShare;\\n        proposalDeadline = block.timestamp + BLOCK_TIMELOCK;\\n        pendingStakeShareUpdate = true;\\n        emit RelayShareProposed(_fastLaneStakeShare, proposalDeadline);\\n    }\\n\\n    /// @notice Withdraws fl stake share\\n    /// @dev Owner only\\n    /// @param _recipient Recipient\\n    /// @param _amount Amount\\n    function withdrawStakeShare(address _recipient, uint256 _amount) external onlyOwner nonReentrant {\\n        if (_recipient == address(0) || _amount == 0) revert RelayCannotBeZero();\\n        flStakeSharePayable -= _amount;\\n        SafeTransferLib.safeTransferETH(\\n            _recipient, \\n            _amount\\n        );\\n        emit RelayProcessingWithdrewStakeShare(_recipient, _amount);\\n    }\\n    \\n\\n    /// @notice Enables an address as participating validator, and defining a payee for it\\n    /// @dev Owner only\\n    /// @param _validator Validator address that will be the coinbase of bids\\n    /// @param _payee Address that can withdraw for that validator\\n    function enableRelayValidator(address _validator, address _payee) external onlyOwner {\\n        if (_validator == address(0) || _payee == address(0)) revert RelayCannotBeZero();\\n        if (_payee == address(this)) revert RelayCannotBeSelf();\\n        validatorsStatusMap[_validator] = true;\\n        validatorsDataMap[_validator] = ValidatorData(_payee, block.timestamp - BLOCK_TIMELOCK);\\n        emit RelayValidatorEnabled(_validator, _payee);\\n    }\\n\\n    /// @notice Disables an address as participating validator\\n    /// @dev Owner only\\n    /// @param _validator Validator address\\n    function disableRelayValidator(address _validator) external onlyOwner {\\n        if (_validator == address(0)) revert RelayCannotBeZero();\\n        validatorsStatusMap[_validator] = false;\\n        emit RelayValidatorDisabled(_validator);\\n    }\\n\\n    /// @notice Recover bids repaid to the relay over bidAmount\\n    /// @dev Owner only, can never tap into validator balances nor flStake.\\n    /// @param _amount amount desired, capped to max\\n    function recoverDust(uint256 _amount) \\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        uint256 maxDust = address(this).balance - validatorsTotal - flStakeSharePayable;\\n        if (_amount > maxDust) _amount = maxDust;\\n        SafeTransferLib.safeTransferETH(owner(), _amount);\\n        emit RelayWithdrawDust(owner(), _amount);\\n    }\\n\\n    /// @notice Withdraws stuck matic\\n    /// @dev In the event something went really wrong / vuln report\\n    /// @dev When out of beta role will be moved to gnosis multisig for added safety\\n    /// @param _amount Amount to send to owner\\n    function withdrawStuckNativeToken(uint256 _amount)\\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        if (address(this).balance >= _amount) {\\n            SafeTransferLib.safeTransferETH(owner(), _amount);\\n            emit RelayWithdrawStuckNativeToken(owner(), _amount);\\n        }\\n    }\\n\\n    /// @notice Withdraws stuck ERC20\\n    /// @dev In the event people send ERC20 instead of Matic we can send them back \\n    /// @param _tokenAddress Address of the stuck token\\n    function withdrawStuckERC20(address _tokenAddress)\\n        external\\n        onlyOwner\\n        nonReentrant\\n    {\\n        ERC20 oopsToken = ERC20(_tokenAddress);\\n        uint256 oopsTokenBalance = oopsToken.balanceOf(address(this));\\n\\n        if (oopsTokenBalance > 0) {\\n            SafeTransferLib.safeTransferFrom(oopsToken, address(this), owner(), oopsTokenBalance);\\n            emit RelayWithdrawStuckERC20(address(this), owner(), oopsTokenBalance);\\n        }\\n    }\\n\\n    /***********************************|\\n    |          Validator Functions      |\\n    |__________________________________*/\\n\\n    /// @notice Pays the validator their outstanding balance\\n    /// @dev Callable by either validator address, their payee address (if not changed recently), or PFL.\\n    /// @param _validator Validator address\\n    function payValidator(address _validator) external whenNotPaused nonReentrant onlyValidatorProxy(_validator) returns (uint256) {        \\n        uint256 payableBalance = validatorsBalanceMap[_validator];\\n        if (payableBalance <= 0) revert RelayCannotBeZero();\\n\\n        validatorsTotal -= validatorsBalanceMap[_validator];\\n        validatorsBalanceMap[_validator] = 0;\\n        SafeTransferLib.safeTransferETH(\\n                validatorPayee(_validator), \\n                payableBalance\\n        );\\n        emit RelayProcessingPaidValidator(_validator, payableBalance, msg.sender);\\n        return payableBalance;\\n    }\\n\\n    /// @notice Updates a validator payee\\n    /// @dev Callable by either validator address, their payee address (if not changed recently), or PFL.\\n    /// @param _validator Validator address\\n    function updateValidatorPayee(address _validator, address _payee) external onlyValidatorProxy(_validator) nonReentrant {\\n        if (_payee == address(0)) revert RelayCannotBeZero();\\n        if (_payee == address(this)) revert RelayCannotBeSelf();\\n        if (!validatorsStatusMap[_validator]) revert RelayPermissionNotFastlaneValidator();\\n        validatorsDataMap[_validator].payee = _payee;\\n        validatorsDataMap[_validator].timeUpdated = block.timestamp;\\n\\n        emit RelayValidatorPayeeUpdated(_validator, _payee, msg.sender);   \\n    }\\n\\n    /***********************************|\\n    |             Public                |\\n    |__________________________________*/\\n\\n    /// @notice Activates a pending stake share update\\n    /// @dev Anyone can call it after a 6 days delay\\n    function triggerPendingStakeShareUpdate() external nonReentrant {\\n        if (!pendingStakeShareUpdate || block.timestamp < proposalDeadline) revert RelayTimeUnsuitable();\\n        flStakeShareRatio = proposalStakeShareRatio;\\n        pendingStakeShareUpdate = false;\\n        emit RelayShareSet(proposalStakeShareRatio);\\n    }\\n\\n    /***********************************|\\n    |              Views                |\\n    |__________________________________*/\\n\\n    function isPayeeTimeLocked(address _validator) public view returns (bool _isTimeLocked) {\\n        _isTimeLocked = block.timestamp < validatorsDataMap[_validator].timeUpdated + BLOCK_TIMELOCK;\\n    }\\n\\n    function isValidPayee(address _validator, address _payee) public view returns (bool _valid) {\\n        _valid = !isPayeeTimeLocked(_validator) && _payee == validatorsDataMap[_validator].payee;\\n    }\\n\\n    function validatorPayee(address _validator) internal view returns (address _recipient) {\\n        _recipient = !isPayeeTimeLocked(_validator) ? validatorsDataMap[_validator].payee : _validator;\\n    }\\n\\n    /// @notice Returns validator pending balance\\n    function getValidatorBalance(address _validator) public view returns (uint256 _validatorBalance) {\\n        _validatorBalance = validatorsBalanceMap[_validator];\\n    }\\n\\n    /// @notice Returns the listed payee address regardless of whether or not it has passed the time lock.\\n    function getValidatorPayee(address _validator) public view returns (address _payee) {\\n        _payee = validatorsDataMap[_validator].payee;\\n    }\\n\\n    /// @notice For validators to determine where their payments will go\\n    /// @dev Will return the Payee if blockTimeLock has passed, will return Validator if not.\\n    /// @param _validator Address\\n    function getValidatorRecipient(address _validator) public view returns (address _recipient) {\\n        _recipient = validatorPayee(_validator);\\n    }\\n\\n    function getCurrentStakeRatio() public view returns (uint24) {\\n        return flStakeShareRatio;\\n    }\\n\\n    function getCurrentStakeBalance() public view returns (uint256) {\\n       return flStakeSharePayable;\\n    }\\n\\n    function getPendingStakeRatio() public view returns (uint24 _fastLaneStakeShare) {\\n        _fastLaneStakeShare = pendingStakeShareUpdate ? proposalStakeShareRatio : flStakeShareRatio;\\n    }\\n\\n    function getPendingDeadline() public view returns (uint256 _timeDeadline) {\\n        _timeDeadline = pendingStakeShareUpdate ? proposalDeadline : block.timestamp;\\n    }\\n\\n    function getValidatorStatus(address _validator) public view returns (bool) {\\n        return validatorsStatusMap[_validator];\\n    }\\n\\n    function humanizeError(bytes memory _errorData) public pure returns (string memory decoded) {\\n        uint256 len = _errorData.length;\\n        bytes memory firstPass = abi.decode(slice(_errorData, 4, len-4), (bytes));\\n        decoded = abi.decode(slice(firstPass, 4, firstPass.length-4), (string));\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /***********************************|\\n    |             Modifiers             |\\n    |__________________________________*/\\n\\n    modifier whenNotPaused() {\\n        if (paused) revert RelayPermissionPaused();\\n        _;\\n    }\\n\\n    modifier onlyEOA() {\\n        if (msg.sender != tx.origin) revert RelayPermissionSenderNotOrigin();\\n        _;\\n    }\\n\\n    modifier onlyParticipatingValidators() {\\n        if (!validatorsStatusMap[block.coinbase]) revert RelayPermissionNotFastlaneValidator();\\n        _;\\n    }\\n\\n    modifier onlyValidatorProxy(address _validator) {\\n        // Address never seen before in validatorsDataMap -> impossible to have balance / proxy\\n        if (validatorsDataMap[_validator].payee == address(0)) revert RelayPermissionUnauthorized();\\n\\n        // Validator or owner or valid payee\\n        if (msg.sender != _validator && msg.sender != owner() && !isValidPayee(_validator, msg.sender)) revert RelayPermissionUnauthorized();\\n        _;\\n    }\\n\\n    /// @notice Validates incoming bid\\n    /// @dev \\n    /// @param _oppTxHash Target Transaction hash\\n    /// @param _bidAmount Amount committed to be repaid\\n    modifier checkBid(bytes32 _oppTxHash, uint256 _bidAmount) {\\n        // Use hash of the opportunity tx hash and the transaction's gasprice as key for bid tracking\\n        // This is dependent on the PFL Relay verifying that the searcher's gasprice matches\\n        // the opportunity's gasprice, and that the searcher used the correct opportunity tx hash\\n\\n        bytes32 auction_key = keccak256(abi.encode(_oppTxHash, tx.gasprice));\\n        uint256 existing_bid = fulfilledAuctionsMap[auction_key];\\n\\n        if (existing_bid != 0) {\\n            if (_bidAmount >= existing_bid) {\\n                // This error message could also arise if the tx was sent via mempool\\n                revert RelayAuctionBidReceivedLate();\\n            } else {\\n                revert RelayAuctionSearcherNotWinner(_bidAmount, existing_bid);\\n            }\\n        }\\n\\n        // Mark this auction as being complete to provide quicker reverts for subsequent searchers\\n        fulfilledAuctionsMap[auction_key] = _bidAmount;\\n        _;\\n    }\\n}\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/tokens/ERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*//////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(address => mapping(address => uint256)) public allowance;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address => uint256) public nonces;\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                               ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                             EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline >= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner's nonce which cannot realistically overflow.\\n        unchecked {\\n            address recoveredAddress = ecrecover(\\n                keccak256(\\n                    abi.encodePacked(\\n                        \\\"\\\\x19\\\\x01\\\",\\n                        DOMAIN_SEPARATOR(),\\n                        keccak256(\\n                            abi.encode(\\n                                keccak256(\\n                                    \\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\"\\n                                ),\\n                                owner,\\n                                spender,\\n                                value,\\n                                nonces[owner]++,\\n                                deadline\\n                            )\\n                        )\\n                    )\\n                ),\\n                v,\\n                r,\\n                s\\n            );\\n\\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can't exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user's balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() virtual {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/SafeTransferLib.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\nimport {ERC20} from \\\"../tokens/ERC20.sol\\\";\\n\\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\\n/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/SafeTransferLib.sol)\\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\\n/// @dev Note that none of the functions in this library check that a token has code at all! That responsibility is delegated to the caller.\\nlibrary SafeTransferLib {\\n    /*//////////////////////////////////////////////////////////////\\n                             ETH OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferETH(address to, uint256 amount) internal {\\n        bool success;\\n\\n        assembly {\\n            // Transfer the ETH and store if it succeeded or not.\\n            success := call(gas(), to, amount, 0, 0, 0, 0)\\n        }\\n\\n        require(success, \\\"ETH_TRANSFER_FAILED\\\");\\n    }\\n\\n    /*//////////////////////////////////////////////////////////////\\n                            ERC20 OPERATIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function safeTransferFrom(\\n        ERC20 token,\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), from) // Append the \\\"from\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 68), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 100 because the length of our calldata totals up like so: 4 + 32 * 3.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 100, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FROM_FAILED\\\");\\n    }\\n\\n    function safeTransfer(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"TRANSFER_FAILED\\\");\\n    }\\n\\n    function safeApprove(\\n        ERC20 token,\\n        address to,\\n        uint256 amount\\n    ) internal {\\n        bool success;\\n\\n        assembly {\\n            // Get a pointer to some free memory.\\n            let freeMemoryPointer := mload(0x40)\\n\\n            // Write the abi-encoded calldata into memory, beginning with the function selector.\\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000)\\n            mstore(add(freeMemoryPointer, 4), to) // Append the \\\"to\\\" argument.\\n            mstore(add(freeMemoryPointer, 36), amount) // Append the \\\"amount\\\" argument.\\n\\n            success := and(\\n                // Set success to whether the call reverted, if not we check it either\\n                // returned exactly 1 (can't just be non-zero data), or had no return data.\\n                or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),\\n                // We use 68 because the length of our calldata totals up like so: 4 + 32 * 2.\\n                // We use 0 and 32 to copy up to 32 bytes of return data into the scratch space.\\n                // Counterintuitively, this call must be positioned second to the or() call in the\\n                // surrounding and() call or else returndatasize() will be zero during the computation.\\n                call(gas(), token, 0, freeMemoryPointer, 68, 0, 32)\\n            )\\n        }\\n\\n        require(success, \\\"APPROVE_FAILED\\\");\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"eth-gas-reporter/=node_modules/eth-gas-reporter/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"solmate/=lib/solmate/src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"none\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"_initialStakeShare\",\"type\":\"uint24\"},{\"internalType\":\"uint256\",\"name\":\"_minRelayBidAmount\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"RelayAuctionBidReceivedLate\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"current\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"existing\",\"type\":\"uint256\"}],\"name\":\"RelayAuctionSearcherNotWinner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayCannotBeSelf\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayCannotBeZero\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayInequalityTooHigh\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualAmount\",\"type\":\"uint256\"}],\"name\":\"RelayNotRepaid\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayPermissionNotFastlaneValidator\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayPermissionPaused\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayPermissionSenderNotOrigin\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayPermissionUnauthorized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amountRequested\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"RelayProcessingAmountExceedsBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayProcessingNoBalancePayable\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"retData\",\"type\":\"bytes\"}],\"name\":\"RelaySearcherCallFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelaySearcherWrongParams\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actualAmount\",\"type\":\"uint256\"}],\"name\":\"RelaySimulatedNotRepaid\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"retData\",\"type\":\"bytes\"}],\"name\":\"RelaySimulatedSearcherCallFailure\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayTimeUnsuitable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RelayWrongInit\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"oppTxHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcherContractAddress\",\"type\":\"address\"}],\"name\":\"RelayFlashBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"initialStakeShare\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"RelayInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"minAmount\",\"type\":\"uint256\"}],\"name\":\"RelayMinAmountSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"RelayPausedStateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"validatorPayment\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"RelayProcessingPaidValidator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountWithdrawn\",\"type\":\"uint256\"}],\"name\":\"RelayProcessingWithdrewStakeShare\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"amount\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"RelayShareProposed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"amount\",\"type\":\"uint24\"}],\"name\":\"RelayShareSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"oppTxHash\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"searcherContractAddress\",\"type\":\"address\"}],\"name\":\"RelaySimulatedFlashBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"state\",\"type\":\"bool\"}],\"name\":\"RelaySimulatorStateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"RelayValidatorDisabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"RelayValidatorEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"initiator\",\"type\":\"address\"}],\"name\":\"RelayValidatorPayeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RelayWithdrawDust\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RelayWithdrawStuckERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RelayWithdrawStuckNativeToken\",\"type\":\"event\"},{\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"inputs\":[],\"name\":\"bid_simulator_enabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"disableRelayValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"enableRelayValidator\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flStakeSharePayable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"flStakeShareRatio\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"fulfilledAuctionsMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentStakeBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCurrentStakeRatio\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_timeDeadline\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPendingStakeRatio\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"_fastLaneStakeShare\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"getValidatorBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"_validatorBalance\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"getValidatorPayee\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_payee\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"getValidatorRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"getValidatorStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_errorData\",\"type\":\"bytes\"}],\"name\":\"humanizeError\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"decoded\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"isPayeeTimeLocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_isTimeLocked\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"isValidPayee\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"_valid\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"minRelayBidAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"}],\"name\":\"payValidator\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingStakeShareUpdate\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalDeadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proposalStakeShareRatio\",\"outputs\":[{\"internalType\":\"uint24\",\"name\":\"\",\"type\":\"uint24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"recoverDust\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint24\",\"name\":\"_fastLaneStakeShare\",\"type\":\"uint24\"}],\"name\":\"setFastLaneStakeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_minAmount\",\"type\":\"uint256\"}],\"name\":\"setMininumBidAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setPausedState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setSimulatorState\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_oppTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_searcherToAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_searcherCallData\",\"type\":\"bytes\"}],\"name\":\"simulateFlashBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_bidAmount\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_oppTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_searcherToAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_searcherCallData\",\"type\":\"bytes\"}],\"name\":\"submitFlashBid\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"triggerPendingStakeShareUpdate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_validator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_payee\",\"type\":\"address\"}],\"name\":\"updateValidatorPayee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validatorsBalanceMap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"validatorsStatusMap\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"validatorsTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStakeShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"withdrawStuckERC20\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawStuckNativeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "FastLaneAuctionHandler", "CompilerVersion": "v0.8.16+commit.07a7930e", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000000000000000000000000000000000000000c35000000000000000000000000000000000000000000000000000000000000186a0", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}