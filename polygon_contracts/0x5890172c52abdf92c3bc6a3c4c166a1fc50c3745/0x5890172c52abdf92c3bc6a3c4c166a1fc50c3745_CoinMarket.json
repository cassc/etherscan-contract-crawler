{"SourceCode": "// File: token/IERC20.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ninterface IERC20 {\r\n\r\n    /// MUST trigger when tokens are transferred, including zero value transfers.\r\n    /// A token contract which creates new tokens SHOULD trigger a Transfer event with \r\n    ///  the _from address set to 0x0 when tokens are created.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /// MUST trigger on any successful call to approve(address _spender, uint256 _value).\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    /// Returns the total token supply.\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// Returns the account balance of another account with address _owner.\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /// Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. \r\n    /// The function SHOULD throw if the message caller\u2019s account balance does not have enough tokens to spend.\r\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event.\r\n    /// The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. \r\n    /// This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies. \r\n    /// The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism.\r\n    /// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// Allows _spender to withdraw from your account multiple times, up to the _value amount. \r\n    /// If this function is called again it overwrites the current allowance with _value.\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /// Returns the amount which _spender is still allowed to withdraw from _owner.\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n}\r\n// File: security/AccessControl.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\ncontract AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant NO_PERMISSION='no permission';\r\n    string constant INVALID_ADDRESS ='invalid address';\r\n    \r\n    /// @dev Administrator with highest authority. Should be a multisig wallet.\r\n    address payable superAdmin;\r\n\r\n    /// @dev Administrator of this contract.\r\n    address payable admin;\r\n\r\n    /// Sets the original admin and superAdmin of the contract to the sender account.\r\n    constructor(){\r\n        superAdmin=payable(msg.sender);\r\n        admin=payable(msg.sender);\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the superAdmin.\r\n    modifier onlySuperAdmin{\r\n        require(msg.sender==superAdmin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Throws if called by any account other than the admin.\r\n    modifier onlyAdmin{\r\n        require(msg.sender==admin,NO_PERMISSION);\r\n        _;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change superAdmin.\r\n    /// @param addr The address to transfer the right of superAdmin to.\r\n    function changeSuperAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        superAdmin=addr;\r\n    }\r\n\r\n    /// @dev Allows the current superAdmin to change admin.\r\n    /// @param addr The address to transfer the right of admin to.\r\n    function changeAdmin(address payable addr) external onlySuperAdmin{\r\n        require(addr!=payable(address(0)),INVALID_ADDRESS);\r\n        admin=addr;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to withdraw balance.\r\n    function withdrawBalance(uint256 amount) external onlySuperAdmin{\r\n        superAdmin.transfer(amount);\r\n    }\r\n\r\n    fallback() external {}\r\n}\r\n// File: security/Pausable.sol\r\n\r\npragma solidity >=0.8.0 <0.9.0;\r\n\r\n\r\ncontract Pausable is AccessControl{\r\n\r\n    /// @dev Error message.\r\n    string constant PAUSED='paused';\r\n    string constant NOT_PAUSED='not paused';\r\n\r\n    /// @dev Keeps track whether the contract is paused. When this is true, most actions are blocked.\r\n    bool public paused = false;\r\n\r\n    /// @dev Modifier to allow actions only when the contract is not paused\r\n    modifier whenNotPaused {\r\n        require(!paused,PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract is paused\r\n    modifier whenPaused {\r\n        require(paused,NOT_PAUSED);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by superAdmin to pause the contract. Used when something goes wrong\r\n    ///  and we need to limit damage.\r\n    function pause() external onlySuperAdmin whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the superAdmin.\r\n    function unpause() external onlySuperAdmin whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n// File: CoinMarket.sol\r\n\r\npragma solidity ^0.8.4;\r\n\r\n\r\n\r\ncontract CoinMarket is Pausable {\r\n    /// @dev Error message.\r\n    string constant WRONG_PARAMETER = \"wrong parameter\";\r\n    string constant ADDRESS_NOT_SET = \"coin address not set\";\r\n    string constant MATIC_NOT_ENOUGH = \"Matic not enough\";\r\n    string constant ID_NOT_EXISTS = \"id not exists\";\r\n\r\n    /// @dev Save address of coinA/B/C sequentially.\r\n    address[3] public coinAddresses;\r\n\r\n    /// @dev Used as id of order.\r\n    uint256 orderCount;\r\n\r\n    /// @dev This event should be fired whenever address in coinAddresses is modified.\r\n    event CoinAddressesChanged(\r\n        uint256 indexed coinType,\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _time\r\n    );\r\n\r\n    /// @dev This event should be fired whenever an order is set.\r\n    event OrderSet(\r\n        uint256 indexed id,\r\n        uint256 indexed coinType,\r\n        address indexed launcher,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 unit,\r\n        bool label\r\n    );\r\n\r\n    event OrderBid(uint256 indexed id, uint256 amount);\r\n\r\n    event OrderCancel(uint256 indexed id, address indexed canceler);\r\n\r\n    struct Order {\r\n        uint256 id; //order identity\r\n        uint256 coinType; //order type, 0/1/2 represents coinA/B/C\r\n        address launcher; //who build this order\r\n        uint256 left;\r\n        uint256 price;\r\n        uint256 unit; //the least unit\r\n        bool label; //true means sell, false means buy\r\n    }\r\n\r\n    Order[] Orders;\r\n\r\n    /// @dev Mapping from id to index of Oreders.\r\n    mapping(uint256 => uint256) idToIndex;\r\n    /// @dev Whether an id exists.\r\n    mapping(uint256 => bool) idExist;\r\n\r\n    modifier validId(uint256 id) {\r\n        require(idExist[id], ID_NOT_EXISTS);\r\n        _;\r\n    }\r\n\r\n    /// @dev Present all orders.\r\n    function presentOrders() external view returns (Order[] memory) {\r\n        return Orders;\r\n    }\r\n\r\n    /// @dev Present one order.\r\n    function presentOneOrder(uint256 id) external validId(id) view returns (Order memory) {\r\n        return Orders[idToIndex[id]];\r\n    }\r\n\r\n    /// @dev Change coinAddress.\r\n    ///  Caller should always be superAdmin. addr is new address of coinType.\r\n    function changeCoinAddresses(uint256 coinType, address addr)\r\n        external\r\n        onlySuperAdmin\r\n    {\r\n        emit CoinAddressesChanged(\r\n            coinType,\r\n            coinAddresses[coinType],\r\n            addr,\r\n            block.timestamp\r\n        );\r\n        coinAddresses[coinType] = addr;\r\n    }\r\n\r\n    /// @dev Seller pending order selling coinA/B/C. Seller should call increaseAllowance in advance.\r\n    ///  Since addr is set by superAdmin, we don't have to worry about re-entrancy attack here.\r\n    function setSell(\r\n        uint256 coinType,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 unit\r\n    ) external whenNotPaused {\r\n        require(\r\n            amount >= unit && unit > 0 && amount % unit == 0,\r\n            WRONG_PARAMETER\r\n        );\r\n        address addr = coinAddresses[coinType];\r\n        require(addr != address(0), ADDRESS_NOT_SET);\r\n        idToIndex[orderCount] = Orders.length;\r\n        idExist[orderCount] = true;\r\n        Order memory _Order = Order({\r\n            id: orderCount,\r\n            coinType: coinType,\r\n            launcher: msg.sender,\r\n            left: amount,\r\n            price: price,\r\n            unit: unit,\r\n            label: true\r\n        });\r\n        Orders.push(_Order);\r\n        emit OrderSet(\r\n            orderCount,\r\n            coinType,\r\n            msg.sender,\r\n            amount,\r\n            price,\r\n            unit,\r\n            true\r\n        );\r\n        orderCount++;\r\n        IERC20 sc = IERC20(addr);\r\n        sc.transferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function bidSell(uint256 id, uint256 amount)\r\n        external\r\n        payable\r\n        whenNotPaused\r\n        validId(id)\r\n    {\r\n        uint256 index = idToIndex[id];\r\n        Order memory _Order = Orders[index];\r\n        require(amount % _Order.unit == 0, WRONG_PARAMETER);\r\n        require(_Order.label, WRONG_PARAMETER);\r\n        uint256 chargeAmount = amount * _Order.price;\r\n        require(msg.value >= chargeAmount, MATIC_NOT_ENOUGH);\r\n        Orders[index].left -= amount;\r\n        if (Orders[index].left == 0) {\r\n            removeInternalState(id);\r\n        }\r\n        IERC20 sc = IERC20(coinAddresses[_Order.coinType]);\r\n        sc.transfer(msg.sender, amount);\r\n        payable(_Order.launcher).transfer((chargeAmount * 9475) / 10000);\r\n        if (msg.value > chargeAmount) {\r\n            payable(msg.sender).transfer(msg.value - chargeAmount);\r\n        }\r\n        emit OrderBid(id,amount);\r\n    }\r\n\r\n    /// @dev Buyer pending order buying coinA/B/C.\r\n    function setBuy(\r\n        uint256 coinType,\r\n        uint256 amount,\r\n        uint256 price,\r\n        uint256 unit\r\n    ) external payable whenNotPaused {\r\n        require(\r\n            amount >= unit && unit > 0 && amount % unit == 0,\r\n            WRONG_PARAMETER\r\n        );\r\n        require(coinAddresses[coinType] != address(0), ADDRESS_NOT_SET);\r\n        uint256 chargeAmount = (price * amount * 10525) / 10000;\r\n        require(msg.value >= chargeAmount, MATIC_NOT_ENOUGH);\r\n        idToIndex[orderCount] = Orders.length;\r\n        idExist[orderCount] = true;\r\n        Order memory _Order = Order({\r\n            id: orderCount,\r\n            coinType: coinType,\r\n            launcher: msg.sender,\r\n            left: amount,\r\n            price: price,\r\n            unit: unit,\r\n            label: false\r\n        });\r\n        Orders.push(_Order);\r\n        emit OrderSet(\r\n            orderCount,\r\n            coinType,\r\n            msg.sender,\r\n            amount,\r\n            price,\r\n            unit,\r\n            false\r\n        );\r\n        orderCount++;\r\n        if (msg.value > chargeAmount) {\r\n            payable(msg.sender).transfer(msg.value - chargeAmount);\r\n        }\r\n    }\r\n\r\n    /// @dev Caller should call increaseAllowance in advance.\r\n    function bidBuy(uint256 id, uint256 amount)\r\n        external\r\n        whenNotPaused\r\n        validId(id)\r\n    {\r\n        uint256 index = idToIndex[id];\r\n        Order memory _Order = Orders[index];\r\n        require(amount % _Order.unit == 0, WRONG_PARAMETER);\r\n        require(!_Order.label, WRONG_PARAMETER);\r\n        address addr = coinAddresses[_Order.coinType];\r\n        Orders[index].left -= amount;\r\n        if (Orders[index].left == 0) {\r\n            removeInternalState(id);\r\n        }\r\n        IERC20 sc = IERC20(addr);\r\n        sc.transferFrom(msg.sender, _Order.launcher, amount);\r\n        payable(msg.sender).transfer(amount * _Order.price);\r\n        emit OrderBid(id,amount);\r\n    }\r\n\r\n    /// @dev Launcher cancel order.\r\n    ///  Since sc is set by superAdmin, we don't have to worry about re-entrancy attack here.\r\n    function cancelSell(uint256 id) external whenNotPaused validId(id) {\r\n        require(msg.sender == Orders[idToIndex[id]].launcher, NO_PERMISSION);\r\n        removeOrder(id);\r\n    }\r\n\r\n    /// @dev Launcher cancel order.\r\n    ///  Since sc is set by superAdmin, we don't have to worry about re-entrancy attack here.\r\n    function cancelSellAdmin(uint256 id) external whenPaused onlyAdmin validId(id) {\r\n        removeOrder(id);\r\n    }\r\n\r\n    function removeInternalState(uint256 id) internal {\r\n        delete idExist[id];\r\n        uint256 index = idToIndex[id];\r\n        delete idToIndex[id];\r\n        uint256 l = Orders.length - 1;\r\n        uint256 lastId = Orders[l].id;\r\n        Orders[index] = Orders[l];\r\n        Orders.pop();\r\n        idToIndex[lastId] = index;\r\n    }\r\n\r\n    /// @dev Internal function used to remove order.\r\n    ///  Since sc is set by superAdmin, we don't have to worry about re-entrancy attack here.\r\n    function removeOrder(uint256 id) internal {\r\n        uint256 index = idToIndex[id];\r\n        Order memory _Order = Orders[index];\r\n        uint256 amount = _Order.left;\r\n        removeInternalState(id);\r\n        emit OrderCancel(id, msg.sender);\r\n        if (_Order.label) {\r\n            IERC20 sc = IERC20(coinAddresses[_Order.coinType]);\r\n            sc.transfer(_Order.launcher, amount);\r\n        } else {\r\n            payable(_Order.launcher).transfer(\r\n                (amount * _Order.price * 10525) / 10000\r\n            );\r\n        }\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"CoinAddressesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OrderBid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"canceler\",\"type\":\"address\"}],\"name\":\"OrderCancel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"launcher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"label\",\"type\":\"bool\"}],\"name\":\"OrderSet\",\"type\":\"event\"},{\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bidBuy\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bidSell\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"cancelSellAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeCoinAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"changeSuperAdmin\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"coinAddresses\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"presentOneOrder\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"launcher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"left\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"label\",\"type\":\"bool\"}],\"internalType\":\"struct CoinMarket.Order\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"presentOrders\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"launcher\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"left\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unit\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"label\",\"type\":\"bool\"}],\"internalType\":\"struct CoinMarket.Order[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unit\",\"type\":\"uint256\"}],\"name\":\"setBuy\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"coinType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"price\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"unit\",\"type\":\"uint256\"}],\"name\":\"setSell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBalance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "CoinMarket", "CompilerVersion": "v0.8.4+commit.c7e474f2", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "None", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://ead16b4c561c5951d4e0e080bb8e847bad6d3a83d9bfc3102c04554ace002c1b"}