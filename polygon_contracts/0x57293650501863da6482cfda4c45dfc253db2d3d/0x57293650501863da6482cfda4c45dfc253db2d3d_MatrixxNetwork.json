{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.21 <0.7.0;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\nabstract contract ERC20Basic {\r\n  function totalSupply() public virtual view returns (uint256);\r\n  function balanceOf(address who) public virtual view returns (uint256);\r\n  function transfer(address to, uint256 value) public virtual returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n//..............................................................................................\r\n\r\nabstract contract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public virtual view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public virtual returns (bool);\r\n  function approve(address spender, uint256 value) public virtual returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n//..................................................................................................\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n  uint256 constant public buy_tax = 100;\r\n  uint256 constant public sell_tax = 150;\r\n  uint256 constant public tax_divider = 1000;\r\n  address contractAddress;\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public override view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n   \r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public override returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    uint256 tax = _value.mul(buy_tax).div(tax_divider);\r\n    uint256 amountToReceive = _value - tax;\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(amountToReceive);\r\n    balances[contractAddress] = balances[contractAddress].add(tax);\r\n    emit Transfer(msg.sender, _to, amountToReceive);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public  override view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n//........................................................................................\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public override returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    uint256 tax = _value.mul(sell_tax).div(tax_divider);\r\n    uint256 amountToReceive = _value - tax;\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(amountToReceive);\r\n    balances[contractAddress] = balances[contractAddress].add(tax);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, amountToReceive);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public override returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public override view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n//....................................................................................\r\n\r\ncontract TRIXXToken is StandardToken {\r\n  address public administrator;\r\n  string public constant name = \"Matrixx Community Token\";\r\n  string public constant symbol = \"TRIXX\";\r\n  uint public constant decimals = 18;\r\n  uint256 public constant INITIAL_SUPPLY = 10000000 * (10 ** decimals);\r\n\r\n\r\n   modifier onlyAdminstrator(){\r\n     require(administrator == msg.sender, \"requires admin priviledge\");\r\n     _;\r\n   }\r\n\r\n}\r\n\r\n\r\ncontract MatrixxNetwork is TRIXXToken{\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public INVEST_MIN_AMOUNT = 10 ether;\r\n\tuint256[] public REFERRAL_PERCENTS = [50, 25, 5];\r\n\tuint256 public VAULT_TAX = 100;\r\n  uint256 constant public REINVEST_TAX = 50;\r\n  uint256 public MIN_REINVEST_AMOUNT = 1000 ether;\r\n  uint256 constant public PROJECT_FEE = 50;\r\n\tuint256 constant public PERCENT_STEP = 0;\r\n  uint256  public WITHDRAW_FEE = 2000; //In base point\r\n\tuint256 constant public PERCENTS_DIVIDER = 1000;\r\n\tuint256 constant public TIME_STEP = 1 days;\r\n  uint256 public airdropMaxTotal = 1600000 ether;\r\n  uint256 public airdropClaimedTotal = 0;\r\n\r\n\r\n\tuint256 public totalStaked;\r\n\tuint256 public totalRefBonus;\r\n\r\n    struct Plan {\r\n        uint256 time;\r\n        uint256 percent;\r\n    }\r\n\r\n    Plan[] internal plans;\r\n\r\n\tstruct Deposit {\r\n        uint8 plan;\r\n\t\tuint256 percent;\r\n\t\tuint256 amount;\r\n\t\tuint256 profit;\r\n\t\tuint256 start;\r\n\t\tuint256 finish;\r\n\t}\r\n\r\n\tstruct User {\r\n\t\tDeposit[] deposits;\r\n\t\tuint256 checkpoint;\r\n\t\taddress referrer;\r\n\t\tuint256[3] levels;\r\n\t\tuint256 bonus;\r\n\t\tuint256 totalBonus;\r\n    uint256 amountWithdrawn;\r\n\t}\r\n\r\n\tmapping (address => User) internal users;\r\n\r\n\tuint256 public startUNIX;\r\n\taddress payable public commissionWallet;\r\n\r\n\tevent Newbie(address user);\r\n\tevent NewDeposit(address indexed user, uint8 plan, uint256 percent, uint256 amount, uint256 profit, uint256 start, uint256 finish);\r\n\tevent Withdrawn(address indexed user, uint256 amount);\r\n\tevent RefBonus(address indexed referrer, address indexed referral, uint256 indexed level, uint256 amount);\r\n\tevent FeePayed(address indexed user, uint256 totalAmount);\r\n  event PayOut(address receiver, uint256 amount);\r\n\r\n  function contractTx (address to, uint256 value) internal {\r\n        require(balances[contractAddress] >= value, \"contract balance is low\");\r\n        balances[contractAddress] = balances[contractAddress].sub(value);\r\n        balances[to] = balances[to].add(value);\r\n        emit PayOut(to, value);\r\n  }\r\n\r\n\r\n\tconstructor(address payable wallet, uint256 startDate) public {\r\n\t\trequire(!isContract(wallet));\r\n\t\trequire(startDate > 0);\r\n\t\tcommissionWallet = wallet;\r\n\t\tstartUNIX = startDate;\r\n\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        administrator = msg.sender;\r\n        contractAddress = address(this);\r\n        balances[contractAddress] = INITIAL_SUPPLY;\r\n        contractTx (administrator, 250000 ether);\r\n\r\n        plans.push(Plan(365, 20));\r\n        plans.push(Plan(90, 19));\r\n        plans.push(Plan(180, 12));\r\n\t}\r\n\r\n\tfunction invest(address referrer, uint8 plan, uint amountToStake) public  {\r\n\t\trequire(amountToStake >= INVEST_MIN_AMOUNT, \"below minimum invest amount\");\r\n    require(balances[msg.sender] >= amountToStake, \"Insufficient funds\");\r\n    require(plan < 3, \"Invalid plan\");\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(amountToStake);\r\n    balances[contractAddress] = balances[contractAddress].add(amountToStake);\r\n\r\n\t\tuint256 fee = amountToStake.mul(VAULT_TAX).div(PERCENTS_DIVIDER);\r\n    uint256 _projectFees  = amountToStake.mul(PROJECT_FEE).div(PERCENTS_DIVIDER);\r\n    uint256 _amountMinusFees  = amountToStake.sub(fee);\r\n    \r\n    contractTx (commissionWallet, _projectFees);\r\n        \r\n\t\temit FeePayed(msg.sender, fee);\r\n\r\n\t\tUser storage user = users[msg.sender]; \r\n\r\n\t\tif (user.referrer == address(0)) {\r\n\t\t\tif (users[referrer].deposits.length > 0 && referrer != msg.sender) {\r\n\t\t\t\tuser.referrer = referrer;\r\n\t\t\t}\r\n\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < 3; i++) {\r\n\t\t\t\tif (upline != address(0)) {\r\n\t\t\t\t\tusers[upline].levels[i] = users[upline].levels[i].add(1);\r\n\t\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t\t} else break;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (user.referrer != address(0)) {\r\n\r\n\t\t\taddress upline = user.referrer;\r\n\t\t\tfor (uint256 i = 0; i < 3; i++) {\r\n\t\t\t\tif (upline != address(0)) {\r\n\t\t\t\t\tuint256 amount = _amountMinusFees.mul(REFERRAL_PERCENTS[i]).div(PERCENTS_DIVIDER);\r\n\t\t\t\t\tusers[upline].bonus = users[upline].bonus.add(amount);\r\n\t\t\t\t\tusers[upline].totalBonus = users[upline].totalBonus.add(amount);\r\n\t\t\t\t\temit RefBonus(upline, msg.sender, i, amount);\r\n\t\t\t\t\tupline = users[upline].referrer;\r\n\t\t\t\t} else break;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif (user.deposits.length == 0) {\r\n\t\t\tuser.checkpoint = block.timestamp;\r\n\t\t\temit Newbie(msg.sender);\r\n\t\t}\r\n\r\n\t\t(uint256 percent, uint256 profit, uint256 finish) = getResult(plan, _amountMinusFees);\r\n\t\tuser.deposits.push(Deposit(plan, percent, _amountMinusFees, profit, block.timestamp, finish));\r\n\r\n\t\ttotalStaked = totalStaked.add(_amountMinusFees);\r\n\t\temit NewDeposit(msg.sender, plan, percent, _amountMinusFees, profit, block.timestamp, finish);\r\n\t}\r\n\r\n\r\nfunction reInvestEarnings(uint8 plan) public  {\r\n      User storage user = users[msg.sender];\r\n      require(user.deposits.length > 0);\r\n      require(plan < 3, \"Invalid plan\");\r\n\r\n      uint256 totalAmount = getUserDividends(msg.sender);\r\n      uint256 referralBonus = getUserReferralBonus(msg.sender);\r\n      if (referralBonus > 0) {\r\n          user.bonus = 0;\r\n          totalAmount = totalAmount.add(referralBonus);           \r\n      }\r\n\r\n      require(totalAmount  >= MIN_REINVEST_AMOUNT);\r\n\t  \tuint256 contractBalance = balances[contractAddress];\r\n\r\n      if (contractBalance < totalAmount) {\r\n          vaultMint(totalAmount);\r\n      }\r\n\r\n\t\t  user.checkpoint = block.timestamp;  \r\n\r\n      uint256 fee = totalAmount.mul(REINVEST_TAX).div(PERCENTS_DIVIDER);\r\n      uint256 _amountMinusFees  = totalAmount.sub(fee);\r\n               \r\n      (uint256 percent, uint256 profit, uint256 finish) = getResult(plan, _amountMinusFees);\r\n      user.deposits.push(Deposit(plan, percent, _amountMinusFees, profit, block.timestamp, finish));\r\n\r\n      totalStaked = totalStaked.add(_amountMinusFees);\r\n      emit NewDeposit(msg.sender, plan, percent, _amountMinusFees, profit, block.timestamp, finish);\r\n\t}\r\n\r\n\r\n\r\n\r\n\tfunction withdraw() public {\r\n\t\tUser storage user = users[msg.sender];\r\n\r\n\t\tuint256 totalAmount = getUserDividends(msg.sender);\r\n\t\tuint256 fees = totalAmount.mul(WITHDRAW_FEE).div(10000);\r\n\t\t        totalAmount = totalAmount.sub(fees);\r\n\r\n\t\tuint256 referralBonus = getUserReferralBonus(msg.sender);\r\n\t\tif (referralBonus > 0) {\r\n\t\t\tuser.bonus = 0;\r\n            uint256 refFees = referralBonus.mul(WITHDRAW_FEE).div(10000);\r\n            referralBonus = referralBonus.sub(refFees);\r\n\t\t\ttotalAmount = totalAmount.add(referralBonus);\r\n            \r\n\t\t}\r\n\r\n\t\trequire(totalAmount > 0, \"User has no dividends\");\r\n\r\n\t\tuint256 contractBalance = balances[contractAddress];\r\n\t\tif (contractBalance < totalAmount) {\r\n\t\t\t  vaultMint(totalAmount);\r\n\t\t}\r\n\r\n\t\tuser.checkpoint = block.timestamp;\r\n    \r\n    uint256 _projectFees  = totalAmount.mul(PROJECT_FEE).div(PERCENTS_DIVIDER);\r\n    contractTx (commissionWallet, _projectFees);\r\n\t\tcontractTx(msg.sender, totalAmount);\r\n    \r\n    user.amountWithdrawn = user.amountWithdrawn.add(totalAmount);\r\n\t\temit Withdrawn(msg.sender, totalAmount);\r\n\r\n\t}\r\n\r\n  function vaultMint(uint256 amount) internal {\r\n\t  \ttotalSupply_ = totalSupply_.add(amount);\r\n      balances[contractAddress] = balances[contractAddress].add(amount);\r\n\t}\r\n\r\n\tfunction getContractBalance() public view returns (uint256) {\r\n\t\treturn balances[contractAddress];\r\n\t}\r\n\r\n\tfunction getPlanInfo(uint8 plan) public view returns(uint256 time, uint256 percent) {\r\n\t\ttime = plans[plan].time;\r\n\t\tpercent = plans[plan].percent;\r\n\t}\r\n\r\n  function updateMinReinvestAmount (uint256 value) onlyAdminstrator public  {\r\n         MIN_REINVEST_AMOUNT = value;\r\n  }\r\n\r\n  function updateMinInvestAmount (uint256 value) onlyAdminstrator public  {\r\n         INVEST_MIN_AMOUNT = value;\r\n  }\r\n\r\n  function updateTaxFees (uint8 index, uint256 value) onlyAdminstrator public  {\r\n         if(index == 0 && value <= 150) {\r\n            VAULT_TAX = value;\r\n         }else if(index == 1 && value < 3000) {\r\n            WITHDRAW_FEE = value;\r\n         }\r\n  }\r\n\r\n\tfunction getPercent(uint8 plan) public view returns (uint256) {\r\n\t\t\t return plans[plan].percent;\r\n    }\r\n\r\n\tfunction getResult(uint8 plan, uint256 deposit) public view returns (uint256 percent, uint256 profit, uint256 finish) {\r\n\t\tpercent = getPercent(plan);\r\n\r\n\t\tif (plan == 0) {\r\n\t\t\tprofit = deposit.mul(percent).div(PERCENTS_DIVIDER).mul(plans[plan].time);\r\n\t\t} else if (plan < 3) {\r\n\t\t\tfor (uint256 i = 0; i < plans[plan].time; i++) {\r\n\t\t\t\tprofit = profit.add((deposit.add(profit)).mul(percent).div(PERCENTS_DIVIDER));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfinish = block.timestamp.add(plans[plan].time.mul(TIME_STEP));\r\n\t}\r\n\r\n\tfunction getUserDividends(address userAddress) public view returns (uint256) {\r\n\t\tUser storage user = users[userAddress];\r\n\r\n\t\tuint256 totalAmount;\r\n\r\n\t\tfor (uint256 i = 0; i < user.deposits.length; i++) {\r\n\t\t\tif (user.checkpoint < user.deposits[i].finish) {\r\n\t\t\t\tif (user.deposits[i].plan == 0) {\r\n\t\t\t\t\tuint256 share = user.deposits[i].amount.mul(user.deposits[i].percent).div(PERCENTS_DIVIDER);\r\n\t\t\t\t\tuint256 from = user.deposits[i].start > user.checkpoint ? user.deposits[i].start : user.checkpoint;\r\n\t\t\t\t\tuint256 to = user.deposits[i].finish < block.timestamp ? user.deposits[i].finish : block.timestamp;\r\n\t\t\t\t\tif (from < to) {\r\n\t\t\t\t\t\ttotalAmount = totalAmount.add(share.mul(to.sub(from)).div(TIME_STEP));\r\n\t\t\t\t\t}\r\n\t\t\t\t} else if (block.timestamp > user.deposits[i].finish) {\r\n\t\t\t\t\ttotalAmount = totalAmount.add(user.deposits[i].profit);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn totalAmount;\r\n\t}\r\n\r\n\tfunction getUserCheckpoint(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].checkpoint;\r\n\t}\r\n\r\n\tfunction getUserReferrer(address userAddress) public view returns(address) {\r\n\t\treturn users[userAddress].referrer;\r\n\t}\r\n\r\n\tfunction getUserDownlineCount(address userAddress) public view returns(uint256, uint256, uint256) {\r\n\t\treturn (users[userAddress].levels[0], users[userAddress].levels[1], users[userAddress].levels[2]);\r\n\t}\r\n\r\n\tfunction getUserReferralBonus(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].bonus;\r\n\t}\r\n\r\n\tfunction getUserReferralTotalBonus(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].totalBonus;\r\n\t}\r\n\r\n\tfunction getUserReferralWithdrawn(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].totalBonus.sub(users[userAddress].bonus);\r\n\t}\r\n\r\n\tfunction getUserAvailable(address userAddress) public view returns(uint256) {\r\n\t\treturn getUserReferralBonus(userAddress).add(getUserDividends(userAddress));\r\n\t}\r\n\r\n\tfunction getUserAmountOfDeposits(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].deposits.length;\r\n\t}\r\n\r\n  function getUserAmountWithdrawn(address userAddress) public view returns(uint256) {\r\n\t\treturn users[userAddress].amountWithdrawn;\r\n\t}\r\n\r\n\tfunction getUserTotalDeposits(address userAddress) public view returns(uint256 amount) {\r\n\t\tfor (uint256 i = 0; i < users[userAddress].deposits.length; i++) {\r\n\t\t\tamount = amount.add(users[userAddress].deposits[i].amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getUserDepositInfo(address userAddress, uint256 index) public view returns(uint8 plan, uint256 percent, uint256 amount, uint256 profit, uint256 start, uint256 finish) {\r\n\t    User storage user = users[userAddress];\r\n\r\n\t\tplan = user.deposits[index].plan;\r\n\t\tpercent = user.deposits[index].percent;\r\n\t\tamount = user.deposits[index].amount;\r\n\t\tprofit = user.deposits[index].profit;\r\n\t\tstart = user.deposits[index].start;\r\n\t\tfinish = user.deposits[index].finish;\r\n\t}\r\n\r\n\tfunction isContract(address addr) internal view returns (bool) {\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n  }\r\n\r\n  struct QualifiedWallet {\r\n      uint256 amount;\r\n      address wallet;\r\n      bool claimed;\r\n\t}\r\n\r\n  mapping (address => QualifiedWallet) qualifiedWallets;\r\n  event Claimed(address receiver, uint256 amount);\r\n\r\n  function snapshot (QualifiedWallet[] calldata list) onlyAdminstrator public  {    \r\n       require(startUNIX > block.timestamp, \"Addresses can only be recorded before contract starts\");  \r\n       for (uint256 i = 0; i < list.length; i++) {\r\n           qualifiedWallets[list[i].wallet].wallet = list[i].wallet;\r\n           qualifiedWallets[list[i].wallet].amount = list[i].amount;\r\n\t\t\t}\r\n  }\r\n\r\n  function claimAirdrop () public {\r\n      require(qualifiedWallets[msg.sender].claimed == false, \"Airdrop has been cliamed\");\r\n      require(airdropClaimedTotal <= airdropMaxTotal && qualifiedWallets[msg.sender].amount < airdropMaxTotal\r\n           , \"reached max airdrop total\");\r\n      contractTx(qualifiedWallets[msg.sender].wallet, qualifiedWallets[msg.sender].amount);\r\n      airdropClaimedTotal += qualifiedWallets[msg.sender].amount;\r\n      qualifiedWallets[msg.sender].claimed = true;\r\n      qualifiedWallets[msg.sender].amount = 0;\r\n  }\r\n\r\n  function checkAirdrop (address userAddress ) view public returns(QualifiedWallet memory) {\r\n      QualifiedWallet storage user = qualifiedWallets[userAddress];\r\n      return qualifiedWallets[user.wallet];\r\n  }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"address payable\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startDate\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAmount\",\"type\":\"uint256\"}],\"name\":\"FeePayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"Newbie\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"referral\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawn\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INVEST_MIN_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MIN_REINVEST_AMOUNT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENTS_DIVIDER\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PERCENT_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PROJECT_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"REFERRAL_PERCENTS\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"REINVEST_TAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TIME_STEP\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"VAULT_TAX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"WITHDRAW_FEE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"administrator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropClaimedTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"airdropMaxTotal\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"buy_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"checkAirdrop\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"internalType\":\"struct MatrixxNetwork.QualifiedWallet\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAirdrop\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"commissionWallet\",\"outputs\":[{\"internalType\":\"address payable\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"}],\"name\":\"getPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"}],\"name\":\"getPlanInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"time\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"getResult\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserAmountOfDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserAmountWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserAvailable\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserCheckpoint\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getUserDepositInfo\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"percent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"start\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"finish\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDividends\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserDownlineCount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralTotalBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferralWithdrawn\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserReferrer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"getUserTotalDeposits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"referrer\",\"type\":\"address\"},{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"amountToStake\",\"type\":\"uint256\"}],\"name\":\"invest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"plan\",\"type\":\"uint8\"}],\"name\":\"reInvestEarnings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sell_tax\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"wallet\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"claimed\",\"type\":\"bool\"}],\"internalType\":\"struct MatrixxNetwork.QualifiedWallet[]\",\"name\":\"list\",\"type\":\"tuple[]\"}],\"name\":\"snapshot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startUNIX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tax_divider\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalRefBonus\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateMinInvestAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateMinReinvestAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"updateTaxFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MatrixxNetwork", "CompilerVersion": "v0.6.10+commit.00c0fcaf", "OptimizationUsed": "0", "Runs": "200", "ConstructorArguments": "000000000000000000000000d969fdadd122db5bab72b62fa7f46616ff5f276100000000000000000000000000000000000000000000000000000000623322c0", "EVMVersion": "Default", "Library": "", "LicenseType": "GNU GPLv3", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://a7f65ba263dc4900be15d04563ae06444546bc2bb87c8197ec931223d285b86b"}