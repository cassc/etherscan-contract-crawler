{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.8.18 <0.9.0;\r\n\r\n\r\n//import \"../utils/Context.sol\";\r\n/**\r\n * @dev Provides information about the current execution context, including the\r\n * sender of the transaction and its data. While these are generally available\r\n * via msg.sender and msg.data, they should not be accessed in such a direct\r\n * manner, since when dealing with meta-transactions the account sending and\r\n * paying for execution may not be the actual sender (as far as an application\r\n * is concerned).\r\n *\r\n * This contract is only required for intermediate, library-like contracts.\r\n */\r\nabstract contract Context {\r\n    function _msgSender() internal view virtual returns (address) {\r\n        return msg.sender;\r\n    }\r\n\r\n    function _msgData() internal view virtual returns (bytes calldata) {\r\n        return msg.data;\r\n    }\r\n}\r\n\r\n\r\n//import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n *\r\n * This module is used through inheritance. It will make available the modifier\r\n * `onlyOwner`, which can be applied to your functions to restrict their use to\r\n * the owner.\r\n */\r\nabstract contract Ownable is Context {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Initializes the contract setting the deployer as the initial owner.\r\n     */\r\n    constructor() {\r\n        _transferOwnership(_msgSender());\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        _checkOwner();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     */\r\n    function owner() public view virtual returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if the sender is not the owner.\r\n     */\r\n    function _checkOwner() internal view virtual {\r\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\r\n    }\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby disabling any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0));\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public virtual onlyOwner {\r\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _transferOwnership(address newOwner) internal virtual {\r\n        address oldOwner = _owner;\r\n        _owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n}\r\n\r\n\r\n//import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to {approve}. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `to`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when {approve} or {transferFrom} are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an {Approval} event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `from` to `to` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a {Transfer} event.\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\r\n}\r\n\r\n\r\n//import \"../../utils/introspection/IERC165.sol\";\r\n/**\r\n * @dev Interface of the ERC165 standard, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\r\n *\r\n * Implementers can declare support of contract interfaces, which can then be\r\n * queried by others ({ERC165Checker}).\r\n *\r\n * For an implementation, see {ERC165}.\r\n */\r\ninterface IERC165 {\r\n    /**\r\n     * @dev Returns true if this contract implements the interface defined by\r\n     * `interfaceId`. See the corresponding\r\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\r\n     * to learn more about how these ids are created.\r\n     *\r\n     * This function call must use less than 30 000 gas.\r\n     */\r\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\r\n}\r\n\r\n\r\n//import \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\n/**\r\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\r\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\r\n *\r\n * _Available since v3.1._\r\n */\r\ninterface IERC1155 is IERC165 {\r\n    /**\r\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\r\n     */\r\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\r\n\r\n    /**\r\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\r\n     * transfers.\r\n     */\r\n    event TransferBatch(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256[] ids,\r\n        uint256[] values\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\r\n     * `approved`.\r\n     */\r\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\r\n\r\n    /**\r\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\r\n     *\r\n     * If an {URI} event was emitted for `id`, the standard\r\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\r\n     * returned by {IERC1155MetadataURI-uri}.\r\n     */\r\n    event URI(string value, uint256 indexed id);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     */\r\n    function balanceOf(address account, uint256 id) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `accounts` and `ids` must have the same length.\r\n     */\r\n    function balanceOfBatch(\r\n        address[] calldata accounts,\r\n        uint256[] calldata ids\r\n    ) external view returns (uint256[] memory);\r\n\r\n    /**\r\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\r\n     *\r\n     * Emits an {ApprovalForAll} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `operator` cannot be the caller.\r\n     */\r\n    function setApprovalForAll(address operator, bool approved) external;\r\n\r\n    /**\r\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\r\n     *\r\n     * See {setApprovalForAll}.\r\n     */\r\n    function isApprovedForAll(address account, address operator) external view returns (bool);\r\n\r\n    /**\r\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\r\n     *\r\n     * Emits a {TransferSingle} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\r\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount, bytes calldata data) external;\r\n\r\n    /**\r\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\r\n     *\r\n     * Emits a {TransferBatch} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `ids` and `amounts` must have the same length.\r\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\r\n     * acceptance magic value.\r\n     */\r\n    function safeBatchTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata amounts,\r\n        bytes calldata data\r\n    ) external;\r\n}\r\n\r\n\r\n//import \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\r\n\r\n/**\r\n * @dev _Available since v3.1._\r\n */\r\ninterface IERC1155Receiver is IERC165 {\r\n    /**\r\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\r\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\r\n     *\r\n     * NOTE: To accept the transfer, this must return\r\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\r\n     * (i.e. 0xf23a6e61, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param id The ID of the token being transferred\r\n     * @param value The amount of tokens being transferred\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        uint256 value,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n\r\n    /**\r\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\r\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\r\n     * been updated.\r\n     *\r\n     * NOTE: To accept the transfer(s), this must return\r\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\r\n     * (i.e. 0xbc197c81, or its own function selector).\r\n     *\r\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\r\n     * @param from The address which previously owned the token\r\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\r\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\r\n     * @param data Additional data with no specified format\r\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\r\n     */\r\n    function onERC1155BatchReceived(\r\n        address operator,\r\n        address from,\r\n        uint256[] calldata ids,\r\n        uint256[] calldata values,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n//import \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n    /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     *\r\n     * Furthermore, `isContract` will also return true if the target contract within\r\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\r\n     * which only has an effect at the end of a transaction.\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        // This method relies on extcodesize/address.code.length, which returns 0\r\n        // for contracts in construction, since the code is only stored at the end\r\n        // of the constructor execution.\r\n\r\n        return account.code.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n    function sendValue(address payable recipient, uint256 amount) internal {\r\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n        (bool success, ) = recipient.call{value: amount}(\"\");\r\n        require(success, \"Address: unable to send value, recipient may have reverted\");\r\n    }\r\n\r\n    /**\r\n     * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, 0, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\r\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n    function functionCallWithValue(\r\n        address target,\r\n        bytes memory data,\r\n        uint256 value,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n    function functionStaticCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.staticcall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n    }\r\n\r\n    /**\r\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n    function functionDelegateCall(\r\n        address target,\r\n        bytes memory data,\r\n        string memory errorMessage\r\n    ) internal returns (bytes memory) {\r\n        (bool success, bytes memory returndata) = target.delegatecall(data);\r\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n    function verifyCallResultFromTarget(\r\n        address target,\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal view returns (bytes memory) {\r\n        if (success) {\r\n            if (returndata.length == 0) {\r\n                // only check isContract if the call was successful and the return data is empty\r\n                // otherwise we already know that it was a contract\r\n                require(isContract(target), \"Address: call to non-contract\");\r\n            }\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n    function verifyCallResult(\r\n        bool success,\r\n        bytes memory returndata,\r\n        string memory errorMessage\r\n    ) internal pure returns (bytes memory) {\r\n        if (success) {\r\n            return returndata;\r\n        } else {\r\n            _revert(returndata, errorMessage);\r\n        }\r\n    }\r\n\r\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n        // Look for revert reason and bubble it up if present\r\n        if (returndata.length > 0) {\r\n            // The easiest way to bubble the revert reason is using memory via assembly\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                let returndata_size := mload(returndata)\r\n                revert(add(32, returndata), returndata_size)\r\n            }\r\n        } else {\r\n            revert(errorMessage);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//import '@openzeppelin/contracts/utils/cryptography/MerkleProof.sol';\r\n\r\n/**\r\n * @dev These functions deal with verification of Merkle Tree proofs.\r\n *\r\n * The tree and the proofs can be generated using our\r\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\r\n * You will find a quickstart guide in the readme.\r\n *\r\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\r\n * hashing, or use a hash function other than keccak256 for hashing leaves.\r\n * This is because the concatenation of a sorted pair of internal nodes in\r\n * the merkle tree could be reinterpreted as a leaf value.\r\n * OpenZeppelin's JavaScript library generates merkle trees that are safe\r\n * against this attack out of the box.\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\r\n     * defined by `root`. For this, a `proof` must be provided, containing\r\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\r\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\r\n     */\r\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProof(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {verify}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\r\n        return processProofCalldata(proof, leaf) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\r\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\r\n     * hash matches the root of the tree. When processing the proof, the pairs\r\n     * of leafs & pre-images are assumed to be sorted.\r\n     *\r\n     * _Available since v4.4._\r\n     */\r\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processProof}\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\r\n        bytes32 computedHash = leaf;\r\n        for (uint256 i = 0; i < proof.length; i++) {\r\n            computedHash = _hashPair(computedHash, proof[i]);\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a merkle tree defined by\r\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerify(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProof(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {multiProofVerify}\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function multiProofVerifyCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32 root,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bool) {\r\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\r\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\r\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\r\n     * respectively.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\r\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\r\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProof(\r\n        bytes32[] memory proof,\r\n        bool[] memory proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 proofLen = proof.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Calldata version of {processMultiProof}.\r\n     *\r\n     * CAUTION: Not all merkle trees admit multiproofs. See {processMultiProof} for details.\r\n     *\r\n     * _Available since v4.7._\r\n     */\r\n    function processMultiProofCalldata(\r\n        bytes32[] calldata proof,\r\n        bool[] calldata proofFlags,\r\n        bytes32[] memory leaves\r\n    ) internal pure returns (bytes32 merkleRoot) {\r\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\r\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\r\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\r\n        // the merkle tree.\r\n        uint256 leavesLen = leaves.length;\r\n        uint256 proofLen = proof.length;\r\n        uint256 totalHashes = proofFlags.length;\r\n\r\n        // Check proof validity.\r\n        require(leavesLen + proofLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");\r\n\r\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\r\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\r\n        bytes32[] memory hashes = new bytes32[](totalHashes);\r\n        uint256 leafPos = 0;\r\n        uint256 hashPos = 0;\r\n        uint256 proofPos = 0;\r\n        // At each step, we compute the next hash using two values:\r\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\r\n        //   get the next hash.\r\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\r\n        //   `proof` array.\r\n        for (uint256 i = 0; i < totalHashes; i++) {\r\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\r\n            bytes32 b = proofFlags[i]\r\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\r\n                : proof[proofPos++];\r\n            hashes[i] = _hashPair(a, b);\r\n        }\r\n\r\n        if (totalHashes > 0) {\r\n            require(proofPos == proofLen, \"MerkleProof: invalid multiproof\");\r\n            unchecked {\r\n                return hashes[totalHashes - 1];\r\n            }\r\n        } else if (leavesLen > 0) {\r\n            return leaves[0];\r\n        } else {\r\n            return proof[0];\r\n        }\r\n    }\r\n\r\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\r\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\r\n    }\r\n\r\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\r\n        /// @solidity memory-safe-assembly\r\n        assembly {\r\n            mstore(0x00, a)\r\n            mstore(0x20, b)\r\n            value := keccak256(0x00, 0x40)\r\n        }\r\n    }\r\n}\r\n\r\n\r\n//import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n    // Booleans are more expensive than uint256 or any type that takes up a full\r\n    // word because each write operation emits an extra SLOAD to first read the\r\n    // slot's contents, replace the bits taken up by the boolean, and then write\r\n    // back. This is the compiler's defense against contract upgrades and\r\n    // pointer aliasing, and it cannot be disabled.\r\n\r\n    // The values being non-zero value makes deployment a bit more expensive,\r\n    // but in exchange the refund on every call to nonReentrant will be lower in\r\n    // amount. Since refunds are capped to a percentage of the total\r\n    // transaction's gas, it is best to keep them low in cases like this one, to\r\n    // increase the likelihood of the full refund coming into effect.\r\n    uint256 private constant _NOT_ENTERED = 1;\r\n    uint256 private constant _ENTERED = 2;\r\n\r\n    uint256 private _status;\r\n\r\n    constructor() {\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n    modifier nonReentrant() {\r\n        _nonReentrantBefore();\r\n        _;\r\n        _nonReentrantAfter();\r\n    }\r\n\r\n    function _nonReentrantBefore() private {\r\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n        // Any calls to nonReentrant after this point will fail\r\n        _status = _ENTERED;\r\n    }\r\n\r\n    function _nonReentrantAfter() private {\r\n        // By storing the original value once again, a refund is triggered (see\r\n        // https://eips.ethereum.org/EIPS/eip-2200)\r\n        _status = _NOT_ENTERED;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n    function _reentrancyGuardEntered() internal view returns (bool) {\r\n        return _status == _ENTERED;\r\n    }\r\n}\r\n\r\n\r\n//------------------------------------------------------------\r\n// MedalVendor\r\n//------------------------------------------------------------\r\ncontract MedalVendor is Ownable, ReentrancyGuard, IERC1155Receiver {\r\n    address constant public TRESURY_ADDRESS = 0x422C7D8C3d5655051c119C55c0b6C343E4160a8D;\r\n    address constant public MITHRIL_ADDRESS = 0xb0e4eC69115E61d8D2c8401e1f254308572Abe49;\r\n    address constant public MEDAL_ADDRESS = 0x7ded1BC4d835ACf2Ec667a5d977AeE808fca2C13;\r\n\r\n    //--------------------------------------------------------\r\n    // constant\r\n    //--------------------------------------------------------\r\n    uint256 constant private BLOCK_SEC_MARGIN = 30;\r\n    uint256 constant private DATA_ID_OFFSET = 1;\r\n    uint256 constant private PRICE_OFFSET = 10**15;\r\n    uint256 constant private UINT32_DATA = 0xFFFFFFFF;\r\n\r\n    // sale_data(uint256)\r\n    uint256 constant private SALE_DATA_MATIC_A_SHIFT        = 0;\r\n    uint256 constant private SALE_DATA_MATIC_A_MASK         = UINT32_DATA << SALE_DATA_MATIC_A_SHIFT;\r\n\r\n    uint256 constant private SALE_DATA_MITHRIL_A_SHIFT      = 32;\r\n    uint256 constant private SALE_DATA_MITHRIL_A_MASK       = UINT32_DATA << SALE_DATA_MITHRIL_A_SHIFT;\r\n\r\n    uint256 constant private SALE_DATA_MATIC_B_SHIFT        = 64;\r\n    uint256 constant private SALE_DATA_MATIC_B_MASK         = UINT32_DATA << SALE_DATA_MATIC_B_SHIFT;\r\n\r\n    uint256 constant private SALE_DATA_MITHRIL_B_SHIFT      = 96;\r\n    uint256 constant private SALE_DATA_MITHRIL_B_MASK       = UINT32_DATA << SALE_DATA_MITHRIL_B_SHIFT;\r\n\r\n    uint256 constant private SALE_DATA_MATIC_C_SHIFT        = 128;\r\n    uint256 constant private SALE_DATA_MATIC_C_MASK         = UINT32_DATA << SALE_DATA_MATIC_C_SHIFT;\r\n\r\n    uint256 constant private SALE_DATA_MITHRIL_C_SHIFT      = 160;\r\n    uint256 constant private SALE_DATA_MITHRIL_C_MASK       = UINT32_DATA << SALE_DATA_MITHRIL_C_SHIFT;\r\n\r\n    uint256 constant private SALE_DATA_TOTAL_SUPPLY_SHIFT   = 192;\r\n    uint256 constant private SALE_DATA_TOTAL_SUPPLY_MASK    = UINT32_DATA << SALE_DATA_TOTAL_SUPPLY_SHIFT;\r\n\r\n    uint256 constant private SALE_DATA_TOTAL_MINTED_SHIFT   = 224;\r\n    uint256 constant private SALE_DATA_TOTAL_MINTED_MASK    = UINT32_DATA << SALE_DATA_TOTAL_MINTED_SHIFT;\r\n\r\n    // time_data(uint256)\r\n    uint256 constant private TIME_DATA_START_A_SHIFT        = 0;\r\n    uint256 constant private TIME_DATA_START_A_MASK         = UINT32_DATA << TIME_DATA_START_A_SHIFT;\r\n\r\n    uint256 constant private TIME_DATA_END_A_SHIFT          = 32;\r\n    uint256 constant private TIME_DATA_END_A_MASK           = UINT32_DATA << TIME_DATA_END_A_SHIFT;\r\n\r\n    uint256 constant private TIME_DATA_START_B_SHIFT        = 64;\r\n    uint256 constant private TIME_DATA_START_B_MASK         = UINT32_DATA << TIME_DATA_START_B_SHIFT;\r\n\r\n    uint256 constant private TIME_DATA_END_B_SHIFT          = 96;\r\n    uint256 constant private TIME_DATA_END_B_MASK           = UINT32_DATA << TIME_DATA_END_B_SHIFT;\r\n\r\n    uint256 constant private TIME_DATA_START_C_SHIFT        = 128;\r\n    uint256 constant private TIME_DATA_START_C_MASK         = UINT32_DATA << TIME_DATA_START_C_SHIFT;\r\n\r\n    uint256 constant private TIME_DATA_END_C_SHIFT          = 160;\r\n    uint256 constant private TIME_DATA_END_C_MASK           = UINT32_DATA << TIME_DATA_END_C_SHIFT;\r\n\r\n    uint256 constant private TIME_DATA_START_LIST_SHIFT     = 192;\r\n    uint256 constant private TIME_DATA_START_LIST_MASK      = UINT32_DATA << TIME_DATA_START_LIST_SHIFT;\r\n\r\n    uint256 constant private TIME_DATA_END_LIST_SHIFT       = 224;\r\n    uint256 constant private TIME_DATA_END_LIST_MASK        = UINT32_DATA << TIME_DATA_END_LIST_SHIFT;\r\n\r\n    // limit_data(uint256)\r\n    uint256 constant private LIMIT_DATA_MAX_B_SHIFT         = 0;\r\n    uint256 constant private LIMIT_DATA_MAX_B_MASK          = UINT32_DATA << LIMIT_DATA_MAX_B_SHIFT;\r\n\r\n    uint256 constant private LIMIT_DATA_MAX_C_SHIFT         = 32;\r\n    uint256 constant private LIMIT_DATA_MAX_C_MASK          = UINT32_DATA << LIMIT_DATA_MAX_C_SHIFT;\r\n\r\n    uint256 constant private LIMIT_DATA_MAX_PER_TX_SHIFT    = 64;\r\n    uint256 constant private LIMIT_DATA_MAX_PER_TX_MASK     = UINT32_DATA << LIMIT_DATA_MAX_PER_TX_SHIFT;\r\n\r\n    // user_data(uint256)\r\n    uint256 constant private USER_DATA_MINTED_A_SHIFT       = 0;\r\n    uint256 constant private USER_DATA_MINTED_A_MASK        = UINT32_DATA << USER_DATA_MINTED_A_SHIFT;\r\n\r\n    uint256 constant private USER_DATA_MINTED_B_SHIFT       = 32;\r\n    uint256 constant private USER_DATA_MINTED_B_MASK        = UINT32_DATA << USER_DATA_MINTED_B_SHIFT;\r\n\r\n    uint256 constant private USER_DATA_MINTED_C_SHIFT       = 64;\r\n    uint256 constant private USER_DATA_MINTED_C_MASK        = UINT32_DATA << USER_DATA_MINTED_C_SHIFT;\r\n\r\n    uint256 constant private USER_DATA_MAX_A_SHIFT          = 96;\r\n    uint256 constant private USER_DATA_MAX_B_SHIFT          = 128;\r\n    uint256 constant private USER_DATA_MAX_C_SHIFT          = 160;\r\n    uint256 constant private USER_DATA_MAX_PER_TX_SHIFT     = 192;\r\n\r\n    // enum\r\n    uint256 constant private DETAIL_INFO_MATIC_BALANCE      = 0;\r\n    uint256 constant private DETAIL_INFO_MITHRIL_BALANCE    = 1;\r\n    uint256 constant private DETAIL_INFO_MITHRIL_ALLOWANCE  = 2;\r\n    uint256 constant private DETAIL_INFO_FLAG               = 3;\r\n    uint256 constant private DETAIL_INFO_SALE_DATA          = 4;\r\n    uint256 constant private DETAIL_INFO_TIME_DATA          = 5;\r\n    uint256 constant private DETAIL_INFO_USER_DATA          = 6;\r\n    uint256 constant private DETAIL_INFO_MAX                = 7;\r\n\r\n    // enum\r\n    uint256 constant private SALE_TYPE_A = 1;       // private sale(mithril)\r\n    uint256 constant private SALE_TYPE_B = 2;       // public sale(mithril)\r\n    uint256 constant private SALE_TYPE_C = 3;       // public sale(matic)\r\n\r\n    // flag\r\n    uint256 constant private FLAG_VALID         = 0x1 << 0;\r\n    uint256 constant private FLAG_WHITELISTED_A = 0x1 << 1;\r\n    uint256 constant private FLAG_WHITELISTED_B = 0x1 << 2;\r\n    uint256 constant private FLAG_WHITELISTED_C = 0x1 << 3;\r\n\r\n    //--------------------------------------------------------\r\n    // storage\r\n    //--------------------------------------------------------\r\n    mapping( uint256 => uint256 ) private _map_data_id_for_token_id;\r\n\r\n    uint256[] private _arr_token_id;\r\n    bool[] private _arr_is_valid;\r\n    uint256[] private _arr_sale_data;\r\n    uint256[] private _arr_time_data;\r\n    uint256[] private _arr_limit_data;\r\n    bytes32[] private _arr_merkle_root_a;\r\n    mapping( uint256 => mapping( address => uint256 ) ) private _map_map_user_data;\r\n\r\n    //--------------------------------------------------------\r\n    // constructor\r\n    //--------------------------------------------------------\r\n    constructor() Ownable() {\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [public/override] for acceptable of ERC1155 transfering\r\n    //--------------------------------------------------------\r\n    function supportsInterface( bytes4 interfaceId ) public pure override returns (bool) { return( interfaceId == type(IERC1155Receiver).interfaceId ); }\r\n    function onERC1155Received( address, address, uint256, uint256, bytes memory ) external pure override returns (bytes4) { return( this.onERC1155Received.selector ); }\r\n    function onERC1155BatchReceived( address, address, uint256[] calldata, uint256[] calldata, bytes calldata ) external pure override returns (bytes4){ return( this.onERC1155BatchReceived.selector ); }\r\n\r\n    //--------------------------------------------------------\r\n    // [internal] _getDataIdOf\r\n    //--------------------------------------------------------\r\n    function _getDataIdOf( uint256 tokenId ) internal view returns (uint256) {\r\n        uint256 dataId = _map_data_id_for_token_id[tokenId];\r\n        require( dataId >= DATA_ID_OFFSET, \"_getDataIdOf: tokenId not registered\");\r\n\r\n        return( dataId - DATA_ID_OFFSET );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [external/onlyOwner] registMedalOf\r\n    //--------------------------------------------------------\r\n    function registMedalOf( uint256 tokenId ) external onlyOwner {\r\n        require( _map_data_id_for_token_id[tokenId] == 0, \"registMedalInfo: tokenId already registered\" );\r\n\r\n        uint256 dataId = _arr_token_id.length + DATA_ID_OFFSET;\r\n        _map_data_id_for_token_id[tokenId] = dataId;\r\n\r\n        _arr_token_id.push( tokenId );\r\n        _arr_is_valid.push( false );\r\n        _arr_sale_data.push( 0 );\r\n        _arr_time_data.push( 0 );\r\n        _arr_limit_data.push( 0 );\r\n        _arr_merkle_root_a.push( 0 );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [external/onlyOwner] unregistMedalOf\r\n    //--------------------------------------------------------\r\n    function unregistMedalOf( uint256 tokenId ) external onlyOwner {\r\n        uint256 dataId = _getDataIdOf( tokenId );\r\n        require( !_arr_is_valid[dataId], \"unregistMedalOf: can't unregist valid token\" );\r\n\r\n        delete _map_data_id_for_token_id[tokenId];       \r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [external/onlyOwner] setSaleDataOf\r\n    //--------------------------------------------------------\r\n    function setSaleDataOf( uint256 tokenId, uint256 maticA, uint256 mithrilA, uint256 maticB, uint256 mithrilB, uint256 maticC, uint256 mithrilC, uint256 supply, uint256 minted ) external onlyOwner {\r\n        maticA /= PRICE_OFFSET;\r\n        mithrilA /= PRICE_OFFSET;\r\n        maticB /= PRICE_OFFSET;\r\n        mithrilB /= PRICE_OFFSET;\r\n        maticC /= PRICE_OFFSET;\r\n        mithrilC /= PRICE_OFFSET;\r\n\r\n        require( maticA <= UINT32_DATA, \"setSaleData: invalid maticA\" );\r\n        require( mithrilA <= UINT32_DATA, \"setSaleData: invalid mithrilA\" );\r\n        require( maticB <= UINT32_DATA, \"setSaleData: invalid maticB\" );\r\n        require( mithrilB <= UINT32_DATA, \"setSaleData: invalid mithrilB\" );\r\n        require( maticC <= UINT32_DATA, \"setSaleData: invalid maticC\" );\r\n        require( mithrilC <= UINT32_DATA, \"setSaleData: invalid mithrilC\" );\r\n        require( supply <= UINT32_DATA, \"setSaleData: invalid supply\" );\r\n        require( minted <= UINT32_DATA, \"setSaleData: invalid minted\" );\r\n\r\n        uint256 saleData;\r\n        saleData |= maticA << SALE_DATA_MATIC_A_SHIFT;\r\n        saleData |= mithrilA << SALE_DATA_MITHRIL_A_SHIFT;\r\n        saleData |= maticB << SALE_DATA_MATIC_B_SHIFT;\r\n        saleData |= mithrilB << SALE_DATA_MITHRIL_B_SHIFT;\r\n        saleData |= maticC << SALE_DATA_MATIC_C_SHIFT;\r\n        saleData |= mithrilC << SALE_DATA_MITHRIL_C_SHIFT;\r\n        saleData |= supply << SALE_DATA_TOTAL_SUPPLY_SHIFT;\r\n        saleData |= minted << SALE_DATA_TOTAL_MINTED_SHIFT;\r\n\r\n        uint256 dataId = _getDataIdOf( tokenId );\r\n        _arr_sale_data[dataId] = saleData;\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [external/onlyOwner] setTimeDataOf\r\n    //--------------------------------------------------------\r\n    function setTimeDataOf( uint256 tokenId, uint256 startA, uint256 endA, uint256 startB, uint256 endB, uint256 startC, uint256 endC, uint256 startList, uint256 endList ) external onlyOwner {\r\n        require( startA <= UINT32_DATA, \"setTimeData: invalid startA\" );\r\n        require( endA <= UINT32_DATA, \"setTimeData: invalid endA\" );\r\n        require( startB <= UINT32_DATA, \"setTimeData: invalid startB\" );\r\n        require( endB <= UINT32_DATA, \"setTimeData: invalid endB\" );\r\n        require( startC <= UINT32_DATA, \"setTimeData: invalid startC\" );\r\n        require( endC <= UINT32_DATA, \"setTimeData: invalid endC\" );\r\n        require( startList <= UINT32_DATA, \"setTimeData: invalid startList\" );\r\n        require( endList <= UINT32_DATA, \"setTimeData: invalid endList\" );\r\n\r\n        uint256 timeData;\r\n        timeData |= startA << TIME_DATA_START_A_SHIFT;\r\n        timeData |= endA << TIME_DATA_END_A_SHIFT;\r\n        timeData |= startB << TIME_DATA_START_B_SHIFT;\r\n        timeData |= endB << TIME_DATA_END_B_SHIFT;\r\n        timeData |= startC << TIME_DATA_START_C_SHIFT;\r\n        timeData |= endC << TIME_DATA_END_C_SHIFT;\r\n        timeData |= startList << TIME_DATA_START_LIST_SHIFT;\r\n        timeData |= endList << TIME_DATA_END_LIST_SHIFT;\r\n\r\n        uint256 dataId = _getDataIdOf( tokenId );\r\n        _arr_time_data[dataId] = timeData;\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [external/onlyOwner] setLimitDataOf\r\n    //--------------------------------------------------------\r\n    function setLimitDataOf( uint256 tokenId, bytes32 rootA, uint256 maxB, uint256 maxC, uint256 maxPerTx ) external onlyOwner {\r\n        require( maxB <= UINT32_DATA, \"setLimitDataOf: invalid maxB\" );\r\n        require( maxC <= UINT32_DATA, \"setLimitDataOf: invalid maxC\" );\r\n        require( maxPerTx <= UINT32_DATA, \"setLimitDataOf: invalid maxPerTx\" );\r\n\r\n        uint256 dataId = _getDataIdOf( tokenId );\r\n        _arr_merkle_root_a[dataId] = rootA;\r\n\r\n        uint256 limitData;\r\n        limitData |= maxB << LIMIT_DATA_MAX_B_SHIFT;\r\n        limitData |= maxC << LIMIT_DATA_MAX_C_SHIFT;\r\n        limitData |= maxPerTx << LIMIT_DATA_MAX_PER_TX_SHIFT;\r\n        _arr_limit_data[dataId] = limitData;\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [external/onlyOwner] setValidOf\r\n    //--------------------------------------------------------\r\n    function setValidOf( uint256 tokenId, bool flag ) external onlyOwner {\r\n        uint256 dataId = _getDataIdOf( tokenId );\r\n        _arr_is_valid[dataId] = flag;\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [external] getMedalList\r\n    //--------------------------------------------------------\r\n    function getMedalList() external view returns (uint256, uint256[] memory, uint256[] memory, uint256[] memory ) {\r\n        uint256 total = _arr_token_id.length;\r\n        uint256 hit;\r\n        uint256[] memory arrValidId = new uint256[](total);\r\n\r\n        for( uint256 i=0; i<total; i++ ){\r\n            if( ! _arr_is_valid[i] ){ continue; }\r\n\r\n            uint256 start = (_arr_time_data[i]&TIME_DATA_START_LIST_MASK) >> TIME_DATA_START_LIST_SHIFT;\r\n            if( start > 0 && start > block.timestamp ){ continue; }\r\n\r\n            uint256 end = (_arr_time_data[i]&TIME_DATA_END_LIST_MASK) >> TIME_DATA_END_LIST_SHIFT;\r\n            if( end > 0 && end <= block.timestamp ){ continue; }\r\n\r\n            uint256 dataId = _map_data_id_for_token_id[_arr_token_id[i]];\r\n            if( dataId == (i+DATA_ID_OFFSET) ){\r\n                arrValidId[hit++] = i;\r\n            }\r\n        }\r\n\r\n        uint256[] memory arrTokenId = new uint256[](hit);\r\n        uint256[] memory arrSaleData = new uint256[](hit);\r\n        uint256[] memory arrTimeData = new uint256[](hit);\r\n\r\n        for( uint256 i=0; i<hit; i++ ){\r\n            uint256 target = arrValidId[i];\r\n            arrTokenId[i] = _arr_token_id[target];\r\n            arrSaleData[i] = _arr_sale_data[target];\r\n            arrTimeData[i] = _arr_time_data[target];\r\n        }\r\n\r\n        return( hit, arrTokenId, arrSaleData, arrTimeData );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [external] getDetailInfoOf\r\n    //--------------------------------------------------------\r\n    function getDetailInfoOf( address target, uint256 tokenId, uint256 maxA, bytes32[] calldata merkleProofA ) external view returns (uint256[DETAIL_INFO_MAX] memory ) {\r\n        uint256[DETAIL_INFO_MAX] memory arrRet;\r\n        arrRet[DETAIL_INFO_MATIC_BALANCE] = target.balance;\r\n        arrRet[DETAIL_INFO_MITHRIL_BALANCE] = _getMithrilBalance( target );\r\n        arrRet[DETAIL_INFO_MITHRIL_ALLOWANCE] = _getMithrilAllowance( target );\r\n\r\n        uint256 dataId = _map_data_id_for_token_id[tokenId];\r\n        if( dataId >= DATA_ID_OFFSET ){\r\n            dataId -= DATA_ID_OFFSET;\r\n\r\n            // userdata\r\n            uint256 userData = _map_map_user_data[dataId][target];\r\n            userData |= ((_arr_limit_data[dataId]&LIMIT_DATA_MAX_B_MASK) >> LIMIT_DATA_MAX_B_SHIFT) << USER_DATA_MAX_B_SHIFT;\r\n            userData |= ((_arr_limit_data[dataId]&LIMIT_DATA_MAX_C_MASK) >> LIMIT_DATA_MAX_C_SHIFT) << USER_DATA_MAX_C_SHIFT;\r\n            userData |= ((_arr_limit_data[dataId]&LIMIT_DATA_MAX_PER_TX_MASK) >> LIMIT_DATA_MAX_PER_TX_SHIFT) << USER_DATA_MAX_PER_TX_SHIFT;\r\n\r\n            if( _arr_is_valid[dataId] ){ arrRet[DETAIL_INFO_FLAG] |= FLAG_VALID; }\r\n            if( _checkWhitelisted( _arr_merkle_root_a[dataId], target, maxA, merkleProofA ) ){\r\n                arrRet[DETAIL_INFO_FLAG] |= FLAG_WHITELISTED_A;\r\n                userData |= maxA << USER_DATA_MAX_A_SHIFT;\r\n            }\r\n            arrRet[DETAIL_INFO_FLAG] |= FLAG_WHITELISTED_B;\r\n            arrRet[DETAIL_INFO_FLAG] |= FLAG_WHITELISTED_C;\r\n\r\n            arrRet[DETAIL_INFO_SALE_DATA] = _arr_sale_data[dataId];\r\n            arrRet[DETAIL_INFO_TIME_DATA] = _arr_time_data[dataId];\r\n            arrRet[DETAIL_INFO_USER_DATA] = userData;\r\n        }\r\n\r\n        return( arrRet );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [internal] _getMithrilBalance\r\n    //--------------------------------------------------------\r\n    function _getMithrilBalance( address target ) internal view returns (uint256) {\r\n        IERC20 mithril = IERC20( MITHRIL_ADDRESS );\r\n        return( mithril.balanceOf( target ) );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [internal] _getMithrilAllowance\r\n    //--------------------------------------------------------\r\n    function _getMithrilAllowance( address target ) internal view returns (uint256) {\r\n        IERC20 mithril = IERC20( MITHRIL_ADDRESS );\r\n        return( mithril.allowance( target, address(this) ) );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [internal] _checkWhitelisted\r\n    //--------------------------------------------------------\r\n    function _checkWhitelisted( bytes32 merkleRoot, address target, uint256 userMintMax, bytes32[] calldata merkleProof ) internal pure returns (bool) {\r\n        bytes32 node = keccak256( abi.encodePacked( target, userMintMax ) );\r\n        return( MerkleProof.verify( merkleProof, merkleRoot, node ) );\r\n    }\r\n\r\n    //-----------------------------------------------------------\r\n    // [external/payable/nonReentrant] purchaseWithMatic\r\n    //-----------------------------------------------------------\r\n    function purchaseWithMatic( uint256 saleType, uint256 tokenId, uint256 num, uint256 userMintMax, bytes32[] calldata merkleProof ) external payable nonReentrant {\r\n        uint256 dataId = _getDataIdOf( tokenId );\r\n\r\n        uint256 priceInMatic;\r\n        if( saleType == SALE_TYPE_A ){\r\n            priceInMatic = ((_arr_sale_data[dataId] & SALE_DATA_MATIC_A_MASK) >> SALE_DATA_MATIC_A_SHIFT) * PRICE_OFFSET;\r\n        }else if( saleType == SALE_TYPE_B ){\r\n            priceInMatic = ((_arr_sale_data[dataId] & SALE_DATA_MATIC_B_MASK) >> SALE_DATA_MATIC_B_SHIFT) * PRICE_OFFSET;\r\n        }else if( saleType == SALE_TYPE_C ){\r\n            priceInMatic = ((_arr_sale_data[dataId] & SALE_DATA_MATIC_C_MASK) >> SALE_DATA_MATIC_C_SHIFT) * PRICE_OFFSET;\r\n        }else{\r\n            require( false, \"purchaseWithMatic: unknown saleType\" );\r\n        }\r\n\r\n        require( priceInMatic > 0, \"purchaseWithMatic: invalid price\" );\r\n        _checkMaticPayment( msg.sender, msg.value, priceInMatic*num );\r\n\r\n        _purchase( msg.sender, dataId, saleType, tokenId, num, userMintMax, merkleProof );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [internal] _checkMaticPayment\r\n    //--------------------------------------------------------\r\n    function _checkMaticPayment( address msgSender, uint256 msgValue, uint256 price ) internal {\r\n        require( msgValue >= price, \"_checkMaticPayment: insufficient value\" );\r\n\r\n        if( msgValue > price ){\r\n            uint256 change = msgValue - price;\r\n            address payable target = payable( msgSender );\r\n            Address.sendValue( target, change );\r\n        }\r\n    }\r\n\r\n    //-----------------------------------------------------------\r\n    // [external/nonReentrant] purchaseWithMithril\r\n    //-----------------------------------------------------------\r\n    function purchaseWithMithril( uint256 saleType, uint256 tokenId, uint256 num, uint256 userMintMax, bytes32[] calldata merkleProof ) external nonReentrant {\r\n        uint256 dataId = _getDataIdOf( tokenId );\r\n\r\n        uint256 priceInMithril;\r\n        if( saleType == SALE_TYPE_A ){\r\n            priceInMithril = ((_arr_sale_data[dataId] & SALE_DATA_MITHRIL_A_MASK) >> SALE_DATA_MITHRIL_A_SHIFT) * PRICE_OFFSET;\r\n        }else if( saleType == SALE_TYPE_B ){\r\n            priceInMithril = ((_arr_sale_data[dataId] & SALE_DATA_MITHRIL_B_MASK) >> SALE_DATA_MITHRIL_B_SHIFT) * PRICE_OFFSET;\r\n        }else if( saleType == SALE_TYPE_C ){\r\n            priceInMithril = ((_arr_sale_data[dataId] & SALE_DATA_MITHRIL_C_MASK) >> SALE_DATA_MITHRIL_C_SHIFT) * PRICE_OFFSET;\r\n        }else{\r\n            require( false, \"purchaseWithMithril: unknown saleType\" );\r\n        }\r\n\r\n        require( priceInMithril > 0, \"purchaseWithMithril: invalid price\" );\r\n        _receiveMithril( msg.sender, priceInMithril*num );\r\n\r\n        _purchase( msg.sender, dataId, saleType, tokenId, num, userMintMax, merkleProof );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [internal] _receiveMithril\r\n    //--------------------------------------------------------\r\n    function _receiveMithril( address from, uint256 price ) internal {\r\n        IERC20 mithril = IERC20( MITHRIL_ADDRESS );\r\n        mithril.transferFrom( from, TRESURY_ADDRESS, price );\r\n    }\r\n\r\n    //-----------------------------------------------------------\r\n    // [internal] _purchase\r\n    //-----------------------------------------------------------\r\n    function _purchase( address from, uint256 dataId, uint256 saleType, uint256 tokenId, uint256 num, uint256 userMintMax, bytes32[] calldata merkleProof ) internal {\r\n        require( _arr_is_valid[dataId], \"_purchase: not valid data\" );\r\n        require( ((_arr_limit_data[dataId]&LIMIT_DATA_MAX_PER_TX_MASK)>>LIMIT_DATA_MAX_PER_TX_SHIFT) >= num, \"_purchase: reached tx max\" );\r\n\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 minted;\r\n        if( saleType == SALE_TYPE_A ){\r\n            require( _checkWhitelisted( _arr_merkle_root_a[dataId], from, userMintMax, merkleProof ), \"_purchase: not allowed for SALE_TYPE_A\" );\r\n            start = (_arr_time_data[dataId]&TIME_DATA_START_A_MASK) >> TIME_DATA_START_A_SHIFT;\r\n            end = (_arr_time_data[dataId]&TIME_DATA_END_A_MASK) >> TIME_DATA_END_A_SHIFT;\r\n            minted = (_map_map_user_data[dataId][from]&USER_DATA_MINTED_A_MASK) >> USER_DATA_MINTED_A_SHIFT;\r\n        }else if( saleType == SALE_TYPE_B ){\r\n            userMintMax = (_arr_limit_data[dataId]&LIMIT_DATA_MAX_B_MASK) >> LIMIT_DATA_MAX_B_SHIFT;\r\n            start = (_arr_time_data[dataId]&TIME_DATA_START_B_MASK) >> TIME_DATA_START_B_SHIFT;\r\n            end = (_arr_time_data[dataId]&TIME_DATA_END_B_MASK) >> TIME_DATA_END_B_SHIFT;\r\n            minted = (_map_map_user_data[dataId][from]&USER_DATA_MINTED_B_MASK) >> USER_DATA_MINTED_B_SHIFT;\r\n        }else if( saleType == SALE_TYPE_C ){\r\n            userMintMax = (_arr_limit_data[dataId]&LIMIT_DATA_MAX_C_MASK) >> LIMIT_DATA_MAX_C_SHIFT;\r\n            start = (_arr_time_data[dataId]&TIME_DATA_START_C_MASK) >> TIME_DATA_START_C_SHIFT;\r\n            end = (_arr_time_data[dataId]&TIME_DATA_END_C_MASK) >> TIME_DATA_END_C_SHIFT;\r\n            minted = (_map_map_user_data[dataId][from]&USER_DATA_MINTED_C_MASK) >> USER_DATA_MINTED_C_SHIFT;\r\n        }else{\r\n            require( false, \"_purchase: unknown saleType\" );\r\n        }\r\n\r\n        require( start == 0 || start <= (block.timestamp+BLOCK_SEC_MARGIN), \"_purchase: not opened\" );\r\n        require( end == 0 || (end+BLOCK_SEC_MARGIN) > block.timestamp, \"_purchase: finished\" );\r\n        require( userMintMax >= (minted+num), \"_purchase: reached user max\" );\r\n\r\n        minted += num;\r\n        if( saleType == SALE_TYPE_A ){\r\n            _map_map_user_data[dataId][from] &= ~USER_DATA_MINTED_A_MASK;\r\n            _map_map_user_data[dataId][from] |=  minted << USER_DATA_MINTED_A_SHIFT;\r\n        }else if( saleType == SALE_TYPE_B ){\r\n            _map_map_user_data[dataId][from] &= ~USER_DATA_MINTED_B_MASK;\r\n            _map_map_user_data[dataId][from] |=  minted << USER_DATA_MINTED_B_SHIFT;\r\n        }else if( saleType == SALE_TYPE_C ){\r\n            _map_map_user_data[dataId][from] &= ~USER_DATA_MINTED_C_MASK;\r\n            _map_map_user_data[dataId][from] |=  minted << USER_DATA_MINTED_C_SHIFT;\r\n        }\r\n\r\n        _transferMedal( dataId, from, tokenId, num );\r\n    }\r\n\r\n    //--------------------------------------------------------\r\n    // [internal] _transferMedal\r\n    //--------------------------------------------------------\r\n    function _transferMedal( uint256 dataId, address to, uint256 tokenId, uint256 num ) internal {\r\n        uint256 totalSupply = (_arr_sale_data[dataId]&SALE_DATA_TOTAL_SUPPLY_MASK) >> SALE_DATA_TOTAL_SUPPLY_SHIFT;\r\n        uint256 totalMinted = (_arr_sale_data[dataId]&SALE_DATA_TOTAL_MINTED_MASK) >> SALE_DATA_TOTAL_MINTED_SHIFT;\r\n        require( totalSupply >= (totalMinted+num), \"_transferMedal: reached supply max\" );\r\n\r\n        totalMinted += num;\r\n        _arr_sale_data[dataId] &= ~SALE_DATA_TOTAL_MINTED_MASK;\r\n        _arr_sale_data[dataId] |= totalMinted << SALE_DATA_TOTAL_MINTED_SHIFT;\r\n\r\n        IERC1155 medal = IERC1155( MEDAL_ADDRESS );\r\n        medal.safeTransferFrom( address(this), to, tokenId, num, \"\" );\r\n    }\r\n\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // [external] getBalance\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    function getBalance() external view returns (uint256) {\r\n        return( address(this).balance );\r\n    }\r\n\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // [external/onlyOwner] withdraw\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    function withdraw( uint256 amount ) external onlyOwner {\r\n        require( amount <= address(this).balance, \"withdraw: insufficient balance\" );\r\n\r\n        address payable target = payable( TRESURY_ADDRESS );\r\n        Address.sendValue( target, amount );\r\n    }\r\n\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // [external] getMedalBalanceOf\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    function getMedalBalanceOf( uint256 tokenId ) external view returns (uint256) {\r\n        IERC1155 medal = IERC1155( MEDAL_ADDRESS );\r\n        return( medal.balanceOf( address(this), tokenId ) );\r\n    }\r\n\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    // [external/onlyOwner] withdrawMedalOf\r\n    //++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n    function withdrawMedalOf( uint256 tokenId, uint256 amount ) external onlyOwner {\r\n        IERC1155 medal = IERC1155( MEDAL_ADDRESS );\r\n        require( amount <= medal.balanceOf( address(this), tokenId ), \"withdrawMedalOf: insufficient balance\" );\r\n\r\n        medal.safeTransferFrom( address(this), TRESURY_ADDRESS, tokenId, amount, \"\" );\r\n    }\r\n\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MEDAL_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MITHRIL_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TRESURY_ADDRESS\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxA\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProofA\",\"type\":\"bytes32[]\"}],\"name\":\"getDetailInfoOf\",\"outputs\":[{\"internalType\":\"uint256[7]\",\"name\":\"\",\"type\":\"uint256[7]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getMedalBalanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getMedalList\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"saleType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userMintMax\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"purchaseWithMatic\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"saleType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"num\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"userMintMax\",\"type\":\"uint256\"},{\"internalType\":\"bytes32[]\",\"name\":\"merkleProof\",\"type\":\"bytes32[]\"}],\"name\":\"purchaseWithMithril\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"registMedalOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"rootA\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"maxB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxPerTx\",\"type\":\"uint256\"}],\"name\":\"setLimitDataOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maticA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mithrilA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maticB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mithrilB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maticC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"mithrilC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minted\",\"type\":\"uint256\"}],\"name\":\"setSaleDataOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endB\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endC\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"startList\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endList\",\"type\":\"uint256\"}],\"name\":\"setTimeDataOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"flag\",\"type\":\"bool\"}],\"name\":\"setValidOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unregistMedalOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawMedalOf\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "MedalVendor", "CompilerVersion": "v0.8.18+commit.87f61d96", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://1d05382b87b6b7ffa83f821a4f004d005d6b61275b985241bdefb839bb2f8d21"}