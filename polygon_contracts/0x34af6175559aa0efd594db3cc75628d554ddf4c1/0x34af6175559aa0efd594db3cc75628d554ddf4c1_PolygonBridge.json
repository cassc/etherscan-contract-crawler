{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/PolygonBridge.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.21;\\n\\nimport {Ownable} from \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport {ILayerZeroEndpoint} from \\\"./interfaces/ILayerZeroEndpoint.sol\\\";\\nimport {ILayerZeroReceiver} from \\\"./interfaces/ILayerZeroReceiver.sol\\\";\\n\\n/// @dev the bridge contract to deploy on the main-chain where the token is deployed\\ncontract PolygonBridge is Ownable, ILayerZeroReceiver {\\n    /*///////////////////////////////////////////////////////////////\\n                            STATE VARIABLES\\n    //////////////////////////////////////////////////////////////*/\\n    /// the MCT_TOKEN contract representing the token being bridged.\\n    IERC20 public constant MCT_TOKEN = IERC20(0x13eFAA3D5E2C86E7ABa168F925FeF9827648Cff4);\\n\\n    /// the chain ID of the LayerZero chain where this contract is deployed.\\n    uint16 public constant LZ_CHAIN_ID = 109;\\n\\n    /// @dev not declared as constant to prevent vendor lock-in\\n    ILayerZeroEndpoint public endpoint = ILayerZeroEndpoint(0x3c2269811836af69497E5F486A85D7316753cf62);\\n\\n    /// @dev mapping trusted remote\\n    mapping(uint16 => bytes) public trustedRemote;\\n\\n    /// @dev total src chain tx counter\\n    uint256 public txCounter;\\n\\n    /// @dev map nonce to processed state to prevent replay attack\\n    mapping(bytes => mapping(uint16 => mapping(uint64 => bool))) public nonceStatus;\\n\\n    /// @dev transfer fees per tx\\n    uint256 public transferFeePercent = 50;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                MODIFIER\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev ensures only the endpoint contract can call the function.\\n    modifier onlyEndpoint() {\\n        require(msg.sender == address(endpoint), \\\"bridge/caller-not-endpoint\\\");\\n        _;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @dev emitted when a bridging operation is initiated.\\n    event BridgingInitiated(\\n        uint16 srcChainId, uint16 dstChainId, uint256 srcTxIndex, address indexed receiver, uint256 amount, uint256 fees\\n    );\\n\\n    /// @dev emitted when a bridging operation is completed.\\n    event BridgingCompleted(\\n        uint16 srcChainId, uint16 dstChainId, uint256 srcTxIndex, address indexed receiver, uint256 amount\\n    );\\n\\n    /// @dev emitted when the LayerZero endpoint address is updated.\\n    event EndpointUpdated(address indexed oldEndpoint, address indexed newEndpoint);\\n\\n    /// @dev emitted when trusted remote addresses are updated.\\n    event TrustedRemoteUpdated(uint16 indexed dstChainId, bytes trustedRemote);\\n\\n    /// @dev emitted when transfer fees are updated.\\n    event TransferFeeUpdated(uint256 oldFees, uint256 newFees);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n    constructor() Ownable(msg.sender) {}\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            EXTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Initiates a cross-chain token transfer.\\n    /// @param _receiver The recipient's address on the destination chain.\\n    /// @param _amount The amount of tokens to transfer.\\n    /// @param _dstChainId The destination chain's ID.\\n    /// @param _adapterParams Additional adapter parameters.\\n    function xChainTransfer(address _receiver, uint256 _amount, uint16 _dstChainId, bytes memory _adapterParams)\\n        external\\n        payable\\n    {\\n        require(trustedRemote[_dstChainId].length > 0, \\\"bridge/invalid-dst-chain-id\\\");\\n        require(MCT_TOKEN.balanceOf(msg.sender) >= _amount, \\\"bridge/insufficient-balance\\\");\\n        require(MCT_TOKEN.allowance(msg.sender, address(this)) >= _amount, \\\"bridge/insufficient-allowance\\\");\\n\\n        uint256 balanceBefore = MCT_TOKEN.balanceOf(address(this));\\n        MCT_TOKEN.transferFrom(msg.sender, address(this), _amount);\\n        uint256 balanceAfter = MCT_TOKEN.balanceOf(address(this));\\n\\n        require(balanceAfter - balanceBefore == _amount, \\\"bridge/transfer-from-failed\\\");\\n\\n        uint256 fees = (_amount * transferFeePercent) / 10000;\\n        uint256 finalAmount = _amount - fees;\\n\\n        if (fees > 0) {\\n            /// @dev moves to this address (effectively burn it)\\n            MCT_TOKEN.transfer(0x000000000000000000000000000000000000dEaD, fees);\\n        }\\n\\n        ++txCounter;\\n        endpoint.send{value: msg.value}(\\n            _dstChainId,\\n            trustedRemote[_dstChainId],\\n            abi.encode(_receiver, finalAmount, txCounter),\\n            payable(msg.sender),\\n            address(0),\\n            _adapterParams\\n        );\\n        emit BridgingInitiated(LZ_CHAIN_ID, _dstChainId, txCounter, _receiver, finalAmount, fees);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              AUTH FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Updates the LayerZero endpoint contract address.\\n    /// @param _newEndpoint The new endpoint contract address.\\n    function updateEndpoint(address _newEndpoint) external onlyOwner {\\n        address oldEndpoint = address(endpoint);\\n        endpoint = ILayerZeroEndpoint(_newEndpoint);\\n\\n        emit EndpointUpdated(oldEndpoint, _newEndpoint);\\n    }\\n\\n    /// @notice Sets a trusted remote address for a destination chain.\\n    /// @param _dstChainId The destination chain's ID.\\n    /// @param _trustedRemote The trusted remote address.\\n    function setTrustedRemote(uint16 _dstChainId, bytes memory _trustedRemote) external onlyOwner {\\n        trustedRemote[_dstChainId] = _trustedRemote;\\n\\n        emit TrustedRemoteUpdated(_dstChainId, _trustedRemote);\\n    }\\n\\n    /// @notice Sets the transfer fee per transaction\\n    /// @param _transferFeePercent the transfer fee percent (eg: 100% = 10000)\\n    function setTransferFees(uint256 _transferFeePercent) external onlyOwner {\\n        uint256 oldFees = transferFeePercent;\\n        transferFeePercent = _transferFeePercent;\\n\\n        emit TransferFeeUpdated(oldFees, _transferFeePercent);\\n    }\\n\\n    /// @dev generic config for LayerZero user Application\\n    function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config)\\n        external\\n        onlyOwner\\n    {\\n        endpoint.setConfig(_version, _chainId, _configType, _config);\\n    }\\n\\n    function setSendVersion(uint16 _version) external onlyOwner {\\n        endpoint.setSendVersion(_version);\\n    }\\n\\n    function setReceiveVersion(uint16 _version) external onlyOwner {\\n        endpoint.setReceiveVersion(_version);\\n    }\\n\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external onlyOwner {\\n        endpoint.forceResumeReceive(_srcChainId, _srcAddress);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        EXTERNAL VIEW FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n    function estimateFees(address _receiver, uint256 _amount, uint16 _dstChainId, bytes memory _adapterParams)\\n        external\\n        view\\n        returns (uint256)\\n    {\\n        bytes memory message = abi.encode(_receiver, _amount, txCounter);\\n        (uint256 fees,) = endpoint.estimateFees(_dstChainId, address(this), message, false, _adapterParams);\\n        return fees;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            INTERNAL FUNCTIONS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Handles the reception of tokens on the LayerZero chain.\\n    /// @param _srcChainId The source chain's ID.\\n    /// @param _srcAddress The source address on the source chain.\\n    /// @param _nonce The nonce of the transaction.\\n    /// @param _payload The payload containing receiver, amount, and transaction ID.\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload)\\n        external\\n        onlyEndpoint\\n    {\\n        require(trustedRemote[_srcChainId].length > 0, \\\"bridge/invalid-remote-chain\\\");\\n        require(_srcAddress.length == trustedRemote[_srcChainId].length, \\\"bridge/invalid-src-sender-length\\\");\\n        require(keccak256(_srcAddress) == keccak256(trustedRemote[_srcChainId]), \\\"bridge/invalid-src-sender\\\");\\n        require(!nonceStatus[_srcAddress][_srcChainId][_nonce], \\\"bridge/invalid-nonce\\\");\\n\\n        nonceStatus[_srcAddress][_srcChainId][_nonce] = true;\\n        (address receiver, uint256 amount, uint256 srcTxId) = abi.decode(_payload, (address, uint256, uint256));\\n        MCT_TOKEN.transfer(receiver, amount);\\n\\n        emit BridgingCompleted(_srcChainId, LZ_CHAIN_ID, srcTxId, receiver, amount);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.20;\\n\\nimport {Context} from \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * The initial owner is set to the address provided by the deployer. This can\\n * later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    /**\\n     * @dev The caller account is not authorized to perform an operation.\\n     */\\n    error OwnableUnauthorizedAccount(address account);\\n\\n    /**\\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\\n     */\\n    error OwnableInvalidOwner(address owner);\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\\n     */\\n    constructor(address initialOwner) {\\n        if (initialOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(initialOwner);\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        if (owner() != _msgSender()) {\\n            revert OwnableUnauthorizedAccount(_msgSender());\\n        }\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        if (newOwner == address(0)) {\\n            revert OwnableInvalidOwner(address(0));\\n        }\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the value of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the value of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\\n     * caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 value) external returns (bool);\\n\\n    /**\\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\\n     * allowance mechanism. `value` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILayerZeroEndpoint.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.21;\\n\\ninterface ILayerZeroUserApplicationConfig {\\n    // @notice set the configuration of the LayerZero messaging library of the specified version\\n    // @param _version - messaging library version\\n    // @param _chainId - the chainId for the pending config change\\n    // @param _configType - type of configuration. every messaging library has its own convention.\\n    // @param _config - configuration in the bytes. can encode arbitrary content.\\n    function setConfig(uint16 _version, uint16 _chainId, uint256 _configType, bytes calldata _config) external;\\n\\n    // @notice set the send() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setSendVersion(uint16 _version) external;\\n\\n    // @notice set the lzReceive() LayerZero messaging library version to _version\\n    // @param _version - new messaging library version\\n    function setReceiveVersion(uint16 _version) external;\\n\\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\\n    // @param _srcChainId - the chainId of the source chain\\n    // @param _srcAddress - the contract address of the source contract at the source chain\\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\\n}\\n\\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\\n    // @param dstChainId_ - the destination chain identifier\\n    // @param destination_ - the address on destination chain (in bytes). address length/format may vary by chains\\n    // @param payload_ - a custom bytes payload to send to the destination contract\\n    // @param refundAddress_ - if the source transaction is cheaper than the amount of value passed, refund the\\n    // additional amount to this address\\n    // @param zroPaymentAddress_ - the address of the ZRO token holder who would pay for the transaction\\n    // @param adapterParams_ - parameters for custom functionality. e.g. receive airdropped native gas from the relayer\\n    // on destination\\n    function send(\\n        uint16 dstChainId_,\\n        bytes calldata destination_,\\n        bytes calldata payload_,\\n        address payable refundAddress_,\\n        address zroPaymentAddress_,\\n        bytes calldata adapterParams_\\n    ) external payable;\\n\\n    // @notice used by the messaging library to publish verified payload\\n    // @param srcChainId_ - the source chain identifier\\n    // @param srcAddress_ - the source contract (as bytes) at the source chain\\n    // @param dstAddress_ - the address on destination chain\\n    // @param nonce_ - the unbound message ordering nonce\\n    // @param gasLimit_ - the gas limit for external contract execution\\n    // @param payload_ - verified payload to send to the destination contract\\n    function receivePayload(\\n        uint16 srcChainId_,\\n        bytes calldata srcAddress_,\\n        address dstAddress_,\\n        uint64 nonce_,\\n        uint256 gasLimit_,\\n        bytes calldata payload_\\n    ) external;\\n\\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\\n    // @param srcChainId_ - the source chain identifier\\n    // @param srcAddress_ - the source chain contract address\\n    function getInboundNonce(uint16 srcChainId_, bytes calldata srcAddress_) external view returns (uint64);\\n\\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\\n    // @param srcAddress_ - the source chain contract address\\n    function getOutboundNonce(uint16 dstChainId_, address srcAddress_) external view returns (uint64);\\n\\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\\n    // @param dstChainId_ - the destination chain identifier\\n    // @param userApplication_ - the user app address on this EVM chain\\n    // @param payload_ - the custom message to send over LayerZero\\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\\n    function estimateFees(\\n        uint16 dstChainId_,\\n        address userApplication_,\\n        bytes calldata payload_,\\n        bool _payInZRO,\\n        bytes calldata _adapterParam\\n    ) external view returns (uint256 nativeFee, uint256 zroFee);\\n\\n    // @notice get this Endpoint's immutable source identifier\\n    function getChainId() external view returns (uint16);\\n\\n    // @notice the interface to retry failed message on this Endpoint destination\\n    // @param srcChainId_ - the source chain identifier\\n    // @param srcAddress_ - the source chain contract address\\n    // @param payload_ - the payload to be retried\\n    function retryPayload(uint16 srcChainId_, bytes calldata srcAddress_, bytes calldata payload_) external;\\n\\n    // @notice query if any STORED payload (message blocking) at the endpoint.\\n    // @param srcChainId_ - the source chain identifier\\n    // @param srcAddress_ - the source chain contract address\\n    function hasStoredPayload(uint16 srcChainId_, bytes calldata srcAddress_) external view returns (bool);\\n\\n    // @notice query if the _libraryAddress is valid for sending msgs.\\n    // @param userApplication_ - the user app address on this EVM chain\\n    function getSendLibraryAddress(address userApplication_) external view returns (address);\\n\\n    // @notice query if the _libraryAddress is valid for receiving msgs.\\n    // @param userApplication_ - the user app address on this EVM chain\\n    function getReceiveLibraryAddress(address userApplication_) external view returns (address);\\n\\n    // @notice query if the non-reentrancy guard for send() is on\\n    // @return true if the guard is on. false otherwise\\n    function isSendingPayload() external view returns (bool);\\n\\n    // @notice query if the non-reentrancy guard for receive() is on\\n    // @return true if the guard is on. false otherwise\\n    function isReceivingPayload() external view returns (bool);\\n\\n    // @notice get the configuration of the LayerZero messaging library of the specified version\\n    // @param version_ - messaging library version\\n    // @param chainId_ - the chainId for the pending config change\\n    // @param userApplication_ - the contract address of the user application\\n    // @param configType_ - type of configuration. every messaging library has its own convention.\\n    function getConfig(uint16 version_, uint16 chainId_, address userApplication_, uint256 configType_)\\n        external\\n        view\\n        returns (bytes memory);\\n\\n    // @notice get the send() LayerZero messaging library version\\n    // @param userApplication_ - the contract address of the user application\\n    function getSendVersion(address userApplication_) external view returns (uint16);\\n\\n    // @notice get the lzReceive() LayerZero messaging library version\\n    // @param userApplication_ - the contract address of the user application\\n    function getReceiveVersion(address userApplication_) external view returns (uint16);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/ILayerZeroReceiver.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: UNLICENSED\\npragma solidity 0.8.21;\\n\\n/// @dev is imported from\\n/// (https://github.com/LayerZero-Labs/LayerZero/blob/main/contracts/interfaces/ILayerZeroReceiver.sol)\\ninterface ILayerZeroReceiver {\\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\\n    // @param _srcChainId - the source endpoint identifier\\n    // @param _srcAddress - the source sending contract address from the source chain\\n    // @param _nonce - the ordered message nonce\\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\\n    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload)\\n        external;\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Context.sol)\\n\\npragma solidity ^0.8.20;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"ds-test/=lib/forge-std/lib/ds-test/src/\",\r\n      \"erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/\",\r\n      \"pigeon/=lib/pigeon/src/\",\r\n      \"solady/=lib/pigeon/lib/solady/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"useLiteralContent\": false,\r\n      \"bytecodeHash\": \"ipfs\",\r\n      \"appendCBOR\": true\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"paris\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcTxIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgingCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"srcChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcTxIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fees\",\"type\":\"uint256\"}],\"name\":\"BridgingInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldEndpoint\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newEndpoint\",\"type\":\"address\"}],\"name\":\"EndpointUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"oldFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newFees\",\"type\":\"uint256\"}],\"name\":\"TransferFeeUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint16\",\"name\":\"dstChainId\",\"type\":\"uint16\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"trustedRemote\",\"type\":\"bytes\"}],\"name\":\"TrustedRemoteUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"LZ_CHAIN_ID\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"MCT_TOKEN\",\"outputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"endpoint\",\"outputs\":[{\"internalType\":\"contract ILayerZeroEndpoint\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"estimateFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"}],\"name\":\"forceResumeReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_srcChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"uint64\",\"name\":\"_nonce\",\"type\":\"uint64\"},{\"internalType\":\"bytes\",\"name\":\"_payload\",\"type\":\"bytes\"}],\"name\":\"lzReceive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"nonceStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"},{\"internalType\":\"uint16\",\"name\":\"_chainId\",\"type\":\"uint16\"},{\"internalType\":\"uint256\",\"name\":\"_configType\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_config\",\"type\":\"bytes\"}],\"name\":\"setConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setReceiveVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_version\",\"type\":\"uint16\"}],\"name\":\"setSendVersion\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_transferFeePercent\",\"type\":\"uint256\"}],\"name\":\"setTransferFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_trustedRemote\",\"type\":\"bytes\"}],\"name\":\"setTrustedRemote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"transferFeePercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"trustedRemote\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"txCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newEndpoint\",\"type\":\"address\"}],\"name\":\"updateEndpoint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_receiver\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"uint16\",\"name\":\"_dstChainId\",\"type\":\"uint16\"},{\"internalType\":\"bytes\",\"name\":\"_adapterParams\",\"type\":\"bytes\"}],\"name\":\"xChainTransfer\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}]", "ContractName": "PolygonBridge", "CompilerVersion": "v0.8.21+commit.d9974bed", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}